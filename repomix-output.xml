<repomix><file_summary>This file is a merged representation of the entire codebase, combined into a single document by Repomix.
The content has been processed where empty lines have been removed, content has been formatted for parsing in xml style, security check has been disabled.<purpose>This file contains a packed representation of the entire repository&apos;s contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.</purpose><file_format>The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Repository files, each consisting of:
  - File path as an attribute
  - Full contents of the file</file_format><usage_guidelines>- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.</usage_guidelines><notes>- Some files may have been excluded based on .gitignore rules and Repomix&apos;s configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Empty lines have been removed from all files
- Content has been formatted for parsing in xml style
- Security check has been disabled - content may contain sensitive information
- Files are sorted by Git change count (files with more changes are at the bottom)</notes></file_summary><directory_structure>.dockerignore
.env.dev.example
.env.example
.gitattributes
.gitignore
.junie/guideliens.md
.repomixignore
app/Actions/Fortify/CreateNewUser.php
app/Actions/Fortify/PasswordValidationRules.php
app/Actions/Fortify/ResetUserPassword.php
app/Actions/Fortify/UpdateUserPassword.php
app/Actions/Fortify/UpdateUserProfileInformation.php
app/Actions/Tokens/PruneExpiredTokens.php
app/Auth/AclFactory.php
app/Auth/Role.php
app/Auth/TokenName.php
app/Baander.php
app/Console/Commands/Auth/ManageSanctumTokens.php
app/Console/Commands/Auth/PruneExpiredTokensCommand.php
app/Console/Commands/DeployFreshCommand.php
app/Console/Commands/Filter/CreateFilterCommand.php
app/Console/Commands/GenerateMbModels.php
app/Console/Commands/ID3TestCommand.php
app/Console/Commands/Insights/PruneInsightRecordsCommand.php
app/Console/Commands/Music/SyncSmartPlaylists.php
app/Console/Commands/Octane/ProdStartSwooleCommand.php
app/Console/Commands/PruneLibrariesCommand.php
app/Console/Commands/QueueMonitor/Concerns/HandlesDateInputs.php
app/Console/Commands/QueueMonitor/MarkJobsAsStaleCommand.php
app/Console/Commands/QueueMonitor/PurgeOldMonitorsCommand.php
app/Console/Commands/Recommendations/GenerateRecommendations.php
app/Console/Commands/Recommendations/SynchronizeRecommendationsCommand.php
app/Console/Commands/ScanLibraryCommand.php
app/Console/Commands/SetupDevCommand.php
app/Console/Commands/SetupEnvironmentCommand.php
app/Console/Commands/SyncMetadataCommand.php
app/Console/Commands/TranscoderStartCommand.php
app/Console/Commands/UserCreateCommand.php
app/Console/Kernel.php
app/Events/Auth/PasskeyUsedToAuthenticateEvent.php
app/Events/ChannelName.php
app/Events/LibraryScanCompleted.php
app/Exceptions/Handler.php
app/Exceptions/ImageNotFoundException.php
app/Exceptions/InsightException.php
app/Exceptions/Jobs/Manager/CouldNotFindJobException.php
app/Extensions/ArrExt.php
app/Extensions/EnumExt.php
app/Extensions/GeneratorCollection.php
app/Extensions/Logger/StdOutLogger.php
app/Extensions/StrExt.php
app/Http/Concerns/Filterable.php
app/Http/Controllers/Api/AlbumController.php
app/Http/Controllers/Api/ArtistController.php
app/Http/Controllers/Api/Auth/AuthController.php
app/Http/Controllers/Api/Auth/Concerns/HandlesUserTokens.php
app/Http/Controllers/Api/GenreController.php
app/Http/Controllers/Api/ImageController.php
app/Http/Controllers/Api/JobController.php
app/Http/Controllers/Api/LibraryController.php
app/Http/Controllers/Api/MovieController.php
app/Http/Controllers/Api/OpCacheController.php
app/Http/Controllers/Api/PlaylistController.php
app/Http/Controllers/Api/QueueController.php
app/Http/Controllers/Api/SchemaController.php
app/Http/Controllers/Api/SongController.php
app/Http/Controllers/Api/StreamController.php
app/Http/Controllers/Api/SystemInfoController.php
app/Http/Controllers/Api/UserController.php
app/Http/Controllers/Api/UserTokenController.php
app/Http/Controllers/Controller.php
app/Http/Controllers/UIController.php
app/Http/Controllers/Web/PasskeyController.php
app/Http/Integrations/CoverArtArchive/CoverArtArchiveClient.php
app/Http/Integrations/CoverArtArchive/Models/CoverArtImage.php
app/Http/Integrations/CoverArtArchive/Models/CoverArtResponse.php
app/Http/Integrations/CoverArtArchive/Models/CoverArtThumbnails.php
app/Http/Integrations/Discogs/DiscogsClient.php
app/Http/Integrations/Discogs/Filters/ArtistFilter.php
app/Http/Integrations/Discogs/Filters/BaseFilter.php
app/Http/Integrations/Discogs/Filters/LabelFilter.php
app/Http/Integrations/Discogs/Filters/MasterFilter.php
app/Http/Integrations/Discogs/Filters/ReleaseFilter.php
app/Http/Integrations/Discogs/Handler.php
app/Http/Integrations/Discogs/Handlers/LookupHandler.php
app/Http/Integrations/Discogs/Handlers/SearchHandler.php
app/Http/Integrations/Discogs/Models/Artist.php
app/Http/Integrations/Discogs/Models/Label.php
app/Http/Integrations/Discogs/Models/Master.php
app/Http/Integrations/Discogs/Models/Model.php
app/Http/Integrations/Discogs/Models/Release.php
app/Http/Integrations/MusicBrainz/Filters/AreaFilter.php
app/Http/Integrations/MusicBrainz/Filters/ArtistFilter.php
app/Http/Integrations/MusicBrainz/Filters/BaseFilter.php
app/Http/Integrations/MusicBrainz/Filters/EventFilter.php
app/Http/Integrations/MusicBrainz/Filters/GenreFilter.php
app/Http/Integrations/MusicBrainz/Filters/InstrumentFilter.php
app/Http/Integrations/MusicBrainz/Filters/LabelFilter.php
app/Http/Integrations/MusicBrainz/Filters/PlaceFilter.php
app/Http/Integrations/MusicBrainz/Filters/RecordingFilter.php
app/Http/Integrations/MusicBrainz/Filters/ReleaseFilter.php
app/Http/Integrations/MusicBrainz/Filters/SeriesFilter.php
app/Http/Integrations/MusicBrainz/Filters/UrlFilter.php
app/Http/Integrations/MusicBrainz/Filters/WorkFilter.php
app/Http/Integrations/MusicBrainz/Handler.php
app/Http/Integrations/MusicBrainz/Handlers/LookupHandler.php
app/Http/Integrations/MusicBrainz/Handlers/SearchHandler.php
app/Http/Integrations/MusicBrainz/Models/Alias.php
app/Http/Integrations/MusicBrainz/Models/AliasList.php
app/Http/Integrations/MusicBrainz/Models/Annotation.php
app/Http/Integrations/MusicBrainz/Models/AnnotationList.php
app/Http/Integrations/MusicBrainz/Models/Area.php
app/Http/Integrations/MusicBrainz/Models/AreaElementInner.php
app/Http/Integrations/MusicBrainz/Models/AreaList.php
app/Http/Integrations/MusicBrainz/Models/Artist.php
app/Http/Integrations/MusicBrainz/Models/ArtistCredit.php
app/Http/Integrations/MusicBrainz/Models/ArtistList.php
app/Http/Integrations/MusicBrainz/Models/AttributeList.php
app/Http/Integrations/MusicBrainz/Models/Cancelled.php
app/Http/Integrations/MusicBrainz/Models/Cdstub.php
app/Http/Integrations/MusicBrainz/Models/CdstubList.php
app/Http/Integrations/MusicBrainz/Models/Collection.php
app/Http/Integrations/MusicBrainz/Models/CollectionList.php
app/Http/Integrations/MusicBrainz/Models/CoverArtArchive.php
app/Http/Integrations/MusicBrainz/Models/DataTrackList.php
app/Http/Integrations/MusicBrainz/Models/Disc.php
app/Http/Integrations/MusicBrainz/Models/DiscList.php
app/Http/Integrations/MusicBrainz/Models/Editor.php
app/Http/Integrations/MusicBrainz/Models/EditorList.php
app/Http/Integrations/MusicBrainz/Models/Ended.php
app/Http/Integrations/MusicBrainz/Models/EntityList.php
app/Http/Integrations/MusicBrainz/Models/Event.php
app/Http/Integrations/MusicBrainz/Models/EventList.php
app/Http/Integrations/MusicBrainz/Models/FreedbDisc.php
app/Http/Integrations/MusicBrainz/Models/FreedbDiscList.php
app/Http/Integrations/MusicBrainz/Models/Genre.php
app/Http/Integrations/MusicBrainz/Models/GenreList.php
app/Http/Integrations/MusicBrainz/Models/Instrument.php
app/Http/Integrations/MusicBrainz/Models/InstrumentList.php
app/Http/Integrations/MusicBrainz/Models/IpiList.php
app/Http/Integrations/MusicBrainz/Models/IsniList.php
app/Http/Integrations/MusicBrainz/Models/Iso31661CodeList.php
app/Http/Integrations/MusicBrainz/Models/Iso31662CodeList.php
app/Http/Integrations/MusicBrainz/Models/Iso31663CodeList.php
app/Http/Integrations/MusicBrainz/Models/Isrc.php
app/Http/Integrations/MusicBrainz/Models/IsrcList.php
app/Http/Integrations/MusicBrainz/Models/Iswc.php
app/Http/Integrations/MusicBrainz/Models/IswcList.php
app/Http/Integrations/MusicBrainz/Models/Label.php
app/Http/Integrations/MusicBrainz/Models/LabelInfo.php
app/Http/Integrations/MusicBrainz/Models/LabelInfoList.php
app/Http/Integrations/MusicBrainz/Models/LabelList.php
app/Http/Integrations/MusicBrainz/Models/LanguageList.php
app/Http/Integrations/MusicBrainz/Models/ListAttributes.php
app/Http/Integrations/MusicBrainz/Models/Medium.php
app/Http/Integrations/MusicBrainz/Models/MediumList.php
app/Http/Integrations/MusicBrainz/Models/Metadata.php
app/Http/Integrations/MusicBrainz/Models/NonmbTrack.php
app/Http/Integrations/MusicBrainz/Models/NonmbTrackList.php
app/Http/Integrations/MusicBrainz/Models/OffsetList.php
app/Http/Integrations/MusicBrainz/Models/Place.php
app/Http/Integrations/MusicBrainz/Models/PlaceList.php
app/Http/Integrations/MusicBrainz/Models/PregapTrack.php
app/Http/Integrations/MusicBrainz/Models/Puid.php
app/Http/Integrations/MusicBrainz/Models/PuidList.php
app/Http/Integrations/MusicBrainz/Models/Rating.php
app/Http/Integrations/MusicBrainz/Models/Recording.php
app/Http/Integrations/MusicBrainz/Models/RecordingList.php
app/Http/Integrations/MusicBrainz/Models/Relation.php
app/Http/Integrations/MusicBrainz/Models/RelationList.php
app/Http/Integrations/MusicBrainz/Models/Release.php
app/Http/Integrations/MusicBrainz/Models/ReleaseEvent.php
app/Http/Integrations/MusicBrainz/Models/ReleaseEventList.php
app/Http/Integrations/MusicBrainz/Models/ReleaseGroup.php
app/Http/Integrations/MusicBrainz/Models/ReleaseGroupList.php
app/Http/Integrations/MusicBrainz/Models/ReleaseList.php
app/Http/Integrations/MusicBrainz/Models/Series.php
app/Http/Integrations/MusicBrainz/Models/SeriesList.php
app/Http/Integrations/MusicBrainz/Models/Tag.php
app/Http/Integrations/MusicBrainz/Models/TagList.php
app/Http/Integrations/MusicBrainz/Models/Track.php
app/Http/Integrations/MusicBrainz/Models/TrackData.php
app/Http/Integrations/MusicBrainz/Models/TrackList.php
app/Http/Integrations/MusicBrainz/Models/Url.php
app/Http/Integrations/MusicBrainz/Models/UrlList.php
app/Http/Integrations/MusicBrainz/Models/UserGenre.php
app/Http/Integrations/MusicBrainz/Models/UserGenreList.php
app/Http/Integrations/MusicBrainz/Models/UserRating.php
app/Http/Integrations/MusicBrainz/Models/UserTag.php
app/Http/Integrations/MusicBrainz/Models/UserTagList.php
app/Http/Integrations/MusicBrainz/Models/Video.php
app/Http/Integrations/MusicBrainz/Models/Work.php
app/Http/Integrations/MusicBrainz/Models/WorkAttributeList.php
app/Http/Integrations/MusicBrainz/Models/WorkList.php
app/Http/Integrations/MusicBrainz/MusicBrainzClient.php
app/Http/Integrations/MusicBrainz/Subqueries/ArtistAliasHandler.php
app/Http/Integrations/TasteDive/Handler.php
app/Http/Integrations/TasteDive/Handlers/MovieHandler.php
app/Http/Integrations/TasteDive/TasteDiveClient.php
app/Http/Integrations/Transcoder/TranscoderClient.php
app/Http/Kernel.php
app/Http/Middleware/AddContentSecurityPolicyHeaders.php
app/Http/Middleware/Authenticate.php
app/Http/Middleware/ConvertQueryTokenToHeaderMiddleware.php
app/Http/Middleware/EncryptCookies.php
app/Http/Middleware/ForceJsonResponse.php
app/Http/Middleware/PreventRequestsDuringMaintenance.php
app/Http/Middleware/RedirectIfAuthenticated.php
app/Http/Middleware/SecurityHeadersMiddleware.php
app/Http/Middleware/TrimStrings.php
app/Http/Middleware/TrustHosts.php
app/Http/Middleware/TrustProxies.php
app/Http/Middleware/ValidateSignature.php
app/Http/Middleware/VerifyCsrfToken.php
app/Http/Requests/Album/AlbumIndexRequest.php
app/Http/Requests/Artist/ArtistIndexRequest.php
app/Http/Requests/Auth/AuthenticateUsingPasskeyRequest.php
app/Http/Requests/Auth/ForgotPasswordRequest.php
app/Http/Requests/Auth/LoginRequest.php
app/Http/Requests/Auth/LogoutRequest.php
app/Http/Requests/Auth/RegisterRequest.php
app/Http/Requests/Auth/ResetPasswordRequest.php
app/Http/Requests/Auth/StorePasskeyRequest.php
app/Http/Requests/Genre/GenreIndexRequest.php
app/Http/Requests/Genre/UpdateGenreRequest.php
app/Http/Requests/Library/CreateLibraryRequest.php
app/Http/Requests/Library/LibraryIndexRequest.php
app/Http/Requests/Library/UpdateLibraryRequest.php
app/Http/Requests/Logs/GetLogContentRequest.php
app/Http/Requests/Playlist/CreatePlaylistRequest.php
app/Http/Requests/Playlist/CreateSmartPlaylistRequest.php
app/Http/Requests/Playlist/PlaylistShowRequest.php
app/Http/Requests/Playlist/UpdatePlaylistRequest.php
app/Http/Requests/Playlist/UpdateSmartPlaylistRulesRequest.php
app/Http/Requests/QueueMetrics/MetricsRequest.php
app/Http/Requests/QueueMetrics/ShowQueueMetricsRequest.php
app/Http/Requests/QueueMonitor/RetryJobRequest.php
app/Http/Requests/Song/SongIndexRequest.php
app/Http/Requests/Song/SongShowRequest.php
app/Http/Requests/Stream/StartStreamRequest.php
app/Http/Requests/User/CreateUserRequest.php
app/Http/Requests/User/UpdateUserRequest.php
app/Http/Requests/User/UserIndexRequest.php
app/Http/Requests/UserToken/RevokeTokenRequest.php
app/Http/Requests/UserToken/UserTokenIndexRequest.php
app/Http/Resources/Album/AlbumResource.php
app/Http/Resources/Album/AlbumWithoutSongsResource.php
app/Http/Resources/Artist/ArtistResource.php
app/Http/Resources/Auth/NewAccessTokenResource.php
app/Http/Resources/Auth/PersonalAccessTokenResource.php
app/Http/Resources/Genre/GenreResource.php
app/Http/Resources/HasJsonCollection.php
app/Http/Resources/Image/ImageResource.php
app/Http/Resources/Library/LibraryResource.php
app/Http/Resources/Movie/MovieResource.php
app/Http/Resources/Playlist/PlaylistResource.php
app/Http/Resources/PlaylistStatistic/PlaylistStatisticResource.php
app/Http/Resources/QueueMonitor/QueueMonitorResource.php
app/Http/Resources/Song/SongResource.php
app/Http/Resources/User/UserResource.php
app/Http/Resources/UserToken/PersonalAccessTokenViewResource.php
app/Http/Resources/Video/VideoResource.php
app/Jobs/Auth/RevokeTokenJob.php
app/Jobs/BaseJob.php
app/Jobs/Concerns/HasJobsLogger.php
app/Jobs/Library/Metadata/ProbeQueueChecker.php
app/Jobs/Library/MetaDataMusicBrainzAlbumJob.php
app/Jobs/Library/Music/SaveAlbumCoverJob.php
app/Jobs/Library/Music/ScanDirectoryJob.php
app/Jobs/Library/Music/ScanMusicLibraryJob.php
app/Jobs/Library/Music/SyncAlbumMetadataJob.php
app/Jobs/Library/Music/SyncArtistMetadataJob.php
app/Jobs/Library/Music/SyncSmartPlaylists.php
app/Jobs/Library/Music/SyncSongMetadataJob.php
app/Jobs/Middleware/ResourceMonitor.php
app/Jobs/Movies/ScanMovieLibraryJob.php
app/Jobs/Recommendation/GenerateRecommendationsJob.php
app/Listeners/Auth/LogoutInvalidateTokenCache.php
app/Mail/MailbookMail.php
app/Models/Album.php
app/Models/AlbumArtist.php
app/Models/Artist.php
app/Models/ArtistSong.php
app/Models/BaseModel.php
app/Models/BasePivot.php
app/Models/Concerns/HasLibraryAccess.php
app/Models/Concerns/IsBaseModel.php
app/Models/Genre.php
app/Models/GenreSong.php
app/Models/Image.php
app/Models/Library.php
app/Models/LibraryType.php
app/Models/Movie.php
app/Models/MovieVideo.php
app/Models/Passkey.php
app/Models/PersonalAccessToken.php
app/Models/Playlist.php
app/Models/PlaylistCollaborator.php
app/Models/PlaylistSong.php
app/Models/PlaylistStatistic.php
app/Models/Queries/Trend/Trend.php
app/Models/Queries/Trend/TrendValue.php
app/Models/QueueMonitor.php
app/Models/Recommendation.php
app/Models/Song.php
app/Models/TokenAbility.php
app/Models/TranscodingSession.php
app/Models/User.php
app/Models/UserLibrary.php
app/Models/UserMediaActivity.php
app/Models/Version.php
app/Models/Video.php
app/Modules/Apm/Apm.php
app/Modules/Apm/Collectors/SwooleMetricsCollector.php
app/Modules/Apm/ElasticApmAgentServiceProvider.php
app/Modules/Apm/Listeners/AuthenticationListener.php
app/Modules/Apm/Listeners/CacheEventListener.php
app/Modules/Apm/Listeners/DatabaseQueryListener.php
app/Modules/Apm/Listeners/DefaultTerminatedHandler.php
app/Modules/Apm/Listeners/HttpClientListener.php
app/Modules/Apm/Listeners/QueueListener.php
app/Modules/Apm/Listeners/RedisListener.php
app/Modules/Apm/Listeners/RequestReceivedHandler.php
app/Modules/Apm/Listeners/RequestWorkerStartHandler.php
app/Modules/Apm/Listeners/TaskReceivedHandler.php
app/Modules/Apm/Listeners/TickReceivedHandler.php
app/Modules/Apm/Middleware/ApmMiddleware.php
app/Modules/Apm/Middleware/SwooleMetricsSampler.php
app/Modules/Apm/OctaneApmManager.php
app/Modules/Apm/Services/SwooleMetricsService.php
app/Modules/Apm/Spans/AbstractSpan.php
app/Modules/Apm/Spans/QuerySpan.php
app/Modules/Blade/directives.php
app/Modules/BlurHash/Base83.php
app/Modules/BlurHash/BlurHash.php
app/Modules/BlurHash/BlurHashServiceProvider.php
app/Modules/BlurHash/Drivers/Driver.php
app/Modules/BlurHash/Drivers/GdDriver.php
app/Modules/BlurHash/Drivers/ImagickDriver.php
app/Modules/BlurHash/Exceptions/BlurHashException.php
app/Modules/BlurHash/Exceptions/DriverNotFoundException.php
app/Modules/BlurHash/Exceptions/UnableToConvertColorException.php
app/Modules/BlurHash/Exceptions/UnableToCreateImageException.php
app/Modules/BlurHash/Exceptions/UnableToGetColorException.php
app/Modules/BlurHash/Exceptions/UnableToReadFileException.php
app/Modules/BlurHash/Exceptions/UnableToSetPixelException.php
app/Modules/BlurHash/Exceptions/UnsupportedFileException.php
app/Modules/BlurHash/Facades/BlurHash.php
app/Modules/DeviceDetector/CacheRepository.php
app/Modules/DeviceDetector/Device.php
app/Modules/DeviceDetector/DeviceDetector.php
app/Modules/DeviceDetector/DeviceDetectorServiceProvider.php
app/Modules/Eloquent/BaseBuilder.php
app/Modules/FFmpeg/Drivers/InteractsWithFilters.php
app/Modules/FFmpeg/Drivers/InteractsWithMediaStreams.php
app/Modules/FFmpeg/Drivers/PHPFFMpeg.php
app/Modules/FFmpeg/Drivers/UnknownDurationException.php
app/Modules/FFmpeg/Exporters/EncodingException.php
app/Modules/FFmpeg/Exporters/EncryptsHLSSegments.php
app/Modules/FFmpeg/Exporters/HandlesAdvancedMedia.php
app/Modules/FFmpeg/Exporters/HandlesConcatenation.php
app/Modules/FFmpeg/Exporters/HandlesFrames.php
app/Modules/FFmpeg/Exporters/HandlesTimelapse.php
app/Modules/FFmpeg/Exporters/HasProgressListener.php
app/Modules/FFmpeg/Exporters/HLSExporter.php
app/Modules/FFmpeg/Exporters/HLSPlaylistGenerator.php
app/Modules/FFmpeg/Exporters/HLSVideoFilters.php
app/Modules/FFmpeg/Exporters/MediaExporter.php
app/Modules/FFmpeg/Exporters/NoFormatException.php
app/Modules/FFmpeg/Exporters/PlaylistGenerator.php
app/Modules/FFmpeg/Exporters/VTTPreviewThumbnailsGenerator.php
app/Modules/FFmpeg/FFMpeg/AdvancedMedia.php
app/Modules/FFmpeg/FFMpeg/AdvancedOutputMapping.php
app/Modules/FFmpeg/FFMpeg/AudioMedia.php
app/Modules/FFmpeg/FFMpeg/CopyFormat.php
app/Modules/FFmpeg/FFMpeg/CopyVideoFormat.php
app/Modules/FFmpeg/FFMpeg/FFProbe.php
app/Modules/FFmpeg/FFMpeg/ImageFormat.php
app/Modules/FFmpeg/FFMpeg/InteractsWithBeforeSavingCallbacks.php
app/Modules/FFmpeg/FFMpeg/InteractsWithHttpHeaders.php
app/Modules/FFmpeg/FFMpeg/InteractsWithInputPath.php
app/Modules/FFmpeg/FFMpeg/LegacyFilterMapping.php
app/Modules/FFmpeg/FFMpeg/NullFormat.php
app/Modules/FFmpeg/FFMpeg/ProgressListenerDecorator.php
app/Modules/FFmpeg/FFMpeg/RebuildsCommands.php
app/Modules/FFmpeg/FFMpeg/StdListener.php
app/Modules/FFmpeg/FFMpeg/VideoMedia.php
app/Modules/FFmpeg/FFMpeg/VideoProgressListenerDecorator.php
app/Modules/FFmpeg/Filesystem/Disk.php
app/Modules/FFmpeg/Filesystem/HasInputOptions.php
app/Modules/FFmpeg/Filesystem/Media.php
app/Modules/FFmpeg/Filesystem/MediaCollection.php
app/Modules/FFmpeg/Filesystem/MediaOnNetwork.php
app/Modules/FFmpeg/Filesystem/TemporaryDirectories.php
app/Modules/FFmpeg/Filters/TileFactory.php
app/Modules/FFmpeg/Filters/TileFilter.php
app/Modules/FFmpeg/Filters/WatermarkFactory.php
app/Modules/FFmpeg/Filters/WatermarkFilter.php
app/Modules/FFmpeg/Http/DynamicHLSPlaylist.php
app/Modules/FFmpeg/MediaOpener.php
app/Modules/FFmpeg/Support/Container.php
app/Modules/FFmpeg/Support/FFMpeg.php
app/Modules/FFmpeg/Support/MediaOpenerFactory.php
app/Modules/FFmpeg/Support/ProcessOutput.php
app/Modules/FFmpeg/Support/StreamParser.php
app/Modules/Filesystem/Exceptions/UnreadablePathException.php
app/Modules/Filesystem/MimeExtension.php
app/Modules/Filesystem/Path.php
app/Modules/Http/Concerns/DirectStreamableFile.php
app/Modules/Http/Resources/Json/JsonAnonymousResourceCollection.php
app/Modules/Http/Resources/Json/JsonPaginatedResourceResponse.php
app/Modules/Humanize/bytes.php
app/Modules/Humanize/HumanDuration.php
app/Modules/LogStreamer/LogFileService.php
app/Modules/LogStreamer/SearchableLogFile.php
app/Modules/Lyrics/Lrc.php
app/Modules/MediaMeta/Encoding.php
app/Modules/MediaMeta/Frame/Apic.php
app/Modules/MediaMeta/Frame/COMM.php
app/Modules/MediaMeta/Frame/EQUA.php
app/Modules/MediaMeta/Frame/ETCO.php
app/Modules/MediaMeta/Frame/Frame.php
app/Modules/MediaMeta/Frame/IPLS.php
app/Modules/MediaMeta/Frame/LINK.php
app/Modules/MediaMeta/Frame/MCDI.php
app/Modules/MediaMeta/Frame/MVIN.php
app/Modules/MediaMeta/Frame/OWNE.php
app/Modules/MediaMeta/Frame/POPM.php
app/Modules/MediaMeta/Frame/SYLT.php
app/Modules/MediaMeta/Frame/TALB.php
app/Modules/MediaMeta/Frame/TCOM.php
app/Modules/MediaMeta/Frame/TCON.php
app/Modules/MediaMeta/Frame/TDAT.php
app/Modules/MediaMeta/Frame/TEXT.php
app/Modules/MediaMeta/Frame/TextFrame.php
app/Modules/MediaMeta/Frame/TIT2.php
app/Modules/MediaMeta/Frame/TLAN.php
app/Modules/MediaMeta/Frame/TLEN.php
app/Modules/MediaMeta/Frame/TORY.php
app/Modules/MediaMeta/Frame/TPE1.php
app/Modules/MediaMeta/Frame/TPE2.php
app/Modules/MediaMeta/Frame/TPE3.php
app/Modules/MediaMeta/Frame/TPE4.php
app/Modules/MediaMeta/Frame/TPUB.php
app/Modules/MediaMeta/Frame/TRCK.php
app/Modules/MediaMeta/Frame/TSRC.php
app/Modules/MediaMeta/Frame/TYER.php
app/Modules/MediaMeta/Frame/USLT.php
app/Modules/MediaMeta/Id3v1.php
app/Modules/MediaMeta/Id3v2.php
app/Modules/MediaMeta/MediaMeta.php
app/Modules/MediaMeta/MediaMetaTest.php
app/Modules/MediaMeta/README.md
app/Modules/Nanoid/Concerns/HasNanoPublicId.php
app/Modules/Nanoid/NanoId.php
app/Modules/Nanoid/NanoIdService.php
app/Modules/Nanoid/NanoIdServiceProvider.php
app/Modules/OpenApi/Concerns/CastsDtoToSchema.php
app/Modules/OpenApi/JsonPaginatorExtension.php
app/Modules/OpenApi/LaravelDataRequestExtension.php
app/Modules/OpenApi/LaravelDataToSchema.php
app/Modules/Pagination/JsonPaginator.php
app/Modules/PhpInfoParser/Collections/Items.php
app/Modules/PhpInfoParser/Collections/Lines.php
app/Modules/PhpInfoParser/Concerns/ConfigAliases.php
app/Modules/PhpInfoParser/Info.php
app/Modules/PhpInfoParser/Models/Config.php
app/Modules/PhpInfoParser/Models/Group.php
app/Modules/PhpInfoParser/Models/Module.php
app/Modules/PhpInfoParser/Parsers/HtmlParser.php
app/Modules/PhpInfoParser/Parsers/TextParser.php
app/Modules/PhpInfoParser/Result.php
app/Modules/QueueMonitor/Concerns/IsMonitored.php
app/Modules/QueueMonitor/Contracts/MonitoredJobContract.php
app/Modules/QueueMonitor/MonitorStatus.php
app/Modules/Recommendation/Algorithms/CosineSimilarity.php
app/Modules/Recommendation/Algorithms/EuclideanDistance.php
app/Modules/Recommendation/Algorithms/HammingDistance.php
app/Modules/Recommendation/Algorithms/JaccardIndex.php
app/Modules/Recommendation/Algorithms/MinMaxNorm.php
app/Modules/Recommendation/Algorithms/TfIdf.php
app/Modules/Recommendation/Calculators/ContentBasedCalculator.php
app/Modules/Recommendation/Calculators/DatabaseRelationCalculator.php
app/Modules/Recommendation/Calculators/SimilarityCalculator.php
app/Modules/Recommendation/Concerns/Recommendable.php
app/Modules/Recommendation/Contracts/AlgorithmInterface.php
app/Modules/Recommendation/Contracts/CalculatorInterface.php
app/Modules/Recommendation/HasRecommendation.php
app/Modules/Recommendation/Services/RecommendationService.php
app/Modules/Transcoder/TranscoderConfig.php
app/Modules/Transcoder/TranscoderContextFactory.php
app/Modules/Translation/LocaleString.php
app/Modules/Webauthn/Actions/FindPasskeyToAuthenticateAction.php
app/Modules/Webauthn/Actions/GeneratePasskeyAuthenticationOptionsAction.php
app/Modules/Webauthn/Actions/GeneratePasskeyRegisterOptionsAction.php
app/Modules/Webauthn/Actions/StorePasskeyAction.php
app/Modules/Webauthn/Concerns/HasPasskeys.php
app/Modules/Webauthn/CounterChecker.php
app/Modules/Webauthn/Exceptions/CurrentCountExceededSource.php
app/Modules/Webauthn/Exceptions/InvalidPasskey.php
app/Modules/Webauthn/Exceptions/InvalidPasskeyOptions.php
app/Modules/Webauthn/Models/PublicKeyCredentialCreationOptionsData.php
app/Modules/Webauthn/PasskeyService.php
app/Modules/Webauthn/WebauthnService.php
app/Notifications/ForgotPasswordNotification.php
app/Notifications/VerifyEmail.php
app/Observers/ImageObserver.php
app/Observers/VideoObserver.php
app/Octane/EmergencyWorker.php
app/Octane/OnWorkerStart.php
app/Policies/AlbumPolicy.php
app/Policies/PlaylistPolicy.php
app/Policies/SongPolicy.php
app/Providers/AppServiceProvider.php
app/Providers/AuthorizationGateServiceProvider.php
app/Providers/AuthServiceProvider.php
app/Providers/BroadcastServiceProvider.php
app/Providers/EventServiceProvider.php
app/Providers/FortifyServiceProvider.php
app/Providers/HorizonServiceProvider.php
app/Providers/IntegrationsServiceProvider.php
app/Providers/LogConfigurationServiceProvider.php
app/Providers/QueueMonitorProvider.php
app/Providers/RecommendationServiceProvider.php
app/Providers/RouteServiceProvider.php
app/Providers/ScrambleServiceProvider.php
app/Providers/StreamServiceProvider.php
app/Repositories/Cache/CacheRepositoryInterface.php
app/Repositories/Cache/LaravelCacheRepository.php
app/Services/AuthTokenService.php
app/Services/DownloadService.php
app/Services/GuzzleService.php
app/Services/Metadata/LocalMetadataService.php
app/Services/Metadata/MetadataSyncService.php
app/Services/Metadata/Processing/MetadataProcessor.php
app/Services/Metadata/Search/AlbumSearchService.php
app/Services/Metadata/Search/ArtistSearchService.php
app/Services/Metadata/Search/SongSearchService.php
app/Services/MetadataMatching/MatchingStrategy.php
app/Services/MetadataMatching/QualityValidator.php
app/Services/MetadataSearch/AlbumSearchService.php
app/Services/MetadataSearch/ArtistSearchService.php
app/Services/MetadataSearch/SongSearchService.php
app/Services/OpCacheService.php
app/Services/QueueMetrics/Models/QueueMetric.php
app/Services/QueueMetrics/QueueMetricsService.php
app/Services/QueueMonitorService.php
app/Services/SmartPlaylistService.php
app/Services/Streaming/Handlers/DASHStreamService.php
app/Services/Streaming/Handlers/HLSStreamService.php
app/Services/Streaming/StreamService.php
app/Services/Streaming/StreamServiceInterface.php
app/Services/SystemInfoService.php
app/Services/SystemMetricsCollectorService.php
app/Services/SystemMonitor.php
app/Services/TranscoderService.php
artisan
bin/dev_refresh.sh
bin/lint.php
bootstrap/app.php
bootstrap/cache/.gitignore
composer.json
config/apm.php
config/app.php
config/auth.php
config/blurhash.php
config/broadcasting.php
config/cache.php
config/cors.php
config/database.php
config/eloquent-filtering.php
config/ffmpeg.php
config/filesystems.php
config/fortify.php
config/hashing.php
config/horizon.php
config/image.php
config/log-viewer.php
config/logging.php
config/mail.php
config/octane.php
config/opcache.php
config/passport.php
config/permission.php
config/queue.php
config/recommendation.php
config/route-attributes.php
config/sanctum.php
config/scanner.php
config/schema-rules.php
config/scramble.php
config/services.php
config/session.php
config/transcoder.php
config/versionable.php
config/view.php
config/webauthn.php
config/ziggy.php
database/.gitignore
database/factories/AlbumArtistFactory.php
database/factories/AlbumFactory.php
database/factories/ArtistFactory.php
database/factories/GenreFactory.php
database/factories/GenreSongFactory.php
database/factories/ImageFactory.php
database/factories/LibraryFactory.php
database/factories/MovieFactory.php
database/factories/MovieVideoFactory.php
database/factories/PasskeyFactory.php
database/factories/Player/PlayerStateFactory.php
database/factories/PlaylistFactory.php
database/factories/PlaylistSongFactory.php
database/factories/PlaylistStatisticFactory.php
database/factories/SongFactory.php
database/factories/TranscodingSessionFactory.php
database/factories/UserFactory.php
database/factories/UserLibraryFactory.php
database/factories/UserMediaActivityFactory.php
database/factories/UserTwoFactorAuthenticationFactory.php
database/factories/VideoFactory.php
database/migrations/1900_01_01_000000_create_citext_extension.php
database/migrations/1900_01_01_000001_create_uuidossp_extension.php
database/migrations/2014_10_12_000000_create_users_table.php
database/migrations/2014_10_12_100000_create_password_reset_tokens_table.php
database/migrations/2018_02_05_000000_create_queue_monitor_table.php
database/migrations/2019_05_31_042934_create_versions_table.php
database/migrations/2019_08_19_000000_create_failed_jobs_table.php
database/migrations/2019_12_14_000001_create_personal_access_tokens_table.php
database/migrations/2020_07_03_163707_add_deleted_at_to_versions.php
database/migrations/2021_03_18_160750_make_user_nullable.php
database/migrations/2023_06_07_000001_create_pulse_tables.php
database/migrations/2024_04_07_120726_create_libraries_table.php
database/migrations/2024_04_07_120837_create_artists_table.php
database/migrations/2024_04_07_121115_create_albums_table.php
database/migrations/2024_04_07_121120_create_songs_table.php
database/migrations/2024_04_07_121647_create_images_table.php
database/migrations/2024_04_07_122724_create_genres_table.php
database/migrations/2024_04_13_001853_create_artist_song_table.php
database/migrations/2024_08_05_135758_create_user_media_activities_table.php
database/migrations/2024_08_11_200722_add_two_factor_columns_to_users_table.php
database/migrations/2024_09_13_224442_create_permission_tables.php
database/migrations/2024_09_13_232859_create_user_library_table.php
database/migrations/2024_10_04_212603_create_genre_song_table.php
database/migrations/2024_10_05_162336_create_album_artists_table.php
database/migrations/2024_10_05_192816_create_passkeys_table.php
database/migrations/2024_10_06_014632_create_oauth_auth_codes_table.php
database/migrations/2024_10_06_014633_create_oauth_access_tokens_table.php
database/migrations/2024_10_06_014634_create_oauth_refresh_tokens_table.php
database/migrations/2024_10_06_014635_create_oauth_clients_table.php
database/migrations/2025_02_26_225139_create_transcoding_sessions_table.php
database/migrations/2025_05_11_113239_create_playlists_table.php
database/migrations/2025_05_11_113343_create_playlist_song_table.php
database/migrations/2025_05_11_115840_create_playlist_collaborator_table.php
database/migrations/2025_05_11_120239_create_playlist_statistics_table.php
database/migrations/2025_05_31_195952_create_recommendations_table.php
database/migrations/2025_06_07_180140_create_movies_table.php
database/migrations/2025_06_07_181520_create_videos_table.php
database/migrations/2025_06_07_186232_create_movie_video_table.php
database/migrations/2025_06_08_102241_add_mbid_discogs_ids.php
database/seeders/AclSeed.php
database/seeders/DatabaseSeeder.php
database/seeders/UsersSeed.php
Discogs.postman_collection-v2.1.json
docker-compose-prod.yml
docker-compose.yml
docker/dev/ca.crt
docker/dev/nginx.conf
docker/dev/php.ini
docker/dev/www.conf
docker/dev/xdebug-main.ini
docker/dev/xdebug-osx.ini
docker/ffmpeg/Dockerfile
docker/general/cron
docker/general/do_we_need_xdebug.sh
docker/general/supervisord.conf
docker/nginx/Dockerfile
Dockerfile
docs/assets/baander-logo.svg
docs/dev_docker_services.md
docs/dev_setup_host.md
docs/dev_users.md
docs/dev_workflow.md
docs/discogs-client.md
docs/phpstorm.md
docs/xdebug.md
lang/en/acl.php
lang/en/auth.php
lang/en/date.php
lang/en/error.php
lang/en/library.php
lang/en/pagination.php
lang/en/passwords.php
lang/en/validation.php
LICENSE
Makefile
openapi-gen-client.ts
package.json
phpcs.xml
phpstan.neon
phpunit.xml
queue_listen.sh
README.md
repomix.config.json
resources/app/api-client-ext/interceptors/apm-transaction.interceptor.ts
resources/app/api-client-ext/interceptors/index.ts
resources/app/api-client-ext/interceptors/profiler-param.interceptor.ts
resources/app/api-client-ext/interceptors/refresh-access-token.interceptor.ts
resources/app/api-client/queries/common.ts
resources/app/api-client/queries/ensureQueryData.ts
resources/app/api-client/queries/index.ts
resources/app/api-client/queries/infiniteQueries.ts
resources/app/api-client/queries/prefetch.ts
resources/app/api-client/queries/queries.ts
resources/app/api-client/queries/suspense.ts
resources/app/api-client/requests/core/ApiError.ts
resources/app/api-client/requests/core/ApiRequestOptions.ts
resources/app/api-client/requests/core/ApiResult.ts
resources/app/api-client/requests/core/CancelablePromise.ts
resources/app/api-client/requests/core/OpenAPI.ts
resources/app/api-client/requests/core/request.ts
resources/app/api-client/requests/index.ts
resources/app/api-client/requests/schemas.gen.ts
resources/app/api-client/requests/services.gen.ts
resources/app/api-client/requests/types.gen.ts
resources/app/app.module.scss
resources/app/App.tsx
resources/app/assets/svg/baander-logo.svg
resources/app/bootstrap.ts
resources/app/common/env.ts
resources/app/common/i18n.ts
resources/app/common/react-query.ts
resources/app/components/apm/apm-error-boundary.tsx
resources/app/components/apm/with-apm-instrumentation.tsx
resources/app/components/song-table/song-table.module.scss
resources/app/components/song-table/song-table.tsx
resources/app/components/video-player/advanced-video-player.tsx
resources/app/components/video-player/video-player.tsx
resources/app/docs/apm-tracking.md
resources/app/env.d.ts
resources/app/global.d.ts
resources/app/hooks/use-apm-component-tracking.ts
resources/app/hooks/use-apm-route-tracking.ts
resources/app/hooks/use-app-config.ts
resources/app/hooks/use-app-dashboards.ts
resources/app/hooks/use-block-body-scroll.ts
resources/app/hooks/use-disclosure.ts
resources/app/hooks/use-event-listener.ts
resources/app/hooks/use-is-online.ts
resources/app/hooks/use-outside-click.ts
resources/app/hooks/use-path-param.ts
resources/app/hooks/use-queue.ts
resources/app/hooks/use-stream-token.ts
resources/app/hooks/use-webauthn.ts
resources/app/index.css
resources/app/index.tsx
resources/app/layouts/bare-layout/bare-layout.module.scss
resources/app/layouts/bare-layout/bare-layout.tsx
resources/app/layouts/dashboard-layout/components/dashboard-menu.module.scss
resources/app/layouts/dashboard-layout/components/dashboard-menu.tsx
resources/app/layouts/dashboard-layout/dashboard-layout.module.scss
resources/app/layouts/dashboard-layout/dashboard-layout.tsx
resources/app/layouts/root-layout/components/root-menu.module.scss
resources/app/layouts/root-layout/components/root-menu.tsx
resources/app/layouts/root-layout/root-layout.module.scss
resources/app/layouts/root-layout/root-layout.tsx
resources/app/libs/blurhash/decode.ts
resources/app/libs/blurhash/generate-bg-image.ts
resources/app/libs/blurhash/luminance.ts
resources/app/libs/blurhash/srgb.ts
resources/app/libs/lyrics/audio-lyric-synchronizer.ts
resources/app/libs/lyrics/line-parser.ts
resources/app/libs/lyrics/lrc.ts
resources/app/models/library-type.ts
resources/app/models/library.ts
resources/app/modules/auth/create-account/create-account-form.module.scss
resources/app/modules/auth/create-account/create-account-form.tsx
resources/app/modules/auth/forgot-password-form/forgot-password-form.tsx
resources/app/modules/auth/routes/_routes.tsx
resources/app/modules/auth/routes/create-account.module.scss
resources/app/modules/auth/routes/create-account.tsx
resources/app/modules/auth/routes/forgot-password.module.scss
resources/app/modules/auth/routes/forgot-password.tsx
resources/app/modules/auth/routes/login.module.scss
resources/app/modules/auth/routes/login.tsx
resources/app/modules/auth/routes/shared.scss
resources/app/modules/authorize/confirm-password.tsx
resources/app/modules/authorize/routes.tsx
resources/app/modules/dashboard/components/iframe.module.scss
resources/app/modules/dashboard/components/iframe.tsx
resources/app/modules/dashboard/dashboard-home/dashboard-home.tsx
resources/app/modules/dashboard/documentation/musicbrainz/musicbrainz-schema.tsx
resources/app/modules/dashboard/libraries/components/create-library.module.css
resources/app/modules/dashboard/libraries/components/create-library.tsx
resources/app/modules/dashboard/libraries/libraries-list.tsx
resources/app/modules/dashboard/libraries/libraries-new.tsx
resources/app/modules/dashboard/music/MusicTasks.tsx
resources/app/modules/dashboard/queue-monitor/components/job-details.module.scss
resources/app/modules/dashboard/queue-monitor/components/job-details.tsx
resources/app/modules/dashboard/queue-monitor/components/job-status.tsx
resources/app/modules/dashboard/queue-monitor/components/jobs-list.module.scss
resources/app/modules/dashboard/queue-monitor/components/jobs-list.tsx
resources/app/modules/dashboard/queue-monitor/components/metric-card.tsx
resources/app/modules/dashboard/queue-monitor/components/metrics.tsx
resources/app/modules/dashboard/queue-monitor/queue-monitor.tsx
resources/app/modules/dashboard/routes.tsx
resources/app/modules/dashboard/routes/log-viewer.tsx
resources/app/modules/dashboard/system-info/php.module.scss
resources/app/modules/dashboard/system-info/php.tsx
resources/app/modules/dashboard/users/users-list.tsx
resources/app/modules/equalizer/components/description.module.scss
resources/app/modules/equalizer/components/description.tsx
resources/app/modules/equalizer/components/eq-button.module.scss
resources/app/modules/equalizer/components/eq-button.tsx
resources/app/modules/equalizer/components/knob.module.scss
resources/app/modules/equalizer/components/knob.tsx
resources/app/modules/equalizer/components/power.tsx
resources/app/modules/equalizer/components/vfd-channel-analyzer.module.scss
resources/app/modules/equalizer/components/vfd-channel-analyzer.tsx
resources/app/modules/equalizer/components/vfd-display.module.scss
resources/app/modules/equalizer/components/vfd-display.tsx
resources/app/modules/equalizer/components/vfd-spectrum.module.scss
resources/app/modules/equalizer/components/vfd-spectrum.tsx
resources/app/modules/equalizer/equalizer.module.scss
resources/app/modules/equalizer/equalizer.tsx
resources/app/modules/equalizer/models/playback-source.ts
resources/app/modules/equalizer/models/three-band-eq.ts
resources/app/modules/equalizer/types.ts
resources/app/modules/equalizer/vfd-frequency-bars.ts
resources/app/modules/library-movies/components/movie-list/movie-list.tsx
resources/app/modules/library-movies/mock.ts
resources/app/modules/library-movies/modes.ts
resources/app/modules/library-movies/routes/_routes.tsx
resources/app/modules/library-movies/routes/overview.tsx
resources/app/modules/library-music-player/components/player-buttons/player-buttons.tsx
resources/app/modules/library-music-player/components/player-buttons/player-controls.module.scss
resources/app/modules/library-music-player/components/player-controls/player-controls.module.scss
resources/app/modules/library-music-player/components/player-controls/player-controls.tsx
resources/app/modules/library-music-player/components/player-face-plate/player-face-plate.module.scss
resources/app/modules/library-music-player/components/player-face-plate/player-face-plate.tsx
resources/app/modules/library-music-player/components/player-meta-controls/player-meta-controls.module.scss
resources/app/modules/library-music-player/components/player-meta-controls/player-meta-controls.tsx
resources/app/modules/library-music-player/components/progress-bar/progress-bar.module.css
resources/app/modules/library-music-player/components/progress-bar/progress-bar.tsx
resources/app/modules/library-music-player/components/volume-slider/volume-slider.tsx
resources/app/modules/library-music-player/constants.ts
resources/app/modules/library-music-player/hooks/use-audio-processor.tsx
resources/app/modules/library-music-player/inline-player.tsx
resources/app/modules/library-music-player/providers/audio-player-provider.tsx
resources/app/modules/library-music-playlists/_routes.tsx
resources/app/modules/library-music-playlists/components/context-menu/playlist-layout-context-menu/playlist-layout-context-menu.tsx
resources/app/modules/library-music-playlists/components/create-playlist/create-playlist.module.scss
resources/app/modules/library-music-playlists/components/create-playlist/create-playlist.tsx
resources/app/modules/library-music-playlists/components/create-smart-playlist/create-smart-playlist.module.scss
resources/app/modules/library-music-playlists/components/create-smart-playlist/create-smart-playlist.tsx
resources/app/modules/library-music-playlists/components/smart-playlist-rule-editor/smart-playlist-rule-editor.module.scss
resources/app/modules/library-music-playlists/components/smart-playlist-rule-editor/smart-playlist-rule-editor.tsx
resources/app/modules/library-music-playlists/playlist/playlist.module.scss
resources/app/modules/library-music-playlists/playlist/playlist.tsx
resources/app/modules/library-music/components/album-detail/album-detail.module.scss
resources/app/modules/library-music/components/album-detail/album-detail.tsx
resources/app/modules/library-music/components/album-detail/index.ts
resources/app/modules/library-music/components/album/album.module.scss
resources/app/modules/library-music/components/album/album.tsx
resources/app/modules/library-music/components/album/index.ts
resources/app/modules/library-music/components/artwork/artist-big-circle/artist-big-circle.module.scss
resources/app/modules/library-music/components/artwork/artist-big-circle/artist-big-circle.tsx
resources/app/modules/library-music/components/artwork/cover/cover.module.scss
resources/app/modules/library-music/components/artwork/cover/cover.tsx
resources/app/modules/library-music/components/artwork/cover/index.ts
resources/app/modules/library-music/components/cover-grid/cover-grid.module.scss
resources/app/modules/library-music/components/cover-grid/cover-grid.tsx
resources/app/modules/library-music/components/cover-grid/index.ts
resources/app/modules/library-music/components/scroll-list/index.ts
resources/app/modules/library-music/components/scroll-list/scroll-list.module.scss
resources/app/modules/library-music/components/scroll-list/scroll-list.tsx
resources/app/modules/library-music/components/song-detail/song-detail.tsx
resources/app/modules/library-music/components/song-list/song-list.module.scss
resources/app/modules/library-music/components/song-list/song-list.tsx
resources/app/modules/library-music/routes/_routes.tsx
resources/app/modules/library-music/routes/albums.module.scss
resources/app/modules/library-music/routes/albums.tsx
resources/app/modules/library-music/routes/artists.module.scss
resources/app/modules/library-music/routes/artists.tsx
resources/app/modules/library-music/routes/songs.module.scss
resources/app/modules/library-music/routes/songs.tsx
resources/app/modules/notifications/components/notification-card/notification-card.tsx
resources/app/modules/notifications/models.ts
resources/app/modules/notifications/notification-area.tsx
resources/app/modules/notifications/notification-facade.ts
resources/app/modules/overview/overview.tsx
resources/app/modules/user-settings/features/dev-panel.tsx
resources/app/modules/user-settings/features/passkeys/create-passkey.tsx
resources/app/modules/user-settings/features/tokens/token-detail.tsx
resources/app/modules/user-settings/layouts/settings-page-layout.tsx
resources/app/modules/user-settings/pages/equalizer-settings.tsx
resources/app/modules/user-settings/pages/passkeys.tsx
resources/app/modules/user-settings/pages/sessions.tsx
resources/app/modules/user-settings/pages/settings-overview.tsx
resources/app/modules/user-settings/routes.tsx
resources/app/providers/dayjs-provider.tsx
resources/app/providers/music-source-provider.tsx
resources/app/providers/radix-provider.tsx
resources/app/providers/test-mode-provider.tsx
resources/app/reset.css
resources/app/routes/index.tsx
resources/app/routes/protected.tsx
resources/app/routes/public.tsx
resources/app/services/apm-user-interactions.ts
resources/app/services/apm.ts
resources/app/services/auth/refresh-token.service.ts
resources/app/services/auth/stream-token.ts
resources/app/services/auth/token.ts
resources/app/services/libraries/player-state.ts
resources/app/services/libraries/support.ts
resources/app/store/audio/equalizer.ts
resources/app/store/create-app-slice.ts
resources/app/store/hooks.ts
resources/app/store/index.ts
resources/app/store/music/music-player-slice.ts
resources/app/store/notifications/notifications-slice.ts
resources/app/store/users/auth-slice.ts
resources/app/store/users/auth-slice.utils.ts
resources/app/store/users/ui-slice.ts
resources/app/ui/alerts/alert-loading-error.tsx
resources/app/ui/alerts/alert.tsx
resources/app/ui/animations/vinyl-spin-animation/vinyl-spin-animation.json
resources/app/ui/animations/vinyl-spin-animation/vinyl-spin-animation.tsx
resources/app/ui/audio-stats/audio-stats.tsx
resources/app/ui/blur-hash/blur-hash-canvas.tsx
resources/app/ui/blur-hash/blur-hash.tsx
resources/app/ui/brand/Brand.tsx
resources/app/ui/branding/baander-logo/baander-logo.module.scss
resources/app/ui/branding/baander-logo/baander-logo.tsx
resources/app/ui/buttons/close-button.tsx
resources/app/ui/carousel/carousel.scss
resources/app/ui/carousel/carousel.tsx
resources/app/ui/carousel/components/arrow-buttons.tsx
resources/app/ui/carousel/components/dot-button.tsx
resources/app/ui/dates/date-time.tsx
resources/app/ui/feedback/loading/beach-ball.tsx
resources/app/ui/icons/iconify.tsx
resources/app/ui/icons/libary.tsx
resources/app/ui/icons/player.tsx
resources/app/ui/link-button.tsx
resources/app/ui/lyrics-viewer/components/lyrics-animation/lyrics-animation.module.scss
resources/app/ui/lyrics-viewer/components/lyrics-animation/lyrics-animation.tsx
resources/app/ui/lyrics-viewer/components/lyrics-settings/lyrics-settings.module.scss
resources/app/ui/lyrics-viewer/components/lyrics-settings/lyrics-settings.tsx
resources/app/ui/lyrics-viewer/lyrics-viewer.module.scss
resources/app/ui/lyrics-viewer/lyrics-viewer.tsx
resources/app/ui/lyrics-viewer/providers/lyrics-provider.tsx
resources/app/ui/media-library/media-item/media-item.tsx
resources/app/ui/music/track-row/track-row.tsx
resources/app/ui/nav-link.tsx
resources/app/ui/schema/rng-visualizer/constants.ts
resources/app/ui/schema/rng-visualizer/rng-visualizer.scss
resources/app/ui/schema/rng-visualizer/rng-visualizer.tsx
resources/app/ui/side-nav/side-nav.tsx
resources/app/ui/toast/_imperative.tsx
resources/app/ui/toast/toast.tsx
resources/app/ui/user-button/user-button.module.scss
resources/app/ui/user-button/user-button.tsx
resources/app/ui/users/user-table/user-table.tsx
resources/app/ui/waveform/waveform.module.scss
resources/app/ui/waveform/waveform.tsx
resources/app/utils/assert/is-defined.ts
resources/app/utils/is-promise.ts
resources/app/utils/job-status.ts
resources/app/utils/lazy-import.ts
resources/app/utils/lazy-lottie.ts
resources/app/utils/noop.ts
resources/app/utils/testing/generateMockDataFromType.ts
resources/app/utils/time/format-duration.ts
resources/app/vite-env.d.ts
resources/app/ziggy.d.ts
resources/app/ziggy.js
resources/views/app.blade.php
resources/views/dbg.blade.php
resources/views/mail/mailbook.blade.php
routes/api.php
routes/channels.php
routes/console.php
routes/mailbook.php
routes/web.php
scrambleexport.js
start_dev.sh
start_reverb.sh
start-swoole-server
storage/app/images/covers/.gitignore
storage/logs/.gitignore
tests/CreatesApplication.php
tests/Feature/DiscogsClientTest.php
tests/Feature/ExampleTest.php
tests/TestCase.php
tests/Unit/ExampleTest.php
TODO.md
tsconfig.json
tsconfig.node.json
tsconfig.paths.json
vite.config.mts</directory_structure><files>This section contains the contents of the repository&apos;s files.<file path=".junie/guideliens.md"># Never use any terminal commands.
Dont even use `ls` or `cd`.

``` markdown

# Laravel Development Guidelines for Bånder

## Table of Contents
- [General Principles](#general-principles)
- [Code Standards](#code-standards)
- [Laravel Conventions](#laravel-conventions)
- [Database Guidelines](#database-guidelines)
- [API Development](#api-development)
- [Frontend Integration](#frontend-integration)
- [Testing Guidelines](#testing-guidelines)
- [Security Guidelines](#security-guidelines)
- [Performance Guidelines](#performance-guidelines)
- [Documentation Standards](#documentation-standards)

## General Principles

### Code Quality
- Write clean, readable, and maintainable code
- Follow SOLID principles
- Use meaningful variable and method names
- Keep methods small and focused on a single responsibility
- Favor composition over inheritance

### Version Control
- Use descriptive commit messages following conventional commits format
- Keep commits atomic and focused
- Use feature branches for new functionality
- Review code before merging to main branch

## Code Standards

### PHP Standards
- Follow PSR-12 coding standards
- Use PHP 8.4 features where appropriate (typed properties, match expressions, etc.)
- Use strict types declaration: `declare(strict_types=1);`
- Use return type declarations for all methods
- Use nullable types when appropriate: `?string`

### Naming Conventions
- **Classes**: PascalCase (`UserController`, `OrderService`)
- **Methods**: camelCase (`getUserData`, `processOrder`)
- **Variables**: camelCase (`$userEmail`, `$orderTotal`)
- **Constants**: SCREAMING_SNAKE_CASE (`MAX_RETRY_ATTEMPTS`)
- **Database tables**: snake_case, plural (`users`, `order_items`)
- **Database columns**: snake_case (`created_at`, `user_id`)

## Laravel Conventions

### Directory Structure
```
app/ ├── Actions/ # Single-purpose action classes ├── Console/ # Artisan commands ├── Events/ # Event classes ├── Exceptions/ # Custom exceptions ├── Http/ │ ├── Controllers/ # HTTP controllers │ ├── Middleware/ # Custom middleware │ ├── Requests/ # Form request validation │ └── Resources/ # API resources ├── Jobs/ # Queue jobs ├── Listeners/ # Event listeners ├── Mail/ # Mailable classes ├── Models/ # Eloquent models ├── Policies/ # Authorization policies ├── Providers/ # Service providers ├── Rules/ # Custom validation rules └── Services/ # Business logic services
``` 

### Controllers
- Keep controllers thin - delegate business logic to services
- Use form request classes for validation
- Return appropriate HTTP status codes
- Use resource controllers for RESTful endpoints
```
php class UserController extends Controller { public function __construct( private readonly UserService $userService ) {}
public function store(CreateUserRequest $request): JsonResponse
{
$user = $this-&gt;userService-&gt;createUser($request-&gt;validated());

    return response()-&gt;json($user, 201);
}
}
latex_unknown_tag
``` 

### Models
- Use Eloquent relationships instead of manual joins
- Define fillable or guarded properties
- Use model factories for testing
- Implement soft deletes when appropriate
- Use UUID as primary keys for public-facing resources
```
php class User extends Authenticatable { use HasApiTokens, HasFactory, Notifiable, SoftDeletes;
protected $fillable = [
&apos;name&apos;,
&apos;email&apos;,
&apos;password&apos;,
];

protected $hidden = [
&apos;password&apos;,
&apos;remember_token&apos;,
];

protected function casts(): array
{
return [
&apos;email_verified_at&apos; =&gt; &apos;datetime&apos;,
&apos;password&apos; =&gt; &apos;hashed&apos;,
];
}
}
``` 

### Services
- Create service classes for complex business logic
- Use dependency injection
- Make services stateless when possible
```
php class UserService { public function __construct( private readonly UserRepository userRepository, private readonly NotificationServicenotificationService ) {}
public function createUser(array $data): User
{
$user = $this-&gt;userRepository-&gt;create($data);
$this-&gt;notificationService-&gt;sendWelcomeEmail($user);

    return $user;
}
}
latex_unknown_tag
``` 

## Database Guidelines

### Migrations
- Use descriptive migration names
- Always include rollback logic in `down()` method
- Use foreign key constraints
- Add indexes for frequently queried columns
- Use appropriate data types
```
php public function up(): void { Schema::create(&apos;user_profiles&apos;, function (Blueprint table) {table-&gt;uuid(&apos;id&apos;)-&gt;primary(); table-&gt;foreignUuid(&apos;user_id&apos;)-&gt;constrained()-&gt;onDelete(&apos;cascade&apos;);table-&gt;string(&apos;first_name&apos;); table-&gt;string(&apos;last_name&apos;);table-&gt;date(&apos;birth_date&apos;)-&gt;nullable(); $table-&gt;timestamps();
$table-&gt;index([&apos;user_id&apos;]);
});
}
``` 

### Eloquent
- Use eager loading to prevent N+1 queries
- Use query scopes for reusable query logic
- Prefer Eloquent relationships over raw queries
- Use database transactions for multi-step operations
```
php // Good: Eager loading $users = User::with([&apos;profile&apos;, &apos;orders&apos;])-&gt;get();
// Good: Using query scopes class User extends Model { public function scopeActive(Builder query): void {query-&gt;where(&apos;is_active&apos;, true); } }
``` 

## API Development

### RESTful APIs
- Follow REST conventions for URL structure
- Use appropriate HTTP methods (GET, POST, PUT, DELETE)
- Return consistent JSON responses
- Implement proper error handling
- Use API resources for response formatting

### Authentication
- Use Laravel Sanctum for API authentication
- Implement proper token management
- Use middleware for route protection
```
php // API Resource example class UserResource extends JsonResource { public function toArray(Request request): array { return [ &apos;id&apos; =&gt;this-&gt;id, &apos;name&apos; =&gt; this-&gt;name, &apos;email&apos; =&gt;this-&gt;email, &apos;created_at&apos; =&gt; this-&gt;created_at, &apos;profile&apos; =&gt; new ProfileResource(this-&gt;whenLoaded(&apos;profile&apos;)), ]; } }
latex_unknown_tag
``` 

## Frontend Integration

### React Integration
- Use Ziggy for route generation in JavaScript
- Implement proper error handling for API calls
- Use TypeScript for type safety
- Follow React best practices and hooks patterns

### Asset Management
- Use Vite for asset compilation
- Organize assets logically
- Optimize images and other media files
- Use SCSS for styling with proper organization

## Testing Guidelines

### PHPUnit Testing
- Write tests for all business logic
- Use factories for test data
- Mock external dependencies
- Test both happy path and edge cases
- Aim for high test coverage
```
php class UserServiceTest extends TestCase { use RefreshDatabase;
public function test_can_create_user(): void
{
$userData = [
&apos;name&apos; =&gt; &apos;John Doe&apos;,
&apos;email&apos; =&gt; &apos;john@example.com&apos;,
&apos;password&apos; =&gt; &apos;password123&apos;,
];

    $user = $this-&gt;userService-&gt;createUser($userData);

    $this-&gt;assertInstanceOf(User::class, $user);
    $this-&gt;assertEquals($userData[&apos;email&apos;], $user-&gt;email);
}
}
``` 

### Test Organization
- Feature tests for end-to-end functionality
- Unit tests for individual components
- Use meaningful test method names
- Group related tests in test classes

## Security Guidelines

### Authentication &amp; Authorization
- Use Laravel&apos;s built-in authentication features
- Implement proper authorization with policies
- Validate all user inputs
- Use HTTPS in production
- Implement rate limiting

### Data Protection
- Hash sensitive data
- Use environment variables for secrets
- Implement proper CORS configuration
- Sanitize user inputs
- Use CSRF protection
```
php // Policy example class PostPolicy { public function update(User user, Postpost): bool { return user-&gt;id ===post-&gt;user_id; } }
``` 

## Performance Guidelines

### Database Optimization
- Use database indexing strategically
- Implement query optimization
- Use Redis for caching
- Implement database connection pooling

### Caching Strategy
- Cache frequently accessed data
- Use appropriate cache drivers
- Implement cache invalidation strategies
- Use Redis for session storage and queues
```
php // Caching example public function getPopularPosts(): Collection { return Cache::remember(&apos;popular_posts&apos;, 3600, function () { return Post::with(&apos;author&apos;) -&gt;where(&apos;views&apos;, &apos;&gt;&apos;, 1000) -&gt;orderBy(&apos;views&apos;, &apos;desc&apos;) -&gt;take(10) -&gt;get(); }); }
``` 

### Queue Management
- Use queues for time-consuming tasks
- Implement proper job retry logic
- Monitor queue performance
- Use Redis as queue driver

## Documentation Standards

### Code Documentation
- Use PHPDoc blocks for all public methods
- Document complex business logic
- Keep documentation up to date
- Include examples in documentation

```php
/**
 * Create a new user account with the provided data.
 *
 * @param array $data User data including name, email, and password
 * @return User The newly created user instance
 * @throws ValidationException When user data is invalid
 */
public function createUser(array $data): User
{
    // Implementation
}
```
```
### API Documentation
- Document all API endpoints
- Include request/response examples
- Document authentication requirements
- Keep API documentation current

## Environment Configuration
### Development
- Use appropriate log levels
- Enable debug mode for development
- Use local database for development
- Configure proper error reporting

### Production
- Disable debug mode
- Use environment-specific configurations
- Implement proper logging
- Use production-optimized settings

## Best Practices Summary
1. **Follow Laravel conventions** - Use Laravel&apos;s built-in features and conventions
2. **Write testable code** - Design code that&apos;s easy to test and maintain
3. **Use dependency injection** - Leverage Laravel&apos;s service container
4. **Implement proper error handling** - Handle errors gracefully and provide meaningful messages
5. **Optimize for performance** - Use caching, queues, and database optimization
6. **Maintain security** - Follow security best practices and validate all inputs
7. **Document your code** - Write clear documentation and comments
8. **Stay consistent** - Follow established patterns and conventions throughout the project

## Tools and Resources
- **Code Quality**: PHPStan for static analysis
- **Testing**: PHPUnit with Mockery for mocking
- **API Testing**: Use built-in testing tools
- **Performance**: Use Laravel Telescope for debugging
- **Security**: Follow OWASP guidelines

Remember: These guidelines should evolve with the project and team needs. Regular reviews and updates ensure they remain relevant and useful.
``` 

This comprehensive guidelines document covers all the essential aspects of Laravel development for your Bånder application, including the specific technologies and frameworks you&apos;re using (Laravel 12.17.0, PostgreSQL, Redis, React with TypeScript, etc.). The guidelines are tailored to promote best practices, maintainability, and consistency across your development team.
```</file><file path=".repomixignore"># Add patterns to ignore here, one per line
# Example:
# *.log
# tmp/
vendor
node_modules
third_party
stubs
public
examples
packages</file><file path="app/Modules/Apm/Spans/AbstractSpan.php">&lt;?php
namespace App\Modules\Apm\Spans;
use Closure;
use Elastic\Apm\CustomErrorData;
use Elastic\Apm\DistributedTracingData;
use Elastic\Apm\ExecutionSegmentContextInterface;
use Elastic\Apm\ExecutionSegmentInterface;
use Elastic\Apm\SpanContextDbInterface;
use Elastic\Apm\SpanContextDestinationInterface;
use Elastic\Apm\SpanContextHttpInterface;
use Elastic\Apm\SpanContextInterface;
use Elastic\Apm\SpanContextServiceInterface;
use Elastic\Apm\SpanInterface;
use Throwable;
/**
 * Abstract base class for spans in the APM system
 * 
 * This class provides a foundation for adding data to SpanInterface instances.
 * It is designed to be used as a helper for classes that implement SpanInterface,
 * focusing only on data-adding operations.
 * 
 * Note: This class implements SpanInterface for backward compatibility,
 * but should only be used for adding data to spans. Methods not related to
 * adding data are marked as @deprecated.
 */
abstract class AbstractSpan implements SpanInterface
{
    /**
     * The wrapped Elastic APM span instance
     */
    protected ?SpanInterface $span;
    /**
     * Constructor
     */
    public function __construct(?SpanInterface $span = null)
    {
        $this-&gt;span = $span;
    }
    /**
     * Get the wrapped span instance
     */
    public function getSpan(): ?SpanInterface
    {
        return $this-&gt;span;
    }
    /**
     * Set the wrapped span instance
     */
    public function setSpan(?SpanInterface $span): void
    {
        $this-&gt;span = $span;
    }
    /**
     * {@inheritdoc}
     */
    public function getId(): string
    {
        return $this-&gt;span ? $this-&gt;span-&gt;getId() : &apos;&apos;;
    }
    /**
     * {@inheritdoc}
     */
    public function getTraceId(): string
    {
        return $this-&gt;span ? $this-&gt;span-&gt;getTraceId() : &apos;&apos;;
    }
    /**
     * {@inheritdoc}
     */
    public function getTimestamp(): float
    {
        return $this-&gt;span ? $this-&gt;span-&gt;getTimestamp() : 0.0;
    }
    /**
     * {@inheritdoc}
     * 
     * @deprecated This method is not related to adding data to spans and should not be used.
     *             AbstractSpan should only be used for adding data to spans.
     */
    public function beginChildSpan(
        string $name,
        string $type,
        ?string $subtype = null,
        ?string $action = null,
        ?float $timestamp = null
    ): SpanInterface {
        if (!$this-&gt;span) {
            throw new \RuntimeException(&apos;Cannot begin child span: no span instance set&apos;);
        }
        return $this-&gt;span-&gt;beginChildSpan($name, $type, $subtype, $action, $timestamp);
    }
    /**
     * {@inheritdoc}
     * 
     * @deprecated This method is not related to adding data to spans and should not be used.
     *             AbstractSpan should only be used for adding data to spans.
     */
    public function captureChildSpan(
        string $name,
        string $type,
        Closure $callback,
        ?string $subtype = null,
        ?string $action = null,
        ?float $timestamp = null
    ) {
        if (!$this-&gt;span) {
            return $callback(new class implements SpanInterface {
                public function getId(): string { return &apos;&apos;; }
                public function getTraceId(): string { return &apos;&apos;; }
                public function getTimestamp(): float { return 0.0; }
                public function beginChildSpan(string $name, string $type, ?string $subtype = null, ?string $action = null, ?float $timestamp = null): SpanInterface { return $this; }
                public function captureChildSpan(string $name, string $type, Closure $callback, ?string $subtype = null, ?string $action = null, ?float $timestamp = null) { return $callback($this); }
                public function setName(string $name): void {}
                public function setType(string $type): void {}
                public function getDistributedTracingData(): ?DistributedTracingData { return null; }
                public function injectDistributedTracingHeaders(Closure $headerInjector): void {}
                public function end(?float $duration = null): void {}
                public function hasEnded(): bool { return true; }
                public function createErrorFromThrowable(Throwable $throwable): ?string { return null; }
                public function createCustomError(CustomErrorData $customErrorData): ?string { return null; }
                public function setOutcome(?string $outcome): void {}
                public function getOutcome(): ?string { return null; }
                public function isNoop(): bool { return true; }
                public function discard(): void {}
                public function getTransactionId(): string { return &apos;&apos;; }
                public function getParentId(): string { return &apos;&apos;; }
                public function setAction(?string $action): void {}
                public function setSubtype(?string $subtype): void {}
                public function context(): SpanContextInterface { 
                    return new class implements SpanContextInterface {
                        public function setLabel(string $key, $value): void {}
                        public function db(): SpanContextDbInterface { 
                            return new class implements SpanContextDbInterface {
                                public function setStatement(?string $statement): void {}
                                public function setType(?string $type): void {}
                                public function setUser(?string $user): void {}
                                public function setInstance(?string $instance): void {}
                            };
                        }
                        public function http(): SpanContextHttpInterface { 
                            return new class implements SpanContextHttpInterface {
                                public function setUrl(?string $url): void {}
                                public function setStatusCode(?int $statusCode): void {}
                                public function setMethod(?string $method): void {}
                            };
                        }
                        public function destination(): SpanContextDestinationInterface { 
                            return new class implements SpanContextDestinationInterface {
                                public function setAddress(?string $address): void {}
                                public function setPort(?int $port): void {}
                                public function setService(?string $name, ?string $resource = null, ?string $type = null): void {}
                            };
                        }
                        public function service(): SpanContextServiceInterface { 
                            return new class implements SpanContextServiceInterface {
                                public function setName(?string $name): void {}
                                public function setVersion(?string $version): void {}
                                public function setEnvironment(?string $environment): void {}
                                public function target(): \Elastic\Apm\SpanContextServiceTargetInterface {
                                    return new class implements \Elastic\Apm\SpanContextServiceTargetInterface {
                                        public function setName(?string $name): void {}
                                        public function setType(?string $type): void {}
                                    };
                                }
                            };
                        }
                    };
                }
                public function endSpanEx(int $numberOfStackFramesToSkip, ?float $duration = null): void {}
            });
        }
        return $this-&gt;span-&gt;captureChildSpan($name, $type, $callback, $subtype, $action, $timestamp);
    }
    /**
     * {@inheritdoc}
     */
    public function setName(string $name): void
    {
        if ($this-&gt;span) {
            $this-&gt;span-&gt;setName($name);
        }
    }
    /**
     * {@inheritdoc}
     */
    public function setType(string $type): void
    {
        if ($this-&gt;span) {
            $this-&gt;span-&gt;setType($type);
        }
    }
    /**
     * {@inheritdoc}
     */
    public function getDistributedTracingData(): ?DistributedTracingData
    {
        return $this-&gt;span ? $this-&gt;span-&gt;getDistributedTracingData() : null;
    }
    /**
     * {@inheritdoc}
     */
    public function injectDistributedTracingHeaders(Closure $headerInjector): void
    {
        if ($this-&gt;span) {
            $this-&gt;span-&gt;injectDistributedTracingHeaders($headerInjector);
        }
    }
    /**
     * {@inheritdoc}
     * 
     * @deprecated This method is not related to adding data to spans and should not be used.
     *             AbstractSpan should only be used for adding data to spans.
     */
    public function end(?float $duration = null): void
    {
        if ($this-&gt;span) {
            $this-&gt;span-&gt;end($duration);
        }
    }
    /**
     * {@inheritdoc}
     * 
     * @deprecated This method is not related to adding data to spans and should not be used.
     *             AbstractSpan should only be used for adding data to spans.
     */
    public function hasEnded(): bool
    {
        return $this-&gt;span ? $this-&gt;span-&gt;hasEnded() : true;
    }
    /**
     * {@inheritdoc}
     * 
     * @deprecated This method is not related to adding data to spans and should not be used.
     *             AbstractSpan should only be used for adding data to spans.
     */
    public function createErrorFromThrowable(Throwable $throwable): ?string
    {
        return $this-&gt;span ? $this-&gt;span-&gt;createErrorFromThrowable($throwable) : null;
    }
    /**
     * {@inheritdoc}
     * 
     * @deprecated This method is not related to adding data to spans and should not be used.
     *             AbstractSpan should only be used for adding data to spans.
     */
    public function createCustomError(CustomErrorData $customErrorData): ?string
    {
        return $this-&gt;span ? $this-&gt;span-&gt;createCustomError($customErrorData) : null;
    }
    /**
     * {@inheritdoc}
     */
    public function setOutcome(?string $outcome): void
    {
        if ($this-&gt;span) {
            $this-&gt;span-&gt;setOutcome($outcome);
        }
    }
    /**
     * {@inheritdoc}
     */
    public function getOutcome(): ?string
    {
        return $this-&gt;span ? $this-&gt;span-&gt;getOutcome() : null;
    }
    /**
     * {@inheritdoc}
     */
    public function isNoop(): bool
    {
        return $this-&gt;span ? $this-&gt;span-&gt;isNoop() : true;
    }
    /**
     * {@inheritdoc}
     * 
     * @deprecated This method is not related to adding data to spans and should not be used.
     *             AbstractSpan should only be used for adding data to spans.
     */
    public function discard(): void
    {
        if ($this-&gt;span) {
            $this-&gt;span-&gt;discard();
        }
    }
    /**
     * {@inheritdoc}
     */
    public function getTransactionId(): string
    {
        return $this-&gt;span ? $this-&gt;span-&gt;getTransactionId() : &apos;&apos;;
    }
    /**
     * {@inheritdoc}
     */
    public function getParentId(): string
    {
        return $this-&gt;span ? $this-&gt;span-&gt;getParentId() : &apos;&apos;;
    }
    /**
     * {@inheritdoc}
     */
    public function setAction(?string $action): void
    {
        if ($this-&gt;span) {
            $this-&gt;span-&gt;setAction($action);
        }
    }
    /**
     * {@inheritdoc}
     */
    public function setSubtype(?string $subtype): void
    {
        if ($this-&gt;span) {
            $this-&gt;span-&gt;setSubtype($subtype);
        }
    }
    /**
     * {@inheritdoc}
     */
    public function context(): SpanContextInterface
    {
        if (!$this-&gt;span) {
            return new class implements SpanContextInterface {
                public function setLabel(string $key, $value): void {}
                public function db(): SpanContextDbInterface { 
                    return new class implements SpanContextDbInterface {
                        public function setStatement(?string $statement): void {}
                        public function setType(?string $type): void {}
                        public function setUser(?string $user): void {}
                        public function setInstance(?string $instance): void {}
                    };
                }
                public function http(): SpanContextHttpInterface { 
                    return new class implements SpanContextHttpInterface {
                        public function setUrl(?string $url): void {}
                        public function setStatusCode(?int $statusCode): void {}
                        public function setMethod(?string $method): void {}
                    };
                }
                public function destination(): SpanContextDestinationInterface { 
                    return new class implements SpanContextDestinationInterface {
                        public function setAddress(?string $address): void {}
                        public function setPort(?int $port): void {}
                        public function setService(?string $name, ?string $resource = null, ?string $type = null): void {}
                    };
                }
                public function service(): SpanContextServiceInterface { 
                    return new class implements SpanContextServiceInterface {
                        public function setName(?string $name): void {}
                        public function setVersion(?string $version): void {}
                        public function setEnvironment(?string $environment): void {}
                        public function target(): \Elastic\Apm\SpanContextServiceTargetInterface {
                            return new class implements \Elastic\Apm\SpanContextServiceTargetInterface {
                                public function setName(?string $name): void {}
                                public function setType(?string $type): void {}
                            };
                        }
                    };
                }
            };
        }
        return $this-&gt;span-&gt;context();
    }
    /**
     * {@inheritdoc}
     * 
     * @deprecated This method is not related to adding data to spans and should not be used.
     *             AbstractSpan should only be used for adding data to spans.
     */
    public function endSpanEx(int $numberOfStackFramesToSkip, ?float $duration = null): void
    {
        if ($this-&gt;span) {
            $this-&gt;span-&gt;endSpanEx($numberOfStackFramesToSkip, $duration);
        }
    }
}</file><file path="app/Modules/Apm/Spans/QuerySpan.php">&lt;?php
namespace App\Modules\Apm\Spans;
use Elastic\Apm\SpanInterface;
/**
 * Specialized span for database queries
 * 
 * This class extends AbstractSpan to add data to database query spans.
 * It implements SpanInterface directly to ensure proper type compatibility.
 */
class QuerySpan extends AbstractSpan implements SpanInterface
{
    // No additional methods needed, as AbstractSpan already implements SpanInterface
    // and provides all the necessary functionality for adding data to spans.
}</file><file path="repomix.config.json">{
  &quot;$schema&quot;: &quot;https://repomix.com/schemas/latest/schema.json&quot;,
  &quot;input&quot;: {
    &quot;maxFileSize&quot;: 52428800
  },
  &quot;output&quot;: {
    &quot;filePath&quot;: &quot;repomix-output.xml&quot;,
    &quot;style&quot;: &quot;xml&quot;,
    &quot;parsableStyle&quot;: true,
    &quot;fileSummary&quot;: true,
    &quot;directoryStructure&quot;: true,
    &quot;files&quot;: true,
    &quot;removeComments&quot;: false,
    &quot;removeEmptyLines&quot;: true,
    &quot;compress&quot;: false,
    &quot;topFilesLength&quot;: 5,
    &quot;showLineNumbers&quot;: false,
    &quot;copyToClipboard&quot;: false,
    &quot;git&quot;: {
      &quot;sortByChanges&quot;: true,
      &quot;sortByChangesMaxCommits&quot;: 100,
      &quot;includeDiffs&quot;: false
    }
  },
  &quot;include&quot;: [],
  &quot;ignore&quot;: {
    &quot;useGitignore&quot;: true,
    &quot;useDefaultPatterns&quot;: true,
    &quot;customPatterns&quot;: []
  },
  &quot;security&quot;: {
    &quot;enableSecurityCheck&quot;: false
  },
  &quot;tokenCount&quot;: {
    &quot;encoding&quot;: &quot;o200k_base&quot;
  }
}</file><file path="resources/app/api-client-ext/interceptors/apm-transaction.interceptor.ts">import { OpenAPI } from &apos;@/api-client/requests&apos;;
import { apm } from &apos;@/services/apm.ts&apos;;
// Map to store transactions by request URL
const transactionMap = new Map&lt;string, any&gt;();
export function apmTransactionInterceptor() {
  // Request interceptor - start transaction
  OpenAPI.interceptors.request.use(
    async (request) =&gt; {
      // Extract the endpoint from the URL
      const url = new URL(request.url || &apos;&apos;);
      const endpoint = url.pathname;
      // Create a unique ID for this request
      const requestId = `${request.method}-${endpoint}-${Date.now()}`;
      // Start a transaction for this API call
      const transaction = apm.startTransaction(`API ${request.method} ${endpoint}`, &apos;api&apos;);
      // Add metadata about the request
      transaction?.addLabels({
        method: request.method,
        url: endpoint,
        query: url.search,
      });
      // Store the transaction in the map
      transactionMap.set(requestId, { transaction, startTime: Date.now() });
      // Add the request ID to the request object for later retrieval
      request.headers = request.headers || {};
      request.headers[&apos;X-APM-Request-ID&apos;] = requestId;
      return request;
    },
  );
  // Response interceptor - end transaction
  OpenAPI.interceptors.response.use(
    async (response) =&gt; {
      // Get the request ID from the request headers
      const requestId = response.config?.headers?.[&apos;X-APM-Request-ID&apos;];
      if (requestId &amp;&amp; transactionMap.has(requestId)) {
        const { transaction } = transactionMap.get(requestId);
        // Add response metadata
        transaction?.addLabels({
          status: response.status,
          statusText: response.statusText,
          responseTime: Date.now() - transactionMap.get(requestId).startTime,
        });
        // End the transaction
        transaction?.end();
        // Remove the transaction from the map
        transactionMap.delete(requestId);
      }
      return response;
    },
  );
}</file><file path="resources/app/docs/apm-tracking.md"># APM Tracking Implementation

This document describes the APM (Application Performance Monitoring) implementation in the application, which uses the Elastic APM RUM (Real User Monitoring) library.

## Overview

The APM implementation tracks various aspects of the application:

1. **Route Changes** - Tracks when users navigate between routes
2. **API Calls** - Tracks API requests and responses
3. **User Interactions** - Tracks user actions like button clicks and form submissions
4. **Component Performance** - Tracks React component rendering and lifecycle events
5. **Errors** - Captures and reports errors

## Implementation Details

### APM Service

The main APM service is defined in `resources/app/services/apm.ts`. It initializes the Elastic APM RUM client and provides utility functions for tracking React components.

```typescript
import { init as initApm } from &apos;@elastic/apm-rum&apos;

const apm = initApm({
  serviceName: &apos;baander-frontend&apos;,
  serverUrl: &apos;https://192.168.50.151:8200&apos;,
  serviceVersion: &apos;1.0.0&apos;,
  environment: &apos;development&apos;,
})

// Custom React instrumentation utilities
export const reactApm = {
  // ... utility functions for tracking React components
};

export { apm }
```

### Route Tracking with React Router

Route changes are tracked using the `useApmRouteTracking` hook in `resources/app/hooks/use-apm-route-tracking.ts`. This hook creates a transaction for each route change and tracks detailed navigation information using React Router hooks.

The hook captures:
- Route path, search parameters, and hash
- Navigation type (PUSH, POP, REPLACE)
- Previous path for transition tracking
- Route parameters from dynamic routes
- Query parameters from the URL
- Route type based on pattern matching
- Page load metrics for initial loads

```typescript
// In App.tsx
import { useApmRouteTracking } from &apos;@/hooks/use-apm-route-tracking&apos;;

function AppWithRouteTracking() {
  useApmRouteTracking();

  return (
    &lt;ApmErrorBoundary&gt;
      &lt;AppRoutes /&gt;
    &lt;/ApmErrorBoundary&gt;
  );
}
```

The hook uses several React Router hooks for comprehensive tracking:
- `useLocation` - Gets the current location object
- `useNavigationType` - Gets the navigation type (PUSH, POP, REPLACE)
- `useParams` - Gets route parameters from dynamic routes
- `useMatch` - Matches the current URL against route patterns

Each route change creates a transaction with detailed metadata:

```typescript
// Transaction name format
`Route: ${routeType}:${location.pathname}`

// Transaction labels
{
  route: location.pathname,
  routeType, // &apos;dashboard&apos;, &apos;library&apos;, &apos;playlist&apos;, etc.
  search: location.search,
  hash: location.hash,
  navigationType, // &apos;PUSH&apos;, &apos;POP&apos;, or &apos;REPLACE&apos;
  prevPath: prevPath || &apos;initial&apos;,
  timestamp: new Date().toISOString(),
}

// Custom context
{
  page: {
    url: location.pathname + location.search + location.hash,
    route: location.pathname,
    routeType,
    title: document.title,
    referrer: document.referrer,
    queryParams: {...},
    routeParams: {...},
  },
  navigation: {
    type: navigationType,
    from: prevPath || &apos;initial&apos;,
    to: location.pathname,
  },
  routeMatches: {
    dashboard: boolean,
    library: boolean,
    playlist: boolean,
    userSettings: boolean,
    auth: boolean,
  }
}
```

### API Call Tracking

API calls are tracked using an interceptor in `resources/app/api-client-ext/interceptors/apm-transaction.interceptor.ts`. This interceptor creates a transaction for each API call and tracks request and response information.

```typescript
// In api-client-ext/interceptors/index.ts
import { apmTransactionInterceptor } from &apos;@/api-client-ext/interceptors/apm-transaction.interceptor.ts&apos;;

export function applyInterceptors() {
  // ... other interceptors
  apmTransactionInterceptor();
}
```

### User Interaction Tracking

User interactions are tracked using the `apmUserInteractions` utility in `resources/app/services/apm-user-interactions.ts`. This utility provides functions for tracking various user actions.

```typescript
// In a component
import { useApmUserInteractions } from &apos;@/services/apm-user-interactions&apos;;

function MyComponent() {
  const { trackButtonClick } = useApmUserInteractions();

  return (
    &lt;Button onClick={() =&gt; trackButtonClick(&apos;Submit&apos;, { formId: &apos;login-form&apos; })}&gt;
      Submit
    &lt;/Button&gt;
  );
}
```

### Component Performance Tracking

Component performance is tracked using the `withApmInstrumentation` HOC in `resources/app/components/apm/with-apm-instrumentation.tsx`. This HOC tracks component renders, mounts, prop changes, and errors.

```typescript
// In a component file
import { withApmInstrumentation } from &apos;@/components/apm/with-apm-instrumentation&apos;;

function MyComponent(props) {
  // ... component implementation
}

export default withApmInstrumentation(MyComponent, &apos;MyComponent&apos;);
```

### Error Tracking

Errors are tracked using the `ApmErrorBoundary` component in `resources/app/components/apm/apm-error-boundary.tsx`. This component catches errors in the component tree and reports them to APM.

```typescript
// In a component
import { ApmErrorBoundary } from &apos;@/components/apm/apm-error-boundary&apos;;

function MyComponent() {
  return (
    &lt;ApmErrorBoundary&gt;
      {/* Component content */}
    &lt;/ApmErrorBoundary&gt;
  );
}
```

## Usage Examples

### Tracking Route Changes

The route tracking is automatically applied in the `App.tsx` file using the `useApmRouteTracking` hook.

### Tracking API Calls

API calls are automatically tracked by the `apmTransactionInterceptor`, which is applied in the `applyInterceptors` function.

### Tracking User Interactions

```typescript
import { useApmUserInteractions } from &apos;@/services/apm-user-interactions&apos;;

function MyComponent() {
  const { 
    trackButtonClick, 
    trackFormSubmission, 
    trackSearch, 
    trackNavigation 
  } = useApmUserInteractions();

  return (
    &lt;div&gt;
      &lt;Button onClick={() =&gt; trackButtonClick(&apos;Save&apos;, { itemId: &apos;123&apos; })}&gt;
        Save
      &lt;/Button&gt;

      &lt;form onSubmit={(e) =&gt; {
        e.preventDefault();
        trackFormSubmission(&apos;login-form&apos;, { username: &apos;user123&apos; });
        // Form submission logic
      }}&gt;
        {/* Form fields */}
        &lt;Button type=&quot;submit&quot;&gt;Login&lt;/Button&gt;
      &lt;/form&gt;

      &lt;SearchBox onSearch={(term) =&gt; {
        trackSearch(term);
        // Search logic
      }} /&gt;

      &lt;NavLink 
        to=&quot;/dashboard&quot; 
        onClick={() =&gt; trackNavigation(&apos;/dashboard&apos;, { from: &apos;/home&apos; })}
      &gt;
        Dashboard
      &lt;/NavLink&gt;
    &lt;/div&gt;
  );
}
```

### Tracking Component Performance

```typescript
import { withApmInstrumentation } from &apos;@/components/apm/with-apm-instrumentation&apos;;

function ExpensiveComponent(props) {
  // ... component implementation with expensive operations
}

// Track all renders, mounts, and prop changes
export default withApmInstrumentation(
  ExpensiveComponent, 
  &apos;ExpensiveComponent&apos;, 
  { 
    trackRenders: true,
    trackMounts: true,
    trackPropChanges: true,
    trackErrors: true
  }
);
```

### Error Handling

```typescript
import { ApmErrorBoundary } from &apos;@/components/apm/apm-error-boundary&apos;;

function MyComponent() {
  return (
    &lt;ApmErrorBoundary 
      fallback={&lt;div&gt;Something went wrong&lt;/div&gt;}
      onError={(error, errorInfo) =&gt; {
        // Custom error handling
        console.error(&apos;Caught an error:&apos;, error, errorInfo);
      }}
    &gt;
      {/* Component content that might throw errors */}
    &lt;/ApmErrorBoundary&gt;
  );
}
```

## Conclusion

This APM implementation provides comprehensive tracking of the application&apos;s performance and user interactions. It helps identify performance bottlenecks, track user behavior, and catch errors early.</file><file path="resources/app/services/apm-user-interactions.ts">import { apm } from &apos;@/services/apm.ts&apos;;
/**
 * Utility functions for tracking user interactions with APM
 */
export const apmUserInteractions = {
  /**
   * Track a user interaction
   * @param actionName - Name of the action (e.g., &apos;click&apos;, &apos;submit&apos;)
   * @param targetName - Name of the target (e.g., &apos;login-button&apos;, &apos;search-form&apos;)
   * @param metadata - Additional metadata about the interaction
   */
  trackAction: (
    actionName: string,
    targetName: string,
    metadata?: Record&lt;string, any&gt;
  ) =&gt; {
    const transaction = apm.startTransaction(
      `User Action: ${actionName} ${targetName}`,
      &apos;user-interaction&apos;
    );
    transaction?.addLabels({
      action: actionName,
      target: targetName,
      timestamp: new Date().toISOString(),
      ...metadata,
    });
    // End the transaction after a short delay to capture any immediate effects
    setTimeout(() =&gt; {
      transaction?.end();
    }, 100);
    return transaction;
  },
  /**
   * Track a form submission
   * @param formName - Name of the form
   * @param metadata - Additional metadata about the form submission
   */
  trackFormSubmission: (
    formName: string,
    metadata?: Record&lt;string, any&gt;
  ) =&gt; {
    return apmUserInteractions.trackAction(&apos;submit&apos;, formName, metadata);
  },
  /**
   * Track a button click
   * @param buttonName - Name of the button
   * @param metadata - Additional metadata about the button click
   */
  trackButtonClick: (
    buttonName: string,
    metadata?: Record&lt;string, any&gt;
  ) =&gt; {
    return apmUserInteractions.trackAction(&apos;click&apos;, buttonName, metadata);
  },
  /**
   * Track a search action
   * @param searchTerm - The search term
   * @param metadata - Additional metadata about the search
   */
  trackSearch: (
    searchTerm: string,
    metadata?: Record&lt;string, any&gt;
  ) =&gt; {
    return apmUserInteractions.trackAction(&apos;search&apos;, &apos;search-box&apos;, {
      searchTerm,
      ...metadata,
    });
  },
  /**
   * Track a navigation action (e.g., menu click)
   * @param destination - The destination of the navigation
   * @param metadata - Additional metadata about the navigation
   */
  trackNavigation: (
    destination: string,
    metadata?: Record&lt;string, any&gt;
  ) =&gt; {
    return apmUserInteractions.trackAction(&apos;navigate&apos;, destination, metadata);
  },
  /**
   * Create a custom span for tracking a specific part of a user interaction
   * @param transaction - The parent transaction
   * @param spanName - Name of the span
   * @param spanType - Type of the span
   * @param metadata - Additional metadata for the span
   */
  createActionSpan: (
    transaction: any,
    spanName: string,
    spanType: string,
    metadata?: Record&lt;string, any&gt;
  ) =&gt; {
    const span = transaction?.startSpan(spanName, spanType);
    if (span &amp;&amp; metadata) {
      span.addLabels(metadata);
    }
    return span;
  },
};
/**
 * React hook for tracking user interactions
 * @returns Object with tracking functions
 */
export function useApmUserInteractions() {
  return apmUserInteractions;
}</file><file path="scrambleexport.js">const Ziggy = {&quot;url&quot;:&quot;https:\/\/baander.test&quot;,&quot;port&quot;:null,&quot;defaults&quot;:{},&quot;routes&quot;:{&quot;login.store&quot;:{&quot;uri&quot;:&quot;login&quot;,&quot;methods&quot;:[&quot;POST&quot;]},&quot;logout&quot;:{&quot;uri&quot;:&quot;logout&quot;,&quot;methods&quot;:[&quot;POST&quot;]},&quot;password.email&quot;:{&quot;uri&quot;:&quot;forgot-password&quot;,&quot;methods&quot;:[&quot;POST&quot;]},&quot;password.update&quot;:{&quot;uri&quot;:&quot;reset-password&quot;,&quot;methods&quot;:[&quot;POST&quot;]},&quot;verification.verify&quot;:{&quot;uri&quot;:&quot;email\/verify\/{id}\/{hash}&quot;,&quot;methods&quot;:[&quot;GET&quot;,&quot;HEAD&quot;],&quot;parameters&quot;:[&quot;id&quot;,&quot;hash&quot;]},&quot;verification.send&quot;:{&quot;uri&quot;:&quot;email\/verification-notification&quot;,&quot;methods&quot;:[&quot;POST&quot;]},&quot;password.confirmation&quot;:{&quot;uri&quot;:&quot;user\/confirmed-password-status&quot;,&quot;methods&quot;:[&quot;GET&quot;,&quot;HEAD&quot;]},&quot;password.confirm.store&quot;:{&quot;uri&quot;:&quot;user\/confirm-password&quot;,&quot;methods&quot;:[&quot;POST&quot;]},&quot;two-factor.login.store&quot;:{&quot;uri&quot;:&quot;two-factor-challenge&quot;,&quot;methods&quot;:[&quot;POST&quot;]},&quot;two-factor.enable&quot;:{&quot;uri&quot;:&quot;user\/two-factor-authentication&quot;,&quot;methods&quot;:[&quot;POST&quot;]},&quot;two-factor.confirm&quot;:{&quot;uri&quot;:&quot;user\/confirmed-two-factor-authentication&quot;,&quot;methods&quot;:[&quot;POST&quot;]},&quot;two-factor.disable&quot;:{&quot;uri&quot;:&quot;user\/two-factor-authentication&quot;,&quot;methods&quot;:[&quot;DELETE&quot;]},&quot;two-factor.qr-code&quot;:{&quot;uri&quot;:&quot;user\/two-factor-qr-code&quot;,&quot;methods&quot;:[&quot;GET&quot;,&quot;HEAD&quot;]},&quot;two-factor.secret-key&quot;:{&quot;uri&quot;:&quot;user\/two-factor-secret-key&quot;,&quot;methods&quot;:[&quot;GET&quot;,&quot;HEAD&quot;]},&quot;two-factor.recovery-codes&quot;:{&quot;uri&quot;:&quot;user\/two-factor-recovery-codes&quot;,&quot;methods&quot;:[&quot;GET&quot;,&quot;HEAD&quot;]},&quot;horizon.stats.index&quot;:{&quot;uri&quot;:&quot;-\/horizon\/api\/stats&quot;,&quot;methods&quot;:[&quot;GET&quot;,&quot;HEAD&quot;]},&quot;horizon.workload.index&quot;:{&quot;uri&quot;:&quot;-\/horizon\/api\/workload&quot;,&quot;methods&quot;:[&quot;GET&quot;,&quot;HEAD&quot;]},&quot;horizon.masters.index&quot;:{&quot;uri&quot;:&quot;-\/horizon\/api\/masters&quot;,&quot;methods&quot;:[&quot;GET&quot;,&quot;HEAD&quot;]},&quot;horizon.monitoring.index&quot;:{&quot;uri&quot;:&quot;-\/horizon\/api\/monitoring&quot;,&quot;methods&quot;:[&quot;GET&quot;,&quot;HEAD&quot;]},&quot;horizon.monitoring.store&quot;:{&quot;uri&quot;:&quot;-\/horizon\/api\/monitoring&quot;,&quot;methods&quot;:[&quot;POST&quot;]},&quot;horizon.monitoring-tag.paginate&quot;:{&quot;uri&quot;:&quot;-\/horizon\/api\/monitoring\/{tag}&quot;,&quot;methods&quot;:[&quot;GET&quot;,&quot;HEAD&quot;],&quot;parameters&quot;:[&quot;tag&quot;]},&quot;horizon.monitoring-tag.destroy&quot;:{&quot;uri&quot;:&quot;-\/horizon\/api\/monitoring\/{tag}&quot;,&quot;methods&quot;:[&quot;DELETE&quot;],&quot;wheres&quot;:{&quot;tag&quot;:&quot;.*&quot;},&quot;parameters&quot;:[&quot;tag&quot;]},&quot;horizon.jobs-metrics.index&quot;:{&quot;uri&quot;:&quot;-\/horizon\/api\/metrics\/jobs&quot;,&quot;methods&quot;:[&quot;GET&quot;,&quot;HEAD&quot;]},&quot;horizon.jobs-metrics.show&quot;:{&quot;uri&quot;:&quot;-\/horizon\/api\/metrics\/jobs\/{id}&quot;,&quot;methods&quot;:[&quot;GET&quot;,&quot;HEAD&quot;],&quot;parameters&quot;:[&quot;id&quot;]},&quot;horizon.queues-metrics.index&quot;:{&quot;uri&quot;:&quot;-\/horizon\/api\/metrics\/queues&quot;,&quot;methods&quot;:[&quot;GET&quot;,&quot;HEAD&quot;]},&quot;horizon.queues-metrics.show&quot;:{&quot;uri&quot;:&quot;-\/horizon\/api\/metrics\/queues\/{id}&quot;,&quot;methods&quot;:[&quot;GET&quot;,&quot;HEAD&quot;],&quot;parameters&quot;:[&quot;id&quot;]},&quot;horizon.jobs-batches.index&quot;:{&quot;uri&quot;:&quot;-\/horizon\/api\/batches&quot;,&quot;methods&quot;:[&quot;GET&quot;,&quot;HEAD&quot;]},&quot;horizon.jobs-batches.show&quot;:{&quot;uri&quot;:&quot;-\/horizon\/api\/batches\/{id}&quot;,&quot;methods&quot;:[&quot;GET&quot;,&quot;HEAD&quot;],&quot;parameters&quot;:[&quot;id&quot;]},&quot;horizon.jobs-batches.retry&quot;:{&quot;uri&quot;:&quot;-\/horizon\/api\/batches\/retry\/{id}&quot;,&quot;methods&quot;:[&quot;POST&quot;],&quot;parameters&quot;:[&quot;id&quot;]},&quot;horizon.pending-jobs.index&quot;:{&quot;uri&quot;:&quot;-\/horizon\/api\/jobs\/pending&quot;,&quot;methods&quot;:[&quot;GET&quot;,&quot;HEAD&quot;]},&quot;horizon.completed-jobs.index&quot;:{&quot;uri&quot;:&quot;-\/horizon\/api\/jobs\/completed&quot;,&quot;methods&quot;:[&quot;GET&quot;,&quot;HEAD&quot;]},&quot;horizon.silenced-jobs.index&quot;:{&quot;uri&quot;:&quot;-\/horizon\/api\/jobs\/silenced&quot;,&quot;methods&quot;:[&quot;GET&quot;,&quot;HEAD&quot;]},&quot;horizon.failed-jobs.index&quot;:{&quot;uri&quot;:&quot;-\/horizon\/api\/jobs\/failed&quot;,&quot;methods&quot;:[&quot;GET&quot;,&quot;HEAD&quot;]},&quot;horizon.failed-jobs.show&quot;:{&quot;uri&quot;:&quot;-\/horizon\/api\/jobs\/failed\/{id}&quot;,&quot;methods&quot;:[&quot;GET&quot;,&quot;HEAD&quot;],&quot;parameters&quot;:[&quot;id&quot;]},&quot;horizon.retry-jobs.show&quot;:{&quot;uri&quot;:&quot;-\/horizon\/api\/jobs\/retry\/{id}&quot;,&quot;methods&quot;:[&quot;POST&quot;],&quot;parameters&quot;:[&quot;id&quot;]},&quot;horizon.jobs.show&quot;:{&quot;uri&quot;:&quot;-\/horizon\/api\/jobs\/{id}&quot;,&quot;methods&quot;:[&quot;GET&quot;,&quot;HEAD&quot;],&quot;parameters&quot;:[&quot;id&quot;]},&quot;horizon.index&quot;:{&quot;uri&quot;:&quot;-\/horizon\/{view?}&quot;,&quot;methods&quot;:[&quot;GET&quot;,&quot;HEAD&quot;],&quot;wheres&quot;:{&quot;view&quot;:&quot;(.*)&quot;},&quot;parameters&quot;:[&quot;view&quot;]},&quot;passport.token&quot;:{&quot;uri&quot;:&quot;oauth\/token&quot;,&quot;methods&quot;:[&quot;POST&quot;]},&quot;passport.authorizations.authorize&quot;:{&quot;uri&quot;:&quot;oauth\/authorize&quot;,&quot;methods&quot;:[&quot;GET&quot;,&quot;HEAD&quot;]},&quot;passport.token.refresh&quot;:{&quot;uri&quot;:&quot;oauth\/token\/refresh&quot;,&quot;methods&quot;:[&quot;POST&quot;]},&quot;passport.authorizations.approve&quot;:{&quot;uri&quot;:&quot;oauth\/authorize&quot;,&quot;methods&quot;:[&quot;POST&quot;]},&quot;passport.authorizations.deny&quot;:{&quot;uri&quot;:&quot;oauth\/authorize&quot;,&quot;methods&quot;:[&quot;DELETE&quot;]},&quot;passport.tokens.index&quot;:{&quot;uri&quot;:&quot;oauth\/tokens&quot;,&quot;methods&quot;:[&quot;GET&quot;,&quot;HEAD&quot;]},&quot;passport.tokens.destroy&quot;:{&quot;uri&quot;:&quot;oauth\/tokens\/{token_id}&quot;,&quot;methods&quot;:[&quot;DELETE&quot;],&quot;parameters&quot;:[&quot;token_id&quot;]},&quot;passport.clients.index&quot;:{&quot;uri&quot;:&quot;oauth\/clients&quot;,&quot;methods&quot;:[&quot;GET&quot;,&quot;HEAD&quot;]},&quot;passport.clients.store&quot;:{&quot;uri&quot;:&quot;oauth\/clients&quot;,&quot;methods&quot;:[&quot;POST&quot;]},&quot;passport.clients.update&quot;:{&quot;uri&quot;:&quot;oauth\/clients\/{client_id}&quot;,&quot;methods&quot;:[&quot;PUT&quot;],&quot;parameters&quot;:[&quot;client_id&quot;]},&quot;passport.clients.destroy&quot;:{&quot;uri&quot;:&quot;oauth\/clients\/{client_id}&quot;,&quot;methods&quot;:[&quot;DELETE&quot;],&quot;parameters&quot;:[&quot;client_id&quot;]},&quot;passport.scopes.index&quot;:{&quot;uri&quot;:&quot;oauth\/scopes&quot;,&quot;methods&quot;:[&quot;GET&quot;,&quot;HEAD&quot;]},&quot;passport.personal.tokens.index&quot;:{&quot;uri&quot;:&quot;oauth\/personal-access-tokens&quot;,&quot;methods&quot;:[&quot;GET&quot;,&quot;HEAD&quot;]},&quot;passport.personal.tokens.store&quot;:{&quot;uri&quot;:&quot;oauth\/personal-access-tokens&quot;,&quot;methods&quot;:[&quot;POST&quot;]},&quot;passport.personal.tokens.destroy&quot;:{&quot;uri&quot;:&quot;oauth\/personal-access-tokens\/{token_id}&quot;,&quot;methods&quot;:[&quot;DELETE&quot;],&quot;parameters&quot;:[&quot;token_id&quot;]},&quot;pulse&quot;:{&quot;uri&quot;:&quot;-\/pulse&quot;,&quot;methods&quot;:[&quot;GET&quot;,&quot;HEAD&quot;]},&quot;sanctum.csrf-cookie&quot;:{&quot;uri&quot;:&quot;sanctum\/csrf-cookie&quot;,&quot;methods&quot;:[&quot;GET&quot;,&quot;HEAD&quot;]},&quot;livewire.update&quot;:{&quot;uri&quot;:&quot;livewire\/update&quot;,&quot;methods&quot;:[&quot;POST&quot;]},&quot;livewire.upload-file&quot;:{&quot;uri&quot;:&quot;livewire\/upload-file&quot;,&quot;methods&quot;:[&quot;POST&quot;]},&quot;livewire.preview-file&quot;:{&quot;uri&quot;:&quot;livewire\/preview-file\/{filename}&quot;,&quot;methods&quot;:[&quot;GET&quot;,&quot;HEAD&quot;],&quot;parameters&quot;:[&quot;filename&quot;]},&quot;log-viewer.hosts&quot;:{&quot;uri&quot;:&quot;system\/log-viewer\/api\/hosts&quot;,&quot;methods&quot;:[&quot;GET&quot;,&quot;HEAD&quot;]},&quot;log-viewer.folders&quot;:{&quot;uri&quot;:&quot;system\/log-viewer\/api\/folders&quot;,&quot;methods&quot;:[&quot;GET&quot;,&quot;HEAD&quot;]},&quot;log-viewer.folders.request-download&quot;:{&quot;uri&quot;:&quot;system\/log-viewer\/api\/folders\/{folderIdentifier}\/download\/request&quot;,&quot;methods&quot;:[&quot;GET&quot;,&quot;HEAD&quot;],&quot;parameters&quot;:[&quot;folderIdentifier&quot;]},&quot;log-viewer.folders.clear-cache&quot;:{&quot;uri&quot;:&quot;system\/log-viewer\/api\/folders\/{folderIdentifier}\/clear-cache&quot;,&quot;methods&quot;:[&quot;POST&quot;],&quot;parameters&quot;:[&quot;folderIdentifier&quot;]},&quot;log-viewer.folders.delete&quot;:{&quot;uri&quot;:&quot;system\/log-viewer\/api\/folders\/{folderIdentifier}&quot;,&quot;methods&quot;:[&quot;DELETE&quot;],&quot;parameters&quot;:[&quot;folderIdentifier&quot;]},&quot;log-viewer.files&quot;:{&quot;uri&quot;:&quot;system\/log-viewer\/api\/files&quot;,&quot;methods&quot;:[&quot;GET&quot;,&quot;HEAD&quot;]},&quot;log-viewer.files.request-download&quot;:{&quot;uri&quot;:&quot;system\/log-viewer\/api\/files\/{fileIdentifier}\/download\/request&quot;,&quot;methods&quot;:[&quot;GET&quot;,&quot;HEAD&quot;],&quot;parameters&quot;:[&quot;fileIdentifier&quot;]},&quot;log-viewer.files.clear-cache&quot;:{&quot;uri&quot;:&quot;system\/log-viewer\/api\/files\/{fileIdentifier}\/clear-cache&quot;,&quot;methods&quot;:[&quot;POST&quot;],&quot;parameters&quot;:[&quot;fileIdentifier&quot;]},&quot;log-viewer.files.delete&quot;:{&quot;uri&quot;:&quot;system\/log-viewer\/api\/files\/{fileIdentifier}&quot;,&quot;methods&quot;:[&quot;DELETE&quot;],&quot;parameters&quot;:[&quot;fileIdentifier&quot;]},&quot;log-viewer.files.clear-cache-all&quot;:{&quot;uri&quot;:&quot;system\/log-viewer\/api\/clear-cache-all&quot;,&quot;methods&quot;:[&quot;POST&quot;]},&quot;log-viewer.files.delete-multiple-files&quot;:{&quot;uri&quot;:&quot;system\/log-viewer\/api\/delete-multiple-files&quot;,&quot;methods&quot;:[&quot;POST&quot;]},&quot;log-viewer.logs&quot;:{&quot;uri&quot;:&quot;system\/log-viewer\/api\/logs&quot;,&quot;methods&quot;:[&quot;GET&quot;,&quot;HEAD&quot;]},&quot;log-viewer.folders.download&quot;:{&quot;uri&quot;:&quot;system\/log-viewer\/api\/folders\/{folderIdentifier}\/download&quot;,&quot;methods&quot;:[&quot;GET&quot;,&quot;HEAD&quot;],&quot;parameters&quot;:[&quot;folderIdentifier&quot;]},&quot;log-viewer.files.download&quot;:{&quot;uri&quot;:&quot;system\/log-viewer\/api\/files\/{fileIdentifier}\/download&quot;,&quot;methods&quot;:[&quot;GET&quot;,&quot;HEAD&quot;],&quot;parameters&quot;:[&quot;fileIdentifier&quot;]},&quot;log-viewer.index&quot;:{&quot;uri&quot;:&quot;system\/log-viewer\/{view?}&quot;,&quot;methods&quot;:[&quot;GET&quot;,&quot;HEAD&quot;],&quot;wheres&quot;:{&quot;view&quot;:&quot;(.*)&quot;},&quot;parameters&quot;:[&quot;view&quot;]},&quot;ignition.healthCheck&quot;:{&quot;uri&quot;:&quot;_ignition\/health-check&quot;,&quot;methods&quot;:[&quot;GET&quot;,&quot;HEAD&quot;]},&quot;ignition.executeSolution&quot;:{&quot;uri&quot;:&quot;_ignition\/execute-solution&quot;,&quot;methods&quot;:[&quot;POST&quot;]},&quot;ignition.updateConfig&quot;:{&quot;uri&quot;:&quot;_ignition\/update-config&quot;,&quot;methods&quot;:[&quot;POST&quot;]},&quot;api.albums.index&quot;:{&quot;uri&quot;:&quot;api\/libraries\/{library}\/albums&quot;,&quot;methods&quot;:[&quot;GET&quot;,&quot;HEAD&quot;],&quot;parameters&quot;:[&quot;library&quot;],&quot;bindings&quot;:{&quot;library&quot;:&quot;slug&quot;}},&quot;api.albums.show&quot;:{&quot;uri&quot;:&quot;api\/libraries\/{library}\/albums\/{album}&quot;,&quot;methods&quot;:[&quot;GET&quot;,&quot;HEAD&quot;],&quot;parameters&quot;:[&quot;library&quot;,&quot;album&quot;],&quot;bindings&quot;:{&quot;library&quot;:&quot;slug&quot;,&quot;album&quot;:&quot;slug&quot;}},&quot;api.artists.index&quot;:{&quot;uri&quot;:&quot;api\/libraries\/{library}\/artists&quot;,&quot;methods&quot;:[&quot;GET&quot;,&quot;HEAD&quot;],&quot;parameters&quot;:[&quot;library&quot;]},&quot;api.artists.show&quot;:{&quot;uri&quot;:&quot;api\/libraries\/{library}\/artists\/{artist}&quot;,&quot;methods&quot;:[&quot;GET&quot;,&quot;HEAD&quot;],&quot;parameters&quot;:[&quot;library&quot;,&quot;artist&quot;],&quot;bindings&quot;:{&quot;artist&quot;:&quot;slug&quot;}},&quot;auth.login&quot;:{&quot;uri&quot;:&quot;api\/auth\/login&quot;,&quot;methods&quot;:[&quot;POST&quot;]},&quot;auth.refreshToken&quot;:{&quot;uri&quot;:&quot;api\/auth\/refreshToken&quot;,&quot;methods&quot;:[&quot;POST&quot;]},&quot;auth.streamToken&quot;:{&quot;uri&quot;:&quot;api\/auth\/streamToken&quot;,&quot;methods&quot;:[&quot;POST&quot;]},&quot;auth.register&quot;:{&quot;uri&quot;:&quot;api\/auth\/register&quot;,&quot;methods&quot;:[&quot;POST&quot;]},&quot;auth.forgotPassword&quot;:{&quot;uri&quot;:&quot;api\/auth\/forgotPassword&quot;,&quot;methods&quot;:[&quot;POST&quot;]},&quot;auth.resetPassword&quot;:{&quot;uri&quot;:&quot;api\/auth\/resetPassword&quot;,&quot;methods&quot;:[&quot;POST&quot;]},&quot;auth.verifyEmail&quot;:{&quot;uri&quot;:&quot;api\/auth\/verify\/{id}\/{hash}&quot;,&quot;methods&quot;:[&quot;POST&quot;],&quot;parameters&quot;:[&quot;id&quot;,&quot;hash&quot;]},&quot;auth.logout&quot;:{&quot;uri&quot;:&quot;api\/auth\/logout&quot;,&quot;methods&quot;:[&quot;POST&quot;]},&quot;api.genres.index&quot;:{&quot;uri&quot;:&quot;api\/genres&quot;,&quot;methods&quot;:[&quot;GET&quot;,&quot;HEAD&quot;]},&quot;api.genres.show&quot;:{&quot;uri&quot;:&quot;api\/genres\/{genre}&quot;,&quot;methods&quot;:[&quot;GET&quot;,&quot;HEAD&quot;],&quot;parameters&quot;:[&quot;genre&quot;],&quot;bindings&quot;:{&quot;genre&quot;:&quot;slug&quot;}},&quot;api.genres.update&quot;:{&quot;uri&quot;:&quot;api\/genres\/{genre}&quot;,&quot;methods&quot;:[&quot;PATCH&quot;],&quot;parameters&quot;:[&quot;genre&quot;],&quot;bindings&quot;:{&quot;genre&quot;:&quot;slug&quot;}},&quot;api.genres.destroy&quot;:{&quot;uri&quot;:&quot;api\/genres\/{genre}&quot;,&quot;methods&quot;:[&quot;DELETE&quot;],&quot;parameters&quot;:[&quot;genre&quot;],&quot;bindings&quot;:{&quot;genre&quot;:&quot;slug&quot;}},&quot;api.image.serve&quot;:{&quot;uri&quot;:&quot;api\/images\/{image}&quot;,&quot;methods&quot;:[&quot;GET&quot;,&quot;HEAD&quot;],&quot;parameters&quot;:[&quot;image&quot;],&quot;bindings&quot;:{&quot;image&quot;:&quot;public_id&quot;}},&quot;api.job.library-scan&quot;:{&quot;uri&quot;:&quot;api\/jobs\/scanLibrary\/{slug}&quot;,&quot;methods&quot;:[&quot;POST&quot;],&quot;parameters&quot;:[&quot;slug&quot;]},&quot;api.libraries.index&quot;:{&quot;uri&quot;:&quot;api\/libraries&quot;,&quot;methods&quot;:[&quot;GET&quot;,&quot;HEAD&quot;]},&quot;api.library.create&quot;:{&quot;uri&quot;:&quot;api\/libraries&quot;,&quot;methods&quot;:[&quot;POST&quot;]},&quot;api.library.show&quot;:{&quot;uri&quot;:&quot;api\/libraries\/{slug}&quot;,&quot;methods&quot;:[&quot;GET&quot;,&quot;HEAD&quot;],&quot;parameters&quot;:[&quot;slug&quot;]},&quot;api.library.update&quot;:{&quot;uri&quot;:&quot;api\/libraries\/{slug}&quot;,&quot;methods&quot;:[&quot;PATCH&quot;],&quot;parameters&quot;:[&quot;slug&quot;]},&quot;api.library.delete&quot;:{&quot;uri&quot;:&quot;api\/libraries\/{slug}&quot;,&quot;methods&quot;:[&quot;DELETE&quot;],&quot;parameters&quot;:[&quot;slug&quot;]},&quot;api.opcache.getConfig&quot;:{&quot;uri&quot;:&quot;api\/opcache\/config&quot;,&quot;methods&quot;:[&quot;GET&quot;,&quot;HEAD&quot;]},&quot;api.opcache.clear&quot;:{&quot;uri&quot;:&quot;api\/opcache\/clear&quot;,&quot;methods&quot;:[&quot;POST&quot;]},&quot;api.opcache.compile&quot;:{&quot;uri&quot;:&quot;api\/opcache\/compile&quot;,&quot;methods&quot;:[&quot;POST&quot;]},&quot;api.queue-metrics.show&quot;:{&quot;uri&quot;:&quot;api\/queue-metrics&quot;,&quot;methods&quot;:[&quot;GET&quot;,&quot;HEAD&quot;]},&quot;api.queue-metrics.queues&quot;:{&quot;uri&quot;:&quot;api\/queue-metrics\/queues&quot;,&quot;methods&quot;:[&quot;GET&quot;,&quot;HEAD&quot;]},&quot;api.queue-metrics.metrics&quot;:{&quot;uri&quot;:&quot;api\/queue-metrics\/metrics&quot;,&quot;methods&quot;:[&quot;GET&quot;,&quot;HEAD&quot;]},&quot;api.queue-metrics.retry-job&quot;:{&quot;uri&quot;:&quot;api\/queue-metrics\/retry\/{id}&quot;,&quot;methods&quot;:[&quot;POST&quot;],&quot;parameters&quot;:[&quot;id&quot;]},&quot;api.queue-metrics.delete&quot;:{&quot;uri&quot;:&quot;api\/queue-metrics\/{id}&quot;,&quot;methods&quot;:[&quot;DELETE&quot;],&quot;parameters&quot;:[&quot;id&quot;]},&quot;api.queue-metrics.purge&quot;:{&quot;uri&quot;:&quot;api\/queue-metrics\/purge&quot;,&quot;methods&quot;:[&quot;DELETE&quot;]},&quot;api.songs.index&quot;:{&quot;uri&quot;:&quot;api\/libraries\/{library}\/songs&quot;,&quot;methods&quot;:[&quot;GET&quot;,&quot;HEAD&quot;],&quot;parameters&quot;:[&quot;library&quot;],&quot;bindings&quot;:{&quot;library&quot;:&quot;slug&quot;}},&quot;api.songs.show&quot;:{&quot;uri&quot;:&quot;api\/libraries\/{library}\/songs\/{publicId}&quot;,&quot;methods&quot;:[&quot;GET&quot;,&quot;HEAD&quot;],&quot;parameters&quot;:[&quot;library&quot;,&quot;publicId&quot;],&quot;bindings&quot;:{&quot;library&quot;:&quot;slug&quot;}},&quot;api.songs.stream&quot;:{&quot;uri&quot;:&quot;api\/libraries\/{library}\/songs\/stream\/song\/{song}\/direct&quot;,&quot;methods&quot;:[&quot;GET&quot;,&quot;HEAD&quot;],&quot;parameters&quot;:[&quot;library&quot;,&quot;song&quot;],&quot;bindings&quot;:{&quot;library&quot;:&quot;slug&quot;,&quot;song&quot;:&quot;public_id&quot;}},&quot;api.system-info.php&quot;:{&quot;uri&quot;:&quot;api\/system-info&quot;,&quot;methods&quot;:[&quot;GET&quot;,&quot;HEAD&quot;]},&quot;api.system-info.sys&quot;:{&quot;uri&quot;:&quot;api\/system-info\/sys&quot;,&quot;methods&quot;:[&quot;GET&quot;,&quot;HEAD&quot;]},&quot;api.users.index&quot;:{&quot;uri&quot;:&quot;api\/users&quot;,&quot;methods&quot;:[&quot;GET&quot;,&quot;HEAD&quot;]},&quot;api.users.store&quot;:{&quot;uri&quot;:&quot;api\/users&quot;,&quot;methods&quot;:[&quot;POST&quot;]},&quot;api.users.update&quot;:{&quot;uri&quot;:&quot;api\/users\/{user}&quot;,&quot;methods&quot;:[&quot;PATCH&quot;],&quot;parameters&quot;:[&quot;user&quot;],&quot;bindings&quot;:{&quot;user&quot;:&quot;id&quot;}},&quot;api.users.me&quot;:{&quot;uri&quot;:&quot;api\/users\/me&quot;,&quot;methods&quot;:[&quot;GET&quot;,&quot;HEAD&quot;]},&quot;api.users.show&quot;:{&quot;uri&quot;:&quot;api\/users\/{user}&quot;,&quot;methods&quot;:[&quot;GET&quot;,&quot;HEAD&quot;],&quot;parameters&quot;:[&quot;user&quot;],&quot;bindings&quot;:{&quot;user&quot;:&quot;id&quot;}},&quot;api.users.destroy&quot;:{&quot;uri&quot;:&quot;api\/users\/{user}&quot;,&quot;methods&quot;:[&quot;DELETE&quot;],&quot;parameters&quot;:[&quot;user&quot;]},&quot;auth.passkey.options&quot;:{&quot;uri&quot;:&quot;webauthn\/passkey&quot;,&quot;methods&quot;:[&quot;GET&quot;,&quot;HEAD&quot;]},&quot;auth.passkey.login&quot;:{&quot;uri&quot;:&quot;webauthn\/passkey&quot;,&quot;methods&quot;:[&quot;POST&quot;]},&quot;auth.passkey.register-option&quot;:{&quot;uri&quot;:&quot;webauthn\/passkey\/register&quot;,&quot;methods&quot;:[&quot;GET&quot;,&quot;HEAD&quot;]},&quot;auth.passkey.register&quot;:{&quot;uri&quot;:&quot;webauthn\/passkey\/register&quot;,&quot;methods&quot;:[&quot;POST&quot;]},&quot;mailbook.dashboard&quot;:{&quot;uri&quot;:&quot;mailbook&quot;,&quot;methods&quot;:[&quot;GET&quot;,&quot;HEAD&quot;]},&quot;mailbook.content&quot;:{&quot;uri&quot;:&quot;mailbook\/content&quot;,&quot;methods&quot;:[&quot;GET&quot;,&quot;HEAD&quot;]},&quot;mailbook.send&quot;:{&quot;uri&quot;:&quot;mailbook\/send&quot;,&quot;methods&quot;:[&quot;GET&quot;,&quot;HEAD&quot;]},&quot;dbg&quot;:{&quot;uri&quot;:&quot;dbg&quot;,&quot;methods&quot;:[&quot;GET&quot;,&quot;HEAD&quot;]},&quot;webui&quot;:{&quot;uri&quot;:&quot;{any}&quot;,&quot;methods&quot;:[&quot;GET&quot;,&quot;HEAD&quot;],&quot;wheres&quot;:{&quot;any&quot;:&quot;^(?!api|docs|storage|public-api|clockwork|system|2fa|login|dbg|jobs).*$&quot;},&quot;parameters&quot;:[&quot;any&quot;]},&quot;scramble.docs.ui&quot;:{&quot;uri&quot;:&quot;docs\/api&quot;,&quot;methods&quot;:[&quot;GET&quot;,&quot;HEAD&quot;]},&quot;scramble.docs.document&quot;:{&quot;uri&quot;:&quot;docs\/api.json&quot;,&quot;methods&quot;:[&quot;GET&quot;,&quot;HEAD&quot;]}}};
if (typeof window !== &apos;undefined&apos; &amp;&amp; typeof window.Ziggy !== &apos;undefined&apos;) {
  Object.assign(Ziggy.routes, window.Ziggy.routes);
}
export { Ziggy };</file><file path="start_dev.sh">#!/usr/bin/env bash
/var/www/html/artisan octane:start --watch --log-level=debug --host=0.0.0.0 --port=8000 --workers=auto --task-workers=auto --max-requests=250</file><file path=".gitattributes">* text=auto eol=lf

*.blade.php diff=html
*.css diff=css
*.html diff=html
*.md diff=markdown
*.php diff=php

/.github export-ignore
CHANGELOG.md export-ignore
.styleci.yml export-ignore</file><file path="app/Actions/Fortify/PasswordValidationRules.php">&lt;?php
namespace App\Actions\Fortify;
use Illuminate\Validation\Rules\Password;
trait PasswordValidationRules
{
    /**
     * Get the validation rules used to validate passwords.
     *
     * @return array&lt;int, \Illuminate\Contracts\Validation\Rule|array&lt;mixed&gt;|string&gt;
     */
    protected function passwordRules(): array
    {
        return [&apos;required&apos;, &apos;string&apos;, Password::default(), &apos;confirmed&apos;];
    }
}</file><file path="app/Actions/Tokens/PruneExpiredTokens.php">&lt;?php
namespace App\Actions\Tokens;
use App\Services\AuthTokenService;
use JetBrains\PhpStorm\ArrayShape;
class PruneExpiredTokens
{
    public function __construct(private readonly AuthTokenService $authTokenManager)
    {
    }
    #[ArrayShape([
        &apos;status&apos;  =&gt; &quot;string&quot;,
        &apos;removed&apos; =&gt; &apos;int&apos;,
        &apos;context&apos; =&gt; &apos;mixed&apos;,
    ])]
    public function run(): array
    {
        $count = $this-&gt;authTokenManager-&gt;getExpiredTokenCount();
        $res = $this-&gt;authTokenManager-&gt;pruneExpiredTokens();
        return [
            &apos;status&apos;  =&gt; &apos;success&apos;,
            &apos;removed&apos; =&gt; $count,
            &apos;context&apos; =&gt; $res,
        ];
    }
}</file><file path="app/Auth/AclFactory.php">&lt;?php
namespace App\Auth;
use Spatie\Permission\Models\Permission;
class AclFactory
{
    public const array CRUD_METHODS = [&apos;viewAny&apos;, &apos;update&apos;, &apos;store&apos;, &apos;delete&apos;, &apos;forceDelete&apos;];
    public const string SEPARATOR = &apos;.&apos;;
    public const array GUARDS = [&apos;api&apos;, &apos;web&apos;];
    public static function createPermission(string $name, string $permission)
    {
        Permission::create([&apos;name&apos; =&gt; $name . AclFactory::SEPARATOR . $permission]);
    }
    public static function createPermissionsFor(string $subject)
    {
        $models = [];
        foreach (self::CRUD_METHODS as $method) {
            $models[] = Permission::create([&apos;name&apos; =&gt; $subject . AclFactory::SEPARATOR . $method]);
        }
        return $models;
    }
}</file><file path="app/Console/Commands/Auth/ManageSanctumTokens.php">&lt;?php
namespace App\Console\Commands\Auth;
use App\Models\PersonalAccessToken;
use Illuminate\Console\Command;
use Illuminate\Support\Facades\Cache;
class ManageSanctumTokens extends Command
{
    /**
     * The name and signature of the console command.
     *
     * @var string
     */
    protected $signature = &apos;sanctum:tokens
                            {action : Action to perform (clean, cache, clear)}&apos;;
    /**
     * The console command description.
     *
     * @var string
     */
    protected $description = &apos;Manage Sanctum tokens (clean expired, cache all, clear cache)&apos;;
    /**
     * Execute the console command.
     *
     * @return int
     */
    public function handle()
    {
        $action = $this-&gt;argument(&apos;action&apos;);
        switch ($action) {
            case &apos;clean&apos;:
                return $this-&gt;cleanExpiredTokens();
            case &apos;cache&apos;:
                return $this-&gt;cacheAllTokens();
            case &apos;clear&apos;:
                return $this-&gt;clearTokenCache();
            case &apos;stats&apos;:
                return $this-&gt;showStats();
            default:
                $this-&gt;error(&quot;Unknown action: {$action}&quot;);
                return 1;
        }
    }
    /**
     * Remove expired tokens.
     */
    protected function cleanExpiredTokens()
    {
        $count = PersonalAccessToken::whereNotNull(&apos;expires_at&apos;)
            -&gt;where(&apos;expires_at&apos;, &apos;&lt;&apos;, now())
            -&gt;delete();
        $this-&gt;info(&quot;{$count} expired tokens deleted&quot;);
        return 0;
    }
    /**
     * Cache all active tokens.
     */
    protected function cacheAllTokens()
    {
        $cacheConfig = config(&apos;sanctum.token_cache&apos;);
        if (!$cacheConfig[&apos;enabled&apos;]) {
            $this-&gt;error(&quot;Token caching is disabled in config&quot;);
            return 1;
        }
        $tokens = PersonalAccessToken::whereNull(&apos;expires_at&apos;)
            -&gt;orWhere(&apos;expires_at&apos;, &apos;&gt;&apos;, now())
            -&gt;get();
        $count = 0;
        $ttl = is_numeric($cacheConfig[&apos;ttl&apos;]) ? (int) $cacheConfig[&apos;ttl&apos;] : null;
        foreach ($tokens as $token) {
            $cacheKey = $cacheConfig[&apos;prefix&apos;] . $token-&gt;id;
            Cache::store($cacheConfig[&apos;store&apos;])-&gt;put(
                $cacheKey,
                $token,
                $ttl ? now()-&gt;addMinutes($ttl) : null
            );
            $count++;
        }
        $this-&gt;info(&quot;{$count} tokens cached in Redis&quot;);
        return 0;
    }
    /**
     * Clear token cache.
     */
    protected function clearTokenCache()
    {
        $cacheConfig = config(&apos;sanctum.token_cache&apos;);
        $prefix = $cacheConfig[&apos;prefix&apos;];
        // Safer approach - only clear tokens with our prefix
        $tokens = PersonalAccessToken::all();
        $count = 0;
        foreach ($tokens as $token) {
            $cacheKey = $prefix . $token-&gt;id;
            Cache::store($cacheConfig[&apos;store&apos;])-&gt;forget($cacheKey);
            $count++;
        }
        $this-&gt;info(&quot;{$count} tokens cleared from cache&quot;);
        return 0;
    }
    /**
     * Show token stats.
     */
    protected function showStats()
    {
        $totalTokens = PersonalAccessToken::count();
        $activeTokens = PersonalAccessToken::whereNull(&apos;expires_at&apos;)
            -&gt;orWhere(&apos;expires_at&apos;, &apos;&gt;&apos;, now())
            -&gt;count();
        $expiredTokens = PersonalAccessToken::whereNotNull(&apos;expires_at&apos;)
            -&gt;where(&apos;expires_at&apos;, &apos;&lt;&apos;, now())
            -&gt;count();
        $this-&gt;info(&quot;Token Statistics:&quot;);
        $this-&gt;table(
            [&apos;Total Tokens&apos;, &apos;Active Tokens&apos;, &apos;Expired Tokens&apos;],
            [[$totalTokens, $activeTokens, $expiredTokens]]
        );
        $cacheConfig = config(&apos;sanctum.token_cache&apos;);
        $this-&gt;info(&quot;Cache Configuration:&quot;);
        $this-&gt;table(
            [&apos;Setting&apos;, &apos;Value&apos;],
            [
                [&apos;Enabled&apos;, $cacheConfig[&apos;enabled&apos;] ? &apos;Yes&apos; : &apos;No&apos;],
                [&apos;Store&apos;, $cacheConfig[&apos;store&apos;]],
                [&apos;Prefix&apos;, $cacheConfig[&apos;prefix&apos;]],
                [&apos;TTL (minutes)&apos;, $cacheConfig[&apos;ttl&apos;] ?? &apos;No expiration&apos;],
            ]
        );
        return 0;
    }
}</file><file path="app/Console/Commands/DeployFreshCommand.php">&lt;?php
namespace App\Console\Commands;
use Illuminate\Console\Command;
class DeployFreshCommand extends Command
{
    /**
     * The name and signature of the console command.
     *
     * @var string
     */
    protected $signature = &apos;deploy:fresh&apos;;
    /**
     * The console command description.
     *
     * @var string
     */
    protected $description = &apos;Command description&apos;;
    /**
     * Execute the console command.
     */
    public function handle()
    {
        $this-&gt;call(&apos;migrate:fresh&apos;, [
            &apos;--force&apos; =&gt; true,
        ]);
        $this-&gt;call(&apos;optimize:clear&apos;);
        $this-&gt;call(&apos;event:clear&apos;);
        $this-&gt;call(&apos;view:clear&apos;);
    }
}</file><file path="app/Console/Commands/Filter/CreateFilterCommand.php">&lt;?php
namespace App\Console\Commands\Filter;
use Illuminate\Console\Command;
use Illuminate\Console\GeneratorCommand;
class CreateFilterCommand extends GeneratorCommand
{
    /**
     * The name and signature of the console command.
     *
     * @var string
     */
    protected $signature = &apos;make:filter {name}&apos;;
    /**
     * The console command description.
     *
     * @var string
     */
    protected $description = &apos;Create a new filter&apos;;
    protected function getStub()
    {
        return app_path(&apos;../stubs/filter.stub&apos;);
    }
    protected function getDefaultNamespace($rootNamespace)
    {
        return parent::getDefaultNamespace($rootNamespace) . &apos;\Filters&apos;;
    }
}</file><file path="app/Console/Commands/GenerateMbModels.php">&lt;?php
namespace App\Console\Commands;
use Illuminate\Console\Command;
use Illuminate\Support\Str;
class GenerateMbModels extends Command
{
    /**
     * The name and signature of the console command.
     *
     * @var string
     */
    protected $signature = &apos;mbb&apos;;
    /**
     * The console command description.
     *
     * @var string
     */
    protected $description = &apos;Generate PHP models from an XML schema (RNG)&apos;;
    /**
     * A map to keep track of schema definitions.
     *
     * @var array
     */
    protected $schemaDefinitions = [];
    /**
     * Execute the console command.
     *
     * @return void
     */
    public function handle()
    {
        $schemaFile = storage_path(&apos;app/schemas/musicbrainz_mmd-2.0.rng&apos;);
        $modelsDir = app_path(&apos;Http/Integrations/MusicBrainz/Models&apos;);
        if (!file_exists($schemaFile)) {
            $this-&gt;error(&quot;Schema file not found: $schemaFile&quot;);
            return;
        }
        if (!is_dir($modelsDir)) {
            mkdir($modelsDir, 0777, true);
        }
        $schemas = simplexml_load_file($schemaFile);
        if ($schemas === false) {
            $this-&gt;error(&apos;Failed to load XML schema.&apos;);
            return;
        }
        // Load all schema definitions into a map for quick lookup
        foreach ($schemas-&gt;define as $define) {
            $this-&gt;schemaDefinitions[(string) $define[&apos;name&apos;]] = $define;
        }
        // Generate models from schema definitions
        foreach ($this-&gt;schemaDefinitions as $elementName =&gt; $define) {
            $this-&gt;info(&quot;Processing element: $elementName&quot;);
            $properties = $this-&gt;extractProperties($define, $elementName);
            if (!empty($properties)) {
                $formattedElementName = $this-&gt;formatElementName($elementName);
                $formattedElementName = $this-&gt;removeDefPrefix($formattedElementName);
                // Ensure the class name and root attributes are not included in properties
                $properties = $this-&gt;filterInvalidProperties($formattedElementName, $properties);
                $modelClass = $this-&gt;generateModelClass($formattedElementName, $properties, $this-&gt;schemaDefinitions);
                $fileName = $modelsDir . &apos;/&apos; . $formattedElementName . &apos;.php&apos;;
                file_put_contents($fileName, $modelClass);
                $this-&gt;info(&quot;Generated model: $fileName&quot;);
            } else {
                $this-&gt;info(&quot;No properties found for element: $elementName&quot;);
            }
        }
        $this-&gt;info(&quot;Model generation complete.&quot;);
    }
    /**
     * Extract properties (both elements and attributes) from the schema definition.
     *
     * @param \SimpleXMLElement $define
     * @param string $context
     * @param int $depth
     * @return array
     */
    protected function extractProperties($define, $context = &apos;&apos;, $depth = 0)
    {
        $properties = [];
        $visited = [];
        // Avoid deep recursion
        $depthLimit = 10;
        if ($depth &gt; $depthLimit) {
            $this-&gt;warn(&quot;Recursion depth limit reached for element: $context&quot;);
            return [];
        }
        $this-&gt;extractElementProperties($properties, $define, $visited, $depth);
        // Handle nested structures like &lt;ref&gt;, &lt;optional&gt;, etc.
        foreach ($define-&gt;children() as $child) {
            $this-&gt;extractElementProperties($properties, $child, $visited, $depth);
        }
        return array_unique($properties);
    }
    /**
     * Extracts properties from elements and attributes and adds them to the properties array.
     *
     * @param array $properties
     * @param \SimpleXMLElement $element
     * @param array $visited
     * @param int $depth
     * @return void
     */
    private function extractElementProperties(array &amp;$properties, $element, array &amp;$visited, $depth)
    {
        if (isset($element-&gt;element)) {
            foreach ($element-&gt;element as $childElement) {
                if (isset($childElement[&apos;name&apos;])) {
                    $properties[] = (string) $childElement[&apos;name&apos;];
                }
                $this-&gt;extractElementProperties($properties, $childElement, $visited, $depth + 1);
            }
        }
        if (isset($element-&gt;attribute)) {
            foreach ($element-&gt;attribute as $childAttribute) {
                if (isset($childAttribute[&apos;name&apos;])) {
                    $properties[] = (string) $childAttribute[&apos;name&apos;];
                }
            }
        }
        if (isset($element-&gt;ref)) {
            foreach ($element-&gt;ref as $ref) {
                $refName = (string) $ref[&apos;name&apos;];
                // Avoid infinite recursion
                if (isset($visited[$refName])) {
                    continue;
                }
                $visited[$refName] = true;
                if (isset($this-&gt;schemaDefinitions[$refName])) {
                    $this-&gt;info(&quot;Resolving reference: $refName&quot;);
                    $this-&gt;extractElementProperties($properties, $this-&gt;schemaDefinitions[$refName], $visited, $depth + 1);
                } else {
                    $this-&gt;info(&quot;Reference not found: $refName&quot;);
                }
            }
        }
        if (isset($element-&gt;optional)) {
            foreach ($element-&gt;optional as $optional) {
                $this-&gt;extractElementProperties($properties, $optional, $visited, $depth + 1);
            }
        }
        if (isset($element-&gt;zeroOrMore)) {
            foreach ($element-&gt;zeroOrMore as $zeroOrMore) {
                $this-&gt;extractElementProperties($properties, $zeroOrMore, $visited, $depth + 1);
            }
        }
    }
    /**
     * Format the element name to create valid PHP class and file names.
     *
     * @param string $elementName
     * @return string
     */
    private function formatElementName(string $elementName): string
    {
        return Str::studly(str_replace([&apos;_&apos;, &apos;-&apos;], &apos; &apos;, $elementName));
    }
    /**
     * Remove the &apos;Def&apos; prefix from the class name.
     *
     * @param string $className
     * @return string
     */
    private function removeDefPrefix(string $className): string
    {
        return Str::startsWith($className, &apos;Def&apos;) ? Str::replaceFirst(&apos;Def&apos;, &apos;&apos;, $className) : $className;
    }
    /**
     * Format attribute names to create valid PHP variable names.
     *
     * @param string $attributeName
     * @return string
     */
    private function formatAttributeName(string $attributeName): string
    {
        return str_replace(&apos;-&apos;, &apos;_&apos;, $attributeName);
    }
    /**
     * Filter out invalid properties (such as the root attribute) from the class properties.
     *
     * @param string $className
     * @param array $properties
     * @return array
     */
    private function filterInvalidProperties(string $className, array $properties): array
    {
        $formattedClassName = lcfirst($this-&gt;formatAttributeName($className));
        return array_filter($properties, function ($property) use ($formattedClassName) {
            return !str_ends_with($property, &apos;-list&apos;) &amp;&amp; $property !== $formattedClassName;
        });
    }
    /**
     * Generate the PHP model class content.
     *
     * @param string $className
     * @param array $properties
     * @param array $schemaDefinitions
     * @return string
     */
    private function generateModelClass(string $className, array $properties, array $schemaDefinitions): string
    {
        $constructorArgs = array_map(function ($attribute) use ($schemaDefinitions) {
            $formattedAttr = $this-&gt;formatAttributeName($attribute);
            // If there&apos;s a matching model for the property, use it as the type
            if (isset($schemaDefinitions[$attribute])) {
                $type = $this-&gt;formatElementName($attribute);
            } else {
                $type = &apos;mixed&apos;; // Default type
            }
            return &quot;public $type \$$formattedAttr&quot;;
        }, $properties);
        $fromApiDataArgs = array_map(function ($attribute) use ($schemaDefinitions) {
            $formattedAttr = $this-&gt;formatAttributeName($attribute);
            if (isset($schemaDefinitions[$attribute])) {
                $typeClass = $this-&gt;formatElementName($attribute);
                return &quot;$formattedAttr: $typeClass::fromApiData(\$data[&apos;$attribute&apos;])&quot;;
            }
            return &quot;$formattedAttr: \$data[&apos;$attribute&apos;] ?? null&quot;;
        }, $properties);
        $constructorArgsStr = implode(&apos;, &apos;, $constructorArgs);
        $fromApiDataArgsStr = implode(&quot;,\n            &quot;, $fromApiDataArgs);
        return &lt;&lt;&lt;PHP
&lt;?php
namespace App\Http\Integrations\MusicBrainz\Models;
use Spatie\LaravelData\Data;
class $className extends Data
{
    public function __construct($constructorArgsStr)
    {
    }
    public static function fromApiData(array \$data): self
    {
        return new self(
            $fromApiDataArgsStr
        );
    }
}
PHP;
    }
}</file><file path="app/Console/Commands/ID3TestCommand.php">&lt;?php
namespace App\Console\Commands;
use Illuminate\Console\Command;
class ID3TestCommand extends Command
{
    /**
     * The name and signature of the console command.
     *
     * @var string
     */
    protected $signature = &apos;id3:test&apos;;
    /**
     * The console command description.
     *
     * @var string
     */
    protected $description = &apos;Command description&apos;;
    /**
     * Execute the console command.
     * @throws \Zend_Media_Id3_Exception
     */
    public function handle()
    {
        $file = &apos;/Users/martin/Music/testlibrary/Headhunterz - Colors/01 - Headhunterz_Tatu - Colors.mp3&apos;;
        $id3 = new \Zend_Media_Id3v2($file);
        dd($id3-&gt;getFrames());
    }
}</file><file path="app/Console/Commands/Insights/PruneInsightRecordsCommand.php">&lt;?php
namespace App\Console\Commands\Insights;
use App\Models\Insight\Gauge;
use App\Models\Insight\Message;
use Illuminate\Console\Command;
use Illuminate\Support\Carbon;
use Illuminate\Support\Str;
class PruneInsightRecordsCommand extends Command
{
    /**
     * The name and signature of the console command.
     *
     * @var string
     */
    protected $signature = &apos;insight:prune-insight-records {datetime : Parsable datetime format}&apos;;
    /**
     * The console command description.
     *
     * @var string
     */
    protected $description = &apos;Delete records older than the given time&apos;;
    /**
     * Execute the console command.
     */
    public function handle()
    {
        $time = Carbon::parse((string)$this-&gt;argument(&apos;datetime&apos;));
        $this-&gt;info(&quot;Deleting messages and gauges older than {$time-&gt;toDateTimeString()}...&quot;);
        $messages = Message::query()
            -&gt;where(&apos;created_at&apos;, &apos;&lt;=&apos;, $time)
            -&gt;get();
        $messages-&gt;each(function (Message $message) {
            $message-&gt;gauges()-&gt;delete();
        });
        $count = Message::query()
            -&gt;where(&apos;created_at&apos;, &apos;&lt;=&apos;, $time)
            -&gt;delete();
        $count += Gauge::query()
            -&gt;where(&apos;created_at&apos;, &apos;&lt;=&apos;, $time)
            -&gt;delete();
        $this-&gt;info($count . &apos; &apos; . Str::plural(&apos;row&apos;) . &apos; deleted.&apos;);
        return 0;
    }
}</file><file path="app/Console/Commands/Music/SyncSmartPlaylists.php">&lt;?php
namespace App\Console\Commands\Music;
use Illuminate\Console\Command;
class SyncSmartPlaylists extends Command
{
    /**
     * The name and signature of the console command.
     *
     * @var string
     */
    protected $signature = &apos;music:sync-smart-playlists&apos;;
    /**
     * The console command description.
     *
     * @var string
     */
    protected $description = &apos;Synchronizes smart playlists according to the rules defined in their configurations&apos;;
    /**
     * Execute the console command.
     */
    public function handle(): void
    {
        dispatch(SyncSmartPlaylists::class)-&gt;withoutDelay();
    }
}</file><file path="app/Console/Commands/PruneLibrariesCommand.php">&lt;?php
namespace App\Console\Commands;
use App\Models\{Album, Artist, Genre, Image, Song};
use Illuminate\Console\Command;
use Illuminate\Support\Facades\DB;
class PruneLibrariesCommand extends Command
{
    /**
     * The name and signature of the console command.
     *
     * @var string
     */
    protected $signature = &apos;prune:libraries&apos;;
    /**
     * The console command description.
     *
     * @var string
     */
    protected $description = &apos;Prune all libraries&apos;;
    /**
     * Execute the console command.
     */
    public function handle()
    {
        DB::table((new Song)-&gt;getTable())-&gt;truncate();
        DB::table((new Album)-&gt;getTable())-&gt;truncate();
        DB::table((new Genre)-&gt;getTable())-&gt;truncate();
        DB::table((new Image)-&gt;getTable())-&gt;truncate();
        DB::table((new Artist)-&gt;getTable())-&gt;truncate();
    }
}</file><file path="app/Console/Commands/QueueMonitor/Concerns/HandlesDateInputs.php">&lt;?php
namespace App\Console\Commands\QueueMonitor\Concerns;
use Carbon\Carbon;
use Carbon\CarbonInterval;
use Illuminate\Console\Command;
trait HandlesDateInputs
{
    public static function parseBeforeDate(Command $command): ?Carbon
    {
        if ($before = $command-&gt;option(&apos;before&apos;)) {
            return Carbon::parse($before);
        }
        if ($beforeDays = $command-&gt;option(&apos;beforeDays&apos;)) {
            return Carbon::now()-&gt;subDays((int)$beforeDays);
        }
        if ($interval = $command-&gt;option(&apos;beforeInterval&apos;)) {
            return Carbon::now()-&gt;sub(
                new CarbonInterval($interval),
            );
        }
        return null;
    }
}</file><file path="app/Console/Commands/Recommendations/GenerateRecommendations.php">&lt;?php
namespace App\Console\Commands\Recommendations;
use App\Modules\Recommendation\Services\RecommendationService;
use Illuminate\Console\Command;
class GenerateRecommendations extends Command
{
    /**
     * The name and signature of the console command.
     *
     * @var string
     */
    protected $signature = &apos;recommendations:generate 
                            {model : The model class to generate recommendations for}
                            {--name= : Optional specific recommendation name to generate}
                            {--fresh : Force regeneration of all recommendations}&apos;;
    /**
     * The console command description.
     *
     * @var string
     */
    protected $description = &apos;Generate model recommendations&apos;;
    /**
     * Execute the console command.
     *
     * @param RecommendationService $recommendationService
     * @return int
     */
    public function handle(RecommendationService $recommendationService)
    {
        $modelClass = $this-&gt;argument(&apos;model&apos;);
        $specificName = $this-&gt;option(&apos;name&apos;);
        $fresh = $this-&gt;option(&apos;fresh&apos;);
        if (!class_exists($modelClass)) {
            $this-&gt;error(&quot;Model class {$modelClass} does not exist&quot;);
            return 1;
        }
        $configMethod = &apos;getRecommendationConfig&apos;;
        if (!method_exists($modelClass, $configMethod)) {
            $this-&gt;error(&quot;Model {$modelClass} does not implement {$configMethod}&quot;);
            return 1;
        }
        $config = $modelClass::$configMethod();
        if (empty($config)) {
            $this-&gt;error(&quot;No recommendation configurations found for {$modelClass}&quot;);
            return 1;
        }
        $this-&gt;info(&quot;Generating recommendations for {$modelClass}&quot;);
        $totalCount = 0;
        if ($specificName) {
            if (!isset($config[$specificName])) {
                $this-&gt;error(&quot;Recommendation configuration &apos;{$specificName}&apos; not found&quot;);
                return 1;
            }
            $algorithm = $config[$specificName][&apos;algorithm&apos;] ?? &apos;unknown&apos;;
            $this-&gt;info(&quot;Generating &apos;{$specificName}&apos; recommendations using {$algorithm} algorithm&quot;);
            $count = $recommendationService-&gt;generateRecommendations($modelClass, $specificName);
            $this-&gt;info(&quot;Generated {$count} recommendations for &apos;{$specificName}&apos;&quot;);
            $totalCount += $count;
        } else {
            $this-&gt;info(&quot;Generating all recommendation types&quot;);
            foreach ($config as $name =&gt; $settings) {
                $algorithm = $settings[&apos;algorithm&apos;] ?? &apos;unknown&apos;;
                $this-&gt;line(&quot;Generating &apos;{$name}&apos; recommendations using {$algorithm} algorithm&quot;);
                $count = $recommendationService-&gt;generateRecommendations($modelClass, $name);
                $this-&gt;line(&quot;Generated {$count} recommendations for &apos;{$name}&apos;&quot;);
                $totalCount += $count;
            }
        }
        $this-&gt;info(&quot;Finished generating a total of {$totalCount} recommendations&quot;);
        return 0;
    }
}</file><file path="app/Console/Commands/Recommendations/SynchronizeRecommendationsCommand.php">&lt;?php
namespace App\Console\Commands\Recommendations;
use App\Models\Song;
use Illuminate\Console\Command;
class SynchronizeRecommendationsCommand extends Command
{
    /**
     * The name and signature of the console command.
     *
     * @var string
     */
    protected $signature = &apos;recommendation:sync&apos;;
    /**
     * The console command description.
     *
     * @var string
     */
    protected $description = &apos;Command description&apos;;
    /**
     * Execute the console command.
     */
    public function handle()
    {
        Song::generateRecommendations(&apos;same_genre&apos;);
    }
}</file><file path="app/Console/Commands/SetupEnvironmentCommand.php">&lt;?php
namespace App\Console\Commands;
use Illuminate\Console\Command;
class SetupEnvironmentCommand extends Command
{
    /**
     * The name and signature of the console command.
     *
     * @var string
     */
    protected $signature = &apos;setup:env&apos;;
    /**
     * The console command description.
     *
     * @var string
     */
    protected $description = &apos;Command description&apos;;
    /**
     * Execute the console command.
     */
    public function handle()
    {
        $this-&gt;info(&apos;Downloading graphiql assets to public directory&apos;);
        $this-&gt;call(&apos;graphiql:download-assets&apos;);
    }
}</file><file path="app/Console/Commands/SyncMetadataCommand.php">&lt;?php
namespace App\Console\Commands;
use App\Jobs\Library\Music\SyncAlbumMetadataJob;
use App\Jobs\Library\Music\SyncArtistMetadataJob;
use App\Jobs\Library\Music\SyncSongMetadataJob;
use App\Models\Album;
use App\Models\Song;
use App\Models\Artist;
use Illuminate\Console\Command;
use Illuminate\Support\Facades\Queue;
class SyncMetadataCommand extends Command
{
    protected $signature = &apos;metadata:sync 
                           {--album=* : Specific album IDs to sync}
                           {--song=* : Specific song IDs to sync}
                           {--artist=* : Specific artist IDs to sync}
                           {--library= : Library ID to sync}
                           {--include-songs : Include songs when syncing albums}
                           {--include-artists : Include artists when syncing albums}
                           {--force : Force update existing metadata}
                           {--batch-size=10 : Number of items to process in each batch}
                           {--queue=default : Queue name for processing jobs}&apos;;
    protected $description = &apos;Sync metadata from external sources (MusicBrainz, Discogs) for albums, songs, and artists&apos;;
    public function handle(): int
    {
        $albumIds = $this-&gt;option(&apos;album&apos;);
        $songIds = $this-&gt;option(&apos;song&apos;);
        $artistIds = $this-&gt;option(&apos;artist&apos;);
        $libraryId = $this-&gt;option(&apos;library&apos;);
        $includeSongs = $this-&gt;option(&apos;include-songs&apos;);
        $includeArtists = $this-&gt;option(&apos;include-artists&apos;);
        $forceUpdate = $this-&gt;option(&apos;force&apos;);
        $batchSize = (int) $this-&gt;option(&apos;batch-size&apos;);
        $queueName = $this-&gt;option(&apos;queue&apos;);
        $totalJobs = 0;
        // Sync specific albums
        if (!empty($albumIds)) {
            $totalJobs += $this-&gt;syncAlbums($albumIds, $forceUpdate, $batchSize, $queueName, $includeSongs, $includeArtists);
        }
        // Sync specific songs
        if (!empty($songIds)) {
            $totalJobs += $this-&gt;syncSongs($songIds, $forceUpdate, $batchSize, $queueName);
        }
        // Sync specific artists
        if (!empty($artistIds)) {
            $totalJobs += $this-&gt;syncArtists($artistIds, $forceUpdate, $batchSize, $queueName);
        }
        // Sync entire library
        if ($libraryId &amp;&amp; empty($albumIds) &amp;&amp; empty($songIds) &amp;&amp; empty($artistIds)) {
            $totalJobs += $this-&gt;syncLibrary($libraryId, $forceUpdate, $batchSize, $queueName, $includeSongs, $includeArtists);
        }
        // If no specific options provided, show help
        if (!$libraryId &amp;&amp; empty($albumIds) &amp;&amp; empty($songIds) &amp;&amp; empty($artistIds)) {
            $this-&gt;error(&apos;Please specify what to sync: --album, --song, --artist, or --library&apos;);
            $this-&gt;line(&apos;Use --help for more information&apos;);
            return self::FAILURE;
        }
        if ($totalJobs &gt; 0) {
            $this-&gt;info(&quot;Queued {$totalJobs} metadata sync jobs.&quot;);
        } else {
            $this-&gt;info(&apos;No items found to sync.&apos;);
        }
        return self::SUCCESS;
    }
    private function syncAlbums(array $albumIds, bool $forceUpdate, int $batchSize, string $queueName, bool $includeSongs = false, bool $includeArtists = false): int
    {
        $query = Album::query()-&gt;whereIn(&apos;id&apos;, $albumIds);
        $totalAlbums = $query-&gt;count();
        if ($totalAlbums === 0) {
            $this-&gt;warn(&apos;No albums found with the specified IDs.&apos;);
            return 0;
        }
        $this-&gt;info(&quot;Found {$totalAlbums} albums to sync.&quot;);
        $bar = $this-&gt;output-&gt;createProgressBar($totalAlbums);
        $bar-&gt;start();
        $jobCount = 0;
        $query-&gt;chunk($batchSize, function ($albums) use ($forceUpdate, $queueName, $bar, &amp;$jobCount, $includeSongs, $includeArtists) {
            foreach ($albums as $album) {
                SyncAlbumMetadataJob::dispatch($album-&gt;id, $forceUpdate)
                    -&gt;onQueue($queueName);
                $jobCount++;
                // Optionally sync songs in the album
                if ($includeSongs) {
                    foreach ($album-&gt;songs as $song) {
                        SyncSongMetadataJob::dispatch($song-&gt;id, $forceUpdate)
                            -&gt;onQueue($queueName);
                        $jobCount++;
                    }
                }
                // Optionally sync artists in the album
                if ($includeArtists) {
                    foreach ($album-&gt;artists as $artist) {
                        SyncArtistMetadataJob::dispatch($artist-&gt;id, $forceUpdate)
                            -&gt;onQueue($queueName);
                        $jobCount++;
                    }
                }
                $bar-&gt;advance();
            }
        });
        $bar-&gt;finish();
        $this-&gt;newLine();
        return $jobCount;
    }
    private function syncSongs(array $songIds, bool $forceUpdate, int $batchSize, string $queueName): int
    {
        $query = Song::query()-&gt;whereIn(&apos;id&apos;, $songIds);
        $totalSongs = $query-&gt;count();
        if ($totalSongs === 0) {
            $this-&gt;warn(&apos;No songs found with the specified IDs.&apos;);
            return 0;
        }
        $this-&gt;info(&quot;Found {$totalSongs} songs to sync.&quot;);
        $bar = $this-&gt;output-&gt;createProgressBar($totalSongs);
        $bar-&gt;start();
        $jobCount = 0;
        $query-&gt;chunk($batchSize, function ($songs) use ($forceUpdate, $queueName, $bar, &amp;$jobCount) {
            foreach ($songs as $song) {
                SyncSongMetadataJob::dispatch($song-&gt;id, $forceUpdate)
                    -&gt;onQueue($queueName);
                $jobCount++;
                $bar-&gt;advance();
            }
        });
        $bar-&gt;finish();
        $this-&gt;newLine();
        return $jobCount;
    }
    private function syncArtists(array $artistIds, bool $forceUpdate, int $batchSize, string $queueName): int
    {
        $query = Artist::query()-&gt;whereIn(&apos;id&apos;, $artistIds);
        $totalArtists = $query-&gt;count();
        if ($totalArtists === 0) {
            $this-&gt;warn(&apos;No artists found with the specified IDs.&apos;);
            return 0;
        }
        $this-&gt;info(&quot;Found {$totalArtists} artists to sync.&quot;);
        $bar = $this-&gt;output-&gt;createProgressBar($totalArtists);
        $bar-&gt;start();
        $jobCount = 0;
        $query-&gt;chunk($batchSize, function ($artists) use ($forceUpdate, $queueName, $bar, &amp;$jobCount) {
            foreach ($artists as $artist) {
                SyncArtistMetadataJob::dispatch($artist-&gt;id, $forceUpdate)
                    -&gt;onQueue($queueName);
                $jobCount++;
                $bar-&gt;advance();
            }
        });
        $bar-&gt;finish();
        $this-&gt;newLine();
        return $jobCount;
    }
    private function syncLibrary(int $libraryId, bool $forceUpdate, int $batchSize, string $queueName, bool $includeSongs = false, bool $includeArtists = false): int
    {
        $this-&gt;info(&quot;Syncing metadata for library ID: {$libraryId}&quot;);
        $jobCount = 0;
        // Sync all albums in the library
        $albumQuery = Album::query()-&gt;where(&apos;library_id&apos;, $libraryId);
        $totalAlbums = $albumQuery-&gt;count();
        if ($totalAlbums &gt; 0) {
            $this-&gt;info(&quot;Found {$totalAlbums} albums in library.&quot;);
            $bar = $this-&gt;output-&gt;createProgressBar($totalAlbums);
            $bar-&gt;setFormat(&apos;Albums: %current%/%max% [%bar%] %percent:3s%%&apos;);
            $bar-&gt;start();
            $albumQuery-&gt;chunk($batchSize, function ($albums) use ($forceUpdate, $queueName, $bar, &amp;$jobCount, $includeSongs, $includeArtists) {
                foreach ($albums as $album) {
                    SyncAlbumMetadataJob::dispatch($album-&gt;id, $forceUpdate)
                        -&gt;onQueue($queueName);
                    $jobCount++;
                    if ($includeSongs) {
                        foreach ($album-&gt;songs as $song) {
                            SyncSongMetadataJob::dispatch($song-&gt;id, $forceUpdate)
                                -&gt;onQueue($queueName);
                            $jobCount++;
                        }
                    }
                    if ($includeArtists) {
                        foreach ($album-&gt;artists as $artist) {
                            SyncArtistMetadataJob::dispatch($artist-&gt;id, $forceUpdate)
                                -&gt;onQueue($queueName);
                            $jobCount++;
                        }
                    }
                    $bar-&gt;advance();
                }
            });
            $bar-&gt;finish();
            $this-&gt;newLine();
        }
        // Optionally sync orphaned songs (songs without albums)
        if ($includeSongs) {
            $orphanedSongsQuery = Song::query()
                -&gt;whereHas(&apos;album&apos;, function ($query) use ($libraryId) {
                    $query-&gt;where(&apos;library_id&apos;, $libraryId);
                })
                -&gt;whereDoesntHave(&apos;album&apos;);
            $totalOrphanedSongs = $orphanedSongsQuery-&gt;count();
            if ($totalOrphanedSongs &gt; 0) {
                $this-&gt;info(&quot;Found {$totalOrphanedSongs} orphaned songs in library.&quot;);
                $bar = $this-&gt;output-&gt;createProgressBar($totalOrphanedSongs);
                $bar-&gt;setFormat(&apos;Orphaned Songs: %current%/%max% [%bar%] %percent:3s%%&apos;);
                $bar-&gt;start();
                $orphanedSongsQuery-&gt;chunk($batchSize, function ($songs) use ($forceUpdate, $queueName, $bar, &amp;$jobCount) {
                    foreach ($songs as $song) {
                        SyncSongMetadataJob::dispatch($song-&gt;id, $forceUpdate)
                            -&gt;onQueue($queueName);
                        $jobCount++;
                        $bar-&gt;advance();
                    }
                });
                $bar-&gt;finish();
                $this-&gt;newLine();
            }
        }
        // Optionally sync all unique artists in the library
        if ($includeArtists) {
            $artistQuery = Artist::query()
                -&gt;whereHas(&apos;albums&apos;, function ($query) use ($libraryId) {
                    $query-&gt;where(&apos;library_id&apos;, $libraryId);
                });
            $totalArtists = $artistQuery-&gt;count();
            if ($totalArtists &gt; 0) {
                $this-&gt;info(&quot;Found {$totalArtists} unique artists in library.&quot;);
                $bar = $this-&gt;output-&gt;createProgressBar($totalArtists);
                $bar-&gt;setFormat(&apos;Artists: %current%/%max% [%bar%] %percent:3s%%&apos;);
                $bar-&gt;start();
                $artistQuery-&gt;chunk($batchSize, function ($artists) use ($forceUpdate, $queueName, $bar, &amp;$jobCount) {
                    foreach ($artists as $artist) {
                        SyncArtistMetadataJob::dispatch($artist-&gt;id, $forceUpdate)
                            -&gt;onQueue($queueName);
                        $jobCount++;
                        $bar-&gt;advance();
                    }
                });
                $bar-&gt;finish();
                $this-&gt;newLine();
            }
        }
        return $jobCount;
    }
}</file><file path="app/Console/Commands/TranscoderStartCommand.php">&lt;?php
namespace App\Console\Commands;
use App\Modules\Transcoder\TranscoderContextFactory;
use Baander\Transcoder\ApplicationManager;
use Illuminate\Console\Command;
class TranscoderStartCommand extends Command
{
    /**
     * The name and signature of the console command.
     *
     * @var string
     */
    protected $signature = &apos;transcoder:start&apos;;
    /**
     * The console command description.
     *
     * @var string
     */
    protected $description = &apos;Command description&apos;;
    /**
     * Execute the console command.
     */
    public function handle()
    {
        $context = TranscoderContextFactory::create();
        $manager = new ApplicationManager($context);
        $manager-&gt;getApplication()-&gt;run();
    }
}</file><file path="app/Console/Commands/UserCreateCommand.php">&lt;?php
namespace App\Console\Commands;
use App\Models\User;
use Illuminate\Console\Command;
class UserCreateCommand extends Command
{
    /**
     * The name and signature of the console command.
     *
     * @var string
     */
    protected $signature = &apos;user:create {--admin}&apos;;
    /**
     * The console command description.
     *
     * @var string
     */
    protected $description = &apos;Create a new user&apos;;
    /**
     * Execute the console command.
     * @throws \Throwable
     */
    public function handle()
    {
        $is_admin = false;
        if ($this-&gt;option(&apos;admin&apos;)) {
            $is_admin = true;
        }
        $data = $this-&gt;getUserData();
        if (User::whereEmail($data[&apos;email&apos;])-&gt;exists()) {
            $this-&gt;error(&apos;User already exists&apos;);
            return 1;
        }
        $user = new User($data + [&apos;is_admin&apos; =&gt; $is_admin]);
        $user-&gt;forceFill([&apos;email_verified_at&apos; =&gt; now()]);
        $user-&gt;saveOrFail();
        $this-&gt;info(&apos;User created successfully.&apos;);
    }
    private function getUserData(): array
    {
        return [
            &apos;name&apos;     =&gt; $this-&gt;ask(&apos;name&apos;),
            &apos;email&apos;    =&gt; $this-&gt;ask(&apos;email&apos;),
            &apos;password&apos; =&gt; \Hash::make($this-&gt;secret(&apos;password&apos;)),
        ];
    }
}</file><file path="app/Events/ChannelName.php">&lt;?php
namespace App\Events;
enum ChannelName: string
{
    case Notifications = &apos;notifications&apos;;
}</file><file path="app/Exceptions/ImageNotFoundException.php">&lt;?php
namespace App\Exceptions;
use Exception;
use Symfony\Component\HttpFoundation\Response;
use Throwable;
class ImageNotFoundException extends Exception
{
    public function __construct(string $model, int $code = 0, ?Throwable $previous = null)
    {
        $message = &apos;Could not find image for model [&apos; . $model . &apos;]&apos;;
        parent::__construct($message, $code, $previous);
    }
    public function render()
    {
        return response(__(&apos;error.unable_to_locate_image&apos;))
            -&gt;setStatusCode(Response::HTTP_NOT_FOUND);
    }
}</file><file path="app/Exceptions/InsightException.php">&lt;?php
namespace App\Exceptions;
class InsightException extends \Exception
{
}</file><file path="app/Extensions/ArrExt.php">&lt;?php
namespace App\Extensions;
class ArrExt
{
    public static function dotKeys(array $arr): array
    {
        $iterator = new \RecursiveIteratorIterator(new \RecursiveArrayIterator($arr));
        $res = [];
        foreach ($iterator as $leaf) {
            $keys = [];
            foreach (range(0, $iterator-&gt;getDepth()) as $depth) {
                $keys[] = $iterator-&gt;getSubIterator($depth)-&gt;key();
            }
            $res[implode(&apos;.&apos;, $keys)] = $leaf;
        }
        return $res;
    }
}</file><file path="app/Extensions/GeneratorCollection.php">&lt;?php
namespace App\Extensions;
use Exception;
use Generator;
use IteratorAggregate;
/**
 * @template T
 * @implements IteratorAggregate&lt;T&gt;
 */
class GeneratorCollection implements IteratorAggregate
{
    /** @var array&lt;T&gt; */
    private array $items;
    /**
     * @param iterable&lt;T&gt; $itemCollection
     * @param T ...$items
     */
    public function __construct(
        private readonly iterable $itemCollection,
                                  ...$items,
    ) {
        $this-&gt;items = $items;
    }
    /**
     * @template U
     * @param callable(T): U $func
     * @return Generator&lt;U&gt;
     * @throws Exception
     */
    public function each(callable $func): Generator
    {
        foreach ($this-&gt;getIterator() as $item) {
            yield $func($item);
        }
    }
    /**
     * @template U
     * @param callable(T): U $func
     * @return GeneratorCollection&lt;U&gt;
     * @throws Exception
     */
    public function map(callable $func): self
    {
        return new self($this-&gt;each($func));
    }
    /**
     * @return GeneratorCollection&lt;T&gt;
     * @throws Exception
     */
    public function filter(callable $func): self
    {
        return new self($this-&gt;filterItems($func));
    }
    /**
     * @return Generator&lt;T&gt;
     */
    public function getIterator(): Generator
    {
        yield from $this-&gt;itemCollection;
        yield from $this-&gt;items;
    }
    /**
     * @return Generator&lt;T&gt;
     * @throws Exception
     */
    private function filterItems(callable $func): Generator
    {
        foreach ($this-&gt;getIterator() as $item) {
            if (!$func($item)) {
                continue;
            }
            yield $item;
        }
    }
}</file><file path="app/Extensions/Logger/StdOutLogger.php">&lt;?php
namespace App\Extensions\Logger;
use Illuminate\Support\Facades\Log;
class StdOutLogger
{
    private const string LOG_CHANNEL = &apos;stdout&apos;;
    private const string LOG_CHANNEL_ERROR = &apos;stderr&apos;;
    /**
     * @param string|\Stringable $message
     * @param array $context
     * @return void
     */
    public function info($message, array $context = []): void
    {
        Log::channel(self::LOG_CHANNEL)-&gt;info($message, $context);
    }
    /**
     * @param string|\Stringable $message
     * @param array $context
     * @return void
     */
    public function warning($message, array $context = []): void
    {
        Log::channel(self::LOG_CHANNEL_ERROR)-&gt;warning($message, $context);
    }
    /**
     * @param string|\Stringable $message
     * @param array $context
     * @return void
     */
    public function debug($message, array $context = []): void
    {
        Log::channel(self::LOG_CHANNEL)-&gt;debug($message, $context);
    }
    /**
     * @param string|\Stringable $message
     * @param array $context
     * @return void
     */
    public function error($message, array $context = []): void
    {
        Log::channel(self::LOG_CHANNEL_ERROR)-&gt;error($message, $context);
    }
}</file><file path="app/Http/Controllers/Api/MovieController.php">&lt;?php
namespace App\Http\Controllers\Api;
use App\Http\Resources\Movie\MovieResource;
use App\Models\Library;
use App\Models\Movie;
use App\Models\TokenAbility;
use App\Modules\Pagination\JsonPaginator;
use Illuminate\Http\Resources\Json\AnonymousResourceCollection;
use Spatie\RouteAttributes\Attributes\Get;
use Spatie\RouteAttributes\Attributes\Middleware;
use Spatie\RouteAttributes\Attributes\Prefix;
#[Prefix(&apos;/libraries/{library}/movies&apos;)]
#[Middleware([
    &apos;auth:sanctum&apos;,
    &apos;ability:&apos; . TokenAbility::ACCESS_API-&gt;value,
    &apos;force.json&apos;,
])]
class MovieController
{
    /**
     * Get a collection of movies
     *
     * @param Library $library
     * @return AnonymousResourceCollection&lt;JsonPaginator&lt;MovieResource&gt;&gt;
     */
    #[Get(&apos;/&apos;, &apos;api.movies.index&apos;)]
    public function index(Library $library)
    {
        $movies = Movie::query()
            -&gt;whereLibraryId($library-&gt;id)
            -&gt;paginate();
        return MovieResource::collection($movies);
    }
    /**
     * Get a movie
     *
     * @param Library $library
     * @param Movie $movie
     * @return MovieResource
     */
    #[Get(&apos;{movie}&apos;, &apos;api.movies.show&apos;)]
    public function show(Library $library, Movie $movie)
    {
        return new MovieResource($movie);
    }
}</file><file path="app/Http/Controllers/Api/SchemaController.php">&lt;?php
namespace App\Http\Controllers\Api;
use App\Http\Controllers\Controller;
use App\Models\TokenAbility;
use Illuminate\Http\Request;
use SimpleXMLElement;
use Spatie\RouteAttributes\Attributes\Get;
use Spatie\RouteAttributes\Attributes\Middleware;
use Spatie\RouteAttributes\Attributes\Prefix;
#[Prefix(&apos;/schemas&apos;)]
#[Middleware([
])]
class SchemaController extends Controller
{
    protected $schemaDefinitions = [];
    /**
     * @response array[]
     */
    #[Get(&apos;/musicbrainz&apos;)]
    public function fetchSchema()
    {
        $schemaFile = storage_path(&apos;app/public/schemas/musicbrainz_mmd-2.0.rng&apos;);
        if (!file_exists($schemaFile)) {
            return response()-&gt;json([&apos;error&apos; =&gt; &quot;Schema file not found: $schemaFile&quot;], 404);
        }
        $schemas = simplexml_load_file($schemaFile);
        if ($schemas === false) {
            return response()-&gt;json([&apos;error&apos; =&gt; &apos;Failed to load XML schema.&apos;], 500);
        }
        // Load all schema definitions into a map for quick lookup
        foreach ($schemas-&gt;define as $define) {
            $this-&gt;schemaDefinitions[(string) $define[&apos;name&apos;]] = $define;
        }
        // Generate a structured JSON from the schema definitions
        $schemaData = [];
        foreach ($this-&gt;schemaDefinitions as $elementName =&gt; $define) {
            $schemaData[] = $this-&gt;processElement($define, $elementName);
        }
        return response()-&gt;json($schemaData);
    }
    protected function processElement(SimpleXMLElement $element, string $name, int $depth = 0, bool $isParentOptional = false)
    {
        if ($depth &gt; 10) {
            return [&apos;name&apos; =&gt; &apos;Max depth reached&apos;];
        }
        // Flatten optional elements by removing them and adding their children to the parent
        $children = $this-&gt;flattenOptionalElements($element);
        $attributes = [];
        foreach ($element-&gt;attributes() as $attrName =&gt; $attrValue) {
            $attributes[(string) $attrName] = (string) $attrValue;
        }
        $childrenData = [];
        foreach ($children as [$childName, $childElement, $wasOptional]) {
            $childNameWithAsterisk = $wasOptional ? &quot;{$childName}*&quot; : $childName;
            $childrenData[] = $this-&gt;processElement($childElement, $childNameWithAsterisk, $depth + 1, $wasOptional);
        }
        return [
            &apos;name&apos; =&gt; $name,
            &apos;attributes&apos; =&gt; $attributes,
            &apos;children&apos; =&gt; $childrenData,
        ];
    }
    protected function flattenOptionalElements(SimpleXMLElement $element)
    {
        $result = [];
        foreach ($element-&gt;children() as $childName =&gt; $childElement) {
            if ($childName === &apos;optional&apos;) {
                foreach ($childElement-&gt;children() as $grandChildName =&gt; $grandChild) {
                    $result[] = [$grandChildName, $grandChild, true];
                }
            } else {
                $result[] = [$childName, $childElement, false];
            }
        }
        return $result;
    }
}</file><file path="app/Http/Integrations/CoverArtArchive/Models/CoverArtImage.php">&lt;?php
namespace App\Http\Integrations\CoverArtArchive\Models;
use Spatie\LaravelData\Data;
class CoverArtImage extends Data
{
    public function __construct(
        public array $types,
        public bool $front,
        public bool $back,
        public int $edit,
        public string $image,
        public string $comment,
        public bool $approved,
        public string $id,
        public CoverArtThumbnails $thumbnails
    ) {}
    public static function fromApiData(array $data): self
    {
        return new self(
            types: $data[&apos;types&apos;],
            front: $data[&apos;front&apos;],
            back: $data[&apos;back&apos;],
            edit: $data[&apos;edit&apos;],
            image: $data[&apos;image&apos;],
            comment: $data[&apos;comment&apos;],
            approved: $data[&apos;approved&apos;],
            id: $data[&apos;id&apos;],
            thumbnails: CoverArtThumbnails::fromApiData($data[&apos;thumbnails&apos;])
        );
    }
}</file><file path="app/Http/Integrations/CoverArtArchive/Models/CoverArtResponse.php">&lt;?php
namespace App\Http\Integrations\CoverArtArchive\Models;
use Spatie\LaravelData\Data;
class CoverArtResponse extends Data
{
    public function __construct(
        public array $images
    ) {}
    public static function fromApiData(array $data): self
    {
        return new self(
            images: array_map([CoverArtImage::class, &apos;fromApiData&apos;], $data[&apos;images&apos;])
        );
    }
}</file><file path="app/Http/Integrations/CoverArtArchive/Models/CoverArtThumbnails.php">&lt;?php
namespace App\Http\Integrations\CoverArtArchive\Models;
use Spatie\LaravelData\Data;
class CoverArtThumbnails extends Data
{
    public function __construct(
        public string $small,
        public string $medium, // renamed from 250
        public string $large, // renamed from 500
        public string $extraLarge, // renamed from 1200
        public string $defaultLarge // renamed from large
    ) {}
    public static function fromApiData(array $data): self
    {
        return new self(
            small: $data[&apos;small&apos;],
            medium: $data[&apos;250&apos;],
            large: $data[&apos;500&apos;],
            extraLarge: $data[&apos;1200&apos;],
            defaultLarge: $data[&apos;large&apos;]
        );
    }
}</file><file path="app/Http/Integrations/Discogs/DiscogsClient.php">&lt;?php
namespace App\Http\Integrations\Discogs;
use App\Services\GuzzleService;
use App\Http\Integrations\Discogs\Handlers\LookupHandler;
use App\Http\Integrations\Discogs\Handlers\SearchHandler;
class DiscogsClient
{
    public const string BASE_URL = &apos;https://api.discogs.com/&apos;;
    public LookupHandler $lookup;
    public SearchHandler $search;
    public function __construct(GuzzleService $guzzleService)
    {
        $client = $guzzleService-&gt;getClient();
        $this-&gt;lookup = new LookupHandler($client, self::BASE_URL);
        $this-&gt;search = new SearchHandler($client, self::BASE_URL);
    }
}</file><file path="app/Http/Integrations/Discogs/Filters/ArtistFilter.php">&lt;?php
namespace App\Http\Integrations\Discogs\Filters;
class ArtistFilter extends BaseFilter
{
    public function __construct(
        public ?string $q = null,
        public ?string $type = null,
        public ?string $title = null,
        public ?string $country = null,
        int $page = 1,
        int $per_page = 50
    ) {
        parent::__construct($page, $per_page);
    }
    public function setQ(?string $q): ArtistFilter
    {
        $this-&gt;q = $q;
        return $this;
    }
    public function setType(?string $type): ArtistFilter
    {
        $this-&gt;type = $type;
        return $this;
    }
    public function setTitle(?string $title): ArtistFilter
    {
        $this-&gt;title = $title;
        return $this;
    }
    public function setCountry(?string $country): ArtistFilter
    {
        $this-&gt;country = $country;
        return $this;
    }
    protected function buildQuery(): array
    {
        $query = [];
        if ($this-&gt;q) {
            $query[&apos;q&apos;] = $this-&gt;q;
        }
        if ($this-&gt;type) {
            $query[&apos;type&apos;] = $this-&gt;type;
        }
        if ($this-&gt;title) {
            $query[&apos;title&apos;] = $this-&gt;title;
        }
        if ($this-&gt;country) {
            $query[&apos;country&apos;] = $this-&gt;country;
        }
        return $query;
    }
}</file><file path="app/Http/Integrations/Discogs/Filters/BaseFilter.php">&lt;?php
namespace App\Http\Integrations\Discogs\Filters;
use Spatie\LaravelData\Data;
abstract class BaseFilter extends Data
{
    public function __construct(
        public int $page = 1,
        public int $per_page = 50
    ) {}
    abstract protected function buildQuery(): array;
    public function toQueryParameters(): array
    {
        $params = [
            &apos;page&apos; =&gt; $this-&gt;page,
            &apos;per_page&apos; =&gt; $this-&gt;per_page,
        ];
        $queryParams = $this-&gt;buildQuery();
        if (!empty($queryParams)) {
            $params = array_merge($params, $queryParams);
        }
        return $params;
    }
}</file><file path="app/Http/Integrations/Discogs/Filters/LabelFilter.php">&lt;?php
namespace App\Http\Integrations\Discogs\Filters;
class LabelFilter extends BaseFilter
{
    public function __construct(
        public ?string $q = null,
        public ?string $type = null,
        public ?string $title = null,
        public ?string $country = null,
        int $page = 1,
        int $per_page = 50
    ) {
        parent::__construct($page, $per_page);
    }
    protected function buildQuery(): array
    {
        $query = [];
        if ($this-&gt;q) {
            $query[&apos;q&apos;] = $this-&gt;q;
        }
        if ($this-&gt;type) {
            $query[&apos;type&apos;] = $this-&gt;type;
        }
        if ($this-&gt;title) {
            $query[&apos;title&apos;] = $this-&gt;title;
        }
        if ($this-&gt;country) {
            $query[&apos;country&apos;] = $this-&gt;country;
        }
        return $query;
    }
}</file><file path="app/Http/Integrations/Discogs/Filters/MasterFilter.php">&lt;?php
namespace App\Http\Integrations\Discogs\Filters;
class MasterFilter extends BaseFilter
{
    public function __construct(
        public ?string $q = null,
        public ?string $type = null,
        public ?string $title = null,
        public ?string $artist = null,
        public ?string $country = null,
        public ?string $year = null,
        public ?string $genre = null,
        public ?string $style = null,
        int $page = 1,
        int $per_page = 50
    ) {
        parent::__construct($page, $per_page);
    }
    protected function buildQuery(): array
    {
        $query = [];
        if ($this-&gt;q) {
            $query[&apos;q&apos;] = $this-&gt;q;
        }
        if ($this-&gt;type) {
            $query[&apos;type&apos;] = $this-&gt;type;
        }
        if ($this-&gt;title) {
            $query[&apos;title&apos;] = $this-&gt;title;
        }
        if ($this-&gt;artist) {
            $query[&apos;artist&apos;] = $this-&gt;artist;
        }
        if ($this-&gt;country) {
            $query[&apos;country&apos;] = $this-&gt;country;
        }
        if ($this-&gt;year) {
            $query[&apos;year&apos;] = $this-&gt;year;
        }
        if ($this-&gt;genre) {
            $query[&apos;genre&apos;] = $this-&gt;genre;
        }
        if ($this-&gt;style) {
            $query[&apos;style&apos;] = $this-&gt;style;
        }
        return $query;
    }
}</file><file path="app/Http/Integrations/Discogs/Filters/ReleaseFilter.php">&lt;?php
namespace App\Http\Integrations\Discogs\Filters;
class ReleaseFilter extends BaseFilter
{
    public function __construct(
        public ?string $q = null,
        public ?string $type = null,
        public ?string $title = null,
        public ?string $artist = null,
        public ?string $label = null,
        public ?string $country = null,
        public ?string $year = null,
        public ?string $format = null,
        public ?string $genre = null,
        public ?string $style = null,
        int $page = 1,
        int $per_page = 50
    ) {
        parent::__construct($page, $per_page);
    }
    public function setQ(?string $q): ReleaseFilter
    {
        $this-&gt;q = $q;
        return $this;
    }
    public function setType(?string $type): ReleaseFilter
    {
        $this-&gt;type = $type;
        return $this;
    }
    public function setTitle(?string $title): ReleaseFilter
    {
        $this-&gt;title = $title;
        return $this;
    }
    public function setArtist(?string $artist): ReleaseFilter
    {
        $this-&gt;artist = $artist;
        return $this;
    }
    public function setLabel(?string $label): ReleaseFilter
    {
        $this-&gt;label = $label;
        return $this;
    }
    public function setCountry(?string $country): ReleaseFilter
    {
        $this-&gt;country = $country;
        return $this;
    }
    public function setYear(?string $year): ReleaseFilter
    {
        $this-&gt;year = $year;
        return $this;
    }
    public function setFormat(?string $format): ReleaseFilter
    {
        $this-&gt;format = $format;
        return $this;
    }
    public function setGenre(?string $genre): ReleaseFilter
    {
        $this-&gt;genre = $genre;
        return $this;
    }
    public function setStyle(?string $style): ReleaseFilter
    {
        $this-&gt;style = $style;
        return $this;
    }
    protected function buildQuery(): array
    {
        $query = [];
        if ($this-&gt;q) {
            $query[&apos;q&apos;] = $this-&gt;q;
        }
        if ($this-&gt;type) {
            $query[&apos;type&apos;] = $this-&gt;type;
        }
        if ($this-&gt;title) {
            $query[&apos;title&apos;] = $this-&gt;title;
        }
        if ($this-&gt;artist) {
            $query[&apos;artist&apos;] = $this-&gt;artist;
        }
        if ($this-&gt;label) {
            $query[&apos;label&apos;] = $this-&gt;label;
        }
        if ($this-&gt;country) {
            $query[&apos;country&apos;] = $this-&gt;country;
        }
        if ($this-&gt;year) {
            $query[&apos;year&apos;] = $this-&gt;year;
        }
        if ($this-&gt;format) {
            $query[&apos;format&apos;] = $this-&gt;format;
        }
        if ($this-&gt;genre) {
            $query[&apos;genre&apos;] = $this-&gt;genre;
        }
        if ($this-&gt;style) {
            $query[&apos;style&apos;] = $this-&gt;style;
        }
        return $query;
    }
}</file><file path="app/Http/Integrations/Discogs/Handler.php">&lt;?php
namespace App\Http\Integrations\Discogs;
use App\Baander;
use GuzzleHttp\Client;
abstract class Handler
{
    public function __construct(protected readonly Client $client, protected readonly string $baseUrl)
    {}
    protected function fetchEndpoint(string $endpoint, array $params = []): ?array
    {
        if (config(&apos;services.discogs.api_key&apos;)) {
            $params[&apos;token&apos;] = config(&apos;services.discogs.api_key&apos;);
        }
        $headers = [
            &apos;User-Agent&apos; =&gt; Baander::getPeerName(),
        ];
        $response = $this-&gt;client-&gt;getAsync($this-&gt;baseUrl . $endpoint, [
            &apos;query&apos; =&gt; $params,
            &apos;headers&apos; =&gt; $headers,
        ])-&gt;wait();
        if ($response-&gt;getStatusCode() === 200) {
            return json_decode($response-&gt;getBody()-&gt;getContents(), true);
        }
        return null;
    }
}</file><file path="app/Http/Integrations/Discogs/Handlers/LookupHandler.php">&lt;?php
namespace App\Http\Integrations\Discogs\Handlers;
use App\Http\Integrations\Discogs\Handler;
use App\Http\Integrations\Discogs\Models\{
    Artist,
    Release,
    Master,
    Label
};
class LookupHandler extends Handler
{
    /**
     * Get artist by ID
     * 
     * @param int $id Artist ID
     * @return Artist|null Artist data
     */
    public function artist(int $id): ?Artist
    {
        $data = $this-&gt;fetchEndpoint(&quot;artists/{$id}&quot;);
        return $data ? Artist::fromApiData($data) : null;
    }
    /**
     * Get artist releases
     * 
     * @param int $id Artist ID
     * @param int $page Page number
     * @param int $per_page Items per page
     * @return array|null Array containing releases (as Release models) and pagination info
     */
    public function artistReleases(int $id, int $page = 1, int $per_page = 50): ?array
    {
        $data = $this-&gt;fetchEndpoint(&quot;artists/{$id}/releases&quot;, [
            &apos;page&apos; =&gt; $page,
            &apos;per_page&apos; =&gt; $per_page
        ]);
        if (!$data || !isset($data[&apos;releases&apos;])) {
            return null;
        }
        // Convert releases to Release models
        $releases = array_map(fn($item) =&gt; Release::fromApiData($item), $data[&apos;releases&apos;]);
        return [
            &apos;releases&apos; =&gt; $releases,
            &apos;pagination&apos; =&gt; $data[&apos;pagination&apos;] ?? null
        ];
    }
    /**
     * Get release by ID
     * 
     * @param int $id Release ID
     * @return Release|null Release data
     */
    public function release(int $id): ?Release
    {
        $data = $this-&gt;fetchEndpoint(&quot;releases/{$id}&quot;);
        return $data ? Release::fromApiData($data) : null;
    }
    /**
     * Get master release by ID
     * 
     * @param int $id Master ID
     * @return Master|null Master release data
     */
    public function master(int $id): ?Master
    {
        $data = $this-&gt;fetchEndpoint(&quot;masters/{$id}&quot;);
        return $data ? Master::fromApiData($data) : null;
    }
    /**
     * Get master release versions
     * 
     * @param int $id Master ID
     * @param int $page Page number
     * @param int $per_page Items per page
     * @return array|null Array containing versions (as Release models) and pagination info
     */
    public function masterVersions(int $id, int $page = 1, int $per_page = 50): ?array
    {
        $data = $this-&gt;fetchEndpoint(&quot;masters/{$id}/versions&quot;, [
            &apos;page&apos; =&gt; $page,
            &apos;per_page&apos; =&gt; $per_page
        ]);
        if (!$data || !isset($data[&apos;versions&apos;])) {
            return null;
        }
        // Convert versions to Release models
        $versions = array_map(fn($item) =&gt; Release::fromApiData($item), $data[&apos;versions&apos;]);
        return [
            &apos;versions&apos; =&gt; $versions,
            &apos;pagination&apos; =&gt; $data[&apos;pagination&apos;] ?? null
        ];
    }
    /**
     * Get label by ID
     * 
     * @param int $id Label ID
     * @return Label|null Label data
     */
    public function label(int $id): ?Label
    {
        $data = $this-&gt;fetchEndpoint(&quot;labels/{$id}&quot;);
        return $data ? Label::fromApiData($data) : null;
    }
    /**
     * Get label releases
     * 
     * @param int $id Label ID
     * @param int $page Page number
     * @param int $per_page Items per page
     * @return array|null Array containing releases (as Release models) and pagination info
     */
    public function labelReleases(int $id, int $page = 1, int $per_page = 50): ?array
    {
        $data = $this-&gt;fetchEndpoint(&quot;labels/{$id}/releases&quot;, [
            &apos;page&apos; =&gt; $page,
            &apos;per_page&apos; =&gt; $per_page
        ]);
        if (!$data || !isset($data[&apos;releases&apos;])) {
            return null;
        }
        // Convert releases to Release models
        $releases = array_map(fn($item) =&gt; Release::fromApiData($item), $data[&apos;releases&apos;]);
        return [
            &apos;releases&apos; =&gt; $releases,
            &apos;pagination&apos; =&gt; $data[&apos;pagination&apos;] ?? null
        ];
    }
}</file><file path="app/Http/Integrations/Discogs/Handlers/SearchHandler.php">&lt;?php
namespace App\Http\Integrations\Discogs\Handlers;
use App\Http\Integrations\Discogs\Handler;
use App\Http\Integrations\Discogs\Models\{
    Artist,
    Release,
    Master,
    Label
};
use App\Http\Integrations\Discogs\Filters\{
    ArtistFilter,
    ReleaseFilter,
    MasterFilter,
    LabelFilter
};
use Illuminate\Support\Collection;
class SearchHandler extends Handler
{
    private ?array $lastPagination = null;
    /**
     * Search for artists and return models
     *
     * @param ArtistFilter $filter Filter criteria
     * @return Collection&lt;Artist&gt; Collection of Artist models
     */
    public function artist(ArtistFilter $filter): Collection
    {
        $data = $this-&gt;fetchEndpoint(&apos;database/search&apos;, array_merge($filter-&gt;toQueryParameters(), [&apos;type&apos; =&gt; &apos;artist&apos;]));
        // Store pagination for later retrieval
        $this-&gt;lastPagination = $data[&apos;pagination&apos;] ?? null;
        if (!isset($data[&apos;results&apos;])) {
            return collect();
        }
        return collect($data[&apos;results&apos;])-&gt;map(fn($item) =&gt; Artist::fromApiData($item));
    }
    /**
     * Search for releases and return models
     *
     * @param ReleaseFilter $filter Filter criteria
     * @return Collection&lt;Release&gt; Collection of Release models
     */
    public function release(ReleaseFilter $filter): Collection
    {
        $data = $this-&gt;fetchEndpoint(&apos;database/search&apos;, array_merge($filter-&gt;toQueryParameters(), [&apos;type&apos; =&gt; &apos;release&apos;]));
        // Store pagination for later retrieval
        $this-&gt;lastPagination = $data[&apos;pagination&apos;] ?? null;
        if (!isset($data[&apos;results&apos;])) {
            return collect();
        }
        return collect($data[&apos;results&apos;])-&gt;map(fn($item) =&gt; Release::fromApiData($item));
    }
    /**
     * Search for master releases and return models
     *
     * @param MasterFilter $filter Filter criteria
     * @return Collection&lt;Master&gt; Collection of Master models
     */
    public function master(MasterFilter $filter): Collection
    {
        $data = $this-&gt;fetchEndpoint(&apos;database/search&apos;, array_merge($filter-&gt;toQueryParameters(), [&apos;type&apos; =&gt; &apos;master&apos;]));
        // Store pagination for later retrieval
        $this-&gt;lastPagination = $data[&apos;pagination&apos;] ?? null;
        if (!isset($data[&apos;results&apos;])) {
            return collect();
        }
        return collect($data[&apos;results&apos;])-&gt;map(fn($item) =&gt; Master::fromApiData($item));
    }
    /**
     * Search for labels and return models
     *
     * @param LabelFilter $filter Filter criteria
     * @return Collection&lt;Label&gt; Collection of Label models
     */
    public function label(LabelFilter $filter): Collection
    {
        $data = $this-&gt;fetchEndpoint(&apos;database/search&apos;, array_merge($filter-&gt;toQueryParameters(), [&apos;type&apos; =&gt; &apos;label&apos;]));
        // Store pagination for later retrieval
        $this-&gt;lastPagination = $data[&apos;pagination&apos;] ?? null;
        if (!isset($data[&apos;results&apos;])) {
            return collect();
        }
        return collect($data[&apos;results&apos;])-&gt;map(fn($item) =&gt; Label::fromApiData($item));
    }
    /**
     * Get raw API response for artists (for backward compatibility)
     *
     * @param ArtistFilter $filter Filter criteria
     * @return array Raw API response
     */
    public function artistRaw(ArtistFilter $filter): array
    {
        return $this-&gt;fetchEndpoint(&apos;database/search&apos;, array_merge($filter-&gt;toQueryParameters(), [&apos;type&apos; =&gt; &apos;artist&apos;]));
    }
    /**
     * Get raw API response for releases (for backward compatibility)
     *
     * @param ReleaseFilter $filter Filter criteria
     * @return array Raw API response
     */
    public function releaseRaw(ReleaseFilter $filter): array
    {
        return $this-&gt;fetchEndpoint(&apos;database/search&apos;, array_merge($filter-&gt;toQueryParameters(), [&apos;type&apos; =&gt; &apos;release&apos;]));
    }
    /**
     * Get pagination information from the last search
     *
     * @return array|null Array containing pagination info (page, pages, items, per_page)
     */
    public function getPagination(): ?array
    {
        if (!$this-&gt;lastPagination) {
            return null;
        }
        return [
            &apos;page&apos; =&gt; $this-&gt;lastPagination[&apos;page&apos;] ?? 1,
            &apos;pages&apos; =&gt; $this-&gt;lastPagination[&apos;pages&apos;] ?? 1,
            &apos;items&apos; =&gt; $this-&gt;lastPagination[&apos;items&apos;] ?? 0,
            &apos;per_page&apos; =&gt; $this-&gt;lastPagination[&apos;per_page&apos;] ?? 50,
        ];
    }
    /**
     * Search with full pagination info
     *
     * @param string $type Entity type (artist, release, master, label)
     * @param mixed $filter Filter criteria
     * @return array Array with &apos;results&apos; (Collection) and &apos;pagination&apos; keys
     */
    public function searchWithPagination(string $type, $filter): array
    {
        $method = $type; // artist, release, master, label
        $results = $this-&gt;$method($filter);
        return [
            &apos;results&apos; =&gt; $results,
            &apos;pagination&apos; =&gt; $this-&gt;getPagination(),
        ];
    }
}</file><file path="app/Http/Integrations/Discogs/Models/Artist.php">&lt;?php
namespace App\Http\Integrations\Discogs\Models;
class Artist extends Model
{
    public function __construct(
        public ?int $id = null,
        public ?string $name = null,
        public ?string $title = null,
        public ?string $profile = null,
        public ?string $uri = null,
        public ?string $resource_url = null,
        public ?string $type = null,
        public ?string $thumbnail = null,
        public ?string $cover_image = null,
        public ?array $images = null,
        public ?array $urls = null,
        public ?array $members = null,
        public ?string $data_quality = null,
        public ?string $namevariations = null,
        public ?array $aliases = null,
        public ?int $releases_count = null
    ) {
    }
    public static function fromApiData(array $data): self
    {
        return new self(
            id: $data[&apos;id&apos;] ?? null,
            name: $data[&apos;name&apos;] ?? null,
            title: $data[&apos;title&apos;] ?? null,
            profile: $data[&apos;profile&apos;] ?? null,
            uri: $data[&apos;uri&apos;] ?? null,
            resource_url: $data[&apos;resource_url&apos;] ?? null,
            type: $data[&apos;type&apos;] ?? null,
            thumbnail: $data[&apos;thumb&apos;] ?? null,
            cover_image: $data[&apos;cover_image&apos;] ?? null,
            images: $data[&apos;images&apos;] ?? null,
            urls: $data[&apos;urls&apos;] ?? null,
            members: $data[&apos;members&apos;] ?? null,
            data_quality: $data[&apos;data_quality&apos;] ?? null,
            namevariations: $data[&apos;namevariations&apos;] ?? null,
            aliases: $data[&apos;aliases&apos;] ?? null,
            releases_count: $data[&apos;releases_count&apos;] ?? null
        );
    }
}</file><file path="app/Http/Integrations/Discogs/Models/Label.php">&lt;?php
namespace App\Http\Integrations\Discogs\Models;
class Label extends Model
{
    public function __construct(
        public ?int $id = null,
        public ?string $name = null,
        public ?string $title = null,
        public ?string $profile = null,
        public ?string $uri = null,
        public ?string $resource_url = null,
        public ?string $type = null,
        public ?string $thumbnail = null,
        public ?string $cover_image = null,
        public ?array $images = null,
        public ?string $contact_info = null,
        public ?string $parent_label = null,
        public ?array $sublabels = null,
        public ?array $urls = null,
        public ?string $data_quality = null,
        public ?int $releases_count = null,
        public ?string $country = null
    ) {
    }
    public static function fromApiData(array $data): self
    {
        return new self(
            id: $data[&apos;id&apos;] ?? null,
            name: $data[&apos;name&apos;] ?? null,
            title: $data[&apos;title&apos;] ?? null,
            profile: $data[&apos;profile&apos;] ?? null,
            uri: $data[&apos;uri&apos;] ?? null,
            resource_url: $data[&apos;resource_url&apos;] ?? null,
            type: $data[&apos;type&apos;] ?? null,
            thumbnail: $data[&apos;thumb&apos;] ?? null,
            cover_image: $data[&apos;cover_image&apos;] ?? null,
            images: $data[&apos;images&apos;] ?? null,
            contact_info: $data[&apos;contact_info&apos;] ?? null,
            parent_label: $data[&apos;parent_label&apos;] ?? null,
            sublabels: $data[&apos;sublabels&apos;] ?? null,
            urls: $data[&apos;urls&apos;] ?? null,
            data_quality: $data[&apos;data_quality&apos;] ?? null,
            releases_count: $data[&apos;releases_count&apos;] ?? null,
            country: $data[&apos;country&apos;] ?? null
        );
    }
}</file><file path="app/Http/Integrations/Discogs/Models/Master.php">&lt;?php
namespace App\Http\Integrations\Discogs\Models;
class Master extends Model
{
    public function __construct(
        public ?int $id = null,
        public ?string $title = null,
        public ?string $uri = null,
        public ?string $resource_url = null,
        public ?string $type = null,
        public ?string $thumbnail = null,
        public ?string $cover_image = null,
        public ?array $images = null,
        public ?array $artists = null,
        public ?array $tracklist = null,
        public ?array $videos = null,
        public ?array $genres = null,
        public ?array $styles = null,
        public ?int $year = null,
        public ?string $data_quality = null,
        public ?int $versions_count = null,
        public ?string $main_release = null,
        public ?string $main_release_url = null,
        public ?string $notes = null,
        public ?int $num_for_sale = null,
        public ?float $lowest_price = null
    ) {
    }
    public static function fromApiData(array $data): self
    {
        return new self(
            id: $data[&apos;id&apos;] ?? null,
            title: $data[&apos;title&apos;] ?? null,
            uri: $data[&apos;uri&apos;] ?? null,
            resource_url: $data[&apos;resource_url&apos;] ?? null,
            type: $data[&apos;type&apos;] ?? null,
            thumbnail: $data[&apos;thumb&apos;] ?? null,
            cover_image: $data[&apos;cover_image&apos;] ?? null,
            images: $data[&apos;images&apos;] ?? null,
            artists: $data[&apos;artists&apos;] ?? null,
            tracklist: $data[&apos;tracklist&apos;] ?? null,
            videos: $data[&apos;videos&apos;] ?? null,
            genres: $data[&apos;genres&apos;] ?? null,
            styles: $data[&apos;styles&apos;] ?? null,
            year: $data[&apos;year&apos;] ?? null,
            data_quality: $data[&apos;data_quality&apos;] ?? null,
            versions_count: $data[&apos;versions_count&apos;] ?? null,
            main_release: $data[&apos;main_release&apos;] ?? null,
            main_release_url: $data[&apos;main_release_url&apos;] ?? null,
            notes: $data[&apos;notes&apos;] ?? null,
            num_for_sale: $data[&apos;num_for_sale&apos;] ?? null,
            lowest_price: $data[&apos;lowest_price&apos;] ?? null
        );
    }
}</file><file path="app/Http/Integrations/Discogs/Models/Model.php">&lt;?php
namespace App\Http\Integrations\Discogs\Models;
use Spatie\LaravelData\Data;
abstract class Model extends Data
{
    /**
     * Create a new model instance from API data
     *
     * @param array $data API response data
     * @return static
     */
    abstract public static function fromApiData(array $data): self;
}</file><file path="app/Http/Integrations/Discogs/Models/Release.php">&lt;?php
namespace App\Http\Integrations\Discogs\Models;
class Release extends Model
{
    public function __construct(
        public ?int $id = null,
        public ?string $title = null,
        public ?string $uri = null,
        public ?string $resource_url = null,
        public ?string $type = null,
        public ?string $thumbnail = null,
        public ?string $cover_image = null,
        public ?array $images = null,
        public ?array $artists = null,
        public ?array $formats = null,
        public ?array $labels = null,
        public ?array $tracklist = null,
        public ?string $country = null,
        public ?string $released = null,
        public ?int $year = null,
        public ?string $notes = null,
        public ?string $data_quality = null,
        public ?array $genres = null,
        public ?array $styles = null,
        public ?string $master_id = null,
        public ?string $master_url = null,
        public ?string $catno = null
    ) {
    }
    public static function fromApiData(array $data): self
    {
        return new self(
            id: $data[&apos;id&apos;] ?? null,
            title: $data[&apos;title&apos;] ?? null,
            uri: $data[&apos;uri&apos;] ?? null,
            resource_url: $data[&apos;resource_url&apos;] ?? null,
            type: $data[&apos;type&apos;] ?? null,
            thumbnail: $data[&apos;thumb&apos;] ?? null,
            cover_image: $data[&apos;cover_image&apos;] ?? null,
            images: $data[&apos;images&apos;] ?? null,
            artists: $data[&apos;artists&apos;] ?? null,
            formats: $data[&apos;formats&apos;] ?? null,
            labels: $data[&apos;labels&apos;] ?? null,
            tracklist: $data[&apos;tracklist&apos;] ?? null,
            country: $data[&apos;country&apos;] ?? null,
            released: $data[&apos;released&apos;] ?? null,
            year: $data[&apos;year&apos;] ?? null,
            notes: $data[&apos;notes&apos;] ?? null,
            data_quality: $data[&apos;data_quality&apos;] ?? null,
            genres: $data[&apos;genres&apos;] ?? null,
            styles: $data[&apos;styles&apos;] ?? null,
            master_id: $data[&apos;master_id&apos;] ?? null,
            master_url: $data[&apos;master_url&apos;] ?? null,
            catno: $data[&apos;catno&apos;] ?? null
        );
    }
}</file><file path="app/Http/Integrations/MusicBrainz/Filters/AreaFilter.php">&lt;?php
namespace App\Http\Integrations\MusicBrainz\Filters;
class AreaFilter extends BaseFilter
{
    public function __construct(
        public ?string $name = null,
        int $limit = 25,
        int $offset = 0
    ) {
        parent::__construct($limit, $offset);
    }
    protected function buildQuery(): array
    {
        $query = [];
        if ($this-&gt;name) {
            $query[] = &apos;area:&apos; . $this-&gt;name;
        }
        return $query;
    }
}</file><file path="app/Http/Integrations/MusicBrainz/Filters/BaseFilter.php">&lt;?php
namespace App\Http\Integrations\MusicBrainz\Filters;
use Spatie\LaravelData\Data;
abstract class BaseFilter extends Data
{
    public function __construct(
        public int $limit = 25,
        public int $offset = 0
    ) {}
    abstract protected function buildQuery(): array;
    public function toQueryParameters(): array
    {
        return [
            &apos;query&apos; =&gt; implode(&apos; AND &apos;, $this-&gt;buildQuery()),
            &apos;limit&apos; =&gt; $this-&gt;limit,
            &apos;offset&apos; =&gt; $this-&gt;offset,
            &apos;fmt&apos; =&gt; &apos;json&apos;,
        ];
    }
}</file><file path="app/Http/Integrations/MusicBrainz/Filters/EventFilter.php">&lt;?php
namespace App\Http\Integrations\MusicBrainz\Filters;
class EventFilter extends BaseFilter
{
    public function __construct(
        public ?string $name = null,
        int $limit = 25,
        int $offset = 0
    ) {
        parent::__construct($limit, $offset);
    }
    protected function buildQuery(): array
    {
        $query = [];
        if ($this-&gt;name) {
            $query[] = &apos;event:&apos; . $this-&gt;name;
        }
        return $query;
    }
}</file><file path="app/Http/Integrations/MusicBrainz/Filters/GenreFilter.php">&lt;?php
namespace App\Http\Integrations\MusicBrainz\Filters;
class GenreFilter extends BaseFilter
{
    public function __construct(
        public ?string $name = null,
        int $limit = 25,
        int $offset = 0
    ) {
        parent::__construct($limit, $offset);
    }
    protected function buildQuery(): array
    {
        $query = [];
        if ($this-&gt;name) {
            $query[] = &apos;genre:&apos; . $this-&gt;name;
        }
        return $query;
    }
}</file><file path="app/Http/Integrations/MusicBrainz/Filters/InstrumentFilter.php">&lt;?php
namespace App\Http\Integrations\MusicBrainz\Filters;
class InstrumentFilter extends BaseFilter
{
    public function __construct(
        public ?string $name = null,
        int $limit = 25,
        int $offset = 0
    ) {
        parent::__construct($limit, $offset);
    }
    protected function buildQuery(): array
    {
        $query = [];
        if ($this-&gt;name) {
            $query[] = &apos;instrument:&apos; . $this-&gt;name;
        }
        return $query;
    }
}</file><file path="app/Http/Integrations/MusicBrainz/Filters/LabelFilter.php">&lt;?php
namespace App\Http\Integrations\MusicBrainz\Filters;
class LabelFilter extends BaseFilter
{
    public function __construct(
        public ?string $name = null,
        public ?string $country = null,
        int $limit = 25,
        int $offset = 0
    ) {
        parent::__construct($limit, $offset);
    }
    protected function buildQuery(): array
    {
        $query = [];
        if ($this-&gt;name) {
            $query[] = &apos;label:&apos; . $this-&gt;name;
        }
        if ($this-&gt;country) {
            $query[] = &apos;country:&apos; . $this-&gt;country;
        }
        return $query;
    }
}</file><file path="app/Http/Integrations/MusicBrainz/Filters/PlaceFilter.php">&lt;?php
namespace App\Http\Integrations\MusicBrainz\Filters;
class PlaceFilter extends BaseFilter
{
    public function __construct(
        public ?string $name = null,
        public ?string $type = null,
        int $limit = 25,
        int $offset = 0
    ) {
        parent::__construct($limit, $offset);
    }
    protected function buildQuery(): array
    {
        $query = [];
        if ($this-&gt;name) {
            $query[] = &apos;place:&apos; . $this-&gt;name;
        }
        if ($this-&gt;type) {
            $query[] = &apos;type:&apos; . $this-&gt;type;
        }
        return $query;
    }
}</file><file path="app/Http/Integrations/MusicBrainz/Filters/SeriesFilter.php">&lt;?php
namespace App\Http\Integrations\MusicBrainz\Filters;
class SeriesFilter extends BaseFilter
{
    public function __construct(
        public ?string $name = null,
        int $limit = 25,
        int $offset = 0
    ) {
        parent::__construct($limit, $offset);
    }
    protected function buildQuery(): array
    {
        $query = [];
        if ($this-&gt;name) {
            $query[] = &apos;series:&apos; . $this-&gt;name;
        }
        return $query;
    }
}</file><file path="app/Http/Integrations/MusicBrainz/Filters/UrlFilter.php">&lt;?php
namespace App\Http\Integrations\MusicBrainz\Filters;
class UrlFilter extends BaseFilter
{
    public function __construct(
        public ?string $resource = null,
        int $limit = 25,
        int $offset = 0
    ) {
        parent::__construct($limit, $offset);
    }
    protected function buildQuery(): array
    {
        $query = [];
        if ($this-&gt;resource) {
            $query[] = &apos;resource:&apos; . $this-&gt;resource;
        }
        return $query;
    }
}</file><file path="app/Http/Integrations/MusicBrainz/Filters/WorkFilter.php">&lt;?php
namespace App\Http\Integrations\MusicBrainz\Filters;
class WorkFilter extends BaseFilter
{
    public function __construct(
        public ?string $title = null,
        public ?string $artistName = null,
        int $limit = 25,
        int $offset = 0
    ) {
        parent::__construct($limit, $offset);
    }
    protected function buildQuery(): array
    {
        $query = [];
        if ($this-&gt;title) {
            $query[] = &apos;work:&apos; . $this-&gt;title;
        }
        if ($this-&gt;artistName) {
            $query[] = &apos;artist:&apos; . $this-&gt;artistName;
        }
        return $query;
    }
}</file><file path="app/Http/Integrations/MusicBrainz/Handler.php">&lt;?php
namespace App\Http\Integrations\MusicBrainz;
use GuzzleHttp\Client;
abstract class Handler
{
    public function __construct(protected readonly Client $client, protected readonly string $baseUrl)
    {}
    protected function fetchEndpoint(string $endpoint, array $params = []): ?array
    {
        $response = $this-&gt;client-&gt;getAsync($this-&gt;baseUrl . $endpoint, [
            &apos;query&apos; =&gt; $params,
        ])-&gt;wait();
        if ($response-&gt;getStatusCode() === 200) {
            return json_decode($response-&gt;getBody()-&gt;getContents(), true);
        }
        return null;
    }
}</file><file path="app/Http/Integrations/MusicBrainz/Models/Alias.php">&lt;?php
namespace App\Http\Integrations\MusicBrainz\Models;
use Spatie\LaravelData\Data;
class Alias extends Data
{
    public function __construct(public mixed $locale, public mixed $sort_name, public mixed $type, public mixed $type_id, public mixed $primary, public mixed $begin_date, public mixed $end_date)
    {
    }
    public static function fromApiData(array $data): self
    {
        return new self(
            locale: $data[&apos;locale&apos;] ?? null,
            sort_name: $data[&apos;sort-name&apos;] ?? null,
            type: $data[&apos;type&apos;] ?? null,
            type_id: $data[&apos;type-id&apos;] ?? null,
            primary: $data[&apos;primary&apos;] ?? null,
            begin_date: $data[&apos;begin-date&apos;] ?? null,
            end_date: $data[&apos;end-date&apos;] ?? null
        );
    }
}</file><file path="app/Http/Integrations/MusicBrainz/Models/AliasList.php">&lt;?php
namespace App\Http\Integrations\MusicBrainz\Models;
use Spatie\LaravelData\Data;
class AliasList extends Data
{
    public function __construct(public mixed $count, public mixed $offset, public mixed $alias, public mixed $locale, public mixed $sort_name, public mixed $type, public mixed $type_id, public mixed $primary, public mixed $begin_date, public mixed $end_date)
    {
    }
    public static function fromApiData(array $data): self
    {
        return new self(
            count: $data[&apos;count&apos;] ?? null,
            offset: $data[&apos;offset&apos;] ?? null,
            alias: $data[&apos;alias&apos;] ?? null,
            locale: $data[&apos;locale&apos;] ?? null,
            sort_name: $data[&apos;sort-name&apos;] ?? null,
            type: $data[&apos;type&apos;] ?? null,
            type_id: $data[&apos;type-id&apos;] ?? null,
            primary: $data[&apos;primary&apos;] ?? null,
            begin_date: $data[&apos;begin-date&apos;] ?? null,
            end_date: $data[&apos;end-date&apos;] ?? null
        );
    }
}</file><file path="app/Http/Integrations/MusicBrainz/Models/Annotation.php">&lt;?php
namespace App\Http\Integrations\MusicBrainz\Models;
use Spatie\LaravelData\Data;
class Annotation extends Data
{
    public function __construct(public mixed $text, public mixed $type, public mixed $entity, public mixed $name)
    {
    }
    public static function fromApiData(array $data): self
    {
        return new self(
            text: $data[&apos;text&apos;] ?? null,
            type: $data[&apos;type&apos;] ?? null,
            entity: $data[&apos;entity&apos;] ?? null,
            name: $data[&apos;name&apos;] ?? null
        );
    }
}</file><file path="app/Http/Integrations/MusicBrainz/Models/AnnotationList.php">&lt;?php
namespace App\Http\Integrations\MusicBrainz\Models;
use Spatie\LaravelData\Data;
class AnnotationList extends Data
{
    public function __construct(public mixed $count, public mixed $offset, public mixed $annotation, public mixed $text, public mixed $type, public mixed $entity, public mixed $name)
    {
    }
    public static function fromApiData(array $data): self
    {
        return new self(
            count: $data[&apos;count&apos;] ?? null,
            offset: $data[&apos;offset&apos;] ?? null,
            annotation: $data[&apos;annotation&apos;] ?? null,
            text: $data[&apos;text&apos;] ?? null,
            type: $data[&apos;type&apos;] ?? null,
            entity: $data[&apos;entity&apos;] ?? null,
            name: $data[&apos;name&apos;] ?? null
        );
    }
}</file><file path="app/Http/Integrations/MusicBrainz/Models/Area.php">&lt;?php
namespace App\Http\Integrations\MusicBrainz\Models;
use Spatie\LaravelData\Data;
class Area extends Data
{
    public function __construct(public mixed $area, public mixed $id, public mixed $type, public mixed $type_id, public mixed $name, public mixed $sort_name, public mixed $disambiguation, public mixed $iso_3166_1_code, public mixed $iso_3166_2_code, public mixed $iso_3166_3_code, public mixed $annotation, public mixed $text, public mixed $entity, public mixed $life_span, public mixed $begin, public mixed $end, public mixed $ended, public mixed $count, public mixed $offset, public mixed $alias, public mixed $locale, public mixed $primary, public mixed $begin_date, public mixed $end_date, public mixed $tag, public mixed $user_tag, public mixed $genre, public mixed $target_type, public mixed $relation, public mixed $target, public mixed $ordering_key, public mixed $direction, public mixed $source_credit, public mixed $target_credit, public mixed $user_genre)
    {
    }
    public static function fromApiData(array $data): self
    {
        return new self(
            area: $data[&apos;area&apos;] ?? null,
            id: $data[&apos;id&apos;] ?? null,
            type: $data[&apos;type&apos;] ?? null,
            type_id: $data[&apos;type-id&apos;] ?? null,
            name: $data[&apos;name&apos;] ?? null,
            sort_name: $data[&apos;sort-name&apos;] ?? null,
            disambiguation: $data[&apos;disambiguation&apos;] ?? null,
            iso_3166_1_code: $data[&apos;iso-3166-1-code&apos;] ?? null,
            iso_3166_2_code: $data[&apos;iso-3166-2-code&apos;] ?? null,
            iso_3166_3_code: $data[&apos;iso-3166-3-code&apos;] ?? null,
            annotation: $data[&apos;annotation&apos;] ?? null,
            text: $data[&apos;text&apos;] ?? null,
            entity: $data[&apos;entity&apos;] ?? null,
            life_span: $data[&apos;life-span&apos;] ?? null,
            begin: $data[&apos;begin&apos;] ?? null,
            end: $data[&apos;end&apos;] ?? null,
            ended: $data[&apos;ended&apos;] ?? null,
            count: $data[&apos;count&apos;] ?? null,
            offset: $data[&apos;offset&apos;] ?? null,
            alias: $data[&apos;alias&apos;] ?? null,
            locale: $data[&apos;locale&apos;] ?? null,
            primary: $data[&apos;primary&apos;] ?? null,
            begin_date: $data[&apos;begin-date&apos;] ?? null,
            end_date: $data[&apos;end-date&apos;] ?? null,
            tag: $data[&apos;tag&apos;] ?? null,
            user_tag: $data[&apos;user-tag&apos;] ?? null,
            genre: $data[&apos;genre&apos;] ?? null,
            target_type: $data[&apos;target-type&apos;] ?? null,
            relation: $data[&apos;relation&apos;] ?? null,
            target: $data[&apos;target&apos;] ?? null,
            ordering_key: $data[&apos;ordering-key&apos;] ?? null,
            direction: $data[&apos;direction&apos;] ?? null,
            source_credit: $data[&apos;source-credit&apos;] ?? null,
            target_credit: $data[&apos;target-credit&apos;] ?? null,
            user_genre: $data[&apos;user-genre&apos;] ?? null
        );
    }
}</file><file path="app/Http/Integrations/MusicBrainz/Models/AreaElementInner.php">&lt;?php
namespace App\Http\Integrations\MusicBrainz\Models;
use Spatie\LaravelData\Data;
class AreaElementInner extends Data
{
    public function __construct(public mixed $id, public mixed $type, public mixed $type_id, public mixed $name, public mixed $sort_name, public mixed $disambiguation, public mixed $iso_3166_1_code, public mixed $iso_3166_2_code, public mixed $iso_3166_3_code, public mixed $annotation, public mixed $text, public mixed $entity, public mixed $life_span, public mixed $begin, public mixed $end, public mixed $ended, public mixed $count, public mixed $offset, public mixed $alias, public mixed $locale, public mixed $primary, public mixed $begin_date, public mixed $end_date, public mixed $tag, public mixed $user_tag, public mixed $genre, public mixed $target_type, public mixed $relation, public mixed $target, public mixed $ordering_key, public mixed $direction, public mixed $source_credit, public mixed $target_credit, public mixed $user_genre)
    {
    }
    public static function fromApiData(array $data): self
    {
        return new self(
            id: $data[&apos;id&apos;] ?? null,
            type: $data[&apos;type&apos;] ?? null,
            type_id: $data[&apos;type-id&apos;] ?? null,
            name: $data[&apos;name&apos;] ?? null,
            sort_name: $data[&apos;sort-name&apos;] ?? null,
            disambiguation: $data[&apos;disambiguation&apos;] ?? null,
            iso_3166_1_code: $data[&apos;iso-3166-1-code&apos;] ?? null,
            iso_3166_2_code: $data[&apos;iso-3166-2-code&apos;] ?? null,
            iso_3166_3_code: $data[&apos;iso-3166-3-code&apos;] ?? null,
            annotation: $data[&apos;annotation&apos;] ?? null,
            text: $data[&apos;text&apos;] ?? null,
            entity: $data[&apos;entity&apos;] ?? null,
            life_span: $data[&apos;life-span&apos;] ?? null,
            begin: $data[&apos;begin&apos;] ?? null,
            end: $data[&apos;end&apos;] ?? null,
            ended: $data[&apos;ended&apos;] ?? null,
            count: $data[&apos;count&apos;] ?? null,
            offset: $data[&apos;offset&apos;] ?? null,
            alias: $data[&apos;alias&apos;] ?? null,
            locale: $data[&apos;locale&apos;] ?? null,
            primary: $data[&apos;primary&apos;] ?? null,
            begin_date: $data[&apos;begin-date&apos;] ?? null,
            end_date: $data[&apos;end-date&apos;] ?? null,
            tag: $data[&apos;tag&apos;] ?? null,
            user_tag: $data[&apos;user-tag&apos;] ?? null,
            genre: $data[&apos;genre&apos;] ?? null,
            target_type: $data[&apos;target-type&apos;] ?? null,
            relation: $data[&apos;relation&apos;] ?? null,
            target: $data[&apos;target&apos;] ?? null,
            ordering_key: $data[&apos;ordering-key&apos;] ?? null,
            direction: $data[&apos;direction&apos;] ?? null,
            source_credit: $data[&apos;source-credit&apos;] ?? null,
            target_credit: $data[&apos;target-credit&apos;] ?? null,
            user_genre: $data[&apos;user-genre&apos;] ?? null
        );
    }
}</file><file path="app/Http/Integrations/MusicBrainz/Models/AreaList.php">&lt;?php
namespace App\Http\Integrations\MusicBrainz\Models;
use Spatie\LaravelData\Data;
class AreaList extends Data
{
    public function __construct(public mixed $count, public mixed $offset, public mixed $area, public mixed $id, public mixed $type, public mixed $type_id, public mixed $name, public mixed $sort_name, public mixed $disambiguation, public mixed $iso_3166_1_code, public mixed $iso_3166_2_code, public mixed $iso_3166_3_code, public mixed $annotation, public mixed $text, public mixed $entity, public mixed $life_span, public mixed $begin, public mixed $end, public mixed $ended, public mixed $alias, public mixed $locale, public mixed $primary, public mixed $begin_date, public mixed $end_date, public mixed $tag, public mixed $user_tag, public mixed $genre, public mixed $target_type, public mixed $relation, public mixed $target, public mixed $ordering_key, public mixed $direction, public mixed $source_credit, public mixed $target_credit, public mixed $user_genre)
    {
    }
    public static function fromApiData(array $data): self
    {
        return new self(
            count: $data[&apos;count&apos;] ?? null,
            offset: $data[&apos;offset&apos;] ?? null,
            area: $data[&apos;area&apos;] ?? null,
            id: $data[&apos;id&apos;] ?? null,
            type: $data[&apos;type&apos;] ?? null,
            type_id: $data[&apos;type-id&apos;] ?? null,
            name: $data[&apos;name&apos;] ?? null,
            sort_name: $data[&apos;sort-name&apos;] ?? null,
            disambiguation: $data[&apos;disambiguation&apos;] ?? null,
            iso_3166_1_code: $data[&apos;iso-3166-1-code&apos;] ?? null,
            iso_3166_2_code: $data[&apos;iso-3166-2-code&apos;] ?? null,
            iso_3166_3_code: $data[&apos;iso-3166-3-code&apos;] ?? null,
            annotation: $data[&apos;annotation&apos;] ?? null,
            text: $data[&apos;text&apos;] ?? null,
            entity: $data[&apos;entity&apos;] ?? null,
            life_span: $data[&apos;life-span&apos;] ?? null,
            begin: $data[&apos;begin&apos;] ?? null,
            end: $data[&apos;end&apos;] ?? null,
            ended: $data[&apos;ended&apos;] ?? null,
            alias: $data[&apos;alias&apos;] ?? null,
            locale: $data[&apos;locale&apos;] ?? null,
            primary: $data[&apos;primary&apos;] ?? null,
            begin_date: $data[&apos;begin-date&apos;] ?? null,
            end_date: $data[&apos;end-date&apos;] ?? null,
            tag: $data[&apos;tag&apos;] ?? null,
            user_tag: $data[&apos;user-tag&apos;] ?? null,
            genre: $data[&apos;genre&apos;] ?? null,
            target_type: $data[&apos;target-type&apos;] ?? null,
            relation: $data[&apos;relation&apos;] ?? null,
            target: $data[&apos;target&apos;] ?? null,
            ordering_key: $data[&apos;ordering-key&apos;] ?? null,
            direction: $data[&apos;direction&apos;] ?? null,
            source_credit: $data[&apos;source-credit&apos;] ?? null,
            target_credit: $data[&apos;target-credit&apos;] ?? null,
            user_genre: $data[&apos;user-genre&apos;] ?? null
        );
    }
}</file><file path="app/Http/Integrations/MusicBrainz/Models/Artist.php">&lt;?php
namespace App\Http\Integrations\MusicBrainz\Models;
use Spatie\LaravelData\Data;
class Artist extends Data
{
    public function __construct(public mixed $artist, public mixed $id, public mixed $type, public mixed $type_id, public mixed $name, public mixed $sort_name, public mixed $gender, public mixed $country, public mixed $area, public mixed $disambiguation, public mixed $iso_3166_1_code, public mixed $iso_3166_2_code, public mixed $iso_3166_3_code, public mixed $annotation, public mixed $text, public mixed $entity, public mixed $life_span, public mixed $begin, public mixed $end, public mixed $ended, public mixed $count, public mixed $offset, public mixed $alias, public mixed $locale, public mixed $primary, public mixed $begin_date, public mixed $end_date, public mixed $tag, public mixed $user_tag, public mixed $genre, public mixed $target_type, public mixed $relation, public mixed $target, public mixed $ordering_key, public mixed $direction, public mixed $source_credit, public mixed $target_credit, public mixed $user_genre, public mixed $begin_area, public mixed $end_area, public mixed $ipi, public mixed $isni, public mixed $recording, public mixed $title, public mixed $length, public mixed $video, public mixed $artist_credit, public mixed $first_release_date, public mixed $release, public mixed $status, public mixed $quality, public mixed $packaging, public mixed $text_representation, public mixed $language, public mixed $script, public mixed $release_group, public mixed $primary_type, public mixed $secondary_type, public mixed $rating, public mixed $votes_count, public mixed $user_rating, public mixed $date, public mixed $release_event, public mixed $barcode, public mixed $asin, public mixed $cover_art_archive, public mixed $artwork, public mixed $front, public mixed $back, public mixed $darkened, public mixed $label_info, public mixed $catalog_number, public mixed $label, public mixed $label_code, public mixed $track_count, public mixed $medium, public mixed $track, public mixed $position, public mixed $number, public mixed $format, public mixed $disc, public mixed $sectors, public mixed $pregap, public mixed $collection, public mixed $entity_type, public mixed $editor, public mixed $work, public mixed $fluency, public mixed $iswc, public mixed $event, public mixed $cancelled, public mixed $time, public mixed $setlist, public mixed $instrument, public mixed $description, public mixed $place, public mixed $address, public mixed $coordinates, public mixed $latitude, public mixed $longitude, public mixed $series, public mixed $puid, public mixed $isrc)
    {
    }
    public static function fromApiData(array $data): self
    {
        return new self(
            artist: $data[&apos;artist&apos;] ?? null,
            id: $data[&apos;id&apos;] ?? null,
            type: $data[&apos;type&apos;] ?? null,
            type_id: $data[&apos;type-id&apos;] ?? null,
            name: $data[&apos;name&apos;] ?? null,
            sort_name: $data[&apos;sort-name&apos;] ?? null,
            gender: $data[&apos;gender&apos;] ?? null,
            country: $data[&apos;country&apos;] ?? null,
            area: $data[&apos;area&apos;] ?? null,
            disambiguation: $data[&apos;disambiguation&apos;] ?? null,
            iso_3166_1_code: $data[&apos;iso-3166-1-code&apos;] ?? null,
            iso_3166_2_code: $data[&apos;iso-3166-2-code&apos;] ?? null,
            iso_3166_3_code: $data[&apos;iso-3166-3-code&apos;] ?? null,
            annotation: $data[&apos;annotation&apos;] ?? null,
            text: $data[&apos;text&apos;] ?? null,
            entity: $data[&apos;entity&apos;] ?? null,
            life_span: $data[&apos;life-span&apos;] ?? null,
            begin: $data[&apos;begin&apos;] ?? null,
            end: $data[&apos;end&apos;] ?? null,
            ended: $data[&apos;ended&apos;] ?? null,
            count: $data[&apos;count&apos;] ?? null,
            offset: $data[&apos;offset&apos;] ?? null,
            alias: $data[&apos;alias&apos;] ?? null,
            locale: $data[&apos;locale&apos;] ?? null,
            primary: $data[&apos;primary&apos;] ?? null,
            begin_date: $data[&apos;begin-date&apos;] ?? null,
            end_date: $data[&apos;end-date&apos;] ?? null,
            tag: $data[&apos;tag&apos;] ?? null,
            user_tag: $data[&apos;user-tag&apos;] ?? null,
            genre: $data[&apos;genre&apos;] ?? null,
            target_type: $data[&apos;target-type&apos;] ?? null,
            relation: $data[&apos;relation&apos;] ?? null,
            target: $data[&apos;target&apos;] ?? null,
            ordering_key: $data[&apos;ordering-key&apos;] ?? null,
            direction: $data[&apos;direction&apos;] ?? null,
            source_credit: $data[&apos;source-credit&apos;] ?? null,
            target_credit: $data[&apos;target-credit&apos;] ?? null,
            user_genre: $data[&apos;user-genre&apos;] ?? null,
            begin_area: $data[&apos;begin-area&apos;] ?? null,
            end_area: $data[&apos;end-area&apos;] ?? null,
            ipi: $data[&apos;ipi&apos;] ?? null,
            isni: $data[&apos;isni&apos;] ?? null,
            recording: $data[&apos;recording&apos;] ?? null,
            title: $data[&apos;title&apos;] ?? null,
            length: $data[&apos;length&apos;] ?? null,
            video: $data[&apos;video&apos;] ?? null,
            artist_credit: $data[&apos;artist-credit&apos;] ?? null,
            first_release_date: $data[&apos;first-release-date&apos;] ?? null,
            release: $data[&apos;release&apos;] ?? null,
            status: $data[&apos;status&apos;] ?? null,
            quality: $data[&apos;quality&apos;] ?? null,
            packaging: $data[&apos;packaging&apos;] ?? null,
            text_representation: $data[&apos;text-representation&apos;] ?? null,
            language: $data[&apos;language&apos;] ?? null,
            script: $data[&apos;script&apos;] ?? null,
            release_group: $data[&apos;release-group&apos;] ?? null,
            primary_type: $data[&apos;primary-type&apos;] ?? null,
            secondary_type: $data[&apos;secondary-type&apos;] ?? null,
            rating: $data[&apos;rating&apos;] ?? null,
            votes_count: $data[&apos;votes-count&apos;] ?? null,
            user_rating: $data[&apos;user-rating&apos;] ?? null,
            date: $data[&apos;date&apos;] ?? null,
            release_event: $data[&apos;release-event&apos;] ?? null,
            barcode: $data[&apos;barcode&apos;] ?? null,
            asin: $data[&apos;asin&apos;] ?? null,
            cover_art_archive: $data[&apos;cover-art-archive&apos;] ?? null,
            artwork: $data[&apos;artwork&apos;] ?? null,
            front: $data[&apos;front&apos;] ?? null,
            back: $data[&apos;back&apos;] ?? null,
            darkened: $data[&apos;darkened&apos;] ?? null,
            label_info: $data[&apos;label-info&apos;] ?? null,
            catalog_number: $data[&apos;catalog-number&apos;] ?? null,
            label: $data[&apos;label&apos;] ?? null,
            label_code: $data[&apos;label-code&apos;] ?? null,
            track_count: $data[&apos;track-count&apos;] ?? null,
            medium: $data[&apos;medium&apos;] ?? null,
            track: $data[&apos;track&apos;] ?? null,
            position: $data[&apos;position&apos;] ?? null,
            number: $data[&apos;number&apos;] ?? null,
            format: $data[&apos;format&apos;] ?? null,
            disc: $data[&apos;disc&apos;] ?? null,
            sectors: $data[&apos;sectors&apos;] ?? null,
            pregap: $data[&apos;pregap&apos;] ?? null,
            collection: $data[&apos;collection&apos;] ?? null,
            entity_type: $data[&apos;entity-type&apos;] ?? null,
            editor: $data[&apos;editor&apos;] ?? null,
            work: $data[&apos;work&apos;] ?? null,
            fluency: $data[&apos;fluency&apos;] ?? null,
            iswc: $data[&apos;iswc&apos;] ?? null,
            event: $data[&apos;event&apos;] ?? null,
            cancelled: $data[&apos;cancelled&apos;] ?? null,
            time: $data[&apos;time&apos;] ?? null,
            setlist: $data[&apos;setlist&apos;] ?? null,
            instrument: $data[&apos;instrument&apos;] ?? null,
            description: $data[&apos;description&apos;] ?? null,
            place: $data[&apos;place&apos;] ?? null,
            address: $data[&apos;address&apos;] ?? null,
            coordinates: $data[&apos;coordinates&apos;] ?? null,
            latitude: $data[&apos;latitude&apos;] ?? null,
            longitude: $data[&apos;longitude&apos;] ?? null,
            series: $data[&apos;series&apos;] ?? null,
            puid: $data[&apos;puid&apos;] ?? null,
            isrc: $data[&apos;isrc&apos;] ?? null
        );
    }
}</file><file path="app/Http/Integrations/MusicBrainz/Models/ArtistCredit.php">&lt;?php
namespace App\Http\Integrations\MusicBrainz\Models;
use Spatie\LaravelData\Data;
class ArtistCredit extends Data
{
    public function __construct(public mixed $artist_credit, public mixed $id)
    {
    }
    public static function fromApiData(array $data): self
    {
        return new self(
            artist_credit: $data[&apos;artist-credit&apos;] ?? null,
            id: $data[&apos;id&apos;] ?? null
        );
    }
}</file><file path="app/Http/Integrations/MusicBrainz/Models/ArtistList.php">&lt;?php
namespace App\Http\Integrations\MusicBrainz\Models;
use Spatie\LaravelData\Data;
class ArtistList extends Data
{
    public function __construct(public mixed $count, public mixed $offset, public mixed $artist, public mixed $id, public mixed $type, public mixed $type_id, public mixed $name, public mixed $sort_name, public mixed $gender, public mixed $country, public mixed $area, public mixed $disambiguation, public mixed $iso_3166_1_code, public mixed $iso_3166_2_code, public mixed $iso_3166_3_code, public mixed $annotation, public mixed $text, public mixed $entity, public mixed $life_span, public mixed $begin, public mixed $end, public mixed $ended, public mixed $alias, public mixed $locale, public mixed $primary, public mixed $begin_date, public mixed $end_date, public mixed $tag, public mixed $user_tag, public mixed $genre, public mixed $target_type, public mixed $relation, public mixed $target, public mixed $ordering_key, public mixed $direction, public mixed $source_credit, public mixed $target_credit, public mixed $user_genre, public mixed $begin_area, public mixed $end_area, public mixed $ipi, public mixed $isni, public mixed $recording, public mixed $title, public mixed $length, public mixed $video, public mixed $artist_credit, public mixed $first_release_date, public mixed $release, public mixed $status, public mixed $quality, public mixed $packaging, public mixed $text_representation, public mixed $language, public mixed $script, public mixed $release_group, public mixed $primary_type, public mixed $secondary_type, public mixed $rating, public mixed $votes_count, public mixed $user_rating, public mixed $date, public mixed $release_event, public mixed $barcode, public mixed $asin, public mixed $cover_art_archive, public mixed $artwork, public mixed $front, public mixed $back, public mixed $darkened, public mixed $label_info, public mixed $catalog_number, public mixed $label, public mixed $label_code, public mixed $track_count, public mixed $medium, public mixed $track, public mixed $position, public mixed $number, public mixed $format, public mixed $disc, public mixed $sectors, public mixed $pregap, public mixed $collection, public mixed $entity_type, public mixed $editor, public mixed $event, public mixed $cancelled, public mixed $time, public mixed $setlist, public mixed $instrument, public mixed $description, public mixed $place, public mixed $address, public mixed $coordinates, public mixed $latitude, public mixed $longitude, public mixed $series, public mixed $work, public mixed $fluency, public mixed $iswc, public mixed $puid, public mixed $isrc)
    {
    }
    public static function fromApiData(array $data): self
    {
        return new self(
            count: $data[&apos;count&apos;] ?? null,
            offset: $data[&apos;offset&apos;] ?? null,
            artist: $data[&apos;artist&apos;] ?? null,
            id: $data[&apos;id&apos;] ?? null,
            type: $data[&apos;type&apos;] ?? null,
            type_id: $data[&apos;type-id&apos;] ?? null,
            name: $data[&apos;name&apos;] ?? null,
            sort_name: $data[&apos;sort-name&apos;] ?? null,
            gender: $data[&apos;gender&apos;] ?? null,
            country: $data[&apos;country&apos;] ?? null,
            area: $data[&apos;area&apos;] ?? null,
            disambiguation: $data[&apos;disambiguation&apos;] ?? null,
            iso_3166_1_code: $data[&apos;iso-3166-1-code&apos;] ?? null,
            iso_3166_2_code: $data[&apos;iso-3166-2-code&apos;] ?? null,
            iso_3166_3_code: $data[&apos;iso-3166-3-code&apos;] ?? null,
            annotation: $data[&apos;annotation&apos;] ?? null,
            text: $data[&apos;text&apos;] ?? null,
            entity: $data[&apos;entity&apos;] ?? null,
            life_span: $data[&apos;life-span&apos;] ?? null,
            begin: $data[&apos;begin&apos;] ?? null,
            end: $data[&apos;end&apos;] ?? null,
            ended: $data[&apos;ended&apos;] ?? null,
            alias: $data[&apos;alias&apos;] ?? null,
            locale: $data[&apos;locale&apos;] ?? null,
            primary: $data[&apos;primary&apos;] ?? null,
            begin_date: $data[&apos;begin-date&apos;] ?? null,
            end_date: $data[&apos;end-date&apos;] ?? null,
            tag: $data[&apos;tag&apos;] ?? null,
            user_tag: $data[&apos;user-tag&apos;] ?? null,
            genre: $data[&apos;genre&apos;] ?? null,
            target_type: $data[&apos;target-type&apos;] ?? null,
            relation: $data[&apos;relation&apos;] ?? null,
            target: $data[&apos;target&apos;] ?? null,
            ordering_key: $data[&apos;ordering-key&apos;] ?? null,
            direction: $data[&apos;direction&apos;] ?? null,
            source_credit: $data[&apos;source-credit&apos;] ?? null,
            target_credit: $data[&apos;target-credit&apos;] ?? null,
            user_genre: $data[&apos;user-genre&apos;] ?? null,
            begin_area: $data[&apos;begin-area&apos;] ?? null,
            end_area: $data[&apos;end-area&apos;] ?? null,
            ipi: $data[&apos;ipi&apos;] ?? null,
            isni: $data[&apos;isni&apos;] ?? null,
            recording: $data[&apos;recording&apos;] ?? null,
            title: $data[&apos;title&apos;] ?? null,
            length: $data[&apos;length&apos;] ?? null,
            video: $data[&apos;video&apos;] ?? null,
            artist_credit: $data[&apos;artist-credit&apos;] ?? null,
            first_release_date: $data[&apos;first-release-date&apos;] ?? null,
            release: $data[&apos;release&apos;] ?? null,
            status: $data[&apos;status&apos;] ?? null,
            quality: $data[&apos;quality&apos;] ?? null,
            packaging: $data[&apos;packaging&apos;] ?? null,
            text_representation: $data[&apos;text-representation&apos;] ?? null,
            language: $data[&apos;language&apos;] ?? null,
            script: $data[&apos;script&apos;] ?? null,
            release_group: $data[&apos;release-group&apos;] ?? null,
            primary_type: $data[&apos;primary-type&apos;] ?? null,
            secondary_type: $data[&apos;secondary-type&apos;] ?? null,
            rating: $data[&apos;rating&apos;] ?? null,
            votes_count: $data[&apos;votes-count&apos;] ?? null,
            user_rating: $data[&apos;user-rating&apos;] ?? null,
            date: $data[&apos;date&apos;] ?? null,
            release_event: $data[&apos;release-event&apos;] ?? null,
            barcode: $data[&apos;barcode&apos;] ?? null,
            asin: $data[&apos;asin&apos;] ?? null,
            cover_art_archive: $data[&apos;cover-art-archive&apos;] ?? null,
            artwork: $data[&apos;artwork&apos;] ?? null,
            front: $data[&apos;front&apos;] ?? null,
            back: $data[&apos;back&apos;] ?? null,
            darkened: $data[&apos;darkened&apos;] ?? null,
            label_info: $data[&apos;label-info&apos;] ?? null,
            catalog_number: $data[&apos;catalog-number&apos;] ?? null,
            label: $data[&apos;label&apos;] ?? null,
            label_code: $data[&apos;label-code&apos;] ?? null,
            track_count: $data[&apos;track-count&apos;] ?? null,
            medium: $data[&apos;medium&apos;] ?? null,
            track: $data[&apos;track&apos;] ?? null,
            position: $data[&apos;position&apos;] ?? null,
            number: $data[&apos;number&apos;] ?? null,
            format: $data[&apos;format&apos;] ?? null,
            disc: $data[&apos;disc&apos;] ?? null,
            sectors: $data[&apos;sectors&apos;] ?? null,
            pregap: $data[&apos;pregap&apos;] ?? null,
            collection: $data[&apos;collection&apos;] ?? null,
            entity_type: $data[&apos;entity-type&apos;] ?? null,
            editor: $data[&apos;editor&apos;] ?? null,
            event: $data[&apos;event&apos;] ?? null,
            cancelled: $data[&apos;cancelled&apos;] ?? null,
            time: $data[&apos;time&apos;] ?? null,
            setlist: $data[&apos;setlist&apos;] ?? null,
            instrument: $data[&apos;instrument&apos;] ?? null,
            description: $data[&apos;description&apos;] ?? null,
            place: $data[&apos;place&apos;] ?? null,
            address: $data[&apos;address&apos;] ?? null,
            coordinates: $data[&apos;coordinates&apos;] ?? null,
            latitude: $data[&apos;latitude&apos;] ?? null,
            longitude: $data[&apos;longitude&apos;] ?? null,
            series: $data[&apos;series&apos;] ?? null,
            work: $data[&apos;work&apos;] ?? null,
            fluency: $data[&apos;fluency&apos;] ?? null,
            iswc: $data[&apos;iswc&apos;] ?? null,
            puid: $data[&apos;puid&apos;] ?? null,
            isrc: $data[&apos;isrc&apos;] ?? null
        );
    }
}</file><file path="app/Http/Integrations/MusicBrainz/Models/AttributeList.php">&lt;?php
namespace App\Http\Integrations\MusicBrainz\Models;
use Spatie\LaravelData\Data;
class AttributeList extends Data
{
    public function __construct()
    {
    }
    public static function fromApiData(array $data): self
    {
        return new self(
        );
    }
}</file><file path="app/Http/Integrations/MusicBrainz/Models/Cancelled.php">&lt;?php
namespace App\Http\Integrations\MusicBrainz\Models;
use Spatie\LaravelData\Data;
class Cancelled extends Data
{
    public function __construct()
    {
    }
    public static function fromApiData(array $data): self
    {
        return new self(
        );
    }
}</file><file path="app/Http/Integrations/MusicBrainz/Models/Cdstub.php">&lt;?php
namespace App\Http\Integrations\MusicBrainz\Models;
use Spatie\LaravelData\Data;
class Cdstub extends Data
{
    public function __construct(public mixed $title, public mixed $id, public mixed $count, public mixed $offset, public mixed $track, public mixed $length, public mixed $artist, public mixed $barcode, public mixed $disambiguation)
    {
    }
    public static function fromApiData(array $data): self
    {
        return new self(
            title: $data[&apos;title&apos;] ?? null,
            id: $data[&apos;id&apos;] ?? null,
            count: $data[&apos;count&apos;] ?? null,
            offset: $data[&apos;offset&apos;] ?? null,
            track: $data[&apos;track&apos;] ?? null,
            length: $data[&apos;length&apos;] ?? null,
            artist: $data[&apos;artist&apos;] ?? null,
            barcode: $data[&apos;barcode&apos;] ?? null,
            disambiguation: $data[&apos;disambiguation&apos;] ?? null
        );
    }
}</file><file path="app/Http/Integrations/MusicBrainz/Models/CdstubList.php">&lt;?php
namespace App\Http\Integrations\MusicBrainz\Models;
use Spatie\LaravelData\Data;
class CdstubList extends Data
{
    public function __construct(public mixed $count, public mixed $offset, public mixed $cdstub, public mixed $title, public mixed $id, public mixed $track, public mixed $length, public mixed $artist, public mixed $barcode, public mixed $disambiguation)
    {
    }
    public static function fromApiData(array $data): self
    {
        return new self(
            count: $data[&apos;count&apos;] ?? null,
            offset: $data[&apos;offset&apos;] ?? null,
            cdstub: $data[&apos;cdstub&apos;] ?? null,
            title: $data[&apos;title&apos;] ?? null,
            id: $data[&apos;id&apos;] ?? null,
            track: $data[&apos;track&apos;] ?? null,
            length: $data[&apos;length&apos;] ?? null,
            artist: $data[&apos;artist&apos;] ?? null,
            barcode: $data[&apos;barcode&apos;] ?? null,
            disambiguation: $data[&apos;disambiguation&apos;] ?? null
        );
    }
}</file><file path="app/Http/Integrations/MusicBrainz/Models/Collection.php">&lt;?php
namespace App\Http\Integrations\MusicBrainz\Models;
use Spatie\LaravelData\Data;
class Collection extends Data
{
    public function __construct(public mixed $name, public mixed $id, public mixed $type, public mixed $type_id, public mixed $entity_type, public mixed $editor, public mixed $count, public mixed $offset, public mixed $area, public mixed $sort_name, public mixed $disambiguation, public mixed $iso_3166_1_code, public mixed $iso_3166_2_code, public mixed $iso_3166_3_code, public mixed $annotation, public mixed $text, public mixed $entity, public mixed $life_span, public mixed $begin, public mixed $end, public mixed $ended, public mixed $alias, public mixed $locale, public mixed $primary, public mixed $begin_date, public mixed $end_date, public mixed $tag, public mixed $user_tag, public mixed $genre, public mixed $target_type, public mixed $relation, public mixed $target, public mixed $ordering_key, public mixed $direction, public mixed $source_credit, public mixed $target_credit, public mixed $user_genre, public mixed $artist, public mixed $gender, public mixed $country, public mixed $begin_area, public mixed $end_area, public mixed $ipi, public mixed $isni, public mixed $recording, public mixed $title, public mixed $length, public mixed $video, public mixed $artist_credit, public mixed $first_release_date, public mixed $release, public mixed $status, public mixed $quality, public mixed $packaging, public mixed $text_representation, public mixed $language, public mixed $script, public mixed $release_group, public mixed $primary_type, public mixed $secondary_type, public mixed $rating, public mixed $votes_count, public mixed $user_rating, public mixed $date, public mixed $release_event, public mixed $barcode, public mixed $asin, public mixed $cover_art_archive, public mixed $artwork, public mixed $front, public mixed $back, public mixed $darkened, public mixed $label_info, public mixed $catalog_number, public mixed $label, public mixed $label_code, public mixed $track_count, public mixed $medium, public mixed $track, public mixed $position, public mixed $number, public mixed $format, public mixed $disc, public mixed $sectors, public mixed $pregap, public mixed $event, public mixed $cancelled, public mixed $time, public mixed $setlist, public mixed $instrument, public mixed $description, public mixed $place, public mixed $address, public mixed $coordinates, public mixed $latitude, public mixed $longitude, public mixed $series, public mixed $work, public mixed $fluency, public mixed $iswc, public mixed $puid, public mixed $isrc)
    {
    }
    public static function fromApiData(array $data): self
    {
        return new self(
            name: $data[&apos;name&apos;] ?? null,
            id: $data[&apos;id&apos;] ?? null,
            type: $data[&apos;type&apos;] ?? null,
            type_id: $data[&apos;type-id&apos;] ?? null,
            entity_type: $data[&apos;entity-type&apos;] ?? null,
            editor: $data[&apos;editor&apos;] ?? null,
            count: $data[&apos;count&apos;] ?? null,
            offset: $data[&apos;offset&apos;] ?? null,
            area: $data[&apos;area&apos;] ?? null,
            sort_name: $data[&apos;sort-name&apos;] ?? null,
            disambiguation: $data[&apos;disambiguation&apos;] ?? null,
            iso_3166_1_code: $data[&apos;iso-3166-1-code&apos;] ?? null,
            iso_3166_2_code: $data[&apos;iso-3166-2-code&apos;] ?? null,
            iso_3166_3_code: $data[&apos;iso-3166-3-code&apos;] ?? null,
            annotation: $data[&apos;annotation&apos;] ?? null,
            text: $data[&apos;text&apos;] ?? null,
            entity: $data[&apos;entity&apos;] ?? null,
            life_span: $data[&apos;life-span&apos;] ?? null,
            begin: $data[&apos;begin&apos;] ?? null,
            end: $data[&apos;end&apos;] ?? null,
            ended: $data[&apos;ended&apos;] ?? null,
            alias: $data[&apos;alias&apos;] ?? null,
            locale: $data[&apos;locale&apos;] ?? null,
            primary: $data[&apos;primary&apos;] ?? null,
            begin_date: $data[&apos;begin-date&apos;] ?? null,
            end_date: $data[&apos;end-date&apos;] ?? null,
            tag: $data[&apos;tag&apos;] ?? null,
            user_tag: $data[&apos;user-tag&apos;] ?? null,
            genre: $data[&apos;genre&apos;] ?? null,
            target_type: $data[&apos;target-type&apos;] ?? null,
            relation: $data[&apos;relation&apos;] ?? null,
            target: $data[&apos;target&apos;] ?? null,
            ordering_key: $data[&apos;ordering-key&apos;] ?? null,
            direction: $data[&apos;direction&apos;] ?? null,
            source_credit: $data[&apos;source-credit&apos;] ?? null,
            target_credit: $data[&apos;target-credit&apos;] ?? null,
            user_genre: $data[&apos;user-genre&apos;] ?? null,
            artist: $data[&apos;artist&apos;] ?? null,
            gender: $data[&apos;gender&apos;] ?? null,
            country: $data[&apos;country&apos;] ?? null,
            begin_area: $data[&apos;begin-area&apos;] ?? null,
            end_area: $data[&apos;end-area&apos;] ?? null,
            ipi: $data[&apos;ipi&apos;] ?? null,
            isni: $data[&apos;isni&apos;] ?? null,
            recording: $data[&apos;recording&apos;] ?? null,
            title: $data[&apos;title&apos;] ?? null,
            length: $data[&apos;length&apos;] ?? null,
            video: $data[&apos;video&apos;] ?? null,
            artist_credit: $data[&apos;artist-credit&apos;] ?? null,
            first_release_date: $data[&apos;first-release-date&apos;] ?? null,
            release: $data[&apos;release&apos;] ?? null,
            status: $data[&apos;status&apos;] ?? null,
            quality: $data[&apos;quality&apos;] ?? null,
            packaging: $data[&apos;packaging&apos;] ?? null,
            text_representation: $data[&apos;text-representation&apos;] ?? null,
            language: $data[&apos;language&apos;] ?? null,
            script: $data[&apos;script&apos;] ?? null,
            release_group: $data[&apos;release-group&apos;] ?? null,
            primary_type: $data[&apos;primary-type&apos;] ?? null,
            secondary_type: $data[&apos;secondary-type&apos;] ?? null,
            rating: $data[&apos;rating&apos;] ?? null,
            votes_count: $data[&apos;votes-count&apos;] ?? null,
            user_rating: $data[&apos;user-rating&apos;] ?? null,
            date: $data[&apos;date&apos;] ?? null,
            release_event: $data[&apos;release-event&apos;] ?? null,
            barcode: $data[&apos;barcode&apos;] ?? null,
            asin: $data[&apos;asin&apos;] ?? null,
            cover_art_archive: $data[&apos;cover-art-archive&apos;] ?? null,
            artwork: $data[&apos;artwork&apos;] ?? null,
            front: $data[&apos;front&apos;] ?? null,
            back: $data[&apos;back&apos;] ?? null,
            darkened: $data[&apos;darkened&apos;] ?? null,
            label_info: $data[&apos;label-info&apos;] ?? null,
            catalog_number: $data[&apos;catalog-number&apos;] ?? null,
            label: $data[&apos;label&apos;] ?? null,
            label_code: $data[&apos;label-code&apos;] ?? null,
            track_count: $data[&apos;track-count&apos;] ?? null,
            medium: $data[&apos;medium&apos;] ?? null,
            track: $data[&apos;track&apos;] ?? null,
            position: $data[&apos;position&apos;] ?? null,
            number: $data[&apos;number&apos;] ?? null,
            format: $data[&apos;format&apos;] ?? null,
            disc: $data[&apos;disc&apos;] ?? null,
            sectors: $data[&apos;sectors&apos;] ?? null,
            pregap: $data[&apos;pregap&apos;] ?? null,
            event: $data[&apos;event&apos;] ?? null,
            cancelled: $data[&apos;cancelled&apos;] ?? null,
            time: $data[&apos;time&apos;] ?? null,
            setlist: $data[&apos;setlist&apos;] ?? null,
            instrument: $data[&apos;instrument&apos;] ?? null,
            description: $data[&apos;description&apos;] ?? null,
            place: $data[&apos;place&apos;] ?? null,
            address: $data[&apos;address&apos;] ?? null,
            coordinates: $data[&apos;coordinates&apos;] ?? null,
            latitude: $data[&apos;latitude&apos;] ?? null,
            longitude: $data[&apos;longitude&apos;] ?? null,
            series: $data[&apos;series&apos;] ?? null,
            work: $data[&apos;work&apos;] ?? null,
            fluency: $data[&apos;fluency&apos;] ?? null,
            iswc: $data[&apos;iswc&apos;] ?? null,
            puid: $data[&apos;puid&apos;] ?? null,
            isrc: $data[&apos;isrc&apos;] ?? null
        );
    }
}</file><file path="app/Http/Integrations/MusicBrainz/Models/CollectionList.php">&lt;?php
namespace App\Http\Integrations\MusicBrainz\Models;
use Spatie\LaravelData\Data;
class CollectionList extends Data
{
    public function __construct(public mixed $count, public mixed $offset, public mixed $collection, public mixed $name, public mixed $id, public mixed $type, public mixed $type_id, public mixed $entity_type, public mixed $editor, public mixed $area, public mixed $sort_name, public mixed $disambiguation, public mixed $iso_3166_1_code, public mixed $iso_3166_2_code, public mixed $iso_3166_3_code, public mixed $annotation, public mixed $text, public mixed $entity, public mixed $life_span, public mixed $begin, public mixed $end, public mixed $ended, public mixed $alias, public mixed $locale, public mixed $primary, public mixed $begin_date, public mixed $end_date, public mixed $tag, public mixed $user_tag, public mixed $genre, public mixed $target_type, public mixed $relation, public mixed $target, public mixed $ordering_key, public mixed $direction, public mixed $source_credit, public mixed $target_credit, public mixed $user_genre, public mixed $artist, public mixed $gender, public mixed $country, public mixed $begin_area, public mixed $end_area, public mixed $ipi, public mixed $isni, public mixed $recording, public mixed $title, public mixed $length, public mixed $video, public mixed $artist_credit, public mixed $first_release_date, public mixed $release, public mixed $status, public mixed $quality, public mixed $packaging, public mixed $text_representation, public mixed $language, public mixed $script, public mixed $release_group, public mixed $primary_type, public mixed $secondary_type, public mixed $rating, public mixed $votes_count, public mixed $user_rating, public mixed $date, public mixed $release_event, public mixed $barcode, public mixed $asin, public mixed $cover_art_archive, public mixed $artwork, public mixed $front, public mixed $back, public mixed $darkened, public mixed $label_info, public mixed $catalog_number, public mixed $label, public mixed $label_code, public mixed $track_count, public mixed $medium, public mixed $track, public mixed $position, public mixed $number, public mixed $format, public mixed $disc, public mixed $sectors, public mixed $pregap, public mixed $puid, public mixed $isrc, public mixed $work, public mixed $fluency, public mixed $iswc, public mixed $event, public mixed $cancelled, public mixed $time, public mixed $setlist, public mixed $instrument, public mixed $description, public mixed $place, public mixed $address, public mixed $coordinates, public mixed $latitude, public mixed $longitude, public mixed $series)
    {
    }
    public static function fromApiData(array $data): self
    {
        return new self(
            count: $data[&apos;count&apos;] ?? null,
            offset: $data[&apos;offset&apos;] ?? null,
            collection: $data[&apos;collection&apos;] ?? null,
            name: $data[&apos;name&apos;] ?? null,
            id: $data[&apos;id&apos;] ?? null,
            type: $data[&apos;type&apos;] ?? null,
            type_id: $data[&apos;type-id&apos;] ?? null,
            entity_type: $data[&apos;entity-type&apos;] ?? null,
            editor: $data[&apos;editor&apos;] ?? null,
            area: $data[&apos;area&apos;] ?? null,
            sort_name: $data[&apos;sort-name&apos;] ?? null,
            disambiguation: $data[&apos;disambiguation&apos;] ?? null,
            iso_3166_1_code: $data[&apos;iso-3166-1-code&apos;] ?? null,
            iso_3166_2_code: $data[&apos;iso-3166-2-code&apos;] ?? null,
            iso_3166_3_code: $data[&apos;iso-3166-3-code&apos;] ?? null,
            annotation: $data[&apos;annotation&apos;] ?? null,
            text: $data[&apos;text&apos;] ?? null,
            entity: $data[&apos;entity&apos;] ?? null,
            life_span: $data[&apos;life-span&apos;] ?? null,
            begin: $data[&apos;begin&apos;] ?? null,
            end: $data[&apos;end&apos;] ?? null,
            ended: $data[&apos;ended&apos;] ?? null,
            alias: $data[&apos;alias&apos;] ?? null,
            locale: $data[&apos;locale&apos;] ?? null,
            primary: $data[&apos;primary&apos;] ?? null,
            begin_date: $data[&apos;begin-date&apos;] ?? null,
            end_date: $data[&apos;end-date&apos;] ?? null,
            tag: $data[&apos;tag&apos;] ?? null,
            user_tag: $data[&apos;user-tag&apos;] ?? null,
            genre: $data[&apos;genre&apos;] ?? null,
            target_type: $data[&apos;target-type&apos;] ?? null,
            relation: $data[&apos;relation&apos;] ?? null,
            target: $data[&apos;target&apos;] ?? null,
            ordering_key: $data[&apos;ordering-key&apos;] ?? null,
            direction: $data[&apos;direction&apos;] ?? null,
            source_credit: $data[&apos;source-credit&apos;] ?? null,
            target_credit: $data[&apos;target-credit&apos;] ?? null,
            user_genre: $data[&apos;user-genre&apos;] ?? null,
            artist: $data[&apos;artist&apos;] ?? null,
            gender: $data[&apos;gender&apos;] ?? null,
            country: $data[&apos;country&apos;] ?? null,
            begin_area: $data[&apos;begin-area&apos;] ?? null,
            end_area: $data[&apos;end-area&apos;] ?? null,
            ipi: $data[&apos;ipi&apos;] ?? null,
            isni: $data[&apos;isni&apos;] ?? null,
            recording: $data[&apos;recording&apos;] ?? null,
            title: $data[&apos;title&apos;] ?? null,
            length: $data[&apos;length&apos;] ?? null,
            video: $data[&apos;video&apos;] ?? null,
            artist_credit: $data[&apos;artist-credit&apos;] ?? null,
            first_release_date: $data[&apos;first-release-date&apos;] ?? null,
            release: $data[&apos;release&apos;] ?? null,
            status: $data[&apos;status&apos;] ?? null,
            quality: $data[&apos;quality&apos;] ?? null,
            packaging: $data[&apos;packaging&apos;] ?? null,
            text_representation: $data[&apos;text-representation&apos;] ?? null,
            language: $data[&apos;language&apos;] ?? null,
            script: $data[&apos;script&apos;] ?? null,
            release_group: $data[&apos;release-group&apos;] ?? null,
            primary_type: $data[&apos;primary-type&apos;] ?? null,
            secondary_type: $data[&apos;secondary-type&apos;] ?? null,
            rating: $data[&apos;rating&apos;] ?? null,
            votes_count: $data[&apos;votes-count&apos;] ?? null,
            user_rating: $data[&apos;user-rating&apos;] ?? null,
            date: $data[&apos;date&apos;] ?? null,
            release_event: $data[&apos;release-event&apos;] ?? null,
            barcode: $data[&apos;barcode&apos;] ?? null,
            asin: $data[&apos;asin&apos;] ?? null,
            cover_art_archive: $data[&apos;cover-art-archive&apos;] ?? null,
            artwork: $data[&apos;artwork&apos;] ?? null,
            front: $data[&apos;front&apos;] ?? null,
            back: $data[&apos;back&apos;] ?? null,
            darkened: $data[&apos;darkened&apos;] ?? null,
            label_info: $data[&apos;label-info&apos;] ?? null,
            catalog_number: $data[&apos;catalog-number&apos;] ?? null,
            label: $data[&apos;label&apos;] ?? null,
            label_code: $data[&apos;label-code&apos;] ?? null,
            track_count: $data[&apos;track-count&apos;] ?? null,
            medium: $data[&apos;medium&apos;] ?? null,
            track: $data[&apos;track&apos;] ?? null,
            position: $data[&apos;position&apos;] ?? null,
            number: $data[&apos;number&apos;] ?? null,
            format: $data[&apos;format&apos;] ?? null,
            disc: $data[&apos;disc&apos;] ?? null,
            sectors: $data[&apos;sectors&apos;] ?? null,
            pregap: $data[&apos;pregap&apos;] ?? null,
            puid: $data[&apos;puid&apos;] ?? null,
            isrc: $data[&apos;isrc&apos;] ?? null,
            work: $data[&apos;work&apos;] ?? null,
            fluency: $data[&apos;fluency&apos;] ?? null,
            iswc: $data[&apos;iswc&apos;] ?? null,
            event: $data[&apos;event&apos;] ?? null,
            cancelled: $data[&apos;cancelled&apos;] ?? null,
            time: $data[&apos;time&apos;] ?? null,
            setlist: $data[&apos;setlist&apos;] ?? null,
            instrument: $data[&apos;instrument&apos;] ?? null,
            description: $data[&apos;description&apos;] ?? null,
            place: $data[&apos;place&apos;] ?? null,
            address: $data[&apos;address&apos;] ?? null,
            coordinates: $data[&apos;coordinates&apos;] ?? null,
            latitude: $data[&apos;latitude&apos;] ?? null,
            longitude: $data[&apos;longitude&apos;] ?? null,
            series: $data[&apos;series&apos;] ?? null
        );
    }
}</file><file path="app/Http/Integrations/MusicBrainz/Models/CoverArtArchive.php">&lt;?php
namespace App\Http\Integrations\MusicBrainz\Models;
use Spatie\LaravelData\Data;
class CoverArtArchive extends Data
{
    public function __construct(public mixed $cover_art_archive, public mixed $artwork, public mixed $count, public mixed $front, public mixed $back, public mixed $darkened)
    {
    }
    public static function fromApiData(array $data): self
    {
        return new self(
            cover_art_archive: $data[&apos;cover-art-archive&apos;] ?? null,
            artwork: $data[&apos;artwork&apos;] ?? null,
            count: $data[&apos;count&apos;] ?? null,
            front: $data[&apos;front&apos;] ?? null,
            back: $data[&apos;back&apos;] ?? null,
            darkened: $data[&apos;darkened&apos;] ?? null
        );
    }
}</file><file path="app/Http/Integrations/MusicBrainz/Models/DataTrackList.php">&lt;?php
namespace App\Http\Integrations\MusicBrainz\Models;
use Spatie\LaravelData\Data;
class DataTrackList extends Data
{
    public function __construct(public mixed $count, public mixed $offset)
    {
    }
    public static function fromApiData(array $data): self
    {
        return new self(
            count: $data[&apos;count&apos;] ?? null,
            offset: $data[&apos;offset&apos;] ?? null
        );
    }
}</file><file path="app/Http/Integrations/MusicBrainz/Models/Disc.php">&lt;?php
namespace App\Http\Integrations\MusicBrainz\Models;
use Spatie\LaravelData\Data;
class Disc extends Data
{
    public function __construct(public mixed $disc, public mixed $id, public mixed $sectors, public mixed $count, public mixed $offset, public mixed $position, public mixed $release, public mixed $title, public mixed $status, public mixed $quality, public mixed $annotation, public mixed $text, public mixed $type, public mixed $entity, public mixed $name, public mixed $disambiguation, public mixed $packaging, public mixed $text_representation, public mixed $language, public mixed $script, public mixed $artist_credit, public mixed $alias, public mixed $locale, public mixed $sort_name, public mixed $type_id, public mixed $primary, public mixed $begin_date, public mixed $end_date, public mixed $release_group, public mixed $first_release_date, public mixed $primary_type, public mixed $secondary_type, public mixed $tag, public mixed $user_tag, public mixed $genre, public mixed $target_type, public mixed $relation, public mixed $target, public mixed $ordering_key, public mixed $direction, public mixed $begin, public mixed $end, public mixed $ended, public mixed $source_credit, public mixed $target_credit, public mixed $user_genre, public mixed $rating, public mixed $votes_count, public mixed $user_rating, public mixed $date, public mixed $country, public mixed $release_event, public mixed $area, public mixed $iso_3166_1_code, public mixed $iso_3166_2_code, public mixed $iso_3166_3_code, public mixed $life_span, public mixed $barcode, public mixed $asin, public mixed $cover_art_archive, public mixed $artwork, public mixed $front, public mixed $back, public mixed $darkened, public mixed $label_info, public mixed $catalog_number, public mixed $label, public mixed $label_code, public mixed $ipi, public mixed $isni, public mixed $track_count, public mixed $medium, public mixed $track, public mixed $number, public mixed $length, public mixed $recording, public mixed $video, public mixed $puid, public mixed $isrc, public mixed $format, public mixed $pregap, public mixed $collection, public mixed $entity_type, public mixed $editor, public mixed $artist, public mixed $gender, public mixed $begin_area, public mixed $end_area, public mixed $work, public mixed $fluency, public mixed $iswc, public mixed $event, public mixed $cancelled, public mixed $time, public mixed $setlist, public mixed $instrument, public mixed $description, public mixed $place, public mixed $address, public mixed $coordinates, public mixed $latitude, public mixed $longitude, public mixed $series)
    {
    }
    public static function fromApiData(array $data): self
    {
        return new self(
            disc: $data[&apos;disc&apos;] ?? null,
            id: $data[&apos;id&apos;] ?? null,
            sectors: $data[&apos;sectors&apos;] ?? null,
            count: $data[&apos;count&apos;] ?? null,
            offset: $data[&apos;offset&apos;] ?? null,
            position: $data[&apos;position&apos;] ?? null,
            release: $data[&apos;release&apos;] ?? null,
            title: $data[&apos;title&apos;] ?? null,
            status: $data[&apos;status&apos;] ?? null,
            quality: $data[&apos;quality&apos;] ?? null,
            annotation: $data[&apos;annotation&apos;] ?? null,
            text: $data[&apos;text&apos;] ?? null,
            type: $data[&apos;type&apos;] ?? null,
            entity: $data[&apos;entity&apos;] ?? null,
            name: $data[&apos;name&apos;] ?? null,
            disambiguation: $data[&apos;disambiguation&apos;] ?? null,
            packaging: $data[&apos;packaging&apos;] ?? null,
            text_representation: $data[&apos;text-representation&apos;] ?? null,
            language: $data[&apos;language&apos;] ?? null,
            script: $data[&apos;script&apos;] ?? null,
            artist_credit: $data[&apos;artist-credit&apos;] ?? null,
            alias: $data[&apos;alias&apos;] ?? null,
            locale: $data[&apos;locale&apos;] ?? null,
            sort_name: $data[&apos;sort-name&apos;] ?? null,
            type_id: $data[&apos;type-id&apos;] ?? null,
            primary: $data[&apos;primary&apos;] ?? null,
            begin_date: $data[&apos;begin-date&apos;] ?? null,
            end_date: $data[&apos;end-date&apos;] ?? null,
            release_group: $data[&apos;release-group&apos;] ?? null,
            first_release_date: $data[&apos;first-release-date&apos;] ?? null,
            primary_type: $data[&apos;primary-type&apos;] ?? null,
            secondary_type: $data[&apos;secondary-type&apos;] ?? null,
            tag: $data[&apos;tag&apos;] ?? null,
            user_tag: $data[&apos;user-tag&apos;] ?? null,
            genre: $data[&apos;genre&apos;] ?? null,
            target_type: $data[&apos;target-type&apos;] ?? null,
            relation: $data[&apos;relation&apos;] ?? null,
            target: $data[&apos;target&apos;] ?? null,
            ordering_key: $data[&apos;ordering-key&apos;] ?? null,
            direction: $data[&apos;direction&apos;] ?? null,
            begin: $data[&apos;begin&apos;] ?? null,
            end: $data[&apos;end&apos;] ?? null,
            ended: $data[&apos;ended&apos;] ?? null,
            source_credit: $data[&apos;source-credit&apos;] ?? null,
            target_credit: $data[&apos;target-credit&apos;] ?? null,
            user_genre: $data[&apos;user-genre&apos;] ?? null,
            rating: $data[&apos;rating&apos;] ?? null,
            votes_count: $data[&apos;votes-count&apos;] ?? null,
            user_rating: $data[&apos;user-rating&apos;] ?? null,
            date: $data[&apos;date&apos;] ?? null,
            country: $data[&apos;country&apos;] ?? null,
            release_event: $data[&apos;release-event&apos;] ?? null,
            area: $data[&apos;area&apos;] ?? null,
            iso_3166_1_code: $data[&apos;iso-3166-1-code&apos;] ?? null,
            iso_3166_2_code: $data[&apos;iso-3166-2-code&apos;] ?? null,
            iso_3166_3_code: $data[&apos;iso-3166-3-code&apos;] ?? null,
            life_span: $data[&apos;life-span&apos;] ?? null,
            barcode: $data[&apos;barcode&apos;] ?? null,
            asin: $data[&apos;asin&apos;] ?? null,
            cover_art_archive: $data[&apos;cover-art-archive&apos;] ?? null,
            artwork: $data[&apos;artwork&apos;] ?? null,
            front: $data[&apos;front&apos;] ?? null,
            back: $data[&apos;back&apos;] ?? null,
            darkened: $data[&apos;darkened&apos;] ?? null,
            label_info: $data[&apos;label-info&apos;] ?? null,
            catalog_number: $data[&apos;catalog-number&apos;] ?? null,
            label: $data[&apos;label&apos;] ?? null,
            label_code: $data[&apos;label-code&apos;] ?? null,
            ipi: $data[&apos;ipi&apos;] ?? null,
            isni: $data[&apos;isni&apos;] ?? null,
            track_count: $data[&apos;track-count&apos;] ?? null,
            medium: $data[&apos;medium&apos;] ?? null,
            track: $data[&apos;track&apos;] ?? null,
            number: $data[&apos;number&apos;] ?? null,
            length: $data[&apos;length&apos;] ?? null,
            recording: $data[&apos;recording&apos;] ?? null,
            video: $data[&apos;video&apos;] ?? null,
            puid: $data[&apos;puid&apos;] ?? null,
            isrc: $data[&apos;isrc&apos;] ?? null,
            format: $data[&apos;format&apos;] ?? null,
            pregap: $data[&apos;pregap&apos;] ?? null,
            collection: $data[&apos;collection&apos;] ?? null,
            entity_type: $data[&apos;entity-type&apos;] ?? null,
            editor: $data[&apos;editor&apos;] ?? null,
            artist: $data[&apos;artist&apos;] ?? null,
            gender: $data[&apos;gender&apos;] ?? null,
            begin_area: $data[&apos;begin-area&apos;] ?? null,
            end_area: $data[&apos;end-area&apos;] ?? null,
            work: $data[&apos;work&apos;] ?? null,
            fluency: $data[&apos;fluency&apos;] ?? null,
            iswc: $data[&apos;iswc&apos;] ?? null,
            event: $data[&apos;event&apos;] ?? null,
            cancelled: $data[&apos;cancelled&apos;] ?? null,
            time: $data[&apos;time&apos;] ?? null,
            setlist: $data[&apos;setlist&apos;] ?? null,
            instrument: $data[&apos;instrument&apos;] ?? null,
            description: $data[&apos;description&apos;] ?? null,
            place: $data[&apos;place&apos;] ?? null,
            address: $data[&apos;address&apos;] ?? null,
            coordinates: $data[&apos;coordinates&apos;] ?? null,
            latitude: $data[&apos;latitude&apos;] ?? null,
            longitude: $data[&apos;longitude&apos;] ?? null,
            series: $data[&apos;series&apos;] ?? null
        );
    }
}</file><file path="app/Http/Integrations/MusicBrainz/Models/DiscList.php">&lt;?php
namespace App\Http\Integrations\MusicBrainz\Models;
use Spatie\LaravelData\Data;
class DiscList extends Data
{
    public function __construct(public mixed $count, public mixed $offset, public mixed $disc, public mixed $id, public mixed $sectors, public mixed $position, public mixed $release, public mixed $title, public mixed $status, public mixed $quality, public mixed $annotation, public mixed $text, public mixed $type, public mixed $entity, public mixed $name, public mixed $disambiguation, public mixed $packaging, public mixed $text_representation, public mixed $language, public mixed $script, public mixed $artist_credit, public mixed $alias, public mixed $locale, public mixed $sort_name, public mixed $type_id, public mixed $primary, public mixed $begin_date, public mixed $end_date, public mixed $release_group, public mixed $first_release_date, public mixed $primary_type, public mixed $secondary_type, public mixed $tag, public mixed $user_tag, public mixed $genre, public mixed $target_type, public mixed $relation, public mixed $target, public mixed $ordering_key, public mixed $direction, public mixed $begin, public mixed $end, public mixed $ended, public mixed $source_credit, public mixed $target_credit, public mixed $user_genre, public mixed $rating, public mixed $votes_count, public mixed $user_rating, public mixed $date, public mixed $country, public mixed $release_event, public mixed $area, public mixed $iso_3166_1_code, public mixed $iso_3166_2_code, public mixed $iso_3166_3_code, public mixed $life_span, public mixed $barcode, public mixed $asin, public mixed $cover_art_archive, public mixed $artwork, public mixed $front, public mixed $back, public mixed $darkened, public mixed $label_info, public mixed $catalog_number, public mixed $label, public mixed $label_code, public mixed $ipi, public mixed $isni, public mixed $track_count, public mixed $medium, public mixed $track, public mixed $number, public mixed $length, public mixed $recording, public mixed $video, public mixed $puid, public mixed $isrc, public mixed $format, public mixed $pregap, public mixed $collection, public mixed $entity_type, public mixed $editor, public mixed $artist, public mixed $gender, public mixed $begin_area, public mixed $end_area, public mixed $work, public mixed $fluency, public mixed $iswc, public mixed $event, public mixed $cancelled, public mixed $time, public mixed $setlist, public mixed $instrument, public mixed $description, public mixed $place, public mixed $address, public mixed $coordinates, public mixed $latitude, public mixed $longitude, public mixed $series)
    {
    }
    public static function fromApiData(array $data): self
    {
        return new self(
            count: $data[&apos;count&apos;] ?? null,
            offset: $data[&apos;offset&apos;] ?? null,
            disc: $data[&apos;disc&apos;] ?? null,
            id: $data[&apos;id&apos;] ?? null,
            sectors: $data[&apos;sectors&apos;] ?? null,
            position: $data[&apos;position&apos;] ?? null,
            release: $data[&apos;release&apos;] ?? null,
            title: $data[&apos;title&apos;] ?? null,
            status: $data[&apos;status&apos;] ?? null,
            quality: $data[&apos;quality&apos;] ?? null,
            annotation: $data[&apos;annotation&apos;] ?? null,
            text: $data[&apos;text&apos;] ?? null,
            type: $data[&apos;type&apos;] ?? null,
            entity: $data[&apos;entity&apos;] ?? null,
            name: $data[&apos;name&apos;] ?? null,
            disambiguation: $data[&apos;disambiguation&apos;] ?? null,
            packaging: $data[&apos;packaging&apos;] ?? null,
            text_representation: $data[&apos;text-representation&apos;] ?? null,
            language: $data[&apos;language&apos;] ?? null,
            script: $data[&apos;script&apos;] ?? null,
            artist_credit: $data[&apos;artist-credit&apos;] ?? null,
            alias: $data[&apos;alias&apos;] ?? null,
            locale: $data[&apos;locale&apos;] ?? null,
            sort_name: $data[&apos;sort-name&apos;] ?? null,
            type_id: $data[&apos;type-id&apos;] ?? null,
            primary: $data[&apos;primary&apos;] ?? null,
            begin_date: $data[&apos;begin-date&apos;] ?? null,
            end_date: $data[&apos;end-date&apos;] ?? null,
            release_group: $data[&apos;release-group&apos;] ?? null,
            first_release_date: $data[&apos;first-release-date&apos;] ?? null,
            primary_type: $data[&apos;primary-type&apos;] ?? null,
            secondary_type: $data[&apos;secondary-type&apos;] ?? null,
            tag: $data[&apos;tag&apos;] ?? null,
            user_tag: $data[&apos;user-tag&apos;] ?? null,
            genre: $data[&apos;genre&apos;] ?? null,
            target_type: $data[&apos;target-type&apos;] ?? null,
            relation: $data[&apos;relation&apos;] ?? null,
            target: $data[&apos;target&apos;] ?? null,
            ordering_key: $data[&apos;ordering-key&apos;] ?? null,
            direction: $data[&apos;direction&apos;] ?? null,
            begin: $data[&apos;begin&apos;] ?? null,
            end: $data[&apos;end&apos;] ?? null,
            ended: $data[&apos;ended&apos;] ?? null,
            source_credit: $data[&apos;source-credit&apos;] ?? null,
            target_credit: $data[&apos;target-credit&apos;] ?? null,
            user_genre: $data[&apos;user-genre&apos;] ?? null,
            rating: $data[&apos;rating&apos;] ?? null,
            votes_count: $data[&apos;votes-count&apos;] ?? null,
            user_rating: $data[&apos;user-rating&apos;] ?? null,
            date: $data[&apos;date&apos;] ?? null,
            country: $data[&apos;country&apos;] ?? null,
            release_event: $data[&apos;release-event&apos;] ?? null,
            area: $data[&apos;area&apos;] ?? null,
            iso_3166_1_code: $data[&apos;iso-3166-1-code&apos;] ?? null,
            iso_3166_2_code: $data[&apos;iso-3166-2-code&apos;] ?? null,
            iso_3166_3_code: $data[&apos;iso-3166-3-code&apos;] ?? null,
            life_span: $data[&apos;life-span&apos;] ?? null,
            barcode: $data[&apos;barcode&apos;] ?? null,
            asin: $data[&apos;asin&apos;] ?? null,
            cover_art_archive: $data[&apos;cover-art-archive&apos;] ?? null,
            artwork: $data[&apos;artwork&apos;] ?? null,
            front: $data[&apos;front&apos;] ?? null,
            back: $data[&apos;back&apos;] ?? null,
            darkened: $data[&apos;darkened&apos;] ?? null,
            label_info: $data[&apos;label-info&apos;] ?? null,
            catalog_number: $data[&apos;catalog-number&apos;] ?? null,
            label: $data[&apos;label&apos;] ?? null,
            label_code: $data[&apos;label-code&apos;] ?? null,
            ipi: $data[&apos;ipi&apos;] ?? null,
            isni: $data[&apos;isni&apos;] ?? null,
            track_count: $data[&apos;track-count&apos;] ?? null,
            medium: $data[&apos;medium&apos;] ?? null,
            track: $data[&apos;track&apos;] ?? null,
            number: $data[&apos;number&apos;] ?? null,
            length: $data[&apos;length&apos;] ?? null,
            recording: $data[&apos;recording&apos;] ?? null,
            video: $data[&apos;video&apos;] ?? null,
            puid: $data[&apos;puid&apos;] ?? null,
            isrc: $data[&apos;isrc&apos;] ?? null,
            format: $data[&apos;format&apos;] ?? null,
            pregap: $data[&apos;pregap&apos;] ?? null,
            collection: $data[&apos;collection&apos;] ?? null,
            entity_type: $data[&apos;entity-type&apos;] ?? null,
            editor: $data[&apos;editor&apos;] ?? null,
            artist: $data[&apos;artist&apos;] ?? null,
            gender: $data[&apos;gender&apos;] ?? null,
            begin_area: $data[&apos;begin-area&apos;] ?? null,
            end_area: $data[&apos;end-area&apos;] ?? null,
            work: $data[&apos;work&apos;] ?? null,
            fluency: $data[&apos;fluency&apos;] ?? null,
            iswc: $data[&apos;iswc&apos;] ?? null,
            event: $data[&apos;event&apos;] ?? null,
            cancelled: $data[&apos;cancelled&apos;] ?? null,
            time: $data[&apos;time&apos;] ?? null,
            setlist: $data[&apos;setlist&apos;] ?? null,
            instrument: $data[&apos;instrument&apos;] ?? null,
            description: $data[&apos;description&apos;] ?? null,
            place: $data[&apos;place&apos;] ?? null,
            address: $data[&apos;address&apos;] ?? null,
            coordinates: $data[&apos;coordinates&apos;] ?? null,
            latitude: $data[&apos;latitude&apos;] ?? null,
            longitude: $data[&apos;longitude&apos;] ?? null,
            series: $data[&apos;series&apos;] ?? null
        );
    }
}</file><file path="app/Http/Integrations/MusicBrainz/Models/Editor.php">&lt;?php
namespace App\Http\Integrations\MusicBrainz\Models;
use Spatie\LaravelData\Data;
class Editor extends Data
{
    public function __construct(public mixed $editor, public mixed $name, public mixed $id, public mixed $member_since, public mixed $privs, public mixed $gender, public mixed $age, public mixed $homepage, public mixed $bio, public mixed $area, public mixed $type, public mixed $type_id, public mixed $sort_name, public mixed $disambiguation, public mixed $iso_3166_1_code, public mixed $iso_3166_2_code, public mixed $iso_3166_3_code, public mixed $annotation, public mixed $text, public mixed $entity, public mixed $life_span, public mixed $begin, public mixed $end, public mixed $ended, public mixed $count, public mixed $offset, public mixed $alias, public mixed $locale, public mixed $primary, public mixed $begin_date, public mixed $end_date, public mixed $tag, public mixed $user_tag, public mixed $genre, public mixed $target_type, public mixed $relation, public mixed $target, public mixed $ordering_key, public mixed $direction, public mixed $source_credit, public mixed $target_credit, public mixed $user_genre, public mixed $language, public mixed $fluency, public mixed $edit_information, public mixed $edits_accepted, public mixed $edits_rejected, public mixed $auto_edits_accepted, public mixed $edits_failed)
    {
    }
    public static function fromApiData(array $data): self
    {
        return new self(
            editor: $data[&apos;editor&apos;] ?? null,
            name: $data[&apos;name&apos;] ?? null,
            id: $data[&apos;id&apos;] ?? null,
            member_since: $data[&apos;member-since&apos;] ?? null,
            privs: $data[&apos;privs&apos;] ?? null,
            gender: $data[&apos;gender&apos;] ?? null,
            age: $data[&apos;age&apos;] ?? null,
            homepage: $data[&apos;homepage&apos;] ?? null,
            bio: $data[&apos;bio&apos;] ?? null,
            area: $data[&apos;area&apos;] ?? null,
            type: $data[&apos;type&apos;] ?? null,
            type_id: $data[&apos;type-id&apos;] ?? null,
            sort_name: $data[&apos;sort-name&apos;] ?? null,
            disambiguation: $data[&apos;disambiguation&apos;] ?? null,
            iso_3166_1_code: $data[&apos;iso-3166-1-code&apos;] ?? null,
            iso_3166_2_code: $data[&apos;iso-3166-2-code&apos;] ?? null,
            iso_3166_3_code: $data[&apos;iso-3166-3-code&apos;] ?? null,
            annotation: $data[&apos;annotation&apos;] ?? null,
            text: $data[&apos;text&apos;] ?? null,
            entity: $data[&apos;entity&apos;] ?? null,
            life_span: $data[&apos;life-span&apos;] ?? null,
            begin: $data[&apos;begin&apos;] ?? null,
            end: $data[&apos;end&apos;] ?? null,
            ended: $data[&apos;ended&apos;] ?? null,
            count: $data[&apos;count&apos;] ?? null,
            offset: $data[&apos;offset&apos;] ?? null,
            alias: $data[&apos;alias&apos;] ?? null,
            locale: $data[&apos;locale&apos;] ?? null,
            primary: $data[&apos;primary&apos;] ?? null,
            begin_date: $data[&apos;begin-date&apos;] ?? null,
            end_date: $data[&apos;end-date&apos;] ?? null,
            tag: $data[&apos;tag&apos;] ?? null,
            user_tag: $data[&apos;user-tag&apos;] ?? null,
            genre: $data[&apos;genre&apos;] ?? null,
            target_type: $data[&apos;target-type&apos;] ?? null,
            relation: $data[&apos;relation&apos;] ?? null,
            target: $data[&apos;target&apos;] ?? null,
            ordering_key: $data[&apos;ordering-key&apos;] ?? null,
            direction: $data[&apos;direction&apos;] ?? null,
            source_credit: $data[&apos;source-credit&apos;] ?? null,
            target_credit: $data[&apos;target-credit&apos;] ?? null,
            user_genre: $data[&apos;user-genre&apos;] ?? null,
            language: $data[&apos;language&apos;] ?? null,
            fluency: $data[&apos;fluency&apos;] ?? null,
            edit_information: $data[&apos;edit-information&apos;] ?? null,
            edits_accepted: $data[&apos;edits-accepted&apos;] ?? null,
            edits_rejected: $data[&apos;edits-rejected&apos;] ?? null,
            auto_edits_accepted: $data[&apos;auto-edits-accepted&apos;] ?? null,
            edits_failed: $data[&apos;edits-failed&apos;] ?? null
        );
    }
}</file><file path="app/Http/Integrations/MusicBrainz/Models/EditorList.php">&lt;?php
namespace App\Http\Integrations\MusicBrainz\Models;
use Spatie\LaravelData\Data;
class EditorList extends Data
{
    public function __construct(public mixed $count, public mixed $offset, public mixed $editor, public mixed $name, public mixed $id, public mixed $member_since, public mixed $privs, public mixed $gender, public mixed $age, public mixed $homepage, public mixed $bio, public mixed $area, public mixed $type, public mixed $type_id, public mixed $sort_name, public mixed $disambiguation, public mixed $iso_3166_1_code, public mixed $iso_3166_2_code, public mixed $iso_3166_3_code, public mixed $annotation, public mixed $text, public mixed $entity, public mixed $life_span, public mixed $begin, public mixed $end, public mixed $ended, public mixed $alias, public mixed $locale, public mixed $primary, public mixed $begin_date, public mixed $end_date, public mixed $tag, public mixed $user_tag, public mixed $genre, public mixed $target_type, public mixed $relation, public mixed $target, public mixed $ordering_key, public mixed $direction, public mixed $source_credit, public mixed $target_credit, public mixed $user_genre, public mixed $language, public mixed $fluency, public mixed $edit_information, public mixed $edits_accepted, public mixed $edits_rejected, public mixed $auto_edits_accepted, public mixed $edits_failed)
    {
    }
    public static function fromApiData(array $data): self
    {
        return new self(
            count: $data[&apos;count&apos;] ?? null,
            offset: $data[&apos;offset&apos;] ?? null,
            editor: $data[&apos;editor&apos;] ?? null,
            name: $data[&apos;name&apos;] ?? null,
            id: $data[&apos;id&apos;] ?? null,
            member_since: $data[&apos;member-since&apos;] ?? null,
            privs: $data[&apos;privs&apos;] ?? null,
            gender: $data[&apos;gender&apos;] ?? null,
            age: $data[&apos;age&apos;] ?? null,
            homepage: $data[&apos;homepage&apos;] ?? null,
            bio: $data[&apos;bio&apos;] ?? null,
            area: $data[&apos;area&apos;] ?? null,
            type: $data[&apos;type&apos;] ?? null,
            type_id: $data[&apos;type-id&apos;] ?? null,
            sort_name: $data[&apos;sort-name&apos;] ?? null,
            disambiguation: $data[&apos;disambiguation&apos;] ?? null,
            iso_3166_1_code: $data[&apos;iso-3166-1-code&apos;] ?? null,
            iso_3166_2_code: $data[&apos;iso-3166-2-code&apos;] ?? null,
            iso_3166_3_code: $data[&apos;iso-3166-3-code&apos;] ?? null,
            annotation: $data[&apos;annotation&apos;] ?? null,
            text: $data[&apos;text&apos;] ?? null,
            entity: $data[&apos;entity&apos;] ?? null,
            life_span: $data[&apos;life-span&apos;] ?? null,
            begin: $data[&apos;begin&apos;] ?? null,
            end: $data[&apos;end&apos;] ?? null,
            ended: $data[&apos;ended&apos;] ?? null,
            alias: $data[&apos;alias&apos;] ?? null,
            locale: $data[&apos;locale&apos;] ?? null,
            primary: $data[&apos;primary&apos;] ?? null,
            begin_date: $data[&apos;begin-date&apos;] ?? null,
            end_date: $data[&apos;end-date&apos;] ?? null,
            tag: $data[&apos;tag&apos;] ?? null,
            user_tag: $data[&apos;user-tag&apos;] ?? null,
            genre: $data[&apos;genre&apos;] ?? null,
            target_type: $data[&apos;target-type&apos;] ?? null,
            relation: $data[&apos;relation&apos;] ?? null,
            target: $data[&apos;target&apos;] ?? null,
            ordering_key: $data[&apos;ordering-key&apos;] ?? null,
            direction: $data[&apos;direction&apos;] ?? null,
            source_credit: $data[&apos;source-credit&apos;] ?? null,
            target_credit: $data[&apos;target-credit&apos;] ?? null,
            user_genre: $data[&apos;user-genre&apos;] ?? null,
            language: $data[&apos;language&apos;] ?? null,
            fluency: $data[&apos;fluency&apos;] ?? null,
            edit_information: $data[&apos;edit-information&apos;] ?? null,
            edits_accepted: $data[&apos;edits-accepted&apos;] ?? null,
            edits_rejected: $data[&apos;edits-rejected&apos;] ?? null,
            auto_edits_accepted: $data[&apos;auto-edits-accepted&apos;] ?? null,
            edits_failed: $data[&apos;edits-failed&apos;] ?? null
        );
    }
}</file><file path="app/Http/Integrations/MusicBrainz/Models/Ended.php">&lt;?php
namespace App\Http\Integrations\MusicBrainz\Models;
use Spatie\LaravelData\Data;
class Ended extends Data
{
    public function __construct()
    {
    }
    public static function fromApiData(array $data): self
    {
        return new self(
        );
    }
}</file><file path="app/Http/Integrations/MusicBrainz/Models/EntityList.php">&lt;?php
namespace App\Http\Integrations\MusicBrainz\Models;
use Spatie\LaravelData\Data;
class EntityList extends Data
{
    public function __construct(public mixed $count, public mixed $offset, public mixed $artist, public mixed $id, public mixed $type, public mixed $type_id, public mixed $name, public mixed $sort_name, public mixed $gender, public mixed $country, public mixed $area, public mixed $disambiguation, public mixed $iso_3166_1_code, public mixed $iso_3166_2_code, public mixed $iso_3166_3_code, public mixed $annotation, public mixed $text, public mixed $entity, public mixed $life_span, public mixed $begin, public mixed $end, public mixed $ended, public mixed $alias, public mixed $locale, public mixed $primary, public mixed $begin_date, public mixed $end_date, public mixed $tag, public mixed $user_tag, public mixed $genre, public mixed $target_type, public mixed $relation, public mixed $target, public mixed $ordering_key, public mixed $direction, public mixed $source_credit, public mixed $target_credit, public mixed $user_genre, public mixed $begin_area, public mixed $end_area, public mixed $ipi, public mixed $isni, public mixed $recording, public mixed $title, public mixed $length, public mixed $video, public mixed $artist_credit, public mixed $first_release_date, public mixed $release, public mixed $status, public mixed $quality, public mixed $packaging, public mixed $text_representation, public mixed $language, public mixed $script, public mixed $release_group, public mixed $primary_type, public mixed $secondary_type, public mixed $rating, public mixed $votes_count, public mixed $user_rating, public mixed $date, public mixed $release_event, public mixed $barcode, public mixed $asin, public mixed $cover_art_archive, public mixed $artwork, public mixed $front, public mixed $back, public mixed $darkened, public mixed $label_info, public mixed $catalog_number, public mixed $label, public mixed $label_code, public mixed $track_count, public mixed $medium, public mixed $track, public mixed $position, public mixed $number, public mixed $format, public mixed $disc, public mixed $sectors, public mixed $pregap, public mixed $collection, public mixed $entity_type, public mixed $editor, public mixed $event, public mixed $cancelled, public mixed $time, public mixed $setlist, public mixed $instrument, public mixed $description, public mixed $place, public mixed $address, public mixed $coordinates, public mixed $latitude, public mixed $longitude, public mixed $series, public mixed $work, public mixed $fluency, public mixed $iswc, public mixed $puid, public mixed $isrc)
    {
    }
    public static function fromApiData(array $data): self
    {
        return new self(
            count: $data[&apos;count&apos;] ?? null,
            offset: $data[&apos;offset&apos;] ?? null,
            artist: $data[&apos;artist&apos;] ?? null,
            id: $data[&apos;id&apos;] ?? null,
            type: $data[&apos;type&apos;] ?? null,
            type_id: $data[&apos;type-id&apos;] ?? null,
            name: $data[&apos;name&apos;] ?? null,
            sort_name: $data[&apos;sort-name&apos;] ?? null,
            gender: $data[&apos;gender&apos;] ?? null,
            country: $data[&apos;country&apos;] ?? null,
            area: $data[&apos;area&apos;] ?? null,
            disambiguation: $data[&apos;disambiguation&apos;] ?? null,
            iso_3166_1_code: $data[&apos;iso-3166-1-code&apos;] ?? null,
            iso_3166_2_code: $data[&apos;iso-3166-2-code&apos;] ?? null,
            iso_3166_3_code: $data[&apos;iso-3166-3-code&apos;] ?? null,
            annotation: $data[&apos;annotation&apos;] ?? null,
            text: $data[&apos;text&apos;] ?? null,
            entity: $data[&apos;entity&apos;] ?? null,
            life_span: $data[&apos;life-span&apos;] ?? null,
            begin: $data[&apos;begin&apos;] ?? null,
            end: $data[&apos;end&apos;] ?? null,
            ended: $data[&apos;ended&apos;] ?? null,
            alias: $data[&apos;alias&apos;] ?? null,
            locale: $data[&apos;locale&apos;] ?? null,
            primary: $data[&apos;primary&apos;] ?? null,
            begin_date: $data[&apos;begin-date&apos;] ?? null,
            end_date: $data[&apos;end-date&apos;] ?? null,
            tag: $data[&apos;tag&apos;] ?? null,
            user_tag: $data[&apos;user-tag&apos;] ?? null,
            genre: $data[&apos;genre&apos;] ?? null,
            target_type: $data[&apos;target-type&apos;] ?? null,
            relation: $data[&apos;relation&apos;] ?? null,
            target: $data[&apos;target&apos;] ?? null,
            ordering_key: $data[&apos;ordering-key&apos;] ?? null,
            direction: $data[&apos;direction&apos;] ?? null,
            source_credit: $data[&apos;source-credit&apos;] ?? null,
            target_credit: $data[&apos;target-credit&apos;] ?? null,
            user_genre: $data[&apos;user-genre&apos;] ?? null,
            begin_area: $data[&apos;begin-area&apos;] ?? null,
            end_area: $data[&apos;end-area&apos;] ?? null,
            ipi: $data[&apos;ipi&apos;] ?? null,
            isni: $data[&apos;isni&apos;] ?? null,
            recording: $data[&apos;recording&apos;] ?? null,
            title: $data[&apos;title&apos;] ?? null,
            length: $data[&apos;length&apos;] ?? null,
            video: $data[&apos;video&apos;] ?? null,
            artist_credit: $data[&apos;artist-credit&apos;] ?? null,
            first_release_date: $data[&apos;first-release-date&apos;] ?? null,
            release: $data[&apos;release&apos;] ?? null,
            status: $data[&apos;status&apos;] ?? null,
            quality: $data[&apos;quality&apos;] ?? null,
            packaging: $data[&apos;packaging&apos;] ?? null,
            text_representation: $data[&apos;text-representation&apos;] ?? null,
            language: $data[&apos;language&apos;] ?? null,
            script: $data[&apos;script&apos;] ?? null,
            release_group: $data[&apos;release-group&apos;] ?? null,
            primary_type: $data[&apos;primary-type&apos;] ?? null,
            secondary_type: $data[&apos;secondary-type&apos;] ?? null,
            rating: $data[&apos;rating&apos;] ?? null,
            votes_count: $data[&apos;votes-count&apos;] ?? null,
            user_rating: $data[&apos;user-rating&apos;] ?? null,
            date: $data[&apos;date&apos;] ?? null,
            release_event: $data[&apos;release-event&apos;] ?? null,
            barcode: $data[&apos;barcode&apos;] ?? null,
            asin: $data[&apos;asin&apos;] ?? null,
            cover_art_archive: $data[&apos;cover-art-archive&apos;] ?? null,
            artwork: $data[&apos;artwork&apos;] ?? null,
            front: $data[&apos;front&apos;] ?? null,
            back: $data[&apos;back&apos;] ?? null,
            darkened: $data[&apos;darkened&apos;] ?? null,
            label_info: $data[&apos;label-info&apos;] ?? null,
            catalog_number: $data[&apos;catalog-number&apos;] ?? null,
            label: $data[&apos;label&apos;] ?? null,
            label_code: $data[&apos;label-code&apos;] ?? null,
            track_count: $data[&apos;track-count&apos;] ?? null,
            medium: $data[&apos;medium&apos;] ?? null,
            track: $data[&apos;track&apos;] ?? null,
            position: $data[&apos;position&apos;] ?? null,
            number: $data[&apos;number&apos;] ?? null,
            format: $data[&apos;format&apos;] ?? null,
            disc: $data[&apos;disc&apos;] ?? null,
            sectors: $data[&apos;sectors&apos;] ?? null,
            pregap: $data[&apos;pregap&apos;] ?? null,
            collection: $data[&apos;collection&apos;] ?? null,
            entity_type: $data[&apos;entity-type&apos;] ?? null,
            editor: $data[&apos;editor&apos;] ?? null,
            event: $data[&apos;event&apos;] ?? null,
            cancelled: $data[&apos;cancelled&apos;] ?? null,
            time: $data[&apos;time&apos;] ?? null,
            setlist: $data[&apos;setlist&apos;] ?? null,
            instrument: $data[&apos;instrument&apos;] ?? null,
            description: $data[&apos;description&apos;] ?? null,
            place: $data[&apos;place&apos;] ?? null,
            address: $data[&apos;address&apos;] ?? null,
            coordinates: $data[&apos;coordinates&apos;] ?? null,
            latitude: $data[&apos;latitude&apos;] ?? null,
            longitude: $data[&apos;longitude&apos;] ?? null,
            series: $data[&apos;series&apos;] ?? null,
            work: $data[&apos;work&apos;] ?? null,
            fluency: $data[&apos;fluency&apos;] ?? null,
            iswc: $data[&apos;iswc&apos;] ?? null,
            puid: $data[&apos;puid&apos;] ?? null,
            isrc: $data[&apos;isrc&apos;] ?? null
        );
    }
}</file><file path="app/Http/Integrations/MusicBrainz/Models/Event.php">&lt;?php
namespace App\Http\Integrations\MusicBrainz\Models;
use Spatie\LaravelData\Data;
class Event extends Data
{
    public function __construct(public mixed $event, public mixed $id, public mixed $type, public mixed $type_id, public mixed $name, public mixed $disambiguation, public mixed $cancelled, public mixed $life_span, public mixed $begin, public mixed $end, public mixed $time, public mixed $setlist, public mixed $annotation, public mixed $text, public mixed $entity, public mixed $count, public mixed $offset, public mixed $alias, public mixed $locale, public mixed $sort_name, public mixed $primary, public mixed $begin_date, public mixed $end_date, public mixed $tag, public mixed $user_tag, public mixed $genre, public mixed $target_type, public mixed $relation, public mixed $target, public mixed $ordering_key, public mixed $direction, public mixed $ended, public mixed $source_credit, public mixed $target_credit, public mixed $user_genre, public mixed $rating, public mixed $votes_count, public mixed $user_rating)
    {
    }
    public static function fromApiData(array $data): self
    {
        return new self(
            event: $data[&apos;event&apos;] ?? null,
            id: $data[&apos;id&apos;] ?? null,
            type: $data[&apos;type&apos;] ?? null,
            type_id: $data[&apos;type-id&apos;] ?? null,
            name: $data[&apos;name&apos;] ?? null,
            disambiguation: $data[&apos;disambiguation&apos;] ?? null,
            cancelled: $data[&apos;cancelled&apos;] ?? null,
            life_span: $data[&apos;life-span&apos;] ?? null,
            begin: $data[&apos;begin&apos;] ?? null,
            end: $data[&apos;end&apos;] ?? null,
            time: $data[&apos;time&apos;] ?? null,
            setlist: $data[&apos;setlist&apos;] ?? null,
            annotation: $data[&apos;annotation&apos;] ?? null,
            text: $data[&apos;text&apos;] ?? null,
            entity: $data[&apos;entity&apos;] ?? null,
            count: $data[&apos;count&apos;] ?? null,
            offset: $data[&apos;offset&apos;] ?? null,
            alias: $data[&apos;alias&apos;] ?? null,
            locale: $data[&apos;locale&apos;] ?? null,
            sort_name: $data[&apos;sort-name&apos;] ?? null,
            primary: $data[&apos;primary&apos;] ?? null,
            begin_date: $data[&apos;begin-date&apos;] ?? null,
            end_date: $data[&apos;end-date&apos;] ?? null,
            tag: $data[&apos;tag&apos;] ?? null,
            user_tag: $data[&apos;user-tag&apos;] ?? null,
            genre: $data[&apos;genre&apos;] ?? null,
            target_type: $data[&apos;target-type&apos;] ?? null,
            relation: $data[&apos;relation&apos;] ?? null,
            target: $data[&apos;target&apos;] ?? null,
            ordering_key: $data[&apos;ordering-key&apos;] ?? null,
            direction: $data[&apos;direction&apos;] ?? null,
            ended: $data[&apos;ended&apos;] ?? null,
            source_credit: $data[&apos;source-credit&apos;] ?? null,
            target_credit: $data[&apos;target-credit&apos;] ?? null,
            user_genre: $data[&apos;user-genre&apos;] ?? null,
            rating: $data[&apos;rating&apos;] ?? null,
            votes_count: $data[&apos;votes-count&apos;] ?? null,
            user_rating: $data[&apos;user-rating&apos;] ?? null
        );
    }
}</file><file path="app/Http/Integrations/MusicBrainz/Models/EventList.php">&lt;?php
namespace App\Http\Integrations\MusicBrainz\Models;
use Spatie\LaravelData\Data;
class EventList extends Data
{
    public function __construct(public mixed $count, public mixed $offset, public mixed $event, public mixed $id, public mixed $type, public mixed $type_id, public mixed $name, public mixed $disambiguation, public mixed $cancelled, public mixed $life_span, public mixed $begin, public mixed $end, public mixed $time, public mixed $setlist, public mixed $annotation, public mixed $text, public mixed $entity, public mixed $alias, public mixed $locale, public mixed $sort_name, public mixed $primary, public mixed $begin_date, public mixed $end_date, public mixed $tag, public mixed $user_tag, public mixed $genre, public mixed $target_type, public mixed $relation, public mixed $target, public mixed $ordering_key, public mixed $direction, public mixed $ended, public mixed $source_credit, public mixed $target_credit, public mixed $user_genre, public mixed $rating, public mixed $votes_count, public mixed $user_rating)
    {
    }
    public static function fromApiData(array $data): self
    {
        return new self(
            count: $data[&apos;count&apos;] ?? null,
            offset: $data[&apos;offset&apos;] ?? null,
            event: $data[&apos;event&apos;] ?? null,
            id: $data[&apos;id&apos;] ?? null,
            type: $data[&apos;type&apos;] ?? null,
            type_id: $data[&apos;type-id&apos;] ?? null,
            name: $data[&apos;name&apos;] ?? null,
            disambiguation: $data[&apos;disambiguation&apos;] ?? null,
            cancelled: $data[&apos;cancelled&apos;] ?? null,
            life_span: $data[&apos;life-span&apos;] ?? null,
            begin: $data[&apos;begin&apos;] ?? null,
            end: $data[&apos;end&apos;] ?? null,
            time: $data[&apos;time&apos;] ?? null,
            setlist: $data[&apos;setlist&apos;] ?? null,
            annotation: $data[&apos;annotation&apos;] ?? null,
            text: $data[&apos;text&apos;] ?? null,
            entity: $data[&apos;entity&apos;] ?? null,
            alias: $data[&apos;alias&apos;] ?? null,
            locale: $data[&apos;locale&apos;] ?? null,
            sort_name: $data[&apos;sort-name&apos;] ?? null,
            primary: $data[&apos;primary&apos;] ?? null,
            begin_date: $data[&apos;begin-date&apos;] ?? null,
            end_date: $data[&apos;end-date&apos;] ?? null,
            tag: $data[&apos;tag&apos;] ?? null,
            user_tag: $data[&apos;user-tag&apos;] ?? null,
            genre: $data[&apos;genre&apos;] ?? null,
            target_type: $data[&apos;target-type&apos;] ?? null,
            relation: $data[&apos;relation&apos;] ?? null,
            target: $data[&apos;target&apos;] ?? null,
            ordering_key: $data[&apos;ordering-key&apos;] ?? null,
            direction: $data[&apos;direction&apos;] ?? null,
            ended: $data[&apos;ended&apos;] ?? null,
            source_credit: $data[&apos;source-credit&apos;] ?? null,
            target_credit: $data[&apos;target-credit&apos;] ?? null,
            user_genre: $data[&apos;user-genre&apos;] ?? null,
            rating: $data[&apos;rating&apos;] ?? null,
            votes_count: $data[&apos;votes-count&apos;] ?? null,
            user_rating: $data[&apos;user-rating&apos;] ?? null
        );
    }
}</file><file path="app/Http/Integrations/MusicBrainz/Models/FreedbDisc.php">&lt;?php
namespace App\Http\Integrations\MusicBrainz\Models;
use Spatie\LaravelData\Data;
class FreedbDisc extends Data
{
    public function __construct(public mixed $freedb_disc, public mixed $title, public mixed $count, public mixed $offset, public mixed $track, public mixed $length, public mixed $artist, public mixed $id, public mixed $category, public mixed $year)
    {
    }
    public static function fromApiData(array $data): self
    {
        return new self(
            freedb_disc: $data[&apos;freedb-disc&apos;] ?? null,
            title: $data[&apos;title&apos;] ?? null,
            count: $data[&apos;count&apos;] ?? null,
            offset: $data[&apos;offset&apos;] ?? null,
            track: $data[&apos;track&apos;] ?? null,
            length: $data[&apos;length&apos;] ?? null,
            artist: $data[&apos;artist&apos;] ?? null,
            id: $data[&apos;id&apos;] ?? null,
            category: $data[&apos;category&apos;] ?? null,
            year: $data[&apos;year&apos;] ?? null
        );
    }
}</file><file path="app/Http/Integrations/MusicBrainz/Models/FreedbDiscList.php">&lt;?php
namespace App\Http\Integrations\MusicBrainz\Models;
use Spatie\LaravelData\Data;
class FreedbDiscList extends Data
{
    public function __construct(public mixed $count, public mixed $offset, public mixed $freedb_disc, public mixed $title, public mixed $track, public mixed $length, public mixed $artist, public mixed $id, public mixed $category, public mixed $year)
    {
    }
    public static function fromApiData(array $data): self
    {
        return new self(
            count: $data[&apos;count&apos;] ?? null,
            offset: $data[&apos;offset&apos;] ?? null,
            freedb_disc: $data[&apos;freedb-disc&apos;] ?? null,
            title: $data[&apos;title&apos;] ?? null,
            track: $data[&apos;track&apos;] ?? null,
            length: $data[&apos;length&apos;] ?? null,
            artist: $data[&apos;artist&apos;] ?? null,
            id: $data[&apos;id&apos;] ?? null,
            category: $data[&apos;category&apos;] ?? null,
            year: $data[&apos;year&apos;] ?? null
        );
    }
}</file><file path="app/Http/Integrations/MusicBrainz/Models/Genre.php">&lt;?php
namespace App\Http\Integrations\MusicBrainz\Models;
use Spatie\LaravelData\Data;
class Genre extends Data
{
    public function __construct(public mixed $genre, public mixed $name, public mixed $id, public mixed $count, public mixed $disambiguation, public mixed $annotation, public mixed $text, public mixed $type, public mixed $entity, public mixed $offset, public mixed $alias, public mixed $locale, public mixed $sort_name, public mixed $type_id, public mixed $primary, public mixed $begin_date, public mixed $end_date, public mixed $target_type, public mixed $relation, public mixed $target, public mixed $ordering_key, public mixed $direction, public mixed $begin, public mixed $end, public mixed $ended, public mixed $source_credit, public mixed $target_credit)
    {
    }
    public static function fromApiData(array $data): self
    {
        return new self(
            genre: $data[&apos;genre&apos;] ?? null,
            name: $data[&apos;name&apos;] ?? null,
            id: $data[&apos;id&apos;] ?? null,
            count: $data[&apos;count&apos;] ?? null,
            disambiguation: $data[&apos;disambiguation&apos;] ?? null,
            annotation: $data[&apos;annotation&apos;] ?? null,
            text: $data[&apos;text&apos;] ?? null,
            type: $data[&apos;type&apos;] ?? null,
            entity: $data[&apos;entity&apos;] ?? null,
            offset: $data[&apos;offset&apos;] ?? null,
            alias: $data[&apos;alias&apos;] ?? null,
            locale: $data[&apos;locale&apos;] ?? null,
            sort_name: $data[&apos;sort-name&apos;] ?? null,
            type_id: $data[&apos;type-id&apos;] ?? null,
            primary: $data[&apos;primary&apos;] ?? null,
            begin_date: $data[&apos;begin-date&apos;] ?? null,
            end_date: $data[&apos;end-date&apos;] ?? null,
            target_type: $data[&apos;target-type&apos;] ?? null,
            relation: $data[&apos;relation&apos;] ?? null,
            target: $data[&apos;target&apos;] ?? null,
            ordering_key: $data[&apos;ordering-key&apos;] ?? null,
            direction: $data[&apos;direction&apos;] ?? null,
            begin: $data[&apos;begin&apos;] ?? null,
            end: $data[&apos;end&apos;] ?? null,
            ended: $data[&apos;ended&apos;] ?? null,
            source_credit: $data[&apos;source-credit&apos;] ?? null,
            target_credit: $data[&apos;target-credit&apos;] ?? null
        );
    }
}</file><file path="app/Http/Integrations/MusicBrainz/Models/GenreList.php">&lt;?php
namespace App\Http\Integrations\MusicBrainz\Models;
use Spatie\LaravelData\Data;
class GenreList extends Data
{
    public function __construct(public mixed $count, public mixed $offset, public mixed $genre, public mixed $name, public mixed $id, public mixed $disambiguation, public mixed $annotation, public mixed $text, public mixed $type, public mixed $entity, public mixed $alias, public mixed $locale, public mixed $sort_name, public mixed $type_id, public mixed $primary, public mixed $begin_date, public mixed $end_date, public mixed $target_type, public mixed $relation, public mixed $target, public mixed $ordering_key, public mixed $direction, public mixed $begin, public mixed $end, public mixed $ended, public mixed $source_credit, public mixed $target_credit)
    {
    }
    public static function fromApiData(array $data): self
    {
        return new self(
            count: $data[&apos;count&apos;] ?? null,
            offset: $data[&apos;offset&apos;] ?? null,
            genre: $data[&apos;genre&apos;] ?? null,
            name: $data[&apos;name&apos;] ?? null,
            id: $data[&apos;id&apos;] ?? null,
            disambiguation: $data[&apos;disambiguation&apos;] ?? null,
            annotation: $data[&apos;annotation&apos;] ?? null,
            text: $data[&apos;text&apos;] ?? null,
            type: $data[&apos;type&apos;] ?? null,
            entity: $data[&apos;entity&apos;] ?? null,
            alias: $data[&apos;alias&apos;] ?? null,
            locale: $data[&apos;locale&apos;] ?? null,
            sort_name: $data[&apos;sort-name&apos;] ?? null,
            type_id: $data[&apos;type-id&apos;] ?? null,
            primary: $data[&apos;primary&apos;] ?? null,
            begin_date: $data[&apos;begin-date&apos;] ?? null,
            end_date: $data[&apos;end-date&apos;] ?? null,
            target_type: $data[&apos;target-type&apos;] ?? null,
            relation: $data[&apos;relation&apos;] ?? null,
            target: $data[&apos;target&apos;] ?? null,
            ordering_key: $data[&apos;ordering-key&apos;] ?? null,
            direction: $data[&apos;direction&apos;] ?? null,
            begin: $data[&apos;begin&apos;] ?? null,
            end: $data[&apos;end&apos;] ?? null,
            ended: $data[&apos;ended&apos;] ?? null,
            source_credit: $data[&apos;source-credit&apos;] ?? null,
            target_credit: $data[&apos;target-credit&apos;] ?? null
        );
    }
}</file><file path="app/Http/Integrations/MusicBrainz/Models/Instrument.php">&lt;?php
namespace App\Http\Integrations\MusicBrainz\Models;
use Spatie\LaravelData\Data;
class Instrument extends Data
{
    public function __construct(public mixed $instrument, public mixed $id, public mixed $type, public mixed $type_id, public mixed $name, public mixed $disambiguation, public mixed $description, public mixed $annotation, public mixed $text, public mixed $entity, public mixed $count, public mixed $offset, public mixed $alias, public mixed $locale, public mixed $sort_name, public mixed $primary, public mixed $begin_date, public mixed $end_date, public mixed $tag, public mixed $user_tag, public mixed $genre, public mixed $target_type, public mixed $relation, public mixed $target, public mixed $ordering_key, public mixed $direction, public mixed $begin, public mixed $end, public mixed $ended, public mixed $source_credit, public mixed $target_credit, public mixed $user_genre)
    {
    }
    public static function fromApiData(array $data): self
    {
        return new self(
            instrument: $data[&apos;instrument&apos;] ?? null,
            id: $data[&apos;id&apos;] ?? null,
            type: $data[&apos;type&apos;] ?? null,
            type_id: $data[&apos;type-id&apos;] ?? null,
            name: $data[&apos;name&apos;] ?? null,
            disambiguation: $data[&apos;disambiguation&apos;] ?? null,
            description: $data[&apos;description&apos;] ?? null,
            annotation: $data[&apos;annotation&apos;] ?? null,
            text: $data[&apos;text&apos;] ?? null,
            entity: $data[&apos;entity&apos;] ?? null,
            count: $data[&apos;count&apos;] ?? null,
            offset: $data[&apos;offset&apos;] ?? null,
            alias: $data[&apos;alias&apos;] ?? null,
            locale: $data[&apos;locale&apos;] ?? null,
            sort_name: $data[&apos;sort-name&apos;] ?? null,
            primary: $data[&apos;primary&apos;] ?? null,
            begin_date: $data[&apos;begin-date&apos;] ?? null,
            end_date: $data[&apos;end-date&apos;] ?? null,
            tag: $data[&apos;tag&apos;] ?? null,
            user_tag: $data[&apos;user-tag&apos;] ?? null,
            genre: $data[&apos;genre&apos;] ?? null,
            target_type: $data[&apos;target-type&apos;] ?? null,
            relation: $data[&apos;relation&apos;] ?? null,
            target: $data[&apos;target&apos;] ?? null,
            ordering_key: $data[&apos;ordering-key&apos;] ?? null,
            direction: $data[&apos;direction&apos;] ?? null,
            begin: $data[&apos;begin&apos;] ?? null,
            end: $data[&apos;end&apos;] ?? null,
            ended: $data[&apos;ended&apos;] ?? null,
            source_credit: $data[&apos;source-credit&apos;] ?? null,
            target_credit: $data[&apos;target-credit&apos;] ?? null,
            user_genre: $data[&apos;user-genre&apos;] ?? null
        );
    }
}</file><file path="app/Http/Integrations/MusicBrainz/Models/InstrumentList.php">&lt;?php
namespace App\Http\Integrations\MusicBrainz\Models;
use Spatie\LaravelData\Data;
class InstrumentList extends Data
{
    public function __construct(public mixed $count, public mixed $offset, public mixed $instrument, public mixed $id, public mixed $type, public mixed $type_id, public mixed $name, public mixed $disambiguation, public mixed $description, public mixed $annotation, public mixed $text, public mixed $entity, public mixed $alias, public mixed $locale, public mixed $sort_name, public mixed $primary, public mixed $begin_date, public mixed $end_date, public mixed $tag, public mixed $user_tag, public mixed $genre, public mixed $target_type, public mixed $relation, public mixed $target, public mixed $ordering_key, public mixed $direction, public mixed $begin, public mixed $end, public mixed $ended, public mixed $source_credit, public mixed $target_credit, public mixed $user_genre)
    {
    }
    public static function fromApiData(array $data): self
    {
        return new self(
            count: $data[&apos;count&apos;] ?? null,
            offset: $data[&apos;offset&apos;] ?? null,
            instrument: $data[&apos;instrument&apos;] ?? null,
            id: $data[&apos;id&apos;] ?? null,
            type: $data[&apos;type&apos;] ?? null,
            type_id: $data[&apos;type-id&apos;] ?? null,
            name: $data[&apos;name&apos;] ?? null,
            disambiguation: $data[&apos;disambiguation&apos;] ?? null,
            description: $data[&apos;description&apos;] ?? null,
            annotation: $data[&apos;annotation&apos;] ?? null,
            text: $data[&apos;text&apos;] ?? null,
            entity: $data[&apos;entity&apos;] ?? null,
            alias: $data[&apos;alias&apos;] ?? null,
            locale: $data[&apos;locale&apos;] ?? null,
            sort_name: $data[&apos;sort-name&apos;] ?? null,
            primary: $data[&apos;primary&apos;] ?? null,
            begin_date: $data[&apos;begin-date&apos;] ?? null,
            end_date: $data[&apos;end-date&apos;] ?? null,
            tag: $data[&apos;tag&apos;] ?? null,
            user_tag: $data[&apos;user-tag&apos;] ?? null,
            genre: $data[&apos;genre&apos;] ?? null,
            target_type: $data[&apos;target-type&apos;] ?? null,
            relation: $data[&apos;relation&apos;] ?? null,
            target: $data[&apos;target&apos;] ?? null,
            ordering_key: $data[&apos;ordering-key&apos;] ?? null,
            direction: $data[&apos;direction&apos;] ?? null,
            begin: $data[&apos;begin&apos;] ?? null,
            end: $data[&apos;end&apos;] ?? null,
            ended: $data[&apos;ended&apos;] ?? null,
            source_credit: $data[&apos;source-credit&apos;] ?? null,
            target_credit: $data[&apos;target-credit&apos;] ?? null,
            user_genre: $data[&apos;user-genre&apos;] ?? null
        );
    }
}</file><file path="app/Http/Integrations/MusicBrainz/Models/IpiList.php">&lt;?php
namespace App\Http\Integrations\MusicBrainz\Models;
use Spatie\LaravelData\Data;
class IpiList extends Data
{
    public function __construct(public mixed $ipi)
    {
    }
    public static function fromApiData(array $data): self
    {
        return new self(
            ipi: $data[&apos;ipi&apos;] ?? null
        );
    }
}</file><file path="app/Http/Integrations/MusicBrainz/Models/IsniList.php">&lt;?php
namespace App\Http\Integrations\MusicBrainz\Models;
use Spatie\LaravelData\Data;
class IsniList extends Data
{
    public function __construct(public mixed $isni)
    {
    }
    public static function fromApiData(array $data): self
    {
        return new self(
            isni: $data[&apos;isni&apos;] ?? null
        );
    }
}</file><file path="app/Http/Integrations/MusicBrainz/Models/Iso31661CodeList.php">&lt;?php
namespace App\Http\Integrations\MusicBrainz\Models;
use Spatie\LaravelData\Data;
class Iso31661CodeList extends Data
{
    public function __construct(public mixed $iso_3166_1_code)
    {
    }
    public static function fromApiData(array $data): self
    {
        return new self(
            iso_3166_1_code: $data[&apos;iso-3166-1-code&apos;] ?? null
        );
    }
}</file><file path="app/Http/Integrations/MusicBrainz/Models/Iso31662CodeList.php">&lt;?php
namespace App\Http\Integrations\MusicBrainz\Models;
use Spatie\LaravelData\Data;
class Iso31662CodeList extends Data
{
    public function __construct(public mixed $iso_3166_2_code)
    {
    }
    public static function fromApiData(array $data): self
    {
        return new self(
            iso_3166_2_code: $data[&apos;iso-3166-2-code&apos;] ?? null
        );
    }
}</file><file path="app/Http/Integrations/MusicBrainz/Models/Iso31663CodeList.php">&lt;?php
namespace App\Http\Integrations\MusicBrainz\Models;
use Spatie\LaravelData\Data;
class Iso31663CodeList extends Data
{
    public function __construct(public mixed $iso_3166_3_code)
    {
    }
    public static function fromApiData(array $data): self
    {
        return new self(
            iso_3166_3_code: $data[&apos;iso-3166-3-code&apos;] ?? null
        );
    }
}</file><file path="app/Http/Integrations/MusicBrainz/Models/Isrc.php">&lt;?php
namespace App\Http\Integrations\MusicBrainz\Models;
use Spatie\LaravelData\Data;
class Isrc extends Data
{
    public function __construct(public mixed $isrc, public mixed $id, public mixed $count, public mixed $offset, public mixed $recording, public mixed $title, public mixed $length, public mixed $annotation, public mixed $text, public mixed $type, public mixed $entity, public mixed $name, public mixed $disambiguation, public mixed $video, public mixed $artist_credit, public mixed $first_release_date, public mixed $release, public mixed $status, public mixed $quality, public mixed $packaging, public mixed $text_representation, public mixed $language, public mixed $script, public mixed $alias, public mixed $locale, public mixed $sort_name, public mixed $type_id, public mixed $primary, public mixed $begin_date, public mixed $end_date, public mixed $release_group, public mixed $primary_type, public mixed $secondary_type, public mixed $tag, public mixed $user_tag, public mixed $genre, public mixed $target_type, public mixed $relation, public mixed $target, public mixed $ordering_key, public mixed $direction, public mixed $begin, public mixed $end, public mixed $ended, public mixed $source_credit, public mixed $target_credit, public mixed $user_genre, public mixed $rating, public mixed $votes_count, public mixed $user_rating, public mixed $date, public mixed $country, public mixed $release_event, public mixed $area, public mixed $iso_3166_1_code, public mixed $iso_3166_2_code, public mixed $iso_3166_3_code, public mixed $life_span, public mixed $barcode, public mixed $asin, public mixed $cover_art_archive, public mixed $artwork, public mixed $front, public mixed $back, public mixed $darkened, public mixed $label_info, public mixed $catalog_number, public mixed $label, public mixed $label_code, public mixed $ipi, public mixed $isni, public mixed $track_count, public mixed $medium, public mixed $track, public mixed $position, public mixed $number, public mixed $format, public mixed $disc, public mixed $sectors, public mixed $pregap, public mixed $collection, public mixed $entity_type, public mixed $editor, public mixed $artist, public mixed $gender, public mixed $begin_area, public mixed $end_area, public mixed $work, public mixed $fluency, public mixed $iswc, public mixed $event, public mixed $cancelled, public mixed $time, public mixed $setlist, public mixed $instrument, public mixed $description, public mixed $place, public mixed $address, public mixed $coordinates, public mixed $latitude, public mixed $longitude, public mixed $series, public mixed $puid)
    {
    }
    public static function fromApiData(array $data): self
    {
        return new self(
            isrc: $data[&apos;isrc&apos;] ?? null,
            id: $data[&apos;id&apos;] ?? null,
            count: $data[&apos;count&apos;] ?? null,
            offset: $data[&apos;offset&apos;] ?? null,
            recording: $data[&apos;recording&apos;] ?? null,
            title: $data[&apos;title&apos;] ?? null,
            length: $data[&apos;length&apos;] ?? null,
            annotation: $data[&apos;annotation&apos;] ?? null,
            text: $data[&apos;text&apos;] ?? null,
            type: $data[&apos;type&apos;] ?? null,
            entity: $data[&apos;entity&apos;] ?? null,
            name: $data[&apos;name&apos;] ?? null,
            disambiguation: $data[&apos;disambiguation&apos;] ?? null,
            video: $data[&apos;video&apos;] ?? null,
            artist_credit: $data[&apos;artist-credit&apos;] ?? null,
            first_release_date: $data[&apos;first-release-date&apos;] ?? null,
            release: $data[&apos;release&apos;] ?? null,
            status: $data[&apos;status&apos;] ?? null,
            quality: $data[&apos;quality&apos;] ?? null,
            packaging: $data[&apos;packaging&apos;] ?? null,
            text_representation: $data[&apos;text-representation&apos;] ?? null,
            language: $data[&apos;language&apos;] ?? null,
            script: $data[&apos;script&apos;] ?? null,
            alias: $data[&apos;alias&apos;] ?? null,
            locale: $data[&apos;locale&apos;] ?? null,
            sort_name: $data[&apos;sort-name&apos;] ?? null,
            type_id: $data[&apos;type-id&apos;] ?? null,
            primary: $data[&apos;primary&apos;] ?? null,
            begin_date: $data[&apos;begin-date&apos;] ?? null,
            end_date: $data[&apos;end-date&apos;] ?? null,
            release_group: $data[&apos;release-group&apos;] ?? null,
            primary_type: $data[&apos;primary-type&apos;] ?? null,
            secondary_type: $data[&apos;secondary-type&apos;] ?? null,
            tag: $data[&apos;tag&apos;] ?? null,
            user_tag: $data[&apos;user-tag&apos;] ?? null,
            genre: $data[&apos;genre&apos;] ?? null,
            target_type: $data[&apos;target-type&apos;] ?? null,
            relation: $data[&apos;relation&apos;] ?? null,
            target: $data[&apos;target&apos;] ?? null,
            ordering_key: $data[&apos;ordering-key&apos;] ?? null,
            direction: $data[&apos;direction&apos;] ?? null,
            begin: $data[&apos;begin&apos;] ?? null,
            end: $data[&apos;end&apos;] ?? null,
            ended: $data[&apos;ended&apos;] ?? null,
            source_credit: $data[&apos;source-credit&apos;] ?? null,
            target_credit: $data[&apos;target-credit&apos;] ?? null,
            user_genre: $data[&apos;user-genre&apos;] ?? null,
            rating: $data[&apos;rating&apos;] ?? null,
            votes_count: $data[&apos;votes-count&apos;] ?? null,
            user_rating: $data[&apos;user-rating&apos;] ?? null,
            date: $data[&apos;date&apos;] ?? null,
            country: $data[&apos;country&apos;] ?? null,
            release_event: $data[&apos;release-event&apos;] ?? null,
            area: $data[&apos;area&apos;] ?? null,
            iso_3166_1_code: $data[&apos;iso-3166-1-code&apos;] ?? null,
            iso_3166_2_code: $data[&apos;iso-3166-2-code&apos;] ?? null,
            iso_3166_3_code: $data[&apos;iso-3166-3-code&apos;] ?? null,
            life_span: $data[&apos;life-span&apos;] ?? null,
            barcode: $data[&apos;barcode&apos;] ?? null,
            asin: $data[&apos;asin&apos;] ?? null,
            cover_art_archive: $data[&apos;cover-art-archive&apos;] ?? null,
            artwork: $data[&apos;artwork&apos;] ?? null,
            front: $data[&apos;front&apos;] ?? null,
            back: $data[&apos;back&apos;] ?? null,
            darkened: $data[&apos;darkened&apos;] ?? null,
            label_info: $data[&apos;label-info&apos;] ?? null,
            catalog_number: $data[&apos;catalog-number&apos;] ?? null,
            label: $data[&apos;label&apos;] ?? null,
            label_code: $data[&apos;label-code&apos;] ?? null,
            ipi: $data[&apos;ipi&apos;] ?? null,
            isni: $data[&apos;isni&apos;] ?? null,
            track_count: $data[&apos;track-count&apos;] ?? null,
            medium: $data[&apos;medium&apos;] ?? null,
            track: $data[&apos;track&apos;] ?? null,
            position: $data[&apos;position&apos;] ?? null,
            number: $data[&apos;number&apos;] ?? null,
            format: $data[&apos;format&apos;] ?? null,
            disc: $data[&apos;disc&apos;] ?? null,
            sectors: $data[&apos;sectors&apos;] ?? null,
            pregap: $data[&apos;pregap&apos;] ?? null,
            collection: $data[&apos;collection&apos;] ?? null,
            entity_type: $data[&apos;entity-type&apos;] ?? null,
            editor: $data[&apos;editor&apos;] ?? null,
            artist: $data[&apos;artist&apos;] ?? null,
            gender: $data[&apos;gender&apos;] ?? null,
            begin_area: $data[&apos;begin-area&apos;] ?? null,
            end_area: $data[&apos;end-area&apos;] ?? null,
            work: $data[&apos;work&apos;] ?? null,
            fluency: $data[&apos;fluency&apos;] ?? null,
            iswc: $data[&apos;iswc&apos;] ?? null,
            event: $data[&apos;event&apos;] ?? null,
            cancelled: $data[&apos;cancelled&apos;] ?? null,
            time: $data[&apos;time&apos;] ?? null,
            setlist: $data[&apos;setlist&apos;] ?? null,
            instrument: $data[&apos;instrument&apos;] ?? null,
            description: $data[&apos;description&apos;] ?? null,
            place: $data[&apos;place&apos;] ?? null,
            address: $data[&apos;address&apos;] ?? null,
            coordinates: $data[&apos;coordinates&apos;] ?? null,
            latitude: $data[&apos;latitude&apos;] ?? null,
            longitude: $data[&apos;longitude&apos;] ?? null,
            series: $data[&apos;series&apos;] ?? null,
            puid: $data[&apos;puid&apos;] ?? null
        );
    }
}</file><file path="app/Http/Integrations/MusicBrainz/Models/IsrcList.php">&lt;?php
namespace App\Http\Integrations\MusicBrainz\Models;
use Spatie\LaravelData\Data;
class IsrcList extends Data
{
    public function __construct(public mixed $count, public mixed $offset, public mixed $isrc, public mixed $id, public mixed $recording, public mixed $title, public mixed $length, public mixed $annotation, public mixed $text, public mixed $type, public mixed $entity, public mixed $name, public mixed $disambiguation, public mixed $video, public mixed $artist_credit, public mixed $first_release_date, public mixed $release, public mixed $status, public mixed $quality, public mixed $packaging, public mixed $text_representation, public mixed $language, public mixed $script, public mixed $alias, public mixed $locale, public mixed $sort_name, public mixed $type_id, public mixed $primary, public mixed $begin_date, public mixed $end_date, public mixed $release_group, public mixed $primary_type, public mixed $secondary_type, public mixed $tag, public mixed $user_tag, public mixed $genre, public mixed $target_type, public mixed $relation, public mixed $target, public mixed $ordering_key, public mixed $direction, public mixed $begin, public mixed $end, public mixed $ended, public mixed $source_credit, public mixed $target_credit, public mixed $user_genre, public mixed $rating, public mixed $votes_count, public mixed $user_rating, public mixed $date, public mixed $country, public mixed $release_event, public mixed $area, public mixed $iso_3166_1_code, public mixed $iso_3166_2_code, public mixed $iso_3166_3_code, public mixed $life_span, public mixed $barcode, public mixed $asin, public mixed $cover_art_archive, public mixed $artwork, public mixed $front, public mixed $back, public mixed $darkened, public mixed $label_info, public mixed $catalog_number, public mixed $label, public mixed $label_code, public mixed $ipi, public mixed $isni, public mixed $track_count, public mixed $medium, public mixed $track, public mixed $position, public mixed $number, public mixed $format, public mixed $disc, public mixed $sectors, public mixed $pregap, public mixed $collection, public mixed $entity_type, public mixed $editor, public mixed $artist, public mixed $gender, public mixed $begin_area, public mixed $end_area, public mixed $work, public mixed $fluency, public mixed $iswc, public mixed $event, public mixed $cancelled, public mixed $time, public mixed $setlist, public mixed $instrument, public mixed $description, public mixed $place, public mixed $address, public mixed $coordinates, public mixed $latitude, public mixed $longitude, public mixed $series, public mixed $puid)
    {
    }
    public static function fromApiData(array $data): self
    {
        return new self(
            count: $data[&apos;count&apos;] ?? null,
            offset: $data[&apos;offset&apos;] ?? null,
            isrc: $data[&apos;isrc&apos;] ?? null,
            id: $data[&apos;id&apos;] ?? null,
            recording: $data[&apos;recording&apos;] ?? null,
            title: $data[&apos;title&apos;] ?? null,
            length: $data[&apos;length&apos;] ?? null,
            annotation: $data[&apos;annotation&apos;] ?? null,
            text: $data[&apos;text&apos;] ?? null,
            type: $data[&apos;type&apos;] ?? null,
            entity: $data[&apos;entity&apos;] ?? null,
            name: $data[&apos;name&apos;] ?? null,
            disambiguation: $data[&apos;disambiguation&apos;] ?? null,
            video: $data[&apos;video&apos;] ?? null,
            artist_credit: $data[&apos;artist-credit&apos;] ?? null,
            first_release_date: $data[&apos;first-release-date&apos;] ?? null,
            release: $data[&apos;release&apos;] ?? null,
            status: $data[&apos;status&apos;] ?? null,
            quality: $data[&apos;quality&apos;] ?? null,
            packaging: $data[&apos;packaging&apos;] ?? null,
            text_representation: $data[&apos;text-representation&apos;] ?? null,
            language: $data[&apos;language&apos;] ?? null,
            script: $data[&apos;script&apos;] ?? null,
            alias: $data[&apos;alias&apos;] ?? null,
            locale: $data[&apos;locale&apos;] ?? null,
            sort_name: $data[&apos;sort-name&apos;] ?? null,
            type_id: $data[&apos;type-id&apos;] ?? null,
            primary: $data[&apos;primary&apos;] ?? null,
            begin_date: $data[&apos;begin-date&apos;] ?? null,
            end_date: $data[&apos;end-date&apos;] ?? null,
            release_group: $data[&apos;release-group&apos;] ?? null,
            primary_type: $data[&apos;primary-type&apos;] ?? null,
            secondary_type: $data[&apos;secondary-type&apos;] ?? null,
            tag: $data[&apos;tag&apos;] ?? null,
            user_tag: $data[&apos;user-tag&apos;] ?? null,
            genre: $data[&apos;genre&apos;] ?? null,
            target_type: $data[&apos;target-type&apos;] ?? null,
            relation: $data[&apos;relation&apos;] ?? null,
            target: $data[&apos;target&apos;] ?? null,
            ordering_key: $data[&apos;ordering-key&apos;] ?? null,
            direction: $data[&apos;direction&apos;] ?? null,
            begin: $data[&apos;begin&apos;] ?? null,
            end: $data[&apos;end&apos;] ?? null,
            ended: $data[&apos;ended&apos;] ?? null,
            source_credit: $data[&apos;source-credit&apos;] ?? null,
            target_credit: $data[&apos;target-credit&apos;] ?? null,
            user_genre: $data[&apos;user-genre&apos;] ?? null,
            rating: $data[&apos;rating&apos;] ?? null,
            votes_count: $data[&apos;votes-count&apos;] ?? null,
            user_rating: $data[&apos;user-rating&apos;] ?? null,
            date: $data[&apos;date&apos;] ?? null,
            country: $data[&apos;country&apos;] ?? null,
            release_event: $data[&apos;release-event&apos;] ?? null,
            area: $data[&apos;area&apos;] ?? null,
            iso_3166_1_code: $data[&apos;iso-3166-1-code&apos;] ?? null,
            iso_3166_2_code: $data[&apos;iso-3166-2-code&apos;] ?? null,
            iso_3166_3_code: $data[&apos;iso-3166-3-code&apos;] ?? null,
            life_span: $data[&apos;life-span&apos;] ?? null,
            barcode: $data[&apos;barcode&apos;] ?? null,
            asin: $data[&apos;asin&apos;] ?? null,
            cover_art_archive: $data[&apos;cover-art-archive&apos;] ?? null,
            artwork: $data[&apos;artwork&apos;] ?? null,
            front: $data[&apos;front&apos;] ?? null,
            back: $data[&apos;back&apos;] ?? null,
            darkened: $data[&apos;darkened&apos;] ?? null,
            label_info: $data[&apos;label-info&apos;] ?? null,
            catalog_number: $data[&apos;catalog-number&apos;] ?? null,
            label: $data[&apos;label&apos;] ?? null,
            label_code: $data[&apos;label-code&apos;] ?? null,
            ipi: $data[&apos;ipi&apos;] ?? null,
            isni: $data[&apos;isni&apos;] ?? null,
            track_count: $data[&apos;track-count&apos;] ?? null,
            medium: $data[&apos;medium&apos;] ?? null,
            track: $data[&apos;track&apos;] ?? null,
            position: $data[&apos;position&apos;] ?? null,
            number: $data[&apos;number&apos;] ?? null,
            format: $data[&apos;format&apos;] ?? null,
            disc: $data[&apos;disc&apos;] ?? null,
            sectors: $data[&apos;sectors&apos;] ?? null,
            pregap: $data[&apos;pregap&apos;] ?? null,
            collection: $data[&apos;collection&apos;] ?? null,
            entity_type: $data[&apos;entity-type&apos;] ?? null,
            editor: $data[&apos;editor&apos;] ?? null,
            artist: $data[&apos;artist&apos;] ?? null,
            gender: $data[&apos;gender&apos;] ?? null,
            begin_area: $data[&apos;begin-area&apos;] ?? null,
            end_area: $data[&apos;end-area&apos;] ?? null,
            work: $data[&apos;work&apos;] ?? null,
            fluency: $data[&apos;fluency&apos;] ?? null,
            iswc: $data[&apos;iswc&apos;] ?? null,
            event: $data[&apos;event&apos;] ?? null,
            cancelled: $data[&apos;cancelled&apos;] ?? null,
            time: $data[&apos;time&apos;] ?? null,
            setlist: $data[&apos;setlist&apos;] ?? null,
            instrument: $data[&apos;instrument&apos;] ?? null,
            description: $data[&apos;description&apos;] ?? null,
            place: $data[&apos;place&apos;] ?? null,
            address: $data[&apos;address&apos;] ?? null,
            coordinates: $data[&apos;coordinates&apos;] ?? null,
            latitude: $data[&apos;latitude&apos;] ?? null,
            longitude: $data[&apos;longitude&apos;] ?? null,
            series: $data[&apos;series&apos;] ?? null,
            puid: $data[&apos;puid&apos;] ?? null
        );
    }
}</file><file path="app/Http/Integrations/MusicBrainz/Models/Iswc.php">&lt;?php
namespace App\Http\Integrations\MusicBrainz\Models;
use Spatie\LaravelData\Data;
class Iswc extends Data
{
    public function __construct(public mixed $iswc)
    {
    }
    public static function fromApiData(array $data): self
    {
        return new self(
            iswc: $data[&apos;iswc&apos;] ?? null
        );
    }
}</file><file path="app/Http/Integrations/MusicBrainz/Models/IswcList.php">&lt;?php
namespace App\Http\Integrations\MusicBrainz\Models;
use Spatie\LaravelData\Data;
class IswcList extends Data
{
    public function __construct(public mixed $count, public mixed $offset, public mixed $iswc)
    {
    }
    public static function fromApiData(array $data): self
    {
        return new self(
            count: $data[&apos;count&apos;] ?? null,
            offset: $data[&apos;offset&apos;] ?? null,
            iswc: $data[&apos;iswc&apos;] ?? null
        );
    }
}</file><file path="app/Http/Integrations/MusicBrainz/Models/Label.php">&lt;?php
namespace App\Http\Integrations\MusicBrainz\Models;
use Spatie\LaravelData\Data;
class Label extends Data
{
    public function __construct(public mixed $label, public mixed $id, public mixed $type, public mixed $type_id, public mixed $name, public mixed $sort_name, public mixed $label_code, public mixed $ipi, public mixed $isni, public mixed $annotation, public mixed $text, public mixed $entity, public mixed $disambiguation, public mixed $country, public mixed $area, public mixed $iso_3166_1_code, public mixed $iso_3166_2_code, public mixed $iso_3166_3_code, public mixed $life_span, public mixed $begin, public mixed $end, public mixed $ended, public mixed $count, public mixed $offset, public mixed $alias, public mixed $locale, public mixed $primary, public mixed $begin_date, public mixed $end_date, public mixed $tag, public mixed $user_tag, public mixed $genre, public mixed $target_type, public mixed $relation, public mixed $target, public mixed $ordering_key, public mixed $direction, public mixed $source_credit, public mixed $target_credit, public mixed $user_genre, public mixed $release, public mixed $title, public mixed $status, public mixed $quality, public mixed $packaging, public mixed $text_representation, public mixed $language, public mixed $script, public mixed $artist_credit, public mixed $release_group, public mixed $first_release_date, public mixed $primary_type, public mixed $secondary_type, public mixed $rating, public mixed $votes_count, public mixed $user_rating, public mixed $date, public mixed $release_event, public mixed $barcode, public mixed $asin, public mixed $cover_art_archive, public mixed $artwork, public mixed $front, public mixed $back, public mixed $darkened, public mixed $label_info, public mixed $catalog_number, public mixed $track_count, public mixed $medium, public mixed $track, public mixed $position, public mixed $number, public mixed $length, public mixed $recording, public mixed $video, public mixed $puid, public mixed $isrc, public mixed $format, public mixed $disc, public mixed $sectors, public mixed $pregap, public mixed $collection, public mixed $entity_type, public mixed $editor, public mixed $artist, public mixed $gender, public mixed $begin_area, public mixed $end_area, public mixed $work, public mixed $fluency, public mixed $iswc, public mixed $event, public mixed $cancelled, public mixed $time, public mixed $setlist, public mixed $instrument, public mixed $description, public mixed $place, public mixed $address, public mixed $coordinates, public mixed $latitude, public mixed $longitude, public mixed $series)
    {
    }
    public static function fromApiData(array $data): self
    {
        return new self(
            label: $data[&apos;label&apos;] ?? null,
            id: $data[&apos;id&apos;] ?? null,
            type: $data[&apos;type&apos;] ?? null,
            type_id: $data[&apos;type-id&apos;] ?? null,
            name: $data[&apos;name&apos;] ?? null,
            sort_name: $data[&apos;sort-name&apos;] ?? null,
            label_code: $data[&apos;label-code&apos;] ?? null,
            ipi: $data[&apos;ipi&apos;] ?? null,
            isni: $data[&apos;isni&apos;] ?? null,
            annotation: $data[&apos;annotation&apos;] ?? null,
            text: $data[&apos;text&apos;] ?? null,
            entity: $data[&apos;entity&apos;] ?? null,
            disambiguation: $data[&apos;disambiguation&apos;] ?? null,
            country: $data[&apos;country&apos;] ?? null,
            area: $data[&apos;area&apos;] ?? null,
            iso_3166_1_code: $data[&apos;iso-3166-1-code&apos;] ?? null,
            iso_3166_2_code: $data[&apos;iso-3166-2-code&apos;] ?? null,
            iso_3166_3_code: $data[&apos;iso-3166-3-code&apos;] ?? null,
            life_span: $data[&apos;life-span&apos;] ?? null,
            begin: $data[&apos;begin&apos;] ?? null,
            end: $data[&apos;end&apos;] ?? null,
            ended: $data[&apos;ended&apos;] ?? null,
            count: $data[&apos;count&apos;] ?? null,
            offset: $data[&apos;offset&apos;] ?? null,
            alias: $data[&apos;alias&apos;] ?? null,
            locale: $data[&apos;locale&apos;] ?? null,
            primary: $data[&apos;primary&apos;] ?? null,
            begin_date: $data[&apos;begin-date&apos;] ?? null,
            end_date: $data[&apos;end-date&apos;] ?? null,
            tag: $data[&apos;tag&apos;] ?? null,
            user_tag: $data[&apos;user-tag&apos;] ?? null,
            genre: $data[&apos;genre&apos;] ?? null,
            target_type: $data[&apos;target-type&apos;] ?? null,
            relation: $data[&apos;relation&apos;] ?? null,
            target: $data[&apos;target&apos;] ?? null,
            ordering_key: $data[&apos;ordering-key&apos;] ?? null,
            direction: $data[&apos;direction&apos;] ?? null,
            source_credit: $data[&apos;source-credit&apos;] ?? null,
            target_credit: $data[&apos;target-credit&apos;] ?? null,
            user_genre: $data[&apos;user-genre&apos;] ?? null,
            release: $data[&apos;release&apos;] ?? null,
            title: $data[&apos;title&apos;] ?? null,
            status: $data[&apos;status&apos;] ?? null,
            quality: $data[&apos;quality&apos;] ?? null,
            packaging: $data[&apos;packaging&apos;] ?? null,
            text_representation: $data[&apos;text-representation&apos;] ?? null,
            language: $data[&apos;language&apos;] ?? null,
            script: $data[&apos;script&apos;] ?? null,
            artist_credit: $data[&apos;artist-credit&apos;] ?? null,
            release_group: $data[&apos;release-group&apos;] ?? null,
            first_release_date: $data[&apos;first-release-date&apos;] ?? null,
            primary_type: $data[&apos;primary-type&apos;] ?? null,
            secondary_type: $data[&apos;secondary-type&apos;] ?? null,
            rating: $data[&apos;rating&apos;] ?? null,
            votes_count: $data[&apos;votes-count&apos;] ?? null,
            user_rating: $data[&apos;user-rating&apos;] ?? null,
            date: $data[&apos;date&apos;] ?? null,
            release_event: $data[&apos;release-event&apos;] ?? null,
            barcode: $data[&apos;barcode&apos;] ?? null,
            asin: $data[&apos;asin&apos;] ?? null,
            cover_art_archive: $data[&apos;cover-art-archive&apos;] ?? null,
            artwork: $data[&apos;artwork&apos;] ?? null,
            front: $data[&apos;front&apos;] ?? null,
            back: $data[&apos;back&apos;] ?? null,
            darkened: $data[&apos;darkened&apos;] ?? null,
            label_info: $data[&apos;label-info&apos;] ?? null,
            catalog_number: $data[&apos;catalog-number&apos;] ?? null,
            track_count: $data[&apos;track-count&apos;] ?? null,
            medium: $data[&apos;medium&apos;] ?? null,
            track: $data[&apos;track&apos;] ?? null,
            position: $data[&apos;position&apos;] ?? null,
            number: $data[&apos;number&apos;] ?? null,
            length: $data[&apos;length&apos;] ?? null,
            recording: $data[&apos;recording&apos;] ?? null,
            video: $data[&apos;video&apos;] ?? null,
            puid: $data[&apos;puid&apos;] ?? null,
            isrc: $data[&apos;isrc&apos;] ?? null,
            format: $data[&apos;format&apos;] ?? null,
            disc: $data[&apos;disc&apos;] ?? null,
            sectors: $data[&apos;sectors&apos;] ?? null,
            pregap: $data[&apos;pregap&apos;] ?? null,
            collection: $data[&apos;collection&apos;] ?? null,
            entity_type: $data[&apos;entity-type&apos;] ?? null,
            editor: $data[&apos;editor&apos;] ?? null,
            artist: $data[&apos;artist&apos;] ?? null,
            gender: $data[&apos;gender&apos;] ?? null,
            begin_area: $data[&apos;begin-area&apos;] ?? null,
            end_area: $data[&apos;end-area&apos;] ?? null,
            work: $data[&apos;work&apos;] ?? null,
            fluency: $data[&apos;fluency&apos;] ?? null,
            iswc: $data[&apos;iswc&apos;] ?? null,
            event: $data[&apos;event&apos;] ?? null,
            cancelled: $data[&apos;cancelled&apos;] ?? null,
            time: $data[&apos;time&apos;] ?? null,
            setlist: $data[&apos;setlist&apos;] ?? null,
            instrument: $data[&apos;instrument&apos;] ?? null,
            description: $data[&apos;description&apos;] ?? null,
            place: $data[&apos;place&apos;] ?? null,
            address: $data[&apos;address&apos;] ?? null,
            coordinates: $data[&apos;coordinates&apos;] ?? null,
            latitude: $data[&apos;latitude&apos;] ?? null,
            longitude: $data[&apos;longitude&apos;] ?? null,
            series: $data[&apos;series&apos;] ?? null
        );
    }
}</file><file path="app/Http/Integrations/MusicBrainz/Models/LabelInfo.php">&lt;?php
namespace App\Http\Integrations\MusicBrainz\Models;
use Spatie\LaravelData\Data;
class LabelInfo extends Data
{
    public function __construct(public mixed $label_info, public mixed $catalog_number, public mixed $label, public mixed $id, public mixed $type, public mixed $type_id, public mixed $name, public mixed $sort_name, public mixed $label_code, public mixed $ipi, public mixed $isni, public mixed $annotation, public mixed $text, public mixed $entity, public mixed $disambiguation, public mixed $country, public mixed $area, public mixed $iso_3166_1_code, public mixed $iso_3166_2_code, public mixed $iso_3166_3_code, public mixed $life_span, public mixed $begin, public mixed $end, public mixed $ended, public mixed $count, public mixed $offset, public mixed $alias, public mixed $locale, public mixed $primary, public mixed $begin_date, public mixed $end_date, public mixed $tag, public mixed $user_tag, public mixed $genre, public mixed $target_type, public mixed $relation, public mixed $target, public mixed $ordering_key, public mixed $direction, public mixed $source_credit, public mixed $target_credit, public mixed $user_genre, public mixed $release, public mixed $title, public mixed $status, public mixed $quality, public mixed $packaging, public mixed $text_representation, public mixed $language, public mixed $script, public mixed $artist_credit, public mixed $release_group, public mixed $first_release_date, public mixed $primary_type, public mixed $secondary_type, public mixed $rating, public mixed $votes_count, public mixed $user_rating, public mixed $date, public mixed $release_event, public mixed $barcode, public mixed $asin, public mixed $cover_art_archive, public mixed $artwork, public mixed $front, public mixed $back, public mixed $darkened, public mixed $track_count, public mixed $medium, public mixed $track, public mixed $position, public mixed $number, public mixed $length, public mixed $recording, public mixed $video, public mixed $puid, public mixed $isrc, public mixed $format, public mixed $disc, public mixed $sectors, public mixed $pregap, public mixed $collection, public mixed $entity_type, public mixed $editor, public mixed $artist, public mixed $gender, public mixed $begin_area, public mixed $end_area, public mixed $work, public mixed $fluency, public mixed $iswc, public mixed $event, public mixed $cancelled, public mixed $time, public mixed $setlist, public mixed $instrument, public mixed $description, public mixed $place, public mixed $address, public mixed $coordinates, public mixed $latitude, public mixed $longitude, public mixed $series)
    {
    }
    public static function fromApiData(array $data): self
    {
        return new self(
            label_info: $data[&apos;label-info&apos;] ?? null,
            catalog_number: $data[&apos;catalog-number&apos;] ?? null,
            label: $data[&apos;label&apos;] ?? null,
            id: $data[&apos;id&apos;] ?? null,
            type: $data[&apos;type&apos;] ?? null,
            type_id: $data[&apos;type-id&apos;] ?? null,
            name: $data[&apos;name&apos;] ?? null,
            sort_name: $data[&apos;sort-name&apos;] ?? null,
            label_code: $data[&apos;label-code&apos;] ?? null,
            ipi: $data[&apos;ipi&apos;] ?? null,
            isni: $data[&apos;isni&apos;] ?? null,
            annotation: $data[&apos;annotation&apos;] ?? null,
            text: $data[&apos;text&apos;] ?? null,
            entity: $data[&apos;entity&apos;] ?? null,
            disambiguation: $data[&apos;disambiguation&apos;] ?? null,
            country: $data[&apos;country&apos;] ?? null,
            area: $data[&apos;area&apos;] ?? null,
            iso_3166_1_code: $data[&apos;iso-3166-1-code&apos;] ?? null,
            iso_3166_2_code: $data[&apos;iso-3166-2-code&apos;] ?? null,
            iso_3166_3_code: $data[&apos;iso-3166-3-code&apos;] ?? null,
            life_span: $data[&apos;life-span&apos;] ?? null,
            begin: $data[&apos;begin&apos;] ?? null,
            end: $data[&apos;end&apos;] ?? null,
            ended: $data[&apos;ended&apos;] ?? null,
            count: $data[&apos;count&apos;] ?? null,
            offset: $data[&apos;offset&apos;] ?? null,
            alias: $data[&apos;alias&apos;] ?? null,
            locale: $data[&apos;locale&apos;] ?? null,
            primary: $data[&apos;primary&apos;] ?? null,
            begin_date: $data[&apos;begin-date&apos;] ?? null,
            end_date: $data[&apos;end-date&apos;] ?? null,
            tag: $data[&apos;tag&apos;] ?? null,
            user_tag: $data[&apos;user-tag&apos;] ?? null,
            genre: $data[&apos;genre&apos;] ?? null,
            target_type: $data[&apos;target-type&apos;] ?? null,
            relation: $data[&apos;relation&apos;] ?? null,
            target: $data[&apos;target&apos;] ?? null,
            ordering_key: $data[&apos;ordering-key&apos;] ?? null,
            direction: $data[&apos;direction&apos;] ?? null,
            source_credit: $data[&apos;source-credit&apos;] ?? null,
            target_credit: $data[&apos;target-credit&apos;] ?? null,
            user_genre: $data[&apos;user-genre&apos;] ?? null,
            release: $data[&apos;release&apos;] ?? null,
            title: $data[&apos;title&apos;] ?? null,
            status: $data[&apos;status&apos;] ?? null,
            quality: $data[&apos;quality&apos;] ?? null,
            packaging: $data[&apos;packaging&apos;] ?? null,
            text_representation: $data[&apos;text-representation&apos;] ?? null,
            language: $data[&apos;language&apos;] ?? null,
            script: $data[&apos;script&apos;] ?? null,
            artist_credit: $data[&apos;artist-credit&apos;] ?? null,
            release_group: $data[&apos;release-group&apos;] ?? null,
            first_release_date: $data[&apos;first-release-date&apos;] ?? null,
            primary_type: $data[&apos;primary-type&apos;] ?? null,
            secondary_type: $data[&apos;secondary-type&apos;] ?? null,
            rating: $data[&apos;rating&apos;] ?? null,
            votes_count: $data[&apos;votes-count&apos;] ?? null,
            user_rating: $data[&apos;user-rating&apos;] ?? null,
            date: $data[&apos;date&apos;] ?? null,
            release_event: $data[&apos;release-event&apos;] ?? null,
            barcode: $data[&apos;barcode&apos;] ?? null,
            asin: $data[&apos;asin&apos;] ?? null,
            cover_art_archive: $data[&apos;cover-art-archive&apos;] ?? null,
            artwork: $data[&apos;artwork&apos;] ?? null,
            front: $data[&apos;front&apos;] ?? null,
            back: $data[&apos;back&apos;] ?? null,
            darkened: $data[&apos;darkened&apos;] ?? null,
            track_count: $data[&apos;track-count&apos;] ?? null,
            medium: $data[&apos;medium&apos;] ?? null,
            track: $data[&apos;track&apos;] ?? null,
            position: $data[&apos;position&apos;] ?? null,
            number: $data[&apos;number&apos;] ?? null,
            length: $data[&apos;length&apos;] ?? null,
            recording: $data[&apos;recording&apos;] ?? null,
            video: $data[&apos;video&apos;] ?? null,
            puid: $data[&apos;puid&apos;] ?? null,
            isrc: $data[&apos;isrc&apos;] ?? null,
            format: $data[&apos;format&apos;] ?? null,
            disc: $data[&apos;disc&apos;] ?? null,
            sectors: $data[&apos;sectors&apos;] ?? null,
            pregap: $data[&apos;pregap&apos;] ?? null,
            collection: $data[&apos;collection&apos;] ?? null,
            entity_type: $data[&apos;entity-type&apos;] ?? null,
            editor: $data[&apos;editor&apos;] ?? null,
            artist: $data[&apos;artist&apos;] ?? null,
            gender: $data[&apos;gender&apos;] ?? null,
            begin_area: $data[&apos;begin-area&apos;] ?? null,
            end_area: $data[&apos;end-area&apos;] ?? null,
            work: $data[&apos;work&apos;] ?? null,
            fluency: $data[&apos;fluency&apos;] ?? null,
            iswc: $data[&apos;iswc&apos;] ?? null,
            event: $data[&apos;event&apos;] ?? null,
            cancelled: $data[&apos;cancelled&apos;] ?? null,
            time: $data[&apos;time&apos;] ?? null,
            setlist: $data[&apos;setlist&apos;] ?? null,
            instrument: $data[&apos;instrument&apos;] ?? null,
            description: $data[&apos;description&apos;] ?? null,
            place: $data[&apos;place&apos;] ?? null,
            address: $data[&apos;address&apos;] ?? null,
            coordinates: $data[&apos;coordinates&apos;] ?? null,
            latitude: $data[&apos;latitude&apos;] ?? null,
            longitude: $data[&apos;longitude&apos;] ?? null,
            series: $data[&apos;series&apos;] ?? null
        );
    }
}</file><file path="app/Http/Integrations/MusicBrainz/Models/LabelInfoList.php">&lt;?php
namespace App\Http\Integrations\MusicBrainz\Models;
use Spatie\LaravelData\Data;
class LabelInfoList extends Data
{
    public function __construct(public mixed $count, public mixed $offset, public mixed $label_info, public mixed $catalog_number, public mixed $label, public mixed $id, public mixed $type, public mixed $type_id, public mixed $name, public mixed $sort_name, public mixed $label_code, public mixed $ipi, public mixed $isni, public mixed $annotation, public mixed $text, public mixed $entity, public mixed $disambiguation, public mixed $country, public mixed $area, public mixed $iso_3166_1_code, public mixed $iso_3166_2_code, public mixed $iso_3166_3_code, public mixed $life_span, public mixed $begin, public mixed $end, public mixed $ended, public mixed $alias, public mixed $locale, public mixed $primary, public mixed $begin_date, public mixed $end_date, public mixed $tag, public mixed $user_tag, public mixed $genre, public mixed $target_type, public mixed $relation, public mixed $target, public mixed $ordering_key, public mixed $direction, public mixed $source_credit, public mixed $target_credit, public mixed $user_genre, public mixed $release, public mixed $title, public mixed $status, public mixed $quality, public mixed $packaging, public mixed $text_representation, public mixed $language, public mixed $script, public mixed $artist_credit, public mixed $release_group, public mixed $first_release_date, public mixed $primary_type, public mixed $secondary_type, public mixed $rating, public mixed $votes_count, public mixed $user_rating, public mixed $date, public mixed $release_event, public mixed $barcode, public mixed $asin, public mixed $cover_art_archive, public mixed $artwork, public mixed $front, public mixed $back, public mixed $darkened, public mixed $track_count, public mixed $medium, public mixed $track, public mixed $position, public mixed $number, public mixed $length, public mixed $recording, public mixed $video, public mixed $puid, public mixed $isrc, public mixed $format, public mixed $disc, public mixed $sectors, public mixed $pregap, public mixed $collection, public mixed $entity_type, public mixed $editor, public mixed $artist, public mixed $gender, public mixed $begin_area, public mixed $end_area, public mixed $work, public mixed $fluency, public mixed $iswc, public mixed $event, public mixed $cancelled, public mixed $time, public mixed $setlist, public mixed $instrument, public mixed $description, public mixed $place, public mixed $address, public mixed $coordinates, public mixed $latitude, public mixed $longitude, public mixed $series)
    {
    }
    public static function fromApiData(array $data): self
    {
        return new self(
            count: $data[&apos;count&apos;] ?? null,
            offset: $data[&apos;offset&apos;] ?? null,
            label_info: $data[&apos;label-info&apos;] ?? null,
            catalog_number: $data[&apos;catalog-number&apos;] ?? null,
            label: $data[&apos;label&apos;] ?? null,
            id: $data[&apos;id&apos;] ?? null,
            type: $data[&apos;type&apos;] ?? null,
            type_id: $data[&apos;type-id&apos;] ?? null,
            name: $data[&apos;name&apos;] ?? null,
            sort_name: $data[&apos;sort-name&apos;] ?? null,
            label_code: $data[&apos;label-code&apos;] ?? null,
            ipi: $data[&apos;ipi&apos;] ?? null,
            isni: $data[&apos;isni&apos;] ?? null,
            annotation: $data[&apos;annotation&apos;] ?? null,
            text: $data[&apos;text&apos;] ?? null,
            entity: $data[&apos;entity&apos;] ?? null,
            disambiguation: $data[&apos;disambiguation&apos;] ?? null,
            country: $data[&apos;country&apos;] ?? null,
            area: $data[&apos;area&apos;] ?? null,
            iso_3166_1_code: $data[&apos;iso-3166-1-code&apos;] ?? null,
            iso_3166_2_code: $data[&apos;iso-3166-2-code&apos;] ?? null,
            iso_3166_3_code: $data[&apos;iso-3166-3-code&apos;] ?? null,
            life_span: $data[&apos;life-span&apos;] ?? null,
            begin: $data[&apos;begin&apos;] ?? null,
            end: $data[&apos;end&apos;] ?? null,
            ended: $data[&apos;ended&apos;] ?? null,
            alias: $data[&apos;alias&apos;] ?? null,
            locale: $data[&apos;locale&apos;] ?? null,
            primary: $data[&apos;primary&apos;] ?? null,
            begin_date: $data[&apos;begin-date&apos;] ?? null,
            end_date: $data[&apos;end-date&apos;] ?? null,
            tag: $data[&apos;tag&apos;] ?? null,
            user_tag: $data[&apos;user-tag&apos;] ?? null,
            genre: $data[&apos;genre&apos;] ?? null,
            target_type: $data[&apos;target-type&apos;] ?? null,
            relation: $data[&apos;relation&apos;] ?? null,
            target: $data[&apos;target&apos;] ?? null,
            ordering_key: $data[&apos;ordering-key&apos;] ?? null,
            direction: $data[&apos;direction&apos;] ?? null,
            source_credit: $data[&apos;source-credit&apos;] ?? null,
            target_credit: $data[&apos;target-credit&apos;] ?? null,
            user_genre: $data[&apos;user-genre&apos;] ?? null,
            release: $data[&apos;release&apos;] ?? null,
            title: $data[&apos;title&apos;] ?? null,
            status: $data[&apos;status&apos;] ?? null,
            quality: $data[&apos;quality&apos;] ?? null,
            packaging: $data[&apos;packaging&apos;] ?? null,
            text_representation: $data[&apos;text-representation&apos;] ?? null,
            language: $data[&apos;language&apos;] ?? null,
            script: $data[&apos;script&apos;] ?? null,
            artist_credit: $data[&apos;artist-credit&apos;] ?? null,
            release_group: $data[&apos;release-group&apos;] ?? null,
            first_release_date: $data[&apos;first-release-date&apos;] ?? null,
            primary_type: $data[&apos;primary-type&apos;] ?? null,
            secondary_type: $data[&apos;secondary-type&apos;] ?? null,
            rating: $data[&apos;rating&apos;] ?? null,
            votes_count: $data[&apos;votes-count&apos;] ?? null,
            user_rating: $data[&apos;user-rating&apos;] ?? null,
            date: $data[&apos;date&apos;] ?? null,
            release_event: $data[&apos;release-event&apos;] ?? null,
            barcode: $data[&apos;barcode&apos;] ?? null,
            asin: $data[&apos;asin&apos;] ?? null,
            cover_art_archive: $data[&apos;cover-art-archive&apos;] ?? null,
            artwork: $data[&apos;artwork&apos;] ?? null,
            front: $data[&apos;front&apos;] ?? null,
            back: $data[&apos;back&apos;] ?? null,
            darkened: $data[&apos;darkened&apos;] ?? null,
            track_count: $data[&apos;track-count&apos;] ?? null,
            medium: $data[&apos;medium&apos;] ?? null,
            track: $data[&apos;track&apos;] ?? null,
            position: $data[&apos;position&apos;] ?? null,
            number: $data[&apos;number&apos;] ?? null,
            length: $data[&apos;length&apos;] ?? null,
            recording: $data[&apos;recording&apos;] ?? null,
            video: $data[&apos;video&apos;] ?? null,
            puid: $data[&apos;puid&apos;] ?? null,
            isrc: $data[&apos;isrc&apos;] ?? null,
            format: $data[&apos;format&apos;] ?? null,
            disc: $data[&apos;disc&apos;] ?? null,
            sectors: $data[&apos;sectors&apos;] ?? null,
            pregap: $data[&apos;pregap&apos;] ?? null,
            collection: $data[&apos;collection&apos;] ?? null,
            entity_type: $data[&apos;entity-type&apos;] ?? null,
            editor: $data[&apos;editor&apos;] ?? null,
            artist: $data[&apos;artist&apos;] ?? null,
            gender: $data[&apos;gender&apos;] ?? null,
            begin_area: $data[&apos;begin-area&apos;] ?? null,
            end_area: $data[&apos;end-area&apos;] ?? null,
            work: $data[&apos;work&apos;] ?? null,
            fluency: $data[&apos;fluency&apos;] ?? null,
            iswc: $data[&apos;iswc&apos;] ?? null,
            event: $data[&apos;event&apos;] ?? null,
            cancelled: $data[&apos;cancelled&apos;] ?? null,
            time: $data[&apos;time&apos;] ?? null,
            setlist: $data[&apos;setlist&apos;] ?? null,
            instrument: $data[&apos;instrument&apos;] ?? null,
            description: $data[&apos;description&apos;] ?? null,
            place: $data[&apos;place&apos;] ?? null,
            address: $data[&apos;address&apos;] ?? null,
            coordinates: $data[&apos;coordinates&apos;] ?? null,
            latitude: $data[&apos;latitude&apos;] ?? null,
            longitude: $data[&apos;longitude&apos;] ?? null,
            series: $data[&apos;series&apos;] ?? null
        );
    }
}</file><file path="app/Http/Integrations/MusicBrainz/Models/LabelList.php">&lt;?php
namespace App\Http\Integrations\MusicBrainz\Models;
use Spatie\LaravelData\Data;
class LabelList extends Data
{
    public function __construct(public mixed $count, public mixed $offset, public mixed $label, public mixed $id, public mixed $type, public mixed $type_id, public mixed $name, public mixed $sort_name, public mixed $label_code, public mixed $ipi, public mixed $isni, public mixed $annotation, public mixed $text, public mixed $entity, public mixed $disambiguation, public mixed $country, public mixed $area, public mixed $iso_3166_1_code, public mixed $iso_3166_2_code, public mixed $iso_3166_3_code, public mixed $life_span, public mixed $begin, public mixed $end, public mixed $ended, public mixed $alias, public mixed $locale, public mixed $primary, public mixed $begin_date, public mixed $end_date, public mixed $tag, public mixed $user_tag, public mixed $genre, public mixed $target_type, public mixed $relation, public mixed $target, public mixed $ordering_key, public mixed $direction, public mixed $source_credit, public mixed $target_credit, public mixed $user_genre, public mixed $release, public mixed $title, public mixed $status, public mixed $quality, public mixed $packaging, public mixed $text_representation, public mixed $language, public mixed $script, public mixed $artist_credit, public mixed $release_group, public mixed $first_release_date, public mixed $primary_type, public mixed $secondary_type, public mixed $rating, public mixed $votes_count, public mixed $user_rating, public mixed $date, public mixed $release_event, public mixed $barcode, public mixed $asin, public mixed $cover_art_archive, public mixed $artwork, public mixed $front, public mixed $back, public mixed $darkened, public mixed $label_info, public mixed $catalog_number, public mixed $track_count, public mixed $medium, public mixed $track, public mixed $position, public mixed $number, public mixed $length, public mixed $recording, public mixed $video, public mixed $puid, public mixed $isrc, public mixed $format, public mixed $disc, public mixed $sectors, public mixed $pregap, public mixed $collection, public mixed $entity_type, public mixed $editor, public mixed $artist, public mixed $gender, public mixed $begin_area, public mixed $end_area, public mixed $work, public mixed $fluency, public mixed $iswc, public mixed $event, public mixed $cancelled, public mixed $time, public mixed $setlist, public mixed $instrument, public mixed $description, public mixed $place, public mixed $address, public mixed $coordinates, public mixed $latitude, public mixed $longitude, public mixed $series)
    {
    }
    public static function fromApiData(array $data): self
    {
        return new self(
            count: $data[&apos;count&apos;] ?? null,
            offset: $data[&apos;offset&apos;] ?? null,
            label: $data[&apos;label&apos;] ?? null,
            id: $data[&apos;id&apos;] ?? null,
            type: $data[&apos;type&apos;] ?? null,
            type_id: $data[&apos;type-id&apos;] ?? null,
            name: $data[&apos;name&apos;] ?? null,
            sort_name: $data[&apos;sort-name&apos;] ?? null,
            label_code: $data[&apos;label-code&apos;] ?? null,
            ipi: $data[&apos;ipi&apos;] ?? null,
            isni: $data[&apos;isni&apos;] ?? null,
            annotation: $data[&apos;annotation&apos;] ?? null,
            text: $data[&apos;text&apos;] ?? null,
            entity: $data[&apos;entity&apos;] ?? null,
            disambiguation: $data[&apos;disambiguation&apos;] ?? null,
            country: $data[&apos;country&apos;] ?? null,
            area: $data[&apos;area&apos;] ?? null,
            iso_3166_1_code: $data[&apos;iso-3166-1-code&apos;] ?? null,
            iso_3166_2_code: $data[&apos;iso-3166-2-code&apos;] ?? null,
            iso_3166_3_code: $data[&apos;iso-3166-3-code&apos;] ?? null,
            life_span: $data[&apos;life-span&apos;] ?? null,
            begin: $data[&apos;begin&apos;] ?? null,
            end: $data[&apos;end&apos;] ?? null,
            ended: $data[&apos;ended&apos;] ?? null,
            alias: $data[&apos;alias&apos;] ?? null,
            locale: $data[&apos;locale&apos;] ?? null,
            primary: $data[&apos;primary&apos;] ?? null,
            begin_date: $data[&apos;begin-date&apos;] ?? null,
            end_date: $data[&apos;end-date&apos;] ?? null,
            tag: $data[&apos;tag&apos;] ?? null,
            user_tag: $data[&apos;user-tag&apos;] ?? null,
            genre: $data[&apos;genre&apos;] ?? null,
            target_type: $data[&apos;target-type&apos;] ?? null,
            relation: $data[&apos;relation&apos;] ?? null,
            target: $data[&apos;target&apos;] ?? null,
            ordering_key: $data[&apos;ordering-key&apos;] ?? null,
            direction: $data[&apos;direction&apos;] ?? null,
            source_credit: $data[&apos;source-credit&apos;] ?? null,
            target_credit: $data[&apos;target-credit&apos;] ?? null,
            user_genre: $data[&apos;user-genre&apos;] ?? null,
            release: $data[&apos;release&apos;] ?? null,
            title: $data[&apos;title&apos;] ?? null,
            status: $data[&apos;status&apos;] ?? null,
            quality: $data[&apos;quality&apos;] ?? null,
            packaging: $data[&apos;packaging&apos;] ?? null,
            text_representation: $data[&apos;text-representation&apos;] ?? null,
            language: $data[&apos;language&apos;] ?? null,
            script: $data[&apos;script&apos;] ?? null,
            artist_credit: $data[&apos;artist-credit&apos;] ?? null,
            release_group: $data[&apos;release-group&apos;] ?? null,
            first_release_date: $data[&apos;first-release-date&apos;] ?? null,
            primary_type: $data[&apos;primary-type&apos;] ?? null,
            secondary_type: $data[&apos;secondary-type&apos;] ?? null,
            rating: $data[&apos;rating&apos;] ?? null,
            votes_count: $data[&apos;votes-count&apos;] ?? null,
            user_rating: $data[&apos;user-rating&apos;] ?? null,
            date: $data[&apos;date&apos;] ?? null,
            release_event: $data[&apos;release-event&apos;] ?? null,
            barcode: $data[&apos;barcode&apos;] ?? null,
            asin: $data[&apos;asin&apos;] ?? null,
            cover_art_archive: $data[&apos;cover-art-archive&apos;] ?? null,
            artwork: $data[&apos;artwork&apos;] ?? null,
            front: $data[&apos;front&apos;] ?? null,
            back: $data[&apos;back&apos;] ?? null,
            darkened: $data[&apos;darkened&apos;] ?? null,
            label_info: $data[&apos;label-info&apos;] ?? null,
            catalog_number: $data[&apos;catalog-number&apos;] ?? null,
            track_count: $data[&apos;track-count&apos;] ?? null,
            medium: $data[&apos;medium&apos;] ?? null,
            track: $data[&apos;track&apos;] ?? null,
            position: $data[&apos;position&apos;] ?? null,
            number: $data[&apos;number&apos;] ?? null,
            length: $data[&apos;length&apos;] ?? null,
            recording: $data[&apos;recording&apos;] ?? null,
            video: $data[&apos;video&apos;] ?? null,
            puid: $data[&apos;puid&apos;] ?? null,
            isrc: $data[&apos;isrc&apos;] ?? null,
            format: $data[&apos;format&apos;] ?? null,
            disc: $data[&apos;disc&apos;] ?? null,
            sectors: $data[&apos;sectors&apos;] ?? null,
            pregap: $data[&apos;pregap&apos;] ?? null,
            collection: $data[&apos;collection&apos;] ?? null,
            entity_type: $data[&apos;entity-type&apos;] ?? null,
            editor: $data[&apos;editor&apos;] ?? null,
            artist: $data[&apos;artist&apos;] ?? null,
            gender: $data[&apos;gender&apos;] ?? null,
            begin_area: $data[&apos;begin-area&apos;] ?? null,
            end_area: $data[&apos;end-area&apos;] ?? null,
            work: $data[&apos;work&apos;] ?? null,
            fluency: $data[&apos;fluency&apos;] ?? null,
            iswc: $data[&apos;iswc&apos;] ?? null,
            event: $data[&apos;event&apos;] ?? null,
            cancelled: $data[&apos;cancelled&apos;] ?? null,
            time: $data[&apos;time&apos;] ?? null,
            setlist: $data[&apos;setlist&apos;] ?? null,
            instrument: $data[&apos;instrument&apos;] ?? null,
            description: $data[&apos;description&apos;] ?? null,
            place: $data[&apos;place&apos;] ?? null,
            address: $data[&apos;address&apos;] ?? null,
            coordinates: $data[&apos;coordinates&apos;] ?? null,
            latitude: $data[&apos;latitude&apos;] ?? null,
            longitude: $data[&apos;longitude&apos;] ?? null,
            series: $data[&apos;series&apos;] ?? null
        );
    }
}</file><file path="app/Http/Integrations/MusicBrainz/Models/LanguageList.php">&lt;?php
namespace App\Http\Integrations\MusicBrainz\Models;
use Spatie\LaravelData\Data;
class LanguageList extends Data
{
    public function __construct(public mixed $count, public mixed $offset, public mixed $language, public mixed $fluency)
    {
    }
    public static function fromApiData(array $data): self
    {
        return new self(
            count: $data[&apos;count&apos;] ?? null,
            offset: $data[&apos;offset&apos;] ?? null,
            language: $data[&apos;language&apos;] ?? null,
            fluency: $data[&apos;fluency&apos;] ?? null
        );
    }
}</file><file path="app/Http/Integrations/MusicBrainz/Models/ListAttributes.php">&lt;?php
namespace App\Http\Integrations\MusicBrainz\Models;
use Spatie\LaravelData\Data;
class ListAttributes extends Data
{
    public function __construct(public mixed $count, public mixed $offset)
    {
    }
    public static function fromApiData(array $data): self
    {
        return new self(
            count: $data[&apos;count&apos;] ?? null,
            offset: $data[&apos;offset&apos;] ?? null
        );
    }
}</file><file path="app/Http/Integrations/MusicBrainz/Models/Medium.php">&lt;?php
namespace App\Http\Integrations\MusicBrainz\Models;
use Spatie\LaravelData\Data;
class Medium extends Data
{
    public function __construct(public mixed $count, public mixed $offset, public mixed $track, public mixed $id, public mixed $position, public mixed $number, public mixed $title, public mixed $length, public mixed $artist_credit, public mixed $recording, public mixed $annotation, public mixed $text, public mixed $type, public mixed $entity, public mixed $name, public mixed $disambiguation, public mixed $video, public mixed $first_release_date, public mixed $release, public mixed $status, public mixed $quality, public mixed $packaging, public mixed $text_representation, public mixed $language, public mixed $script, public mixed $alias, public mixed $locale, public mixed $sort_name, public mixed $type_id, public mixed $primary, public mixed $begin_date, public mixed $end_date, public mixed $release_group, public mixed $primary_type, public mixed $secondary_type, public mixed $tag, public mixed $user_tag, public mixed $genre, public mixed $target_type, public mixed $relation, public mixed $target, public mixed $ordering_key, public mixed $direction, public mixed $begin, public mixed $end, public mixed $ended, public mixed $source_credit, public mixed $target_credit, public mixed $user_genre, public mixed $rating, public mixed $votes_count, public mixed $user_rating, public mixed $date, public mixed $country, public mixed $release_event, public mixed $area, public mixed $iso_3166_1_code, public mixed $iso_3166_2_code, public mixed $iso_3166_3_code, public mixed $life_span, public mixed $barcode, public mixed $asin, public mixed $cover_art_archive, public mixed $artwork, public mixed $front, public mixed $back, public mixed $darkened, public mixed $label_info, public mixed $catalog_number, public mixed $label, public mixed $label_code, public mixed $ipi, public mixed $isni, public mixed $track_count, public mixed $format, public mixed $disc, public mixed $sectors, public mixed $pregap, public mixed $collection, public mixed $entity_type, public mixed $editor, public mixed $artist, public mixed $gender, public mixed $begin_area, public mixed $end_area, public mixed $work, public mixed $fluency, public mixed $iswc, public mixed $event, public mixed $cancelled, public mixed $time, public mixed $setlist, public mixed $instrument, public mixed $description, public mixed $place, public mixed $address, public mixed $coordinates, public mixed $latitude, public mixed $longitude, public mixed $series, public mixed $puid, public mixed $isrc)
    {
    }
    public static function fromApiData(array $data): self
    {
        return new self(
            count: $data[&apos;count&apos;] ?? null,
            offset: $data[&apos;offset&apos;] ?? null,
            track: $data[&apos;track&apos;] ?? null,
            id: $data[&apos;id&apos;] ?? null,
            position: $data[&apos;position&apos;] ?? null,
            number: $data[&apos;number&apos;] ?? null,
            title: $data[&apos;title&apos;] ?? null,
            length: $data[&apos;length&apos;] ?? null,
            artist_credit: $data[&apos;artist-credit&apos;] ?? null,
            recording: $data[&apos;recording&apos;] ?? null,
            annotation: $data[&apos;annotation&apos;] ?? null,
            text: $data[&apos;text&apos;] ?? null,
            type: $data[&apos;type&apos;] ?? null,
            entity: $data[&apos;entity&apos;] ?? null,
            name: $data[&apos;name&apos;] ?? null,
            disambiguation: $data[&apos;disambiguation&apos;] ?? null,
            video: $data[&apos;video&apos;] ?? null,
            first_release_date: $data[&apos;first-release-date&apos;] ?? null,
            release: $data[&apos;release&apos;] ?? null,
            status: $data[&apos;status&apos;] ?? null,
            quality: $data[&apos;quality&apos;] ?? null,
            packaging: $data[&apos;packaging&apos;] ?? null,
            text_representation: $data[&apos;text-representation&apos;] ?? null,
            language: $data[&apos;language&apos;] ?? null,
            script: $data[&apos;script&apos;] ?? null,
            alias: $data[&apos;alias&apos;] ?? null,
            locale: $data[&apos;locale&apos;] ?? null,
            sort_name: $data[&apos;sort-name&apos;] ?? null,
            type_id: $data[&apos;type-id&apos;] ?? null,
            primary: $data[&apos;primary&apos;] ?? null,
            begin_date: $data[&apos;begin-date&apos;] ?? null,
            end_date: $data[&apos;end-date&apos;] ?? null,
            release_group: $data[&apos;release-group&apos;] ?? null,
            primary_type: $data[&apos;primary-type&apos;] ?? null,
            secondary_type: $data[&apos;secondary-type&apos;] ?? null,
            tag: $data[&apos;tag&apos;] ?? null,
            user_tag: $data[&apos;user-tag&apos;] ?? null,
            genre: $data[&apos;genre&apos;] ?? null,
            target_type: $data[&apos;target-type&apos;] ?? null,
            relation: $data[&apos;relation&apos;] ?? null,
            target: $data[&apos;target&apos;] ?? null,
            ordering_key: $data[&apos;ordering-key&apos;] ?? null,
            direction: $data[&apos;direction&apos;] ?? null,
            begin: $data[&apos;begin&apos;] ?? null,
            end: $data[&apos;end&apos;] ?? null,
            ended: $data[&apos;ended&apos;] ?? null,
            source_credit: $data[&apos;source-credit&apos;] ?? null,
            target_credit: $data[&apos;target-credit&apos;] ?? null,
            user_genre: $data[&apos;user-genre&apos;] ?? null,
            rating: $data[&apos;rating&apos;] ?? null,
            votes_count: $data[&apos;votes-count&apos;] ?? null,
            user_rating: $data[&apos;user-rating&apos;] ?? null,
            date: $data[&apos;date&apos;] ?? null,
            country: $data[&apos;country&apos;] ?? null,
            release_event: $data[&apos;release-event&apos;] ?? null,
            area: $data[&apos;area&apos;] ?? null,
            iso_3166_1_code: $data[&apos;iso-3166-1-code&apos;] ?? null,
            iso_3166_2_code: $data[&apos;iso-3166-2-code&apos;] ?? null,
            iso_3166_3_code: $data[&apos;iso-3166-3-code&apos;] ?? null,
            life_span: $data[&apos;life-span&apos;] ?? null,
            barcode: $data[&apos;barcode&apos;] ?? null,
            asin: $data[&apos;asin&apos;] ?? null,
            cover_art_archive: $data[&apos;cover-art-archive&apos;] ?? null,
            artwork: $data[&apos;artwork&apos;] ?? null,
            front: $data[&apos;front&apos;] ?? null,
            back: $data[&apos;back&apos;] ?? null,
            darkened: $data[&apos;darkened&apos;] ?? null,
            label_info: $data[&apos;label-info&apos;] ?? null,
            catalog_number: $data[&apos;catalog-number&apos;] ?? null,
            label: $data[&apos;label&apos;] ?? null,
            label_code: $data[&apos;label-code&apos;] ?? null,
            ipi: $data[&apos;ipi&apos;] ?? null,
            isni: $data[&apos;isni&apos;] ?? null,
            track_count: $data[&apos;track-count&apos;] ?? null,
            format: $data[&apos;format&apos;] ?? null,
            disc: $data[&apos;disc&apos;] ?? null,
            sectors: $data[&apos;sectors&apos;] ?? null,
            pregap: $data[&apos;pregap&apos;] ?? null,
            collection: $data[&apos;collection&apos;] ?? null,
            entity_type: $data[&apos;entity-type&apos;] ?? null,
            editor: $data[&apos;editor&apos;] ?? null,
            artist: $data[&apos;artist&apos;] ?? null,
            gender: $data[&apos;gender&apos;] ?? null,
            begin_area: $data[&apos;begin-area&apos;] ?? null,
            end_area: $data[&apos;end-area&apos;] ?? null,
            work: $data[&apos;work&apos;] ?? null,
            fluency: $data[&apos;fluency&apos;] ?? null,
            iswc: $data[&apos;iswc&apos;] ?? null,
            event: $data[&apos;event&apos;] ?? null,
            cancelled: $data[&apos;cancelled&apos;] ?? null,
            time: $data[&apos;time&apos;] ?? null,
            setlist: $data[&apos;setlist&apos;] ?? null,
            instrument: $data[&apos;instrument&apos;] ?? null,
            description: $data[&apos;description&apos;] ?? null,
            place: $data[&apos;place&apos;] ?? null,
            address: $data[&apos;address&apos;] ?? null,
            coordinates: $data[&apos;coordinates&apos;] ?? null,
            latitude: $data[&apos;latitude&apos;] ?? null,
            longitude: $data[&apos;longitude&apos;] ?? null,
            series: $data[&apos;series&apos;] ?? null,
            puid: $data[&apos;puid&apos;] ?? null,
            isrc: $data[&apos;isrc&apos;] ?? null
        );
    }
}</file><file path="app/Http/Integrations/MusicBrainz/Models/MediumList.php">&lt;?php
namespace App\Http\Integrations\MusicBrainz\Models;
use Spatie\LaravelData\Data;
class MediumList extends Data
{
    public function __construct(public mixed $count, public mixed $offset, public mixed $track_count, public mixed $medium, public mixed $track, public mixed $id, public mixed $position, public mixed $number, public mixed $title, public mixed $length, public mixed $artist_credit, public mixed $recording, public mixed $annotation, public mixed $text, public mixed $type, public mixed $entity, public mixed $name, public mixed $disambiguation, public mixed $video, public mixed $first_release_date, public mixed $release, public mixed $status, public mixed $quality, public mixed $packaging, public mixed $text_representation, public mixed $language, public mixed $script, public mixed $alias, public mixed $locale, public mixed $sort_name, public mixed $type_id, public mixed $primary, public mixed $begin_date, public mixed $end_date, public mixed $release_group, public mixed $primary_type, public mixed $secondary_type, public mixed $tag, public mixed $user_tag, public mixed $genre, public mixed $target_type, public mixed $relation, public mixed $target, public mixed $ordering_key, public mixed $direction, public mixed $begin, public mixed $end, public mixed $ended, public mixed $source_credit, public mixed $target_credit, public mixed $user_genre, public mixed $rating, public mixed $votes_count, public mixed $user_rating, public mixed $date, public mixed $country, public mixed $release_event, public mixed $area, public mixed $iso_3166_1_code, public mixed $iso_3166_2_code, public mixed $iso_3166_3_code, public mixed $life_span, public mixed $barcode, public mixed $asin, public mixed $cover_art_archive, public mixed $artwork, public mixed $front, public mixed $back, public mixed $darkened, public mixed $label_info, public mixed $catalog_number, public mixed $label, public mixed $label_code, public mixed $ipi, public mixed $isni, public mixed $collection, public mixed $entity_type, public mixed $editor, public mixed $artist, public mixed $gender, public mixed $begin_area, public mixed $end_area, public mixed $work, public mixed $fluency, public mixed $iswc, public mixed $event, public mixed $cancelled, public mixed $time, public mixed $setlist, public mixed $instrument, public mixed $description, public mixed $place, public mixed $address, public mixed $coordinates, public mixed $latitude, public mixed $longitude, public mixed $series, public mixed $puid, public mixed $isrc, public mixed $format, public mixed $disc, public mixed $sectors, public mixed $pregap)
    {
    }
    public static function fromApiData(array $data): self
    {
        return new self(
            count: $data[&apos;count&apos;] ?? null,
            offset: $data[&apos;offset&apos;] ?? null,
            track_count: $data[&apos;track-count&apos;] ?? null,
            medium: $data[&apos;medium&apos;] ?? null,
            track: $data[&apos;track&apos;] ?? null,
            id: $data[&apos;id&apos;] ?? null,
            position: $data[&apos;position&apos;] ?? null,
            number: $data[&apos;number&apos;] ?? null,
            title: $data[&apos;title&apos;] ?? null,
            length: $data[&apos;length&apos;] ?? null,
            artist_credit: $data[&apos;artist-credit&apos;] ?? null,
            recording: $data[&apos;recording&apos;] ?? null,
            annotation: $data[&apos;annotation&apos;] ?? null,
            text: $data[&apos;text&apos;] ?? null,
            type: $data[&apos;type&apos;] ?? null,
            entity: $data[&apos;entity&apos;] ?? null,
            name: $data[&apos;name&apos;] ?? null,
            disambiguation: $data[&apos;disambiguation&apos;] ?? null,
            video: $data[&apos;video&apos;] ?? null,
            first_release_date: $data[&apos;first-release-date&apos;] ?? null,
            release: $data[&apos;release&apos;] ?? null,
            status: $data[&apos;status&apos;] ?? null,
            quality: $data[&apos;quality&apos;] ?? null,
            packaging: $data[&apos;packaging&apos;] ?? null,
            text_representation: $data[&apos;text-representation&apos;] ?? null,
            language: $data[&apos;language&apos;] ?? null,
            script: $data[&apos;script&apos;] ?? null,
            alias: $data[&apos;alias&apos;] ?? null,
            locale: $data[&apos;locale&apos;] ?? null,
            sort_name: $data[&apos;sort-name&apos;] ?? null,
            type_id: $data[&apos;type-id&apos;] ?? null,
            primary: $data[&apos;primary&apos;] ?? null,
            begin_date: $data[&apos;begin-date&apos;] ?? null,
            end_date: $data[&apos;end-date&apos;] ?? null,
            release_group: $data[&apos;release-group&apos;] ?? null,
            primary_type: $data[&apos;primary-type&apos;] ?? null,
            secondary_type: $data[&apos;secondary-type&apos;] ?? null,
            tag: $data[&apos;tag&apos;] ?? null,
            user_tag: $data[&apos;user-tag&apos;] ?? null,
            genre: $data[&apos;genre&apos;] ?? null,
            target_type: $data[&apos;target-type&apos;] ?? null,
            relation: $data[&apos;relation&apos;] ?? null,
            target: $data[&apos;target&apos;] ?? null,
            ordering_key: $data[&apos;ordering-key&apos;] ?? null,
            direction: $data[&apos;direction&apos;] ?? null,
            begin: $data[&apos;begin&apos;] ?? null,
            end: $data[&apos;end&apos;] ?? null,
            ended: $data[&apos;ended&apos;] ?? null,
            source_credit: $data[&apos;source-credit&apos;] ?? null,
            target_credit: $data[&apos;target-credit&apos;] ?? null,
            user_genre: $data[&apos;user-genre&apos;] ?? null,
            rating: $data[&apos;rating&apos;] ?? null,
            votes_count: $data[&apos;votes-count&apos;] ?? null,
            user_rating: $data[&apos;user-rating&apos;] ?? null,
            date: $data[&apos;date&apos;] ?? null,
            country: $data[&apos;country&apos;] ?? null,
            release_event: $data[&apos;release-event&apos;] ?? null,
            area: $data[&apos;area&apos;] ?? null,
            iso_3166_1_code: $data[&apos;iso-3166-1-code&apos;] ?? null,
            iso_3166_2_code: $data[&apos;iso-3166-2-code&apos;] ?? null,
            iso_3166_3_code: $data[&apos;iso-3166-3-code&apos;] ?? null,
            life_span: $data[&apos;life-span&apos;] ?? null,
            barcode: $data[&apos;barcode&apos;] ?? null,
            asin: $data[&apos;asin&apos;] ?? null,
            cover_art_archive: $data[&apos;cover-art-archive&apos;] ?? null,
            artwork: $data[&apos;artwork&apos;] ?? null,
            front: $data[&apos;front&apos;] ?? null,
            back: $data[&apos;back&apos;] ?? null,
            darkened: $data[&apos;darkened&apos;] ?? null,
            label_info: $data[&apos;label-info&apos;] ?? null,
            catalog_number: $data[&apos;catalog-number&apos;] ?? null,
            label: $data[&apos;label&apos;] ?? null,
            label_code: $data[&apos;label-code&apos;] ?? null,
            ipi: $data[&apos;ipi&apos;] ?? null,
            isni: $data[&apos;isni&apos;] ?? null,
            collection: $data[&apos;collection&apos;] ?? null,
            entity_type: $data[&apos;entity-type&apos;] ?? null,
            editor: $data[&apos;editor&apos;] ?? null,
            artist: $data[&apos;artist&apos;] ?? null,
            gender: $data[&apos;gender&apos;] ?? null,
            begin_area: $data[&apos;begin-area&apos;] ?? null,
            end_area: $data[&apos;end-area&apos;] ?? null,
            work: $data[&apos;work&apos;] ?? null,
            fluency: $data[&apos;fluency&apos;] ?? null,
            iswc: $data[&apos;iswc&apos;] ?? null,
            event: $data[&apos;event&apos;] ?? null,
            cancelled: $data[&apos;cancelled&apos;] ?? null,
            time: $data[&apos;time&apos;] ?? null,
            setlist: $data[&apos;setlist&apos;] ?? null,
            instrument: $data[&apos;instrument&apos;] ?? null,
            description: $data[&apos;description&apos;] ?? null,
            place: $data[&apos;place&apos;] ?? null,
            address: $data[&apos;address&apos;] ?? null,
            coordinates: $data[&apos;coordinates&apos;] ?? null,
            latitude: $data[&apos;latitude&apos;] ?? null,
            longitude: $data[&apos;longitude&apos;] ?? null,
            series: $data[&apos;series&apos;] ?? null,
            puid: $data[&apos;puid&apos;] ?? null,
            isrc: $data[&apos;isrc&apos;] ?? null,
            format: $data[&apos;format&apos;] ?? null,
            disc: $data[&apos;disc&apos;] ?? null,
            sectors: $data[&apos;sectors&apos;] ?? null,
            pregap: $data[&apos;pregap&apos;] ?? null
        );
    }
}</file><file path="app/Http/Integrations/MusicBrainz/Models/Metadata.php">&lt;?php
namespace App\Http\Integrations\MusicBrainz\Models;
use Spatie\LaravelData\Data;
class Metadata extends Data
{
    public function __construct(public mixed $metadata, public mixed $generator, public mixed $created, public mixed $artist, public mixed $id, public mixed $type, public mixed $type_id, public mixed $name, public mixed $sort_name, public mixed $gender, public mixed $country, public mixed $area, public mixed $disambiguation, public mixed $iso_3166_1_code, public mixed $iso_3166_2_code, public mixed $iso_3166_3_code, public mixed $annotation, public mixed $text, public mixed $entity, public mixed $life_span, public mixed $begin, public mixed $end, public mixed $ended, public mixed $count, public mixed $offset, public mixed $alias, public mixed $locale, public mixed $primary, public mixed $begin_date, public mixed $end_date, public mixed $tag, public mixed $user_tag, public mixed $genre, public mixed $target_type, public mixed $relation, public mixed $target, public mixed $ordering_key, public mixed $direction, public mixed $source_credit, public mixed $target_credit, public mixed $user_genre, public mixed $begin_area, public mixed $end_area, public mixed $ipi, public mixed $isni, public mixed $recording, public mixed $title, public mixed $length, public mixed $video, public mixed $artist_credit, public mixed $first_release_date, public mixed $release, public mixed $status, public mixed $quality, public mixed $packaging, public mixed $text_representation, public mixed $language, public mixed $script, public mixed $release_group, public mixed $primary_type, public mixed $secondary_type, public mixed $rating, public mixed $votes_count, public mixed $user_rating, public mixed $date, public mixed $release_event, public mixed $barcode, public mixed $asin, public mixed $cover_art_archive, public mixed $artwork, public mixed $front, public mixed $back, public mixed $darkened, public mixed $label_info, public mixed $catalog_number, public mixed $label, public mixed $label_code, public mixed $track_count, public mixed $medium, public mixed $track, public mixed $position, public mixed $number, public mixed $format, public mixed $disc, public mixed $sectors, public mixed $pregap, public mixed $collection, public mixed $entity_type, public mixed $editor, public mixed $event, public mixed $cancelled, public mixed $time, public mixed $setlist, public mixed $instrument, public mixed $description, public mixed $place, public mixed $address, public mixed $coordinates, public mixed $latitude, public mixed $longitude, public mixed $series, public mixed $work, public mixed $fluency, public mixed $iswc, public mixed $puid, public mixed $isrc, public mixed $url, public mixed $resource, public mixed $cdstub, public mixed $member_since, public mixed $privs, public mixed $age, public mixed $homepage, public mixed $bio, public mixed $edit_information, public mixed $edits_accepted, public mixed $edits_rejected, public mixed $auto_edits_accepted, public mixed $edits_failed, public mixed $freedb_disc, public mixed $category, public mixed $year, public mixed $edit_note)
    {
    }
    public static function fromApiData(array $data): self
    {
        return new self(
            metadata: $data[&apos;metadata&apos;] ?? null,
            generator: $data[&apos;generator&apos;] ?? null,
            created: $data[&apos;created&apos;] ?? null,
            artist: $data[&apos;artist&apos;] ?? null,
            id: $data[&apos;id&apos;] ?? null,
            type: $data[&apos;type&apos;] ?? null,
            type_id: $data[&apos;type-id&apos;] ?? null,
            name: $data[&apos;name&apos;] ?? null,
            sort_name: $data[&apos;sort-name&apos;] ?? null,
            gender: $data[&apos;gender&apos;] ?? null,
            country: $data[&apos;country&apos;] ?? null,
            area: $data[&apos;area&apos;] ?? null,
            disambiguation: $data[&apos;disambiguation&apos;] ?? null,
            iso_3166_1_code: $data[&apos;iso-3166-1-code&apos;] ?? null,
            iso_3166_2_code: $data[&apos;iso-3166-2-code&apos;] ?? null,
            iso_3166_3_code: $data[&apos;iso-3166-3-code&apos;] ?? null,
            annotation: $data[&apos;annotation&apos;] ?? null,
            text: $data[&apos;text&apos;] ?? null,
            entity: $data[&apos;entity&apos;] ?? null,
            life_span: $data[&apos;life-span&apos;] ?? null,
            begin: $data[&apos;begin&apos;] ?? null,
            end: $data[&apos;end&apos;] ?? null,
            ended: $data[&apos;ended&apos;] ?? null,
            count: $data[&apos;count&apos;] ?? null,
            offset: $data[&apos;offset&apos;] ?? null,
            alias: $data[&apos;alias&apos;] ?? null,
            locale: $data[&apos;locale&apos;] ?? null,
            primary: $data[&apos;primary&apos;] ?? null,
            begin_date: $data[&apos;begin-date&apos;] ?? null,
            end_date: $data[&apos;end-date&apos;] ?? null,
            tag: $data[&apos;tag&apos;] ?? null,
            user_tag: $data[&apos;user-tag&apos;] ?? null,
            genre: $data[&apos;genre&apos;] ?? null,
            target_type: $data[&apos;target-type&apos;] ?? null,
            relation: $data[&apos;relation&apos;] ?? null,
            target: $data[&apos;target&apos;] ?? null,
            ordering_key: $data[&apos;ordering-key&apos;] ?? null,
            direction: $data[&apos;direction&apos;] ?? null,
            source_credit: $data[&apos;source-credit&apos;] ?? null,
            target_credit: $data[&apos;target-credit&apos;] ?? null,
            user_genre: $data[&apos;user-genre&apos;] ?? null,
            begin_area: $data[&apos;begin-area&apos;] ?? null,
            end_area: $data[&apos;end-area&apos;] ?? null,
            ipi: $data[&apos;ipi&apos;] ?? null,
            isni: $data[&apos;isni&apos;] ?? null,
            recording: $data[&apos;recording&apos;] ?? null,
            title: $data[&apos;title&apos;] ?? null,
            length: $data[&apos;length&apos;] ?? null,
            video: $data[&apos;video&apos;] ?? null,
            artist_credit: $data[&apos;artist-credit&apos;] ?? null,
            first_release_date: $data[&apos;first-release-date&apos;] ?? null,
            release: $data[&apos;release&apos;] ?? null,
            status: $data[&apos;status&apos;] ?? null,
            quality: $data[&apos;quality&apos;] ?? null,
            packaging: $data[&apos;packaging&apos;] ?? null,
            text_representation: $data[&apos;text-representation&apos;] ?? null,
            language: $data[&apos;language&apos;] ?? null,
            script: $data[&apos;script&apos;] ?? null,
            release_group: $data[&apos;release-group&apos;] ?? null,
            primary_type: $data[&apos;primary-type&apos;] ?? null,
            secondary_type: $data[&apos;secondary-type&apos;] ?? null,
            rating: $data[&apos;rating&apos;] ?? null,
            votes_count: $data[&apos;votes-count&apos;] ?? null,
            user_rating: $data[&apos;user-rating&apos;] ?? null,
            date: $data[&apos;date&apos;] ?? null,
            release_event: $data[&apos;release-event&apos;] ?? null,
            barcode: $data[&apos;barcode&apos;] ?? null,
            asin: $data[&apos;asin&apos;] ?? null,
            cover_art_archive: $data[&apos;cover-art-archive&apos;] ?? null,
            artwork: $data[&apos;artwork&apos;] ?? null,
            front: $data[&apos;front&apos;] ?? null,
            back: $data[&apos;back&apos;] ?? null,
            darkened: $data[&apos;darkened&apos;] ?? null,
            label_info: $data[&apos;label-info&apos;] ?? null,
            catalog_number: $data[&apos;catalog-number&apos;] ?? null,
            label: $data[&apos;label&apos;] ?? null,
            label_code: $data[&apos;label-code&apos;] ?? null,
            track_count: $data[&apos;track-count&apos;] ?? null,
            medium: $data[&apos;medium&apos;] ?? null,
            track: $data[&apos;track&apos;] ?? null,
            position: $data[&apos;position&apos;] ?? null,
            number: $data[&apos;number&apos;] ?? null,
            format: $data[&apos;format&apos;] ?? null,
            disc: $data[&apos;disc&apos;] ?? null,
            sectors: $data[&apos;sectors&apos;] ?? null,
            pregap: $data[&apos;pregap&apos;] ?? null,
            collection: $data[&apos;collection&apos;] ?? null,
            entity_type: $data[&apos;entity-type&apos;] ?? null,
            editor: $data[&apos;editor&apos;] ?? null,
            event: $data[&apos;event&apos;] ?? null,
            cancelled: $data[&apos;cancelled&apos;] ?? null,
            time: $data[&apos;time&apos;] ?? null,
            setlist: $data[&apos;setlist&apos;] ?? null,
            instrument: $data[&apos;instrument&apos;] ?? null,
            description: $data[&apos;description&apos;] ?? null,
            place: $data[&apos;place&apos;] ?? null,
            address: $data[&apos;address&apos;] ?? null,
            coordinates: $data[&apos;coordinates&apos;] ?? null,
            latitude: $data[&apos;latitude&apos;] ?? null,
            longitude: $data[&apos;longitude&apos;] ?? null,
            series: $data[&apos;series&apos;] ?? null,
            work: $data[&apos;work&apos;] ?? null,
            fluency: $data[&apos;fluency&apos;] ?? null,
            iswc: $data[&apos;iswc&apos;] ?? null,
            puid: $data[&apos;puid&apos;] ?? null,
            isrc: $data[&apos;isrc&apos;] ?? null,
            url: $data[&apos;url&apos;] ?? null,
            resource: $data[&apos;resource&apos;] ?? null,
            cdstub: $data[&apos;cdstub&apos;] ?? null,
            member_since: $data[&apos;member-since&apos;] ?? null,
            privs: $data[&apos;privs&apos;] ?? null,
            age: $data[&apos;age&apos;] ?? null,
            homepage: $data[&apos;homepage&apos;] ?? null,
            bio: $data[&apos;bio&apos;] ?? null,
            edit_information: $data[&apos;edit-information&apos;] ?? null,
            edits_accepted: $data[&apos;edits-accepted&apos;] ?? null,
            edits_rejected: $data[&apos;edits-rejected&apos;] ?? null,
            auto_edits_accepted: $data[&apos;auto-edits-accepted&apos;] ?? null,
            edits_failed: $data[&apos;edits-failed&apos;] ?? null,
            freedb_disc: $data[&apos;freedb-disc&apos;] ?? null,
            category: $data[&apos;category&apos;] ?? null,
            year: $data[&apos;year&apos;] ?? null,
            edit_note: $data[&apos;edit-note&apos;] ?? null
        );
    }
}</file><file path="app/Http/Integrations/MusicBrainz/Models/NonmbTrack.php">&lt;?php
namespace App\Http\Integrations\MusicBrainz\Models;
use Spatie\LaravelData\Data;
class NonmbTrack extends Data
{
    public function __construct(public mixed $track, public mixed $title, public mixed $length, public mixed $artist)
    {
    }
    public static function fromApiData(array $data): self
    {
        return new self(
            track: $data[&apos;track&apos;] ?? null,
            title: $data[&apos;title&apos;] ?? null,
            length: $data[&apos;length&apos;] ?? null,
            artist: $data[&apos;artist&apos;] ?? null
        );
    }
}</file><file path="app/Http/Integrations/MusicBrainz/Models/NonmbTrackList.php">&lt;?php
namespace App\Http\Integrations\MusicBrainz\Models;
use Spatie\LaravelData\Data;
class NonmbTrackList extends Data
{
    public function __construct(public mixed $count, public mixed $offset, public mixed $track, public mixed $title, public mixed $length, public mixed $artist)
    {
    }
    public static function fromApiData(array $data): self
    {
        return new self(
            count: $data[&apos;count&apos;] ?? null,
            offset: $data[&apos;offset&apos;] ?? null,
            track: $data[&apos;track&apos;] ?? null,
            title: $data[&apos;title&apos;] ?? null,
            length: $data[&apos;length&apos;] ?? null,
            artist: $data[&apos;artist&apos;] ?? null
        );
    }
}</file><file path="app/Http/Integrations/MusicBrainz/Models/OffsetList.php">&lt;?php
namespace App\Http\Integrations\MusicBrainz\Models;
use Spatie\LaravelData\Data;
class OffsetList extends Data
{
    public function __construct(public mixed $count, public mixed $offset, public mixed $position)
    {
    }
    public static function fromApiData(array $data): self
    {
        return new self(
            count: $data[&apos;count&apos;] ?? null,
            offset: $data[&apos;offset&apos;] ?? null,
            position: $data[&apos;position&apos;] ?? null
        );
    }
}</file><file path="app/Http/Integrations/MusicBrainz/Models/Place.php">&lt;?php
namespace App\Http\Integrations\MusicBrainz\Models;
use Spatie\LaravelData\Data;
class Place extends Data
{
    public function __construct(public mixed $place, public mixed $id, public mixed $type, public mixed $type_id, public mixed $name, public mixed $disambiguation, public mixed $address, public mixed $coordinates, public mixed $latitude, public mixed $longitude, public mixed $annotation, public mixed $text, public mixed $entity, public mixed $area, public mixed $sort_name, public mixed $iso_3166_1_code, public mixed $iso_3166_2_code, public mixed $iso_3166_3_code, public mixed $life_span, public mixed $begin, public mixed $end, public mixed $ended, public mixed $count, public mixed $offset, public mixed $alias, public mixed $locale, public mixed $primary, public mixed $begin_date, public mixed $end_date, public mixed $tag, public mixed $user_tag, public mixed $genre, public mixed $target_type, public mixed $relation, public mixed $target, public mixed $ordering_key, public mixed $direction, public mixed $source_credit, public mixed $target_credit, public mixed $user_genre)
    {
    }
    public static function fromApiData(array $data): self
    {
        return new self(
            place: $data[&apos;place&apos;] ?? null,
            id: $data[&apos;id&apos;] ?? null,
            type: $data[&apos;type&apos;] ?? null,
            type_id: $data[&apos;type-id&apos;] ?? null,
            name: $data[&apos;name&apos;] ?? null,
            disambiguation: $data[&apos;disambiguation&apos;] ?? null,
            address: $data[&apos;address&apos;] ?? null,
            coordinates: $data[&apos;coordinates&apos;] ?? null,
            latitude: $data[&apos;latitude&apos;] ?? null,
            longitude: $data[&apos;longitude&apos;] ?? null,
            annotation: $data[&apos;annotation&apos;] ?? null,
            text: $data[&apos;text&apos;] ?? null,
            entity: $data[&apos;entity&apos;] ?? null,
            area: $data[&apos;area&apos;] ?? null,
            sort_name: $data[&apos;sort-name&apos;] ?? null,
            iso_3166_1_code: $data[&apos;iso-3166-1-code&apos;] ?? null,
            iso_3166_2_code: $data[&apos;iso-3166-2-code&apos;] ?? null,
            iso_3166_3_code: $data[&apos;iso-3166-3-code&apos;] ?? null,
            life_span: $data[&apos;life-span&apos;] ?? null,
            begin: $data[&apos;begin&apos;] ?? null,
            end: $data[&apos;end&apos;] ?? null,
            ended: $data[&apos;ended&apos;] ?? null,
            count: $data[&apos;count&apos;] ?? null,
            offset: $data[&apos;offset&apos;] ?? null,
            alias: $data[&apos;alias&apos;] ?? null,
            locale: $data[&apos;locale&apos;] ?? null,
            primary: $data[&apos;primary&apos;] ?? null,
            begin_date: $data[&apos;begin-date&apos;] ?? null,
            end_date: $data[&apos;end-date&apos;] ?? null,
            tag: $data[&apos;tag&apos;] ?? null,
            user_tag: $data[&apos;user-tag&apos;] ?? null,
            genre: $data[&apos;genre&apos;] ?? null,
            target_type: $data[&apos;target-type&apos;] ?? null,
            relation: $data[&apos;relation&apos;] ?? null,
            target: $data[&apos;target&apos;] ?? null,
            ordering_key: $data[&apos;ordering-key&apos;] ?? null,
            direction: $data[&apos;direction&apos;] ?? null,
            source_credit: $data[&apos;source-credit&apos;] ?? null,
            target_credit: $data[&apos;target-credit&apos;] ?? null,
            user_genre: $data[&apos;user-genre&apos;] ?? null
        );
    }
}</file><file path="app/Http/Integrations/MusicBrainz/Models/PlaceList.php">&lt;?php
namespace App\Http\Integrations\MusicBrainz\Models;
use Spatie\LaravelData\Data;
class PlaceList extends Data
{
    public function __construct(public mixed $count, public mixed $offset, public mixed $place, public mixed $id, public mixed $type, public mixed $type_id, public mixed $name, public mixed $disambiguation, public mixed $address, public mixed $coordinates, public mixed $latitude, public mixed $longitude, public mixed $annotation, public mixed $text, public mixed $entity, public mixed $area, public mixed $sort_name, public mixed $iso_3166_1_code, public mixed $iso_3166_2_code, public mixed $iso_3166_3_code, public mixed $life_span, public mixed $begin, public mixed $end, public mixed $ended, public mixed $alias, public mixed $locale, public mixed $primary, public mixed $begin_date, public mixed $end_date, public mixed $tag, public mixed $user_tag, public mixed $genre, public mixed $target_type, public mixed $relation, public mixed $target, public mixed $ordering_key, public mixed $direction, public mixed $source_credit, public mixed $target_credit, public mixed $user_genre)
    {
    }
    public static function fromApiData(array $data): self
    {
        return new self(
            count: $data[&apos;count&apos;] ?? null,
            offset: $data[&apos;offset&apos;] ?? null,
            place: $data[&apos;place&apos;] ?? null,
            id: $data[&apos;id&apos;] ?? null,
            type: $data[&apos;type&apos;] ?? null,
            type_id: $data[&apos;type-id&apos;] ?? null,
            name: $data[&apos;name&apos;] ?? null,
            disambiguation: $data[&apos;disambiguation&apos;] ?? null,
            address: $data[&apos;address&apos;] ?? null,
            coordinates: $data[&apos;coordinates&apos;] ?? null,
            latitude: $data[&apos;latitude&apos;] ?? null,
            longitude: $data[&apos;longitude&apos;] ?? null,
            annotation: $data[&apos;annotation&apos;] ?? null,
            text: $data[&apos;text&apos;] ?? null,
            entity: $data[&apos;entity&apos;] ?? null,
            area: $data[&apos;area&apos;] ?? null,
            sort_name: $data[&apos;sort-name&apos;] ?? null,
            iso_3166_1_code: $data[&apos;iso-3166-1-code&apos;] ?? null,
            iso_3166_2_code: $data[&apos;iso-3166-2-code&apos;] ?? null,
            iso_3166_3_code: $data[&apos;iso-3166-3-code&apos;] ?? null,
            life_span: $data[&apos;life-span&apos;] ?? null,
            begin: $data[&apos;begin&apos;] ?? null,
            end: $data[&apos;end&apos;] ?? null,
            ended: $data[&apos;ended&apos;] ?? null,
            alias: $data[&apos;alias&apos;] ?? null,
            locale: $data[&apos;locale&apos;] ?? null,
            primary: $data[&apos;primary&apos;] ?? null,
            begin_date: $data[&apos;begin-date&apos;] ?? null,
            end_date: $data[&apos;end-date&apos;] ?? null,
            tag: $data[&apos;tag&apos;] ?? null,
            user_tag: $data[&apos;user-tag&apos;] ?? null,
            genre: $data[&apos;genre&apos;] ?? null,
            target_type: $data[&apos;target-type&apos;] ?? null,
            relation: $data[&apos;relation&apos;] ?? null,
            target: $data[&apos;target&apos;] ?? null,
            ordering_key: $data[&apos;ordering-key&apos;] ?? null,
            direction: $data[&apos;direction&apos;] ?? null,
            source_credit: $data[&apos;source-credit&apos;] ?? null,
            target_credit: $data[&apos;target-credit&apos;] ?? null,
            user_genre: $data[&apos;user-genre&apos;] ?? null
        );
    }
}</file><file path="app/Http/Integrations/MusicBrainz/Models/PregapTrack.php">&lt;?php
namespace App\Http\Integrations\MusicBrainz\Models;
use Spatie\LaravelData\Data;
class PregapTrack extends Data
{
    public function __construct(public mixed $pregap, public mixed $id, public mixed $position, public mixed $number, public mixed $title, public mixed $length, public mixed $artist_credit, public mixed $recording, public mixed $annotation, public mixed $text, public mixed $type, public mixed $entity, public mixed $name, public mixed $disambiguation, public mixed $video, public mixed $first_release_date, public mixed $count, public mixed $offset, public mixed $release, public mixed $status, public mixed $quality, public mixed $packaging, public mixed $text_representation, public mixed $language, public mixed $script, public mixed $alias, public mixed $locale, public mixed $sort_name, public mixed $type_id, public mixed $primary, public mixed $begin_date, public mixed $end_date, public mixed $release_group, public mixed $primary_type, public mixed $secondary_type, public mixed $tag, public mixed $user_tag, public mixed $genre, public mixed $target_type, public mixed $relation, public mixed $target, public mixed $ordering_key, public mixed $direction, public mixed $begin, public mixed $end, public mixed $ended, public mixed $source_credit, public mixed $target_credit, public mixed $user_genre, public mixed $rating, public mixed $votes_count, public mixed $user_rating, public mixed $date, public mixed $country, public mixed $release_event, public mixed $area, public mixed $iso_3166_1_code, public mixed $iso_3166_2_code, public mixed $iso_3166_3_code, public mixed $life_span, public mixed $barcode, public mixed $asin, public mixed $cover_art_archive, public mixed $artwork, public mixed $front, public mixed $back, public mixed $darkened, public mixed $label_info, public mixed $catalog_number, public mixed $label, public mixed $label_code, public mixed $ipi, public mixed $isni, public mixed $track_count, public mixed $medium, public mixed $track, public mixed $format, public mixed $disc, public mixed $sectors, public mixed $collection, public mixed $entity_type, public mixed $editor, public mixed $artist, public mixed $gender, public mixed $begin_area, public mixed $end_area, public mixed $work, public mixed $fluency, public mixed $iswc, public mixed $event, public mixed $cancelled, public mixed $time, public mixed $setlist, public mixed $instrument, public mixed $description, public mixed $place, public mixed $address, public mixed $coordinates, public mixed $latitude, public mixed $longitude, public mixed $series, public mixed $puid, public mixed $isrc)
    {
    }
    public static function fromApiData(array $data): self
    {
        return new self(
            pregap: $data[&apos;pregap&apos;] ?? null,
            id: $data[&apos;id&apos;] ?? null,
            position: $data[&apos;position&apos;] ?? null,
            number: $data[&apos;number&apos;] ?? null,
            title: $data[&apos;title&apos;] ?? null,
            length: $data[&apos;length&apos;] ?? null,
            artist_credit: $data[&apos;artist-credit&apos;] ?? null,
            recording: $data[&apos;recording&apos;] ?? null,
            annotation: $data[&apos;annotation&apos;] ?? null,
            text: $data[&apos;text&apos;] ?? null,
            type: $data[&apos;type&apos;] ?? null,
            entity: $data[&apos;entity&apos;] ?? null,
            name: $data[&apos;name&apos;] ?? null,
            disambiguation: $data[&apos;disambiguation&apos;] ?? null,
            video: $data[&apos;video&apos;] ?? null,
            first_release_date: $data[&apos;first-release-date&apos;] ?? null,
            count: $data[&apos;count&apos;] ?? null,
            offset: $data[&apos;offset&apos;] ?? null,
            release: $data[&apos;release&apos;] ?? null,
            status: $data[&apos;status&apos;] ?? null,
            quality: $data[&apos;quality&apos;] ?? null,
            packaging: $data[&apos;packaging&apos;] ?? null,
            text_representation: $data[&apos;text-representation&apos;] ?? null,
            language: $data[&apos;language&apos;] ?? null,
            script: $data[&apos;script&apos;] ?? null,
            alias: $data[&apos;alias&apos;] ?? null,
            locale: $data[&apos;locale&apos;] ?? null,
            sort_name: $data[&apos;sort-name&apos;] ?? null,
            type_id: $data[&apos;type-id&apos;] ?? null,
            primary: $data[&apos;primary&apos;] ?? null,
            begin_date: $data[&apos;begin-date&apos;] ?? null,
            end_date: $data[&apos;end-date&apos;] ?? null,
            release_group: $data[&apos;release-group&apos;] ?? null,
            primary_type: $data[&apos;primary-type&apos;] ?? null,
            secondary_type: $data[&apos;secondary-type&apos;] ?? null,
            tag: $data[&apos;tag&apos;] ?? null,
            user_tag: $data[&apos;user-tag&apos;] ?? null,
            genre: $data[&apos;genre&apos;] ?? null,
            target_type: $data[&apos;target-type&apos;] ?? null,
            relation: $data[&apos;relation&apos;] ?? null,
            target: $data[&apos;target&apos;] ?? null,
            ordering_key: $data[&apos;ordering-key&apos;] ?? null,
            direction: $data[&apos;direction&apos;] ?? null,
            begin: $data[&apos;begin&apos;] ?? null,
            end: $data[&apos;end&apos;] ?? null,
            ended: $data[&apos;ended&apos;] ?? null,
            source_credit: $data[&apos;source-credit&apos;] ?? null,
            target_credit: $data[&apos;target-credit&apos;] ?? null,
            user_genre: $data[&apos;user-genre&apos;] ?? null,
            rating: $data[&apos;rating&apos;] ?? null,
            votes_count: $data[&apos;votes-count&apos;] ?? null,
            user_rating: $data[&apos;user-rating&apos;] ?? null,
            date: $data[&apos;date&apos;] ?? null,
            country: $data[&apos;country&apos;] ?? null,
            release_event: $data[&apos;release-event&apos;] ?? null,
            area: $data[&apos;area&apos;] ?? null,
            iso_3166_1_code: $data[&apos;iso-3166-1-code&apos;] ?? null,
            iso_3166_2_code: $data[&apos;iso-3166-2-code&apos;] ?? null,
            iso_3166_3_code: $data[&apos;iso-3166-3-code&apos;] ?? null,
            life_span: $data[&apos;life-span&apos;] ?? null,
            barcode: $data[&apos;barcode&apos;] ?? null,
            asin: $data[&apos;asin&apos;] ?? null,
            cover_art_archive: $data[&apos;cover-art-archive&apos;] ?? null,
            artwork: $data[&apos;artwork&apos;] ?? null,
            front: $data[&apos;front&apos;] ?? null,
            back: $data[&apos;back&apos;] ?? null,
            darkened: $data[&apos;darkened&apos;] ?? null,
            label_info: $data[&apos;label-info&apos;] ?? null,
            catalog_number: $data[&apos;catalog-number&apos;] ?? null,
            label: $data[&apos;label&apos;] ?? null,
            label_code: $data[&apos;label-code&apos;] ?? null,
            ipi: $data[&apos;ipi&apos;] ?? null,
            isni: $data[&apos;isni&apos;] ?? null,
            track_count: $data[&apos;track-count&apos;] ?? null,
            medium: $data[&apos;medium&apos;] ?? null,
            track: $data[&apos;track&apos;] ?? null,
            format: $data[&apos;format&apos;] ?? null,
            disc: $data[&apos;disc&apos;] ?? null,
            sectors: $data[&apos;sectors&apos;] ?? null,
            collection: $data[&apos;collection&apos;] ?? null,
            entity_type: $data[&apos;entity-type&apos;] ?? null,
            editor: $data[&apos;editor&apos;] ?? null,
            artist: $data[&apos;artist&apos;] ?? null,
            gender: $data[&apos;gender&apos;] ?? null,
            begin_area: $data[&apos;begin-area&apos;] ?? null,
            end_area: $data[&apos;end-area&apos;] ?? null,
            work: $data[&apos;work&apos;] ?? null,
            fluency: $data[&apos;fluency&apos;] ?? null,
            iswc: $data[&apos;iswc&apos;] ?? null,
            event: $data[&apos;event&apos;] ?? null,
            cancelled: $data[&apos;cancelled&apos;] ?? null,
            time: $data[&apos;time&apos;] ?? null,
            setlist: $data[&apos;setlist&apos;] ?? null,
            instrument: $data[&apos;instrument&apos;] ?? null,
            description: $data[&apos;description&apos;] ?? null,
            place: $data[&apos;place&apos;] ?? null,
            address: $data[&apos;address&apos;] ?? null,
            coordinates: $data[&apos;coordinates&apos;] ?? null,
            latitude: $data[&apos;latitude&apos;] ?? null,
            longitude: $data[&apos;longitude&apos;] ?? null,
            series: $data[&apos;series&apos;] ?? null,
            puid: $data[&apos;puid&apos;] ?? null,
            isrc: $data[&apos;isrc&apos;] ?? null
        );
    }
}</file><file path="app/Http/Integrations/MusicBrainz/Models/Puid.php">&lt;?php
namespace App\Http\Integrations\MusicBrainz\Models;
use Spatie\LaravelData\Data;
class Puid extends Data
{
    public function __construct(public mixed $puid, public mixed $id, public mixed $count, public mixed $offset, public mixed $recording, public mixed $title, public mixed $length, public mixed $annotation, public mixed $text, public mixed $type, public mixed $entity, public mixed $name, public mixed $disambiguation, public mixed $video, public mixed $artist_credit, public mixed $first_release_date, public mixed $release, public mixed $status, public mixed $quality, public mixed $packaging, public mixed $text_representation, public mixed $language, public mixed $script, public mixed $alias, public mixed $locale, public mixed $sort_name, public mixed $type_id, public mixed $primary, public mixed $begin_date, public mixed $end_date, public mixed $release_group, public mixed $primary_type, public mixed $secondary_type, public mixed $tag, public mixed $user_tag, public mixed $genre, public mixed $target_type, public mixed $relation, public mixed $target, public mixed $ordering_key, public mixed $direction, public mixed $begin, public mixed $end, public mixed $ended, public mixed $source_credit, public mixed $target_credit, public mixed $user_genre, public mixed $rating, public mixed $votes_count, public mixed $user_rating, public mixed $date, public mixed $country, public mixed $release_event, public mixed $area, public mixed $iso_3166_1_code, public mixed $iso_3166_2_code, public mixed $iso_3166_3_code, public mixed $life_span, public mixed $barcode, public mixed $asin, public mixed $cover_art_archive, public mixed $artwork, public mixed $front, public mixed $back, public mixed $darkened, public mixed $label_info, public mixed $catalog_number, public mixed $label, public mixed $label_code, public mixed $ipi, public mixed $isni, public mixed $track_count, public mixed $medium, public mixed $track, public mixed $position, public mixed $number, public mixed $format, public mixed $disc, public mixed $sectors, public mixed $pregap, public mixed $collection, public mixed $entity_type, public mixed $editor, public mixed $artist, public mixed $gender, public mixed $begin_area, public mixed $end_area, public mixed $work, public mixed $fluency, public mixed $iswc, public mixed $event, public mixed $cancelled, public mixed $time, public mixed $setlist, public mixed $instrument, public mixed $description, public mixed $place, public mixed $address, public mixed $coordinates, public mixed $latitude, public mixed $longitude, public mixed $series, public mixed $isrc)
    {
    }
    public static function fromApiData(array $data): self
    {
        return new self(
            puid: $data[&apos;puid&apos;] ?? null,
            id: $data[&apos;id&apos;] ?? null,
            count: $data[&apos;count&apos;] ?? null,
            offset: $data[&apos;offset&apos;] ?? null,
            recording: $data[&apos;recording&apos;] ?? null,
            title: $data[&apos;title&apos;] ?? null,
            length: $data[&apos;length&apos;] ?? null,
            annotation: $data[&apos;annotation&apos;] ?? null,
            text: $data[&apos;text&apos;] ?? null,
            type: $data[&apos;type&apos;] ?? null,
            entity: $data[&apos;entity&apos;] ?? null,
            name: $data[&apos;name&apos;] ?? null,
            disambiguation: $data[&apos;disambiguation&apos;] ?? null,
            video: $data[&apos;video&apos;] ?? null,
            artist_credit: $data[&apos;artist-credit&apos;] ?? null,
            first_release_date: $data[&apos;first-release-date&apos;] ?? null,
            release: $data[&apos;release&apos;] ?? null,
            status: $data[&apos;status&apos;] ?? null,
            quality: $data[&apos;quality&apos;] ?? null,
            packaging: $data[&apos;packaging&apos;] ?? null,
            text_representation: $data[&apos;text-representation&apos;] ?? null,
            language: $data[&apos;language&apos;] ?? null,
            script: $data[&apos;script&apos;] ?? null,
            alias: $data[&apos;alias&apos;] ?? null,
            locale: $data[&apos;locale&apos;] ?? null,
            sort_name: $data[&apos;sort-name&apos;] ?? null,
            type_id: $data[&apos;type-id&apos;] ?? null,
            primary: $data[&apos;primary&apos;] ?? null,
            begin_date: $data[&apos;begin-date&apos;] ?? null,
            end_date: $data[&apos;end-date&apos;] ?? null,
            release_group: $data[&apos;release-group&apos;] ?? null,
            primary_type: $data[&apos;primary-type&apos;] ?? null,
            secondary_type: $data[&apos;secondary-type&apos;] ?? null,
            tag: $data[&apos;tag&apos;] ?? null,
            user_tag: $data[&apos;user-tag&apos;] ?? null,
            genre: $data[&apos;genre&apos;] ?? null,
            target_type: $data[&apos;target-type&apos;] ?? null,
            relation: $data[&apos;relation&apos;] ?? null,
            target: $data[&apos;target&apos;] ?? null,
            ordering_key: $data[&apos;ordering-key&apos;] ?? null,
            direction: $data[&apos;direction&apos;] ?? null,
            begin: $data[&apos;begin&apos;] ?? null,
            end: $data[&apos;end&apos;] ?? null,
            ended: $data[&apos;ended&apos;] ?? null,
            source_credit: $data[&apos;source-credit&apos;] ?? null,
            target_credit: $data[&apos;target-credit&apos;] ?? null,
            user_genre: $data[&apos;user-genre&apos;] ?? null,
            rating: $data[&apos;rating&apos;] ?? null,
            votes_count: $data[&apos;votes-count&apos;] ?? null,
            user_rating: $data[&apos;user-rating&apos;] ?? null,
            date: $data[&apos;date&apos;] ?? null,
            country: $data[&apos;country&apos;] ?? null,
            release_event: $data[&apos;release-event&apos;] ?? null,
            area: $data[&apos;area&apos;] ?? null,
            iso_3166_1_code: $data[&apos;iso-3166-1-code&apos;] ?? null,
            iso_3166_2_code: $data[&apos;iso-3166-2-code&apos;] ?? null,
            iso_3166_3_code: $data[&apos;iso-3166-3-code&apos;] ?? null,
            life_span: $data[&apos;life-span&apos;] ?? null,
            barcode: $data[&apos;barcode&apos;] ?? null,
            asin: $data[&apos;asin&apos;] ?? null,
            cover_art_archive: $data[&apos;cover-art-archive&apos;] ?? null,
            artwork: $data[&apos;artwork&apos;] ?? null,
            front: $data[&apos;front&apos;] ?? null,
            back: $data[&apos;back&apos;] ?? null,
            darkened: $data[&apos;darkened&apos;] ?? null,
            label_info: $data[&apos;label-info&apos;] ?? null,
            catalog_number: $data[&apos;catalog-number&apos;] ?? null,
            label: $data[&apos;label&apos;] ?? null,
            label_code: $data[&apos;label-code&apos;] ?? null,
            ipi: $data[&apos;ipi&apos;] ?? null,
            isni: $data[&apos;isni&apos;] ?? null,
            track_count: $data[&apos;track-count&apos;] ?? null,
            medium: $data[&apos;medium&apos;] ?? null,
            track: $data[&apos;track&apos;] ?? null,
            position: $data[&apos;position&apos;] ?? null,
            number: $data[&apos;number&apos;] ?? null,
            format: $data[&apos;format&apos;] ?? null,
            disc: $data[&apos;disc&apos;] ?? null,
            sectors: $data[&apos;sectors&apos;] ?? null,
            pregap: $data[&apos;pregap&apos;] ?? null,
            collection: $data[&apos;collection&apos;] ?? null,
            entity_type: $data[&apos;entity-type&apos;] ?? null,
            editor: $data[&apos;editor&apos;] ?? null,
            artist: $data[&apos;artist&apos;] ?? null,
            gender: $data[&apos;gender&apos;] ?? null,
            begin_area: $data[&apos;begin-area&apos;] ?? null,
            end_area: $data[&apos;end-area&apos;] ?? null,
            work: $data[&apos;work&apos;] ?? null,
            fluency: $data[&apos;fluency&apos;] ?? null,
            iswc: $data[&apos;iswc&apos;] ?? null,
            event: $data[&apos;event&apos;] ?? null,
            cancelled: $data[&apos;cancelled&apos;] ?? null,
            time: $data[&apos;time&apos;] ?? null,
            setlist: $data[&apos;setlist&apos;] ?? null,
            instrument: $data[&apos;instrument&apos;] ?? null,
            description: $data[&apos;description&apos;] ?? null,
            place: $data[&apos;place&apos;] ?? null,
            address: $data[&apos;address&apos;] ?? null,
            coordinates: $data[&apos;coordinates&apos;] ?? null,
            latitude: $data[&apos;latitude&apos;] ?? null,
            longitude: $data[&apos;longitude&apos;] ?? null,
            series: $data[&apos;series&apos;] ?? null,
            isrc: $data[&apos;isrc&apos;] ?? null
        );
    }
}</file><file path="app/Http/Integrations/MusicBrainz/Models/PuidList.php">&lt;?php
namespace App\Http\Integrations\MusicBrainz\Models;
use Spatie\LaravelData\Data;
class PuidList extends Data
{
    public function __construct(public mixed $count, public mixed $offset, public mixed $puid, public mixed $id, public mixed $recording, public mixed $title, public mixed $length, public mixed $annotation, public mixed $text, public mixed $type, public mixed $entity, public mixed $name, public mixed $disambiguation, public mixed $video, public mixed $artist_credit, public mixed $first_release_date, public mixed $release, public mixed $status, public mixed $quality, public mixed $packaging, public mixed $text_representation, public mixed $language, public mixed $script, public mixed $alias, public mixed $locale, public mixed $sort_name, public mixed $type_id, public mixed $primary, public mixed $begin_date, public mixed $end_date, public mixed $release_group, public mixed $primary_type, public mixed $secondary_type, public mixed $tag, public mixed $user_tag, public mixed $genre, public mixed $target_type, public mixed $relation, public mixed $target, public mixed $ordering_key, public mixed $direction, public mixed $begin, public mixed $end, public mixed $ended, public mixed $source_credit, public mixed $target_credit, public mixed $user_genre, public mixed $rating, public mixed $votes_count, public mixed $user_rating, public mixed $date, public mixed $country, public mixed $release_event, public mixed $area, public mixed $iso_3166_1_code, public mixed $iso_3166_2_code, public mixed $iso_3166_3_code, public mixed $life_span, public mixed $barcode, public mixed $asin, public mixed $cover_art_archive, public mixed $artwork, public mixed $front, public mixed $back, public mixed $darkened, public mixed $label_info, public mixed $catalog_number, public mixed $label, public mixed $label_code, public mixed $ipi, public mixed $isni, public mixed $track_count, public mixed $medium, public mixed $track, public mixed $position, public mixed $number, public mixed $format, public mixed $disc, public mixed $sectors, public mixed $pregap, public mixed $collection, public mixed $entity_type, public mixed $editor, public mixed $artist, public mixed $gender, public mixed $begin_area, public mixed $end_area, public mixed $work, public mixed $fluency, public mixed $iswc, public mixed $event, public mixed $cancelled, public mixed $time, public mixed $setlist, public mixed $instrument, public mixed $description, public mixed $place, public mixed $address, public mixed $coordinates, public mixed $latitude, public mixed $longitude, public mixed $series, public mixed $isrc)
    {
    }
    public static function fromApiData(array $data): self
    {
        return new self(
            count: $data[&apos;count&apos;] ?? null,
            offset: $data[&apos;offset&apos;] ?? null,
            puid: $data[&apos;puid&apos;] ?? null,
            id: $data[&apos;id&apos;] ?? null,
            recording: $data[&apos;recording&apos;] ?? null,
            title: $data[&apos;title&apos;] ?? null,
            length: $data[&apos;length&apos;] ?? null,
            annotation: $data[&apos;annotation&apos;] ?? null,
            text: $data[&apos;text&apos;] ?? null,
            type: $data[&apos;type&apos;] ?? null,
            entity: $data[&apos;entity&apos;] ?? null,
            name: $data[&apos;name&apos;] ?? null,
            disambiguation: $data[&apos;disambiguation&apos;] ?? null,
            video: $data[&apos;video&apos;] ?? null,
            artist_credit: $data[&apos;artist-credit&apos;] ?? null,
            first_release_date: $data[&apos;first-release-date&apos;] ?? null,
            release: $data[&apos;release&apos;] ?? null,
            status: $data[&apos;status&apos;] ?? null,
            quality: $data[&apos;quality&apos;] ?? null,
            packaging: $data[&apos;packaging&apos;] ?? null,
            text_representation: $data[&apos;text-representation&apos;] ?? null,
            language: $data[&apos;language&apos;] ?? null,
            script: $data[&apos;script&apos;] ?? null,
            alias: $data[&apos;alias&apos;] ?? null,
            locale: $data[&apos;locale&apos;] ?? null,
            sort_name: $data[&apos;sort-name&apos;] ?? null,
            type_id: $data[&apos;type-id&apos;] ?? null,
            primary: $data[&apos;primary&apos;] ?? null,
            begin_date: $data[&apos;begin-date&apos;] ?? null,
            end_date: $data[&apos;end-date&apos;] ?? null,
            release_group: $data[&apos;release-group&apos;] ?? null,
            primary_type: $data[&apos;primary-type&apos;] ?? null,
            secondary_type: $data[&apos;secondary-type&apos;] ?? null,
            tag: $data[&apos;tag&apos;] ?? null,
            user_tag: $data[&apos;user-tag&apos;] ?? null,
            genre: $data[&apos;genre&apos;] ?? null,
            target_type: $data[&apos;target-type&apos;] ?? null,
            relation: $data[&apos;relation&apos;] ?? null,
            target: $data[&apos;target&apos;] ?? null,
            ordering_key: $data[&apos;ordering-key&apos;] ?? null,
            direction: $data[&apos;direction&apos;] ?? null,
            begin: $data[&apos;begin&apos;] ?? null,
            end: $data[&apos;end&apos;] ?? null,
            ended: $data[&apos;ended&apos;] ?? null,
            source_credit: $data[&apos;source-credit&apos;] ?? null,
            target_credit: $data[&apos;target-credit&apos;] ?? null,
            user_genre: $data[&apos;user-genre&apos;] ?? null,
            rating: $data[&apos;rating&apos;] ?? null,
            votes_count: $data[&apos;votes-count&apos;] ?? null,
            user_rating: $data[&apos;user-rating&apos;] ?? null,
            date: $data[&apos;date&apos;] ?? null,
            country: $data[&apos;country&apos;] ?? null,
            release_event: $data[&apos;release-event&apos;] ?? null,
            area: $data[&apos;area&apos;] ?? null,
            iso_3166_1_code: $data[&apos;iso-3166-1-code&apos;] ?? null,
            iso_3166_2_code: $data[&apos;iso-3166-2-code&apos;] ?? null,
            iso_3166_3_code: $data[&apos;iso-3166-3-code&apos;] ?? null,
            life_span: $data[&apos;life-span&apos;] ?? null,
            barcode: $data[&apos;barcode&apos;] ?? null,
            asin: $data[&apos;asin&apos;] ?? null,
            cover_art_archive: $data[&apos;cover-art-archive&apos;] ?? null,
            artwork: $data[&apos;artwork&apos;] ?? null,
            front: $data[&apos;front&apos;] ?? null,
            back: $data[&apos;back&apos;] ?? null,
            darkened: $data[&apos;darkened&apos;] ?? null,
            label_info: $data[&apos;label-info&apos;] ?? null,
            catalog_number: $data[&apos;catalog-number&apos;] ?? null,
            label: $data[&apos;label&apos;] ?? null,
            label_code: $data[&apos;label-code&apos;] ?? null,
            ipi: $data[&apos;ipi&apos;] ?? null,
            isni: $data[&apos;isni&apos;] ?? null,
            track_count: $data[&apos;track-count&apos;] ?? null,
            medium: $data[&apos;medium&apos;] ?? null,
            track: $data[&apos;track&apos;] ?? null,
            position: $data[&apos;position&apos;] ?? null,
            number: $data[&apos;number&apos;] ?? null,
            format: $data[&apos;format&apos;] ?? null,
            disc: $data[&apos;disc&apos;] ?? null,
            sectors: $data[&apos;sectors&apos;] ?? null,
            pregap: $data[&apos;pregap&apos;] ?? null,
            collection: $data[&apos;collection&apos;] ?? null,
            entity_type: $data[&apos;entity-type&apos;] ?? null,
            editor: $data[&apos;editor&apos;] ?? null,
            artist: $data[&apos;artist&apos;] ?? null,
            gender: $data[&apos;gender&apos;] ?? null,
            begin_area: $data[&apos;begin-area&apos;] ?? null,
            end_area: $data[&apos;end-area&apos;] ?? null,
            work: $data[&apos;work&apos;] ?? null,
            fluency: $data[&apos;fluency&apos;] ?? null,
            iswc: $data[&apos;iswc&apos;] ?? null,
            event: $data[&apos;event&apos;] ?? null,
            cancelled: $data[&apos;cancelled&apos;] ?? null,
            time: $data[&apos;time&apos;] ?? null,
            setlist: $data[&apos;setlist&apos;] ?? null,
            instrument: $data[&apos;instrument&apos;] ?? null,
            description: $data[&apos;description&apos;] ?? null,
            place: $data[&apos;place&apos;] ?? null,
            address: $data[&apos;address&apos;] ?? null,
            coordinates: $data[&apos;coordinates&apos;] ?? null,
            latitude: $data[&apos;latitude&apos;] ?? null,
            longitude: $data[&apos;longitude&apos;] ?? null,
            series: $data[&apos;series&apos;] ?? null,
            isrc: $data[&apos;isrc&apos;] ?? null
        );
    }
}</file><file path="app/Http/Integrations/MusicBrainz/Models/Rating.php">&lt;?php
namespace App\Http\Integrations\MusicBrainz\Models;
use Spatie\LaravelData\Data;
class Rating extends Data
{
    public function __construct(public mixed $votes_count)
    {
    }
    public static function fromApiData(array $data): self
    {
        return new self(
            votes_count: $data[&apos;votes-count&apos;] ?? null
        );
    }
}</file><file path="app/Http/Integrations/MusicBrainz/Models/Recording.php">&lt;?php
namespace App\Http\Integrations\MusicBrainz\Models;
use Spatie\LaravelData\Data;
class Recording extends Data
{
    public function __construct(public mixed $recording, public mixed $id, public mixed $title, public mixed $length, public mixed $annotation, public mixed $text, public mixed $type, public mixed $entity, public mixed $name, public mixed $disambiguation, public mixed $video, public mixed $artist_credit, public mixed $first_release_date, public mixed $count, public mixed $offset, public mixed $release, public mixed $status, public mixed $quality, public mixed $packaging, public mixed $text_representation, public mixed $language, public mixed $script, public mixed $alias, public mixed $locale, public mixed $sort_name, public mixed $type_id, public mixed $primary, public mixed $begin_date, public mixed $end_date, public mixed $release_group, public mixed $primary_type, public mixed $secondary_type, public mixed $tag, public mixed $user_tag, public mixed $genre, public mixed $target_type, public mixed $relation, public mixed $target, public mixed $ordering_key, public mixed $direction, public mixed $begin, public mixed $end, public mixed $ended, public mixed $source_credit, public mixed $target_credit, public mixed $user_genre, public mixed $rating, public mixed $votes_count, public mixed $user_rating, public mixed $date, public mixed $country, public mixed $release_event, public mixed $area, public mixed $iso_3166_1_code, public mixed $iso_3166_2_code, public mixed $iso_3166_3_code, public mixed $life_span, public mixed $barcode, public mixed $asin, public mixed $cover_art_archive, public mixed $artwork, public mixed $front, public mixed $back, public mixed $darkened, public mixed $label_info, public mixed $catalog_number, public mixed $label, public mixed $label_code, public mixed $ipi, public mixed $isni, public mixed $track_count, public mixed $medium, public mixed $track, public mixed $position, public mixed $number, public mixed $puid, public mixed $isrc, public mixed $format, public mixed $disc, public mixed $sectors, public mixed $pregap, public mixed $collection, public mixed $entity_type, public mixed $editor, public mixed $artist, public mixed $gender, public mixed $begin_area, public mixed $end_area, public mixed $work, public mixed $fluency, public mixed $iswc, public mixed $event, public mixed $cancelled, public mixed $time, public mixed $setlist, public mixed $instrument, public mixed $description, public mixed $place, public mixed $address, public mixed $coordinates, public mixed $latitude, public mixed $longitude, public mixed $series)
    {
    }
    public static function fromApiData(array $data): self
    {
        return new self(
            recording: $data[&apos;recording&apos;] ?? null,
            id: $data[&apos;id&apos;] ?? null,
            title: $data[&apos;title&apos;] ?? null,
            length: $data[&apos;length&apos;] ?? null,
            annotation: $data[&apos;annotation&apos;] ?? null,
            text: $data[&apos;text&apos;] ?? null,
            type: $data[&apos;type&apos;] ?? null,
            entity: $data[&apos;entity&apos;] ?? null,
            name: $data[&apos;name&apos;] ?? null,
            disambiguation: $data[&apos;disambiguation&apos;] ?? null,
            video: $data[&apos;video&apos;] ?? null,
            artist_credit: $data[&apos;artist-credit&apos;] ?? null,
            first_release_date: $data[&apos;first-release-date&apos;] ?? null,
            count: $data[&apos;count&apos;] ?? null,
            offset: $data[&apos;offset&apos;] ?? null,
            release: $data[&apos;release&apos;] ?? null,
            status: $data[&apos;status&apos;] ?? null,
            quality: $data[&apos;quality&apos;] ?? null,
            packaging: $data[&apos;packaging&apos;] ?? null,
            text_representation: $data[&apos;text-representation&apos;] ?? null,
            language: $data[&apos;language&apos;] ?? null,
            script: $data[&apos;script&apos;] ?? null,
            alias: $data[&apos;alias&apos;] ?? null,
            locale: $data[&apos;locale&apos;] ?? null,
            sort_name: $data[&apos;sort-name&apos;] ?? null,
            type_id: $data[&apos;type-id&apos;] ?? null,
            primary: $data[&apos;primary&apos;] ?? null,
            begin_date: $data[&apos;begin-date&apos;] ?? null,
            end_date: $data[&apos;end-date&apos;] ?? null,
            release_group: $data[&apos;release-group&apos;] ?? null,
            primary_type: $data[&apos;primary-type&apos;] ?? null,
            secondary_type: $data[&apos;secondary-type&apos;] ?? null,
            tag: $data[&apos;tag&apos;] ?? null,
            user_tag: $data[&apos;user-tag&apos;] ?? null,
            genre: $data[&apos;genre&apos;] ?? null,
            target_type: $data[&apos;target-type&apos;] ?? null,
            relation: $data[&apos;relation&apos;] ?? null,
            target: $data[&apos;target&apos;] ?? null,
            ordering_key: $data[&apos;ordering-key&apos;] ?? null,
            direction: $data[&apos;direction&apos;] ?? null,
            begin: $data[&apos;begin&apos;] ?? null,
            end: $data[&apos;end&apos;] ?? null,
            ended: $data[&apos;ended&apos;] ?? null,
            source_credit: $data[&apos;source-credit&apos;] ?? null,
            target_credit: $data[&apos;target-credit&apos;] ?? null,
            user_genre: $data[&apos;user-genre&apos;] ?? null,
            rating: $data[&apos;rating&apos;] ?? null,
            votes_count: $data[&apos;votes-count&apos;] ?? null,
            user_rating: $data[&apos;user-rating&apos;] ?? null,
            date: $data[&apos;date&apos;] ?? null,
            country: $data[&apos;country&apos;] ?? null,
            release_event: $data[&apos;release-event&apos;] ?? null,
            area: $data[&apos;area&apos;] ?? null,
            iso_3166_1_code: $data[&apos;iso-3166-1-code&apos;] ?? null,
            iso_3166_2_code: $data[&apos;iso-3166-2-code&apos;] ?? null,
            iso_3166_3_code: $data[&apos;iso-3166-3-code&apos;] ?? null,
            life_span: $data[&apos;life-span&apos;] ?? null,
            barcode: $data[&apos;barcode&apos;] ?? null,
            asin: $data[&apos;asin&apos;] ?? null,
            cover_art_archive: $data[&apos;cover-art-archive&apos;] ?? null,
            artwork: $data[&apos;artwork&apos;] ?? null,
            front: $data[&apos;front&apos;] ?? null,
            back: $data[&apos;back&apos;] ?? null,
            darkened: $data[&apos;darkened&apos;] ?? null,
            label_info: $data[&apos;label-info&apos;] ?? null,
            catalog_number: $data[&apos;catalog-number&apos;] ?? null,
            label: $data[&apos;label&apos;] ?? null,
            label_code: $data[&apos;label-code&apos;] ?? null,
            ipi: $data[&apos;ipi&apos;] ?? null,
            isni: $data[&apos;isni&apos;] ?? null,
            track_count: $data[&apos;track-count&apos;] ?? null,
            medium: $data[&apos;medium&apos;] ?? null,
            track: $data[&apos;track&apos;] ?? null,
            position: $data[&apos;position&apos;] ?? null,
            number: $data[&apos;number&apos;] ?? null,
            puid: $data[&apos;puid&apos;] ?? null,
            isrc: $data[&apos;isrc&apos;] ?? null,
            format: $data[&apos;format&apos;] ?? null,
            disc: $data[&apos;disc&apos;] ?? null,
            sectors: $data[&apos;sectors&apos;] ?? null,
            pregap: $data[&apos;pregap&apos;] ?? null,
            collection: $data[&apos;collection&apos;] ?? null,
            entity_type: $data[&apos;entity-type&apos;] ?? null,
            editor: $data[&apos;editor&apos;] ?? null,
            artist: $data[&apos;artist&apos;] ?? null,
            gender: $data[&apos;gender&apos;] ?? null,
            begin_area: $data[&apos;begin-area&apos;] ?? null,
            end_area: $data[&apos;end-area&apos;] ?? null,
            work: $data[&apos;work&apos;] ?? null,
            fluency: $data[&apos;fluency&apos;] ?? null,
            iswc: $data[&apos;iswc&apos;] ?? null,
            event: $data[&apos;event&apos;] ?? null,
            cancelled: $data[&apos;cancelled&apos;] ?? null,
            time: $data[&apos;time&apos;] ?? null,
            setlist: $data[&apos;setlist&apos;] ?? null,
            instrument: $data[&apos;instrument&apos;] ?? null,
            description: $data[&apos;description&apos;] ?? null,
            place: $data[&apos;place&apos;] ?? null,
            address: $data[&apos;address&apos;] ?? null,
            coordinates: $data[&apos;coordinates&apos;] ?? null,
            latitude: $data[&apos;latitude&apos;] ?? null,
            longitude: $data[&apos;longitude&apos;] ?? null,
            series: $data[&apos;series&apos;] ?? null
        );
    }
}</file><file path="app/Http/Integrations/MusicBrainz/Models/RecordingList.php">&lt;?php
namespace App\Http\Integrations\MusicBrainz\Models;
use Spatie\LaravelData\Data;
class RecordingList extends Data
{
    public function __construct(public mixed $count, public mixed $offset, public mixed $recording, public mixed $id, public mixed $title, public mixed $length, public mixed $annotation, public mixed $text, public mixed $type, public mixed $entity, public mixed $name, public mixed $disambiguation, public mixed $video, public mixed $artist_credit, public mixed $first_release_date, public mixed $release, public mixed $status, public mixed $quality, public mixed $packaging, public mixed $text_representation, public mixed $language, public mixed $script, public mixed $alias, public mixed $locale, public mixed $sort_name, public mixed $type_id, public mixed $primary, public mixed $begin_date, public mixed $end_date, public mixed $release_group, public mixed $primary_type, public mixed $secondary_type, public mixed $tag, public mixed $user_tag, public mixed $genre, public mixed $target_type, public mixed $relation, public mixed $target, public mixed $ordering_key, public mixed $direction, public mixed $begin, public mixed $end, public mixed $ended, public mixed $source_credit, public mixed $target_credit, public mixed $user_genre, public mixed $rating, public mixed $votes_count, public mixed $user_rating, public mixed $date, public mixed $country, public mixed $release_event, public mixed $area, public mixed $iso_3166_1_code, public mixed $iso_3166_2_code, public mixed $iso_3166_3_code, public mixed $life_span, public mixed $barcode, public mixed $asin, public mixed $cover_art_archive, public mixed $artwork, public mixed $front, public mixed $back, public mixed $darkened, public mixed $label_info, public mixed $catalog_number, public mixed $label, public mixed $label_code, public mixed $ipi, public mixed $isni, public mixed $track_count, public mixed $medium, public mixed $track, public mixed $position, public mixed $number, public mixed $format, public mixed $disc, public mixed $sectors, public mixed $pregap, public mixed $collection, public mixed $entity_type, public mixed $editor, public mixed $artist, public mixed $gender, public mixed $begin_area, public mixed $end_area, public mixed $work, public mixed $fluency, public mixed $iswc, public mixed $event, public mixed $cancelled, public mixed $time, public mixed $setlist, public mixed $instrument, public mixed $description, public mixed $place, public mixed $address, public mixed $coordinates, public mixed $latitude, public mixed $longitude, public mixed $series, public mixed $puid, public mixed $isrc)
    {
    }
    public static function fromApiData(array $data): self
    {
        return new self(
            count: $data[&apos;count&apos;] ?? null,
            offset: $data[&apos;offset&apos;] ?? null,
            recording: $data[&apos;recording&apos;] ?? null,
            id: $data[&apos;id&apos;] ?? null,
            title: $data[&apos;title&apos;] ?? null,
            length: $data[&apos;length&apos;] ?? null,
            annotation: $data[&apos;annotation&apos;] ?? null,
            text: $data[&apos;text&apos;] ?? null,
            type: $data[&apos;type&apos;] ?? null,
            entity: $data[&apos;entity&apos;] ?? null,
            name: $data[&apos;name&apos;] ?? null,
            disambiguation: $data[&apos;disambiguation&apos;] ?? null,
            video: $data[&apos;video&apos;] ?? null,
            artist_credit: $data[&apos;artist-credit&apos;] ?? null,
            first_release_date: $data[&apos;first-release-date&apos;] ?? null,
            release: $data[&apos;release&apos;] ?? null,
            status: $data[&apos;status&apos;] ?? null,
            quality: $data[&apos;quality&apos;] ?? null,
            packaging: $data[&apos;packaging&apos;] ?? null,
            text_representation: $data[&apos;text-representation&apos;] ?? null,
            language: $data[&apos;language&apos;] ?? null,
            script: $data[&apos;script&apos;] ?? null,
            alias: $data[&apos;alias&apos;] ?? null,
            locale: $data[&apos;locale&apos;] ?? null,
            sort_name: $data[&apos;sort-name&apos;] ?? null,
            type_id: $data[&apos;type-id&apos;] ?? null,
            primary: $data[&apos;primary&apos;] ?? null,
            begin_date: $data[&apos;begin-date&apos;] ?? null,
            end_date: $data[&apos;end-date&apos;] ?? null,
            release_group: $data[&apos;release-group&apos;] ?? null,
            primary_type: $data[&apos;primary-type&apos;] ?? null,
            secondary_type: $data[&apos;secondary-type&apos;] ?? null,
            tag: $data[&apos;tag&apos;] ?? null,
            user_tag: $data[&apos;user-tag&apos;] ?? null,
            genre: $data[&apos;genre&apos;] ?? null,
            target_type: $data[&apos;target-type&apos;] ?? null,
            relation: $data[&apos;relation&apos;] ?? null,
            target: $data[&apos;target&apos;] ?? null,
            ordering_key: $data[&apos;ordering-key&apos;] ?? null,
            direction: $data[&apos;direction&apos;] ?? null,
            begin: $data[&apos;begin&apos;] ?? null,
            end: $data[&apos;end&apos;] ?? null,
            ended: $data[&apos;ended&apos;] ?? null,
            source_credit: $data[&apos;source-credit&apos;] ?? null,
            target_credit: $data[&apos;target-credit&apos;] ?? null,
            user_genre: $data[&apos;user-genre&apos;] ?? null,
            rating: $data[&apos;rating&apos;] ?? null,
            votes_count: $data[&apos;votes-count&apos;] ?? null,
            user_rating: $data[&apos;user-rating&apos;] ?? null,
            date: $data[&apos;date&apos;] ?? null,
            country: $data[&apos;country&apos;] ?? null,
            release_event: $data[&apos;release-event&apos;] ?? null,
            area: $data[&apos;area&apos;] ?? null,
            iso_3166_1_code: $data[&apos;iso-3166-1-code&apos;] ?? null,
            iso_3166_2_code: $data[&apos;iso-3166-2-code&apos;] ?? null,
            iso_3166_3_code: $data[&apos;iso-3166-3-code&apos;] ?? null,
            life_span: $data[&apos;life-span&apos;] ?? null,
            barcode: $data[&apos;barcode&apos;] ?? null,
            asin: $data[&apos;asin&apos;] ?? null,
            cover_art_archive: $data[&apos;cover-art-archive&apos;] ?? null,
            artwork: $data[&apos;artwork&apos;] ?? null,
            front: $data[&apos;front&apos;] ?? null,
            back: $data[&apos;back&apos;] ?? null,
            darkened: $data[&apos;darkened&apos;] ?? null,
            label_info: $data[&apos;label-info&apos;] ?? null,
            catalog_number: $data[&apos;catalog-number&apos;] ?? null,
            label: $data[&apos;label&apos;] ?? null,
            label_code: $data[&apos;label-code&apos;] ?? null,
            ipi: $data[&apos;ipi&apos;] ?? null,
            isni: $data[&apos;isni&apos;] ?? null,
            track_count: $data[&apos;track-count&apos;] ?? null,
            medium: $data[&apos;medium&apos;] ?? null,
            track: $data[&apos;track&apos;] ?? null,
            position: $data[&apos;position&apos;] ?? null,
            number: $data[&apos;number&apos;] ?? null,
            format: $data[&apos;format&apos;] ?? null,
            disc: $data[&apos;disc&apos;] ?? null,
            sectors: $data[&apos;sectors&apos;] ?? null,
            pregap: $data[&apos;pregap&apos;] ?? null,
            collection: $data[&apos;collection&apos;] ?? null,
            entity_type: $data[&apos;entity-type&apos;] ?? null,
            editor: $data[&apos;editor&apos;] ?? null,
            artist: $data[&apos;artist&apos;] ?? null,
            gender: $data[&apos;gender&apos;] ?? null,
            begin_area: $data[&apos;begin-area&apos;] ?? null,
            end_area: $data[&apos;end-area&apos;] ?? null,
            work: $data[&apos;work&apos;] ?? null,
            fluency: $data[&apos;fluency&apos;] ?? null,
            iswc: $data[&apos;iswc&apos;] ?? null,
            event: $data[&apos;event&apos;] ?? null,
            cancelled: $data[&apos;cancelled&apos;] ?? null,
            time: $data[&apos;time&apos;] ?? null,
            setlist: $data[&apos;setlist&apos;] ?? null,
            instrument: $data[&apos;instrument&apos;] ?? null,
            description: $data[&apos;description&apos;] ?? null,
            place: $data[&apos;place&apos;] ?? null,
            address: $data[&apos;address&apos;] ?? null,
            coordinates: $data[&apos;coordinates&apos;] ?? null,
            latitude: $data[&apos;latitude&apos;] ?? null,
            longitude: $data[&apos;longitude&apos;] ?? null,
            series: $data[&apos;series&apos;] ?? null,
            puid: $data[&apos;puid&apos;] ?? null,
            isrc: $data[&apos;isrc&apos;] ?? null
        );
    }
}</file><file path="app/Http/Integrations/MusicBrainz/Models/Relation.php">&lt;?php
namespace App\Http\Integrations\MusicBrainz\Models;
use Spatie\LaravelData\Data;
class Relation extends Data
{
    public function __construct(public mixed $relation, public mixed $target, public mixed $id, public mixed $type, public mixed $type_id, public mixed $ordering_key, public mixed $direction, public mixed $begin, public mixed $end, public mixed $ended, public mixed $source_credit, public mixed $target_credit)
    {
    }
    public static function fromApiData(array $data): self
    {
        return new self(
            relation: $data[&apos;relation&apos;] ?? null,
            target: $data[&apos;target&apos;] ?? null,
            id: $data[&apos;id&apos;] ?? null,
            type: $data[&apos;type&apos;] ?? null,
            type_id: $data[&apos;type-id&apos;] ?? null,
            ordering_key: $data[&apos;ordering-key&apos;] ?? null,
            direction: $data[&apos;direction&apos;] ?? null,
            begin: $data[&apos;begin&apos;] ?? null,
            end: $data[&apos;end&apos;] ?? null,
            ended: $data[&apos;ended&apos;] ?? null,
            source_credit: $data[&apos;source-credit&apos;] ?? null,
            target_credit: $data[&apos;target-credit&apos;] ?? null
        );
    }
}</file><file path="app/Http/Integrations/MusicBrainz/Models/RelationList.php">&lt;?php
namespace App\Http\Integrations\MusicBrainz\Models;
use Spatie\LaravelData\Data;
class RelationList extends Data
{
    public function __construct(public mixed $target_type, public mixed $count, public mixed $offset, public mixed $relation, public mixed $target, public mixed $id, public mixed $type, public mixed $type_id, public mixed $ordering_key, public mixed $direction, public mixed $begin, public mixed $end, public mixed $ended, public mixed $source_credit, public mixed $target_credit)
    {
    }
    public static function fromApiData(array $data): self
    {
        return new self(
            target_type: $data[&apos;target-type&apos;] ?? null,
            count: $data[&apos;count&apos;] ?? null,
            offset: $data[&apos;offset&apos;] ?? null,
            relation: $data[&apos;relation&apos;] ?? null,
            target: $data[&apos;target&apos;] ?? null,
            id: $data[&apos;id&apos;] ?? null,
            type: $data[&apos;type&apos;] ?? null,
            type_id: $data[&apos;type-id&apos;] ?? null,
            ordering_key: $data[&apos;ordering-key&apos;] ?? null,
            direction: $data[&apos;direction&apos;] ?? null,
            begin: $data[&apos;begin&apos;] ?? null,
            end: $data[&apos;end&apos;] ?? null,
            ended: $data[&apos;ended&apos;] ?? null,
            source_credit: $data[&apos;source-credit&apos;] ?? null,
            target_credit: $data[&apos;target-credit&apos;] ?? null
        );
    }
}</file><file path="app/Http/Integrations/MusicBrainz/Models/Release.php">&lt;?php
namespace App\Http\Integrations\MusicBrainz\Models;
use Spatie\LaravelData\Data;
class Release extends Data
{
    public function __construct(public mixed $release, public mixed $id, public mixed $title, public mixed $status, public mixed $quality, public mixed $annotation, public mixed $text, public mixed $type, public mixed $entity, public mixed $name, public mixed $disambiguation, public mixed $packaging, public mixed $text_representation, public mixed $language, public mixed $script, public mixed $artist_credit, public mixed $count, public mixed $offset, public mixed $alias, public mixed $locale, public mixed $sort_name, public mixed $type_id, public mixed $primary, public mixed $begin_date, public mixed $end_date, public mixed $release_group, public mixed $first_release_date, public mixed $primary_type, public mixed $secondary_type, public mixed $date, public mixed $country, public mixed $release_event, public mixed $area, public mixed $iso_3166_1_code, public mixed $iso_3166_2_code, public mixed $iso_3166_3_code, public mixed $life_span, public mixed $begin, public mixed $end, public mixed $ended, public mixed $tag, public mixed $user_tag, public mixed $genre, public mixed $target_type, public mixed $relation, public mixed $target, public mixed $ordering_key, public mixed $direction, public mixed $source_credit, public mixed $target_credit, public mixed $user_genre, public mixed $barcode, public mixed $asin, public mixed $cover_art_archive, public mixed $artwork, public mixed $front, public mixed $back, public mixed $darkened, public mixed $label_info, public mixed $catalog_number, public mixed $label, public mixed $label_code, public mixed $ipi, public mixed $isni, public mixed $rating, public mixed $votes_count, public mixed $user_rating, public mixed $track_count, public mixed $medium, public mixed $track, public mixed $position, public mixed $number, public mixed $length, public mixed $recording, public mixed $video, public mixed $puid, public mixed $isrc, public mixed $format, public mixed $disc, public mixed $sectors, public mixed $pregap, public mixed $collection, public mixed $entity_type, public mixed $editor, public mixed $artist, public mixed $gender, public mixed $begin_area, public mixed $end_area, public mixed $work, public mixed $fluency, public mixed $iswc, public mixed $event, public mixed $cancelled, public mixed $time, public mixed $setlist, public mixed $instrument, public mixed $description, public mixed $place, public mixed $address, public mixed $coordinates, public mixed $latitude, public mixed $longitude, public mixed $series)
    {
    }
    public static function fromApiData(array $data): self
    {
        return new self(
            release: $data[&apos;release&apos;] ?? null,
            id: $data[&apos;id&apos;] ?? null,
            title: $data[&apos;title&apos;] ?? null,
            status: $data[&apos;status&apos;] ?? null,
            quality: $data[&apos;quality&apos;] ?? null,
            annotation: $data[&apos;annotation&apos;] ?? null,
            text: $data[&apos;text&apos;] ?? null,
            type: $data[&apos;type&apos;] ?? null,
            entity: $data[&apos;entity&apos;] ?? null,
            name: $data[&apos;name&apos;] ?? null,
            disambiguation: $data[&apos;disambiguation&apos;] ?? null,
            packaging: $data[&apos;packaging&apos;] ?? null,
            text_representation: $data[&apos;text-representation&apos;] ?? null,
            language: $data[&apos;language&apos;] ?? null,
            script: $data[&apos;script&apos;] ?? null,
            artist_credit: $data[&apos;artist-credit&apos;] ?? null,
            count: $data[&apos;count&apos;] ?? null,
            offset: $data[&apos;offset&apos;] ?? null,
            alias: $data[&apos;alias&apos;] ?? null,
            locale: $data[&apos;locale&apos;] ?? null,
            sort_name: $data[&apos;sort-name&apos;] ?? null,
            type_id: $data[&apos;type-id&apos;] ?? null,
            primary: $data[&apos;primary&apos;] ?? null,
            begin_date: $data[&apos;begin-date&apos;] ?? null,
            end_date: $data[&apos;end-date&apos;] ?? null,
            release_group: $data[&apos;release-group&apos;] ?? null,
            first_release_date: $data[&apos;first-release-date&apos;] ?? null,
            primary_type: $data[&apos;primary-type&apos;] ?? null,
            secondary_type: $data[&apos;secondary-type&apos;] ?? null,
            date: $data[&apos;date&apos;] ?? null,
            country: $data[&apos;country&apos;] ?? null,
            release_event: $data[&apos;release-event&apos;] ?? null,
            area: $data[&apos;area&apos;] ?? null,
            iso_3166_1_code: $data[&apos;iso-3166-1-code&apos;] ?? null,
            iso_3166_2_code: $data[&apos;iso-3166-2-code&apos;] ?? null,
            iso_3166_3_code: $data[&apos;iso-3166-3-code&apos;] ?? null,
            life_span: $data[&apos;life-span&apos;] ?? null,
            begin: $data[&apos;begin&apos;] ?? null,
            end: $data[&apos;end&apos;] ?? null,
            ended: $data[&apos;ended&apos;] ?? null,
            tag: $data[&apos;tag&apos;] ?? null,
            user_tag: $data[&apos;user-tag&apos;] ?? null,
            genre: $data[&apos;genre&apos;] ?? null,
            target_type: $data[&apos;target-type&apos;] ?? null,
            relation: $data[&apos;relation&apos;] ?? null,
            target: $data[&apos;target&apos;] ?? null,
            ordering_key: $data[&apos;ordering-key&apos;] ?? null,
            direction: $data[&apos;direction&apos;] ?? null,
            source_credit: $data[&apos;source-credit&apos;] ?? null,
            target_credit: $data[&apos;target-credit&apos;] ?? null,
            user_genre: $data[&apos;user-genre&apos;] ?? null,
            barcode: $data[&apos;barcode&apos;] ?? null,
            asin: $data[&apos;asin&apos;] ?? null,
            cover_art_archive: $data[&apos;cover-art-archive&apos;] ?? null,
            artwork: $data[&apos;artwork&apos;] ?? null,
            front: $data[&apos;front&apos;] ?? null,
            back: $data[&apos;back&apos;] ?? null,
            darkened: $data[&apos;darkened&apos;] ?? null,
            label_info: $data[&apos;label-info&apos;] ?? null,
            catalog_number: $data[&apos;catalog-number&apos;] ?? null,
            label: $data[&apos;label&apos;] ?? null,
            label_code: $data[&apos;label-code&apos;] ?? null,
            ipi: $data[&apos;ipi&apos;] ?? null,
            isni: $data[&apos;isni&apos;] ?? null,
            rating: $data[&apos;rating&apos;] ?? null,
            votes_count: $data[&apos;votes-count&apos;] ?? null,
            user_rating: $data[&apos;user-rating&apos;] ?? null,
            track_count: $data[&apos;track-count&apos;] ?? null,
            medium: $data[&apos;medium&apos;] ?? null,
            track: $data[&apos;track&apos;] ?? null,
            position: $data[&apos;position&apos;] ?? null,
            number: $data[&apos;number&apos;] ?? null,
            length: $data[&apos;length&apos;] ?? null,
            recording: $data[&apos;recording&apos;] ?? null,
            video: $data[&apos;video&apos;] ?? null,
            puid: $data[&apos;puid&apos;] ?? null,
            isrc: $data[&apos;isrc&apos;] ?? null,
            format: $data[&apos;format&apos;] ?? null,
            disc: $data[&apos;disc&apos;] ?? null,
            sectors: $data[&apos;sectors&apos;] ?? null,
            pregap: $data[&apos;pregap&apos;] ?? null,
            collection: $data[&apos;collection&apos;] ?? null,
            entity_type: $data[&apos;entity-type&apos;] ?? null,
            editor: $data[&apos;editor&apos;] ?? null,
            artist: $data[&apos;artist&apos;] ?? null,
            gender: $data[&apos;gender&apos;] ?? null,
            begin_area: $data[&apos;begin-area&apos;] ?? null,
            end_area: $data[&apos;end-area&apos;] ?? null,
            work: $data[&apos;work&apos;] ?? null,
            fluency: $data[&apos;fluency&apos;] ?? null,
            iswc: $data[&apos;iswc&apos;] ?? null,
            event: $data[&apos;event&apos;] ?? null,
            cancelled: $data[&apos;cancelled&apos;] ?? null,
            time: $data[&apos;time&apos;] ?? null,
            setlist: $data[&apos;setlist&apos;] ?? null,
            instrument: $data[&apos;instrument&apos;] ?? null,
            description: $data[&apos;description&apos;] ?? null,
            place: $data[&apos;place&apos;] ?? null,
            address: $data[&apos;address&apos;] ?? null,
            coordinates: $data[&apos;coordinates&apos;] ?? null,
            latitude: $data[&apos;latitude&apos;] ?? null,
            longitude: $data[&apos;longitude&apos;] ?? null,
            series: $data[&apos;series&apos;] ?? null
        );
    }
}</file><file path="app/Http/Integrations/MusicBrainz/Models/ReleaseEvent.php">&lt;?php
namespace App\Http\Integrations\MusicBrainz\Models;
use Spatie\LaravelData\Data;
class ReleaseEvent extends Data
{
    public function __construct(public mixed $release_event, public mixed $date, public mixed $area, public mixed $id, public mixed $type, public mixed $type_id, public mixed $name, public mixed $sort_name, public mixed $disambiguation, public mixed $iso_3166_1_code, public mixed $iso_3166_2_code, public mixed $iso_3166_3_code, public mixed $annotation, public mixed $text, public mixed $entity, public mixed $life_span, public mixed $begin, public mixed $end, public mixed $ended, public mixed $count, public mixed $offset, public mixed $alias, public mixed $locale, public mixed $primary, public mixed $begin_date, public mixed $end_date, public mixed $tag, public mixed $user_tag, public mixed $genre, public mixed $target_type, public mixed $relation, public mixed $target, public mixed $ordering_key, public mixed $direction, public mixed $source_credit, public mixed $target_credit, public mixed $user_genre)
    {
    }
    public static function fromApiData(array $data): self
    {
        return new self(
            release_event: $data[&apos;release-event&apos;] ?? null,
            date: $data[&apos;date&apos;] ?? null,
            area: $data[&apos;area&apos;] ?? null,
            id: $data[&apos;id&apos;] ?? null,
            type: $data[&apos;type&apos;] ?? null,
            type_id: $data[&apos;type-id&apos;] ?? null,
            name: $data[&apos;name&apos;] ?? null,
            sort_name: $data[&apos;sort-name&apos;] ?? null,
            disambiguation: $data[&apos;disambiguation&apos;] ?? null,
            iso_3166_1_code: $data[&apos;iso-3166-1-code&apos;] ?? null,
            iso_3166_2_code: $data[&apos;iso-3166-2-code&apos;] ?? null,
            iso_3166_3_code: $data[&apos;iso-3166-3-code&apos;] ?? null,
            annotation: $data[&apos;annotation&apos;] ?? null,
            text: $data[&apos;text&apos;] ?? null,
            entity: $data[&apos;entity&apos;] ?? null,
            life_span: $data[&apos;life-span&apos;] ?? null,
            begin: $data[&apos;begin&apos;] ?? null,
            end: $data[&apos;end&apos;] ?? null,
            ended: $data[&apos;ended&apos;] ?? null,
            count: $data[&apos;count&apos;] ?? null,
            offset: $data[&apos;offset&apos;] ?? null,
            alias: $data[&apos;alias&apos;] ?? null,
            locale: $data[&apos;locale&apos;] ?? null,
            primary: $data[&apos;primary&apos;] ?? null,
            begin_date: $data[&apos;begin-date&apos;] ?? null,
            end_date: $data[&apos;end-date&apos;] ?? null,
            tag: $data[&apos;tag&apos;] ?? null,
            user_tag: $data[&apos;user-tag&apos;] ?? null,
            genre: $data[&apos;genre&apos;] ?? null,
            target_type: $data[&apos;target-type&apos;] ?? null,
            relation: $data[&apos;relation&apos;] ?? null,
            target: $data[&apos;target&apos;] ?? null,
            ordering_key: $data[&apos;ordering-key&apos;] ?? null,
            direction: $data[&apos;direction&apos;] ?? null,
            source_credit: $data[&apos;source-credit&apos;] ?? null,
            target_credit: $data[&apos;target-credit&apos;] ?? null,
            user_genre: $data[&apos;user-genre&apos;] ?? null
        );
    }
}</file><file path="app/Http/Integrations/MusicBrainz/Models/ReleaseEventList.php">&lt;?php
namespace App\Http\Integrations\MusicBrainz\Models;
use Spatie\LaravelData\Data;
class ReleaseEventList extends Data
{
    public function __construct(public mixed $count, public mixed $offset, public mixed $release_event, public mixed $date, public mixed $area, public mixed $id, public mixed $type, public mixed $type_id, public mixed $name, public mixed $sort_name, public mixed $disambiguation, public mixed $iso_3166_1_code, public mixed $iso_3166_2_code, public mixed $iso_3166_3_code, public mixed $annotation, public mixed $text, public mixed $entity, public mixed $life_span, public mixed $begin, public mixed $end, public mixed $ended, public mixed $alias, public mixed $locale, public mixed $primary, public mixed $begin_date, public mixed $end_date, public mixed $tag, public mixed $user_tag, public mixed $genre, public mixed $target_type, public mixed $relation, public mixed $target, public mixed $ordering_key, public mixed $direction, public mixed $source_credit, public mixed $target_credit, public mixed $user_genre)
    {
    }
    public static function fromApiData(array $data): self
    {
        return new self(
            count: $data[&apos;count&apos;] ?? null,
            offset: $data[&apos;offset&apos;] ?? null,
            release_event: $data[&apos;release-event&apos;] ?? null,
            date: $data[&apos;date&apos;] ?? null,
            area: $data[&apos;area&apos;] ?? null,
            id: $data[&apos;id&apos;] ?? null,
            type: $data[&apos;type&apos;] ?? null,
            type_id: $data[&apos;type-id&apos;] ?? null,
            name: $data[&apos;name&apos;] ?? null,
            sort_name: $data[&apos;sort-name&apos;] ?? null,
            disambiguation: $data[&apos;disambiguation&apos;] ?? null,
            iso_3166_1_code: $data[&apos;iso-3166-1-code&apos;] ?? null,
            iso_3166_2_code: $data[&apos;iso-3166-2-code&apos;] ?? null,
            iso_3166_3_code: $data[&apos;iso-3166-3-code&apos;] ?? null,
            annotation: $data[&apos;annotation&apos;] ?? null,
            text: $data[&apos;text&apos;] ?? null,
            entity: $data[&apos;entity&apos;] ?? null,
            life_span: $data[&apos;life-span&apos;] ?? null,
            begin: $data[&apos;begin&apos;] ?? null,
            end: $data[&apos;end&apos;] ?? null,
            ended: $data[&apos;ended&apos;] ?? null,
            alias: $data[&apos;alias&apos;] ?? null,
            locale: $data[&apos;locale&apos;] ?? null,
            primary: $data[&apos;primary&apos;] ?? null,
            begin_date: $data[&apos;begin-date&apos;] ?? null,
            end_date: $data[&apos;end-date&apos;] ?? null,
            tag: $data[&apos;tag&apos;] ?? null,
            user_tag: $data[&apos;user-tag&apos;] ?? null,
            genre: $data[&apos;genre&apos;] ?? null,
            target_type: $data[&apos;target-type&apos;] ?? null,
            relation: $data[&apos;relation&apos;] ?? null,
            target: $data[&apos;target&apos;] ?? null,
            ordering_key: $data[&apos;ordering-key&apos;] ?? null,
            direction: $data[&apos;direction&apos;] ?? null,
            source_credit: $data[&apos;source-credit&apos;] ?? null,
            target_credit: $data[&apos;target-credit&apos;] ?? null,
            user_genre: $data[&apos;user-genre&apos;] ?? null
        );
    }
}</file><file path="app/Http/Integrations/MusicBrainz/Models/ReleaseGroup.php">&lt;?php
namespace App\Http\Integrations\MusicBrainz\Models;
use Spatie\LaravelData\Data;
class ReleaseGroup extends Data
{
    public function __construct(public mixed $release_group, public mixed $id, public mixed $type, public mixed $type_id, public mixed $title, public mixed $annotation, public mixed $text, public mixed $entity, public mixed $name, public mixed $disambiguation, public mixed $first_release_date, public mixed $primary_type, public mixed $secondary_type, public mixed $artist_credit, public mixed $count, public mixed $offset, public mixed $release, public mixed $status, public mixed $quality, public mixed $packaging, public mixed $text_representation, public mixed $language, public mixed $script, public mixed $alias, public mixed $locale, public mixed $sort_name, public mixed $primary, public mixed $begin_date, public mixed $end_date, public mixed $tag, public mixed $user_tag, public mixed $genre, public mixed $target_type, public mixed $relation, public mixed $target, public mixed $ordering_key, public mixed $direction, public mixed $begin, public mixed $end, public mixed $ended, public mixed $source_credit, public mixed $target_credit, public mixed $user_genre, public mixed $rating, public mixed $votes_count, public mixed $user_rating, public mixed $date, public mixed $country, public mixed $release_event, public mixed $area, public mixed $iso_3166_1_code, public mixed $iso_3166_2_code, public mixed $iso_3166_3_code, public mixed $life_span, public mixed $barcode, public mixed $asin, public mixed $cover_art_archive, public mixed $artwork, public mixed $front, public mixed $back, public mixed $darkened, public mixed $label_info, public mixed $catalog_number, public mixed $label, public mixed $label_code, public mixed $ipi, public mixed $isni, public mixed $track_count, public mixed $medium, public mixed $track, public mixed $position, public mixed $number, public mixed $length, public mixed $recording, public mixed $video, public mixed $puid, public mixed $isrc, public mixed $format, public mixed $disc, public mixed $sectors, public mixed $pregap, public mixed $collection, public mixed $entity_type, public mixed $editor, public mixed $artist, public mixed $gender, public mixed $begin_area, public mixed $end_area, public mixed $work, public mixed $fluency, public mixed $iswc, public mixed $event, public mixed $cancelled, public mixed $time, public mixed $setlist, public mixed $instrument, public mixed $description, public mixed $place, public mixed $address, public mixed $coordinates, public mixed $latitude, public mixed $longitude, public mixed $series)
    {
    }
    public static function fromApiData(array $data): self
    {
        return new self(
            release_group: $data[&apos;release-group&apos;] ?? null,
            id: $data[&apos;id&apos;] ?? null,
            type: $data[&apos;type&apos;] ?? null,
            type_id: $data[&apos;type-id&apos;] ?? null,
            title: $data[&apos;title&apos;] ?? null,
            annotation: $data[&apos;annotation&apos;] ?? null,
            text: $data[&apos;text&apos;] ?? null,
            entity: $data[&apos;entity&apos;] ?? null,
            name: $data[&apos;name&apos;] ?? null,
            disambiguation: $data[&apos;disambiguation&apos;] ?? null,
            first_release_date: $data[&apos;first-release-date&apos;] ?? null,
            primary_type: $data[&apos;primary-type&apos;] ?? null,
            secondary_type: $data[&apos;secondary-type&apos;] ?? null,
            artist_credit: $data[&apos;artist-credit&apos;] ?? null,
            count: $data[&apos;count&apos;] ?? null,
            offset: $data[&apos;offset&apos;] ?? null,
            release: $data[&apos;release&apos;] ?? null,
            status: $data[&apos;status&apos;] ?? null,
            quality: $data[&apos;quality&apos;] ?? null,
            packaging: $data[&apos;packaging&apos;] ?? null,
            text_representation: $data[&apos;text-representation&apos;] ?? null,
            language: $data[&apos;language&apos;] ?? null,
            script: $data[&apos;script&apos;] ?? null,
            alias: $data[&apos;alias&apos;] ?? null,
            locale: $data[&apos;locale&apos;] ?? null,
            sort_name: $data[&apos;sort-name&apos;] ?? null,
            primary: $data[&apos;primary&apos;] ?? null,
            begin_date: $data[&apos;begin-date&apos;] ?? null,
            end_date: $data[&apos;end-date&apos;] ?? null,
            tag: $data[&apos;tag&apos;] ?? null,
            user_tag: $data[&apos;user-tag&apos;] ?? null,
            genre: $data[&apos;genre&apos;] ?? null,
            target_type: $data[&apos;target-type&apos;] ?? null,
            relation: $data[&apos;relation&apos;] ?? null,
            target: $data[&apos;target&apos;] ?? null,
            ordering_key: $data[&apos;ordering-key&apos;] ?? null,
            direction: $data[&apos;direction&apos;] ?? null,
            begin: $data[&apos;begin&apos;] ?? null,
            end: $data[&apos;end&apos;] ?? null,
            ended: $data[&apos;ended&apos;] ?? null,
            source_credit: $data[&apos;source-credit&apos;] ?? null,
            target_credit: $data[&apos;target-credit&apos;] ?? null,
            user_genre: $data[&apos;user-genre&apos;] ?? null,
            rating: $data[&apos;rating&apos;] ?? null,
            votes_count: $data[&apos;votes-count&apos;] ?? null,
            user_rating: $data[&apos;user-rating&apos;] ?? null,
            date: $data[&apos;date&apos;] ?? null,
            country: $data[&apos;country&apos;] ?? null,
            release_event: $data[&apos;release-event&apos;] ?? null,
            area: $data[&apos;area&apos;] ?? null,
            iso_3166_1_code: $data[&apos;iso-3166-1-code&apos;] ?? null,
            iso_3166_2_code: $data[&apos;iso-3166-2-code&apos;] ?? null,
            iso_3166_3_code: $data[&apos;iso-3166-3-code&apos;] ?? null,
            life_span: $data[&apos;life-span&apos;] ?? null,
            barcode: $data[&apos;barcode&apos;] ?? null,
            asin: $data[&apos;asin&apos;] ?? null,
            cover_art_archive: $data[&apos;cover-art-archive&apos;] ?? null,
            artwork: $data[&apos;artwork&apos;] ?? null,
            front: $data[&apos;front&apos;] ?? null,
            back: $data[&apos;back&apos;] ?? null,
            darkened: $data[&apos;darkened&apos;] ?? null,
            label_info: $data[&apos;label-info&apos;] ?? null,
            catalog_number: $data[&apos;catalog-number&apos;] ?? null,
            label: $data[&apos;label&apos;] ?? null,
            label_code: $data[&apos;label-code&apos;] ?? null,
            ipi: $data[&apos;ipi&apos;] ?? null,
            isni: $data[&apos;isni&apos;] ?? null,
            track_count: $data[&apos;track-count&apos;] ?? null,
            medium: $data[&apos;medium&apos;] ?? null,
            track: $data[&apos;track&apos;] ?? null,
            position: $data[&apos;position&apos;] ?? null,
            number: $data[&apos;number&apos;] ?? null,
            length: $data[&apos;length&apos;] ?? null,
            recording: $data[&apos;recording&apos;] ?? null,
            video: $data[&apos;video&apos;] ?? null,
            puid: $data[&apos;puid&apos;] ?? null,
            isrc: $data[&apos;isrc&apos;] ?? null,
            format: $data[&apos;format&apos;] ?? null,
            disc: $data[&apos;disc&apos;] ?? null,
            sectors: $data[&apos;sectors&apos;] ?? null,
            pregap: $data[&apos;pregap&apos;] ?? null,
            collection: $data[&apos;collection&apos;] ?? null,
            entity_type: $data[&apos;entity-type&apos;] ?? null,
            editor: $data[&apos;editor&apos;] ?? null,
            artist: $data[&apos;artist&apos;] ?? null,
            gender: $data[&apos;gender&apos;] ?? null,
            begin_area: $data[&apos;begin-area&apos;] ?? null,
            end_area: $data[&apos;end-area&apos;] ?? null,
            work: $data[&apos;work&apos;] ?? null,
            fluency: $data[&apos;fluency&apos;] ?? null,
            iswc: $data[&apos;iswc&apos;] ?? null,
            event: $data[&apos;event&apos;] ?? null,
            cancelled: $data[&apos;cancelled&apos;] ?? null,
            time: $data[&apos;time&apos;] ?? null,
            setlist: $data[&apos;setlist&apos;] ?? null,
            instrument: $data[&apos;instrument&apos;] ?? null,
            description: $data[&apos;description&apos;] ?? null,
            place: $data[&apos;place&apos;] ?? null,
            address: $data[&apos;address&apos;] ?? null,
            coordinates: $data[&apos;coordinates&apos;] ?? null,
            latitude: $data[&apos;latitude&apos;] ?? null,
            longitude: $data[&apos;longitude&apos;] ?? null,
            series: $data[&apos;series&apos;] ?? null
        );
    }
}</file><file path="app/Http/Integrations/MusicBrainz/Models/ReleaseGroupList.php">&lt;?php
namespace App\Http\Integrations\MusicBrainz\Models;
use Spatie\LaravelData\Data;
class ReleaseGroupList extends Data
{
    public function __construct(public mixed $count, public mixed $offset, public mixed $release_group, public mixed $id, public mixed $type, public mixed $type_id, public mixed $title, public mixed $annotation, public mixed $text, public mixed $entity, public mixed $name, public mixed $disambiguation, public mixed $first_release_date, public mixed $primary_type, public mixed $secondary_type, public mixed $artist_credit, public mixed $release, public mixed $status, public mixed $quality, public mixed $packaging, public mixed $text_representation, public mixed $language, public mixed $script, public mixed $alias, public mixed $locale, public mixed $sort_name, public mixed $primary, public mixed $begin_date, public mixed $end_date, public mixed $date, public mixed $country, public mixed $release_event, public mixed $area, public mixed $iso_3166_1_code, public mixed $iso_3166_2_code, public mixed $iso_3166_3_code, public mixed $life_span, public mixed $begin, public mixed $end, public mixed $ended, public mixed $tag, public mixed $user_tag, public mixed $genre, public mixed $target_type, public mixed $relation, public mixed $target, public mixed $ordering_key, public mixed $direction, public mixed $source_credit, public mixed $target_credit, public mixed $user_genre, public mixed $barcode, public mixed $asin, public mixed $cover_art_archive, public mixed $artwork, public mixed $front, public mixed $back, public mixed $darkened, public mixed $label_info, public mixed $catalog_number, public mixed $label, public mixed $label_code, public mixed $ipi, public mixed $isni, public mixed $rating, public mixed $votes_count, public mixed $user_rating, public mixed $track_count, public mixed $medium, public mixed $track, public mixed $position, public mixed $number, public mixed $length, public mixed $recording, public mixed $video, public mixed $puid, public mixed $isrc, public mixed $format, public mixed $disc, public mixed $sectors, public mixed $pregap, public mixed $collection, public mixed $entity_type, public mixed $editor, public mixed $artist, public mixed $gender, public mixed $begin_area, public mixed $end_area, public mixed $work, public mixed $fluency, public mixed $iswc, public mixed $event, public mixed $cancelled, public mixed $time, public mixed $setlist, public mixed $instrument, public mixed $description, public mixed $place, public mixed $address, public mixed $coordinates, public mixed $latitude, public mixed $longitude, public mixed $series)
    {
    }
    public static function fromApiData(array $data): self
    {
        return new self(
            count: $data[&apos;count&apos;] ?? null,
            offset: $data[&apos;offset&apos;] ?? null,
            release_group: $data[&apos;release-group&apos;] ?? null,
            id: $data[&apos;id&apos;] ?? null,
            type: $data[&apos;type&apos;] ?? null,
            type_id: $data[&apos;type-id&apos;] ?? null,
            title: $data[&apos;title&apos;] ?? null,
            annotation: $data[&apos;annotation&apos;] ?? null,
            text: $data[&apos;text&apos;] ?? null,
            entity: $data[&apos;entity&apos;] ?? null,
            name: $data[&apos;name&apos;] ?? null,
            disambiguation: $data[&apos;disambiguation&apos;] ?? null,
            first_release_date: $data[&apos;first-release-date&apos;] ?? null,
            primary_type: $data[&apos;primary-type&apos;] ?? null,
            secondary_type: $data[&apos;secondary-type&apos;] ?? null,
            artist_credit: $data[&apos;artist-credit&apos;] ?? null,
            release: $data[&apos;release&apos;] ?? null,
            status: $data[&apos;status&apos;] ?? null,
            quality: $data[&apos;quality&apos;] ?? null,
            packaging: $data[&apos;packaging&apos;] ?? null,
            text_representation: $data[&apos;text-representation&apos;] ?? null,
            language: $data[&apos;language&apos;] ?? null,
            script: $data[&apos;script&apos;] ?? null,
            alias: $data[&apos;alias&apos;] ?? null,
            locale: $data[&apos;locale&apos;] ?? null,
            sort_name: $data[&apos;sort-name&apos;] ?? null,
            primary: $data[&apos;primary&apos;] ?? null,
            begin_date: $data[&apos;begin-date&apos;] ?? null,
            end_date: $data[&apos;end-date&apos;] ?? null,
            date: $data[&apos;date&apos;] ?? null,
            country: $data[&apos;country&apos;] ?? null,
            release_event: $data[&apos;release-event&apos;] ?? null,
            area: $data[&apos;area&apos;] ?? null,
            iso_3166_1_code: $data[&apos;iso-3166-1-code&apos;] ?? null,
            iso_3166_2_code: $data[&apos;iso-3166-2-code&apos;] ?? null,
            iso_3166_3_code: $data[&apos;iso-3166-3-code&apos;] ?? null,
            life_span: $data[&apos;life-span&apos;] ?? null,
            begin: $data[&apos;begin&apos;] ?? null,
            end: $data[&apos;end&apos;] ?? null,
            ended: $data[&apos;ended&apos;] ?? null,
            tag: $data[&apos;tag&apos;] ?? null,
            user_tag: $data[&apos;user-tag&apos;] ?? null,
            genre: $data[&apos;genre&apos;] ?? null,
            target_type: $data[&apos;target-type&apos;] ?? null,
            relation: $data[&apos;relation&apos;] ?? null,
            target: $data[&apos;target&apos;] ?? null,
            ordering_key: $data[&apos;ordering-key&apos;] ?? null,
            direction: $data[&apos;direction&apos;] ?? null,
            source_credit: $data[&apos;source-credit&apos;] ?? null,
            target_credit: $data[&apos;target-credit&apos;] ?? null,
            user_genre: $data[&apos;user-genre&apos;] ?? null,
            barcode: $data[&apos;barcode&apos;] ?? null,
            asin: $data[&apos;asin&apos;] ?? null,
            cover_art_archive: $data[&apos;cover-art-archive&apos;] ?? null,
            artwork: $data[&apos;artwork&apos;] ?? null,
            front: $data[&apos;front&apos;] ?? null,
            back: $data[&apos;back&apos;] ?? null,
            darkened: $data[&apos;darkened&apos;] ?? null,
            label_info: $data[&apos;label-info&apos;] ?? null,
            catalog_number: $data[&apos;catalog-number&apos;] ?? null,
            label: $data[&apos;label&apos;] ?? null,
            label_code: $data[&apos;label-code&apos;] ?? null,
            ipi: $data[&apos;ipi&apos;] ?? null,
            isni: $data[&apos;isni&apos;] ?? null,
            rating: $data[&apos;rating&apos;] ?? null,
            votes_count: $data[&apos;votes-count&apos;] ?? null,
            user_rating: $data[&apos;user-rating&apos;] ?? null,
            track_count: $data[&apos;track-count&apos;] ?? null,
            medium: $data[&apos;medium&apos;] ?? null,
            track: $data[&apos;track&apos;] ?? null,
            position: $data[&apos;position&apos;] ?? null,
            number: $data[&apos;number&apos;] ?? null,
            length: $data[&apos;length&apos;] ?? null,
            recording: $data[&apos;recording&apos;] ?? null,
            video: $data[&apos;video&apos;] ?? null,
            puid: $data[&apos;puid&apos;] ?? null,
            isrc: $data[&apos;isrc&apos;] ?? null,
            format: $data[&apos;format&apos;] ?? null,
            disc: $data[&apos;disc&apos;] ?? null,
            sectors: $data[&apos;sectors&apos;] ?? null,
            pregap: $data[&apos;pregap&apos;] ?? null,
            collection: $data[&apos;collection&apos;] ?? null,
            entity_type: $data[&apos;entity-type&apos;] ?? null,
            editor: $data[&apos;editor&apos;] ?? null,
            artist: $data[&apos;artist&apos;] ?? null,
            gender: $data[&apos;gender&apos;] ?? null,
            begin_area: $data[&apos;begin-area&apos;] ?? null,
            end_area: $data[&apos;end-area&apos;] ?? null,
            work: $data[&apos;work&apos;] ?? null,
            fluency: $data[&apos;fluency&apos;] ?? null,
            iswc: $data[&apos;iswc&apos;] ?? null,
            event: $data[&apos;event&apos;] ?? null,
            cancelled: $data[&apos;cancelled&apos;] ?? null,
            time: $data[&apos;time&apos;] ?? null,
            setlist: $data[&apos;setlist&apos;] ?? null,
            instrument: $data[&apos;instrument&apos;] ?? null,
            description: $data[&apos;description&apos;] ?? null,
            place: $data[&apos;place&apos;] ?? null,
            address: $data[&apos;address&apos;] ?? null,
            coordinates: $data[&apos;coordinates&apos;] ?? null,
            latitude: $data[&apos;latitude&apos;] ?? null,
            longitude: $data[&apos;longitude&apos;] ?? null,
            series: $data[&apos;series&apos;] ?? null
        );
    }
}</file><file path="app/Http/Integrations/MusicBrainz/Models/ReleaseList.php">&lt;?php
namespace App\Http\Integrations\MusicBrainz\Models;
use Spatie\LaravelData\Data;
class ReleaseList extends Data
{
    public function __construct(public mixed $count, public mixed $offset, public mixed $release, public mixed $id, public mixed $title, public mixed $status, public mixed $quality, public mixed $annotation, public mixed $text, public mixed $type, public mixed $entity, public mixed $name, public mixed $disambiguation, public mixed $packaging, public mixed $text_representation, public mixed $language, public mixed $script, public mixed $artist_credit, public mixed $alias, public mixed $locale, public mixed $sort_name, public mixed $type_id, public mixed $primary, public mixed $begin_date, public mixed $end_date, public mixed $release_group, public mixed $first_release_date, public mixed $primary_type, public mixed $secondary_type, public mixed $tag, public mixed $user_tag, public mixed $genre, public mixed $target_type, public mixed $relation, public mixed $target, public mixed $ordering_key, public mixed $direction, public mixed $begin, public mixed $end, public mixed $ended, public mixed $source_credit, public mixed $target_credit, public mixed $user_genre, public mixed $rating, public mixed $votes_count, public mixed $user_rating, public mixed $date, public mixed $country, public mixed $release_event, public mixed $area, public mixed $iso_3166_1_code, public mixed $iso_3166_2_code, public mixed $iso_3166_3_code, public mixed $life_span, public mixed $barcode, public mixed $asin, public mixed $cover_art_archive, public mixed $artwork, public mixed $front, public mixed $back, public mixed $darkened, public mixed $label_info, public mixed $catalog_number, public mixed $label, public mixed $label_code, public mixed $ipi, public mixed $isni, public mixed $track_count, public mixed $medium, public mixed $track, public mixed $position, public mixed $number, public mixed $length, public mixed $recording, public mixed $video, public mixed $puid, public mixed $isrc, public mixed $format, public mixed $disc, public mixed $sectors, public mixed $pregap, public mixed $collection, public mixed $entity_type, public mixed $editor, public mixed $artist, public mixed $gender, public mixed $begin_area, public mixed $end_area, public mixed $work, public mixed $fluency, public mixed $iswc, public mixed $event, public mixed $cancelled, public mixed $time, public mixed $setlist, public mixed $instrument, public mixed $description, public mixed $place, public mixed $address, public mixed $coordinates, public mixed $latitude, public mixed $longitude, public mixed $series)
    {
    }
    public static function fromApiData(array $data): self
    {
        return new self(
            count: $data[&apos;count&apos;] ?? null,
            offset: $data[&apos;offset&apos;] ?? null,
            release: $data[&apos;release&apos;] ?? null,
            id: $data[&apos;id&apos;] ?? null,
            title: $data[&apos;title&apos;] ?? null,
            status: $data[&apos;status&apos;] ?? null,
            quality: $data[&apos;quality&apos;] ?? null,
            annotation: $data[&apos;annotation&apos;] ?? null,
            text: $data[&apos;text&apos;] ?? null,
            type: $data[&apos;type&apos;] ?? null,
            entity: $data[&apos;entity&apos;] ?? null,
            name: $data[&apos;name&apos;] ?? null,
            disambiguation: $data[&apos;disambiguation&apos;] ?? null,
            packaging: $data[&apos;packaging&apos;] ?? null,
            text_representation: $data[&apos;text-representation&apos;] ?? null,
            language: $data[&apos;language&apos;] ?? null,
            script: $data[&apos;script&apos;] ?? null,
            artist_credit: $data[&apos;artist-credit&apos;] ?? null,
            alias: $data[&apos;alias&apos;] ?? null,
            locale: $data[&apos;locale&apos;] ?? null,
            sort_name: $data[&apos;sort-name&apos;] ?? null,
            type_id: $data[&apos;type-id&apos;] ?? null,
            primary: $data[&apos;primary&apos;] ?? null,
            begin_date: $data[&apos;begin-date&apos;] ?? null,
            end_date: $data[&apos;end-date&apos;] ?? null,
            release_group: $data[&apos;release-group&apos;] ?? null,
            first_release_date: $data[&apos;first-release-date&apos;] ?? null,
            primary_type: $data[&apos;primary-type&apos;] ?? null,
            secondary_type: $data[&apos;secondary-type&apos;] ?? null,
            tag: $data[&apos;tag&apos;] ?? null,
            user_tag: $data[&apos;user-tag&apos;] ?? null,
            genre: $data[&apos;genre&apos;] ?? null,
            target_type: $data[&apos;target-type&apos;] ?? null,
            relation: $data[&apos;relation&apos;] ?? null,
            target: $data[&apos;target&apos;] ?? null,
            ordering_key: $data[&apos;ordering-key&apos;] ?? null,
            direction: $data[&apos;direction&apos;] ?? null,
            begin: $data[&apos;begin&apos;] ?? null,
            end: $data[&apos;end&apos;] ?? null,
            ended: $data[&apos;ended&apos;] ?? null,
            source_credit: $data[&apos;source-credit&apos;] ?? null,
            target_credit: $data[&apos;target-credit&apos;] ?? null,
            user_genre: $data[&apos;user-genre&apos;] ?? null,
            rating: $data[&apos;rating&apos;] ?? null,
            votes_count: $data[&apos;votes-count&apos;] ?? null,
            user_rating: $data[&apos;user-rating&apos;] ?? null,
            date: $data[&apos;date&apos;] ?? null,
            country: $data[&apos;country&apos;] ?? null,
            release_event: $data[&apos;release-event&apos;] ?? null,
            area: $data[&apos;area&apos;] ?? null,
            iso_3166_1_code: $data[&apos;iso-3166-1-code&apos;] ?? null,
            iso_3166_2_code: $data[&apos;iso-3166-2-code&apos;] ?? null,
            iso_3166_3_code: $data[&apos;iso-3166-3-code&apos;] ?? null,
            life_span: $data[&apos;life-span&apos;] ?? null,
            barcode: $data[&apos;barcode&apos;] ?? null,
            asin: $data[&apos;asin&apos;] ?? null,
            cover_art_archive: $data[&apos;cover-art-archive&apos;] ?? null,
            artwork: $data[&apos;artwork&apos;] ?? null,
            front: $data[&apos;front&apos;] ?? null,
            back: $data[&apos;back&apos;] ?? null,
            darkened: $data[&apos;darkened&apos;] ?? null,
            label_info: $data[&apos;label-info&apos;] ?? null,
            catalog_number: $data[&apos;catalog-number&apos;] ?? null,
            label: $data[&apos;label&apos;] ?? null,
            label_code: $data[&apos;label-code&apos;] ?? null,
            ipi: $data[&apos;ipi&apos;] ?? null,
            isni: $data[&apos;isni&apos;] ?? null,
            track_count: $data[&apos;track-count&apos;] ?? null,
            medium: $data[&apos;medium&apos;] ?? null,
            track: $data[&apos;track&apos;] ?? null,
            position: $data[&apos;position&apos;] ?? null,
            number: $data[&apos;number&apos;] ?? null,
            length: $data[&apos;length&apos;] ?? null,
            recording: $data[&apos;recording&apos;] ?? null,
            video: $data[&apos;video&apos;] ?? null,
            puid: $data[&apos;puid&apos;] ?? null,
            isrc: $data[&apos;isrc&apos;] ?? null,
            format: $data[&apos;format&apos;] ?? null,
            disc: $data[&apos;disc&apos;] ?? null,
            sectors: $data[&apos;sectors&apos;] ?? null,
            pregap: $data[&apos;pregap&apos;] ?? null,
            collection: $data[&apos;collection&apos;] ?? null,
            entity_type: $data[&apos;entity-type&apos;] ?? null,
            editor: $data[&apos;editor&apos;] ?? null,
            artist: $data[&apos;artist&apos;] ?? null,
            gender: $data[&apos;gender&apos;] ?? null,
            begin_area: $data[&apos;begin-area&apos;] ?? null,
            end_area: $data[&apos;end-area&apos;] ?? null,
            work: $data[&apos;work&apos;] ?? null,
            fluency: $data[&apos;fluency&apos;] ?? null,
            iswc: $data[&apos;iswc&apos;] ?? null,
            event: $data[&apos;event&apos;] ?? null,
            cancelled: $data[&apos;cancelled&apos;] ?? null,
            time: $data[&apos;time&apos;] ?? null,
            setlist: $data[&apos;setlist&apos;] ?? null,
            instrument: $data[&apos;instrument&apos;] ?? null,
            description: $data[&apos;description&apos;] ?? null,
            place: $data[&apos;place&apos;] ?? null,
            address: $data[&apos;address&apos;] ?? null,
            coordinates: $data[&apos;coordinates&apos;] ?? null,
            latitude: $data[&apos;latitude&apos;] ?? null,
            longitude: $data[&apos;longitude&apos;] ?? null,
            series: $data[&apos;series&apos;] ?? null
        );
    }
}</file><file path="app/Http/Integrations/MusicBrainz/Models/Series.php">&lt;?php
namespace App\Http\Integrations\MusicBrainz\Models;
use Spatie\LaravelData\Data;
class Series extends Data
{
    public function __construct(public mixed $series, public mixed $id, public mixed $type, public mixed $type_id, public mixed $name, public mixed $disambiguation, public mixed $annotation, public mixed $text, public mixed $entity, public mixed $count, public mixed $offset, public mixed $alias, public mixed $locale, public mixed $sort_name, public mixed $primary, public mixed $begin_date, public mixed $end_date, public mixed $tag, public mixed $user_tag, public mixed $genre, public mixed $target_type, public mixed $relation, public mixed $target, public mixed $ordering_key, public mixed $direction, public mixed $begin, public mixed $end, public mixed $ended, public mixed $source_credit, public mixed $target_credit, public mixed $user_genre)
    {
    }
    public static function fromApiData(array $data): self
    {
        return new self(
            series: $data[&apos;series&apos;] ?? null,
            id: $data[&apos;id&apos;] ?? null,
            type: $data[&apos;type&apos;] ?? null,
            type_id: $data[&apos;type-id&apos;] ?? null,
            name: $data[&apos;name&apos;] ?? null,
            disambiguation: $data[&apos;disambiguation&apos;] ?? null,
            annotation: $data[&apos;annotation&apos;] ?? null,
            text: $data[&apos;text&apos;] ?? null,
            entity: $data[&apos;entity&apos;] ?? null,
            count: $data[&apos;count&apos;] ?? null,
            offset: $data[&apos;offset&apos;] ?? null,
            alias: $data[&apos;alias&apos;] ?? null,
            locale: $data[&apos;locale&apos;] ?? null,
            sort_name: $data[&apos;sort-name&apos;] ?? null,
            primary: $data[&apos;primary&apos;] ?? null,
            begin_date: $data[&apos;begin-date&apos;] ?? null,
            end_date: $data[&apos;end-date&apos;] ?? null,
            tag: $data[&apos;tag&apos;] ?? null,
            user_tag: $data[&apos;user-tag&apos;] ?? null,
            genre: $data[&apos;genre&apos;] ?? null,
            target_type: $data[&apos;target-type&apos;] ?? null,
            relation: $data[&apos;relation&apos;] ?? null,
            target: $data[&apos;target&apos;] ?? null,
            ordering_key: $data[&apos;ordering-key&apos;] ?? null,
            direction: $data[&apos;direction&apos;] ?? null,
            begin: $data[&apos;begin&apos;] ?? null,
            end: $data[&apos;end&apos;] ?? null,
            ended: $data[&apos;ended&apos;] ?? null,
            source_credit: $data[&apos;source-credit&apos;] ?? null,
            target_credit: $data[&apos;target-credit&apos;] ?? null,
            user_genre: $data[&apos;user-genre&apos;] ?? null
        );
    }
}</file><file path="app/Http/Integrations/MusicBrainz/Models/SeriesList.php">&lt;?php
namespace App\Http\Integrations\MusicBrainz\Models;
use Spatie\LaravelData\Data;
class SeriesList extends Data
{
    public function __construct(public mixed $count, public mixed $offset, public mixed $series, public mixed $id, public mixed $type, public mixed $type_id, public mixed $name, public mixed $disambiguation, public mixed $annotation, public mixed $text, public mixed $entity, public mixed $alias, public mixed $locale, public mixed $sort_name, public mixed $primary, public mixed $begin_date, public mixed $end_date, public mixed $tag, public mixed $user_tag, public mixed $genre, public mixed $target_type, public mixed $relation, public mixed $target, public mixed $ordering_key, public mixed $direction, public mixed $begin, public mixed $end, public mixed $ended, public mixed $source_credit, public mixed $target_credit, public mixed $user_genre)
    {
    }
    public static function fromApiData(array $data): self
    {
        return new self(
            count: $data[&apos;count&apos;] ?? null,
            offset: $data[&apos;offset&apos;] ?? null,
            series: $data[&apos;series&apos;] ?? null,
            id: $data[&apos;id&apos;] ?? null,
            type: $data[&apos;type&apos;] ?? null,
            type_id: $data[&apos;type-id&apos;] ?? null,
            name: $data[&apos;name&apos;] ?? null,
            disambiguation: $data[&apos;disambiguation&apos;] ?? null,
            annotation: $data[&apos;annotation&apos;] ?? null,
            text: $data[&apos;text&apos;] ?? null,
            entity: $data[&apos;entity&apos;] ?? null,
            alias: $data[&apos;alias&apos;] ?? null,
            locale: $data[&apos;locale&apos;] ?? null,
            sort_name: $data[&apos;sort-name&apos;] ?? null,
            primary: $data[&apos;primary&apos;] ?? null,
            begin_date: $data[&apos;begin-date&apos;] ?? null,
            end_date: $data[&apos;end-date&apos;] ?? null,
            tag: $data[&apos;tag&apos;] ?? null,
            user_tag: $data[&apos;user-tag&apos;] ?? null,
            genre: $data[&apos;genre&apos;] ?? null,
            target_type: $data[&apos;target-type&apos;] ?? null,
            relation: $data[&apos;relation&apos;] ?? null,
            target: $data[&apos;target&apos;] ?? null,
            ordering_key: $data[&apos;ordering-key&apos;] ?? null,
            direction: $data[&apos;direction&apos;] ?? null,
            begin: $data[&apos;begin&apos;] ?? null,
            end: $data[&apos;end&apos;] ?? null,
            ended: $data[&apos;ended&apos;] ?? null,
            source_credit: $data[&apos;source-credit&apos;] ?? null,
            target_credit: $data[&apos;target-credit&apos;] ?? null,
            user_genre: $data[&apos;user-genre&apos;] ?? null
        );
    }
}</file><file path="app/Http/Integrations/MusicBrainz/Models/Tag.php">&lt;?php
namespace App\Http\Integrations\MusicBrainz\Models;
use Spatie\LaravelData\Data;
class Tag extends Data
{
    public function __construct(public mixed $name, public mixed $count)
    {
    }
    public static function fromApiData(array $data): self
    {
        return new self(
            name: $data[&apos;name&apos;] ?? null,
            count: $data[&apos;count&apos;] ?? null
        );
    }
}</file><file path="app/Http/Integrations/MusicBrainz/Models/TagList.php">&lt;?php
namespace App\Http\Integrations\MusicBrainz\Models;
use Spatie\LaravelData\Data;
class TagList extends Data
{
    public function __construct(public mixed $count, public mixed $offset, public mixed $tag, public mixed $name)
    {
    }
    public static function fromApiData(array $data): self
    {
        return new self(
            count: $data[&apos;count&apos;] ?? null,
            offset: $data[&apos;offset&apos;] ?? null,
            tag: $data[&apos;tag&apos;] ?? null,
            name: $data[&apos;name&apos;] ?? null
        );
    }
}</file><file path="app/Http/Integrations/MusicBrainz/Models/Track.php">&lt;?php
namespace App\Http\Integrations\MusicBrainz\Models;
use Spatie\LaravelData\Data;
class Track extends Data
{
    public function __construct(public mixed $id, public mixed $position, public mixed $number, public mixed $title, public mixed $length, public mixed $artist_credit, public mixed $recording, public mixed $annotation, public mixed $text, public mixed $type, public mixed $entity, public mixed $name, public mixed $disambiguation, public mixed $video, public mixed $first_release_date, public mixed $count, public mixed $offset, public mixed $release, public mixed $status, public mixed $quality, public mixed $packaging, public mixed $text_representation, public mixed $language, public mixed $script, public mixed $alias, public mixed $locale, public mixed $sort_name, public mixed $type_id, public mixed $primary, public mixed $begin_date, public mixed $end_date, public mixed $release_group, public mixed $primary_type, public mixed $secondary_type, public mixed $tag, public mixed $user_tag, public mixed $genre, public mixed $target_type, public mixed $relation, public mixed $target, public mixed $ordering_key, public mixed $direction, public mixed $begin, public mixed $end, public mixed $ended, public mixed $source_credit, public mixed $target_credit, public mixed $user_genre, public mixed $rating, public mixed $votes_count, public mixed $user_rating, public mixed $date, public mixed $country, public mixed $release_event, public mixed $area, public mixed $iso_3166_1_code, public mixed $iso_3166_2_code, public mixed $iso_3166_3_code, public mixed $life_span, public mixed $barcode, public mixed $asin, public mixed $cover_art_archive, public mixed $artwork, public mixed $front, public mixed $back, public mixed $darkened, public mixed $label_info, public mixed $catalog_number, public mixed $label, public mixed $label_code, public mixed $ipi, public mixed $isni, public mixed $track_count, public mixed $medium, public mixed $format, public mixed $disc, public mixed $sectors, public mixed $pregap, public mixed $collection, public mixed $entity_type, public mixed $editor, public mixed $artist, public mixed $gender, public mixed $begin_area, public mixed $end_area, public mixed $work, public mixed $fluency, public mixed $iswc, public mixed $event, public mixed $cancelled, public mixed $time, public mixed $setlist, public mixed $instrument, public mixed $description, public mixed $place, public mixed $address, public mixed $coordinates, public mixed $latitude, public mixed $longitude, public mixed $series, public mixed $puid, public mixed $isrc)
    {
    }
    public static function fromApiData(array $data): self
    {
        return new self(
            id: $data[&apos;id&apos;] ?? null,
            position: $data[&apos;position&apos;] ?? null,
            number: $data[&apos;number&apos;] ?? null,
            title: $data[&apos;title&apos;] ?? null,
            length: $data[&apos;length&apos;] ?? null,
            artist_credit: $data[&apos;artist-credit&apos;] ?? null,
            recording: $data[&apos;recording&apos;] ?? null,
            annotation: $data[&apos;annotation&apos;] ?? null,
            text: $data[&apos;text&apos;] ?? null,
            type: $data[&apos;type&apos;] ?? null,
            entity: $data[&apos;entity&apos;] ?? null,
            name: $data[&apos;name&apos;] ?? null,
            disambiguation: $data[&apos;disambiguation&apos;] ?? null,
            video: $data[&apos;video&apos;] ?? null,
            first_release_date: $data[&apos;first-release-date&apos;] ?? null,
            count: $data[&apos;count&apos;] ?? null,
            offset: $data[&apos;offset&apos;] ?? null,
            release: $data[&apos;release&apos;] ?? null,
            status: $data[&apos;status&apos;] ?? null,
            quality: $data[&apos;quality&apos;] ?? null,
            packaging: $data[&apos;packaging&apos;] ?? null,
            text_representation: $data[&apos;text-representation&apos;] ?? null,
            language: $data[&apos;language&apos;] ?? null,
            script: $data[&apos;script&apos;] ?? null,
            alias: $data[&apos;alias&apos;] ?? null,
            locale: $data[&apos;locale&apos;] ?? null,
            sort_name: $data[&apos;sort-name&apos;] ?? null,
            type_id: $data[&apos;type-id&apos;] ?? null,
            primary: $data[&apos;primary&apos;] ?? null,
            begin_date: $data[&apos;begin-date&apos;] ?? null,
            end_date: $data[&apos;end-date&apos;] ?? null,
            release_group: $data[&apos;release-group&apos;] ?? null,
            primary_type: $data[&apos;primary-type&apos;] ?? null,
            secondary_type: $data[&apos;secondary-type&apos;] ?? null,
            tag: $data[&apos;tag&apos;] ?? null,
            user_tag: $data[&apos;user-tag&apos;] ?? null,
            genre: $data[&apos;genre&apos;] ?? null,
            target_type: $data[&apos;target-type&apos;] ?? null,
            relation: $data[&apos;relation&apos;] ?? null,
            target: $data[&apos;target&apos;] ?? null,
            ordering_key: $data[&apos;ordering-key&apos;] ?? null,
            direction: $data[&apos;direction&apos;] ?? null,
            begin: $data[&apos;begin&apos;] ?? null,
            end: $data[&apos;end&apos;] ?? null,
            ended: $data[&apos;ended&apos;] ?? null,
            source_credit: $data[&apos;source-credit&apos;] ?? null,
            target_credit: $data[&apos;target-credit&apos;] ?? null,
            user_genre: $data[&apos;user-genre&apos;] ?? null,
            rating: $data[&apos;rating&apos;] ?? null,
            votes_count: $data[&apos;votes-count&apos;] ?? null,
            user_rating: $data[&apos;user-rating&apos;] ?? null,
            date: $data[&apos;date&apos;] ?? null,
            country: $data[&apos;country&apos;] ?? null,
            release_event: $data[&apos;release-event&apos;] ?? null,
            area: $data[&apos;area&apos;] ?? null,
            iso_3166_1_code: $data[&apos;iso-3166-1-code&apos;] ?? null,
            iso_3166_2_code: $data[&apos;iso-3166-2-code&apos;] ?? null,
            iso_3166_3_code: $data[&apos;iso-3166-3-code&apos;] ?? null,
            life_span: $data[&apos;life-span&apos;] ?? null,
            barcode: $data[&apos;barcode&apos;] ?? null,
            asin: $data[&apos;asin&apos;] ?? null,
            cover_art_archive: $data[&apos;cover-art-archive&apos;] ?? null,
            artwork: $data[&apos;artwork&apos;] ?? null,
            front: $data[&apos;front&apos;] ?? null,
            back: $data[&apos;back&apos;] ?? null,
            darkened: $data[&apos;darkened&apos;] ?? null,
            label_info: $data[&apos;label-info&apos;] ?? null,
            catalog_number: $data[&apos;catalog-number&apos;] ?? null,
            label: $data[&apos;label&apos;] ?? null,
            label_code: $data[&apos;label-code&apos;] ?? null,
            ipi: $data[&apos;ipi&apos;] ?? null,
            isni: $data[&apos;isni&apos;] ?? null,
            track_count: $data[&apos;track-count&apos;] ?? null,
            medium: $data[&apos;medium&apos;] ?? null,
            format: $data[&apos;format&apos;] ?? null,
            disc: $data[&apos;disc&apos;] ?? null,
            sectors: $data[&apos;sectors&apos;] ?? null,
            pregap: $data[&apos;pregap&apos;] ?? null,
            collection: $data[&apos;collection&apos;] ?? null,
            entity_type: $data[&apos;entity-type&apos;] ?? null,
            editor: $data[&apos;editor&apos;] ?? null,
            artist: $data[&apos;artist&apos;] ?? null,
            gender: $data[&apos;gender&apos;] ?? null,
            begin_area: $data[&apos;begin-area&apos;] ?? null,
            end_area: $data[&apos;end-area&apos;] ?? null,
            work: $data[&apos;work&apos;] ?? null,
            fluency: $data[&apos;fluency&apos;] ?? null,
            iswc: $data[&apos;iswc&apos;] ?? null,
            event: $data[&apos;event&apos;] ?? null,
            cancelled: $data[&apos;cancelled&apos;] ?? null,
            time: $data[&apos;time&apos;] ?? null,
            setlist: $data[&apos;setlist&apos;] ?? null,
            instrument: $data[&apos;instrument&apos;] ?? null,
            description: $data[&apos;description&apos;] ?? null,
            place: $data[&apos;place&apos;] ?? null,
            address: $data[&apos;address&apos;] ?? null,
            coordinates: $data[&apos;coordinates&apos;] ?? null,
            latitude: $data[&apos;latitude&apos;] ?? null,
            longitude: $data[&apos;longitude&apos;] ?? null,
            series: $data[&apos;series&apos;] ?? null,
            puid: $data[&apos;puid&apos;] ?? null,
            isrc: $data[&apos;isrc&apos;] ?? null
        );
    }
}</file><file path="app/Http/Integrations/MusicBrainz/Models/TrackData.php">&lt;?php
namespace App\Http\Integrations\MusicBrainz\Models;
use Spatie\LaravelData\Data;
class TrackData extends Data
{
    public function __construct(public mixed $id, public mixed $position, public mixed $number, public mixed $title, public mixed $length, public mixed $artist_credit, public mixed $recording, public mixed $annotation, public mixed $text, public mixed $type, public mixed $entity, public mixed $name, public mixed $disambiguation, public mixed $video, public mixed $first_release_date, public mixed $count, public mixed $offset, public mixed $release, public mixed $status, public mixed $quality, public mixed $packaging, public mixed $text_representation, public mixed $language, public mixed $script, public mixed $alias, public mixed $locale, public mixed $sort_name, public mixed $type_id, public mixed $primary, public mixed $begin_date, public mixed $end_date, public mixed $release_group, public mixed $primary_type, public mixed $secondary_type, public mixed $tag, public mixed $user_tag, public mixed $genre, public mixed $target_type, public mixed $relation, public mixed $target, public mixed $ordering_key, public mixed $direction, public mixed $begin, public mixed $end, public mixed $ended, public mixed $source_credit, public mixed $target_credit, public mixed $user_genre, public mixed $rating, public mixed $votes_count, public mixed $user_rating, public mixed $date, public mixed $country, public mixed $release_event, public mixed $area, public mixed $iso_3166_1_code, public mixed $iso_3166_2_code, public mixed $iso_3166_3_code, public mixed $life_span, public mixed $barcode, public mixed $asin, public mixed $cover_art_archive, public mixed $artwork, public mixed $front, public mixed $back, public mixed $darkened, public mixed $label_info, public mixed $catalog_number, public mixed $label, public mixed $label_code, public mixed $ipi, public mixed $isni, public mixed $track_count, public mixed $medium, public mixed $track, public mixed $format, public mixed $disc, public mixed $sectors, public mixed $pregap, public mixed $collection, public mixed $entity_type, public mixed $editor, public mixed $artist, public mixed $gender, public mixed $begin_area, public mixed $end_area, public mixed $work, public mixed $fluency, public mixed $iswc, public mixed $event, public mixed $cancelled, public mixed $time, public mixed $setlist, public mixed $instrument, public mixed $description, public mixed $place, public mixed $address, public mixed $coordinates, public mixed $latitude, public mixed $longitude, public mixed $series, public mixed $puid, public mixed $isrc)
    {
    }
    public static function fromApiData(array $data): self
    {
        return new self(
            id: $data[&apos;id&apos;] ?? null,
            position: $data[&apos;position&apos;] ?? null,
            number: $data[&apos;number&apos;] ?? null,
            title: $data[&apos;title&apos;] ?? null,
            length: $data[&apos;length&apos;] ?? null,
            artist_credit: $data[&apos;artist-credit&apos;] ?? null,
            recording: $data[&apos;recording&apos;] ?? null,
            annotation: $data[&apos;annotation&apos;] ?? null,
            text: $data[&apos;text&apos;] ?? null,
            type: $data[&apos;type&apos;] ?? null,
            entity: $data[&apos;entity&apos;] ?? null,
            name: $data[&apos;name&apos;] ?? null,
            disambiguation: $data[&apos;disambiguation&apos;] ?? null,
            video: $data[&apos;video&apos;] ?? null,
            first_release_date: $data[&apos;first-release-date&apos;] ?? null,
            count: $data[&apos;count&apos;] ?? null,
            offset: $data[&apos;offset&apos;] ?? null,
            release: $data[&apos;release&apos;] ?? null,
            status: $data[&apos;status&apos;] ?? null,
            quality: $data[&apos;quality&apos;] ?? null,
            packaging: $data[&apos;packaging&apos;] ?? null,
            text_representation: $data[&apos;text-representation&apos;] ?? null,
            language: $data[&apos;language&apos;] ?? null,
            script: $data[&apos;script&apos;] ?? null,
            alias: $data[&apos;alias&apos;] ?? null,
            locale: $data[&apos;locale&apos;] ?? null,
            sort_name: $data[&apos;sort-name&apos;] ?? null,
            type_id: $data[&apos;type-id&apos;] ?? null,
            primary: $data[&apos;primary&apos;] ?? null,
            begin_date: $data[&apos;begin-date&apos;] ?? null,
            end_date: $data[&apos;end-date&apos;] ?? null,
            release_group: $data[&apos;release-group&apos;] ?? null,
            primary_type: $data[&apos;primary-type&apos;] ?? null,
            secondary_type: $data[&apos;secondary-type&apos;] ?? null,
            tag: $data[&apos;tag&apos;] ?? null,
            user_tag: $data[&apos;user-tag&apos;] ?? null,
            genre: $data[&apos;genre&apos;] ?? null,
            target_type: $data[&apos;target-type&apos;] ?? null,
            relation: $data[&apos;relation&apos;] ?? null,
            target: $data[&apos;target&apos;] ?? null,
            ordering_key: $data[&apos;ordering-key&apos;] ?? null,
            direction: $data[&apos;direction&apos;] ?? null,
            begin: $data[&apos;begin&apos;] ?? null,
            end: $data[&apos;end&apos;] ?? null,
            ended: $data[&apos;ended&apos;] ?? null,
            source_credit: $data[&apos;source-credit&apos;] ?? null,
            target_credit: $data[&apos;target-credit&apos;] ?? null,
            user_genre: $data[&apos;user-genre&apos;] ?? null,
            rating: $data[&apos;rating&apos;] ?? null,
            votes_count: $data[&apos;votes-count&apos;] ?? null,
            user_rating: $data[&apos;user-rating&apos;] ?? null,
            date: $data[&apos;date&apos;] ?? null,
            country: $data[&apos;country&apos;] ?? null,
            release_event: $data[&apos;release-event&apos;] ?? null,
            area: $data[&apos;area&apos;] ?? null,
            iso_3166_1_code: $data[&apos;iso-3166-1-code&apos;] ?? null,
            iso_3166_2_code: $data[&apos;iso-3166-2-code&apos;] ?? null,
            iso_3166_3_code: $data[&apos;iso-3166-3-code&apos;] ?? null,
            life_span: $data[&apos;life-span&apos;] ?? null,
            barcode: $data[&apos;barcode&apos;] ?? null,
            asin: $data[&apos;asin&apos;] ?? null,
            cover_art_archive: $data[&apos;cover-art-archive&apos;] ?? null,
            artwork: $data[&apos;artwork&apos;] ?? null,
            front: $data[&apos;front&apos;] ?? null,
            back: $data[&apos;back&apos;] ?? null,
            darkened: $data[&apos;darkened&apos;] ?? null,
            label_info: $data[&apos;label-info&apos;] ?? null,
            catalog_number: $data[&apos;catalog-number&apos;] ?? null,
            label: $data[&apos;label&apos;] ?? null,
            label_code: $data[&apos;label-code&apos;] ?? null,
            ipi: $data[&apos;ipi&apos;] ?? null,
            isni: $data[&apos;isni&apos;] ?? null,
            track_count: $data[&apos;track-count&apos;] ?? null,
            medium: $data[&apos;medium&apos;] ?? null,
            track: $data[&apos;track&apos;] ?? null,
            format: $data[&apos;format&apos;] ?? null,
            disc: $data[&apos;disc&apos;] ?? null,
            sectors: $data[&apos;sectors&apos;] ?? null,
            pregap: $data[&apos;pregap&apos;] ?? null,
            collection: $data[&apos;collection&apos;] ?? null,
            entity_type: $data[&apos;entity-type&apos;] ?? null,
            editor: $data[&apos;editor&apos;] ?? null,
            artist: $data[&apos;artist&apos;] ?? null,
            gender: $data[&apos;gender&apos;] ?? null,
            begin_area: $data[&apos;begin-area&apos;] ?? null,
            end_area: $data[&apos;end-area&apos;] ?? null,
            work: $data[&apos;work&apos;] ?? null,
            fluency: $data[&apos;fluency&apos;] ?? null,
            iswc: $data[&apos;iswc&apos;] ?? null,
            event: $data[&apos;event&apos;] ?? null,
            cancelled: $data[&apos;cancelled&apos;] ?? null,
            time: $data[&apos;time&apos;] ?? null,
            setlist: $data[&apos;setlist&apos;] ?? null,
            instrument: $data[&apos;instrument&apos;] ?? null,
            description: $data[&apos;description&apos;] ?? null,
            place: $data[&apos;place&apos;] ?? null,
            address: $data[&apos;address&apos;] ?? null,
            coordinates: $data[&apos;coordinates&apos;] ?? null,
            latitude: $data[&apos;latitude&apos;] ?? null,
            longitude: $data[&apos;longitude&apos;] ?? null,
            series: $data[&apos;series&apos;] ?? null,
            puid: $data[&apos;puid&apos;] ?? null,
            isrc: $data[&apos;isrc&apos;] ?? null
        );
    }
}</file><file path="app/Http/Integrations/MusicBrainz/Models/TrackList.php">&lt;?php
namespace App\Http\Integrations\MusicBrainz\Models;
use Spatie\LaravelData\Data;
class TrackList extends Data
{
    public function __construct(public mixed $count, public mixed $offset, public mixed $track, public mixed $id, public mixed $position, public mixed $number, public mixed $title, public mixed $length, public mixed $artist_credit, public mixed $recording, public mixed $annotation, public mixed $text, public mixed $type, public mixed $entity, public mixed $name, public mixed $disambiguation, public mixed $video, public mixed $first_release_date, public mixed $release, public mixed $status, public mixed $quality, public mixed $packaging, public mixed $text_representation, public mixed $language, public mixed $script, public mixed $alias, public mixed $locale, public mixed $sort_name, public mixed $type_id, public mixed $primary, public mixed $begin_date, public mixed $end_date, public mixed $release_group, public mixed $primary_type, public mixed $secondary_type, public mixed $tag, public mixed $user_tag, public mixed $genre, public mixed $target_type, public mixed $relation, public mixed $target, public mixed $ordering_key, public mixed $direction, public mixed $begin, public mixed $end, public mixed $ended, public mixed $source_credit, public mixed $target_credit, public mixed $user_genre, public mixed $rating, public mixed $votes_count, public mixed $user_rating, public mixed $date, public mixed $country, public mixed $release_event, public mixed $area, public mixed $iso_3166_1_code, public mixed $iso_3166_2_code, public mixed $iso_3166_3_code, public mixed $life_span, public mixed $barcode, public mixed $asin, public mixed $cover_art_archive, public mixed $artwork, public mixed $front, public mixed $back, public mixed $darkened, public mixed $label_info, public mixed $catalog_number, public mixed $label, public mixed $label_code, public mixed $ipi, public mixed $isni, public mixed $track_count, public mixed $medium, public mixed $format, public mixed $disc, public mixed $sectors, public mixed $pregap, public mixed $collection, public mixed $entity_type, public mixed $editor, public mixed $artist, public mixed $gender, public mixed $begin_area, public mixed $end_area, public mixed $work, public mixed $fluency, public mixed $iswc, public mixed $event, public mixed $cancelled, public mixed $time, public mixed $setlist, public mixed $instrument, public mixed $description, public mixed $place, public mixed $address, public mixed $coordinates, public mixed $latitude, public mixed $longitude, public mixed $series, public mixed $puid, public mixed $isrc)
    {
    }
    public static function fromApiData(array $data): self
    {
        return new self(
            count: $data[&apos;count&apos;] ?? null,
            offset: $data[&apos;offset&apos;] ?? null,
            track: $data[&apos;track&apos;] ?? null,
            id: $data[&apos;id&apos;] ?? null,
            position: $data[&apos;position&apos;] ?? null,
            number: $data[&apos;number&apos;] ?? null,
            title: $data[&apos;title&apos;] ?? null,
            length: $data[&apos;length&apos;] ?? null,
            artist_credit: $data[&apos;artist-credit&apos;] ?? null,
            recording: $data[&apos;recording&apos;] ?? null,
            annotation: $data[&apos;annotation&apos;] ?? null,
            text: $data[&apos;text&apos;] ?? null,
            type: $data[&apos;type&apos;] ?? null,
            entity: $data[&apos;entity&apos;] ?? null,
            name: $data[&apos;name&apos;] ?? null,
            disambiguation: $data[&apos;disambiguation&apos;] ?? null,
            video: $data[&apos;video&apos;] ?? null,
            first_release_date: $data[&apos;first-release-date&apos;] ?? null,
            release: $data[&apos;release&apos;] ?? null,
            status: $data[&apos;status&apos;] ?? null,
            quality: $data[&apos;quality&apos;] ?? null,
            packaging: $data[&apos;packaging&apos;] ?? null,
            text_representation: $data[&apos;text-representation&apos;] ?? null,
            language: $data[&apos;language&apos;] ?? null,
            script: $data[&apos;script&apos;] ?? null,
            alias: $data[&apos;alias&apos;] ?? null,
            locale: $data[&apos;locale&apos;] ?? null,
            sort_name: $data[&apos;sort-name&apos;] ?? null,
            type_id: $data[&apos;type-id&apos;] ?? null,
            primary: $data[&apos;primary&apos;] ?? null,
            begin_date: $data[&apos;begin-date&apos;] ?? null,
            end_date: $data[&apos;end-date&apos;] ?? null,
            release_group: $data[&apos;release-group&apos;] ?? null,
            primary_type: $data[&apos;primary-type&apos;] ?? null,
            secondary_type: $data[&apos;secondary-type&apos;] ?? null,
            tag: $data[&apos;tag&apos;] ?? null,
            user_tag: $data[&apos;user-tag&apos;] ?? null,
            genre: $data[&apos;genre&apos;] ?? null,
            target_type: $data[&apos;target-type&apos;] ?? null,
            relation: $data[&apos;relation&apos;] ?? null,
            target: $data[&apos;target&apos;] ?? null,
            ordering_key: $data[&apos;ordering-key&apos;] ?? null,
            direction: $data[&apos;direction&apos;] ?? null,
            begin: $data[&apos;begin&apos;] ?? null,
            end: $data[&apos;end&apos;] ?? null,
            ended: $data[&apos;ended&apos;] ?? null,
            source_credit: $data[&apos;source-credit&apos;] ?? null,
            target_credit: $data[&apos;target-credit&apos;] ?? null,
            user_genre: $data[&apos;user-genre&apos;] ?? null,
            rating: $data[&apos;rating&apos;] ?? null,
            votes_count: $data[&apos;votes-count&apos;] ?? null,
            user_rating: $data[&apos;user-rating&apos;] ?? null,
            date: $data[&apos;date&apos;] ?? null,
            country: $data[&apos;country&apos;] ?? null,
            release_event: $data[&apos;release-event&apos;] ?? null,
            area: $data[&apos;area&apos;] ?? null,
            iso_3166_1_code: $data[&apos;iso-3166-1-code&apos;] ?? null,
            iso_3166_2_code: $data[&apos;iso-3166-2-code&apos;] ?? null,
            iso_3166_3_code: $data[&apos;iso-3166-3-code&apos;] ?? null,
            life_span: $data[&apos;life-span&apos;] ?? null,
            barcode: $data[&apos;barcode&apos;] ?? null,
            asin: $data[&apos;asin&apos;] ?? null,
            cover_art_archive: $data[&apos;cover-art-archive&apos;] ?? null,
            artwork: $data[&apos;artwork&apos;] ?? null,
            front: $data[&apos;front&apos;] ?? null,
            back: $data[&apos;back&apos;] ?? null,
            darkened: $data[&apos;darkened&apos;] ?? null,
            label_info: $data[&apos;label-info&apos;] ?? null,
            catalog_number: $data[&apos;catalog-number&apos;] ?? null,
            label: $data[&apos;label&apos;] ?? null,
            label_code: $data[&apos;label-code&apos;] ?? null,
            ipi: $data[&apos;ipi&apos;] ?? null,
            isni: $data[&apos;isni&apos;] ?? null,
            track_count: $data[&apos;track-count&apos;] ?? null,
            medium: $data[&apos;medium&apos;] ?? null,
            format: $data[&apos;format&apos;] ?? null,
            disc: $data[&apos;disc&apos;] ?? null,
            sectors: $data[&apos;sectors&apos;] ?? null,
            pregap: $data[&apos;pregap&apos;] ?? null,
            collection: $data[&apos;collection&apos;] ?? null,
            entity_type: $data[&apos;entity-type&apos;] ?? null,
            editor: $data[&apos;editor&apos;] ?? null,
            artist: $data[&apos;artist&apos;] ?? null,
            gender: $data[&apos;gender&apos;] ?? null,
            begin_area: $data[&apos;begin-area&apos;] ?? null,
            end_area: $data[&apos;end-area&apos;] ?? null,
            work: $data[&apos;work&apos;] ?? null,
            fluency: $data[&apos;fluency&apos;] ?? null,
            iswc: $data[&apos;iswc&apos;] ?? null,
            event: $data[&apos;event&apos;] ?? null,
            cancelled: $data[&apos;cancelled&apos;] ?? null,
            time: $data[&apos;time&apos;] ?? null,
            setlist: $data[&apos;setlist&apos;] ?? null,
            instrument: $data[&apos;instrument&apos;] ?? null,
            description: $data[&apos;description&apos;] ?? null,
            place: $data[&apos;place&apos;] ?? null,
            address: $data[&apos;address&apos;] ?? null,
            coordinates: $data[&apos;coordinates&apos;] ?? null,
            latitude: $data[&apos;latitude&apos;] ?? null,
            longitude: $data[&apos;longitude&apos;] ?? null,
            series: $data[&apos;series&apos;] ?? null,
            puid: $data[&apos;puid&apos;] ?? null,
            isrc: $data[&apos;isrc&apos;] ?? null
        );
    }
}</file><file path="app/Http/Integrations/MusicBrainz/Models/Url.php">&lt;?php
namespace App\Http\Integrations\MusicBrainz\Models;
use Spatie\LaravelData\Data;
class Url extends Data
{
    public function __construct(public mixed $url, public mixed $id, public mixed $resource, public mixed $target_type, public mixed $count, public mixed $offset, public mixed $relation, public mixed $target, public mixed $type, public mixed $type_id, public mixed $ordering_key, public mixed $direction, public mixed $begin, public mixed $end, public mixed $ended, public mixed $source_credit, public mixed $target_credit)
    {
    }
    public static function fromApiData(array $data): self
    {
        return new self(
            url: $data[&apos;url&apos;] ?? null,
            id: $data[&apos;id&apos;] ?? null,
            resource: $data[&apos;resource&apos;] ?? null,
            target_type: $data[&apos;target-type&apos;] ?? null,
            count: $data[&apos;count&apos;] ?? null,
            offset: $data[&apos;offset&apos;] ?? null,
            relation: $data[&apos;relation&apos;] ?? null,
            target: $data[&apos;target&apos;] ?? null,
            type: $data[&apos;type&apos;] ?? null,
            type_id: $data[&apos;type-id&apos;] ?? null,
            ordering_key: $data[&apos;ordering-key&apos;] ?? null,
            direction: $data[&apos;direction&apos;] ?? null,
            begin: $data[&apos;begin&apos;] ?? null,
            end: $data[&apos;end&apos;] ?? null,
            ended: $data[&apos;ended&apos;] ?? null,
            source_credit: $data[&apos;source-credit&apos;] ?? null,
            target_credit: $data[&apos;target-credit&apos;] ?? null
        );
    }
}</file><file path="app/Http/Integrations/MusicBrainz/Models/UrlList.php">&lt;?php
namespace App\Http\Integrations\MusicBrainz\Models;
use Spatie\LaravelData\Data;
class UrlList extends Data
{
    public function __construct(public mixed $count, public mixed $offset, public mixed $url, public mixed $id, public mixed $resource, public mixed $target_type, public mixed $relation, public mixed $target, public mixed $type, public mixed $type_id, public mixed $ordering_key, public mixed $direction, public mixed $begin, public mixed $end, public mixed $ended, public mixed $source_credit, public mixed $target_credit)
    {
    }
    public static function fromApiData(array $data): self
    {
        return new self(
            count: $data[&apos;count&apos;] ?? null,
            offset: $data[&apos;offset&apos;] ?? null,
            url: $data[&apos;url&apos;] ?? null,
            id: $data[&apos;id&apos;] ?? null,
            resource: $data[&apos;resource&apos;] ?? null,
            target_type: $data[&apos;target-type&apos;] ?? null,
            relation: $data[&apos;relation&apos;] ?? null,
            target: $data[&apos;target&apos;] ?? null,
            type: $data[&apos;type&apos;] ?? null,
            type_id: $data[&apos;type-id&apos;] ?? null,
            ordering_key: $data[&apos;ordering-key&apos;] ?? null,
            direction: $data[&apos;direction&apos;] ?? null,
            begin: $data[&apos;begin&apos;] ?? null,
            end: $data[&apos;end&apos;] ?? null,
            ended: $data[&apos;ended&apos;] ?? null,
            source_credit: $data[&apos;source-credit&apos;] ?? null,
            target_credit: $data[&apos;target-credit&apos;] ?? null
        );
    }
}</file><file path="app/Http/Integrations/MusicBrainz/Models/UserGenre.php">&lt;?php
namespace App\Http\Integrations\MusicBrainz\Models;
use Spatie\LaravelData\Data;
class UserGenre extends Data
{
    public function __construct(public mixed $user_genre, public mixed $name, public mixed $id, public mixed $disambiguation)
    {
    }
    public static function fromApiData(array $data): self
    {
        return new self(
            user_genre: $data[&apos;user-genre&apos;] ?? null,
            name: $data[&apos;name&apos;] ?? null,
            id: $data[&apos;id&apos;] ?? null,
            disambiguation: $data[&apos;disambiguation&apos;] ?? null
        );
    }
}</file><file path="app/Http/Integrations/MusicBrainz/Models/UserGenreList.php">&lt;?php
namespace App\Http\Integrations\MusicBrainz\Models;
use Spatie\LaravelData\Data;
class UserGenreList extends Data
{
    public function __construct(public mixed $count, public mixed $offset, public mixed $user_genre, public mixed $name, public mixed $id, public mixed $disambiguation)
    {
    }
    public static function fromApiData(array $data): self
    {
        return new self(
            count: $data[&apos;count&apos;] ?? null,
            offset: $data[&apos;offset&apos;] ?? null,
            user_genre: $data[&apos;user-genre&apos;] ?? null,
            name: $data[&apos;name&apos;] ?? null,
            id: $data[&apos;id&apos;] ?? null,
            disambiguation: $data[&apos;disambiguation&apos;] ?? null
        );
    }
}</file><file path="app/Http/Integrations/MusicBrainz/Models/UserRating.php">&lt;?php
namespace App\Http\Integrations\MusicBrainz\Models;
use Spatie\LaravelData\Data;
class UserRating extends Data
{
    public function __construct(public mixed $user_rating)
    {
    }
    public static function fromApiData(array $data): self
    {
        return new self(
            user_rating: $data[&apos;user-rating&apos;] ?? null
        );
    }
}</file><file path="app/Http/Integrations/MusicBrainz/Models/UserTag.php">&lt;?php
namespace App\Http\Integrations\MusicBrainz\Models;
use Spatie\LaravelData\Data;
class UserTag extends Data
{
    public function __construct(public mixed $user_tag, public mixed $name)
    {
    }
    public static function fromApiData(array $data): self
    {
        return new self(
            user_tag: $data[&apos;user-tag&apos;] ?? null,
            name: $data[&apos;name&apos;] ?? null
        );
    }
}</file><file path="app/Http/Integrations/MusicBrainz/Models/UserTagList.php">&lt;?php
namespace App\Http\Integrations\MusicBrainz\Models;
use Spatie\LaravelData\Data;
class UserTagList extends Data
{
    public function __construct(public mixed $count, public mixed $offset, public mixed $user_tag, public mixed $name)
    {
    }
    public static function fromApiData(array $data): self
    {
        return new self(
            count: $data[&apos;count&apos;] ?? null,
            offset: $data[&apos;offset&apos;] ?? null,
            user_tag: $data[&apos;user-tag&apos;] ?? null,
            name: $data[&apos;name&apos;] ?? null
        );
    }
}</file><file path="app/Http/Integrations/MusicBrainz/Models/Video.php">&lt;?php
namespace App\Http\Integrations\MusicBrainz\Models;
use Spatie\LaravelData\Data;
class Video extends Data
{
    public function __construct()
    {
    }
    public static function fromApiData(array $data): self
    {
        return new self(
        );
    }
}</file><file path="app/Http/Integrations/MusicBrainz/Models/Work.php">&lt;?php
namespace App\Http\Integrations\MusicBrainz\Models;
use Spatie\LaravelData\Data;
class Work extends Data
{
    public function __construct(public mixed $work, public mixed $id, public mixed $type, public mixed $type_id, public mixed $title, public mixed $language, public mixed $count, public mixed $offset, public mixed $fluency, public mixed $artist_credit, public mixed $iswc, public mixed $annotation, public mixed $text, public mixed $entity, public mixed $name, public mixed $disambiguation, public mixed $alias, public mixed $locale, public mixed $sort_name, public mixed $primary, public mixed $begin_date, public mixed $end_date, public mixed $tag, public mixed $user_tag, public mixed $genre, public mixed $target_type, public mixed $relation, public mixed $target, public mixed $ordering_key, public mixed $direction, public mixed $begin, public mixed $end, public mixed $ended, public mixed $source_credit, public mixed $target_credit, public mixed $user_genre, public mixed $rating, public mixed $votes_count, public mixed $user_rating)
    {
    }
    public static function fromApiData(array $data): self
    {
        return new self(
            work: $data[&apos;work&apos;] ?? null,
            id: $data[&apos;id&apos;] ?? null,
            type: $data[&apos;type&apos;] ?? null,
            type_id: $data[&apos;type-id&apos;] ?? null,
            title: $data[&apos;title&apos;] ?? null,
            language: $data[&apos;language&apos;] ?? null,
            count: $data[&apos;count&apos;] ?? null,
            offset: $data[&apos;offset&apos;] ?? null,
            fluency: $data[&apos;fluency&apos;] ?? null,
            artist_credit: $data[&apos;artist-credit&apos;] ?? null,
            iswc: $data[&apos;iswc&apos;] ?? null,
            annotation: $data[&apos;annotation&apos;] ?? null,
            text: $data[&apos;text&apos;] ?? null,
            entity: $data[&apos;entity&apos;] ?? null,
            name: $data[&apos;name&apos;] ?? null,
            disambiguation: $data[&apos;disambiguation&apos;] ?? null,
            alias: $data[&apos;alias&apos;] ?? null,
            locale: $data[&apos;locale&apos;] ?? null,
            sort_name: $data[&apos;sort-name&apos;] ?? null,
            primary: $data[&apos;primary&apos;] ?? null,
            begin_date: $data[&apos;begin-date&apos;] ?? null,
            end_date: $data[&apos;end-date&apos;] ?? null,
            tag: $data[&apos;tag&apos;] ?? null,
            user_tag: $data[&apos;user-tag&apos;] ?? null,
            genre: $data[&apos;genre&apos;] ?? null,
            target_type: $data[&apos;target-type&apos;] ?? null,
            relation: $data[&apos;relation&apos;] ?? null,
            target: $data[&apos;target&apos;] ?? null,
            ordering_key: $data[&apos;ordering-key&apos;] ?? null,
            direction: $data[&apos;direction&apos;] ?? null,
            begin: $data[&apos;begin&apos;] ?? null,
            end: $data[&apos;end&apos;] ?? null,
            ended: $data[&apos;ended&apos;] ?? null,
            source_credit: $data[&apos;source-credit&apos;] ?? null,
            target_credit: $data[&apos;target-credit&apos;] ?? null,
            user_genre: $data[&apos;user-genre&apos;] ?? null,
            rating: $data[&apos;rating&apos;] ?? null,
            votes_count: $data[&apos;votes-count&apos;] ?? null,
            user_rating: $data[&apos;user-rating&apos;] ?? null
        );
    }
}</file><file path="app/Http/Integrations/MusicBrainz/Models/WorkAttributeList.php">&lt;?php
namespace App\Http\Integrations\MusicBrainz\Models;
use Spatie\LaravelData\Data;
class WorkAttributeList extends Data
{
    public function __construct()
    {
    }
    public static function fromApiData(array $data): self
    {
        return new self(
        );
    }
}</file><file path="app/Http/Integrations/MusicBrainz/Models/WorkList.php">&lt;?php
namespace App\Http\Integrations\MusicBrainz\Models;
use Spatie\LaravelData\Data;
class WorkList extends Data
{
    public function __construct(public mixed $count, public mixed $offset, public mixed $work, public mixed $id, public mixed $type, public mixed $type_id, public mixed $title, public mixed $language, public mixed $fluency, public mixed $artist_credit, public mixed $iswc, public mixed $annotation, public mixed $text, public mixed $entity, public mixed $name, public mixed $disambiguation, public mixed $alias, public mixed $locale, public mixed $sort_name, public mixed $primary, public mixed $begin_date, public mixed $end_date, public mixed $tag, public mixed $user_tag, public mixed $genre, public mixed $target_type, public mixed $relation, public mixed $target, public mixed $ordering_key, public mixed $direction, public mixed $begin, public mixed $end, public mixed $ended, public mixed $source_credit, public mixed $target_credit, public mixed $user_genre, public mixed $rating, public mixed $votes_count, public mixed $user_rating)
    {
    }
    public static function fromApiData(array $data): self
    {
        return new self(
            count: $data[&apos;count&apos;] ?? null,
            offset: $data[&apos;offset&apos;] ?? null,
            work: $data[&apos;work&apos;] ?? null,
            id: $data[&apos;id&apos;] ?? null,
            type: $data[&apos;type&apos;] ?? null,
            type_id: $data[&apos;type-id&apos;] ?? null,
            title: $data[&apos;title&apos;] ?? null,
            language: $data[&apos;language&apos;] ?? null,
            fluency: $data[&apos;fluency&apos;] ?? null,
            artist_credit: $data[&apos;artist-credit&apos;] ?? null,
            iswc: $data[&apos;iswc&apos;] ?? null,
            annotation: $data[&apos;annotation&apos;] ?? null,
            text: $data[&apos;text&apos;] ?? null,
            entity: $data[&apos;entity&apos;] ?? null,
            name: $data[&apos;name&apos;] ?? null,
            disambiguation: $data[&apos;disambiguation&apos;] ?? null,
            alias: $data[&apos;alias&apos;] ?? null,
            locale: $data[&apos;locale&apos;] ?? null,
            sort_name: $data[&apos;sort-name&apos;] ?? null,
            primary: $data[&apos;primary&apos;] ?? null,
            begin_date: $data[&apos;begin-date&apos;] ?? null,
            end_date: $data[&apos;end-date&apos;] ?? null,
            tag: $data[&apos;tag&apos;] ?? null,
            user_tag: $data[&apos;user-tag&apos;] ?? null,
            genre: $data[&apos;genre&apos;] ?? null,
            target_type: $data[&apos;target-type&apos;] ?? null,
            relation: $data[&apos;relation&apos;] ?? null,
            target: $data[&apos;target&apos;] ?? null,
            ordering_key: $data[&apos;ordering-key&apos;] ?? null,
            direction: $data[&apos;direction&apos;] ?? null,
            begin: $data[&apos;begin&apos;] ?? null,
            end: $data[&apos;end&apos;] ?? null,
            ended: $data[&apos;ended&apos;] ?? null,
            source_credit: $data[&apos;source-credit&apos;] ?? null,
            target_credit: $data[&apos;target-credit&apos;] ?? null,
            user_genre: $data[&apos;user-genre&apos;] ?? null,
            rating: $data[&apos;rating&apos;] ?? null,
            votes_count: $data[&apos;votes-count&apos;] ?? null,
            user_rating: $data[&apos;user-rating&apos;] ?? null
        );
    }
}</file><file path="app/Http/Integrations/MusicBrainz/MusicBrainzClient.php">&lt;?php
namespace App\Http\Integrations\MusicBrainz;
use App\Services\GuzzleService;
use App\Http\Integrations\MusicBrainz\Handlers\LookupHandler;
use App\Http\Integrations\MusicBrainz\Handlers\SearchHandler;
class MusicBrainzClient
{
    public const string BASE_URL = &apos;https://musicbrainz.org/ws/2/&apos;;
    public LookupHandler $lookup;
    public SearchHandler $search;
    public function __construct(GuzzleService $guzzleService)
    {
        $client = $guzzleService-&gt;getClient();
        $this-&gt;lookup = new LookupHandler($client, self::BASE_URL);
        $this-&gt;search = new SearchHandler($client, self::BASE_URL);
    }
}</file><file path="app/Http/Integrations/MusicBrainz/Subqueries/ArtistAliasHandler.php">&lt;?php
namespace App\Http\Integrations\MusicBrainz\Subqueries;
use App\Http\Integrations\MusicBrainz\Handler;
class ArtistAliasHandler extends Handler
{
    public function list(string $artistMbid): ?array
    {
        return $this-&gt;fetchEndpoint(&apos;artist/&apos; . $artistMbid . &apos;/aliases&apos;);
    }
}</file><file path="app/Http/Integrations/TasteDive/Handler.php">&lt;?php
namespace App\Http\Integrations\TasteDive;
use GuzzleHttp\Client;
abstract class Handler
{
    public function __construct(protected readonly Client $client, protected readonly string $baseUrl)
    {
    }
    protected function fetchEndpoint(string $endpoint, array $params = []): ?array
    {
        $response = $this-&gt;client-&gt;getAsync($this-&gt;baseUrl . $endpoint, [
            &apos;query&apos;   =&gt; $params,
            &apos;headers&apos; =&gt; [
                &apos;Authorization&apos; =&gt; &apos;Bearer &apos; . config(&apos;services.tastedive.api_key&apos;),
            ],
        ])-&gt;wait();
        if ($response-&gt;getStatusCode() === 200) {
            return json_decode($response-&gt;getBody()-&gt;getContents(), true);
        }
        return null;
    }
}</file><file path="app/Http/Integrations/TasteDive/Handlers/MovieHandler.php">&lt;?php
namespace App\Http\Integrations\TasteDive\Handlers;
use App\Http\Integrations\TasteDive\Handler;
class MovieHandler extends Handler
{
    public function getSimilarMovies(string $title)
    {
        return $this-&gt;fetchEndpoint(&apos;similar&apos;, [
            &apos;q&apos;    =&gt; $title,
            &apos;type&apos; =&gt; &apos;movie&apos;,
        ]);
    }
    public function getSimilarMusic(string $title)
    {
        return $this-&gt;fetchEndpoint(&apos;similar&apos;, [
            &apos;q&apos;    =&gt; $title,
            &apos;type&apos; =&gt; &apos;music&apos;,
        ]);
    }
}</file><file path="app/Http/Integrations/TasteDive/TasteDiveClient.php">&lt;?php
namespace App\Http\Integrations\TasteDive;
class TasteDiveClient
{
    public const string BASE_URL = &apos;https://tastedive.com/api/&apos;;
}</file><file path="app/Http/Integrations/Transcoder/TranscoderClient.php">&lt;?php
namespace App\Http\Integrations\Transcoder;
use GuzzleHttp\Client;
class TranscoderClient
{
    public function __construct(
        protected readonly Client $client,
        protected readonly string $baseUrl,
    )
    {
    }
    public function enqueueProbe(string $path)
    {
        $res = $this-&gt;client-&gt;postAsync($this-&gt;baseUrl . &apos;/probe&apos;, [
            &apos;body&apos; =&gt; [
                &apos;path&apos; =&gt; $path,
            ]
        ]);
        return $res-&gt;wait();
    }
}</file><file path="app/Http/Middleware/Authenticate.php">&lt;?php
namespace App\Http\Middleware;
use Illuminate\Auth\Middleware\Authenticate as Middleware;
use Illuminate\Http\Request;
class Authenticate extends Middleware
{
    /**
     * Get the path the user should be redirected to when they are not authenticated.
     */
    protected function redirectTo(Request $request): ?string
    {
        if (!$request-&gt;expectsJson()) {
            return url(&apos;/&apos;);
        }
        return null;
    }
}</file><file path="app/Http/Middleware/ConvertQueryTokenToHeaderMiddleware.php">&lt;?php
namespace App\Http\Middleware;
use Closure;
use Illuminate\Http\Request;
use Symfony\Component\HttpFoundation\Response;
class ConvertQueryTokenToHeaderMiddleware
{
    /**
     * Handle an incoming request.
     *
     * @param \Closure(\Illuminate\Http\Request): (\Symfony\Component\HttpFoundation\Response) $next
     */
    public function handle(Request $request, Closure $next): Response
    {
        $token = $request-&gt;query-&gt;get(&apos;_token&apos;);
        if ($token) {
            $request-&gt;headers-&gt;set(&apos;Authorization&apos;, &apos;Bearer &apos; . $token);
        }
        return $next($request);
    }
}</file><file path="app/Http/Middleware/EncryptCookies.php">&lt;?php
namespace App\Http\Middleware;
use Illuminate\Cookie\Middleware\EncryptCookies as Middleware;
class EncryptCookies extends Middleware
{
    protected static $serialize = false;
    /**
     * The names of the cookies that should not be encrypted.
     *
     * @var array&lt;int, string&gt;
     */
    protected $except = [
        //
    ];
}</file><file path="app/Http/Middleware/PreventRequestsDuringMaintenance.php">&lt;?php
namespace App\Http\Middleware;
use Illuminate\Foundation\Http\Middleware\PreventRequestsDuringMaintenance as Middleware;
class PreventRequestsDuringMaintenance extends Middleware
{
    /**
     * The URIs that should be reachable while maintenance mode is enabled.
     *
     * @var array&lt;int, string&gt;
     */
    protected $except = [
        //
    ];
}</file><file path="app/Http/Middleware/TrimStrings.php">&lt;?php
namespace App\Http\Middleware;
use Illuminate\Foundation\Http\Middleware\TrimStrings as Middleware;
class TrimStrings extends Middleware
{
    /**
     * The names of the attributes that should not be trimmed.
     *
     * @var array&lt;int, string&gt;
     */
    protected $except = [
        &apos;current_password&apos;,
        &apos;password&apos;,
        &apos;password_confirmation&apos;,
    ];
}</file><file path="app/Http/Middleware/TrustHosts.php">&lt;?php
namespace App\Http\Middleware;
use Illuminate\Http\Middleware\TrustHosts as Middleware;
class TrustHosts extends Middleware
{
    /**
     * Get the host patterns that should be trusted.
     *
     * @return array&lt;int, string|null&gt;
     */
    public function hosts(): array
    {
        return [
            $this-&gt;allSubdomainsOfApplicationUrl(),
        ];
    }
}</file><file path="app/Http/Middleware/TrustProxies.php">&lt;?php
namespace App\Http\Middleware;
use Illuminate\Http\Middleware\TrustProxies as Middleware;
use Illuminate\Http\Request;
class TrustProxies extends Middleware
{
    /**
     * The trusted proxies for this application.
     *
     * @var array&lt;int, string&gt;|string|null
     */
    protected $proxies = &apos;*&apos;;
    /**
     * The headers that should be used to detect proxies.
     *
     * @var int
     */
    protected $headers =
        Request::HEADER_X_FORWARDED_FOR |
        Request::HEADER_X_FORWARDED_HOST |
        Request::HEADER_X_FORWARDED_PORT |
        Request::HEADER_X_FORWARDED_PROTO;
}</file><file path="app/Http/Middleware/ValidateSignature.php">&lt;?php
namespace App\Http\Middleware;
use Illuminate\Routing\Middleware\ValidateSignature as Middleware;
class ValidateSignature extends Middleware
{
    /**
     * The names of the query string parameters that should be ignored.
     *
     * @var array&lt;int, string&gt;
     */
    protected $except = [
        // &apos;fbclid&apos;,
        // &apos;utm_campaign&apos;,
        // &apos;utm_content&apos;,
        // &apos;utm_medium&apos;,
        // &apos;utm_source&apos;,
        // &apos;utm_term&apos;,
    ];
}</file><file path="app/Http/Middleware/VerifyCsrfToken.php">&lt;?php
namespace App\Http\Middleware;
use Illuminate\Foundation\Http\Middleware\VerifyCsrfToken as Middleware;
class VerifyCsrfToken extends Middleware
{
    /**
     * The URIs that should be excluded from CSRF verification.
     *
     * @var array&lt;int, string&gt;
     */
    protected $except = [
        //
    ];
}</file><file path="app/Http/Requests/Auth/AuthenticateUsingPasskeyRequest.php">&lt;?php
namespace App\Http\Requests\Auth;
use Illuminate\Foundation\Http\FormRequest;
class AuthenticateUsingPasskeyRequest extends FormRequest
{
    /**
     * Get the validation rules that apply to the request.
     *
     * @return array&lt;string, \Illuminate\Contracts\Validation\ValidationRule|array&lt;mixed&gt;|string&gt;
     */
    public function rules(): array
    {
        return [
            &apos;start_authentication_response&apos; =&gt; [&apos;required&apos;, &apos;json&apos;],
        ];
    }
}</file><file path="app/Http/Requests/Auth/ForgotPasswordRequest.php">&lt;?php
namespace App\Http\Requests\Auth;
use Illuminate\Foundation\Http\FormRequest;
class ForgotPasswordRequest extends FormRequest
{
    /**
     * Determine if the user is authorized to make this request.
     */
    public function authorize(): bool
    {
        return true;
    }
    /**
     * Get the validation rules that apply to the request.
     *
     * @return array&lt;string, \Illuminate\Contracts\Validation\ValidationRule|array&lt;mixed&gt;|string&gt;
     */
    public function rules(): array
    {
        return [
            &apos;email&apos; =&gt; [&apos;required&apos;, &apos;email&apos;],
            &apos;url&apos;   =&gt; [&apos;sometimes&apos;, &apos;string&apos;],
        ];
    }
}</file><file path="app/Http/Requests/Auth/LoginRequest.php">&lt;?php
namespace App\Http\Requests\Auth;
use Illuminate\Foundation\Http\FormRequest;
class LoginRequest extends FormRequest
{
    /**
     * Determine if the user is authorized to make this request.
     */
    public function authorize(): bool
    {
        return true;
    }
    /**
     * Get the validation rules that apply to the request.
     *
     * @return array&lt;string, \Illuminate\Contracts\Validation\ValidationRule|array&lt;mixed&gt;|string&gt;
     */
    public function rules(): array
    {
        return [
            &apos;email&apos;    =&gt; [&apos;required&apos;, &apos;email&apos;],
            &apos;password&apos; =&gt; [&apos;required&apos;],
            &apos;remember&apos; =&gt; [&apos;boolean&apos;],
        ];
    }
}</file><file path="app/Http/Requests/Auth/ResetPasswordRequest.php">&lt;?php
namespace App\Http\Requests\Auth;
use Illuminate\Foundation\Http\FormRequest;
class ResetPasswordRequest extends FormRequest
{
    /**
     * Determine if the user is authorized to make this request.
     */
    public function authorize(): bool
    {
        return true;
    }
    /**
     * Get the validation rules that apply to the request.
     *
     * @return array&lt;string, \Illuminate\Contracts\Validation\ValidationRule|array&lt;mixed&gt;|string&gt;
     */
    public function rules(): array
    {
        return [
            &apos;email&apos;    =&gt; &apos;required|email&apos;,
            &apos;token&apos;    =&gt; &apos;required|string&apos;,
            &apos;password&apos; =&gt; &apos;required|string|confirmed&apos;,
        ];
    }
}</file><file path="app/Http/Requests/Auth/StorePasskeyRequest.php">&lt;?php
namespace App\Http\Requests\Auth;
use Illuminate\Foundation\Http\FormRequest;
class StorePasskeyRequest extends FormRequest
{
    /**
     * Determine if the user is authorized to make this request.
     */
    public function authorize(): bool
    {
        return true;
    }
    /**
     * Get the validation rules that apply to the request.
     *
     * @return array&lt;string, \Illuminate\Contracts\Validation\ValidationRule|array&lt;mixed&gt;|string&gt;
     */
    public function rules(): array
    {
        return [
            &apos;name&apos;    =&gt; [&apos;required&apos;, &apos;string&apos;, &apos;max:255&apos;],
            &apos;passkey&apos; =&gt; [&apos;required&apos;, &apos;json&apos;],
        ];
    }
}</file><file path="app/Http/Requests/Genre/UpdateGenreRequest.php">&lt;?php
namespace App\Http\Requests\Genre;
use Illuminate\Foundation\Http\FormRequest;
class UpdateGenreRequest extends FormRequest
{
    /**
     * Determine if the user is authorized to make this request.
     */
    public function authorize(): bool
    {
        return true;
    }
    /**
     * Get the validation rules that apply to the request.
     *
     * @return array&lt;string, \Illuminate\Contracts\Validation\ValidationRule|array&lt;mixed&gt;|string&gt;
     */
    public function rules(): array
    {
        return [
            &apos;name&apos; =&gt; &apos;required|string|min:1|max:255&apos;,
        ];
    }
}</file><file path="app/Http/Requests/Library/CreateLibraryRequest.php">&lt;?php
namespace App\Http\Requests\Library;
use App\Models\LibraryType;
use Illuminate\Foundation\Http\FormRequest;
use Illuminate\Validation\Rule;
class CreateLibraryRequest extends FormRequest
{
    /**
     * Determine if the user is authorized to make this request.
     */
    public function authorize(): bool
    {
        return true;
    }
    /**
     * Get the validation rules that apply to the request.
     *
     * @return array&lt;string, \Illuminate\Contracts\Validation\ValidationRule|array&lt;mixed&gt;|string&gt;
     */
    public function rules(): array
    {
        return [
            &apos;name&apos;  =&gt; &apos;required|string:min:1|max:100&apos;,
            &apos;path&apos;  =&gt; &apos;required|string:min:1|max:1000&apos;,
            &apos;type&apos;  =&gt; [&apos;required&apos;, Rule::enum(LibraryType::class)],
            &apos;order&apos; =&gt; &apos;required|integer&apos;,
        ];
    }
}</file><file path="app/Http/Requests/Logs/GetLogContentRequest.php">&lt;?php
namespace App\Http\Requests\Logs;
use Illuminate\Foundation\Http\FormRequest;
class GetLogContentRequest extends FormRequest
{
    /**
     * Determine if the user is authorized to make this request.
     */
    public function authorize(): bool
    {
        return true;
    }
    /**
     * Get the validation rules that apply to the request.
     *
     * @return array&lt;string, \Illuminate\Contracts\Validation\ValidationRule|array&lt;mixed&gt;|string&gt;
     */
    public function rules(): array
    {
        return [
            /** @query */
            &apos;path&apos;     =&gt; &apos;required|string&apos;,
            /** @query */
            &apos;lastLine&apos; =&gt; &apos;numeric&apos;,
        ];
    }
}</file><file path="app/Http/Requests/Playlist/CreatePlaylistRequest.php">&lt;?php
namespace App\Http\Requests\Playlist;
use Illuminate\Foundation\Http\FormRequest;
class CreatePlaylistRequest extends FormRequest
{
    /**
     * Determine if the user is authorized to make this request.
     */
    public function authorize(): bool
    {
        return true;
    }
    /**
     * Get the validation rules that apply to the request.
     *
     * @return array&lt;string, \Illuminate\Contracts\Validation\ValidationRule|array&lt;mixed&gt;|string&gt;
     */
    public function rules(): array
    {
        return [
            &apos;name&apos;        =&gt; &apos;required|string|max:255&apos;,
            &apos;description&apos; =&gt; &apos;nullable|string&apos;,
            &apos;is_public&apos;   =&gt; &apos;sometimes|boolean&apos;,
        ];
    }
}</file><file path="app/Http/Requests/Playlist/CreateSmartPlaylistRequest.php">&lt;?php
namespace App\Http\Requests\Playlist;
use Illuminate\Foundation\Http\FormRequest;
class CreateSmartPlaylistRequest extends FormRequest
{
    /**
     * Determine if the user is authorized to make this request.
     */
    public function authorize(): bool
    {
        return true;
    }
    /**
     * Get the validation rules that apply to the request.
     *
     * @return array&lt;string, \Illuminate\Contracts\Validation\ValidationRule|array&lt;mixed&gt;|string&gt;
     */
    public function rules(): array
    {
        return [
            &apos;name&apos;               =&gt; &apos;required|string|max:255&apos;,
            &apos;description&apos;        =&gt; &apos;nullable|string&apos;,
            &apos;is_public&apos;          =&gt; &apos;sometimes|boolean&apos;,
            &apos;rules&apos;              =&gt; &apos;required|array&apos;,
            &apos;rules.*&apos;            =&gt; &apos;array&apos;,
            &apos;rules.*.*.field&apos;    =&gt; &apos;required|string&apos;,
            &apos;rules.*.*.operator&apos; =&gt; &apos;required|string&apos;,
            &apos;rules.*.*.value&apos;    =&gt; &apos;required&apos;,
        ];
    }
}</file><file path="app/Http/Requests/Playlist/PlaylistShowRequest.php">&lt;?php
namespace App\Http\Requests\Playlist;
use Illuminate\Foundation\Http\FormRequest;
class PlaylistShowRequest extends FormRequest
{
    /**
     * Determine if the user is authorized to make this request.
     */
    public function authorize(): bool
    {
        return true;
    }
    /**
     * Get the validation rules that apply to the request.
     *
     * @return array&lt;string, \Illuminate\Contracts\Validation\ValidationRule|array&lt;mixed&gt;|string&gt;
     */
    public function rules(): array
    {
        return [
            /**
             * @query
             * Comma separated string of relations
             * - cover
             * - songs
             * - songs.artists
             * - songs.album
             * - songs.genres
             * - songs.cover
             */
            &apos;relations&apos; =&gt; &apos;string&apos;,
        ];
    }
}</file><file path="app/Http/Requests/Playlist/UpdatePlaylistRequest.php">&lt;?php
namespace App\Http\Requests\Playlist;
use Illuminate\Foundation\Http\FormRequest;
class UpdatePlaylistRequest extends FormRequest
{
    /**
     * Determine if the user is authorized to make this request.
     */
    public function authorize(): bool
    {
        return true;
    }
    /**
     * Get the validation rules that apply to the request.
     *
     * @return array&lt;string, \Illuminate\Contracts\Validation\ValidationRule|array&lt;mixed&gt;|string&gt;
     */
    public function rules(): array
    {
        return [
            &apos;name&apos;        =&gt; &apos;string|max:255&apos;,
            &apos;description&apos; =&gt; &apos;nullable|string&apos;,
            &apos;is_public&apos;   =&gt; &apos;boolean&apos;,
        ];
    }
}</file><file path="app/Http/Requests/Playlist/UpdateSmartPlaylistRulesRequest.php">&lt;?php
namespace App\Http\Requests\Playlist;
use Illuminate\Foundation\Http\FormRequest;
class UpdateSmartPlaylistRulesRequest extends FormRequest
{
    /**
     * Determine if the user is authorized to make this request.
     */
    public function authorize(): bool
    {
        return true;
    }
    /**
     * Get the validation rules that apply to the request.
     *
     * @return array&lt;string, \Illuminate\Contracts\Validation\ValidationRule|array&lt;mixed&gt;|string&gt;
     */
    public function rules(): array
    {
        return [
            &apos;rules&apos;              =&gt; &apos;required|array&apos;,
            &apos;rules.*&apos;            =&gt; &apos;array&apos;,
            &apos;rules.*.*.field&apos;    =&gt; &apos;required|string&apos;,
            &apos;rules.*.*.operator&apos; =&gt; &apos;required|string&apos;,
            &apos;rules.*.*.value&apos;    =&gt; &apos;required&apos;,
        ];
    }
}</file><file path="app/Http/Requests/QueueMetrics/MetricsRequest.php">&lt;?php
namespace App\Http\Requests\QueueMetrics;
use Illuminate\Foundation\Http\FormRequest;
class MetricsRequest extends FormRequest
{
    /**
     * Determine if the user is authorized to make this request.
     */
    public function authorize(): bool
    {
        return true;
    }
    /**
     * Get the validation rules that apply to the request.
     *
     * @return array&lt;string, \Illuminate\Contracts\Validation\ValidationRule|array&lt;mixed&gt;|string&gt;
     */
    public function rules(): array
    {
        return [
            /**
             * @query
             * @default 14
             *
             * Days to aggregate
             */
            &apos;aggregateDays&apos; =&gt; &apos;int&apos;,
        ];
    }
}</file><file path="app/Http/Requests/QueueMonitor/RetryJobRequest.php">&lt;?php
namespace App\Http\Requests\QueueMonitor;
use Illuminate\Foundation\Http\FormRequest;
class RetryJobRequest extends FormRequest
{
    /**
     * Determine if the user is authorized to make this request.
     */
    public function authorize(): bool
    {
        return true;
    }
    /**
     * Get the validation rules that apply to the request.
     *
     * @return array&lt;string, \Illuminate\Contracts\Validation\ValidationRule|array&lt;mixed&gt;|string&gt;
     */
    public function rules(): array
    {
        return [
            &apos;id&apos; =&gt; &apos;int&apos;,
        ];
    }
}</file><file path="app/Http/Requests/Song/SongShowRequest.php">&lt;?php
namespace App\Http\Requests\Song;
use Illuminate\Foundation\Http\FormRequest;
class SongShowRequest extends FormRequest
{
    /**
     * Determine if the user is authorized to make this request.
     */
    public function authorize(): bool
    {
        return true;
    }
    /**
     * Get the validation rules that apply to the request.
     *
     * @return array&lt;string, \Illuminate\Contracts\Validation\ValidationRule|array&lt;mixed&gt;|string&gt;
     */
    public function rules(): array
    {
        return [
            /**
             * @query
             * Comma seperated string of relations
             * - album
             * - artists
             * - albumArtist
             * - genres
             */
            &apos;relations&apos; =&gt; &apos;string&apos;,
        ];
    }
}</file><file path="app/Http/Requests/Stream/StartStreamRequest.php">&lt;?php
namespace App\Http\Requests\Stream;
use Illuminate\Foundation\Http\FormRequest;
class StartStreamRequest extends FormRequest
{
    /**
     * Determine if the user is authorized to make this request.
     */
    public function authorize(): bool
    {
        return true;
    }
    /**
     * Get the validation rules that apply to the request.
     *
     * @return array&lt;string, \Illuminate\Contracts\Validation\ValidationRule|array&lt;mixed&gt;|string&gt;
     */
    public function rules(): array
    {
        return [
            &apos;sessionId&apos;               =&gt; &apos;required|string&apos;,
            &apos;audioProfile.bitrate&apos;    =&gt; &apos;optional|int&apos;,
            &apos;audioProfile.channels&apos;   =&gt; &apos;optional|float&apos;,
            &apos;audioProfile.sampleRate&apos; =&gt; &apos;optional|int&apos;,
            &apos;audioProfile.codec&apos;      =&gt; &apos;optional|string&apos;,
            &apos;videoProfile.height&apos;     =&gt; &apos;optional|int&apos;,
            &apos;videoProfile.width&apos;      =&gt; &apos;optional|int&apos;,
            &apos;videoProfile.bitrate&apos;    =&gt; &apos;optional|int&apos;,
        ];
    }
}</file><file path="app/Http/Requests/User/CreateUserRequest.php">&lt;?php
namespace App\Http\Requests\User;
use Illuminate\Foundation\Http\FormRequest;
class CreateUserRequest extends FormRequest
{
    /**
     * Determine if the user is authorized to make this request.
     */
    public function authorize(): bool
    {
        return true;
    }
    /**
     * Get the validation rules that apply to the request.
     *
     * @return array&lt;string, \Illuminate\Contracts\Validation\ValidationRule|array&lt;mixed&gt;|string&gt;
     */
    public function rules(): array
    {
        return [
            &apos;name&apos;     =&gt; [&apos;required&apos;, &apos;max:160&apos;],
            &apos;email&apos;    =&gt; [&apos;required&apos;, &apos;email&apos;, &apos;max:254&apos;, &apos;unique:users&apos;],
            &apos;password&apos; =&gt; [&apos;required&apos;, &apos;string&apos;, &apos;min:1&apos;, &apos;max:100&apos;],
        ];
    }
}</file><file path="app/Http/Requests/User/UpdateUserRequest.php">&lt;?php
namespace App\Http\Requests\User;
use Illuminate\Foundation\Http\FormRequest;
class UpdateUserRequest extends FormRequest
{
    /**
     * Determine if the user is authorized to make this request.
     */
    public function authorize(): bool
    {
        return true;
    }
    /**
     * Get the validation rules that apply to the request.
     *
     * @return array&lt;string, \Illuminate\Contracts\Validation\ValidationRule|array&lt;mixed&gt;|string&gt;
     */
    public function rules(): array
    {
        return [
            &apos;email&apos;    =&gt; &apos;string|email|max:254&apos;,
            &apos;password&apos; =&gt; &apos;string|max:100&apos;,
        ];
    }
}</file><file path="app/Http/Requests/UserToken/RevokeTokenRequest.php">&lt;?php
namespace App\Http\Requests\UserToken;
use Illuminate\Foundation\Http\FormRequest;
class RevokeTokenRequest extends FormRequest
{
    /**
     * Determine if the user is authorized to make this request.
     */
    public function authorize(): bool
    {
        return true;
    }
    /**
     * Get the validation rules that apply to the request.
     *
     * @return array&lt;string, \Illuminate\Contracts\Validation\ValidationRule|array&lt;mixed&gt;|string&gt;
     */
    public function rules(): array
    {
        return [
            //
        ];
    }
}</file><file path="app/Http/Requests/UserToken/UserTokenIndexRequest.php">&lt;?php
namespace App\Http\Requests\UserToken;
use Illuminate\Foundation\Http\FormRequest;
class UserTokenIndexRequest extends FormRequest
{
    /**
     * Determine if the user is authorized to make this request.
     */
    public function authorize(): bool
    {
        return true;
    }
    /**
     * Get the validation rules that apply to the request.
     *
     * @return array&lt;string, \Illuminate\Contracts\Validation\ValidationRule|array&lt;mixed&gt;|string&gt;
     */
    public function rules(): array
    {
        return [
            /** @query */
            &apos;page&apos;    =&gt; &apos;int&apos;,
            /** @query */
            &apos;perPage&apos; =&gt; &apos;int&apos;,
        ];
    }
}</file><file path="app/Http/Resources/Auth/NewAccessTokenResource.php">&lt;?php
namespace App\Http\Resources\Auth;
use Illuminate\Http\Request;
use Illuminate\Http\Resources\Json\JsonResource;
use Illuminate\Support\Facades\Crypt;
use Laravel\Sanctum\NewAccessToken;
/**
 * @mixin NewAccessToken
 */
class NewAccessTokenResource extends JsonResource
{
    /**
     * Transform the resource into an array.
     *
     * @return array&lt;string, mixed&gt;
     */
    public function toArray(Request $request): array
    {
        return [
            &apos;token&apos;     =&gt; Crypt::encryptString($this-&gt;plainTextToken),
            &apos;abilities&apos; =&gt; $this-&gt;accessToken-&gt;abilities,
            &apos;expiresAt&apos; =&gt; $this-&gt;accessToken-&gt;expires_at,
        ];
    }
}</file><file path="app/Http/Resources/Movie/MovieResource.php">&lt;?php
namespace App\Http\Resources\Movie;
use App\Models\Movie;
use Illuminate\Http\Request;
use Illuminate\Http\Resources\Json\JsonResource;
/**
 * @mixin Movie
 */
class MovieResource extends JsonResource
{
    /**
     * Transform the resource into an array.
     *
     * @return array&lt;string, mixed&gt;
     */
    public function toArray(Request $request): array
    {
        return [
            &apos;title&apos;      =&gt; $this-&gt;title,
            &apos;slug&apos;       =&gt; $this-&gt;slug,
            &apos;year&apos;       =&gt; $this-&gt;year,
            &apos;summary&apos;    =&gt; $this-&gt;summary,
            &apos;created_at&apos; =&gt; $this-&gt;created_at,
            &apos;updated_at&apos; =&gt; $this-&gt;updated_at,
            $this-&gt;mergeWhen(isset($this-&gt;videos_count), [
                &apos;videos_count&apos; =&gt; $this-&gt;videos_count,
            ]),
        ];
    }
}</file><file path="app/Http/Resources/Playlist/PlaylistResource.php">&lt;?php
namespace App\Http\Resources\Playlist;
use App\Http\Resources\Image\ImageResource;
use App\Http\Resources\Song\SongResource;
use App\Models\Playlist;
use Illuminate\Http\Request;
use Illuminate\Http\Resources\Json\JsonResource;
/**
 * @mixin Playlist
 */
class PlaylistResource extends JsonResource
{
    /**
     * Transform the resource into an array.
     *
     * @return array&lt;string, mixed&gt;
     */
    public function toArray(Request $request): array
    {
        return [
            &apos;id&apos;              =&gt; $this-&gt;public_id,
            &apos;name&apos;            =&gt; $this-&gt;name,
            &apos;description&apos;     =&gt; $this-&gt;description,
            &apos;isPublic&apos;        =&gt; $this-&gt;is_public,
            &apos;isCollaborative&apos; =&gt; $this-&gt;is_collaborative,
            &apos;isSmart&apos;         =&gt; $this-&gt;is_smart,
            &apos;smartRules&apos;      =&gt; $this-&gt;when($this-&gt;is_smart, $this-&gt;smart_rules),
            &apos;cover&apos;           =&gt; ImageResource::make($this-&gt;whenLoaded(&apos;cover&apos;)),
            &apos;createdAt&apos;       =&gt; $this-&gt;created_at,
            &apos;updatedAt&apos;       =&gt; $this-&gt;updated_at,
            &apos;songsCount&apos;      =&gt; $this-&gt;whenCounted(&apos;songs&apos;),
            &apos;statistics&apos;      =&gt; $this-&gt;whenLoaded(&apos;statistics&apos;, [
                &apos;views&apos;     =&gt; $this-&gt;statistics-&gt;views,
                &apos;plays&apos;     =&gt; $this-&gt;statistics-&gt;plays,
                &apos;shares&apos;    =&gt; $this-&gt;statistics-&gt;shares,
                &apos;favorites&apos; =&gt; $this-&gt;statistics-&gt;favorites,
            ]),
            &apos;songs&apos;           =&gt; SongResource::collection($this-&gt;whenLoaded(&apos;songs&apos;)),
            &apos;owner&apos;           =&gt; $this-&gt;whenLoaded(&apos;user&apos;, [
                &apos;email&apos; =&gt; $this-&gt;user-&gt;email,
                &apos;name&apos;  =&gt; $this-&gt;user-&gt;name,
            ]),
            &apos;collaborators&apos;   =&gt; $this-&gt;whenLoaded(&apos;collaborators&apos;, function () {
                return $this-&gt;collaborators-&gt;map(function ($collaborator) {
                    return [
                        &apos;id&apos;   =&gt; $collaborator-&gt;email,
                        &apos;name&apos; =&gt; $collaborator-&gt;name,
                        &apos;role&apos; =&gt; $collaborator-&gt;pivot-&gt;role,
                    ];
                });
            }),
        ];
    }
}</file><file path="app/Http/Resources/PlaylistStatistic/PlaylistStatisticResource.php">&lt;?php
namespace App\Http\Resources\PlaylistStatistic;
use App\Http\Resources\Playlist\PlaylistResource;
use App\Models\PlaylistStatistic;
use Illuminate\Http\Request;
use Illuminate\Http\Resources\Json\JsonResource;
/**
 * @mixin PlaylistStatistic
 */
class PlaylistStatisticResource extends JsonResource
{
    /**
     * Transform the resource into an array.
     *
     * @return array&lt;string, mixed&gt;
     */
    public function toArray(Request $request): array
    {
        return [
            &apos;views&apos;     =&gt; $this-&gt;views,
            &apos;plays&apos;     =&gt; $this-&gt;plays,
            &apos;shares&apos;    =&gt; $this-&gt;shares,
            &apos;favorites&apos; =&gt; $this-&gt;favorites,
            &apos;playlist&apos; =&gt; PlaylistResource::make($this-&gt;whenLoaded(&apos;playlist&apos;)),
        ];
    }
}</file><file path="app/Http/Resources/Video/VideoResource.php">&lt;?php
namespace App\Http\Resources\Video;
use Illuminate\Http\Request;
use Illuminate\Http\Resources\Json\JsonResource;
class VideoResource extends JsonResource
{
    /**
     * Transform the resource into an array.
     *
     * @return array&lt;string, mixed&gt;
     */
    public function toArray(Request $request): array
    {
        return parent::toArray($request);
    }
}</file><file path="app/Jobs/Auth/RevokeTokenJob.php">&lt;?php
namespace App\Jobs\Auth;
use App\Services\AuthTokenService;
use Illuminate\Bus\Queueable;
use Illuminate\Contracts\Queue\ShouldQueue;
use Illuminate\Foundation\Bus\Dispatchable;
use Illuminate\Queue\InteractsWithQueue;
use Illuminate\Queue\SerializesModels;
class RevokeTokenJob implements ShouldQueue
{
    use Dispatchable, InteractsWithQueue, Queueable, SerializesModels;
    public int $tries = 1;
    /**
     * Create a new job instance.
     */
    public function __construct(
        private readonly string $token,
    )
    {
        //
    }
    /**
     * Execute the job.
     */
    public function handle(): void
    {
        $service = app(AuthTokenService::class);
        if (!$service-&gt;revokeToken($this-&gt;token)) {
            $this-&gt;fail(&apos;Unable to revoke token.&apos;);
        }
    }
}</file><file path="app/Jobs/Library/Metadata/ProbeQueueChecker.php">&lt;?php
namespace App\Jobs\Library\Metadata;
use App\Models\Video;
use Baander\RedisStack\RedisStack;
use Illuminate\Bus\Queueable;
use Illuminate\Contracts\Queue\ShouldQueue;
use Illuminate\Foundation\Bus\Dispatchable;
use Illuminate\Queue\InteractsWithQueue;
use Illuminate\Queue\SerializesModels;
use Illuminate\Support\Facades\Redis;
class ProbeQueueChecker implements ShouldQueue
{
    use Dispatchable, InteractsWithQueue, Queueable;
    /**
     * Execute the job.
     */
    public function handle(): void
    {
        try {
            $key = &apos;queue:probe&apos;;
            $redis = new RedisStack(Redis::connection(&apos;transcodes&apos;)-&gt;client());
            \Log::channel(&apos;stdout&apos;)-&gt;info($redis-&gt;getRedis()-&gt;getDBNum());
            $res = $redis-&gt;getRedis()-&gt;lPop($key);
            if (!$res) {
                return;
            }
            $res = json_decode($res, true);
            \Log::channel(&apos;stdout&apos;)-&gt;info(&apos;Paths&apos;, [
                &apos;file_path&apos; =&gt; $res[&apos;file_path&apos;],
            ]);
            $res[&apos;file_path&apos;] = str_replace(&apos;/mnt/c&apos;, &apos;/storage&apos;, $res[&apos;file_path&apos;]);
            $video = Video::wherePath($res[&apos;file_path&apos;])-&gt;first();
            if ($video) {
                $video-&gt;probe = $res;
                $video-&gt;save();
            }
            $this-&gt;delete();
        } catch (\Error|\Exception $e) {
            \Log::channel(&apos;stdout&apos;)-&gt;error(&apos;Failed to process video files&apos;, [
                &apos;error&apos; =&gt; $e-&gt;getMessage(),
                &apos;trace&apos; =&gt; $e-&gt;getTraceAsString()
            ]);
        }
    }
}</file><file path="app/Jobs/Library/Music/SyncAlbumMetadataJob.php">&lt;?php
namespace App\Jobs\Library\Music;
use App\Jobs\BaseJob;
use App\Models\Album;
use App\Services\Metadata\MetadataSyncService;
use Illuminate\Bus\Queueable;
use Illuminate\Contracts\Queue\ShouldQueue;
use Illuminate\Foundation\Bus\Dispatchable;
use Illuminate\Queue\InteractsWithQueue;
use Illuminate\Queue\SerializesModels;
use Illuminate\Support\Facades\Log;
class SyncAlbumMetadataJob extends BaseJob implements ShouldQueue
{
    use Dispatchable, InteractsWithQueue, Queueable, SerializesModels;
    public function __construct(
        private int $albumId,
        private bool $forceUpdate = false
    ) {}
    public function handle(): void
    {
        $metadataSyncService = app(MetadataSyncService::class);
        $album = Album::find($this-&gt;albumId);
        if (!$album) {
            Log::channel(&apos;stdout&apos;)-&gt;warning(&apos;Album not found for metadata sync&apos;, [&apos;album_id&apos; =&gt; $this-&gt;albumId]);
            return;
        }
        try {
            $results = $metadataSyncService-&gt;syncAlbum($album);
            if ($results[&apos;quality_score&apos;] &gt;= 0.7) {
                $this-&gt;updateAlbumMetadata($album, $results);
                Log::channel(&apos;stdout&apos;)-&gt;info(&apos;Album metadata synced successfully&apos;, [
                    &apos;album_id&apos; =&gt; $album-&gt;id,
                    &apos;source&apos; =&gt; $results[&apos;source&apos;],
                    &apos;quality_score&apos; =&gt; $results[&apos;quality_score&apos;]
                ]);
            } else {
                Log::channel(&apos;stdout&apos;)-&gt;warning(&apos;Album metadata sync rejected due to low quality&apos;, [
                    &apos;album_id&apos; =&gt; $album-&gt;id,
                    &apos;quality_score&apos; =&gt; $results[&apos;quality_score&apos;]
                ]);
            }
        } catch (\Exception|\Error $e) {
            Log::channel(&apos;stdout&apos;)-&gt;error(&apos;Album metadata sync job failed&apos;, [
                &apos;album_id&apos; =&gt; $this-&gt;albumId,
                &apos;error&apos; =&gt; $e-&gt;getMessage()
            ]);
            throw $e;
        }
    }
    private function updateAlbumMetadata(Album $album, array $results): void
    {
        // Update album if data is present and force update is enabled or current data is missing
        if ($results[&apos;album&apos;] &amp;&amp; ($this-&gt;forceUpdate || !$album-&gt;year)) {
            if ($results[&apos;album&apos;][&apos;year&apos;]) {
                $album-&gt;update([
                    &apos;year&apos; =&gt; $results[&apos;album&apos;][&apos;year&apos;]
                ]);
            }
        }
        // Update genres for songs
        if (!empty($results[&apos;genres&apos;])) {
            $this-&gt;updateSongGenres($album, $results[&apos;genres&apos;]);
        }
    }
    private function updateSongGenres(Album $album, array $genreNames): void
    {
        $genres = collect($genreNames)-&gt;map(function ($genreName) {
            return \App\Models\Genre::firstOrCreate([&apos;name&apos; =&gt; $genreName]);
        });
        foreach ($album-&gt;songs as $song) {
            // Only add genres if song doesn&apos;t have any, or if force update is enabled
            if ($this-&gt;forceUpdate || $song-&gt;genres-&gt;isEmpty()) {
                $song-&gt;genres()-&gt;sync($genres-&gt;pluck(&apos;id&apos;));
            }
        }
    }
}</file><file path="app/Jobs/Library/Music/SyncArtistMetadataJob.php">&lt;?php
namespace App\Jobs\Library\Music;
use App\Models\Artist;
use App\Services\Metadata\MetadataSyncService;
use Illuminate\Bus\Queueable;
use Illuminate\Contracts\Queue\ShouldQueue;
use Illuminate\Foundation\Bus\Dispatchable;
use Illuminate\Queue\InteractsWithQueue;
use Illuminate\Queue\SerializesModels;
use Illuminate\Support\Facades\Log;
class SyncArtistMetadataJob implements ShouldQueue
{
    use Dispatchable, InteractsWithQueue, Queueable, SerializesModels;
    public function __construct(
        private int $artistId,
        private bool $forceUpdate = false
    ) {}
    public function handle(): void
    {
        $metadataSyncService = app(MetadataSyncService::class);
        $artist = Artist::find($this-&gt;artistId);
        if (!$artist) {
            Log::warning(&apos;Artist not found for metadata sync&apos;, [&apos;artist_id&apos; =&gt; $this-&gt;artistId]);
            return;
        }
        try {
            $results = $metadataSyncService-&gt;syncArtist($artist);
            if ($results[&apos;quality_score&apos;] &gt;= 0.7) {
                $this-&gt;updateArtistMetadata($artist, $results);
                Log::info(&apos;Artist metadata synced successfully&apos;, [
                    &apos;artist_id&apos; =&gt; $artist-&gt;id,
                    &apos;source&apos; =&gt; $results[&apos;source&apos;],
                    &apos;quality_score&apos; =&gt; $results[&apos;quality_score&apos;]
                ]);
            } else {
                Log::warning(&apos;Artist metadata sync rejected due to low quality&apos;, [
                    &apos;artist_id&apos; =&gt; $artist-&gt;id,
                    &apos;quality_score&apos; =&gt; $results[&apos;quality_score&apos;]
                ]);
            }
        } catch (\Exception $e) {
            Log::error(&apos;Artist metadata sync job failed&apos;, [
                &apos;artist_id&apos; =&gt; $this-&gt;artistId,
                &apos;error&apos; =&gt; $e-&gt;getMessage()
            ]);
            throw $e;
        }
    }
    private function updateArtistMetadata(Artist $artist, array $results): void
    {
        // Currently, artist metadata mainly consists of name and external IDs
        // Additional fields like bio, country, etc. could be added to the model later
        // Log successful sync for now - can be extended when more artist fields are added
        Log::info(&apos;Artist metadata processed&apos;, [
            &apos;artist_id&apos; =&gt; $artist-&gt;id,
            &apos;albums_found&apos; =&gt; count($results[&apos;albums&apos;] ?? []),
            &apos;source&apos; =&gt; $results[&apos;source&apos;]
        ]);
    }
}</file><file path="app/Jobs/Library/Music/SyncSmartPlaylists.php">&lt;?php
namespace App\Jobs\Library\Music;
use App\Jobs\BaseJob;
use App\Models\Playlist;
use App\Services\SmartPlaylistService;
use Illuminate\Bus\Queueable;
use Illuminate\Contracts\Queue\ShouldQueue;
use Illuminate\Foundation\Bus\Dispatchable;
use Illuminate\Queue\{InteractsWithQueue, SerializesModels, Middleware\WithoutOverlapping};
class SyncSmartPlaylists extends BaseJob implements ShouldQueue
{
    use Dispatchable, InteractsWithQueue, Queueable, SerializesModels;
    public function middleware(): array
    {
        return [new WithoutOverlapping(&apos;sync_smart_playlists&apos;)-&gt;dontRelease()];
    }
    /**
     * Execute the job.
     */
    public function handle(): void
    {
        $playlists = Playlist::whereIsSmart(true)-&gt;get();
        $playlistCount = $playlists-&gt;count();
        $service = app(SmartPlaylistService::class);
        $this-&gt;queueProgress(0);
        foreach ($playlists as $playlist) {
            $service-&gt;sync($playlist);
            $this-&gt;queueProgress(100 / $playlistCount);
        }
        $this-&gt;queueProgress(100);
        unset($service, $playlists);
    }
}</file><file path="app/Jobs/Library/Music/SyncSongMetadataJob.php">&lt;?php
namespace App\Jobs\Library\Music;
use App\Models\Song;
use App\Services\Metadata\MetadataSyncService;
use Illuminate\Bus\Queueable;
use Illuminate\Contracts\Queue\ShouldQueue;
use Illuminate\Foundation\Bus\Dispatchable;
use Illuminate\Queue\InteractsWithQueue;
use Illuminate\Queue\SerializesModels;
use Illuminate\Support\Facades\Log;
class SyncSongMetadataJob implements ShouldQueue
{
    use Dispatchable, InteractsWithQueue, Queueable, SerializesModels;
    public function __construct(
        private int $songId,
        private bool $forceUpdate = false
    ) {}
    public function handle(): void
    {
        $metadataSyncService = app(MetadataSyncService::class);
        $song = Song::find($this-&gt;songId);
        if (!$song) {
            Log::warning(&apos;Song not found for metadata sync&apos;, [&apos;song_id&apos; =&gt; $this-&gt;songId]);
            return;
        }
        try {
            $results = $metadataSyncService-&gt;syncSong($song);
            if ($results[&apos;quality_score&apos;] &gt;= 0.6) {
                $this-&gt;updateSongMetadata($song, $results);
                Log::info(&apos;Song metadata synced successfully&apos;, [
                    &apos;song_id&apos; =&gt; $song-&gt;id,
                    &apos;source&apos; =&gt; $results[&apos;source&apos;],
                    &apos;quality_score&apos; =&gt; $results[&apos;quality_score&apos;]
                ]);
            } else {
                Log::warning(&apos;Song metadata sync rejected due to low quality&apos;, [
                    &apos;song_id&apos; =&gt; $song-&gt;id,
                    &apos;quality_score&apos; =&gt; $results[&apos;quality_score&apos;]
                ]);
            }
        } catch (\Exception $e) {
            Log::error(&apos;Song metadata sync job failed&apos;, [
                &apos;song_id&apos; =&gt; $this-&gt;songId,
                &apos;error&apos; =&gt; $e-&gt;getMessage()
            ]);
            throw $e;
        }
    }
    private function updateSongMetadata(Song $song, array $results): void
    {
        $updateData = [];
        // Update song data if available and conditions are met
        if ($results[&apos;song&apos;]) {
            if (($this-&gt;forceUpdate || !$song-&gt;length) &amp;&amp; isset($results[&apos;song&apos;][&apos;length&apos;])) {
                $updateData[&apos;length&apos;] = $results[&apos;song&apos;][&apos;length&apos;];
            }
        }
        // Update the song if we have data to update
        if (!empty($updateData)) {
            $song-&gt;update($updateData);
        }
        // Update genres
        if (!empty($results[&apos;genres&apos;])) {
            $this-&gt;updateSongGenres($song, $results[&apos;genres&apos;]);
        }
        // Update artists if available
        if (!empty($results[&apos;artists&apos;])) {
            $this-&gt;updateSongArtists($song, $results[&apos;artists&apos;]);
        }
    }
    private function updateSongGenres(Song $song, array $genreNames): void
    {
        $genres = collect($genreNames)-&gt;map(function ($genreName) {
            return \App\Models\Genre::firstOrCreate([&apos;name&apos; =&gt; $genreName]);
        });
        // Only update if song doesn&apos;t have genres, or if force update is enabled
        if ($this-&gt;forceUpdate || $song-&gt;genres-&gt;isEmpty()) {
            $song-&gt;genres()-&gt;sync($genres-&gt;pluck(&apos;id&apos;));
        }
    }
    private function updateSongArtists(Song $song, array $artistsData): void
    {
        // Only update if song doesn&apos;t have artists, or if force update is enabled
        if (!$this-&gt;forceUpdate &amp;&amp; $song-&gt;artists-&gt;isNotEmpty()) {
            return;
        }
        $artists = collect($artistsData)-&gt;map(function ($artistData) {
            return \App\Models\Artist::firstOrCreate([&apos;name&apos; =&gt; $artistData[&apos;name&apos;]]);
        });
        $song-&gt;artists()-&gt;sync($artists-&gt;pluck(&apos;id&apos;));
    }
}</file><file path="app/Jobs/Middleware/ResourceMonitor.php">&lt;?php
namespace App\Jobs\Middleware;
use App\Jobs\BaseJob;
use App\Modules\Apm\Apm;
use App\Services\SystemMonitor;
use Laravel\Octane\Facades\Octane;
use Swoole\Timer;
class ResourceMonitor
{
    private int $tickId;
    public function handle(BaseJob $job, $next)
    {
        Apm::getTransaction()-&gt;setName($job-&gt;getName());
        Apm::getTransaction()-&gt;setType(&apos;job&apos;);
        $id = $job-&gt;job?-&gt;getJobId();
        if (!$id) {
            return $next($job);
        }
        $systemMonitor = new SystemMonitor();
        $this-&gt;tickId = Timer::tick(5000, function () use ($systemMonitor, $id) {
            Apm::getTransactionStats();
            $systemLoad = $systemMonitor-&gt;getSystemLoad();
            $existing = Octane::table(&apos;job_resource_monitor&apos;)-&gt;get($id);
            $cpuUsage = $systemLoad[&apos;cpu&apos;][&apos;overall_percentage&apos;];
            $memoryUsage = $systemLoad[&apos;memory&apos;][&apos;used_percentage&apos;];
            $memoryMb = $systemLoad[&apos;memory&apos;][&apos;used_mb&apos;];
            if (!$existing) {
                Octane::table(&apos;job_resource_monitor&apos;)-&gt;set($id, [
                    &apos;samples&apos; =&gt; 1,
                    &apos;cpu_avg&apos; =&gt; $cpuUsage,
                    &apos;memory_avg&apos; =&gt; $memoryUsage,
                    &apos;cpu_peak&apos; =&gt; $cpuUsage,
                    &apos;memory_peak&apos; =&gt; $memoryUsage,
                    &apos;cpu_min&apos; =&gt; $cpuUsage,
                    &apos;memory_min&apos; =&gt; $memoryUsage,
                    &apos;started_at&apos; =&gt; time(),
                    &apos;last_updated&apos; =&gt; time(),
                    &apos;last_cpu&apos; =&gt; $cpuUsage,
                    &apos;last_memory&apos; =&gt; $memoryUsage,
                    &apos;memory_mb&apos; =&gt; $memoryMb,
                    &apos;status&apos; =&gt; &apos;running&apos;,
                ]);
            } else {
                $samples = $existing[&apos;samples&apos;] + 1;
                Octane::table(&apos;job_resource_monitor&apos;)-&gt;set($id, [
                    &apos;samples&apos; =&gt; $samples,
                    &apos;cpu_avg&apos; =&gt; (($existing[&apos;cpu_avg&apos;] * $existing[&apos;samples&apos;]) + $cpuUsage) / $samples,
                    &apos;memory_avg&apos; =&gt; (($existing[&apos;memory_avg&apos;] * $existing[&apos;samples&apos;]) + $memoryUsage) / $samples,
                    &apos;cpu_peak&apos; =&gt; max($existing[&apos;cpu_peak&apos;], $cpuUsage),
                    &apos;memory_peak&apos; =&gt; max($existing[&apos;memory_peak&apos;], $memoryUsage),
                    &apos;cpu_min&apos; =&gt; min($existing[&apos;cpu_min&apos;], $cpuUsage),
                    &apos;memory_min&apos; =&gt; min($existing[&apos;memory_min&apos;], $memoryUsage),
                    &apos;started_at&apos; =&gt; $existing[&apos;started_at&apos;],
                    &apos;last_updated&apos; =&gt; time(),
                    &apos;last_cpu&apos; =&gt; $cpuUsage,
                    &apos;last_memory&apos; =&gt; $memoryUsage,
                    &apos;memory_mb&apos; =&gt; $memoryMb,
                    &apos;status&apos; =&gt; &apos;running&apos;,
                ]);
            }
        });
        try {
            $result = $next($job);
            // Stop the tick and update final status when job completes successfully
            $this-&gt;stopMonitoring($id, &apos;completed&apos;);
            return $result;
        } catch (\Throwable $exception) {
            // Stop the tick and update status when job fails
            $this-&gt;stopMonitoring($id, &apos;failed&apos;);
            throw $exception;
        }
    }
    private function stopMonitoring(string $id, string $status): void
    {
        // Stop the tick
        Timer::clear($this-&gt;tickId);
        // Update final status in the table
        $existing = Octane::table(&apos;job_resource_monitor&apos;)-&gt;get($id);
        if ($existing) {
            Octane::table(&apos;job_resource_monitor&apos;)-&gt;set($id, array_merge($existing, [
                &apos;status&apos; =&gt; $status,
                &apos;finished_at&apos; =&gt; time(),
                &apos;last_updated&apos; =&gt; time(),
            ]));
        }
    }
}</file><file path="app/Jobs/Movies/ScanMovieLibraryJob.php">&lt;?php
namespace App\Jobs\Movies;
use App\Jobs\BaseJob;
use App\Models\{Library, Movie, Video};
use Illuminate\Bus\Queueable;
use Illuminate\Contracts\Queue\ShouldQueue;
use Illuminate\Foundation\Bus\Dispatchable;
use Illuminate\Queue\InteractsWithQueue;
use Illuminate\Queue\Middleware\WithoutOverlapping;
use Illuminate\Queue\SerializesModels;
use Illuminate\Support\Facades\{DB, File};
use Illuminate\Support\LazyCollection;
class ScanMovieLibraryJob extends BaseJob implements ShouldQueue
{
    use Dispatchable, InteractsWithQueue, Queueable, SerializesModels;
    private array $movieCache = [];
    /**
     * Create a new job instance.
     */
    public function __construct(public Library $library)
    {
        //
    }
    public function middleware(): array
    {
        return [new WithoutOverlapping($this-&gt;library-&gt;id)-&gt;dontRelease()];
    }
    /**
     * Execute the job.
     */
    public function handle(): void
    {
        try {
            $this-&gt;queueProgress(0);
            $this-&gt;library-&gt;updateLastScan();
            $path = $this-&gt;library-&gt;path;
            $directories = LazyCollection::make(File::directories($path));
            \Log::channel(&apos;stdout&apos;)-&gt;info(&apos;Found &apos; . $directories-&gt;count() . &apos; directories in &apos; . $path);
            $totalDirectories = count($directories);
            $processedDirectories = 0;
            $chunkSize = 10;
            $directories-&gt;chunk($chunkSize)-&gt;each(function ($chunk) use (&amp;$processedDirectories, $totalDirectories, &amp;$chunkSize) {
                \Log::channel(&apos;stdout&apos;)-&gt;info(&apos;Processing &apos; . $processedDirectories . &apos;/&apos; . $totalDirectories . &apos; directories&apos;);
                foreach ($chunk as $directory) {
                    try {
                        $this-&gt;scanDirectory($directory);
                    } catch (\Exception $e) {
                        \Log::channel(&apos;stdout&apos;)-&gt;error(&apos;Failed to scan directory: &apos; . $directory, [
                            &apos;error&apos; =&gt; $e-&gt;getMessage(),
                            &apos;trace&apos; =&gt; $e-&gt;getTraceAsString()
                        ]);
                    }
                    $processedDirectories++;
                    $this-&gt;queueProgressChunk($totalDirectories, $chunkSize);
                }
            });
            unset($this-&gt;library, $this-&gt;movieCache);
        } catch (\Exception $e) {
            \Log::channel(&apos;stdout&apos;)-&gt;error(&apos;ScanMovieLibraryJob failed&apos;, [
                &apos;error&apos; =&gt; $e-&gt;getMessage(),
                &apos;trace&apos; =&gt; $e-&gt;getTraceAsString()
            ]);
            throw $e;
        }
        $this-&gt;delete();
    }
    private function scanDirectory(string $directory): void
    {
        try {
            $files = LazyCollection::make(File::files($directory));
            \Log::channel(&apos;stdout&apos;)-&gt;info(&apos;Found &apos; . $files-&gt;count() . &apos; files in &apos; . $directory);
            $movieInfo = $this-&gt;parseMovieFromDirectoryName($directory);
            if (!$movieInfo) {
                \Log::channel(&apos;stdout&apos;)-&gt;error(&apos;Failed to parse movie info from directory name&apos;, [
                    &apos;directory&apos; =&gt; $directory,
                ]);
                return;
            }
            $movie = $this-&gt;findOrCreateMovie($movieInfo);
            \Log::channel(&apos;stdout&apos;)-&gt;info(&apos;Movie found/created&apos;, [&apos;movie_id&apos; =&gt; $movie-&gt;id, &apos;title&apos; =&gt; $movie-&gt;title]);
            $files-&gt;each(function (\SplFileInfo $file) {
                try {
                    $mimeType = mime_content_type($file-&gt;getRealPath());
                } catch (\Exception $e) {
                    \Log::channel(&apos;stdout&apos;)-&gt;error(&apos;Failed to get mime type for file: &apos; . $file-&gt;getFilename(), [
                        &apos;path&apos; =&gt; $file-&gt;getRealPath(),
                        &apos;error&apos; =&gt; $e-&gt;getMessage(),
                        &apos;trace&apos; =&gt; $e-&gt;getTraceAsString()
                    ]);
                }
            });
            $videoFiles = $files-&gt;filter(function (\SplFileInfo $file) {
                try {
                    $mimeType = mime_content_type($file-&gt;getRealPath());
                    return explode(&apos;/&apos;, $mimeType)[0] === &apos;video&apos;;
                } catch (\Exception $e) {
                    \Log::channel(&apos;stdout&apos;)-&gt;error(&apos;Failed to get mime type for file: &apos; . $file-&gt;getFilename(), [
                        &apos;error&apos; =&gt; $e-&gt;getMessage()
                    ]);
                    return false;
                }
            });
            \Log::channel(&apos;stdout&apos;)-&gt;info(&apos;Found video files&apos;, [&apos;count&apos; =&gt; $videoFiles-&gt;count()]);
            if ($videoFiles-&gt;count() &gt; 0) {
                \Log::channel(&apos;stdout&apos;)-&gt;info(&apos;Processing video files...&apos;);
                $this-&gt;processVideoFiles($videoFiles, $movie);
                \Log::channel(&apos;stdout&apos;)-&gt;info(&apos;Finished processing video files&apos;);
            } else {
                \Log::channel(&apos;stdout&apos;)-&gt;info(&apos;No video files found in directory&apos;);
            }
        } catch (\Exception $e) {
            \Log::channel(&apos;stdout&apos;)-&gt;error(&apos;Failed to scan directory: &apos; . $directory, [
                &apos;error&apos; =&gt; $e-&gt;getMessage(),
                &apos;trace&apos; =&gt; $e-&gt;getTraceAsString()
            ]);
            throw $e;
        }
    }
    private function processVideoFiles(LazyCollection $videoFiles, Movie $movie): void
    {
        try {
            $maxOrder = DB::table(&apos;movie_video&apos;)
                -&gt;where(&apos;movie_id&apos;, $movie-&gt;id)
                -&gt;max(&apos;order&apos;) ?? 0;
            $nextOrder = $maxOrder + 1;
            $videoFiles-&gt;chunk(50)-&gt;each(function ($chunk) use ($movie, &amp;$nextOrder) {
                try {
                    $fileData = [];
                    foreach ($chunk as $file) {
                        $hash = Video::makeHash($file);
                        $fileData[$hash] = [
                            &apos;file&apos; =&gt; $file,
                            &apos;hash&apos; =&gt; $hash,
                        ];
                    }
                    $existingVideos = Video::select(&apos;id&apos;, &apos;hash&apos;)
                        -&gt;whereIn(&apos;hash&apos;, array_keys($fileData))
                        -&gt;get()
                        -&gt;keyBy(&apos;hash&apos;);
                    // Get existing video IDs for association check
                    $existingVideoIds = $existingVideos-&gt;map(fn($video) =&gt; $video-&gt;id)-&gt;toArray();
                    // Single query to check which videos are already associated with this movie
                    $associatedVideoIds = [];
                    if (!empty($existingVideoIds)) {
                        $associatedVideoIds = DB::table(&apos;movie_video&apos;)
                            -&gt;select(&apos;video_id&apos;)
                            -&gt;where(&apos;movie_id&apos;, $movie-&gt;id)
                            -&gt;whereIn(&apos;video_id&apos;, $existingVideoIds)
                            -&gt;get()
                            -&gt;map(fn($row) =&gt; $row-&gt;video_id)
                            -&gt;toArray();
                    }
                    $videosToCreate = [];
                    $videosToAssociate = [];
                    foreach ($fileData as $hash =&gt; $data) {
                        $file = $data[&apos;file&apos;];
                        if ($existingVideos-&gt;has($hash)) {
                            // Video exists, check if it needs to be associated
                            $video = $existingVideos[$hash];
                            if (!in_array($video-&gt;id, $associatedVideoIds)) {
                                $videosToAssociate[] = [
                                    &apos;movie_id&apos; =&gt; $movie-&gt;id,
                                    &apos;video_id&apos; =&gt; $video-&gt;id,
                                    &apos;order&apos; =&gt; $nextOrder++
                                ];
                            }
                        } else {
                            // Video doesn&apos;t exist, prepare for bulk creation
                            $videosToCreate[] = [
                                &apos;hash&apos; =&gt; $hash,
                                &apos;path&apos; =&gt; $file-&gt;getRealPath(),
                                &apos;created_at&apos; =&gt; now(),
                                &apos;updated_at&apos; =&gt; now(),
                            ];
                        }
                    }
                    // Bulk insert new videos
                    if (!empty($videosToCreate)) {
                        Video::insert($videosToCreate);
                        // Get the newly created video IDs
                        $newVideoHashes = array_column($videosToCreate, &apos;hash&apos;);
                        $newVideos = Video::select(&apos;id&apos;, &apos;hash&apos;)
                            -&gt;whereIn(&apos;hash&apos;, $newVideoHashes)
                            -&gt;get()
                            -&gt;keyBy(&apos;hash&apos;);
                        // Prepare associations for new videos
                        foreach ($videosToCreate as $videoData) {
                            $video = $newVideos[$videoData[&apos;hash&apos;]];
                            $videosToAssociate[] = [
                                &apos;movie_id&apos; =&gt; $movie-&gt;id,
                                &apos;video_id&apos; =&gt; $video-&gt;id,
                                &apos;order&apos; =&gt; $nextOrder++
                            ];
                        }
                    }
                    if (!empty($videosToAssociate)) {
                        DB::table(&apos;movie_video&apos;)-&gt;insert($videosToAssociate);
                    }
                } catch (\Exception $e) {
                    \Log::channel(&apos;stdout&apos;)-&gt;error(&apos;Failed to process video files chunk&apos;, [
                        &apos;movie_id&apos; =&gt; $movie-&gt;id,
                        &apos;error&apos; =&gt; $e-&gt;getMessage(),
                        &apos;trace&apos; =&gt; $e-&gt;getTraceAsString()
                    ]);
                    throw $e;
                }
            });
        } catch (\Exception $e) {
            \Log::channel(&apos;stdout&apos;)-&gt;error(&apos;Failed to process video files&apos;, [
                &apos;movie_id&apos; =&gt; $movie-&gt;id,
                &apos;error&apos; =&gt; $e-&gt;getMessage(),
                &apos;trace&apos; =&gt; $e-&gt;getTraceAsString()
            ]);
            throw $e;
        }
    }
    private function parseMovieFromDirectoryName(string $directory): ?array
    {
        $directoryName = basename($directory);
        // Pattern to match the &quot;Title (Year)&quot; format
        $pattern = &apos;/^(.+?)\s*\((\d{4})\)\s*$/&apos;;
        if (preg_match($pattern, $directoryName, $matches)) {
            return [
                &apos;title&apos; =&gt; trim($matches[1]),
                &apos;year&apos; =&gt; (int) $matches[2]
            ];
        }
        // Alternative patterns for different formats
        $alternativePatterns = [
            // &quot;Title - Year&quot; format
            &apos;/^(.+?)\s*-\s*(\d{4})\s*$/&apos;,
            // &quot;Title.Year&quot; format (dot separated)
            &apos;/^(.+?)\.(\d{4})\s*$/&apos;,
            // &quot;Title Year&quot; format (space separated, year at the end)
            &apos;/^(.+?)\s+(\d{4})\s*$/&apos;,
        ];
        foreach ($alternativePatterns as $altPattern) {
            if (preg_match($altPattern, $directoryName, $matches)) {
                return [
                    &apos;title&apos; =&gt; trim($matches[1]),
                    &apos;year&apos; =&gt; (int) $matches[2]
                ];
            }
        }
        // If no year is found, check if we have just a title
        if (!empty(trim($directoryName))) {
            return [
                &apos;title&apos; =&gt; trim($directoryName),
                &apos;year&apos; =&gt; null
            ];
        }
        return null;
    }
    private function findOrCreateMovie(array $movieInfo): Movie
    {
        // Create a cache key for this movie
        $cacheKey = $movieInfo[&apos;title&apos;] . &apos;|&apos; . ($movieInfo[&apos;year&apos;] ?? &apos;null&apos;);
        if (isset($this-&gt;movieCache[$cacheKey])) {
            return $this-&gt;movieCache[$cacheKey];
        }
        $query = Movie::where(&apos;title&apos;, $movieInfo[&apos;title&apos;]);
        if ($movieInfo[&apos;year&apos;]) {
            $query-&gt;where(&apos;year&apos;, $movieInfo[&apos;year&apos;]);
        } else {
            $query-&gt;whereNull(&apos;year&apos;);
        }
        $movie = $query-&gt;first();
        if (!$movie) {
            $movie = new Movie([
                &apos;title&apos; =&gt; $movieInfo[&apos;title&apos;],
                &apos;year&apos; =&gt; $movieInfo[&apos;year&apos;],
            ]);
            $movie-&gt;library()-&gt;associate($this-&gt;library);
            $movie-&gt;saveOrFail();
        }
        // Cache the movie for this job instance
        $this-&gt;movieCache[$cacheKey] = $movie;
        return $movie;
    }
}</file><file path="app/Jobs/Recommendation/GenerateRecommendationsJob.php">&lt;?php
namespace App\Jobs\Recommendation;
use App\Modules\Recommendation\Services\RecommendationService;
use Illuminate\Bus\Queueable;
use Illuminate\Contracts\Queue\ShouldQueue;
use Illuminate\Foundation\Bus\Dispatchable;
use Illuminate\Queue\InteractsWithQueue;
use Illuminate\Queue\SerializesModels;
class GenerateRecommendationsJob implements ShouldQueue
{
    use Dispatchable, InteractsWithQueue, Queueable, SerializesModels;
    /**
     * The model class to generate recommendations for
     *
     * @var string
     */
    public string $modelClass;
    /**
     * The name of the recommendation set
     *
     * @var string
     */
    public string $recommendationName;
    /**
     * Create a new job instance.
     *
     * @param string $modelClass
     * @param string $recommendationName
     * @return void
     */
    public function __construct(string $modelClass, string $recommendationName)
    {
        $this-&gt;modelClass = $modelClass;
        $this-&gt;recommendationName = $recommendationName;
        // Set queue connection and name from config
        $this-&gt;onConnection(config(&apos;recommendation.queue.connection&apos;));
        $this-&gt;onQueue(config(&apos;recommendation.queue.queue&apos;, &apos;recommendations&apos;));
    }
    /**
     * Execute the job.
     *
     * @param RecommendationService $recommendationService
     * @return void
     */
    public function handle(RecommendationService $recommendationService): void
    {
        $recommendationService-&gt;generateRecommendations(
            $this-&gt;modelClass,
            $this-&gt;recommendationName
        );
    }
}</file><file path="app/Listeners/Auth/LogoutInvalidateTokenCache.php">&lt;?php
namespace App\Listeners\Auth;
use App\Models\PersonalAccessToken;
use Illuminate\Auth\Events\Logout;
class LogoutInvalidateTokenCache
{
    /**
     * Handle the event.
     */
    public function handle(Logout $event): void
    {
        if (!config(&apos;sanctum.invalidate_on_logout&apos;)) {
            return;
        }
        // Revoke current token if using API
        $currentToken = $event-&gt;user-&gt;currentAccessToken();
        if ($currentToken) {
            // Remove from cache first
            PersonalAccessToken::invalidateTokenCache($currentToken-&gt;id);
            // Then delete from database
            $currentToken-&gt;delete();
        }
    }
}</file><file path="app/Mail/MailbookMail.php">&lt;?php
namespace App\Mail;
use Illuminate\Mail\Mailable;
use Illuminate\Mail\Mailables\Address;
use Illuminate\Mail\Mailables\Content;
use Illuminate\Mail\Mailables\Envelope;
class MailbookMail extends Mailable
{
    public function envelope(): Envelope
    {
        return new Envelope(
            from: new Address(&apos;laravel@mailbook.dev&apos;, &apos;Mailbook&apos;),
            subject: &apos;Welcome to Mailbook!&apos;,
        );
    }
    public function content(): Content
    {
        return new Content(
            markdown: &apos;mail.mailbook&apos;,
        );
    }
}</file><file path="app/Models/AlbumArtist.php">&lt;?php
namespace App\Models;
use App\Models\BaseModel;
use Illuminate\Database\Eloquent\Factories\HasFactory;
use Illuminate\Database\Eloquent\Relations\Pivot;
class AlbumArtist extends BasePivot
{
    use HasFactory;
    public $timestamps = false;
    public function album()
    {
        return $this-&gt;belongsTo(Album::class);
    }
    public function artist()
    {
        return $this-&gt;belongsTo(Artist::class);
    }
}</file><file path="app/Models/ArtistSong.php">&lt;?php
namespace App\Models;
class ArtistSong extends BasePivot
{
    public function artist()
    {
        return $this-&gt;belongsTo(Artist::class);
    }
    public function song()
    {
        return $this-&gt;belongsTo(Song::class);
    }
}</file><file path="app/Models/Concerns/HasLibraryAccess.php">&lt;?php
namespace App\Models\Concerns;
use App\Models\UserLibrary;
trait HasLibraryAccess
{
    /**
     * Determine if a user has access to the library.
     *
     * @param int $userId
     * @param int $libraryId
     * @return bool
     */
    public function userHasAccessToLibrary(int $userId, int $libraryId): bool
    {
        return UserLibrary::where(&apos;user_id&apos;, $userId)
            -&gt;where(&apos;library_id&apos;, $libraryId)
            -&gt;exists();
    }
}</file><file path="app/Models/GenreSong.php">&lt;?php
namespace App\Models;
use Illuminate\Database\Eloquent\Relations\Pivot;
class GenreSong extends Pivot
{
    public $timestamps = false;
    public function genre()
    {
        return $this-&gt;belongsTo(Genre::class);
    }
    public function song()
    {
        return $this-&gt;belongsTo(Song::class);
    }
}</file><file path="app/Models/Movie.php">&lt;?php
namespace App\Models;
use App\Models\BaseModel;
use Illuminate\Database\Eloquent\Factories\HasFactory;
use Spatie\Sluggable\HasSlug;
use Spatie\Sluggable\SlugOptions;
class Movie extends BaseModel
{
    use HasFactory, HasSlug;
    protected $fillable = [
        &apos;title&apos;,
        &apos;year&apos;,
        &apos;summary&apos;,
    ];
    /**
     * Get the options for generating the slug.
     */
    public function getSlugOptions(): SlugOptions
    {
        return SlugOptions::create()
            -&gt;generateSlugsFrom([&apos;title&apos;, &apos;year&apos;])
            -&gt;saveSlugsTo(&apos;slug&apos;);
    }
    public function getRouteKeyName(): string
    {
        return &apos;slug&apos;;
    }
    public function library()
    {
        return $this-&gt;belongsTo(Library::class);
    }
    public function videos()
    {
        return $this-&gt;belongsToMany(Video::class)
            -&gt;using(MovieVideo::class)
            -&gt;withPivot(&apos;order&apos;);
    }
}</file><file path="app/Models/MovieVideo.php">&lt;?php
namespace App\Models;
class MovieVideo extends BasePivot
{
    public $timestamps = false;
    protected $fillable = [
        &apos;order&apos;,
    ];
    public function movie()
    {
        return $this-&gt;belongsTo(Movie::class);
    }
    public function video()
    {
        return $this-&gt;belongsTo(Video::class);
    }
}</file><file path="app/Models/PlaylistCollaborator.php">&lt;?php
namespace App\Models;
use Illuminate\Database\Eloquent\Relations\Pivot;
class PlaylistCollaborator extends Pivot
{
    protected $fillable = [
        &apos;role&apos;,
    ];
    public function playlist()
    {
        return $this-&gt;belongsTo(Playlist::class);
    }
    public function user()
    {
        return $this-&gt;belongsTo(User::class);
    }
}</file><file path="app/Models/PlaylistSong.php">&lt;?php
namespace App\Models;
use Illuminate\Database\Eloquent\Relations\Pivot;
class PlaylistSong extends Pivot
{
    protected $table = &apos;playlist_song&apos;;
    protected $fillable = [
        &apos;playlist_id&apos;,
        &apos;song_id&apos;,
        &apos;position&apos;,
    ];
    public function playlist()
    {
        return $this-&gt;belongsTo(Playlist::class);
    }
    public function song()
    {
        return $this-&gt;belongsTo(Song::class);
    }
}</file><file path="app/Models/PlaylistStatistic.php">&lt;?php
namespace App\Models;
use App\Models\BaseModel;
use Illuminate\Database\Eloquent\Factories\HasFactory;
class PlaylistStatistic extends BaseModel
{
    use HasFactory;
    protected $fillable = [
        &apos;playlist_id&apos;,
        &apos;views&apos;,
        &apos;plays&apos;,
        &apos;shares&apos;,
        &apos;favorites&apos;,
    ];
    public function playlist()
    {
        return $this-&gt;belongsTo(Playlist::class);
    }
}</file><file path="app/Models/Queries/Trend/Trend.php">&lt;?php
namespace App\Models\Queries\Trend;
use Illuminate\Support\Collection;
use Carbon\{CarbonInterface, CarbonPeriod};
use Illuminate\Database\Eloquent\Builder;
use InvalidArgumentException;
class Trend
{
    public const array INTERVALS = [
        &apos;minute&apos; =&gt; &apos;YYYY-MM-DD HH24:MI&apos;,
        &apos;hour&apos;   =&gt; &apos;YYYY-MM-DD HH24&apos;,
        &apos;day&apos;    =&gt; &apos;YYYY-MM-DD&apos;,
        &apos;week&apos;   =&gt; &apos;IYYY-IW&apos;,
        &apos;month&apos;  =&gt; &apos;YYYY-MM&apos;,
        &apos;year&apos;   =&gt; &apos;YYYY&apos;,
    ];
    public string $interval;
    public CarbonInterface $start;
    public CarbonInterface $end;
    public string $dateColumn = &apos;created_at&apos;;
    public string $dateAlias = &apos;date&apos;;
    public ?string $groupingColumn = null;
    protected Builder $builder;
    public function __construct(Builder $builder)
    {
        $this-&gt;builder = $builder;
    }
    public static function query(Builder $builder): self
    {
        return new self($builder);
    }
    public static function model(string $model): self
    {
        return new self($model::newQuery());
    }
    public function between(CarbonInterface $start, CarbonInterface $end): self
    {
        $this-&gt;start = $start;
        $this-&gt;end = $end;
        return $this;
    }
    public function interval(string $interval): self
    {
        if (!array_key_exists($interval, self::INTERVALS)) {
            throw new InvalidArgumentException(&quot;Unsupported interval: {$interval}&quot;);
        }
        $this-&gt;interval = $interval;
        return $this;
    }
    public function perInterval(string $interval): self
    {
        return $this-&gt;interval($interval);
    }
    public function dateColumn(string $column): self
    {
        $this-&gt;dateColumn = $column;
        return $this;
    }
    public function dateAlias(string $alias): self
    {
        $this-&gt;dateAlias = $alias;
        return $this;
    }
    public function groupBy(string $groupingColumn): self
    {
        $this-&gt;groupingColumn = $groupingColumn;
        return $this;
    }
    public function aggregate(string $column, string $aggregate): Collection
    {
        $sqlDate = $this-&gt;getSqlDate();
        $query = $this-&gt;builder-&gt;toBase()-&gt;selectRaw(&quot;
            {$sqlDate} as {$this-&gt;dateAlias},
            {$aggregate}({$column}) as aggregate&quot; .
            ($this-&gt;groupingColumn ? &quot;, {$this-&gt;groupingColumn} as group&quot; : &quot;&quot;),
        )-&gt;whereBetween($this-&gt;dateColumn, [$this-&gt;start, $this-&gt;end])
            -&gt;groupBy($this-&gt;dateAlias);
        if ($this-&gt;groupingColumn) {
            $query-&gt;groupBy($this-&gt;groupingColumn);
        }
        $query-&gt;orderBy($this-&gt;dateAlias);
        $values = $query-&gt;get();
        if ($this-&gt;groupingColumn) {
            return $values-&gt;groupBy(&apos;group&apos;)-&gt;map(fn($group) =&gt; $this-&gt;mapValuesToDates($group));
        }
        return $this-&gt;mapValuesToDates($values);
    }
    public function average(string $column): Collection
    {
        return $this-&gt;aggregate($column, &apos;avg&apos;);
    }
    public function min(string $column): Collection
    {
        return $this-&gt;aggregate($column, &apos;min&apos;);
    }
    public function max(string $column): Collection
    {
        return $this-&gt;aggregate($column, &apos;max&apos;);
    }
    public function sum(string $column): Collection
    {
        return $this-&gt;aggregate($column, &apos;sum&apos;);
    }
    public function count(string $column = &apos;*&apos;): Collection
    {
        return $this-&gt;aggregate($column, &apos;count&apos;);
    }
    public function rate(string $column, string $aggregate): Collection
    {
        $sqlDate = $this-&gt;getSqlDate();
        $values = $this-&gt;builder-&gt;toBase()-&gt;selectRaw(&quot;
            {$sqlDate} as {$this-&gt;dateAlias},
            {$column},
            {$aggregate}({$column}) over (order by {$this-&gt;dateAlias} rows between 1 preceding and current row) as rate&quot;,
        )-&gt;whereBetween($this-&gt;dateColumn, [$this-&gt;start, $this-&gt;end])
            -&gt;groupBy($this-&gt;dateAlias)
            -&gt;orderBy($this-&gt;dateAlias)
            -&gt;get();
        return $this-&gt;mapValuesToDates($values)-&gt;map(function ($value, $key) use ($values) {
            if ($key === 0) {
                $value-&gt;aggregate = 0;
            }
            return $value;
        });
    }
    public function cumulative(string $column, string $aggregate): Collection
    {
        $sqlDate = $this-&gt;getSqlDate();
        $values = $this-&gt;builder-&gt;toBase()-&gt;selectRaw(&quot;
            {$sqlDate} as {$this-&gt;dateAlias},
            {$column},
            sum({$aggregate}({$column})) over (order by {$this-&gt;dateAlias}) as aggregate&quot;,
        )-&gt;whereBetween($this-&gt;dateColumn, [$this-&gt;start, $this-&gt;end])
            -&gt;groupBy($this-&gt;dateAlias)
            -&gt;orderBy($this-&gt;dateAlias)
            -&gt;get();
        return $this-&gt;mapValuesToDates($values);
    }
    public function movingAverage(string $column, string $aggregate, int $period): Collection
    {
        $sqlDate = $this-&gt;getSqlDate();
        $values = $this-&gt;builder-&gt;toBase()-&gt;selectRaw(&quot;
            {$sqlDate} as {$this-&gt;dateAlias},
            {$column},
            avg({$column}) over (order by {$this-&gt;dateAlias} rows between {$period} preceding and current row) as aggregate&quot;,
        )-&gt;whereBetween($this-&gt;dateColumn, [$this-&gt;start, $this-&gt;end])
            -&gt;groupBy($this-&gt;dateAlias)
            -&gt;orderBy($this-&gt;dateAlias)
            -&gt;get();
        return $this-&gt;mapValuesToDates($values);
    }
    public function percentageChange(string $column): Collection
    {
        $sqlDate = $this-&gt;getSqlDate();
        $values = $this-&gt;builder-&gt;toBase()-&gt;selectRaw(&quot;
            {$sqlDate} as {$this-&gt;dateAlias},
            {$column},
            (first_value({$column}) over (order by {$this-&gt;dateAlias}) - 
             lag(first_value({$column}) over (order by {$this-&gt;dateAlias}))) /
             lag(first_value({$column}) over (order by {$this-&gt;dateAlias})) * 100 as aggregate&quot;,
        )-&gt;whereBetween($this-&gt;dateColumn, [$this-&gt;start, $this-&gt;end])
            -&gt;groupBy($this-&gt;dateAlias)
            -&gt;orderBy($this-&gt;dateAlias)
            -&gt;get();
        return $this-&gt;mapValuesToDates($values)-&gt;map(function ($value, $key) use ($values) {
            if ($key === 0) {
                $value-&gt;aggregate = 0; // Set initial change to 0 since there&apos;s no previous value
            }
            return $value;
        });
    }
    public function deviation(string $column, string $aggregate): Collection
    {
        $values = $this-&gt;aggregate($column, $aggregate);
        $mean = $values-&gt;avg(&apos;aggregate&apos;);
        return $values-&gt;map(function ($value) use ($mean) {
            $deviation = pow($value-&gt;aggregate - $mean, 2);
            return new TrendValue(date: $value-&gt;date, aggregate: $deviation);
        });
    }
    public function distribution(string $column, string $aggregate): Collection
    {
        $values = $this-&gt;aggregate($column, $aggregate);
        return $values-&gt;mapToGroups(function ($item) {
            $bucket = floor($item-&gt;aggregate / 10) * 10; // Example of bucketing by tens
            return [$bucket =&gt; $item];
        });
    }
    protected function mapValuesToDates(Collection $values): Collection
    {
        $formattedValues = $values-&gt;map(fn($value) =&gt; new TrendValue(
            date: $value-&gt;{$this-&gt;dateAlias},
            aggregate: $value-&gt;aggregate,
        ));
        $placeholders = $this-&gt;getDatePeriod()-&gt;map(
            fn(CarbonInterface $date) =&gt; new TrendValue(
                date: $date-&gt;format($this-&gt;getCarbonDateFormat()),
                aggregate: 0,
            ),
        );
        return $formattedValues-&gt;merge($placeholders)-&gt;unique(&apos;date&apos;)-&gt;sortBy(&apos;date&apos;)-&gt;values();
    }
    protected function getDatePeriod(): Collection
    {
        return collect(CarbonPeriod::between($this-&gt;start, $this-&gt;end)-&gt;interval(&quot;1 {$this-&gt;interval}&quot;));
    }
    protected function getSqlDate(): string
    {
        return self::INTERVALS[$this-&gt;interval]
            ?? throw new InvalidArgumentException(&quot;Unsupported interval: {$this-&gt;interval}&quot;);
    }
    protected function getCarbonDateFormat(): string
    {
        return match ($this-&gt;interval) {
            &apos;minute&apos; =&gt; &apos;Y-m-d H:i&apos;,
            &apos;hour&apos; =&gt; &apos;Y-m-d H&apos;,
            &apos;day&apos; =&gt; &apos;Y-m-d&apos;,
            &apos;week&apos; =&gt; &apos;o-\WW&apos;,
            &apos;month&apos; =&gt; &apos;Y-m&apos;,
            &apos;year&apos; =&gt; &apos;Y&apos;,
            default =&gt; throw new InvalidArgumentException(&quot;Unsupported interval: {$this-&gt;interval}&quot;)
        };
    }
}</file><file path="app/Models/Recommendation.php">&lt;?php
namespace App\Models;
use Illuminate\Database\Eloquent\Factories\HasFactory;
use Illuminate\Database\Eloquent\Relations\MorphTo;
class Recommendation extends BaseModel
{
    use HasFactory;
    protected $fillable = [
        &apos;source_type&apos;,
        &apos;source_id&apos;,
        &apos;target_type&apos;,
        &apos;target_id&apos;,
        &apos;name&apos;,
        &apos;score&apos;, // raw score means that multiple items can have identical scores
        &apos;position&apos;, // explicit rank ensures a clear, unambiguous sorting order
    ];
    /**
     * Get the source model that the recommendation belongs to.
     *
     * @return MorphTo
     */
    public function source(): MorphTo
    {
        return $this-&gt;morphTo();
    }
    /**
     * Get the target model for the recommendation.
     *
     * @return MorphTo
     */
    public function target(): MorphTo
    {
        return $this-&gt;morphTo();
    }
}</file><file path="app/Models/TranscodingSession.php">&lt;?php
namespace App\Models;
use App\Models\BaseModel;
use Illuminate\Database\Eloquent\Factories\HasFactory;
class TranscodingSession extends BaseModel
{
    use HasFactory;
    protected $fillable = [
        &apos;session_id&apos;,
        &apos;options&apos;,
    ];
    protected $casts = [
        &apos;options&apos; =&gt; &apos;array&apos;,
    ];
}</file><file path="app/Models/UserLibrary.php">&lt;?php
namespace App\Models;
use App\Models\BaseModel;
use Illuminate\Database\Eloquent\Factories\HasFactory;
class UserLibrary extends BasePivot
{
    use HasFactory;
    public function user()
    {
        return $this-&gt;belongsTo(User::class);
    }
    public function library()
    {
        return $this-&gt;belongsTo(Library::class);
    }
}</file><file path="app/Models/Video.php">&lt;?php
namespace App\Models;
use App\Observers\VideoObserver;
use Illuminate\Database\Eloquent\Attributes\ObservedBy;
use Illuminate\Database\Eloquent\Factories\HasFactory;
#[ObservedBy(VideoObserver::class)]
class Video extends BaseModel
{
    use HasFactory;
    protected $fillable = [
        &apos;path&apos;,
        &apos;duration&apos;,
        &apos;height&apos;,
        &apos;width&apos;,
        &apos;video_bitrate&apos;,
        &apos;framerate&apos;,
        &apos;probe&apos;,
    ];
    protected $casts = [
        &apos;probe&apos; =&gt; &apos;array&apos;,
    ];
    public function movies()
    {
        return $this-&gt;belongsToMany(Movie::class)
            -&gt;using(MovieVideo::class);
    }
    public static function makeHash(\SplFileInfo $file): string
    {
        $parts = [
            &apos;path&apos; =&gt; $file-&gt;getRealPath(),
            &apos;size&apos; =&gt; $file-&gt;getSize(),
        ];
        return hash(&apos;sha256&apos;, implode(&apos;,&apos;, $parts));
    }
}</file><file path="app/Modules/Apm/Apm.php">&lt;?php
namespace App\Modules\Apm;
use Illuminate\Support\Facades\Facade;
/**
 * @method static bool isEnabled()
 * @method static \Elastic\Apm\TransactionInterface|null beginTransaction(string $name, string $type, array $context = [])
 * @method static \Elastic\Apm\SpanInterface|null createSpan(string $name, string $type, string $subtype = null, string $action = null)
 * @method static \Elastic\Apm\SpanInterface|null beginAndStoreSpan(string $name, string $type)
 * @method static void endStoredSpan(string $name)
 * @method static void recordException(\Throwable $exception, array $context = [])
 * @method static void addCustomContext(array $context)
 * @method static void addCustomTag(string $key, mixed $value)
 * @method static array getTransactionStats()
 *
 * @see \App\Modules\Apm\OctaneApmManager
 */
class Apm extends Facade
{
    /**
     * Get the registered name of the component.
     */
    protected static function getFacadeAccessor(): string
    {
        return OctaneApmManager::class;
    }
}</file><file path="app/Modules/Apm/Collectors/SwooleMetricsCollector.php">&lt;?php
namespace App\Modules\Apm\Collectors;
use App\Modules\Apm\OctaneApmManager;
use Psr\Log\LoggerInterface;
use Swoole\Server;
class SwooleMetricsCollector
{
    public function __construct(
        private OctaneApmManager $apmManager,
        private ?LoggerInterface $logger = null,
    )
    {
    }
    /**
     * Collect and report Swoole performance metrics
     */
    public function collectMetrics(): void
    {
        if (!$this-&gt;isSwooleEnvironment()) {
            return;
        }
        try {
            $span = $this-&gt;apmManager-&gt;createSpan(&apos;swoole.metrics&apos;, &apos;system&apos;, &apos;swoole&apos;, &apos;collect&apos;);
            if ($span) {
                $metrics = $this-&gt;gatherSwooleMetrics();
                // Use the manager&apos;s setSpanContext method instead of calling setContext directly
                $this-&gt;apmManager-&gt;setSpanContext($span, [
                    &apos;swoole_metrics&apos; =&gt; $metrics,
                ]);
                // Add important metrics as labels directly on the span
                if (isset($metrics[&apos;memory&apos;][&apos;worker_memory_mb&apos;])) {
                    $span-&gt;context()-&gt;setLabel(&apos;swoole.memory.worker_mb&apos;, $metrics[&apos;memory&apos;][&apos;worker_memory_mb&apos;]);
                }
                if (isset($metrics[&apos;performance&apos;][&apos;request_time_ms&apos;])) {
                    $span-&gt;context()-&gt;setLabel(&apos;swoole.performance.request_ms&apos;, $metrics[&apos;performance&apos;][&apos;request_time_ms&apos;]);
                }
                // Add coroutine metrics as labels if available
                if (isset($metrics[&apos;coroutine&apos;][&apos;count&apos;])) {
                    $span-&gt;context()-&gt;setLabel(&apos;swoole.coroutine.count&apos;, $metrics[&apos;coroutine&apos;][&apos;count&apos;]);
                }
                if (isset($metrics[&apos;coroutine&apos;][&apos;peak_count&apos;])) {
                    $span-&gt;context()-&gt;setLabel(&apos;swoole.coroutine.peak_count&apos;, $metrics[&apos;coroutine&apos;][&apos;peak_count&apos;]);
                }
                // Add VM status labels if available
                if (isset($metrics[&apos;vm_status&apos;]) &amp;&amp; is_array($metrics[&apos;vm_status&apos;])) {
                    foreach ($metrics[&apos;vm_status&apos;] as $key =&gt; $value) {
                        if (is_scalar($value)) {
                            $span-&gt;context()-&gt;setLabel(&quot;swoole.vm.{$key}&quot;, $value);
                        }
                    }
                }
                // Add server stats as labels if available
                if (isset($metrics[&apos;server&apos;]) &amp;&amp; is_array($metrics[&apos;server&apos;])) {
                    foreach ($metrics[&apos;server&apos;] as $key =&gt; $value) {
                        if (is_scalar($value)) {
                            $span-&gt;context()-&gt;setLabel(&quot;swoole.server.{$key}&quot;, $value);
                        }
                    }
                }
                $span-&gt;setOutcome(&apos;success&apos;);
                $span-&gt;end();
            }
        } catch (\Throwable $e) {
            $this-&gt;logger?-&gt;error(&apos;Failed to collect Swoole metrics&apos;, [
                &apos;exception&apos; =&gt; $e-&gt;getMessage(),
                &apos;trace&apos;     =&gt; $e-&gt;getTraceAsString(),
            ]);
        }
    }
    /**
     * Check if running in Swoole environment
     */
    private function isSwooleEnvironment(): bool
    {
        return extension_loaded(&apos;swoole&apos;);
    }
    /**
     * Gather comprehensive Swoole metrics
     */
    private function gatherSwooleMetrics(): array
    {
        $metrics = [];
        // Memory metrics
        $metrics[&apos;memory&apos;] = [
            &apos;worker_memory_mb&apos; =&gt; round(memory_get_usage(true) / 1024 / 1024, 2),
            &apos;worker_peak_mb&apos;   =&gt; round(memory_get_peak_usage(true) / 1024 / 1024, 2),
            &apos;real_memory_mb&apos;   =&gt; round(memory_get_usage(false) / 1024 / 1024, 2),
            &apos;real_peak_mb&apos;     =&gt; round(memory_get_peak_usage(false) / 1024 / 1024, 2),
        ];
        // Performance metrics
        $metrics[&apos;performance&apos;] = [
            &apos;request_time_ms&apos; =&gt; round(microtime(true) * 1000),
            &apos;php_version&apos;     =&gt; PHP_VERSION,
            &apos;swoole_version&apos;  =&gt; $this-&gt;getSwooleVersion(),
            &apos;process_id&apos;      =&gt; getmypid(),
        ];
        // VM status if available
        if (function_exists(&apos;swoole_get_vm_status&apos;)) {
            try {
                $vmStatus = swoole_get_vm_status();
                if (is_array($vmStatus)) {
                    $metrics[&apos;vm_status&apos;] = $vmStatus;
                }
            } catch (\Throwable $e) {
                $this-&gt;logger?-&gt;debug(&apos;Failed to get Swoole VM status&apos;, [
                    &apos;exception&apos; =&gt; $e-&gt;getMessage(),
                ]);
                $metrics[&apos;vm_status&apos;] = [&apos;error&apos; =&gt; &apos;Failed to retrieve VM status&apos;];
            }
        }
        // Coroutine metrics
        if ($this-&gt;hasCoroutineSupport()) {
            $metrics[&apos;coroutine&apos;] = $this-&gt;getCoroutineMetrics();
        }
        // Server stats if available
        try {
            $serverStats = Server::stats();
            if (is_array($serverStats)) {
                $metrics[&apos;server&apos;] = $serverStats;
            }
        } catch (\Throwable $e) {
            $this-&gt;logger?-&gt;debug(&apos;Failed to get Swoole server stats&apos;, [
                &apos;exception&apos; =&gt; $e-&gt;getMessage(),
            ]);
        }
        // Add system metrics
        $metrics[&apos;system&apos;] = $this-&gt;getSystemMetrics();
        return $metrics;
    }
    /**
     * Get Swoole version
     */
    private function getSwooleVersion(): string
    {
        if (defined(&apos;SWOOLE_VERSION&apos;)) {
            return SWOOLE_VERSION;
        }
        if (extension_loaded(&apos;swoole&apos;)) {
            $version = phpversion(&apos;swoole&apos;);
            return $version !== false ? $version : &apos;unknown&apos;;
        }
        return &apos;not_loaded&apos;;
    }
    /**
     * Check if coroutine support is available
     */
    private function hasCoroutineSupport(): bool
    {
        return class_exists(&apos;\Swoole\Coroutine&apos;);
    }
    /**
     * Get coroutine metrics
     */
    private function getCoroutineMetrics(): array
    {
        try {
            if (class_exists(&apos;\Swoole\Coroutine&apos;)) {
                $stats = \Swoole\Coroutine::stats();
                return [
                    &apos;count&apos;      =&gt; $stats[&apos;coroutine_num&apos;] ?? 0,
                    &apos;peak_count&apos; =&gt; $stats[&apos;coroutine_peak_num&apos;] ?? 0,
                    &apos;stack_size&apos; =&gt; $stats[&apos;stack_size&apos;] ?? 0,
                ];
            }
            return [&apos;error&apos; =&gt; &apos;Coroutine class not available&apos;];
        } catch (\Throwable $e) {
            return [&apos;error&apos; =&gt; $e-&gt;getMessage()];
        }
    }
    /**
     * Get system metrics
     */
    private function getSystemMetrics(): array
    {
        $metrics = [
            &apos;load_average&apos; =&gt; sys_getloadavg(),
            &apos;timestamp&apos;    =&gt; time(),
        ];
        // Add CPU count if available
        if (function_exists(&apos;swoole_cpu_num&apos;)) {
            $metrics[&apos;cpu_count&apos;] = swoole_cpu_num();
        }
        return $metrics;
    }
}</file><file path="app/Modules/Apm/ElasticApmAgentServiceProvider.php">&lt;?php
namespace App\Modules\Apm;
use App\Modules\Apm\Collectors\SwooleMetricsCollector;
use App\Modules\Apm\Listeners\{AuthenticationListener,
    CacheEventListener,
    DatabaseQueryListener,
    DefaultTerminatedHandler,
    HttpClientListener,
    QueueListener,
    RedisListener,
    RequestReceivedHandler,
    RequestWorkerStartHandler,
    TaskReceivedHandler,
    TickReceivedHandler};
use App\Modules\Apm\Middleware\ApmMiddleware;
use App\Modules\Apm\Services\SwooleMetricsService;
use Illuminate\Auth\Events\Attempting;
use Illuminate\Auth\Events\Authenticated;
use Illuminate\Auth\Events\Lockout;
use Illuminate\Auth\Events\Login;
use Illuminate\Auth\Events\Logout;
use Illuminate\Auth\Events\PasswordReset;
use Illuminate\Auth\Events\Registered;
use Illuminate\Auth\Events\Verified;
use Illuminate\Cache\Events\{CacheHit, CacheMissed, KeyForgotten, KeyWritten};
use Illuminate\Contracts\Events\Dispatcher;
use Illuminate\Http\Client\Events\{ConnectionFailed, RequestSending, ResponseReceived};
use Illuminate\Queue\Events\{JobExceptionOccurred, JobFailed, JobProcessed, JobProcessing, JobQueued};
use Illuminate\Redis\Events\CommandExecuted;
use Illuminate\Support\ServiceProvider;
use Laravel\Octane\Events\{RequestReceived,
    RequestHandled,
    RequestTerminated,
    TaskReceived,
    TaskTerminated,
    TickReceived,
    TickTerminated,
    WorkerStarting,
    WorkerStopping};
use Psr\Log\LoggerInterface;
class ElasticApmAgentServiceProvider extends ServiceProvider
{
    /**
     * Register any application services.
     */
    public function register(): void
    {
        // Register the APM manager as singleton
        $this-&gt;app-&gt;singleton(OctaneApmManager::class, function ($app) {
            $logger = $app-&gt;bound(LoggerInterface::class) ? $app-&gt;make(LoggerInterface::class) : null;
            $config = $this-&gt;buildApmConfig($app);
            return new OctaneApmManager($logger, $config);
        });
        $this-&gt;app-&gt;alias(OctaneApmManager::class, &apos;apm&apos;);
        // Register all listeners as singletons
        $this-&gt;registerListeners();
        $this-&gt;app-&gt;bind(SwooleMetricsCollector::class, function ($app) {
            return new SwooleMetricsCollector(
                $app-&gt;make(OctaneApmManager::class),
                $app-&gt;make(LoggerInterface::class),
            );
        });
        // For the metrics service, we need to be more careful since it holds state
        $this-&gt;app-&gt;bind(SwooleMetricsService::class, function ($app) {
            return new SwooleMetricsService(
                $app-&gt;make(SwooleMetricsCollector::class),
            );
        });
    }
    /**
     * Build APM configuration
     */
    private function buildApmConfig($app): array
    {
        $config = $app-&gt;make(&apos;config&apos;)-&gt;get(&apos;apm&apos;, []);
        // Set defaults from app config if not set
        $config[&apos;service_name&apos;] = $config[&apos;service_name&apos;] ?? $app-&gt;make(&apos;config&apos;)-&gt;get(&apos;app.name&apos;, &apos;unknown&apos;);
        $config[&apos;environment&apos;] = $config[&apos;environment&apos;] ?? $app-&gt;make(&apos;config&apos;)-&gt;get(&apos;app.env&apos;, &apos;unknown&apos;);
        $config[&apos;service_version&apos;] = $config[&apos;service_version&apos;] ?? $app-&gt;version() ?? &apos;unknown&apos;;
        // Ensure sampling rate is valid
        $config[&apos;sampling_rate&apos;] = max(0.0, min(1.0, (float)($config[&apos;sampling_rate&apos;] ?? 1.0)));
        return $config;
    }
    /**
     * Register all event listeners as singletons
     */
    private function registerListeners(): void
    {
        $listeners = [
            DatabaseQueryListener::class,
            DefaultTerminatedHandler::class,
            RequestReceivedHandler::class,
            RequestWorkerStartHandler::class,
            TaskReceivedHandler::class,
            TickReceivedHandler::class,
            HttpClientListener::class,
            CacheEventListener::class,
            RedisListener::class,
            QueueListener::class,
        ];
        foreach ($listeners as $listener) {
            $this-&gt;app-&gt;singleton($listener, function ($app) use ($listener) {
                $logger = $app-&gt;bound(LoggerInterface::class) ? $app-&gt;make(LoggerInterface::class) : null;
                return new $listener($logger);
            });
        }
    }
    /**
     * Bootstrap any application services.
     */
    public function boot(): void
    {
        if (!$this-&gt;shouldEnableApm()) {
            $this-&gt;app-&gt;make(&apos;log&apos;)-&gt;info(&apos;Elastic APM Agent disabled&apos;, [
                &apos;reason&apos; =&gt; $this-&gt;getDisabledReason(),
            ]);
            return;
        }
        $this-&gt;registerEventListeners();
        $this-&gt;warmApmManager();
        $this-&gt;logApmInitialization();
    }
    /**
     * Check if APM should be enabled
     */
    private function shouldEnableApm(): bool
    {
        return config(&apos;apm.enabled&apos;, true) &amp;&amp;
            class_exists(\Elastic\Apm\ElasticApm::class) &amp;&amp;
            $this-&gt;isValidEnvironment();
    }
    /**
     * Check if the environment is valid for APM
     */
    private function isValidEnvironment(): bool
    {
        $environment = config(&apos;app.env&apos;, &apos;production&apos;);
        $enabledEnvironments = config(&apos;apm.enabled_environments&apos;, [&apos;production&apos;, &apos;staging&apos;, &apos;local&apos;]);
        return in_array($environment, $enabledEnvironments);
    }
    /**
     * Get reason why APM is disabled
     */
    private function getDisabledReason(): string
    {
        if (!config(&apos;apm.enabled&apos;, true)) {
            return &apos;disabled_in_config&apos;;
        }
        if (!class_exists(\Elastic\Apm\ElasticApm::class)) {
            return &apos;elastic_apm_class_not_found&apos;;
        }
        if (!$this-&gt;isValidEnvironment()) {
            return &apos;environment_not_enabled&apos;;
        }
        return &apos;unknown&apos;;
    }
    /**
     * Register all event listeners with their respective events
     */
    private function registerEventListeners(): void
    {
        /** @var Dispatcher $dispatcher */
        $dispatcher = $this-&gt;app-&gt;make(Dispatcher::class);
        try {
            // Octane events
            $this-&gt;registerOctaneEvents($dispatcher);
            if (config(&apos;apm.monitoring.auth&apos;, true)) {
                $this-&gt;registerAuthEvents($dispatcher);
            }
            // Register the database query listener
            if ($this-&gt;app-&gt;make(&apos;config&apos;)-&gt;get(&apos;apm.monitoring.database&apos;, true)) {
                $this-&gt;app-&gt;make(DatabaseQueryListener::class)-&gt;register();
            }
            if (config(&apos;apm.monitoring.redis&apos;, true)) {
                $this-&gt;registerRedisEvents($dispatcher);
            }
            // HTTP client events
            if (config(&apos;apm.monitoring.http_client&apos;, true)) {
                $this-&gt;registerHttpClientEvents($dispatcher);
            }
            // Cache events
            if (config(&apos;apm.monitoring.cache&apos;, true)) {
                $this-&gt;registerCacheEvents($dispatcher);
            }
            // Queue events
            if (config(&apos;apm.monitoring.queue&apos;, true)) {
                $this-&gt;registerQueueEvents($dispatcher);
            }
        } catch (\Throwable $e) {
            $this-&gt;app-&gt;make(&apos;log&apos;)-&gt;error(&apos;Failed to register APM event listeners&apos;, [
                &apos;exception&apos; =&gt; $e-&gt;getMessage(),
                &apos;file&apos;      =&gt; $e-&gt;getFile(),
                &apos;line&apos;      =&gt; $e-&gt;getLine(),
            ]);
        }
    }
    /**
     * Register Octane-specific events
     */
    private function registerOctaneEvents(Dispatcher $dispatcher): void
    {
        $octaneEvents = [
            RequestReceived::class   =&gt; RequestReceivedHandler::class,
            RequestTerminated::class =&gt; DefaultTerminatedHandler::class,
            RequestHandled::class    =&gt; DefaultTerminatedHandler::class,
            WorkerStarting::class    =&gt; RequestWorkerStartHandler::class,
            TaskReceived::class      =&gt; TaskReceivedHandler::class,
            TaskTerminated::class    =&gt; DefaultTerminatedHandler::class,
            TickReceived::class      =&gt; TickReceivedHandler::class,
            TickTerminated::class    =&gt; DefaultTerminatedHandler::class,
        ];
        foreach ($octaneEvents as $event =&gt; $listener) {
            if (class_exists($event)) {
                $dispatcher-&gt;listen($event, $listener);
            }
        }
    }
    private function registerAuthEvents(Dispatcher $dispatcher)
    {
        $events = [
            Attempting::class    =&gt; [AuthenticationListener::class, &apos;handleAttempting&apos;],
            Authenticated::class =&gt; [AuthenticationListener::class, &apos;handleAuthenticated&apos;],
            Login::class         =&gt; [AuthenticationListener::class, &apos;handleLogin&apos;],
            Logout::class        =&gt; [AuthenticationListener::class, &apos;handleLogout&apos;],
            Lockout::class       =&gt; [AuthenticationListener::class, &apos;handleLockout&apos;],
            Registered::class    =&gt; [AuthenticationListener::class, &apos;handleRegistered&apos;],
            Verified::class      =&gt; [AuthenticationListener::class, &apos;handleVerified&apos;],
            PasswordReset::class =&gt; [AuthenticationListener::class, &apos;handlePasswordReset&apos;],
        ];
        foreach ($events as $event =&gt; $listener) {
            if (class_exists($event)) {
                $dispatcher-&gt;listen($event, $listener);
            }
        }
    }
    private function registerRedisEvents(Dispatcher $dispatcher): void
    {
        $dispatcher-&gt;listen(CommandExecuted::class, [RedisListener::class, &apos;handle&apos;]);;
    }
    /**
     * Register HTTP client events
     */
    private function registerHttpClientEvents(Dispatcher $dispatcher): void
    {
        $httpEvents = [
            RequestSending::class   =&gt; [HttpClientListener::class, &apos;handleRequestSending&apos;],
            ResponseReceived::class =&gt; [HttpClientListener::class, &apos;handleResponseReceived&apos;],
            ConnectionFailed::class =&gt; [HttpClientListener::class, &apos;handleConnectionFailed&apos;],
        ];
        foreach ($httpEvents as $event =&gt; $listener) {
            if (class_exists($event)) {
                $dispatcher-&gt;listen($event, $listener);
            }
        }
    }
    /**
     * Register cache events
     */
    private function registerCacheEvents(Dispatcher $dispatcher): void
    {
        $cacheEvents = [
            CacheHit::class     =&gt; [CacheEventListener::class, &apos;handleCacheHit&apos;],
            CacheMissed::class  =&gt; [CacheEventListener::class, &apos;handleCacheMissed&apos;],
            KeyWritten::class   =&gt; [CacheEventListener::class, &apos;handleKeyWritten&apos;],
            KeyForgotten::class =&gt; [CacheEventListener::class, &apos;handleKeyForgotten&apos;],
        ];
        foreach ($cacheEvents as $event =&gt; $listener) {
            if (class_exists($event)) {
                $dispatcher-&gt;listen($event, $listener);
            }
        }
    }
    /**
     * Register queue events
     */
    private function registerQueueEvents(Dispatcher $dispatcher): void
    {
        $queueEvents = [
            JobQueued::class            =&gt; [QueueListener::class, &apos;handleJobQueued&apos;],
            JobProcessing::class        =&gt; [QueueListener::class, &apos;handleJobProcessing&apos;],
            JobProcessed::class         =&gt; [QueueListener::class, &apos;handleJobProcessed&apos;],
            JobFailed::class            =&gt; [QueueListener::class, &apos;handleJobFailed&apos;],
            JobExceptionOccurred::class =&gt; [QueueListener::class, &apos;handleJobExceptionOccurred&apos;],
        ];
        foreach ($queueEvents as $event =&gt; $listener) {
            if (class_exists($event)) {
                $dispatcher-&gt;listen($event, $listener);
            }
        }
    }
    /**
     * Warm the APM manager to ensure it&apos;s ready
     */
    private function warmApmManager(): void
    {
        try {
            $manager = $this-&gt;app-&gt;make(OctaneApmManager::class);
            // Verify the manager is working
            if (!$manager-&gt;isEnabled()) {
                $this-&gt;app-&gt;make(&apos;log&apos;)-&gt;warning(&apos;APM manager is not enabled&apos;, [
                    &apos;stats&apos; =&gt; $manager-&gt;getTransactionStats(),
                ]);
            }
        } catch (\Throwable $e) {
            $this-&gt;app-&gt;make(&apos;log&apos;)-&gt;error(&apos;Failed to warm APM manager&apos;, [
                &apos;exception&apos; =&gt; $e-&gt;getMessage(),
                &apos;file&apos;      =&gt; $e-&gt;getFile(),
                &apos;line&apos;      =&gt; $e-&gt;getLine(),
            ]);
        }
    }
    /**
     * Log APM initialization
     */
    private function logApmInitialization(): void
    {
        try {
            $this-&gt;app-&gt;make(&apos;log&apos;)-&gt;info(&apos;Elastic APM Agent initialized successfully&apos;, [
                &apos;service_name&apos;    =&gt; config(&apos;apm.service_name&apos;),
                &apos;environment&apos;     =&gt; config(&apos;apm.environment&apos;),
                &apos;service_version&apos; =&gt; config(&apos;apm.service_version&apos;),
                &apos;sampling_rate&apos;   =&gt; config(&apos;apm.sampling_rate&apos;),
                &apos;monitoring&apos;      =&gt; [
                    &apos;database&apos;    =&gt; config(&apos;apm.monitoring.database&apos;, true),
                    &apos;cache&apos;       =&gt; config(&apos;apm.monitoring.cache&apos;, true),
                    &apos;http_client&apos; =&gt; config(&apos;apm.monitoring.http_client&apos;, true),
                ],
                &apos;laravel_version&apos; =&gt; app()-&gt;version(),
                &apos;php_version&apos;     =&gt; PHP_VERSION,
            ]);
        } catch (\Throwable $e) {
            $this-&gt;app-&gt;make(&apos;log&apos;)-&gt;error(&apos;Failed to log APM initialization&apos;, [
                &apos;exception&apos; =&gt; $e-&gt;getMessage(),
            ]);
        }
    }
    /**
     * Get the services provided by the provider.
     */
    public function provides(): array
    {
        return [
            OctaneApmManager::class,
            ApmMiddleware::class,
        ];
    }
}</file><file path="app/Modules/Apm/Listeners/AuthenticationListener.php">&lt;?php
namespace App\Modules\Apm\Listeners;
use App\Modules\Apm\OctaneApmManager;
use Elastic\Apm\SpanContextInterface;
use Elastic\Apm\SpanInterface;
use Illuminate\Auth\Events\Attempting;
use Illuminate\Auth\Events\Authenticated;
use Illuminate\Auth\Events\Failed;
use Illuminate\Auth\Events\Lockout;
use Illuminate\Auth\Events\Login;
use Illuminate\Auth\Events\Logout;
use Illuminate\Auth\Events\PasswordReset;
use Illuminate\Auth\Events\Registered;
use Illuminate\Auth\Events\Verified;
use Illuminate\Support\Facades\App;
use Illuminate\Support\Facades\Request;
use Psr\Log\LoggerInterface;
class AuthenticationListener
{
    public function __construct(
        private ?LoggerInterface $logger = null,
    )
    {
    }
    /**
     * Handle authentication attempting event
     */
    public function handleAttempting(Attempting $event): void
    {
        try {
            /** @var OctaneApmManager $manager */
            $manager = App::make(OctaneApmManager::class);
            $span = $manager-&gt;createSpan(
                &apos;Authentication Attempt&apos;,
                &apos;auth&apos;,
                &apos;attempt&apos;,
                &apos;security&apos;,
            );
            if ($span) {
                $this-&gt;setAuthAttemptContext($span, $event);
                $this-&gt;addAuthAttemptTags($manager, $span, $event);
                $span-&gt;end();
            }
            // Add transaction-level context
            $this-&gt;addAuthTransactionContext($manager, &apos;attempt&apos;, $event-&gt;credentials);
        } catch (\Throwable $e) {
            $this-&gt;logger?-&gt;error(&apos;Failed to track auth attempt&apos;, [
                &apos;exception&apos;            =&gt; $e-&gt;getMessage(),
                &apos;guard&apos;                =&gt; $event-&gt;guard,
                &apos;credentials_provided&apos; =&gt; array_keys($event-&gt;credentials),
            ]);
        }
    }
    /**
     * Set authentication attempt context
     */
    private function setAuthAttemptContext($span, Attempting $event): void
    {
        $spanContext = $span-&gt;context();
        // Core auth context
        $spanContext-&gt;setLabel(&apos;auth.guard&apos;, $event-&gt;guard);
        $spanContext-&gt;setLabel(&apos;auth.action&apos;, &apos;attempt&apos;);
        $spanContext-&gt;setLabel(&apos;auth.credentials_provided&apos;, json_encode(array_keys($event-&gt;credentials)));
        $spanContext-&gt;setLabel(&apos;auth.remember&apos;, $event-&gt;remember ? &apos;true&apos; : &apos;false&apos;);
        // Request context
        $this-&gt;setRequestContext($spanContext);
        // Security context
        $this-&gt;setSecurityContext($spanContext);
        $span-&gt;setOutcome(&apos;unknown&apos;); // Will be determined by result
    }
    /**
     * Set request context
     */
    private function setRequestContext(SpanContextInterface $spanContext): void
    {
        $spanContext-&gt;setLabel(&apos;http.method&apos;, Request::method());
        $spanContext-&gt;setLabel(&apos;http.url&apos;, Request::url());
        $spanContext-&gt;setLabel(&apos;http.user_agent&apos;, Request::userAgent());
        $spanContext-&gt;setLabel(&apos;http.referer&apos;, Request::header(&apos;referer&apos;, &apos;direct&apos;));
        // Client context
        $spanContext-&gt;setLabel(&apos;client.ip&apos;, Request::ip());
        $spanContext-&gt;setLabel(&apos;client.geo.country&apos;, $this-&gt;getCountryFromIp(Request::ip()));
    }
    /**
     * Get country from IP (mock implementation)
     */
    private function getCountryFromIp(string $ip): string
    {
        // Implement IP geolocation logic or use a service
        return &apos;unknown&apos;;
    }
    /**
     * Set security context
     */
    private function setSecurityContext(SpanContextInterface $spanContext): void
    {
        $spanContext-&gt;setLabel(&apos;security.ip_address&apos;, Request::ip());
        $spanContext-&gt;setLabel(&apos;security.user_agent_hash&apos;, hash(&apos;sha256&apos;, Request::userAgent() ?? &apos;&apos;));
        $spanContext-&gt;setLabel(&apos;security.timestamp&apos;, now()-&gt;toISOString());
        $spanContext-&gt;setLabel(&apos;security.suspicious_activity&apos;, $this-&gt;detectSuspiciousActivity());
    }
    /**
     * Detect suspicious activity
     */
    private function detectSuspiciousActivity(): string
    {
        // Implement suspicious activity detection logic
        return &apos;false&apos;;
    }
    /**
     * Add authentication attempt tags
     */
    private function addAuthAttemptTags(OctaneApmManager $manager, $span, Attempting $event): void
    {
        $manager-&gt;addSpanTag($span, &apos;auth.guard&apos;, $event-&gt;guard);
        $manager-&gt;addSpanTag($span, &apos;auth.action&apos;, &apos;attempt&apos;);
        $manager-&gt;addSpanTag($span, &apos;auth.remember&apos;, $event-&gt;remember ? &apos;true&apos; : &apos;false&apos;);
        $manager-&gt;addSpanTag($span, &apos;component&apos;, &apos;auth&apos;);
        $manager-&gt;addSpanTag($span, &apos;span.kind&apos;, &apos;server&apos;);
    }
    /**
     * Add authentication transaction context
     */
    private function addAuthTransactionContext(OctaneApmManager $manager, string $action, array $credentials = [], $user = null): void
    {
        $manager-&gt;addCustomTag(&apos;auth.action&apos;, $action);
        $manager-&gt;addCustomTag(&apos;auth.timestamp&apos;, now()-&gt;toISOString());
        if ($user) {
            $manager-&gt;addCustomTag(&apos;auth.user_id&apos;, (string)$user-&gt;getKey());
            $manager-&gt;addCustomTag(&apos;user.id&apos;, (string)$user-&gt;getKey());
        }
        $manager-&gt;addCustomTag(&apos;security.ip_address&apos;, Request::ip());
        $manager-&gt;addCustomTag(&apos;security.user_agent_hash&apos;, hash(&apos;sha256&apos;, Request::userAgent() ?? &apos;&apos;));
        if (!empty($credentials)) {
            $manager-&gt;addCustomTag(&apos;auth.credentials_provided&apos;, json_encode(array_keys($credentials)));
        }
    }
    /**
     * Handle successful authentication event
     */
    public function handleAuthenticated(Authenticated $event): void
    {
        try {
            /** @var OctaneApmManager $manager */
            $manager = App::make(OctaneApmManager::class);
            $span = $manager-&gt;createSpan(
                &apos;User Authenticated&apos;,
                &apos;auth&apos;,
                &apos;success&apos;,
                &apos;security&apos;,
            );
            if ($span) {
                $this-&gt;setAuthSuccessContext($span, $event);
                $this-&gt;addAuthSuccessTags($manager, $span, $event);
                $span-&gt;end();
            }
            // Add transaction-level context
            $this-&gt;addAuthTransactionContext($manager, &apos;authenticated&apos;, [], $event-&gt;user);
        } catch (\Throwable $e) {
            $this-&gt;logger?-&gt;error(&apos;Failed to track authentication success&apos;, [
                &apos;exception&apos; =&gt; $e-&gt;getMessage(),
                &apos;guard&apos;     =&gt; $event-&gt;guard,
                &apos;user_id&apos;   =&gt; $event-&gt;user?-&gt;getKey(),
            ]);
        }
    }
    /**
     * Set authentication success context
     */
    private function setAuthSuccessContext($span, Authenticated $event): void
    {
        $spanContext = $span-&gt;context();
        // Core auth context
        $spanContext-&gt;setLabel(&apos;auth.guard&apos;, $event-&gt;guard);
        $spanContext-&gt;setLabel(&apos;auth.action&apos;, &apos;authenticated&apos;);
        $spanContext-&gt;setLabel(&apos;auth.user_id&apos;, (string)$event-&gt;user?-&gt;getKey());
        $spanContext-&gt;setLabel(&apos;auth.user_type&apos;, get_class($event-&gt;user));
        // User context
        $this-&gt;setUserContext($spanContext, $event-&gt;user);
        // Request context
        $this-&gt;setRequestContext($spanContext);
        $span-&gt;setOutcome(&apos;success&apos;);
    }
    /**
     * Set user context
     */
    private function setUserContext(SpanContextInterface $spanContext, $user): void
    {
        if (!$user) return;
        $spanContext-&gt;setLabel(&apos;user.id&apos;, (string)$user-&gt;getKey());
        $spanContext-&gt;setLabel(&apos;user.type&apos;, get_class($user));
        if (method_exists($user, &apos;getEmail&apos;)) {
            $spanContext-&gt;setLabel(&apos;user.email&apos;, $this-&gt;hashEmail($user-&gt;getEmail()));
        }
        if (method_exists($user, &apos;getRoles&apos;)) {
            $spanContext-&gt;setLabel(&apos;user.roles&apos;, json_encode($user-&gt;getRoles()-&gt;pluck(&apos;name&apos;)-&gt;toArray()));
        }
        // User metadata
        $spanContext-&gt;setLabel(&apos;user.created_at&apos;, $user-&gt;created_at?-&gt;toISOString());
        $spanContext-&gt;setLabel(&apos;user.is_new&apos;, $user-&gt;created_at?-&gt;isToday() ? &apos;true&apos; : &apos;false&apos;);
    }
    /**
     * Hash email for privacy
     */
    private function hashEmail(string $email): string
    {
        return hash(&apos;sha256&apos;, strtolower($email));
    }
    /**
     * Add authentication success tags
     */
    private function addAuthSuccessTags(OctaneApmManager $manager, $span, Authenticated $event): void
    {
        $manager-&gt;addSpanTag($span, &apos;auth.guard&apos;, $event-&gt;guard);
        $manager-&gt;addSpanTag($span, &apos;auth.action&apos;, &apos;authenticated&apos;);
        $manager-&gt;addSpanTag($span, &apos;auth.user_id&apos;, (string)$event-&gt;user-&gt;getKey());
        $manager-&gt;addSpanTag($span, &apos;component&apos;, &apos;auth&apos;);
        $manager-&gt;addSpanTag($span, &apos;span.kind&apos;, &apos;server&apos;);
        $manager-&gt;addSpanTag($span, &apos;success&apos;, &apos;true&apos;);
    }
    /**
     * Handle authentication failure event
     */
    public function handleFailed(Failed $event): void
    {
        try {
            /** @var OctaneApmManager $manager */
            $manager = App::make(OctaneApmManager::class);
            $span = $manager-&gt;createSpan(
                &apos;Authentication Failed&apos;,
                &apos;auth&apos;,
                &apos;failure&apos;,
                &apos;security&apos;,
            );
            if ($span) {
                $this-&gt;setAuthFailureContext($span, $event);
                $this-&gt;addAuthFailureTags($manager, $span, $event);
                $span-&gt;setOutcome(&apos;failure&apos;);
                $span-&gt;end();
            }
            // Add transaction-level context for security monitoring
            $this-&gt;addAuthTransactionContext($manager, &apos;failed&apos;, $event-&gt;credentials);
            // Record as security event
            $this-&gt;recordSecurityEvent($manager, &apos;auth_failure&apos;, [
                &apos;guard&apos;          =&gt; $event-&gt;guard,
                &apos;credentials&apos;    =&gt; array_keys($event-&gt;credentials),
                &apos;user_attempted&apos; =&gt; $event-&gt;user?-&gt;getKey(),
                &apos;ip_address&apos;     =&gt; Request::ip(),
                &apos;user_agent&apos;     =&gt; Request::userAgent(),
            ]);
        } catch (\Throwable $e) {
            $this-&gt;logger?-&gt;error(&apos;Failed to track auth failure&apos;, [
                &apos;exception&apos;            =&gt; $e-&gt;getMessage(),
                &apos;guard&apos;                =&gt; $event-&gt;guard,
                &apos;credentials_provided&apos; =&gt; array_keys($event-&gt;credentials),
            ]);
        }
    }
    /**
     * Set authentication failure context
     */
    private function setAuthFailureContext($span, Failed $event): void
    {
        $spanContext = $span-&gt;context();
        // Core auth context
        $spanContext-&gt;setLabel(&apos;auth.guard&apos;, $event-&gt;guard);
        $spanContext-&gt;setLabel(&apos;auth.action&apos;, &apos;failed&apos;);
        $spanContext-&gt;setLabel(&apos;auth.credentials_provided&apos;, json_encode(array_keys($event-&gt;credentials)));
        $spanContext-&gt;setLabel(&apos;auth.user_attempted&apos;, $event-&gt;user ? (string)$event-&gt;user-&gt;getKey() : &apos;unknown&apos;);
        // Security context for failed attempts
        $this-&gt;setSecurityContext($spanContext);
        $this-&gt;setThreatContext($spanContext);
        // Request context
        $this-&gt;setRequestContext($spanContext);
    }
    /**
     * Set threat context
     */
    private function setThreatContext(SpanContextInterface $spanContext): void
    {
        $ip = Request::ip();
        $spanContext-&gt;setLabel(&apos;threat.ip_reputation&apos;, $this-&gt;getIpReputation($ip));
        $spanContext-&gt;setLabel(&apos;threat.failed_attempts_count&apos;, $this-&gt;getFailedAttemptsCount($ip));
        $spanContext-&gt;setLabel(&apos;threat.risk_score&apos;, $this-&gt;calculateRiskScore($ip));
    }
    /**
     * Get IP reputation
     */
    private function getIpReputation(string $ip): string
    {
        // Implement IP reputation checking
        return &apos;unknown&apos;;
    }
    /**
     * Get failed attempts count
     */
    private function getFailedAttemptsCount(string $ip): string
    {
        // Implement failed attempts counting
        return &apos;0&apos;;
    }
    /**
     * Calculate risk score
     */
    private function calculateRiskScore(string $ip): string
    {
        // Implement risk score calculation
        return &apos;low&apos;;
    }
    /**
     * Add authentication failure tags
     */
    private function addAuthFailureTags(OctaneApmManager $manager, $span, Failed $event): void
    {
        $manager-&gt;addSpanTag($span, &apos;auth.guard&apos;, $event-&gt;guard);
        $manager-&gt;addSpanTag($span, &apos;auth.action&apos;, &apos;failed&apos;);
        $manager-&gt;addSpanTag($span, &apos;component&apos;, &apos;auth&apos;);
        $manager-&gt;addSpanTag($span, &apos;span.kind&apos;, &apos;server&apos;);
        $manager-&gt;addSpanTag($span, &apos;error&apos;, &apos;true&apos;);
        $manager-&gt;addSpanTag($span, &apos;security.event&apos;, &apos;auth_failure&apos;);
    }
    /**
     * Record security event
     */
    private function recordSecurityEvent(OctaneApmManager $manager, string $eventType, array $context): void
    {
        $manager-&gt;addCustomTag(&apos;security.event.type&apos;, $eventType);
        $manager-&gt;addCustomTag(&apos;security.event.timestamp&apos;, now()-&gt;toISOString());
        $manager-&gt;addCustomTag(&apos;security.event.context&apos;, json_encode($context));
        $manager-&gt;addCustomTag(&apos;security.event.severity&apos;, $this-&gt;getEventSeverity($eventType));
    }
    /**
     * Get event severity
     */
    private function getEventSeverity(string $eventType): string
    {
        return match ($eventType) {
            &apos;auth_failure&apos; =&gt; &apos;medium&apos;,
            &apos;account_lockout&apos; =&gt; &apos;high&apos;,
            &apos;password_reset&apos; =&gt; &apos;low&apos;,
            default =&gt; &apos;low&apos;
        };
    }
    /**
     * Handle successful login event
     */
    public function handleLogin(Login $event): void
    {
        try {
            /** @var OctaneApmManager $manager */
            $manager = App::make(OctaneApmManager::class);
            $span = $manager-&gt;createSpan(
                &apos;User Login&apos;,
                &apos;auth&apos;,
                &apos;login&apos;,
                &apos;security&apos;,
            );
            if ($span) {
                $this-&gt;setLoginContext($span, $event);
                $this-&gt;addLoginTags($manager, $span, $event);
                $span-&gt;end();
            }
            // Add user context to transaction
            $this-&gt;addUserContextToTransaction($manager, $event-&gt;user);
            // Record login metrics
            $this-&gt;recordLoginMetrics($manager, $event);
        } catch (\Throwable $e) {
            $this-&gt;logger?-&gt;error(&apos;Failed to track login&apos;, [
                &apos;exception&apos; =&gt; $e-&gt;getMessage(),
                &apos;guard&apos;     =&gt; $event-&gt;guard,
                &apos;user_id&apos;   =&gt; $event-&gt;user?-&gt;getKey(),
            ]);
        }
    }
    /**
     * Set login context
     */
    private function setLoginContext($span, Login $event): void
    {
        $spanContext = $span-&gt;context();
        // Core auth context
        $spanContext-&gt;setLabel(&apos;auth.guard&apos;, $event-&gt;guard);
        $spanContext-&gt;setLabel(&apos;auth.action&apos;, &apos;login&apos;);
        $spanContext-&gt;setLabel(&apos;auth.user_id&apos;, (string)$event-&gt;user-&gt;getKey());
        $spanContext-&gt;setLabel(&apos;auth.remember&apos;, $event-&gt;remember ? &apos;true&apos; : &apos;false&apos;);
        // User context
        $this-&gt;setUserContext($spanContext, $event-&gt;user);
        // Session context
        $this-&gt;setSessionContext($spanContext);
        // Request context
        $this-&gt;setRequestContext($spanContext);
        $span-&gt;setOutcome(&apos;success&apos;);
    }
    /**
     * Set session context
     */
    private function setSessionContext(SpanContextInterface $spanContext): void
    {
        $spanContext-&gt;setLabel(&apos;session.id&apos;, session()-&gt;getId());
        $spanContext-&gt;setLabel(&apos;session.lifetime&apos;, (string)config(&apos;session.lifetime&apos;));
        $spanContext-&gt;setLabel(&apos;session.driver&apos;, config(&apos;session.driver&apos;));
    }
    /**
     * Add login tags
     */
    private function addLoginTags(OctaneApmManager $manager, $span, Login $event): void
    {
        $manager-&gt;addSpanTag($span, &apos;auth.guard&apos;, $event-&gt;guard);
        $manager-&gt;addSpanTag($span, &apos;auth.action&apos;, &apos;login&apos;);
        $manager-&gt;addSpanTag($span, &apos;auth.user_id&apos;, (string)$event-&gt;user-&gt;getKey());
        $manager-&gt;addSpanTag($span, &apos;component&apos;, &apos;auth&apos;);
        $manager-&gt;addSpanTag($span, &apos;span.kind&apos;, &apos;server&apos;);
        $manager-&gt;addSpanTag($span, &apos;business.event&apos;, &apos;user_login&apos;);
    }
    /**
     * Add user context to transaction
     */
    private function addUserContextToTransaction(OctaneApmManager $manager, $user): void
    {
        if (!$user) return;
        $manager-&gt;addCustomTag(&apos;user.id&apos;, (string)$user-&gt;getKey());
        $manager-&gt;addCustomTag(&apos;user.type&apos;, get_class($user));
        if (method_exists($user, &apos;getEmail&apos;)) {
            $manager-&gt;addCustomTag(&apos;user.email_hash&apos;, $this-&gt;hashEmail($user-&gt;getEmail()));
        }
        if (method_exists($user, &apos;getRoles&apos;)) {
            $manager-&gt;addCustomTag(&apos;user.roles&apos;, json_encode($user-&gt;getRoles()-&gt;pluck(&apos;name&apos;)-&gt;toArray()));
        }
    }
    /**
     * Record login metrics
     */
    private function recordLoginMetrics(OctaneApmManager $manager, Login $event): void
    {
        $manager-&gt;addCustomTag(&apos;metrics.login.guard&apos;, $event-&gt;guard);
        $manager-&gt;addCustomTag(&apos;metrics.login.remember&apos;, $event-&gt;remember ? &apos;true&apos; : &apos;false&apos;);
        $manager-&gt;addCustomTag(&apos;metrics.login.timestamp&apos;, now()-&gt;toISOString());
        $manager-&gt;addCustomTag(&apos;metrics.login.day_of_week&apos;, now()-&gt;dayOfWeek);
        $manager-&gt;addCustomTag(&apos;metrics.login.hour_of_day&apos;, now()-&gt;hour);
    }
    /**
     * Handle logout event
     */
    public function handleLogout(Logout $event): void
    {
        try {
            /** @var OctaneApmManager $manager */
            $manager = App::make(OctaneApmManager::class);
            $span = $manager-&gt;createSpan(
                &apos;User Logout&apos;,
                &apos;auth&apos;,
                &apos;logout&apos;,
                &apos;security&apos;,
            );
            if ($span) {
                $this-&gt;setLogoutContext($span, $event);
                $this-&gt;addLogoutTags($manager, $span, $event);
                $span-&gt;end();
            }
            // Record logout metrics
            $this-&gt;recordLogoutMetrics($manager, $event);
        } catch (\Throwable $e) {
            $this-&gt;logger?-&gt;error(&apos;Failed to track logout&apos;, [
                &apos;exception&apos; =&gt; $e-&gt;getMessage(),
                &apos;guard&apos;     =&gt; $event-&gt;guard,
                &apos;user_id&apos;   =&gt; $event-&gt;user?-&gt;getKey(),
            ]);
        }
    }
    /**
     * Set logout context
     */
    private function setLogoutContext(SpanInterface $span, Logout $event): void
    {
        $spanContext = $span-&gt;context();
        // Core auth context
        $spanContext-&gt;setLabel(&apos;auth.guard&apos;, $event-&gt;guard);
        $spanContext-&gt;setLabel(&apos;auth.action&apos;, &apos;logout&apos;);
        $spanContext-&gt;setLabel(&apos;auth.user_id&apos;, (string)$event-&gt;user-&gt;getKey());
        // User context
        $this-&gt;setUserContext($spanContext, $event-&gt;user);
        // Session context
        $this-&gt;setSessionContext($spanContext);
        $span-&gt;setOutcome(&apos;success&apos;);
    }
    /**
     * Add logout tags
     */
    private function addLogoutTags(OctaneApmManager $manager, $span, Logout $event): void
    {
        $manager-&gt;addSpanTag($span, &apos;auth.guard&apos;, $event-&gt;guard);
        $manager-&gt;addSpanTag($span, &apos;auth.action&apos;, &apos;logout&apos;);
        $manager-&gt;addSpanTag($span, &apos;auth.user_id&apos;, (string)$event-&gt;user-&gt;getKey());
        $manager-&gt;addSpanTag($span, &apos;component&apos;, &apos;auth&apos;);
        $manager-&gt;addSpanTag($span, &apos;span.kind&apos;, &apos;server&apos;);
    }
    /**
     * Record logout metrics
     */
    private function recordLogoutMetrics(OctaneApmManager $manager, Logout $event): void
    {
        $manager-&gt;addCustomTag(&apos;metrics.logout.guard&apos;, $event-&gt;guard);
        $manager-&gt;addCustomTag(&apos;metrics.logout.timestamp&apos;, now()-&gt;toISOString());
    }
    /**
     * Handle lockout event
     */
    public function handleLockout(Lockout $event): void
    {
        try {
            /** @var OctaneApmManager $manager */
            $manager = App::make(OctaneApmManager::class);
            $span = $manager-&gt;createSpan(
                &apos;Account Lockout&apos;,
                &apos;auth&apos;,
                &apos;lockout&apos;,
                &apos;security&apos;,
            );
            if ($span) {
                $this-&gt;setLockoutContext($span, $event);
                $this-&gt;addLockoutTags($manager, $span, $event);
                $span-&gt;setOutcome(&apos;failure&apos;);
                $span-&gt;end();
            }
            // Record as critical security event
            $this-&gt;recordSecurityEvent($manager, &apos;account_lockout&apos;, [
                &apos;ip_address&apos;  =&gt; Request::ip(),
                &apos;user_agent&apos;  =&gt; Request::userAgent(),
                &apos;request_uri&apos; =&gt; Request::getRequestUri(),
                &apos;lockout_key&apos; =&gt; $this-&gt;extractLockoutKey($event),
            ]);
        } catch (\Throwable $e) {
            $this-&gt;logger?-&gt;error(&apos;Failed to track lockout&apos;, [
                &apos;exception&apos; =&gt; $e-&gt;getMessage(),
            ]);
        }
    }
    /**
     * Set lockout context
     */
    private function setLockoutContext(SpanInterface $span, Lockout $event): void
    {
        $spanContext = $span-&gt;context();
        // Core auth context
        $spanContext-&gt;setLabel(&apos;auth.action&apos;, &apos;lockout&apos;);
        $spanContext-&gt;setLabel(&apos;auth.lockout_key&apos;, $this-&gt;extractLockoutKey($event));
        // Security context
        $this-&gt;setSecurityContext($spanContext);
        $this-&gt;setThreatContext($spanContext);
        // Request context
        $this-&gt;setRequestContext($spanContext);
    }
    /**
     * Extract lockout key from event
     */
    private function extractLockoutKey(Lockout $event): string
    {
        // Try to extract from event properties or request
        return Request::ip() . &apos;|&apos; . Request::userAgent();
    }
    /**
     * Add lockout tags
     */
    private function addLockoutTags(OctaneApmManager $manager, $span, Lockout $event): void
    {
        $manager-&gt;addSpanTag($span, &apos;auth.action&apos;, &apos;lockout&apos;);
        $manager-&gt;addSpanTag($span, &apos;component&apos;, &apos;auth&apos;);
        $manager-&gt;addSpanTag($span, &apos;span.kind&apos;, &apos;server&apos;);
        $manager-&gt;addSpanTag($span, &apos;security.event&apos;, &apos;account_lockout&apos;);
        $manager-&gt;addSpanTag($span, &apos;threat.level&apos;, &apos;high&apos;);
    }
    /**
     * Handle user registration event
     */
    public function handleRegistered(Registered $event): void
    {
        try {
            /** @var OctaneApmManager $manager */
            $manager = App::make(OctaneApmManager::class);
            $span = $manager-&gt;createSpan(
                &apos;User Registration&apos;,
                &apos;auth&apos;,
                &apos;registration&apos;,
                &apos;business&apos;,
            );
            if ($span) {
                $this-&gt;setRegistrationContext($span, $event);
                $this-&gt;addRegistrationTags($manager, $span, $event);
                $span-&gt;end();
            }
            // Record business metrics
            $this-&gt;recordRegistrationMetrics($manager, $event);
        } catch (\Throwable $e) {
            $this-&gt;logger?-&gt;error(&apos;Failed to track registration&apos;, [
                &apos;exception&apos; =&gt; $e-&gt;getMessage(),
                &apos;user_id&apos;   =&gt; $event-&gt;user?-&gt;getKey(),
            ]);
        }
    }
    /**
     * Set registration context
     */
    private function setRegistrationContext(SpanInterface $span, Registered $event): void
    {
        $spanContext = $span-&gt;context();
        // Core auth context
        $spanContext-&gt;setLabel(&apos;auth.action&apos;, &apos;registration&apos;);
        $spanContext-&gt;setLabel(&apos;auth.user_id&apos;, (string)$event-&gt;user-&gt;getKey());
        // User context
        $this-&gt;setUserContext($spanContext, $event-&gt;user);
        // Business context
        $spanContext-&gt;setLabel(&apos;business.event&apos;, &apos;user_acquisition&apos;);
        $spanContext-&gt;setLabel(&apos;business.funnel_stage&apos;, &apos;registration&apos;);
        $span-&gt;setOutcome(&apos;success&apos;);
    }
    // Helper methods
    /**
     * Add registration tags
     */
    private function addRegistrationTags(OctaneApmManager $manager, $span, Registered $event): void
    {
        $manager-&gt;addSpanTag($span, &apos;auth.action&apos;, &apos;registration&apos;);
        $manager-&gt;addSpanTag($span, &apos;auth.user_id&apos;, (string)$event-&gt;user-&gt;getKey());
        $manager-&gt;addSpanTag($span, &apos;component&apos;, &apos;auth&apos;);
        $manager-&gt;addSpanTag($span, &apos;span.kind&apos;, &apos;server&apos;);
        $manager-&gt;addSpanTag($span, &apos;business.event&apos;, &apos;user_acquisition&apos;);
    }
    /**
     * Record registration metrics
     */
    private function recordRegistrationMetrics(OctaneApmManager $manager, Registered $event): void
    {
        $manager-&gt;addCustomTag(&apos;metrics.registration.timestamp&apos;, now()-&gt;toISOString());
        $manager-&gt;addCustomTag(&apos;metrics.registration.day_of_week&apos;, now()-&gt;dayOfWeek);
        $manager-&gt;addCustomTag(&apos;metrics.registration.hour_of_day&apos;, now()-&gt;hour);
        $manager-&gt;addCustomTag(&apos;business.conversion.registration&apos;, &apos;true&apos;);
    }
    /**
     * Handle email verification event
     */
    public function handleVerified(Verified $event): void
    {
        try {
            /** @var OctaneApmManager $manager */
            $manager = App::make(OctaneApmManager::class);
            $span = $manager-&gt;createSpan(
                &apos;Email Verified&apos;,
                &apos;auth&apos;,
                &apos;verification&apos;,
                &apos;business&apos;,
            );
            if ($span) {
                $this-&gt;setVerificationContext($span, $event);
                $this-&gt;addVerificationTags($manager, $span, $event);
                $span-&gt;end();
            }
        } catch (\Throwable $e) {
            $this-&gt;logger?-&gt;error(&apos;Failed to track email verification&apos;, [
                &apos;exception&apos; =&gt; $e-&gt;getMessage(),
                &apos;user_id&apos;   =&gt; $event-&gt;user?-&gt;getKey(),
            ]);
        }
    }
    /**
     * Set verification context
     */
    private function setVerificationContext(SpanInterface $span, Verified $event): void
    {
        $spanContext = $span-&gt;context();
        // Core auth context
        $spanContext-&gt;setLabel(&apos;auth.action&apos;, &apos;verification&apos;);
        $spanContext-&gt;setLabel(&apos;auth.user_id&apos;, (string)$event-&gt;user-&gt;getKey());
        // User context
        $this-&gt;setUserContext($spanContext, $event-&gt;user);
        // Business context
        $spanContext-&gt;setLabel(&apos;business.event&apos;, &apos;user_activation&apos;);
        $spanContext-&gt;setLabel(&apos;business.funnel_stage&apos;, &apos;verification&apos;);
        $span-&gt;setOutcome(&apos;success&apos;);
    }
    /**
     * Add verification tags
     */
    private function addVerificationTags(OctaneApmManager $manager, $span, Verified $event): void
    {
        $manager-&gt;addSpanTag($span, &apos;auth.action&apos;, &apos;verification&apos;);
        $manager-&gt;addSpanTag($span, &apos;auth.user_id&apos;, (string)$event-&gt;user-&gt;getKey());
        $manager-&gt;addSpanTag($span, &apos;component&apos;, &apos;auth&apos;);
        $manager-&gt;addSpanTag($span, &apos;span.kind&apos;, &apos;server&apos;);
        $manager-&gt;addSpanTag($span, &apos;business.event&apos;, &apos;user_activation&apos;);
    }
    /**
     * Handle password reset event
     */
    public function handlePasswordReset(PasswordReset $event): void
    {
        try {
            /** @var OctaneApmManager $manager */
            $manager = App::make(OctaneApmManager::class);
            $span = $manager-&gt;createSpan(
                &apos;Password Reset&apos;,
                &apos;auth&apos;,
                &apos;password_reset&apos;,
                &apos;security&apos;,
            );
            if ($span) {
                $this-&gt;setPasswordResetContext($span, $event);
                $this-&gt;addPasswordResetTags($manager, $span, $event);
                $span-&gt;end();
            }
            // Record as security event
            $this-&gt;recordSecurityEvent($manager, &apos;password_reset&apos;, [
                &apos;user_id&apos;    =&gt; $event-&gt;user?-&gt;getKey(),
                &apos;ip_address&apos; =&gt; Request::ip(),
                &apos;user_agent&apos; =&gt; Request::userAgent(),
            ]);
        } catch (\Throwable $e) {
            $this-&gt;logger?-&gt;error(&apos;Failed to track password reset&apos;, [
                &apos;exception&apos; =&gt; $e-&gt;getMessage(),
                &apos;user_id&apos;   =&gt; $event-&gt;user?-&gt;getKey(),
            ]);
        }
    }
    /**
     * Set password reset context
     */
    private function setPasswordResetContext(SpanInterface $span, PasswordReset $event): void
    {
        $spanContext = $span-&gt;context();
        // Core auth context
        $spanContext-&gt;setLabel(&apos;auth.action&apos;, &apos;password_reset&apos;);
        $spanContext-&gt;setLabel(&apos;auth.user_id&apos;, (string)$event-&gt;user-&gt;getKey());
        // User context
        $this-&gt;setUserContext($spanContext, $event-&gt;user);
        // Security context
        $this-&gt;setSecurityContext($spanContext);
        $span-&gt;setOutcome(&apos;success&apos;);
    }
    /**
     * Add password reset tags
     */
    private function addPasswordResetTags(OctaneApmManager $manager, $span, PasswordReset $event): void
    {
        $manager-&gt;addSpanTag($span, &apos;auth.action&apos;, &apos;password_reset&apos;);
        $manager-&gt;addSpanTag($span, &apos;auth.user_id&apos;, (string)$event-&gt;user-&gt;getKey());
        $manager-&gt;addSpanTag($span, &apos;component&apos;, &apos;auth&apos;);
        $manager-&gt;addSpanTag($span, &apos;span.kind&apos;, &apos;server&apos;);
        $manager-&gt;addSpanTag($span, &apos;security.event&apos;, &apos;password_reset&apos;);
    }
}</file><file path="app/Modules/Apm/Listeners/CacheEventListener.php">&lt;?php
namespace App\Modules\Apm\Listeners;
use App\Modules\Apm\OctaneApmManager;
use Illuminate\Cache\Events\CacheHit;
use Illuminate\Cache\Events\CacheMissed;
use Illuminate\Cache\Events\KeyForgotten;
use Illuminate\Cache\Events\KeyWritten;
use Illuminate\Support\Facades\App;
use Psr\Log\LoggerInterface;
class CacheEventListener
{
    public function __construct(
        private ?LoggerInterface $logger = null,
    )
    {
    }
    /**
     * Handle cache hit event
     */
    public function handleCacheHit(CacheHit $event): void
    {
        if (!config(&apos;apm.monitoring.cache&apos;, true)) {
            return;
        }
        $this-&gt;recordCacheOperation(&apos;hit&apos;, $event-&gt;key, $event-&gt;tags ?? []);
    }
    /**
     * Handle cache miss event
     */
    public function handleCacheMissed(CacheMissed $event): void
    {
        if (!config(&apos;apm.monitoring.cache&apos;, true)) {
            return;
        }
        $this-&gt;recordCacheOperation(&apos;miss&apos;, $event-&gt;key, $event-&gt;tags ?? []);
    }
    /**
     * Handle key written event
     */
    public function handleKeyWritten(KeyWritten $event): void
    {
        if (!config(&apos;apm.monitoring.cache&apos;, true)) {
            return;
        }
        $this-&gt;recordCacheOperation(&apos;write&apos;, $event-&gt;key, $event-&gt;tags ?? [], $event-&gt;seconds ?? null);
    }
    /**
     * Handle key forgotten event
     */
    public function handleKeyForgotten(KeyForgotten $event): void
    {
        if (!config(&apos;apm.monitoring.cache&apos;, true)) {
            return;
        }
        $this-&gt;recordCacheOperation(&apos;delete&apos;, $event-&gt;key, $event-&gt;tags ?? []);
    }
    /**
     * Record a cache operation as a span
     */
    private function recordCacheOperation(string $operation, string $key, array $tags = [], ?int $ttl = null): void
    {
        try {
            /** @var OctaneApmManager $manager */
            $manager = App::make(OctaneApmManager::class);
            $span = $manager-&gt;createSpan(
                &quot;cache {$operation}&quot;,
                &apos;cache&apos;,
                config(&apos;cache.default&apos;),
                $operation,
            );
            if ($span) {
                $this-&gt;addCacheContext($manager, $span, $operation, $key, $tags, $ttl);
                $span-&gt;setOutcome(&apos;success&apos;);
                $span-&gt;end();
            }
        } catch (\Throwable $e) {
            $this-&gt;logger?-&gt;error(&apos;Failed to record cache operation&apos;, [
                &apos;exception&apos; =&gt; $e-&gt;getMessage(),
                &apos;operation&apos; =&gt; $operation,
                &apos;key&apos;       =&gt; $key,
            ]);
        }
    }
    /**
     * Add cache context to span
     */
    private function addCacheContext(OctaneApmManager $manager, $span, string $operation, string $key, array $tags, ?int $ttl): void
    {
        $context = [
            &apos;cache&apos; =&gt; [
                &apos;key&apos;       =&gt; $this-&gt;sanitizeKey($key),
                &apos;operation&apos; =&gt; $operation,
                &apos;store&apos;     =&gt; config(&apos;cache.default&apos;),
            ],
        ];
        if (!empty($tags)) {
            $context[&apos;cache&apos;][&apos;tags&apos;] = array_map([$this, &apos;sanitizeKey&apos;], $tags);
        }
        if ($ttl !== null) {
            $context[&apos;cache&apos;][&apos;ttl_seconds&apos;] = $ttl;
        }
        // Add context to the transaction via manager
        $manager-&gt;addCustomContext($context);
        // Add labels to the span directly
        $spanContext = $span-&gt;context();
        $spanContext-&gt;setLabel(&apos;cache.operation&apos;, $operation);
        $spanContext-&gt;setLabel(&apos;cache.store&apos;, config(&apos;cache.default&apos;));
        $spanContext-&gt;setLabel(&apos;cache.key&apos;, $this-&gt;sanitizeKey($key));
        if ($operation === &apos;hit&apos;) {
            $spanContext-&gt;setLabel(&apos;cache.hit&apos;, &apos;true&apos;);
        } else if ($operation === &apos;miss&apos;) {
            $spanContext-&gt;setLabel(&apos;cache.hit&apos;, &apos;false&apos;);
        }
        if ($ttl !== null) {
            $spanContext-&gt;setLabel(&apos;cache.ttl_seconds&apos;, (string) $ttl);
        }
    }
    /**
     * Sanitize cache key to remove sensitive information
     */
    private function sanitizeKey(string $key): string
    {
        // Truncate very long keys
        if (strlen($key) &gt; 100) {
            return substr($key, 0, 100) . &apos;... [TRUNCATED]&apos;;
        }
        // Check for potentially sensitive patterns and hash them
        $sensitivePatterns = [
            &apos;/user[_-]?(\d+)/i&apos;,
            &apos;/email[_-]?([^_\s]+@[^_\s]+)/i&apos;,
            &apos;/token[_-]?([a-f0-9]{32,})/i&apos;,
        ];
        foreach ($sensitivePatterns as $pattern) {
            $key = preg_replace_callback($pattern, function ($matches) {
                return $matches[0][0] . &apos;_&apos; . substr(md5($matches[1]), 0, 8);
            }, $key);
        }
        return $key;
    }
}</file><file path="app/Modules/Apm/Listeners/DatabaseQueryListener.php">&lt;?php
namespace App\Modules\Apm\Listeners;
use App\Modules\Apm\OctaneApmManager;
use Elastic\Apm\SpanInterface;
use Illuminate\Database\Events\QueryExecuted;
use Illuminate\Support\Facades\App;
use Illuminate\Support\Facades\DB;
use Illuminate\Support\Facades\Event;
use Psr\Log\LoggerInterface;
use Tpetry\PostgresqlEnhanced\PostgresEnhancedConnection;
/**
 * Database Query Listener for APM
 * 
 * This class is responsible for tracking database queries and reporting them to the APM system.
 * It listens for database query events, creates spans for each query, and adds detailed information
 * about the queries to the spans.
 * 
 * For Eloquent queries, it creates parent spans that group related queries together, providing
 * a hierarchical view of database operations. It also extracts and reports information about
 * Eloquent relations.
 * 
 * The listener handles both pre-execution tracking (via beforeQueryExecution) and post-execution
 * tracking (via handleQueryExecuted), with a fallback mechanism for queries that were missed
 * in the pre-execution phase.
 */
class DatabaseQueryListener
{
    /**
     * The only supported database subtype
     */
    private const DB_SUBTYPE_POSTGRESQL = &apos;postgresql&apos;;
    private array $activeQueries = [];
    /**
     * Tracks active Eloquent parent spans by model/builder class
     */
    private array $activeEloquentSpans = [];
    public function __construct(
        private ?LoggerInterface $logger = null
    ) {}
    /**
     * Register database query listeners
     * 
     * This method sets up the event listeners needed to track database queries:
     * 
     * 1. A beforeExecuting listener that captures queries before they execute
     * 2. A QueryExecuted listener that captures queries after they complete
     * 3. Optional event listeners for monitoring specific Laravel events
     * 
     * The beforeExecuting/QueryExecuted pair allows us to track both the start and end
     * of queries, which is necessary for accurate timing information. The fallback
     * mechanism in handleQueryExecuted ensures we don&apos;t miss any queries.
     */
    public function register(): void
    {
        // Use Laravel&apos;s built-in beforeExecuting callback to capture queries before execution
        DB::beforeExecuting($this-&gt;beforeQueryExecution(...));
        // Use QueryExecuted event to capture queries after completion
        DB::listen(function ($event) {
            $this-&gt;handleQueryExecuted($event);
        });
        // Optional: Monitor specific Laravel events if configured
        // Note: This can create many spans and impact performance, so it&apos;s disabled by default
        if (config(&apos;apm.monitoring.events&apos;, false)) {
            /** @var OctaneApmManager $manager */
            $manager = App::make(OctaneApmManager::class);
            // Listen only to specific events instead of all events to prevent excessive span creation
            $monitoredEvents = config(&apos;apm.monitoring.event_patterns&apos;, []);
            if (!empty($monitoredEvents)) {
                foreach ($monitoredEvents as $eventPattern) {
                    Event::listen($eventPattern, function ($event) use ($manager, $eventPattern) {
                        $eventName = is_object($event) ? get_class($event) : $eventPattern;
                        $manager-&gt;createSpan($eventName, &apos;event&apos;, &apos;laravel&apos;, &apos;fire&apos;);
                    });
                }
            }
        }
    }
    /**
     * Create a descriptive span name for an Eloquent query
     * 
     * @param array $eloquentInfo Information about the Eloquent query
     * @return string A descriptive span name
     */
    private function createEloquentSpanName(array $eloquentInfo): string
    {
        $modelClass = $eloquentInfo[&apos;class&apos;] ?? &apos;Unknown&apos;;
        $modelName = substr($modelClass, strrpos($modelClass, &apos;\\&apos;) + 1);
        $methodName = $eloquentInfo[&apos;method&apos;] ?? &apos;query&apos;;
        $isRelation = $eloquentInfo[&apos;is_relation&apos;] ?? false;
        $relationName = $eloquentInfo[&apos;relation_name&apos;] ?? null;
        $relatedModel = $eloquentInfo[&apos;related_model&apos;] ?? null;
        // Start with base name
        $spanName = &quot;Eloquent: {$modelName}&quot;;
        // Add relation info to span name if available
        if ($isRelation &amp;&amp; $relationName) {
            $spanName .= &quot;-&gt;{$relationName}&quot;;
            if ($relatedModel) {
                $relatedModelName = substr($relatedModel, strrpos($relatedModel, &apos;\\&apos;) + 1);
                $spanName .= &quot; ({$relatedModelName})&quot;;
            }
        } else if (str_contains($modelClass, &apos;Illuminate\\Database\\Eloquent\\Relations\\&apos;)) {
            // For relation classes like BelongsTo, use a more descriptive name
            // Extract the parent model name from the backtrace if possible
            $parentModelName = $this-&gt;extractParentModelFromRelation($backtrace = debug_backtrace(DEBUG_BACKTRACE_PROVIDE_OBJECT, 15));
            if ($parentModelName) {
                $spanName = &quot;Eloquent: $parentModelName-&gt;$modelName&quot;;
            } else {
                $spanName = &quot;Eloquent Query ($modelName)&quot;;
            }
        } else if ($modelName === &apos;Model&apos; &amp;&amp; $methodName === &apos;performUpdate&apos;) {
            // For Model::performUpdate, extract the actual model name from the object in the backtrace
            $backtrace = debug_backtrace(DEBUG_BACKTRACE_PROVIDE_OBJECT, 15);
            foreach ($backtrace as $trace) {
                $object = $trace[&apos;object&apos;] ?? null;
                if ($object &amp;&amp; is_object($object) &amp;&amp; method_exists($object, &apos;getTable&apos;)) {
                    // This is likely the actual model instance
                    $actualModelName = get_class($object);
                    $actualModelName = substr($actualModelName, strrpos($actualModelName, &apos;\\&apos;) + 1);
                    $spanName = &quot;Eloquent: $actualModelName::$methodName&quot;;
                    break;
                }
            }
        } else {
            $spanName .= &quot;::{$methodName}&quot;;
        }
        return $spanName;
    }
    /**
     * Get or create a parent span for an Eloquent query group
     * 
     * @param OctaneApmManager $manager The APM manager
     * @param array $eloquentInfo Information about the Eloquent query
     * @param string $dbSubtype Database subtype
     * @return SpanInterface|null The parent span or null if creation failed
     */
    private function getOrCreateEloquentParentSpan(OctaneApmManager $manager, array $eloquentInfo, string $dbSubtype): ?SpanInterface
    {
        $groupKey = $eloquentInfo[&apos;group_key&apos;];
        // If we already have a parent span for this group, return it
        if (isset($this-&gt;activeEloquentSpans[$groupKey])) {
            return $this-&gt;activeEloquentSpans[$groupKey][&apos;span&apos;];
        }
        // Create a new parent span for this Eloquent query group
        $modelClass = $eloquentInfo[&apos;class&apos;] ?? &apos;Unknown&apos;;
        $methodName = $eloquentInfo[&apos;method&apos;] ?? &apos;query&apos;;
        $isRelation = $eloquentInfo[&apos;is_relation&apos;] ?? false;
        $relationName = $eloquentInfo[&apos;relation_name&apos;] ?? null;
        $relatedModel = $eloquentInfo[&apos;related_model&apos;] ?? null;
        // Create a descriptive span name
        $spanName = $this-&gt;createEloquentSpanName($eloquentInfo);
        $span = $manager-&gt;createSpan(
            $spanName,
            &apos;db&apos;,
            $dbSubtype,
            &apos;eloquent.group&apos;
        );
        if ($span) {
            $manager-&gt;addSpanTag($span, &apos;db.framework&apos;, &apos;eloquent&apos;);
            $manager-&gt;addSpanTag($span, &apos;eloquent.model&apos;, $modelClass);
            $manager-&gt;addSpanTag($span, &apos;eloquent.method&apos;, $methodName);
            // Add relation-specific tags if this is a relation
            if ($isRelation) {
                $manager-&gt;addSpanTag($span, &apos;eloquent.is_relation&apos;, &apos;true&apos;);
                if ($relationName) {
                    $manager-&gt;addSpanTag($span, &apos;eloquent.relation_name&apos;, $relationName);
                }
                if ($relatedModel) {
                    $manager-&gt;addSpanTag($span, &apos;eloquent.related_model&apos;, $relatedModel);
                }
            }
            // Store the parent span
            $this-&gt;activeEloquentSpans[$groupKey] = [
                &apos;span&apos; =&gt; $span,
                &apos;model&apos; =&gt; $modelClass,
                &apos;method&apos; =&gt; $methodName,
                &apos;is_relation&apos; =&gt; $isRelation,
                &apos;relation_name&apos; =&gt; $relationName,
                &apos;related_model&apos; =&gt; $relatedModel,
                &apos;start_time&apos; =&gt; microtime(true),
                &apos;total_queries&apos; =&gt; 0,
                &apos;completed_queries&apos; =&gt; 0
            ];
        }
        return $span;
    }
    /**
     * Create a span for a database query
     * 
     * @param OctaneApmManager $manager The APM manager
     * @param string $sql The SQL query
     * @param string $dbSubtype Database subtype
     * @param array|null $eloquentInfo Eloquent information if this is an Eloquent query
     * @param array|null $bindings Query bindings (optional)
     * @param string|null $connectionName Database connection name (optional)
     * @return array Span information including the span, parent span, and group key
     */
    private function createQuerySpan(
        OctaneApmManager $manager,
        string $sql,
        string $dbSubtype,
        ?array $eloquentInfo = null,
        ?array $bindings = null,
        ?string $connectionName = null
    ): array {
        $isEloquent = $eloquentInfo !== null;
        $action = $isEloquent ? &apos;eloquent&apos; : &apos;query&apos;;
        $parentSpan = null;
        $groupKey = null;
        // For Eloquent queries, get or create a parent span
        if ($isEloquent) {
            $parentSpan = $this-&gt;getOrCreateEloquentParentSpan($manager, $eloquentInfo, $dbSubtype);
            $groupKey = $eloquentInfo[&apos;group_key&apos;];
            // Increment total queries count for this group
            if (isset($this-&gt;activeEloquentSpans[$groupKey])) {
                $this-&gt;activeEloquentSpans[$groupKey][&apos;total_queries&apos;]++;
            }
        }
        // Create the span
        $span = null;
        if ($isEloquent &amp;&amp; $parentSpan) {
            // Create as child of the parent Eloquent span
            $span = $parentSpan-&gt;beginChildSpan(
                $this-&gt;formatQuery($sql),
                &apos;db&apos;,
                $dbSubtype,
                $action
            );
        } else {
            // Create as child of the transaction
            $span = $manager-&gt;createSpan(
                $this-&gt;formatQuery($sql),
                &apos;db&apos;,
                $dbSubtype,
                $action
            );
        }
        return [
            &apos;span&apos; =&gt; $span,
            &apos;parent_span&apos; =&gt; $parentSpan,
            &apos;group_key&apos; =&gt; $groupKey,
            &apos;is_eloquent&apos; =&gt; $isEloquent
        ];
    }
    /**
     * Called before query execution
     * 
     * This method is called just before a database query is executed. It:
     * 
     * 1. Creates a transaction if one doesn&apos;t exist
     * 2. Creates a span for the query
     * 3. For Eloquent queries, creates or uses a parent span to group related queries
     * 4. Stores query information for later completion by handleQueryExecuted
     * 
     * This method works in tandem with handleQueryExecuted to track the full lifecycle
     * of database queries, from before execution to after completion.
     * 
     * @param string $sql The SQL query to be executed
     * @param array $bindings The query bindings
     * @param PostgresEnhancedConnection $connection The database connection
     */
    public function beforeQueryExecution(string $sql, array $bindings, PostgresEnhancedConnection $connection): void
    {
        if (!config(&apos;apm.monitoring.database&apos;, true)) {
            return;
        }
        $queryId = $this-&gt;generateQueryId($sql, $bindings);
        $startTime = microtime(true);
        try {
            /** @var OctaneApmManager $manager */
            $manager = App::make(OctaneApmManager::class);
            // Create transaction if needed
            $needsTransaction = $manager-&gt;hasNoTransactionInstance();
            $transaction = null;
            if ($needsTransaction) {
                $transactionName = $this-&gt;formatQuery($sql);
                $transaction = $manager-&gt;beginTransaction($transactionName, &apos;request&apos;);
                if (!$transaction) {
                    return;
                }
            }
            // Set database subtype to postgresql (only supported database)
            $dbSubtype = self::DB_SUBTYPE_POSTGRESQL;
            // Check if this is an Eloquent query
            $eloquentInfo = $this-&gt;getEloquentInfo();
            // Create the span
            $spanInfo = $this-&gt;createQuerySpan($manager, $sql, $dbSubtype, $eloquentInfo, $bindings, $connection-&gt;getName());
            $span = $spanInfo[&apos;span&apos;];
            $groupKey = $spanInfo[&apos;group_key&apos;];
            $isEloquent = $spanInfo[&apos;is_eloquent&apos;];
            if ($span) {
                $this-&gt;setDatabaseContext($span, $sql, $bindings, $connection-&gt;getName(), $dbSubtype);
                $this-&gt;addSpanTags($manager, $span, $sql, $dbSubtype, $isEloquent);
                // Store query info for completion
                $this-&gt;activeQueries[$queryId] = [
                    &apos;span&apos; =&gt; $span,
                    &apos;manager&apos; =&gt; $manager,
                    &apos;start_time&apos; =&gt; $startTime,
                    &apos;transaction&apos; =&gt; $transaction,
                    &apos;needs_transaction_end&apos; =&gt; $needsTransaction,
                    &apos;sql&apos; =&gt; $sql,
                    &apos;connection&apos; =&gt; $connection-&gt;getName(),
                    &apos;is_eloquent&apos; =&gt; $isEloquent,
                    &apos;eloquent_group_key&apos; =&gt; $groupKey
                ];
            }
        } catch (\Throwable $e) {
            $this-&gt;logger?-&gt;error(&apos;Failed to start query APM tracking&apos;, [
                &apos;exception&apos; =&gt; $e-&gt;getMessage(),
                &apos;sql&apos; =&gt; $sql
            ]);
        }
    }
    /**
     * Handle QueryExecuted event
     * 
     * This method is called after a database query has completed execution.
     * It works in tandem with beforeQueryExecution:
     * 
     * 1. If we tracked the query in beforeQueryExecution, we&apos;ll have an entry in $activeQueries
     *    and we can complete the span with timing information.
     * 
     * 2. If we didn&apos;t track the query before (e.g., it came from a package that bypasses Laravel&apos;s
     *    query builder), we use handleMissedQuery as a fallback to create a span after the fact.
     * 
     * This dual approach ensures we capture all queries, even if they bypass the normal flow.
     * 
     * @param QueryExecuted $event The query executed event from Laravel
     */
    public function handleQueryExecuted(QueryExecuted $event): void
    {
        if (!config(&apos;apm.monitoring.database&apos;, true)) {
            return;
        }
        $queryId = $this-&gt;generateQueryId($event-&gt;sql, $event-&gt;bindings);
        // Check if we have pre-execution data
        if (isset($this-&gt;activeQueries[$queryId])) {
            $this-&gt;completeQueryTracking($queryId, $event);
        } else {
            // Fallback for queries we missed in beforeExecuting
            $this-&gt;handleMissedQuery($event);
        }
    }
    /**
     * Check if all child queries are done and complete the parent Eloquent span
     * 
     * This method is called after each child query completes. It increments the
     * completed queries counter for the parent span and checks if all child queries
     * are done. If they are, it completes the parent span with summary information.
     * 
     * For relation queries, it adds additional descriptive information about the
     * relation that was loaded.
     * 
     * @param string $groupKey The unique key identifying the parent span group
     */
    private function checkAndCompleteEloquentSpan(string $groupKey): void
    {
        if (!isset($this-&gt;activeEloquentSpans[$groupKey])) {
            return;
        }
        $spanInfo = $this-&gt;activeEloquentSpans[$groupKey];
        $span = $spanInfo[&apos;span&apos;];
        // Increment completed queries count
        $this-&gt;activeEloquentSpans[$groupKey][&apos;completed_queries&apos;]++;
        // Check if all queries in the group are completed
        if ($this-&gt;activeEloquentSpans[$groupKey][&apos;completed_queries&apos;] &gt;= $this-&gt;activeEloquentSpans[$groupKey][&apos;total_queries&apos;]) {
            // All child queries are done, complete the parent span
            $duration = (microtime(true) - $spanInfo[&apos;start_time&apos;]) * 1000; // Convert to ms
            // Add summary information
            $span-&gt;context()-&gt;setLabel(&apos;eloquent.total_queries&apos;, (string)$spanInfo[&apos;total_queries&apos;]);
            $span-&gt;context()-&gt;setLabel(&apos;eloquent.duration_ms&apos;, (string)round($duration, 3));
            // Add relation-specific summary information if this is a relation
            if (!empty($spanInfo[&apos;is_relation&apos;])) {
                $span-&gt;context()-&gt;setLabel(&apos;eloquent.relation_summary&apos;, &apos;true&apos;);
                if (!empty($spanInfo[&apos;relation_name&apos;])) {
                    $relationName = $spanInfo[&apos;relation_name&apos;];
                    $modelName = substr($spanInfo[&apos;model&apos;], strrpos($spanInfo[&apos;model&apos;], &apos;\\&apos;) + 1);
                    $summary = &quot;Loaded relation &apos;{$relationName}&apos; for model &apos;{$modelName}&apos;&quot;;
                    if (!empty($spanInfo[&apos;related_model&apos;])) {
                        $relatedModelName = substr($spanInfo[&apos;related_model&apos;], strrpos($spanInfo[&apos;related_model&apos;], &apos;\\&apos;) + 1);
                        $summary .= &quot; (related model: {$relatedModelName})&quot;;
                    }
                    $span-&gt;context()-&gt;setLabel(&apos;eloquent.relation_description&apos;, $summary);
                }
            }
            // Complete the span
            $span-&gt;setOutcome(&apos;success&apos;);
            $span-&gt;end();
            // Remove from active spans
            unset($this-&gt;activeEloquentSpans[$groupKey]);
        }
    }
    /**
     * Complete query tracking with execution results
     * 
     * This method completes the tracking of a query that was started in beforeQueryExecution.
     * It adds execution time information to the span, sets the outcome to success,
     * and ends the span. For Eloquent queries, it also checks if all child queries
     * in the group are completed and ends the parent span if necessary.
     * 
     * @param string $queryId The unique ID of the query
     * @param QueryExecuted $event The query executed event with timing information
     */
    private function completeQueryTracking(string $queryId, QueryExecuted $event): void
    {
        $queryInfo = $this-&gt;activeQueries[$queryId];
        $span = $queryInfo[&apos;span&apos;];
        $manager = $queryInfo[&apos;manager&apos;];
        $needsTransactionEnd = $queryInfo[&apos;needs_transaction_end&apos;];
        $eloquentGroupKey = $queryInfo[&apos;eloquent_group_key&apos;] ?? null;
        try {
            // Use Laravel&apos;s provided execution time instead of calculating our own
            $isEloquent = $queryInfo[&apos;is_eloquent&apos;] ?? false;
            $this-&gt;addPostExecutionTags($manager, $span, $event, $isEloquent);
            // Set span outcome
            $span-&gt;setOutcome(&apos;success&apos;);
            $span-&gt;end();
            // Check if we need to complete the parent Eloquent span
            if ($isEloquent &amp;&amp; $eloquentGroupKey) {
                $this-&gt;checkAndCompleteEloquentSpan($eloquentGroupKey);
            }
            // Handle transaction cleanup
            if ($needsTransactionEnd) {
                $manager-&gt;setTransactionResult(&apos;success&apos;);
                $manager-&gt;setTransactionOutcome(&apos;success&apos;);
                $manager-&gt;endTransaction();
            }
        } catch (\Throwable $e) {
            $this-&gt;logger?-&gt;error(&apos;Failed to complete query tracking&apos;, [
                &apos;exception&apos; =&gt; $e-&gt;getMessage(),
                &apos;sql&apos; =&gt; $event-&gt;sql
            ]);
        } finally {
            unset($this-&gt;activeQueries[$queryId]);
        }
    }
    /**
     * Handle queries that we missed in beforeExecuting (fallback)
     * 
     * This method is a fallback for queries that weren&apos;t captured by beforeQueryExecution.
     * This can happen when:
     * 
     * 1. Queries are executed by packages that bypass Laravel&apos;s query builder
     * 2. Queries are executed before our listener is registered
     * 3. Queries are executed in a way that doesn&apos;t trigger the beforeExecuting event
     * 
     * For these missed queries, we create a span after the fact using the information
     * from the QueryExecuted event. This ensures we don&apos;t miss any queries in our APM tracking.
     * 
     * @param QueryExecuted $event The query executed event
     */
    private function handleMissedQuery(QueryExecuted $event): void
    {
        try {
            /** @var OctaneApmManager $manager */
            $manager = App::make(OctaneApmManager::class);
            $dbSubtype = self::DB_SUBTYPE_POSTGRESQL;
            $eloquentInfo = $this-&gt;getEloquentInfo();
            // Create the span using the common method
            $spanInfo = $this-&gt;createQuerySpan($manager, $event-&gt;sql, $dbSubtype, $eloquentInfo);
            $span = $spanInfo[&apos;span&apos;];
            $groupKey = $spanInfo[&apos;group_key&apos;];
            $isEloquent = $spanInfo[&apos;is_eloquent&apos;];
            if ($span) {
                $this-&gt;setDatabaseContextFromEvent($span, $event, $dbSubtype);
                $this-&gt;addEventSpanTags($manager, $span, $event, $dbSubtype, $isEloquent);
                $span-&gt;setOutcome(&apos;success&apos;);
                $span-&gt;end();
                // Check if we need to complete the parent Eloquent span
                if ($isEloquent &amp;&amp; $groupKey) {
                    $this-&gt;checkAndCompleteEloquentSpan($groupKey);
                }
            }
        } catch (\Throwable $e) {
            $this-&gt;logger?-&gt;error(&apos;Failed to handle missed query&apos;, [
                &apos;exception&apos; =&gt; $e-&gt;getMessage(),
                &apos;sql&apos; =&gt; $event-&gt;sql
            ]);
        }
    }
    /**
     * Generate a consistent query ID for matching before/after events
     * 
     * This method creates a unique hash for a query based on its SQL and bindings.
     * The process ID is included to avoid collisions in multi-process environments.
     * 
     * Note: We don&apos;t include microtime in the hash to ensure consistent IDs
     * between beforeQueryExecution and handleQueryExecuted events for the same query.
     * 
     * @param string $sql The SQL query
     * @param array $bindings The query bindings
     * @return string A unique hash identifying the query
     */
    private function generateQueryId(string $sql, array $bindings): string
    {
        return hash(&apos;sha256&apos;, $sql . serialize($bindings) . getmypid());
    }
    /**
     * Set database context for pre-execution span
     * 
     * This method adds database-specific information to a span, including the database name,
     * username, SQL statement, query type, table name, and parameter count. This information
     * is used by the APM system to provide detailed insights into database operations.
     * 
     * @param SpanInterface $span The span to set context on
     * @param string $sql The SQL query
     * @param array $bindings The query bindings
     * @param string $connectionName The database connection name
     * @param string $dbSubtype The database subtype (postgresql, mysql, etc.)
     */
    private function setDatabaseContext(SpanInterface $span, string $sql, array $bindings, string $connectionName, string $dbSubtype): void
    {
        $connection = DB::connection($connectionName);
        $spanContext = $span-&gt;context();
        $database = $connection-&gt;getConfig(&apos;database&apos;);
        $username = $connection-&gt;getConfig(&apos;username&apos;);
        $span-&gt;context()-&gt;db()-&gt;setStatement($this-&gt;sanitizeQuery($sql));
        $spanContext-&gt;setLabel(&apos;db.instance&apos;, $database);
        $spanContext-&gt;setLabel(&apos;db.name&apos;, $database);
        $spanContext-&gt;setLabel(&apos;db.statement&apos;, $this-&gt;sanitizeQuery($sql));
        $spanContext-&gt;setLabel(&apos;db.type&apos;, &apos;sql&apos;);
        $spanContext-&gt;setLabel(&apos;db.user&apos;, $username);
        $spanContext-&gt;setLabel(&apos;db.system&apos;, $dbSubtype);
        $queryType = $this-&gt;getQueryType($sql);
        $tableName = $this-&gt;extractTableName($sql);
        $spanContext-&gt;setLabel(&apos;db.operation&apos;, strtolower($queryType));
        if ($tableName) {
            $spanContext-&gt;setLabel(&apos;db.sql.table&apos;, $tableName);
        }
        $spanContext-&gt;setLabel(&apos;db.query.parameter_count&apos;, (string) count($bindings));
        // Set service target
        $span-&gt;context()-&gt;destination()-&gt;setService($dbSubtype, $database, &apos;db&apos;);
    }
    /**
     * Set database context from QueryExecuted event (fallback)
     * 
     * This method is similar to setDatabaseContext but uses a QueryExecuted event
     * as the source of information. It&apos;s used as a fallback when a query is detected
     * after it has already executed.
     * 
     * @param SpanInterface $span The span to set context on
     * @param QueryExecuted $event The query executed event
     * @param string $dbSubtype The database subtype (postgresql, mysql, etc.)
     */
    private function setDatabaseContextFromEvent(SpanInterface $span, QueryExecuted $event, string $dbSubtype): void
    {
        $spanContext = $span-&gt;context();
        $database = $event-&gt;connection-&gt;getConfig(&apos;database&apos;);
        $username = $event-&gt;connection-&gt;getConfig(&apos;username&apos;);
        $span-&gt;context()-&gt;db()-&gt;setStatement($this-&gt;sanitizeQuery($event-&gt;sql));
        $spanContext-&gt;setLabel(&apos;db.instance&apos;, $database);
        $spanContext-&gt;setLabel(&apos;db.name&apos;, $database);
        $spanContext-&gt;setLabel(&apos;db.statement&apos;, $this-&gt;sanitizeQuery($event-&gt;sql));
        $spanContext-&gt;setLabel(&apos;db.type&apos;, &apos;sql&apos;);
        $spanContext-&gt;setLabel(&apos;db.user&apos;, $username);
        $spanContext-&gt;setLabel(&apos;db.system&apos;, $dbSubtype);
        $spanContext-&gt;setLabel(&apos;db.duration.ms&apos;, (string) $event-&gt;time);
        $queryType = $this-&gt;getQueryType($event-&gt;sql);
        $tableName = $this-&gt;extractTableName($event-&gt;sql);
        $spanContext-&gt;setLabel(&apos;db.operation&apos;, strtolower($queryType));
        if ($tableName) {
            $spanContext-&gt;setLabel(&apos;db.sql.table&apos;, $tableName);
        }
        $spanContext-&gt;setLabel(&apos;db.query.parameter_count&apos;, (string) count($event-&gt;bindings));
        $span-&gt;context()-&gt;destination()-&gt;setService($dbSubtype, $database, &apos;db&apos;);
    }
    /**
     * Add common span tags for all query types
     * 
     * @param OctaneApmManager $manager The APM manager
     * @param SpanInterface $span The span to add tags to
     * @param string $dbSubtype Database subtype (postgresql, mysql, etc.)
     * @param string $operation Database operation type (SELECT, INSERT, etc.)
     * @param bool $isEloquent Whether this is an Eloquent query
     */
    private function addCommonSpanTags(
        OctaneApmManager $manager, 
        SpanInterface $span, 
        string $dbSubtype, 
        string $operation, 
        bool $isEloquent = false
    ): void {
        $manager-&gt;addSpanTag($span, &apos;component&apos;, $dbSubtype);
        $manager-&gt;addSpanTag($span, &apos;span.kind&apos;, &apos;client&apos;);
        $manager-&gt;addSpanTag($span, &apos;db.operation&apos;, strtolower($operation));
        if ($isEloquent) {
            $manager-&gt;addSpanTag($span, &apos;db.framework&apos;, &apos;eloquent&apos;);
            $this-&gt;addEloquentRelationTags($manager, $span);
        }
    }
    /**
     * Add Eloquent relation-specific tags if available
     */
    private function addEloquentRelationTags(OctaneApmManager $manager, SpanInterface $span): void
    {
        $eloquentInfo = $this-&gt;getEloquentInfo();
        if ($eloquentInfo &amp;&amp; !empty($eloquentInfo[&apos;is_relation&apos;])) {
            $manager-&gt;addSpanTag($span, &apos;eloquent.is_relation&apos;, &apos;true&apos;);
            if (!empty($eloquentInfo[&apos;relation_name&apos;])) {
                $manager-&gt;addSpanTag($span, &apos;eloquent.relation_name&apos;, $eloquentInfo[&apos;relation_name&apos;]);
            }
            if (!empty($eloquentInfo[&apos;related_model&apos;])) {
                $relatedModelName = substr($eloquentInfo[&apos;related_model&apos;], strrpos($eloquentInfo[&apos;related_model&apos;], &apos;\\&apos;) + 1);
                $manager-&gt;addSpanTag($span, &apos;eloquent.related_model&apos;, $relatedModelName);
            }
        }
    }
    /**
     * Add span tags for pre-execution
     */
    private function addSpanTags(OctaneApmManager $manager, SpanInterface $span, string $sql, string $dbSubtype, bool $isEloquent = false): void
    {
        $queryType = $this-&gt;getQueryType($sql);
        $this-&gt;addCommonSpanTags($manager, $span, $dbSubtype, $queryType, $isEloquent);
    }
    /**
     * Add post-execution span tags
     */
    private function addPostExecutionTags(OctaneApmManager $manager, SpanInterface $span, QueryExecuted $event, bool $isEloquent = false): void
    {
        $durationMs = $event-&gt;time; // Use Laravel&apos;s timing
        $span-&gt;context()-&gt;setLabel(&apos;db.duration.ms&apos;, (string) round($durationMs, 3));
        if ($isEloquent) {
            $manager-&gt;addSpanTag($span, &apos;db.framework&apos;, &apos;eloquent&apos;);
            $this-&gt;addEloquentRelationTags($manager, $span);
        }
        if ($durationMs &gt; 1000) {
            $manager-&gt;addSpanTag($span, &apos;db.slow_query&apos;, &apos;true&apos;);
        }
    }
    /**
     * Add span tags for event-based tracking (fallback)
     */
    private function addEventSpanTags(OctaneApmManager $manager, SpanInterface $span, QueryExecuted $event, string $dbSubtype, bool $isEloquent = false): void
    {
        $queryType = $this-&gt;getQueryType($event-&gt;sql);
        $this-&gt;addCommonSpanTags($manager, $span, $dbSubtype, $queryType, $isEloquent);
        $manager-&gt;addSpanTag($span, &apos;db.duration.ms&apos;, (string) $event-&gt;time);
        if ($event-&gt;time &gt; 1000) {
            $manager-&gt;addSpanTag($span, &apos;db.slow_query&apos;, &apos;true&apos;);
        }
    }
    /**
     * Format a SQL query into a concise, human-readable description
     * 
     * This method extracts the query type (SELECT, INSERT, etc.) and the table name
     * from the SQL query and combines them into a short description like &quot;SELECT users&quot;.
     * 
     * @param string $sql The SQL query to format
     * @return string A concise description of the query
     */
    private function formatQuery(string $sql): string
    {
        $type = $this-&gt;getQueryType($sql);
        $table = $this-&gt;extractTableName($sql);
        return $table ? &quot;{$type} {$table}&quot; : $type;
    }
    /**
     * Extract the query type (SELECT, INSERT, etc.) from a SQL query
     * 
     * @param string $sql The SQL query
     * @return string The query type in uppercase
     */
    private function getQueryType(string $sql): string
    {
        $sql = trim(strtoupper($sql));
        return match (true) {
            str_starts_with($sql, &apos;SELECT&apos;) =&gt; &apos;SELECT&apos;,
            str_starts_with($sql, &apos;INSERT&apos;) =&gt; &apos;INSERT&apos;,
            str_starts_with($sql, &apos;UPDATE&apos;) =&gt; &apos;UPDATE&apos;,
            str_starts_with($sql, &apos;DELETE&apos;) =&gt; &apos;DELETE&apos;,
            str_starts_with($sql, &apos;CREATE&apos;) =&gt; &apos;CREATE&apos;,
            str_starts_with($sql, &apos;ALTER&apos;) =&gt; &apos;ALTER&apos;,
            str_starts_with($sql, &apos;DROP&apos;) =&gt; &apos;DROP&apos;,
            str_starts_with($sql, &apos;TRUNCATE&apos;) =&gt; &apos;TRUNCATE&apos;,
            str_starts_with($sql, &apos;REPLACE&apos;) =&gt; &apos;REPLACE&apos;,
            default =&gt; &apos;QUERY&apos;
        };
    }
    /**
     * Extract the table name from a SQL query
     * 
     * This method uses regular expressions to find the table name in various
     * types of SQL queries (SELECT, INSERT, UPDATE, etc.).
     * 
     * @param string $sql The SQL query
     * @return string|null The table name or null if not found
     */
    private function extractTableName(string $sql): ?string
    {
        $patterns = [
            &apos;/(?:FROM|INTO|UPDATE|JOIN)\s+[`&quot;]?(\w+)[`&quot;]?/i&apos;,
            &apos;/CREATE\s+TABLE\s+[`&quot;]?(\w+)[`&quot;]?/i&apos;,
            &apos;/ALTER\s+TABLE\s+[`&quot;]?(\w+)[`&quot;]?/i&apos;,
            &apos;/DROP\s+TABLE\s+[`&quot;]?(\w+)[`&quot;]?/i&apos;,
            &apos;/TRUNCATE\s+TABLE\s+[`&quot;]?(\w+)[`&quot;]?/i&apos;,
        ];
        foreach ($patterns as $pattern) {
            if (preg_match($pattern, $sql, $matches)) {
                return $matches[1];
            }
        }
        return null;
    }
    /**
     * Sanitize a SQL query by truncating it if it&apos;s too long
     * 
     * This prevents excessively large queries from consuming too much memory
     * or bandwidth when sent to the APM server.
     * 
     * @param string $sql The SQL query to sanitize
     * @return string The sanitized SQL query
     */
    private function sanitizeQuery(string $sql): string
    {
        return strlen($sql) &gt; 10000 ? substr($sql, 0, 10000) . &apos;... [TRUNCATED]&apos; : $sql;
    }
    /**
     * Determine if the query is from Eloquent and get model/builder info
     * 
     * This method analyzes the backtrace to determine if the current query is from Eloquent,
     * and if so, extracts detailed information about the model, method, and any relations involved.
     * It looks for Eloquent-specific classes and methods in the backtrace to identify Eloquent queries.
     * 
     * For relation queries, it attempts to extract the relation name and related model.
     * 
     * @return array|null Returns null if not an Eloquent query, otherwise returns an array with the following keys:
     *                    - is_eloquent: Always true if an array is returned
     *                    - class: The Eloquent model or builder class
     *                    - method: The method being called
     *                    - is_relation: Whether this is a relation query
     *                    - relation_name: The name of the relation (if is_relation is true)
     *                    - related_model: The related model class (if available)
     *                    - group_key: A unique key for grouping related queries
     */
    private function getEloquentInfo(): ?array
    {
        $backtrace = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS, 15);
        $eloquentClass = null;
        $eloquentMethod = null;
        $isEloquent = false;
        $relationName = null;
        $relatedModel = null;
        $isRelation = false;
        // Relation methods that we want to track
        $relationMethods = [
            &apos;belongsTo&apos;,
            &apos;hasMany&apos;,
            &apos;hasOne&apos;,
            &apos;belongsToMany&apos;,
            &apos;morphTo&apos;,
            &apos;morphMany&apos;,
            &apos;morphOne&apos;,
            &apos;morphToMany&apos;,
            &apos;hasManyThrough&apos;,
            &apos;hasOneThrough&apos;
        ];
        foreach ($backtrace as $index =&gt; $trace) {
            $class = $trace[&apos;class&apos;] ?? &apos;&apos;;
            $function = $trace[&apos;function&apos;] ?? &apos;&apos;;
            // Check for Eloquent classes in the backtrace
            if (str_contains($class, &apos;Illuminate\\Database\\Eloquent&apos;) || 
                str_contains($class, &apos;App\\Modules\\Eloquent&apos;) ||
                str_contains($class, &apos;App\\Models&apos;)) {
                $isEloquent = true;
                // If we haven&apos;t found a specific model/builder yet, use this one
                if ($eloquentClass === null) {
                    $eloquentClass = $class;
                    $eloquentMethod = $function;
                }
                // If this is a model class, prefer it over builder classes
                if (str_contains($class, &apos;App\\Models\\&apos;) || 
                    (str_contains($class, &apos;Illuminate\\Database\\Eloquent\\&apos;) &amp;&amp; !str_contains($class, &apos;Builder&apos;))) {
                    $eloquentClass = $class;
                    $eloquentMethod = $function;
                    // Check if this is a relation method
                    if (in_array($function, $relationMethods)) {
                        $isRelation = true;
                        $relationName = $function;
                        // Try to get the relation name from the next frame if available
                        if (isset($backtrace[$index + 1])) {
                            $nextFrame = $backtrace[$index + 1];
                            if (isset($nextFrame[&apos;function&apos;]) &amp;&amp; $nextFrame[&apos;function&apos;] === &apos;getRelationValue&apos;) {
                                // The relation name is often in the args of getRelationValue
                                if (isset($nextFrame[&apos;args&apos;][0]) &amp;&amp; is_string($nextFrame[&apos;args&apos;][0])) {
                                    $relationName = $nextFrame[&apos;args&apos;][0];
                                }
                            }
                        }
                        // Try to determine the related model
                        if (method_exists($class, $function)) {
                            try {
                                $reflectionMethod = new \ReflectionMethod($class, $function);
                                $docComment = $reflectionMethod-&gt;getDocComment();
                                if ($docComment) {
                                    // Extract @return Model type from docblock
                                    if (preg_match(&apos;/@return\s+([\\\\a-zA-Z0-9_]+)/&apos;, $docComment, $matches)) {
                                        $relatedModel = $matches[1];
                                    }
                                }
                            } catch (\ReflectionException $e) {
                                // Ignore reflection errors
                            }
                        }
                    }
                    // Found a model, no need to look further unless we&apos;re still looking for relation info
                    if (!$isRelation) {
                        break;
                    }
                }
            }
            // Check for Eloquent-specific methods
            if (in_array($function, [
                &apos;newEloquentBuilder&apos;,
                &apos;newModelQuery&apos;,
                &apos;newQuery&apos;,
                &apos;getRelationValue&apos;
            ])) {
                $isEloquent = true;
                // If we haven&apos;t found a specific class yet, use this one
                if ($eloquentClass === null) {
                    $eloquentClass = $class;
                    $eloquentMethod = $function;
                }
                // Check for relation loading
                if ($function === &apos;getRelationValue&apos; &amp;&amp; isset($trace[&apos;args&apos;][0]) &amp;&amp; is_string($trace[&apos;args&apos;][0])) {
                    $isRelation = true;
                    $relationName = $trace[&apos;args&apos;][0];
                }
            }
            // Check specifically for relation methods
            if (in_array($function, $relationMethods)) {
                $isEloquent = true;
                $isRelation = true;
                $relationName = $function;
                // If we haven&apos;t found a specific class yet, use this one
                if ($eloquentClass === null) {
                    $eloquentClass = $class;
                    $eloquentMethod = $function;
                }
            }
        }
        if (!$isEloquent) {
            return null;
        }
        // Generate a unique key for this Eloquent query group
        $groupKey = $eloquentClass ? $eloquentClass : &apos;eloquent&apos;;
        if ($eloquentMethod) {
            $groupKey .= &apos;::&apos; . $eloquentMethod;
        }
        // If this is a relation, add the relation name to the group key
        if ($isRelation &amp;&amp; $relationName) {
            $groupKey .= &apos;::&apos; . $relationName;
        }
        return [
            &apos;is_eloquent&apos; =&gt; true,
            &apos;class&apos; =&gt; $eloquentClass,
            &apos;method&apos; =&gt; $eloquentMethod,
            &apos;is_relation&apos; =&gt; $isRelation,
            &apos;relation_name&apos; =&gt; $relationName,
            &apos;related_model&apos; =&gt; $relatedModel,
            &apos;group_key&apos; =&gt; $groupKey
        ];
    }
    /**
     * Determine if the current query is from Eloquent
     * 
     * This is a simple wrapper around getEloquentInfo() that returns a boolean
     * indicating whether the current query is from Eloquent or not.
     * 
     * @return bool True if the query is from Eloquent, false otherwise
     */
    private function isEloquentQuery(): bool
    {
        return $this-&gt;getEloquentInfo() !== null;
    }
    /**
     * Extract the parent model name from a relation class
     * 
     * This method examines the backtrace to find the parent model of a relation.
     * It first looks for relation objects that have getParent and getRelated methods,
     * then tries to extract the parent model name from there. If that fails, it looks
     * for model classes in the backtrace.
     * 
     * @param array $backtrace The debug backtrace with objects
     * @return string|null The parent model name (without namespace) or null if not found
     */
    private function extractParentModelFromRelation(array $backtrace): ?string
    {
        foreach ($backtrace as $trace) {
            $object = $trace[&apos;object&apos;] ?? null;
            // Check if this is a relation object
            if ($object &amp;&amp; is_object($object) &amp;&amp; method_exists($object, &apos;getParent&apos;) &amp;&amp; method_exists($object, &apos;getRelated&apos;)) {
                try {
                    // Get the parent model
                    $parent = $object-&gt;getParent();
                    if ($parent) {
                        // Get the class name of the parent model
                        $parentClass = get_class($parent);
                        // Extract just the model name without namespace
                        return substr($parentClass, strrpos($parentClass, &apos;\\&apos;) + 1);
                    }
                } catch (\Throwable $e) {
                    // Ignore errors when trying to get parent
                }
            }
            // Fallback: Check if this is a model class with a relation method
            if (isset($trace[&apos;class&apos;]) &amp;&amp; str_contains($trace[&apos;class&apos;], &apos;App\\Models\\&apos;)) {
                return substr($trace[&apos;class&apos;], strrpos($trace[&apos;class&apos;], &apos;\\&apos;) + 1);
            }
        }
        return null;
    }
}</file><file path="app/Modules/Apm/Listeners/DefaultTerminatedHandler.php">&lt;?php
namespace App\Modules\Apm\Listeners;
use App\Modules\Apm\OctaneApmManager;
use Elastic\Apm\SpanInterface;
use Elastic\Apm\TransactionInterface;
use Illuminate\Http\Request;
use Illuminate\Http\Response;
use Laravel\Octane\Events\RequestHandled;
use Illuminate\Support\Facades\App;
use Laravel\Octane\Events\RequestTerminated;
use Laravel\Octane\Events\TaskTerminated;
use Laravel\Octane\Events\TickTerminated;
use Psr\Log\LoggerInterface;
use Throwable;
/**
 * Handles terminated events for APM transaction tracking
 */
class DefaultTerminatedHandler
{
    /**
     * Constructor
     */
    public function __construct(
        private ?LoggerInterface $logger = null,
    )
    {
    }
    /**
     * Handle the RequestHandled event
     */
    public function handleRequestHandled(RequestHandled $event): void
    {
        if (!config(&apos;apm.monitoring.responses&apos;, true)) {
            return;
        }
        try {
            $this-&gt;recordResponseMetrics($event);
        } catch (Throwable $e) {
            $this-&gt;logger?-&gt;error(&apos;Failed to record metrics&apos;, [
                &apos;exception&apos;       =&gt; $e-&gt;getMessage(),
                &apos;request_url&apos;     =&gt; $event-&gt;request-&gt;url(),
                &apos;response_status&apos; =&gt; $event-&gt;response-&gt;getStatusCode(),
            ]);
        }
    }
    /**
     * Handle the event.
     */
    public function handle(RequestTerminated|RequestHandled|TaskTerminated|TickTerminated $event): void
    {
        /** @var OctaneApmManager $manager */
        $manager = null;
        // Handle different event types
        if ($event instanceof RequestHandled) {
            // For RequestHandled events, the transaction is already handled in handleRequestHandled
            // and recordResponseMetrics, so we don&apos;t need to do anything here
            return;
        } else {
            // For Octane events (RequestTerminated, TaskTerminated, TickTerminated)
            // which have the app property
            $manager = $event-&gt;app-&gt;make(OctaneApmManager::class);
        }
        try {
            $this-&gt;setTransactionResult($manager, $event);
            $this-&gt;setTransactionOutcome($manager, $event);
            $this-&gt;addEventContext($manager, $event);
            $this-&gt;addTags($manager, $event);
            $manager-&gt;endTransaction();
        } catch (Throwable $e) {
            $this-&gt;logger?-&gt;error(&apos;Error during transaction termination&apos;, [
                &apos;exception&apos;  =&gt; $e-&gt;getMessage(),
                &apos;event_type&apos; =&gt; get_class($event),
            ]);
            // Ensure transaction always ends, even if there&apos;s an error
            try {
                $manager-&gt;endTransaction();
            } catch (Throwable $secondaryError) {
                $this-&gt;logger?-&gt;error(&apos;Secondary error during transaction cleanup&apos;, [
                    &apos;exception&apos; =&gt; $secondaryError-&gt;getMessage(),
                ]);
            }
        }
    }
    /**
     * Set the transaction result based on event type
     */
    private function setTransactionResult(OctaneApmManager $manager, RequestTerminated|RequestHandled|TaskTerminated|TickTerminated $event): void
    {
        $result = match (true) {
            $event instanceof RequestTerminated || $event instanceof RequestHandled =&gt; $this-&gt;getHttpResult($event),
            $event instanceof TaskTerminated =&gt; $this-&gt;getTaskResult($event),
            $event instanceof TickTerminated =&gt; &apos;success&apos;,
            default =&gt; &apos;unknown&apos;
        };
        $manager-&gt;setTransactionResult($result);
    }
    /**
     * Get HTTP result string from
     */
    private function getHttpResult(RequestTerminated|RequestHandled $event): string
    {
        $code = (string)$event-&gt;response-&gt;getStatusCode();
        if (empty($code)) {
            return &apos;HTTP 0xx&apos;;
        }
        return &apos;HTTP &apos; . $code[0] . str_repeat(&apos;x&apos;, strlen($code) - 1);
    }
    /**
     * Get task result
     */
    private function getTaskResult(TaskTerminated $event): string
    {
        return ($event-&gt;exitCode ?? 0) === 0 ? &apos;success&apos; : &apos;failure&apos;;
    }
    /**
     * Set the transaction outcome
     */
    private function setTransactionOutcome(OctaneApmManager $manager, RequestTerminated|RequestHandled|TaskTerminated|TickTerminated $event): void
    {
        $outcome = match (true) {
            $event instanceof RequestTerminated || $event instanceof RequestHandled =&gt; $this-&gt;getHttpOutcome($event),
            $event instanceof TaskTerminated =&gt; $this-&gt;getTaskOutcome($event),
            $event instanceof TickTerminated =&gt; &apos;success&apos;,
            default =&gt; &apos;unknown&apos;
        };
        $manager-&gt;setTransactionOutcome($outcome);
    }
    /**
     * Get HTTP outcome from
     */
    private function getHttpOutcome(RequestTerminated|RequestHandled $event): string
    {
        $statusCode = $event-&gt;response-&gt;getStatusCode();
        return match (true) {
            $statusCode &gt;= 200 &amp;&amp; $statusCode &lt; 300 =&gt; &apos;success&apos;,
            $statusCode &gt;= 400 &amp;&amp; $statusCode &lt; 500, $statusCode &gt;= 500 =&gt; &apos;failure&apos;,
            default =&gt; &apos;unknown&apos;
        };
    }
    /**
     * Get task outcome
     */
    private function getTaskOutcome(TaskTerminated $event): string
    {
        return ($event-&gt;exitCode ?? 0) === 0 ? &apos;success&apos; : &apos;failure&apos;;
    }
    /**
     * Add event-specific context
     */
    private function addEventContext(OctaneApmManager $manager, RequestTerminated|RequestHandled|TaskTerminated|TickTerminated $event): void
    {
        $transaction = $manager-&gt;getTransaction();
        if (!$transaction) {
            return;
        }
        // Add system resource metrics for all event types
        $this-&gt;addSystemResourceMetrics($manager);
        if ($event instanceof RequestTerminated || $event instanceof RequestHandled) {
            $this-&gt;addRequestContext($manager, $event);
        } else if ($event instanceof TaskTerminated) {
            $this-&gt;addTaskTerminatedContext($manager, $event);
        } else if ($event instanceof TickTerminated) {
            $this-&gt;addTickTerminatedContext($manager, $event);
        }
    }
    /**
     * Add system resource metrics (memory, CPU, etc.)
     */
    private function addSystemResourceMetrics(OctaneApmManager $manager): void
    {
        // Memory usage metrics
        $currentMemory = memory_get_usage(true);
        $peakMemory = memory_get_peak_usage(true);
        $systemMetrics = [
            &apos;system&apos; =&gt; [
                &apos;memory&apos; =&gt; [
                    &apos;current_bytes&apos; =&gt; $currentMemory,
                    &apos;current_mb&apos; =&gt; round($currentMemory / 1024 / 1024, 2),
                    &apos;peak_bytes&apos; =&gt; $peakMemory,
                    &apos;peak_mb&apos; =&gt; round($peakMemory / 1024 / 1024, 2),
                ],
            ],
        ];
        // Add CPU usage metrics if available
        $cpuMetrics = $this-&gt;getCpuUsageMetrics();
        if (!empty($cpuMetrics)) {
            $systemMetrics[&apos;system&apos;][&apos;cpu&apos;] = $cpuMetrics;
            // Add CPU usage as tags for easier querying
            if (isset($cpuMetrics[&apos;process_usage_percent&apos;])) {
                $manager-&gt;addCustomTag(&apos;system.cpu.process_percent&apos;, (string)$cpuMetrics[&apos;process_usage_percent&apos;]);
                // Flag high CPU usage
                if ($cpuMetrics[&apos;process_usage_percent&apos;] &gt; 70) {
                    $manager-&gt;addCustomTag(&apos;system.cpu.high_usage&apos;, &apos;true&apos;);
                }
            }
        }
        // Add load average if available
        $loadAvg = $this-&gt;getSystemLoadAverage();
        if (!empty($loadAvg)) {
            $systemMetrics[&apos;system&apos;][&apos;load_average&apos;] = $loadAvg;
            $manager-&gt;addCustomTag(&apos;system.load.1min&apos;, (string)$loadAvg[&apos;1min&apos;]);
        }
        $manager-&gt;addCustomContext($systemMetrics);
        // Add memory usage as tags for easier querying
        $manager-&gt;addCustomTag(&apos;system.memory.current_mb&apos;, (string)round($currentMemory / 1024 / 1024, 2));
        $manager-&gt;addCustomTag(&apos;system.memory.peak_mb&apos;, (string)round($peakMemory / 1024 / 1024, 2));
        // Check if we&apos;re approaching memory limit
        $memoryLimit = $this-&gt;getMemoryLimitInBytes();
        if ($memoryLimit &gt; 0) {
            $memoryUsagePercent = round(($peakMemory / $memoryLimit) * 100, 1);
            $manager-&gt;addCustomTag(&apos;system.memory.usage_percent&apos;, (string)$memoryUsagePercent);
            // Flag high memory usage
            if ($memoryUsagePercent &gt; 80) {
                $manager-&gt;addCustomTag(&apos;system.memory.high_usage&apos;, &apos;true&apos;);
            }
        }
        // Add garbage collection metrics if available
        if (function_exists(&apos;gc_status&apos;)) {
            $gcStatus = gc_status();
            $manager-&gt;addCustomContext([
                &apos;system&apos; =&gt; [
                    &apos;gc&apos; =&gt; $gcStatus,
                ],
            ]);
        }
        // Add process information
        $processInfo = $this-&gt;getProcessInfo();
        if (!empty($processInfo)) {
            $manager-&gt;addCustomContext([
                &apos;system&apos; =&gt; [
                    &apos;process&apos; =&gt; $processInfo,
                ],
            ]);
        }
    }
    /**
     * Get CPU usage metrics
     */
    private function getCpuUsageMetrics(): array
    {
        $metrics = [];
        // Try to get process CPU usage on Linux systems
        if (function_exists(&apos;shell_exec&apos;) &amp;&amp; PHP_OS_FAMILY === &apos;Linux&apos;) {
            try {
                $pid = getmypid();
                // Get process CPU usage using ps command
                $cmd = &quot;ps -p $pid -o %cpu | tail -n 1&quot;;
                $cpuUsage = trim(shell_exec($cmd));
                if (is_numeric($cpuUsage)) {
                    $metrics[&apos;process_usage_percent&apos;] = (float)$cpuUsage;
                }
                // Get process CPU time
                $cmd = &quot;ps -p $pid -o cputime | tail -n 1&quot;;
                $cpuTime = trim(shell_exec($cmd));
                if ($cpuTime) {
                    $metrics[&apos;process_cpu_time&apos;] = $cpuTime;
                }
            } catch (\Throwable $e) {
                // Ignore errors, CPU metrics are optional
            }
        } elseif (PHP_OS_FAMILY === &apos;Windows&apos; &amp;&amp; function_exists(&apos;shell_exec&apos;)) {
            try {
                $pid = getmypid();
                // Get process CPU usage on Windows
                $cmd = &quot;wmic process where ProcessId=$pid get PercentProcessorTime /value&quot;;
                $output = shell_exec($cmd);
                if (preg_match(&apos;/PercentProcessorTime=(\d+)/&apos;, $output, $matches)) {
                    $metrics[&apos;process_usage_percent&apos;] = (float)$matches[1];
                }
            } catch (\Throwable $e) {
                // Ignore errors, CPU metrics are optional
            }
        }
        return $metrics;
    }
    /**
     * Get system load average
     */
    private function getSystemLoadAverage(): array
    {
        if (function_exists(&apos;sys_getloadavg&apos;)) {
            try {
                $loadAvg = sys_getloadavg();
                if (is_array($loadAvg) &amp;&amp; count($loadAvg) === 3) {
                    return [
                        &apos;1min&apos; =&gt; round($loadAvg[0], 2),
                        &apos;5min&apos; =&gt; round($loadAvg[1], 2),
                        &apos;15min&apos; =&gt; round($loadAvg[2], 2),
                    ];
                }
            } catch (\Throwable $e) {
                // Ignore errors, load average is optional
            }
        }
        return [];
    }
    /**
     * Get process information
     */
    private function getProcessInfo(): array
    {
        $info = [
            &apos;pid&apos; =&gt; getmypid(),
            &apos;php_version&apos; =&gt; PHP_VERSION,
            &apos;sapi&apos; =&gt; PHP_SAPI,
        ];
        // Add uptime if available
        if (function_exists(&apos;hrtime&apos;)) {
            $info[&apos;uptime_seconds&apos;] = round(hrtime(true) / 1e9, 1);
        }
        return $info;
    }
    /**
     * Get PHP memory limit in bytes
     */
    private function getMemoryLimitInBytes(): int
    {
        $memoryLimit = ini_get(&apos;memory_limit&apos;);
        if ($memoryLimit === &apos;-1&apos;) {
            return 0; // Unlimited
        }
        $value = (int)$memoryLimit;
        $unit = strtolower(substr($memoryLimit, -1));
        switch ($unit) {
            case &apos;g&apos;:
                $value *= 1024;
                // Fall through
            case &apos;m&apos;:
                $value *= 1024;
                // Fall through
            case &apos;k&apos;:
                $value *= 1024;
        }
        return $value;
    }
    /**
     * Add context for request events (both RequestHandled and RequestTerminated)
     */
    private function addRequestContext(OctaneApmManager $manager, RequestTerminated|RequestHandled $event): void
    {
        $response = $event-&gt;response;
        $content = $response-&gt;getContent();
        $context = [
            &apos;response&apos; =&gt; [
                &apos;status_code&apos;    =&gt; $response-&gt;getStatusCode(),
                &apos;headers&apos;        =&gt; $this-&gt;getFilteredResponseHeaders($response),
                &apos;content_length&apos; =&gt; strlen($content),
                &apos;content_type&apos;   =&gt; $response-&gt;headers-&gt;get(&apos;Content-Type&apos;),
            ],
        ];
        // Add body for errors if configured
        if ($response-&gt;getStatusCode() &gt;= 400) {
            $captureBody = config(&apos;apm.transaction.capture_body&apos;, &apos;errors&apos;);
            if ($captureBody === &apos;all&apos; || $captureBody === &apos;errors&apos;) {
                $context[&apos;response&apos;][&apos;body&apos;] = $this-&gt;sanitizeResponseBody($content);
            }
        }
        $manager-&gt;addCustomContext($context);
    }
    /**
     * Get filtered headers
     */
    private function getFilteredResponseHeaders(Response $response): array
    {
        $headers = [];
        foreach ($response-&gt;headers-&gt;all() as $name =&gt; $values) {
            $lowerName = strtolower($name);
            if (!in_array($lowerName, [&apos;set-cookie&apos;, &apos;authorization&apos;])) {
                $headers[$name] = $values;
            }
        }
        return $headers;
    }
    /**
     * Sanitize body
     */
    private function sanitizeResponseBody(string $content): string
    {
        // Truncate larges
        if (strlen($content) &gt; 2048) {
            $content = substr($content, 0, 2048) . &apos;... [TRUNCATED]&apos;;
        }
        // If it&apos;s JSON, try to decode and remove sensitive fields
        if ($this-&gt;isValidJson($content)) {
            try {
                $data = json_decode($content, true);
                if (is_array($data)) {
                    $data = $this-&gt;sanitizeArray($data);
                    return json_encode($data);
                }
            } catch (Throwable) {
                // If JSON parsing fails, return original content
            }
        }
        return $content;
    }
    /**
     * Sanitize array by removing sensitive fields
     */
    private function sanitizeArray(array $data): array
    {
        $sensitiveFields = [&apos;password&apos;, &apos;token&apos;, &apos;secret&apos;, &apos;key&apos;, &apos;auth&apos;];
        foreach ($data as $key =&gt; $value) {
            $lowerKey = strtolower($key);
            $isSensitive = false;
            foreach ($sensitiveFields as $sensitiveField) {
                if (str_contains($lowerKey, $sensitiveField)) {
                    $isSensitive = true;
                    break;
                }
            }
            if ($isSensitive) {
                $data[$key] = &apos;[REDACTED]&apos;;
            } else if (is_array($value)) {
                $data[$key] = $this-&gt;sanitizeArray($value);
            }
        }
        return $data;
    }
    /**
     * Add context for task terminated events
     */
    private function addTaskTerminatedContext(OctaneApmManager $manager, TaskTerminated $event): void
    {
        $context = [
            &apos;task&apos; =&gt; [
                &apos;exit_code&apos;   =&gt; $event-&gt;exitCode ?? null,
                &apos;duration_ms&apos; =&gt; isset($event-&gt;duration) ? round($event-&gt;duration * 1000, 2) : null,
            ],
        ];
        if (isset($event-&gt;exception)) {
            $manager-&gt;recordException($event-&gt;exception, $context);
        }
        $manager-&gt;addCustomContext($context);
    }
    /**
     * Add context for tick terminated events
     */
    private function addTickTerminatedContext(OctaneApmManager $manager, TickTerminated $event): void
    {
        $context = [
            &apos;tick&apos; =&gt; [
                &apos;duration_ms&apos; =&gt; isset($event-&gt;duration) ? round($event-&gt;duration * 1000, 2) : null,
            ],
        ];
        $manager-&gt;addCustomContext($context);
    }
    /**
     * Add tags based on event type
     */
    private function addTags(OctaneApmManager $manager, RequestTerminated|RequestHandled|TaskTerminated|TickTerminated $event): void
    {
        if ($event instanceof RequestTerminated || $event instanceof RequestHandled) {
            $manager-&gt;addCustomTag(&apos;response.status_code&apos;, $event-&gt;response-&gt;getStatusCode());
            $manager-&gt;addCustomTag(&apos;response.status_class&apos;, $this-&gt;getStatusClass($event-&gt;response-&gt;getStatusCode()));
        } else if ($event instanceof TaskTerminated) {
            $manager-&gt;addCustomTag(&apos;task.exit_code&apos;, $event-&gt;exitCode ?? &apos;unknown&apos;);
        }
    }
    /**
     * Get status class for status code
     */
    private function getStatusClass(int $statusCode): string
    {
        return match (true) {
            $statusCode &gt;= 200 &amp;&amp; $statusCode &lt; 300 =&gt; &apos;2xx&apos;,
            $statusCode &gt;= 300 &amp;&amp; $statusCode &lt; 400 =&gt; &apos;3xx&apos;,
            $statusCode &gt;= 400 &amp;&amp; $statusCode &lt; 500 =&gt; &apos;4xx&apos;,
            $statusCode &gt;= 500 =&gt; &apos;5xx&apos;,
            default =&gt; &apos;unknown&apos;
        };
    }
    /**
     * Record metrics in APM for RequestHandled event
     */
    private function recordResponseMetrics(RequestHandled $event): void
    {
        /** @var OctaneApmManager $manager */
        $manager = App::make(OctaneApmManager::class);
        $request = $event-&gt;request;
        $response = $event-&gt;response;
        // Get current transaction (the request transaction)
        $requestTransaction = $manager-&gt;getTransaction();
        if (!$requestTransaction) {
            return;
        }
        // Add minimal metadata to request transaction
        $requestTransaction-&gt;context()-&gt;setLabel(&apos;http.response.status_code&apos;, (string)$response-&gt;getStatusCode());
        $requestTransaction-&gt;context()-&gt;setLabel(&apos;http.response.status_class&apos;, $this-&gt;getStatusClass($response-&gt;getStatusCode()));
        // Set outcome for the request transaction
        $this-&gt;setTransactionOutcomeFromResponse($requestTransaction, $response);
        // End the request transaction
        $manager-&gt;endTransaction();
        // Create a new transaction for the
        $responseTransaction = $this-&gt;beginResponseTransaction($manager, $request, $response);
        if (!$responseTransaction) {
            return;
        }
        // Add detailed context to the transaction
        $this-&gt;addResponseContext($responseTransaction, $request, $response);
        // Create a span for processing if it&apos;s a significant
        if ($this-&gt;shouldCreateResponseSpan($response)) {
            $this-&gt;createResponseSpan($manager, $request, $response);
        }
        // Record errors
        if ($response-&gt;isServerError() || $response-&gt;isClientError()) {
            $this-&gt;recordResponseError($responseTransaction, $request, $response);
        }
        // Set transaction outcome based on
        $this-&gt;setTransactionOutcomeFromResponse($responseTransaction, $response);
        // End the transaction
        $manager-&gt;endTransaction();
    }
    /**
     * Begin a new transaction for the
     */
    private function beginResponseTransaction(OctaneApmManager $manager, Request $request, $response): ?TransactionInterface
    {
        // Build a transaction name for the
        $transactionName = $this-&gt;buildResponseTransactionName($request, $response);
        // Build context for the transaction
        $context = [
            &apos;response&apos; =&gt; [
                &apos;status_code&apos; =&gt; $response-&gt;getStatusCode(),
                &apos;content_type&apos; =&gt; $response-&gt;headers-&gt;get(&apos;Content-Type&apos;, &apos;unknown&apos;),
                &apos;size&apos; =&gt; $this-&gt;getResponseSize($response),
            ],
            &apos;request&apos; =&gt; [
                &apos;method&apos; =&gt; $request-&gt;method(),
                &apos;url&apos; =&gt; $request-&gt;fullUrl(),
                &apos;path&apos; =&gt; $request-&gt;path(),
            ]
        ];
        // Begin the transaction
        $transaction = $manager-&gt;beginTransaction($transactionName, &apos;response&apos;, $context);
        if ($transaction) {
            // Add basic tags
            $manager-&gt;addCustomTag(&apos;response.status_code&apos;, $response-&gt;getStatusCode());
            $manager-&gt;addCustomTag(&apos;response.status_class&apos;, $this-&gt;getStatusClass($response-&gt;getStatusCode()));
            $manager-&gt;addCustomTag(&apos;response.content_type&apos;, $response-&gt;headers-&gt;get(&apos;Content-Type&apos;, &apos;unknown&apos;));
            // Link to the original request
            $manager-&gt;addCustomTag(&apos;response.for_request&apos;, $request-&gt;path());
            $manager-&gt;addCustomTag(&apos;response.for_method&apos;, $request-&gt;method());
        }
        return $transaction;
    }
    /**
     * Build a transaction name for the
     */
    private function buildResponseTransactionName(Request $request, $response): string
    {
        $statusCode = $response-&gt;getStatusCode();
        $statusClass = $this-&gt;getStatusClass($statusCode);
        $contentType = $response-&gt;headers-&gt;get(&apos;Content-Type&apos;, &apos;unknown&apos;);
        $contentTypeShort = $this-&gt;getShortContentType($contentType);
        return &quot;Response {$statusClass} {$contentTypeShort} for {$request-&gt;method()} {$request-&gt;path()}&quot;;
    }
    /**
     * Get a short version of the content type
     */
    private function getShortContentType(string $contentType): string
    {
        if (str_contains($contentType, &apos;application/json&apos;)) {
            return &apos;JSON&apos;;
        }
        if (str_contains($contentType, &apos;text/html&apos;)) {
            return &apos;HTML&apos;;
        }
        if (str_contains($contentType, &apos;text/plain&apos;)) {
            return &apos;Text&apos;;
        }
        if (str_contains($contentType, &apos;application/xml&apos;)) {
            return &apos;XML&apos;;
        }
        return &apos;Other&apos;;
    }
    /**
     * Set transaction outcome based on
     */
    private function setTransactionOutcomeFromResponse(TransactionInterface $transaction, $response): void
    {
        $statusCode = $response-&gt;getStatusCode();
        $outcome = match (true) {
            $statusCode &gt;= 200 &amp;&amp; $statusCode &lt; 300 =&gt; &apos;success&apos;,
            $statusCode &gt;= 400 &amp;&amp; $statusCode &lt; 500, $statusCode &gt;= 500 =&gt; &apos;failure&apos;,
            default =&gt; &apos;unknown&apos;
        };
        $transaction-&gt;setOutcome($outcome);
    }
    /**
     * Add context to the current transaction
     */
    private function addResponseContext(TransactionInterface $transaction, Request $request, $response): void
    {
        $context = $transaction-&gt;context();
        // Add labels
        $context-&gt;setLabel(&apos;http.response.status_code&apos;, (string)$response-&gt;getStatusCode());
        $context-&gt;setLabel(&apos;http.response.status_class&apos;, $this-&gt;getStatusClass($response-&gt;getStatusCode()));
        $context-&gt;setLabel(&apos;http.response.content_type&apos;, $response-&gt;headers-&gt;get(&apos;Content-Type&apos;, &apos;unknown&apos;));
        if ($contentLength = $this-&gt;getResponseSize($response)) {
            $context-&gt;setLabel(&apos;http.response.body.bytes&apos;, (string)$contentLength);
        }
        if ($cacheControl = $response-&gt;headers-&gt;get(&apos;Cache-Control&apos;)) {
            $context-&gt;setLabel(&apos;http.response.cache_control&apos;, $cacheControl);
        }
        // Add service dependencies detected from the request/response
        $this-&gt;addServiceDependenciesContext($transaction, $request, $response);
    }
    /**
     * Add service dependencies context to help track external dependencies
     */
    private function addServiceDependenciesContext(TransactionInterface $transaction, Request $request, $response): void
    {
        $dependencies = $this-&gt;detectServiceDependencies($request, $response);
        if (empty($dependencies)) {
            return;
        }
        $context = $transaction-&gt;context();
        // Add dependencies as labels
        foreach ($dependencies as $index =&gt; $dependency) {
            $prefix = &quot;service.dependency.{$index}&quot;;
            $context-&gt;setLabel(&quot;{$prefix}.name&quot;, $dependency[&apos;name&apos;]);
            $context-&gt;setLabel(&quot;{$prefix}.type&quot;, $dependency[&apos;type&apos;]);
            if (isset($dependency[&apos;version&apos;])) {
                $context-&gt;setLabel(&quot;{$prefix}.version&quot;, $dependency[&apos;version&apos;]);
            }
        }
        // Add count of dependencies
        $context-&gt;setLabel(&apos;service.dependencies.count&apos;, (string)count($dependencies));
    }
    /**
     * Detect service dependencies from request/response
     */
    private function detectServiceDependencies(Request $request, $response): array
    {
        $dependencies = [];
        // Check for API dependencies in headers
        $this-&gt;detectApiDependenciesFromHeaders($dependencies, $response);
        // Check for frontend dependencies
        $this-&gt;detectFrontendDependencies($dependencies, $response);
        // Check for third-party services
        $this-&gt;detectThirdPartyServices($dependencies, $request, $response);
        return $dependencies;
    }
    /**
     * Detect API dependencies from headers
     */
    private function detectApiDependenciesFromHeaders(array &amp;$dependencies, $response): void
    {
        // Common API headers that indicate dependencies
        $apiHeaders = [
            &apos;X-Powered-By&apos; =&gt; &apos;server&apos;,
            &apos;Server&apos; =&gt; &apos;server&apos;,
            &apos;X-AspNet-Version&apos; =&gt; &apos;framework&apos;,
            &apos;X-Runtime&apos; =&gt; &apos;framework&apos;,
            &apos;X-Version&apos; =&gt; &apos;api&apos;,
            &apos;X-API-Version&apos; =&gt; &apos;api&apos;,
            &apos;X-RateLimit-Limit&apos; =&gt; &apos;api&apos;,
        ];
        foreach ($apiHeaders as $header =&gt; $type) {
            if ($value = $response-&gt;headers-&gt;get($header)) {
                $dependencies[] = [
                    &apos;name&apos; =&gt; $this-&gt;normalizeHeaderValue($header, $value),
                    &apos;type&apos; =&gt; $type,
                    &apos;version&apos; =&gt; $this-&gt;extractVersionFromHeader($value),
                ];
            }
        }
    }
    /**
     * Detect frontend dependencies from content
     */
    private function detectFrontendDependencies(array &amp;$dependencies, $response): void
    {
        // Only check HTMLs
        if (!$this-&gt;isViewResponse($response)) {
            return;
        }
        $content = $response-&gt;getContent();
        if (!$content) {
            return;
        }
        // Check for common frontend frameworks
        $frontendPatterns = [
            &apos;react&apos; =&gt; &apos;/&lt;(?:script|link).*(?:react|react-dom).*\.js/i&apos;,
            &apos;vue&apos; =&gt; &apos;/&lt;(?:script|link).*vue.*\.js/i&apos;,
            &apos;angular&apos; =&gt; &apos;/&lt;(?:script|link).*angular.*\.js/i&apos;,
            &apos;bootstrap&apos; =&gt; &apos;/&lt;(?:script|link).*bootstrap.*\.(?:js|css)/i&apos;,
            &apos;jquery&apos; =&gt; &apos;/&lt;(?:script|link).*jquery.*\.js/i&apos;,
        ];
        foreach ($frontendPatterns as $framework =&gt; $pattern) {
            if (preg_match($pattern, $content)) {
                $dependencies[] = [
                    &apos;name&apos; =&gt; $framework,
                    &apos;type&apos; =&gt; &apos;frontend&apos;,
                ];
            }
        }
    }
    /**
     * Detect third-party services
     */
    private function detectThirdPartyServices(array &amp;$dependencies, Request $request, $response): void
    {
        // Check for common third-party services in content
        $content = $response-&gt;getContent();
        if (!$content) {
            return;
        }
        $servicePatterns = [
            &apos;google_analytics&apos; =&gt; &apos;/(?:gtag|ga|googletagmanager)/i&apos;,
            &apos;stripe&apos; =&gt; &apos;/(?:stripe\.com|stripe\.js)/i&apos;,
            &apos;facebook_pixel&apos; =&gt; &apos;/(?:facebook\.com\/tr|fbq\()/i&apos;,
            &apos;recaptcha&apos; =&gt; &apos;/(?:recaptcha|google\.com\/recaptcha)/i&apos;,
            &apos;intercom&apos; =&gt; &apos;/(?:intercom\.io|intercomcdn)/i&apos;,
        ];
        foreach ($servicePatterns as $service =&gt; $pattern) {
            if (preg_match($pattern, $content)) {
                $dependencies[] = [
                    &apos;name&apos; =&gt; str_replace(&apos;_&apos;, &apos; &apos;, $service),
                    &apos;type&apos; =&gt; &apos;third-party&apos;,
                ];
            }
        }
    }
    /**
     * Normalize header value for consistent naming
     */
    private function normalizeHeaderValue(string $header, string $value): string
    {
        // Clean up common header values
        $value = trim($value);
        // For Server header, extract main server name
        if ($header === &apos;Server&apos; &amp;&amp; strpos($value, &apos;/&apos;) !== false) {
            $parts = explode(&apos;/&apos;, $value);
            return trim($parts[0]);
        }
        return $value;
    }
    /**
     * Extract version from header value if present
     */
    private function extractVersionFromHeader(string $value): ?string
    {
        // Try to extract version numbers (e.g., &quot;nginx/1.18.0&quot; -&gt; &quot;1.18.0&quot;)
        if (preg_match(&apos;/[\/\s](\d+\.\d+(?:\.\d+)?(?:-\w+)?)/&apos;, $value, $matches)) {
            return $matches[1];
        }
        return null;
    }
    /**
     * Create a processing span for significants
     */
    private function createResponseSpan(OctaneApmManager $manager, Request $request, $response): void
    {
        $spanName = $this-&gt;getResponseSpanName($response);
        $span = $manager-&gt;createSpan(
            $spanName,
            &apos;template&apos;,
            $this-&gt;getResponseSubtype($response),
            &apos;render&apos;,
        );
        if (!$span) {
            return;
        }
        // Add context to span
        $spanContext = $span-&gt;context();
        $spanContext-&gt;setLabel(&apos;http.response.status_code&apos;, (string)$response-&gt;getStatusCode());
        $spanContext-&gt;setLabel(&apos;http.response.content_type&apos;, $response-&gt;headers-&gt;get(&apos;Content-Type&apos;, &apos;unknown&apos;));
        if ($contentLength = $this-&gt;getResponseSize($response)) {
            $spanContext-&gt;setLabel(&apos;http.response.size&apos;, (string)$contentLength);
        }
        // Add template/view information if available
        if ($this-&gt;isViewResponse($response)) {
            $this-&gt;addViewContext($span, $request);
        }
        // Add JSON API context if applicable
        if ($this-&gt;isJsonResponse($response)) {
            $this-&gt;addJsonContext($span, $response);
        }
        $span-&gt;setOutcome($response-&gt;isSuccessful() ? &apos;success&apos; : &apos;failure&apos;);
        $span-&gt;end();
    }
    /**
     * Record errors
     */
    private function recordResponseError(TransactionInterface $transaction, Request $request, $response): void
    {
        $errorType = $response-&gt;isServerError() ? &apos;server_error&apos; : &apos;client_error&apos;;
        $context = $transaction-&gt;context();
        $context-&gt;setLabel(&apos;error.type&apos;, $errorType);
        $context-&gt;setLabel(&apos;error.response_body_preview&apos;, $this-&gt;getResponseBodyPreview($response));
    }
    /**
     * Determine if we should create a span
     */
    private function shouldCreateResponseSpan(Response $response): bool
    {
        // Create spans for:
        // - Larges (&gt; 10KB)
        // - Server errors
        // - Specific content types that might be expensive to render
        if (config(&apos;apm.monitoring.always_sample_responses&apos;, false)) {
            return true;
        }
        $contentLength = $this-&gt;getResponseSize($response);
        if ($contentLength &amp;&amp; $contentLength &gt; 10240) { // 10KB
            return true;
        }
        if ($response-&gt;isServerError()) {
            return true;
        }
        $contentType = $response-&gt;headers-&gt;get(&apos;Content-Type&apos;, &apos;&apos;);
        $expensiveTypes = [&apos;text/html&apos;, &apos;application/pdf&apos;, &apos;image/&apos;, &apos;video/&apos;];
        foreach ($expensiveTypes as $type) {
            if (str_contains($contentType, $type)) {
                return true;
            }
        }
        return false;
    }
    /**
     * Get span name
     */
    private function getResponseSpanName(Response $response): string
    {
        $contentType = $response-&gt;headers-&gt;get(&apos;Content-Type&apos;, &apos;unknown&apos;);
        if (str_contains($contentType, &apos;text/html&apos;)) {
            return &apos;response.html&apos;;
        } else if (str_contains($contentType, &apos;application/json&apos;)) {
            return &apos;response.json&apos;;
        } else if (str_contains($contentType, &apos;image/&apos;)) {
            return &apos;response.image&apos;;
        } else if (str_contains($contentType, &apos;application/pdf&apos;)) {
            return &apos;response.pdf&apos;;
        }
        return &apos;response.render&apos;;
    }
    /**
     * Get subtype for span
     */
    private function getResponseSubtype(Response $response): string
    {
        $contentType = $response-&gt;headers-&gt;get(&apos;Content-Type&apos;, &apos;unknown&apos;);
        if (str_contains($contentType, &apos;text/html&apos;)) {
            return &apos;html&apos;;
        } else if (str_contains($contentType, &apos;application/json&apos;)) {
            return &apos;json&apos;;
        } else if (str_contains($contentType, &apos;image/&apos;)) {
            return &apos;image&apos;;
        } else if (str_contains($contentType, &apos;application/pdf&apos;)) {
            return &apos;pdf&apos;;
        }
        return &apos;http&apos;;
    }
    /**
     * Get size in bytes
     */
    private function getResponseSize(Response $response): ?int
    {
        // Try Content-Length header first
        if ($contentLength = $response-&gt;headers-&gt;get(&apos;Content-Length&apos;)) {
            return (int)$contentLength;
        }
        // Fall back to measuring content
        $content = $response-&gt;getContent();
        return $content ? strlen($content) : null;
    }
    /**
     * Check if is a view/template
     */
    private function isViewResponse(Response $response): bool
    {
        $contentType = $response-&gt;headers-&gt;get(&apos;Content-Type&apos;, &apos;&apos;);
        return str_contains($contentType, &apos;text/html&apos;);
    }
    /**
     * Check if is JSON
     */
    private function isJsonResponse(Response $response): bool
    {
        $contentType = $response-&gt;headers-&gt;get(&apos;Content-Type&apos;, &apos;&apos;);
        return str_contains($contentType, &apos;application/json&apos;);
    }
    /**
     * Add view/template context to span
     */
    private function addViewContext(SpanInterface $span, Request $request): void
    {
        $spanContext = $span-&gt;context();
        // Try to get view information from request attributes
        if ($route = $request-&gt;route()) {
            $spanContext-&gt;setLabel(&apos;template.route&apos;, $route-&gt;getName() ?: $route-&gt;uri());
            $spanContext-&gt;setLabel(&apos;template.controller&apos;, $route-&gt;getActionName());
        }
    }
    /**
     * Add JSON API context to span
     */
    private function addJsonContext(SpanInterface $span, $response): void
    {
        $spanContext = $span-&gt;context();
        // Try to decode and analyze JSON structure
        $content = $response-&gt;getContent();
        if ($content &amp;&amp; $this-&gt;isValidJson($content)) {
            $data = json_decode($content, true);
            if (is_array($data)) {
                $spanContext-&gt;setLabel(&apos;json.keys_count&apos;, (string)count($data));
                $spanContext-&gt;setLabel(&apos;json.has_data&apos;, isset($data[&apos;data&apos;]) ? &apos;true&apos; : &apos;false&apos;);
                $spanContext-&gt;setLabel(&apos;json.has_meta&apos;, isset($data[&apos;meta&apos;]) ? &apos;true&apos; : &apos;false&apos;);
            }
        }
    }
    /**
     * Get body preview for error context
     */
    private function getResponseBodyPreview(Response $response): string
    {
        $content = $response-&gt;getContent();
        if (!$content) {
            return &apos;[Empty body]&apos;;
        }
        // Limit preview to 500 characters
        $preview = substr($content, 0, 500);
        return strlen($content) &gt; 500 ? $preview . &apos;...[TRUNCATED]&apos; : $preview;
    }
    /**
     * Check if string is valid JSON
     */
    private function isValidJson(string $string): bool
    {
        return json_validate($string);
    }
}</file><file path="app/Modules/Apm/Listeners/HttpClientListener.php">&lt;?php
namespace App\Modules\Apm\Listeners;
use App\Modules\Apm\OctaneApmManager;
use Illuminate\Http\Client\Events\ConnectionFailed;
use Illuminate\Http\Client\Events\RequestSending;
use Illuminate\Http\Client\Events\ResponseReceived;
use Illuminate\Support\Facades\App;
use Psr\Log\LoggerInterface;
class HttpClientListener
{
    private array $activeSpans = [];
    public function __construct(
        private ?LoggerInterface $logger = null,
    )
    {
    }
    /**
     * Handle request sending event
     */
    public function handleRequestSending(RequestSending $event): void
    {
        if (!config(&apos;apm.monitoring.http_client&apos;, true)) {
            return;
        }
        try {
            /** @var OctaneApmManager $manager */
            $manager = App::make(OctaneApmManager::class);
            $url = parse_url($event-&gt;request-&gt;url());
            $spanName = ($event-&gt;request-&gt;method() ?? &apos;GET&apos;) . &apos; &apos; . ($url[&apos;host&apos;] ?? &apos;unknown&apos;);
            $span = $manager-&gt;createSpan($spanName, &apos;external&apos;, &apos;http&apos;, &apos;request&apos;);
            if ($span) {
                $this-&gt;activeSpans[spl_object_id($event-&gt;request)] = [
                    &apos;span&apos;       =&gt; $span,
                    &apos;start_time&apos; =&gt; microtime(true),
                ];
                $this-&gt;addRequestContext($manager, $span, $event, $url);
            }
        } catch (\Throwable $e) {
            $this-&gt;logger?-&gt;error(&apos;Failed to create HTTP client span&apos;, [
                &apos;exception&apos; =&gt; $e-&gt;getMessage(),
                &apos;url&apos;       =&gt; $event-&gt;request-&gt;url(),
            ]);
        }
    }
    /**
     * Add request context to span
     */
    private function addRequestContext(OctaneApmManager $manager, $span, RequestSending $event, array $url): void
    {
        $context = [
            &apos;http&apos;        =&gt; [
                &apos;method&apos;  =&gt; $event-&gt;request-&gt;method() ?? &apos;GET&apos;,
                &apos;url&apos;     =&gt; $event-&gt;request-&gt;url(),
                &apos;headers&apos; =&gt; $this-&gt;getFilteredHeaders($event-&gt;request-&gt;headers()),
            ],
            &apos;destination&apos; =&gt; [
                &apos;service&apos; =&gt; [
                    &apos;name&apos;     =&gt; $url[&apos;host&apos;] ?? &apos;unknown&apos;,
                    &apos;resource&apos; =&gt; ($url[&apos;host&apos;] ?? &apos;&apos;) . &apos;:&apos; . ($url[&apos;port&apos;] ?? $this-&gt;getDefaultPort($url)),
                    &apos;type&apos;     =&gt; &apos;external&apos;,
                ],
            ],
        ];
        // Add request body if it&apos;s small and not sensitive
        if ($event-&gt;request-&gt;body() &amp;&amp; strlen($event-&gt;request-&gt;body()) &lt;= 1024) {
            $body = $event-&gt;request-&gt;body();
            $context[&apos;http&apos;][&apos;request_body&apos;] = $this-&gt;sanitizeBody($body);
        }
        $manager-&gt;setSpanContext($span, $context);
        // Add tags using the manager&apos;s method
        $manager-&gt;addSpanTag($span, &apos;http.method&apos;, $event-&gt;request-&gt;method() ?? &apos;GET&apos;);
        $manager-&gt;addSpanTag($span, &apos;http.url.domain&apos;, $url[&apos;host&apos;] ?? &apos;unknown&apos;);
        if (isset($url[&apos;scheme&apos;])) {
            $manager-&gt;addSpanTag($span, &apos;http.url.scheme&apos;, $url[&apos;scheme&apos;]);
        }
    }
    /**
     * Get filtered headers (remove sensitive ones)
     */
    private function getFilteredHeaders(array $headers): array
    {
        $sensitiveHeaders = [
            &apos;authorization&apos;,
            &apos;cookie&apos;,
            &apos;x-api-key&apos;,
            &apos;x-auth-token&apos;,
            &apos;x-access-token&apos;,
        ];
        return array_filter($headers, function ($name) use ($sensitiveHeaders) {
            return !in_array(strtolower($name), $sensitiveHeaders);
        }, ARRAY_FILTER_USE_KEY);
    }
    /**
     * Get default port for scheme
     */
    private function getDefaultPort(array $url): int
    {
        if (isset($url[&apos;port&apos;])) {
            return (int)$url[&apos;port&apos;];
        }
        return match ($url[&apos;scheme&apos;] ?? &apos;http&apos;) {
            &apos;https&apos; =&gt; 443,
            &apos;http&apos; =&gt; 80,
            default =&gt; 80
        };
    }
    /**
     * Sanitize request/response body
     */
    private function sanitizeBody(string $body): string
    {
        // Truncate large bodies
        if (strlen($body) &gt; 1024) {
            $body = substr($body, 0, 1024) . &apos;... [TRUNCATED]&apos;;
        }
        // If it looks like JSON, try to sanitize it
        if ($this-&gt;isJson($body)) {
            try {
                $data = json_decode($body, true);
                if (is_array($data)) {
                    $data = $this-&gt;sanitizeArray($data);
                    return json_encode($data);
                }
            } catch (\Throwable) {
                // If JSON parsing fails, return original
            }
        }
        return $body;
    }
    /**
     * Check if string is JSON
     */
    private function isJson(string $string): bool
    {
        return json_validate($string);
    }
    /**
     * Sanitize array data
     */
    private function sanitizeArray(array $data): array
    {
        $sensitiveFields = [&apos;password&apos;, &apos;token&apos;, &apos;secret&apos;, &apos;key&apos;, &apos;auth&apos;];
        foreach ($data as $key =&gt; $value) {
            $lowerKey = strtolower($key);
            $isSensitive = false;
            foreach ($sensitiveFields as $sensitiveField) {
                if (str_contains($lowerKey, $sensitiveField)) {
                    $isSensitive = true;
                    break;
                }
            }
            if ($isSensitive) {
                $data[$key] = &apos;[REDACTED]&apos;;
            } else if (is_array($value)) {
                $data[$key] = $this-&gt;sanitizeArray($value);
            }
        }
        return $data;
    }
    /**
     * Handle response received event
     */
    public function handleResponseReceived(ResponseReceived $event): void
    {
        $requestId = spl_object_id($event-&gt;request);
        if (!isset($this-&gt;activeSpans[$requestId])) {
            return;
        }
        try {
            /** @var OctaneApmManager $manager */
            $manager = App::make(OctaneApmManager::class);
            $spanData = $this-&gt;activeSpans[$requestId];
            $span = $spanData[&apos;span&apos;];
            $duration = (microtime(true) - $spanData[&apos;start_time&apos;]) * 1000;
            $this-&gt;addResponseContext($manager, $span, $event, $duration);
            $span-&gt;setOutcome($event-&gt;response-&gt;successful() ? &apos;success&apos; : &apos;failure&apos;);
            $span-&gt;end();
        } catch (\Throwable $e) {
            $this-&gt;logger?-&gt;error(&apos;Failed to complete HTTP client span&apos;, [
                &apos;exception&apos; =&gt; $e-&gt;getMessage(),
            ]);
        } finally {
            unset($this-&gt;activeSpans[$requestId]);
        }
    }
    /**
     * Add response context to span
     */
    private function addResponseContext(OctaneApmManager $manager, $span, ResponseReceived $event, float $duration): void
    {
        $response = $event-&gt;response;
        $context = [
            &apos;http&apos;        =&gt; [
                &apos;response&apos; =&gt; [
                    &apos;status_code&apos; =&gt; $response-&gt;status(),
                    &apos;headers&apos;     =&gt; $this-&gt;getFilteredHeaders($response-&gt;headers()),
                ],
            ],
            &apos;performance&apos; =&gt; [
                &apos;duration_ms&apos; =&gt; round($duration, 2),
            ],
        ];
        // Add response body for errors or if it&apos;s small
        if ($response-&gt;failed() || strlen($response-&gt;body()) &lt;= 1024) {
            $context[&apos;http&apos;][&apos;response&apos;][&apos;body&apos;] = $this-&gt;sanitizeBody($response-&gt;body());
        }
        $manager-&gt;setSpanContext($span, $context);
        // Add response tags using the manager&apos;s method
        $manager-&gt;addSpanTag($span, &apos;http.response.status_code&apos;, $response-&gt;status());
        $manager-&gt;addSpanTag($span, &apos;http.response.status_class&apos;, $this-&gt;getStatusClass($response-&gt;status()));
    }
    /**
     * Get status class from status code
     */
    private function getStatusClass(int $statusCode): string
    {
        return match (true) {
            $statusCode &gt;= 200 &amp;&amp; $statusCode &lt; 300 =&gt; &apos;2xx&apos;,
            $statusCode &gt;= 300 &amp;&amp; $statusCode &lt; 400 =&gt; &apos;3xx&apos;,
            $statusCode &gt;= 400 &amp;&amp; $statusCode &lt; 500 =&gt; &apos;4xx&apos;,
            $statusCode &gt;= 500 =&gt; &apos;5xx&apos;,
            default =&gt; &apos;unknown&apos;
        };
    }
    /**
     * Handle connection failed event
     */
    public function handleConnectionFailed(ConnectionFailed $event): void
    {
        $requestId = spl_object_id($event-&gt;request);
        if (!isset($this-&gt;activeSpans[$requestId])) {
            return;
        }
        try {
            /** @var OctaneApmManager $manager */
            $manager = App::make(OctaneApmManager::class);
            $spanData = $this-&gt;activeSpans[$requestId];
            $span = $spanData[&apos;span&apos;];
            $span-&gt;setOutcome(&apos;failure&apos;);
            // Record the connection failure using the manager&apos;s setSpanContext method
            $manager-&gt;setSpanContext($span, [
                &apos;error&apos; =&gt; [
                    &apos;type&apos;    =&gt; &apos;connection_failed&apos;,
                    &apos;message&apos; =&gt; &apos;HTTP connection failed&apos;,
                ],
            ]);
            $span-&gt;end();
        } catch (\Throwable $e) {
            $this-&gt;logger?-&gt;error(&apos;Failed to handle HTTP connection failure&apos;, [
                &apos;exception&apos; =&gt; $e-&gt;getMessage(),
            ]);
        } finally {
            unset($this-&gt;activeSpans[$requestId]);
        }
    }
}</file><file path="app/Modules/Apm/Listeners/QueueListener.php">&lt;?php
namespace App\Modules\Apm\Listeners;
use App\Modules\Apm\OctaneApmManager;
use Illuminate\Queue\Events\{JobExceptionOccurred, JobFailed, JobProcessed, JobProcessing, JobQueued};
use Illuminate\Support\Facades\App;
use Laravel\Octane\Facades\Octane;
use Psr\Log\LoggerInterface;
use Swoole\Http\Server;
class QueueListener
{
    public function __construct(
        private ?LoggerInterface $logger = null,
    )
    {
    }
    /**
     * Handle job-queued event
     */
    public function handleJobQueued(JobQueued $event): void
    {
        if (!config(&apos;apm.monitoring.queue&apos;, true)) {
            return;
        }
        try {
            /** @var OctaneApmManager $manager */
            $manager = App::make(OctaneApmManager::class);
            $span = $manager-&gt;createSpan(
                &quot;Queue {$this-&gt;getJobName($event-&gt;job)}&quot;,
                &apos;messaging&apos;,
                &apos;queue&apos;,
                &apos;send&apos;,
            );
            if ($span) {
                $this-&gt;addQueuedSpanContext($manager, $span, $event);
                $span-&gt;end();
            }
        } catch (\Throwable $e) {
            $this-&gt;logger?-&gt;error(&apos;Failed to create queue queued span&apos;, [
                &apos;exception&apos; =&gt; $e-&gt;getMessage(),
                &apos;job&apos;       =&gt; $this-&gt;getJobName($event-&gt;job),
            ]);
        }
    }
    /**
     * Get job name from job object
     */
    private function getJobName($job): string
    {
        if (method_exists($job, &apos;resolveName&apos;)) {
            return $job-&gt;resolveName();
        }
        if (method_exists($job, &apos;getName&apos;)) {
            return $job-&gt;getName();
        }
        if (isset($job-&gt;job)) {
            return $job-&gt;job;
        }
        return get_class($job);
    }
    /**
     * Add context to queued job span
     */
    private function addQueuedSpanContext(OctaneApmManager $manager, $span, JobQueued $event): void
    {
        $context = [
            &apos;queue&apos; =&gt; [
                &apos;job_name&apos;     =&gt; $this-&gt;getJobName($event-&gt;job),
                &apos;queue_name&apos;   =&gt; $event-&gt;job-&gt;getQueue(),
                &apos;connection&apos;   =&gt; $event-&gt;connectionName,
                &apos;payload_size&apos; =&gt; strlen(json_encode($event-&gt;job-&gt;payload())),
                &apos;delay&apos;        =&gt; $event-&gt;job-&gt;getDelay(),
            ],
        ];
        $manager-&gt;setSpanContext($span, $context);
        $manager-&gt;addSpanTag($span, &apos;queue.name&apos;, $event-&gt;job-&gt;getQueue());
        $manager-&gt;addSpanTag($span, &apos;queue.connection&apos;, $event-&gt;connectionName);
    }
    /**
     * Handle job processing event
     */
    public function handleJobProcessing(JobProcessing $event): void
    {
        if (!config(&apos;apm.monitoring.queue&apos;, true)) {
            return;
        }
        try {
            /** @var OctaneApmManager $manager */
            $manager = App::make(OctaneApmManager::class);
            // Create a transaction for the job processing
            $transaction = $manager-&gt;beginTransaction(
                $this-&gt;getJobName($event-&gt;job),
                &apos;job&apos;,
            );
            if ($transaction) {
                $this-&gt;addProcessingTransactionContext($manager, $transaction, $event);
                // Store transaction data in Swoole table
                $this-&gt;storeTransactionData($event-&gt;job-&gt;getJobId(), [
                    &apos;start_time&apos; =&gt; microtime(true),
                    &apos;job_name&apos;   =&gt; $this-&gt;getJobName($event-&gt;job),
                    &apos;queue_name&apos; =&gt; $event-&gt;job-&gt;getQueue(),
                    &apos;connection&apos; =&gt; $event-&gt;connectionName,
                ]);
            }
        } catch (\Throwable $e) {
            $this-&gt;logger?-&gt;error(&apos;Failed to create queue processing transaction&apos;, [
                &apos;exception&apos; =&gt; $e-&gt;getMessage(),
                &apos;job&apos;       =&gt; $this-&gt;getJobName($event-&gt;job),
            ]);
        }
    }
    /**
     * Add context to processing job transaction
     */
    private function addProcessingTransactionContext(OctaneApmManager $manager, $transaction, JobProcessing $event): void
    {
        $context = [
            &apos;queue&apos; =&gt; [
                &apos;job_name&apos;   =&gt; $this-&gt;getJobName($event-&gt;job),
                &apos;job_id&apos;     =&gt; $event-&gt;job-&gt;getJobId(),
                &apos;queue_name&apos; =&gt; $event-&gt;job-&gt;getQueue(),
                &apos;connection&apos; =&gt; $event-&gt;connectionName,
                &apos;attempts&apos;   =&gt; $event-&gt;job-&gt;attempts(),
                &apos;max_tries&apos;  =&gt; $event-&gt;job-&gt;maxTries(),
                &apos;timeout&apos;    =&gt; $event-&gt;job-&gt;timeout(),
            ],
        ];
        // Add context to the current transaction (which is the one we just created)
        $manager-&gt;addCustomContext($context);
        $manager-&gt;addCustomTag(&apos;queue.name&apos;, $event-&gt;job-&gt;getQueue());
        $manager-&gt;addCustomTag(&apos;queue.connection&apos;, $event-&gt;connectionName);
        $manager-&gt;addCustomTag(&apos;queue.attempts&apos;, (string)$event-&gt;job-&gt;attempts());
    }
    /**
     * Store transaction data
     */
    private function storeTransactionData(string $jobId, array $data): void
    {
        if (!app()-&gt;bound(Server::class)) {
            \Cache::set($jobId, [
                &apos;start_time&apos; =&gt; $data[&apos;start_time&apos;],
                &apos;job_name&apos;   =&gt; $data[&apos;job_name&apos;] ?? &apos;&apos;,
                &apos;queue_name&apos; =&gt; $data[&apos;queue_name&apos;] ?? &apos;&apos;,
                &apos;connection&apos; =&gt; $data[&apos;connection&apos;] ?? &apos;&apos;,
            ]);
        }
        Octane::table(&apos;apm_queue_transactions&apos;)-&gt;set($jobId, [
            &apos;start_time&apos; =&gt; $data[&apos;start_time&apos;],
            &apos;job_name&apos;   =&gt; $data[&apos;job_name&apos;] ?? &apos;&apos;,
            &apos;queue_name&apos; =&gt; $data[&apos;queue_name&apos;] ?? &apos;&apos;,
            &apos;connection&apos; =&gt; $data[&apos;connection&apos;] ?? &apos;&apos;,
        ]);
    }
    /**
     * Handle job processed event
     */
    public function handleJobProcessed(JobProcessed $event): void
    {
        if (!config(&apos;apm.monitoring.queue&apos;, true)) {
            return;
        }
        $jobId = $event-&gt;job-&gt;getJobId();
        $transactionData = $this-&gt;getTransactionData($jobId);
        if ($transactionData) {
            try {
                /** @var OctaneApmManager $manager */
                $manager = App::make(OctaneApmManager::class);
                // Get current transaction (should be the job transaction)
                $duration = (microtime(true) - $transactionData[&apos;start_time&apos;]) * 1000; // Convert to ms
                // Add completion context to current transaction
                $manager-&gt;addCustomTag(&apos;queue.outcome&apos;, &apos;success&apos;);
                $manager-&gt;addCustomTag(&apos;queue.duration_ms&apos;, round($duration, 2));
                // The transaction will automatically end when the job completes
                // We just need to clean up our tracking data
                $this-&gt;removeTransactionData($jobId);
            } catch (\Throwable $e) {
                $this-&gt;logger?-&gt;error(&apos;Failed to update queue processing transaction&apos;, [
                    &apos;exception&apos; =&gt; $e-&gt;getMessage(),
                    &apos;job_id&apos;    =&gt; $jobId,
                ]);
            }
        }
    }
    /**
     * Get transaction data
     */
    private function getTransactionData(string $jobId): ?array
    {
        if (!app()-&gt;bound(Server::class)) {
            return \Cache::get($jobId);
        }
        return Octane::table(&apos;apm_queue_transactions&apos;)-&gt;get($jobId);
    }
    /**
     * Remove transaction data
     */
    private function removeTransactionData(string $jobId): void
    {
        if (!app()-&gt;bound(Server::class)) {
            \Cache::forget($jobId);
        }
        Octane::table(&apos;apm_queue_transactions&apos;)-&gt;del($jobId);
    }
    /**
     * Handle job failed event
     */
    public function handleJobFailed(JobFailed $event): void
    {
        if (!config(&apos;apm.monitoring.queue&apos;, true)) {
            return;
        }
        $jobId = $event-&gt;job-&gt;getJobId();
        $transactionData = $this-&gt;getTransactionData($jobId);
        if ($transactionData) {
            try {
                /** @var OctaneApmManager $manager */
                $manager = App::make(OctaneApmManager::class);
                $duration = (microtime(true) - $transactionData[&apos;start_time&apos;]) * 1000;
                // Add failure context to current transaction
                $manager-&gt;addCustomTag(&apos;queue.outcome&apos;, &apos;failure&apos;);
                $manager-&gt;addCustomTag(&apos;queue.duration_ms&apos;, round($duration, 2));
                $manager-&gt;addCustomTag(&apos;queue.error.message&apos;, $event-&gt;exception-&gt;getMessage());
                $manager-&gt;addCustomTag(&apos;queue.error.type&apos;, get_class($event-&gt;exception));
                // The transaction will automatically end when the job completes
                // We just need to clean up our tracking data
                $this-&gt;removeTransactionData($jobId);
            } catch (\Throwable $e) {
                $this-&gt;logger?-&gt;error(&apos;Failed to update failed queue transaction&apos;, [
                    &apos;exception&apos; =&gt; $e-&gt;getMessage(),
                    &apos;job_id&apos;    =&gt; $jobId,
                ]);
            }
        }
    }
    /**
     * Handle job exception occurred event
     */
    public function handleJobExceptionOccurred(JobExceptionOccurred $event): void
    {
        if (!config(&apos;apm.monitoring.queue&apos;, true)) {
            return;
        }
        try {
            /** @var OctaneApmManager $manager */
            $manager = App::make(OctaneApmManager::class);
            $span = $manager-&gt;createSpan(
                &quot;Exception in {$this-&gt;getJobName($event-&gt;job)}&quot;,
                &apos;messaging&apos;,
                &apos;queue&apos;,
                &apos;process&apos;,
            );
            if ($span) {
                $this-&gt;addExceptionSpanContext($manager, $span, $event);
                $span-&gt;end();
            }
        } catch (\Throwable $e) {
            $this-&gt;logger?-&gt;error(&apos;Failed to create queue exception span&apos;, [
                &apos;exception&apos; =&gt; $e-&gt;getMessage(),
                &apos;job&apos;       =&gt; $this-&gt;getJobName($event-&gt;job),
            ]);
        }
    }
    /**
     * Add context to exception span
     */
    private function addExceptionSpanContext(OctaneApmManager $manager, $span, JobExceptionOccurred $event): void
    {
        $context = [
            &apos;queue&apos; =&gt; [
                &apos;job_name&apos;   =&gt; $this-&gt;getJobName($event-&gt;job),
                &apos;job_id&apos;     =&gt; $event-&gt;job-&gt;getJobId(),
                &apos;queue_name&apos; =&gt; $event-&gt;job-&gt;getQueue(),
                &apos;connection&apos; =&gt; $event-&gt;connectionName,
                &apos;attempts&apos;   =&gt; $event-&gt;job-&gt;attempts(),
                &apos;error&apos;      =&gt; [
                    &apos;message&apos; =&gt; $event-&gt;exception-&gt;getMessage(),
                    &apos;type&apos;    =&gt; get_class($event-&gt;exception),
                    &apos;file&apos;    =&gt; $event-&gt;exception-&gt;getFile(),
                    &apos;line&apos;    =&gt; $event-&gt;exception-&gt;getLine(),
                ],
            ],
        ];
        $manager-&gt;setSpanContext($span, $context);
        $manager-&gt;addSpanTag($span, &apos;queue.name&apos;, $event-&gt;job-&gt;getQueue());
        $manager-&gt;addSpanTag($span, &apos;queue.connection&apos;, $event-&gt;connectionName);
        $manager-&gt;addSpanTag($span, &apos;error&apos;, &apos;true&apos;);
    }
}</file><file path="app/Modules/Apm/Listeners/RedisListener.php">&lt;?php
namespace App\Modules\Apm\Listeners;
use App\Modules\Apm\OctaneApmManager;
use Elastic\Apm\SpanInterface;
use Illuminate\Redis\Events\CommandExecuted;
use Illuminate\Support\Facades\App;
use Illuminate\Support\Facades\Log;
use Psr\Log\LoggerInterface;
use Throwable;
class RedisListener
{
    /**
     * Constructor
     */
    public function __construct(private ?LoggerInterface $logger = null)
    {
    }
    /**
     * Handle Redis command executed event
     */
    public function handle(CommandExecuted $event): void
    {
        if (!config(&apos;apm.monitoring.redis&apos;, true)) {
            return;
        }
        try {
            /** @var OctaneApmManager $manager */
            $manager = App::make(OctaneApmManager::class);
            if (!$manager-&gt;isEnabled()) {
                return;
            }
            $this-&gt;recordRedisCommand($manager, $event);
        } catch (Throwable $e) {
            Log::error(&apos;Failed to record Redis command in APM&apos;, [
                &apos;error&apos;      =&gt; $e-&gt;getMessage(),
                &apos;command&apos;    =&gt; $event-&gt;command,
                &apos;connection&apos; =&gt; $event-&gt;connectionName,
            ]);
        }
    }
    /**
     * Record Redis command execution
     */
    private function recordRedisCommand(OctaneApmManager $manager, CommandExecuted $event): void
    {
        $commandName = strtoupper($event-&gt;command);
        $spanName = &quot;redis.{$commandName}&quot;;
        // Create span for the Redis operation
        $span = $manager-&gt;createSpan(
            name: $spanName,
            type: &apos;db&apos;,
            subtype: &apos;redis&apos;,
            action: &apos;query&apos;,
        );
        if (!$span) {
            return;
        }
        // Add Redis-specific context
        $this-&gt;addRedisContext($span, $event);
        // End the span immediately since the command has already executed
        $span-&gt;end($event-&gt;time);
    }
    /**
     * Add Redis-specific context to the span
     */
    private function addRedisContext(SpanInterface $span, CommandExecuted $event): void
    {
        // Add basic Redis information
        $span-&gt;context()-&gt;setLabel(&apos;redis.command&apos;, strtoupper($event-&gt;command));
        $span-&gt;context()-&gt;setLabel(&apos;redis.connection&apos;, $event-&gt;connectionName ?? &apos;default&apos;);
        $span-&gt;context()-&gt;setLabel(&apos;redis.duration_ms&apos;, number_format($event-&gt;time, 2));
        // Add command parameters (sanitized)
        if (!empty($event-&gt;parameters)) {
            $sanitizedParams = $this-&gt;sanitizeRedisParameters($event-&gt;command, $event-&gt;parameters);
            foreach ($sanitizedParams as $key =&gt; $value) {
                $span-&gt;context()-&gt;setLabel(&quot;redis.param.{$key}&quot;, $value);
            }
        }
        // Add database context if available
        $span-&gt;context()-&gt;db()-&gt;setStatement($this-&gt;buildRedisStatement($event));
        $span-&gt;context()-&gt;db()-&gt;setType(&apos;redis&apos;);
        $span-&gt;context()-&gt;db()-&gt;setInstance($event-&gt;connectionName ?? &apos;default&apos;);;
        // Set destination context
//        $span-&gt;context()-&gt;destination()-&gt;setService(
//            name: &apos;redis&apos;,
//            resource: $event-&gt;connectionName ?? &apos;default&apos;,
//            type: &apos;db&apos;,
//        );
        $span-&gt;setOutcome(&apos;success&apos;);
    }
    /**
     * Sanitize Redis parameters to avoid logging sensitive data
     */
    private function sanitizeRedisParameters(string $command, array $parameters): array
    {
        $sanitized = [];
        $command = strtoupper($command);
        // Define sensitive commands that should have their values hidden
        $sensitiveCommands = [&apos;AUTH&apos;, &apos;CONFIG&apos;, &apos;EVAL&apos;, &apos;EVALSHA&apos;];
        $shouldSanitize = in_array($command, $sensitiveCommands);
        foreach ($parameters as $index =&gt; $param) {
            $key = &quot;param_{$index}&quot;;
            if ($shouldSanitize &amp;&amp; $index &gt; 0) {
                // Hide values for sensitive commands, keep first param (usually key name)
                $sanitized[$key] = &apos;[REDACTED]&apos;;
            } else if (is_string($param) &amp;&amp; strlen($param) &gt; 1000) {
                // Truncate very long parameters
                $sanitized[$key] = substr($param, 0, 1000) . &apos;...[TRUNCATED]&apos;;
            } else if (is_array($param)) {
                $sanitized[$key] = &apos;[ARRAY:&apos; . count($param) . &apos;]&apos;;
            } else if (is_object($param)) {
                $sanitized[$key] = &apos;[OBJECT:&apos; . get_class($param) . &apos;]&apos;;
            } else {
                $sanitized[$key] = (string)$param;
            }
        }
        return $sanitized;
    }
    /**
     * Build Redis statement for database context
     */
    private function buildRedisStatement(CommandExecuted $event): string
    {
        $command = strtoupper($event-&gt;command);
        if (empty($event-&gt;parameters)) {
            return $command;
        }
        // For some commands, include the key name
        $keyCommands = [&apos;GET&apos;, &apos;SET&apos;, &apos;DEL&apos;, &apos;EXISTS&apos;, &apos;EXPIRE&apos;, &apos;TTL&apos;, &apos;INCR&apos;, &apos;DECR&apos;];
        if (in_array($command, $keyCommands) &amp;&amp; isset($event-&gt;parameters[0])) {
            return &quot;{$command} {$event-&gt;parameters[0]}&quot;;
        }
        // For list/hash commands, include key and field if available
        $keyFieldCommands = [&apos;HGET&apos;, &apos;HSET&apos;, &apos;HDEL&apos;, &apos;LPUSH&apos;, &apos;RPUSH&apos;, &apos;LPOP&apos;, &apos;RPOP&apos;];
        if (in_array($command, $keyFieldCommands)) {
            $parts = [$command];
            if (isset($event-&gt;parameters[0])) {
                $parts[] = $event-&gt;parameters[0];
            }
            if (isset($event-&gt;parameters[1]) &amp;&amp; !in_array($command, [&apos;LPOP&apos;, &apos;RPOP&apos;])) {
                $parts[] = $event-&gt;parameters[1];
            }
            return implode(&apos; &apos;, $parts);
        }
        // For other commands, just return the command name with parameter count
        $paramCount = count($event-&gt;parameters);
        return &quot;{$command} ({$paramCount} params)&quot;;
    }
}</file><file path="app/Modules/Apm/Listeners/RequestReceivedHandler.php">&lt;?php
namespace App\Modules\Apm\Listeners;
use App\Modules\Apm\OctaneApmManager;
use Illuminate\Http\Request;
use Illuminate\Routing\Route;
use Laravel\Octane\Events\RequestReceived;
use Psr\Log\LoggerInterface;
use Throwable;
class RequestReceivedHandler
{
    public function __construct(
        private ?LoggerInterface $logger = null,
    )
    {
    }
    /**
     * Handle the event.
     */
    public function handle(RequestReceived $event): void
    {
        try {
            /** @var OctaneApmManager $manager */
            $manager = $event-&gt;app-&gt;make(OctaneApmManager::class);
            $requestContext = $this-&gt;buildRequestContext($event);
            $transactionName = $this-&gt;buildTransactionName($event);
            $transaction = $manager-&gt;beginTransaction($transactionName, &apos;request&apos;, $requestContext);
            $transaction-&gt;context()-&gt;request()-&gt;setMethod($event-&gt;request-&gt;method());
            $transaction-&gt;context()-&gt;request()-&gt;url()-&gt;setFull($event-&gt;request-&gt;fullUrl());
            $transaction-&gt;context()-&gt;request()-&gt;setHeaders($event-&gt;request-&gt;headers-&gt;all());
            $transaction-&gt;context()-&gt;request()-&gt;setCookies($event-&gt;request-&gt;cookies-&gt;all());
            if ($transaction) {
                $this-&gt;addRequestTags($manager, $event);
                $this-&gt;addSwooleContext($manager, $event);
                $this-&gt;addRequestContext($manager, $event, $requestContext);
            }
        } catch (Throwable $e) {
            $this-&gt;logger?-&gt;error(&apos;Failed to handle RequestReceived event&apos;, [
                &apos;exception&apos; =&gt; $e-&gt;getMessage(),
                &apos;trace&apos;     =&gt; $e-&gt;getTraceAsString(),
            ]);
        }
    }
    /**
     * Build request context
     */
    private function buildRequestContext(RequestReceived $event): array
    {
        try {
            $request = $event-&gt;request;
            $context = [
                &apos;request&apos; =&gt; [
                    &apos;method&apos;       =&gt; $request-&gt;method(),
                    &apos;url&apos;          =&gt; $request-&gt;fullUrl(),
                    &apos;user_agent&apos;   =&gt; $request-&gt;userAgent(),
                    &apos;ip&apos;           =&gt; $request-&gt;ip(),
                    &apos;scheme&apos;       =&gt; $request-&gt;getScheme(),
                    &apos;path&apos;         =&gt; $request-&gt;path(),
                    &apos;query_string&apos; =&gt; $request-&gt;getQueryString(),
                ],
            ];
            // Add Swoole-specific request context
            if ($this-&gt;isSwooleEnvironment()) {
                $context[&apos;request&apos;][&apos;swoole&apos;] = [
                    &apos;server_port&apos;   =&gt; $request-&gt;getPort(),
                    &apos;connection_id&apos; =&gt; $this-&gt;getConnectionId($request),
                ];
            }
            return $context;
        } catch (Throwable $e) {
            $this-&gt;logger?-&gt;warning(&apos;Failed to build request context&apos;, [
                &apos;exception&apos; =&gt; $e-&gt;getMessage(),
            ]);
            return [
                &apos;request&apos; =&gt; [
                    &apos;method&apos; =&gt; $event-&gt;request-&gt;method() ?? &apos;UNKNOWN&apos;,
                    &apos;path&apos;   =&gt; $event-&gt;request-&gt;path() ?? &apos;/&apos;,
                ],
            ];
        }
    }
    /**
     * Check if running in Swoole environment
     */
    private function isSwooleEnvironment(): bool
    {
        return extension_loaded(&apos;swoole&apos;) &amp;&amp;
            defined(&apos;SWOOLE_BASE&apos;);
    }
    /**
     * Get connection ID from request
     */
    private function getConnectionId(Request $request): ?int
    {
        // Try to get connection info from request attributes or headers
        try {
            // Check if Octane sets connection info
            if ($request-&gt;attributes-&gt;has(&apos;swoole_connection_id&apos;)) {
                return $request-&gt;attributes-&gt;get(&apos;swoole_connection_id&apos;);
            }
            // Fallback to a hash of the connection info
            $connectionInfo = $request-&gt;ip() . &apos;:&apos; . $request-&gt;getPort();
            return crc32($connectionInfo);
        } catch (Throwable $e) {
            return null;
        }
    }
    /**
     * Build the transaction name
     */
    private function buildTransactionName(RequestReceived $event): string
    {
        try {
            $method = $event-&gt;request-&gt;method();
            $routeInfo = $this-&gt;getRouteInfoFromRequest($event-&gt;request);
            return &quot;{$method} {$routeInfo[&apos;pattern&apos;]}&quot;;
        } catch (Throwable $e) {
            $this-&gt;logger?-&gt;debug(&apos;Failed to build transaction name&apos;, [
                &apos;exception&apos; =&gt; $e-&gt;getMessage(),
            ]);
            return $event-&gt;request-&gt;method() . &apos; &apos; . $event-&gt;request-&gt;path();
        }
    }
    /**
     * Get route information from request (improved method)
     */
    private function getRouteInfoFromRequest(Request $request): array
    {
        try {
            $route = $request-&gt;route();
            if ($route instanceof Route) {
                return [
                    &apos;pattern&apos;    =&gt; $this-&gt;getRoutePattern($route),
                    &apos;name&apos;       =&gt; $route-&gt;getName(),
                    &apos;action&apos;     =&gt; $this-&gt;getRouteAction($route),
                    &apos;parameters&apos; =&gt; $route-&gt;parameters(),
                ];
            }
            // Fallback if route is not resolved yet
            return $this-&gt;buildFallbackRouteInfo($request);
        } catch (Throwable $e) {
            $this-&gt;logger?-&gt;debug(&apos;Route resolution failed&apos;, [
                &apos;path&apos;      =&gt; $request-&gt;path(),
                &apos;method&apos;    =&gt; $request-&gt;method(),
                &apos;exception&apos; =&gt; $e-&gt;getMessage(),
            ]);
            return $this-&gt;buildFallbackRouteInfo($request);
        }
    }
    /**
     * Get route pattern from route
     */
    private function getRoutePattern(Route $route): string
    {
        try {
            $uri = $route-&gt;uri();
            return &apos;/&apos; . ltrim($uri, &apos;/&apos;);
        } catch (Throwable $e) {
            return &apos;/unknown&apos;;
        }
    }
    /**
     * Extract action information from route
     */
    private function getRouteAction(Route $route): string
    {
        try {
            $action = $route-&gt;getAction();
            if (isset($action[&apos;controller&apos;])) {
                return $action[&apos;controller&apos;];
            }
            if (isset($action[&apos;uses&apos;]) &amp;&amp; is_string($action[&apos;uses&apos;])) {
                return $action[&apos;uses&apos;];
            }
            return &apos;closure&apos;;
        } catch (Throwable $e) {
            return &apos;unknown&apos;;
        }
    }
    /**
     * Build fallback route info
     */
    private function buildFallbackRouteInfo(Request $request): array
    {
        $path = $request-&gt;path();
        return [
            &apos;pattern&apos;    =&gt; &apos;/&apos; . ltrim($path, &apos;/&apos;),
            &apos;name&apos;       =&gt; null,
            &apos;action&apos;     =&gt; &apos;unknown&apos;,
            &apos;parameters&apos; =&gt; [],
        ];
    }
    /**
     * Add request tags to the transaction
     */
    private function addRequestTags(OctaneApmManager $manager, RequestReceived $event): void
    {
        try {
            $request = $event-&gt;request;
            $routeInfo = $this-&gt;getRouteInfoFromRequest($request);
            $manager-&gt;addCustomTag(&apos;request.method&apos;, $request-&gt;method());
            $manager-&gt;addCustomTag(&apos;request.scheme&apos;, $request-&gt;getScheme());
            $manager-&gt;addCustomTag(&apos;request.ajax&apos;, $request-&gt;ajax() ? &apos;true&apos; : &apos;false&apos;);
            if (!empty($routeInfo[&apos;name&apos;])) {
                $manager-&gt;addCustomTag(&apos;request.route_name&apos;, $routeInfo[&apos;name&apos;]);
            }
            if ($routeInfo[&apos;action&apos;] !== &apos;unknown&apos;) {
                $manager-&gt;addCustomTag(&apos;request.action&apos;, $routeInfo[&apos;action&apos;]);
            }
            // Add custom headers as tags if configured
            $this-&gt;addHeaderTags($manager, $request);
        } catch (Throwable $e) {
            $this-&gt;logger?-&gt;warning(&apos;Failed to add request tags&apos;, [
                &apos;exception&apos; =&gt; $e-&gt;getMessage(),
            ]);
        }
    }
    /**
     * Add header tags
     */
    private function addHeaderTags(OctaneApmManager $manager, Request $request): void
    {
        $headerTags = [
            &apos;X-Request-ID&apos;    =&gt; &apos;request.id&apos;,
            &apos;X-Forwarded-For&apos; =&gt; &apos;request.forwarded_for&apos;,
            &apos;X-Real-IP&apos;       =&gt; &apos;request.real_ip&apos;,
        ];
        foreach ($headerTags as $header =&gt; $tag) {
            if ($request-&gt;hasHeader($header)) {
                $headerValue = $request-&gt;header($header);
                if ($headerValue &amp;&amp; is_string($headerValue)) {
                    $manager-&gt;addCustomTag($tag, $headerValue);
                }
            }
        }
    }
    /**
     * Add Swoole-specific context
     */
    private function addSwooleContext(OctaneApmManager $manager, RequestReceived $event): void
    {
        if (!$this-&gt;isSwooleEnvironment()) {
            return;
        }
        try {
            $swooleContext = [
                &apos;swoole&apos; =&gt; [
                    &apos;worker_id&apos;    =&gt; $this-&gt;getSwooleWorkerId(),
                    &apos;worker_pid&apos;   =&gt; getmypid(),
                    &apos;memory_usage&apos; =&gt; $this-&gt;getWorkerMemoryUsage(),
                ],
            ];
            // Add coroutine information if available
            if ($this-&gt;hasCoroutineSupport()) {
                $swooleContext[&apos;swoole&apos;][&apos;coroutine&apos;] = $this-&gt;getCoroutineInfo();
            }
            // Add request queue time metrics
            $queueTimeMetrics = $this-&gt;calculateQueueTimeMetrics($event);
            if (!empty($queueTimeMetrics)) {
                $swooleContext[&apos;swoole&apos;][&apos;request_queue&apos;] = $queueTimeMetrics;
                // Add queue time as a tag for easier querying
                if (isset($queueTimeMetrics[&apos;queue_time_ms&apos;])) {
                    $manager-&gt;addCustomTag(&apos;request.queue_time_ms&apos;, (string)$queueTimeMetrics[&apos;queue_time_ms&apos;]);
                    // Flag slow queue times
                    if ($queueTimeMetrics[&apos;queue_time_ms&apos;] &gt; 100) { // More than 100ms in queue
                        $manager-&gt;addCustomTag(&apos;request.slow_queue&apos;, &apos;true&apos;);
                    }
                }
            }
            $manager-&gt;addCustomContext($swooleContext);
            // Add Swoole tags
            $manager-&gt;addCustomTag(&apos;swoole.worker_id&apos;, (string)$this-&gt;getSwooleWorkerId());
            $manager-&gt;addCustomTag(&apos;swoole.worker_type&apos;, $this-&gt;getSwooleWorkerType());
        } catch (Throwable $e) {
            $this-&gt;logger?-&gt;warning(&apos;Failed to add Swoole context to APM&apos;, [
                &apos;exception&apos; =&gt; $e-&gt;getMessage(),
            ]);
        }
    }
    /**
     * Calculate request queue time metrics
     */
    private function calculateQueueTimeMetrics(RequestReceived $event): array
    {
        try {
            $now = microtime(true);
            $requestStartTime = $this-&gt;getRequestStartTime($event);
            if (!$requestStartTime) {
                return [];
            }
            $queueTimeSeconds = $now - $requestStartTime;
            $queueTimeMs = round($queueTimeSeconds * 1000, 2);
            return [
                &apos;queue_time_ms&apos; =&gt; $queueTimeMs,
                &apos;request_received_at&apos; =&gt; $this-&gt;formatMicrotime($requestStartTime),
                &apos;processing_started_at&apos; =&gt; $this-&gt;formatMicrotime($now),
            ];
        } catch (Throwable $e) {
            $this-&gt;logger?-&gt;debug(&apos;Failed to calculate queue time&apos;, [
                &apos;exception&apos; =&gt; $e-&gt;getMessage(),
            ]);
            return [];
        }
    }
    /**
     * Get the time when the request was received by the server
     */
    private function getRequestStartTime(RequestReceived $event): ?float
    {
        // Try to get request start time from Swoole request
        if (isset($event-&gt;request-&gt;server[&apos;request_time_float&apos;])) {
            return (float)$event-&gt;request-&gt;server[&apos;request_time_float&apos;];
        }
        // Try to get from $_SERVER global
        if (isset($_SERVER[&apos;REQUEST_TIME_FLOAT&apos;])) {
            return (float)$_SERVER[&apos;REQUEST_TIME_FLOAT&apos;];
        }
        // Try to get from Octane-specific attributes
        if ($event-&gt;request-&gt;attributes-&gt;has(&apos;octane_request_time&apos;)) {
            return (float)$event-&gt;request-&gt;attributes-&gt;get(&apos;octane_request_time&apos;);
        }
        // If we can&apos;t determine the start time, return null
        return null;
    }
    /**
     * Format microtime for human-readable output
     */
    private function formatMicrotime(float $microtime): string
    {
        return date(&apos;Y-m-d H:i:s&apos;, (int)$microtime) . 
               &apos;.&apos; . 
               substr(number_format($microtime - floor($microtime), 6, &apos;.&apos;, &apos;&apos;), 2);
    }
    /**
     * Get Swoole worker ID (proper implementation for standard Swoole)
     */
    private function getSwooleWorkerId(): int
    {
        // In standard Swoole with Laravel Octane, worker ID is available via environment
        if (isset($_ENV[&apos;OCTANE_WORKER_ID&apos;])) {
            return (int)$_ENV[&apos;OCTANE_WORKER_ID&apos;];
        }
        // Try to get from server globals set by Octane
        if (isset($_SERVER[&apos;OCTANE_WORKER_ID&apos;])) {
            return (int)$_SERVER[&apos;OCTANE_WORKER_ID&apos;];
        }
        // Try to access through Swoole server context if available
        try {
            if (class_exists(&apos;\Swoole\Server&apos;) &amp;&amp; method_exists(&apos;\Swoole\Server&apos;, &apos;getWorkerId&apos;)) {
                return \Swoole\Server::getWorkerId();
            }
        } catch (Throwable $e) {
            // Ignore failures
        }
        // Use process ID as fallback identifier
        return getmypid() % 1000;
    }
    /**
     * Get worker memory usage
     */
    private function getWorkerMemoryUsage(): array
    {
        return [
            &apos;current_mb&apos; =&gt; round(memory_get_usage(true) / 1024 / 1024, 2),
            &apos;peak_mb&apos;    =&gt; round(memory_get_peak_usage(true) / 1024 / 1024, 2),
        ];
    }
    /**
     * Check if coroutine support is available
     */
    private function hasCoroutineSupport(): bool
    {
        return class_exists(&apos;\Swoole\Coroutine&apos;) &amp;&amp;
            method_exists(&apos;\Swoole\Coroutine&apos;, &apos;getCid&apos;);
    }
    /**
     * Get coroutine information
     */
    private function getCoroutineInfo(): array
    {
        if (!$this-&gt;hasCoroutineSupport()) {
            return [];
        }
        try {
            $cid = \Swoole\Coroutine::getCid();
            if ($cid === -1) {
                return [&apos;status&apos; =&gt; &apos;not_in_coroutine&apos;];
            }
            return [
                &apos;id&apos;     =&gt; $cid,
                &apos;exists&apos; =&gt; \Swoole\Coroutine::exists($cid),
            ];
        } catch (Throwable $e) {
            return [&apos;error&apos; =&gt; $e-&gt;getMessage()];
        }
    }
    /**
     * Get Swoole worker type
     */
    private function getSwooleWorkerType(): string
    {
        // Check if this is a task worker via environment
        if (isset($_ENV[&apos;OCTANE_WORKER_TYPE&apos;])) {
            return $_ENV[&apos;OCTANE_WORKER_TYPE&apos;];
        }
        if (isset($_SERVER[&apos;OCTANE_WORKER_TYPE&apos;])) {
            return $_SERVER[&apos;OCTANE_WORKER_TYPE&apos;];
        }
        // Default to request worker
        return &apos;request&apos;;
    }
    /**
     * Add detailed request context
     */
    private function addRequestContext(OctaneApmManager $manager, RequestReceived $event, array $baseContext): void
    {
        try {
            $request = $event-&gt;request;
            $routeInfo = $this-&gt;getRouteInfoFromRequest($request);
            $context = array_merge($baseContext, [
                &apos;route&apos;   =&gt; [
                    &apos;pattern&apos;    =&gt; $routeInfo[&apos;pattern&apos;],
                    &apos;name&apos;       =&gt; $routeInfo[&apos;name&apos;],
                    &apos;action&apos;     =&gt; $routeInfo[&apos;action&apos;],
                    &apos;parameters&apos; =&gt; $routeInfo[&apos;parameters&apos;] ?? [],
                ],
                &apos;headers&apos; =&gt; $this-&gt;getFilteredHeaders($request),
            ]);
            $manager-&gt;addCustomContext($context);
        } catch (Throwable $e) {
            $this-&gt;logger?-&gt;warning(&apos;Failed to add detailed request context&apos;, [
                &apos;exception&apos; =&gt; $e-&gt;getMessage(),
            ]);
        }
    }
    /**
     * Get filtered request headers
     */
    private function getFilteredHeaders(Request $request): array
    {
        try {
            $headers = $request-&gt;headers-&gt;all();
            // Remove sensitive headers
            $sensitiveHeaders = [
                &apos;authorization&apos;,
                &apos;cookie&apos;,
                &apos;x-api-key&apos;,
                &apos;x-auth-token&apos;,
                &apos;x-csrf-token&apos;,
            ];
            foreach ($sensitiveHeaders as $header) {
                unset($headers[strtolower($header)]);
            }
            // Limit header values length
            return array_map(function ($value) {
                if (is_array($value)) {
                    $value = implode(&apos;, &apos;, $value);
                }
                return is_string($value) &amp;&amp; strlen($value) &gt; 200
                    ? substr($value, 0, 200) . &apos;...&apos;
                    : $value;
            }, $headers);
        } catch (Throwable $e) {
            $this-&gt;logger?-&gt;debug(&apos;Failed to filter headers&apos;, [
                &apos;exception&apos; =&gt; $e-&gt;getMessage(),
            ]);
            return [];
        }
    }
}</file><file path="app/Modules/Apm/Listeners/RequestWorkerStartHandler.php">&lt;?php
namespace App\Modules\Apm\Listeners;
use Elastic\Apm\ElasticApm;
use Laravel\Octane\Events\WorkerStarting;
use Psr\Log\LoggerInterface;
class RequestWorkerStartHandler
{
    public function __construct(
        private ?LoggerInterface $logger = null,
    )
    {
    }
    /**
     * Handle the event.
     */
    public function handle(WorkerStarting $event): void
    {
        if (!class_exists(ElasticApm::class)) {
            $this-&gt;logger?-&gt;warning(&apos;ElasticApm class not found, skipping APM worker initialization&apos;);
            return;
        }
        $this-&gt;seedRandomNumberGenerator();
        $this-&gt;cleanupAnyExistingTransaction();
        $this-&gt;logSwooleWorkerStart($event);
    }
    /**
     * Seed random number generator for Swoole workers
     */
    private function seedRandomNumberGenerator(): void
    {
        try {
            // In Swoole, workers share the same parent process, so we need unique seeds
            $workerId = $this-&gt;getSwooleWorkerId();
            $seed = random_int(PHP_INT_MIN, PHP_INT_MAX) + $workerId;
            mt_srand($seed);
            $this-&gt;logger?-&gt;debug(&apos;Successfully seeded mt_rand for Swoole worker&apos;, [
                &apos;seed&apos;       =&gt; $seed,
                &apos;process_id&apos; =&gt; getmypid(),
            ]);
        } catch (\Exception $e) {
            $workerId = $this-&gt;getSwooleWorkerId();
            $fallbackSeed = (int)(microtime(true) * 1000000) + getmypid() + $workerId;
            mt_srand($fallbackSeed);
            $this-&gt;logger?-&gt;warning(&apos;Failed to seed mt_rand with random_int, using microtime fallback&apos;, [
                &apos;exception&apos;     =&gt; $e-&gt;getMessage(),
                &apos;fallback_seed&apos; =&gt; $fallbackSeed,
                &apos;worker_id&apos;     =&gt; $workerId,
            ]);
        }
    }
    /**
     * Get Swoole worker ID
     */
    private function getSwooleWorkerId(): int
    {
        return getmypid();
    }
    /**
     * Clean up any existing transaction
     */
    private function cleanupAnyExistingTransaction(): void
    {
        try {
            $transaction = ElasticApm::getCurrentTransaction();
            if (!$transaction-&gt;hasEnded()) {
                $transaction-&gt;setName(&apos;SwooleWorkerStart&apos;);
                $transaction-&gt;setResult(&apos;success&apos;);
                $transaction-&gt;setOutcome(&apos;success&apos;);
                $transaction-&gt;end();
                $this-&gt;logger?-&gt;debug(&apos;Cleaned up existing transaction during Swoole worker start&apos;);
            }
        } catch (\Throwable $e) {
            $this-&gt;logger?-&gt;error(&apos;Failed to cleanup existing transaction during Swoole worker start&apos;, [
                &apos;exception&apos; =&gt; $e-&gt;getMessage(),
                &apos;worker_id&apos; =&gt; $this-&gt;getSwooleWorkerId(),
            ]);
        }
    }
    /**
     * Log Swoole worker start information
     */
    private function logSwooleWorkerStart($event): void
    {
        $workerInfo = [
            &apos;process_id&apos;         =&gt; getmypid(),
            &apos;worker_type&apos;        =&gt; $this-&gt;getSwooleWorkerType(),
            &apos;memory_limit&apos;       =&gt; ini_get(&apos;memory_limit&apos;),
            &apos;max_execution_time&apos; =&gt; ini_get(&apos;max_execution_time&apos;),
            &apos;swoole_version&apos;     =&gt; phpversion(&apos;swoole&apos;),
        ];
        // Add Swoole server information if available
        if ($this-&gt;hasSwooleServerInfo()) {
            $workerInfo[&apos;swoole_stats&apos;] = $this-&gt;getSwooleServerStats();
        }
        $this-&gt;logger?-&gt;info(&apos;APM Swoole worker started&apos;, $workerInfo);
    }
    /**
     * Determine Swoole worker type
     */
    private function getSwooleWorkerType(): string
    {
        // Check if this is a task worker
        if (defined(&apos;SWOOLE_TASK_WORKER&apos;) &amp;&amp; constant(&apos;SWOOLE_TASK_WORKER&apos;)) {
            return &apos;task&apos;;
        }
        return &apos;request&apos;;
    }
    /**
     * Check if Swoole server stats are available
     */
    private function hasSwooleServerInfo(): bool
    {
        return function_exists(&apos;swoole_get_vm_status&apos;) ||
            (extension_loaded(&apos;swoole&apos;) &amp;&amp; class_exists(&apos;\Swoole\Server&apos;));
    }
    /**
     * Get Swoole server statistics
     */
    private function getSwooleServerStats(): array
    {
        $stats = [];
        try {
            if (function_exists(&apos;swoole_get_vm_status&apos;)) {
                $stats[&apos;vm_status&apos;] = swoole_get_vm_status();
            }
        } catch (\Throwable $e) {
            $this-&gt;logger?-&gt;debug(&apos;Failed to get Swoole VM status&apos;, [
                &apos;exception&apos; =&gt; $e-&gt;getMessage(),
            ]);
        }
        return $stats;
    }
}</file><file path="app/Modules/Apm/Listeners/TaskReceivedHandler.php">&lt;?php
namespace App\Modules\Apm\Listeners;
use App\Modules\Apm\OctaneApmManager;
use Laravel\Octane\Events\TaskReceived;
use Psr\Log\LoggerInterface;
class TaskReceivedHandler
{
    public function __construct(
        private ?LoggerInterface $logger = null,
    )
    {
    }
    /**
     * Handle the event.
     */
    public function handle(TaskReceived $event): void
    {
        /** @var OctaneApmManager $manager */
        $manager = $event-&gt;app-&gt;make(OctaneApmManager::class);
        $taskName = $this-&gt;getTaskName($event);
        $context = $this-&gt;buildTaskContext($event);
        $transaction = $manager-&gt;beginTransaction($taskName, &apos;task&apos;, $context);
        if ($transaction) {
            $this-&gt;addTaskTags($manager, $event);
            $manager-&gt;addCustomContext($context);
        }
    }
    /**
     * Get task name from the event
     */
    private function getTaskName(TaskReceived $event): string
    {
        // Try to extract task name from task data
        if (isset($event-&gt;task) &amp;&amp; is_object($event-&gt;task)) {
            $className = get_class($event-&gt;task);
            return &apos;Task &apos; . class_basename($className);
        }
        if (isset($event-&gt;task) &amp;&amp; is_array($event-&gt;task) &amp;&amp; isset($event-&gt;task[&apos;name&apos;])) {
            return &apos;Task &apos; . $event-&gt;task[&apos;name&apos;];
        }
        return &apos;Task&apos;;
    }
    /**
     * Build task context
     */
    private function buildTaskContext(TaskReceived $event): array
    {
        $context = [
            &apos;task&apos; =&gt; [
                &apos;type&apos;      =&gt; &apos;octane_task&apos;,
                &apos;worker_id&apos; =&gt; getmypid(),
            ],
        ];
        // Add task-specific information if available
        if (isset($event-&gt;task)) {
            if (is_object($event-&gt;task)) {
                $context[&apos;task&apos;][&apos;class&apos;] = get_class($event-&gt;task);
            } else if (is_array($event-&gt;task)) {
                $context[&apos;task&apos;][&apos;data&apos;] = $this-&gt;sanitizeTaskData($event-&gt;task);
            }
        }
        return $context;
    }
    /**
     * Sanitize task data to remove sensitive information
     */
    private function sanitizeTaskData(array $data): array
    {
        $sensitiveKeys = [&apos;password&apos;, &apos;token&apos;, &apos;secret&apos;, &apos;key&apos;, &apos;auth&apos;];
        foreach ($data as $key =&gt; $value) {
            $lowerKey = strtolower($key);
            foreach ($sensitiveKeys as $sensitiveKey) {
                if (str_contains($lowerKey, $sensitiveKey)) {
                    $data[$key] = &apos;[REDACTED]&apos;;
                    break;
                }
            }
            if (is_array($value)) {
                $data[$key] = $this-&gt;sanitizeTaskData($value);
            }
        }
        return $data;
    }
    /**
     * Add task-specific tags
     */
    private function addTaskTags(OctaneApmManager $manager, TaskReceived $event): void
    {
        $manager-&gt;addCustomTag(&apos;task.worker_id&apos;, getmypid());
        if (isset($event-&gt;task) &amp;&amp; is_object($event-&gt;task)) {
            $manager-&gt;addCustomTag(&apos;task.class&apos;, get_class($event-&gt;task));
        }
    }
}</file><file path="app/Modules/Apm/Listeners/TickReceivedHandler.php">&lt;?php
namespace App\Modules\Apm\Listeners;
use App\Modules\Apm\OctaneApmManager;
use Laravel\Octane\Events\TickReceived;
class TickReceivedHandler
{
    /**
     * Handle the event.
     *
     * @param TickReceived $event
     *
     * @return void
     */
    public function handle(TickReceived $event): void
    {
        /** @var OctaneApmManager $manager */
        $manager = $event-&gt;app-&gt;make(OctaneApmManager::class);
        $manager-&gt;beginTransaction(&apos;Tick&apos;, &apos;tick&apos;);
    }
}</file><file path="app/Modules/Apm/Middleware/ApmMiddleware.php">&lt;?php
namespace App\Modules\Apm\Middleware;
use App\Modules\Apm\OctaneApmManager;
use Closure;
use Illuminate\Http\Request;
use Illuminate\Support\Facades\Auth;
use Psr\Log\LoggerInterface;
use Throwable;
class ApmMiddleware
{
    public function __construct(
        private OctaneApmManager $apmManager,
        private ?LoggerInterface $logger = null,
    )
    {
    }
    /**
     * Handle an incoming request.
     */
    public function handle(Request $request, Closure $next)
    {
        $this-&gt;addUserContext($request);
        $this-&gt;addRequestTags($request);
        $this-&gt;addCustomContext($request);
        $response = $next($request);
        $this-&gt;addResponseTags($response);
        $this-&gt;addResponseContext($response);
        return $response;
    }
    /**
     * Add user context if authenticated
     */
    private function addUserContext(Request $request): void
    {
        try {
            if (Auth::check()) {
                $user = Auth::user();
                $this-&gt;apmManager-&gt;addCustomContext([
                    &apos;user&apos; =&gt; [
                        &apos;id&apos;            =&gt; $user-&gt;id,
                        &apos;email&apos;         =&gt; $user-&gt;email ?? null,
                        &apos;authenticated&apos; =&gt; true,
                    ],
                ]);
            } else {
                $this-&gt;apmManager-&gt;addCustomTag(&apos;user.authenticated&apos;, &apos;false&apos;);
            }
        } catch (Throwable $e) {
            $this-&gt;logger?-&gt;warning(&apos;Failed to add user context to APM&apos;, [
                &apos;exception&apos; =&gt; $e-&gt;getMessage(),
            ]);
        }
    }
    /**
     * Add custom request context
     */
    private function addCustomContext(Request $request): void
    {
        try {
            $context = [
                &apos;request_details&apos; =&gt; [
                    &apos;content_type&apos;   =&gt; $request-&gt;header(&apos;Content-Type&apos;),
                    &apos;accept&apos;         =&gt; $request-&gt;header(&apos;Accept&apos;),
                    &apos;content_length&apos; =&gt; $request-&gt;header(&apos;Content-Length&apos;),
                ],
            ];
            // Add session information if available
            if ($request-&gt;hasSession()) {
                $context[&apos;session&apos;] = [
                    &apos;id&apos;      =&gt; $request-&gt;session()-&gt;getId(),
                    &apos;started&apos; =&gt; $request-&gt;session()-&gt;isStarted(),
                ];
            }
            // Add request size information
            if ($request-&gt;getContent()) {
                $context[&apos;request_details&apos;][&apos;body_size&apos;] = strlen($request-&gt;getContent());
            }
            $this-&gt;apmManager-&gt;addCustomContext($context);
        } catch (Throwable $e) {
            $this-&gt;logger?-&gt;warning(&apos;Failed to add custom context to APM&apos;, [
                &apos;exception&apos; =&gt; $e-&gt;getMessage(),
            ]);
        }
    }
    /**
     * Add request-specific tags
     */
    private function addRequestTags(Request $request): void
    {
        try {
            $this-&gt;apmManager-&gt;addCustomTag(&apos;request.method&apos;, $request-&gt;method());
            $this-&gt;apmManager-&gt;addCustomTag(&apos;request.secure&apos;, $request-&gt;secure() ? &apos;true&apos; : &apos;false&apos;);
            if ($request-&gt;route()) {
                $routeName = $request-&gt;route()-&gt;getName();
                if ($routeName) {
                    $this-&gt;apmManager-&gt;addCustomTag(&apos;request.route_name&apos;, $routeName);
                }
            }
            if ($request-&gt;hasHeader(&apos;X-Requested-With&apos;)) {
                $this-&gt;apmManager-&gt;addCustomTag(&apos;request.ajax&apos;, &apos;true&apos;);
            }
            if ($request-&gt;hasHeader(&apos;User-Agent&apos;)) {
                $userAgent = $request-&gt;userAgent();
                $this-&gt;apmManager-&gt;addCustomTag(&apos;request.user_agent.type&apos;, $this-&gt;getUserAgentType($userAgent));
            }
        } catch (Throwable $e) {
            $this-&gt;logger?-&gt;warning(&apos;Failed to add request tags to APM&apos;, [
                &apos;exception&apos; =&gt; $e-&gt;getMessage(),
            ]);
        }
    }
    /**
     * Determine a user agent type
     */
    private function getUserAgentType(?string $userAgent): string
    {
        if (!$userAgent) {
            return &apos;unknown&apos;;
        }
        $userAgent = strtolower($userAgent);
        if (str_contains($userAgent, &apos;bot&apos;) || str_contains($userAgent, &apos;crawler&apos;)) {
            return &apos;bot&apos;;
        }
        if (str_contains($userAgent, &apos;mobile&apos;)) {
            return &apos;mobile&apos;;
        }
        if (str_contains($userAgent, &apos;tablet&apos;)) {
            return &apos;tablet&apos;;
        }
        return &apos;desktop&apos;;
    }
    /**
     * Add response tags
     */
    private function addResponseTags($response): void
    {
        try {
            if (method_exists($response, &apos;getStatusCode&apos;)) {
                $statusCode = $response-&gt;getStatusCode();
                $this-&gt;apmManager-&gt;addCustomTag(&apos;response.status_code&apos;, (string)$statusCode);
                $this-&gt;apmManager-&gt;addCustomTag(&apos;response.status_class&apos;, $this-&gt;getStatusClass($statusCode));
            }
        } catch (Throwable $e) {
            $this-&gt;logger?-&gt;warning(&apos;Failed to add response tags to APM&apos;, [
                &apos;exception&apos; =&gt; $e-&gt;getMessage(),
            ]);
        }
    }
    /**
     * Get status class from status code
     */
    private function getStatusClass(int $statusCode): string
    {
        return match (true) {
            $statusCode &gt;= 200 &amp;&amp; $statusCode &lt; 300 =&gt; &apos;2xx&apos;,
            $statusCode &gt;= 300 &amp;&amp; $statusCode &lt; 400 =&gt; &apos;3xx&apos;,
            $statusCode &gt;= 400 &amp;&amp; $statusCode &lt; 500 =&gt; &apos;4xx&apos;,
            $statusCode &gt;= 500 =&gt; &apos;5xx&apos;,
            default =&gt; &apos;unknown&apos;
        };
    }
    /**
     * Add response context
     */
    private function addResponseContext($response): void
    {
        try {
            if (method_exists($response, &apos;getStatusCode&apos;) &amp;&amp; method_exists($response, &apos;headers&apos;)) {
                $context = [
                    &apos;response_details&apos; =&gt; [
                        &apos;content_type&apos;  =&gt; $response-&gt;headers-&gt;get(&apos;Content-Type&apos;),
                        &apos;cache_control&apos; =&gt; $response-&gt;headers-&gt;get(&apos;Cache-Control&apos;),
                    ],
                ];
                if (method_exists($response, &apos;getContent&apos;)) {
                    $content = $response-&gt;getContent();
                    $context[&apos;response_details&apos;][&apos;content_length&apos;] = strlen($content);
                }
                $this-&gt;apmManager-&gt;addCustomContext($context);
            }
        } catch (Throwable $e) {
            $this-&gt;logger?-&gt;warning(&apos;Failed to add response context to APM&apos;, [
                &apos;exception&apos; =&gt; $e-&gt;getMessage(),
            ]);
        }
    }
}</file><file path="app/Modules/Apm/Middleware/SwooleMetricsSampler.php">&lt;?php
namespace App\Modules\Apm\Middleware;
use App\Modules\Apm\Services\SwooleMetricsService;
use Closure;
use Illuminate\Http\Request;
use Symfony\Component\HttpFoundation\Response;
class SwooleMetricsSampler
{
    // Remove constructor dependency injection to avoid holding service instance
    public function handle(Request $request, Closure $next): Response
    {
        $response = $next($request);
        // Only collect metrics on a sample of requests to avoid overhead
        if ($this-&gt;shouldCollectMetrics($request)) {
            try {
                // Create fresh service instance for each collection
                $metricsService = app(SwooleMetricsService::class);
                $metricsService-&gt;collectOnce();
            } catch (\Throwable $e) {
                // Log error but don&apos;t fail the request
                logger()-&gt;debug(&apos;Failed to collect Swoole metrics in middleware&apos;, [
                    &apos;exception&apos; =&gt; $e-&gt;getMessage(),
                ]);
            }
        }
        return $response;
    }
    /**
     * Determine if we should collect metrics for this request
     */
    private function shouldCollectMetrics(Request $request): bool
    {
        // Don&apos;t collect on health checks or static assets
        if ($this-&gt;isIgnoredRoute($request)) {
            return false;
        }
        // Collect metrics on a configurable percentage of requests
        $sampleRate = config(&apos;apm.swoole_metrics.sample_rate&apos;, 0.01); // 1% by default
        return mt_rand(1, 10000) &lt;= ($sampleRate * 10000);
    }
    /**
     * Check if this is a route we should ignore
     */
    private function isIgnoredRoute(Request $request): bool
    {
        $ignoredPatterns = [
            &apos;/health&apos;,
            &apos;/ping&apos;,
            &apos;/status&apos;,
            &apos;/metrics&apos;,
            &apos;/favicon.ico&apos;,
            &apos;*.css&apos;,
            &apos;*.js&apos;,
            &apos;*.png&apos;,
            &apos;*.jpg&apos;,
            &apos;*.gif&apos;,
            &apos;*.svg&apos;,
        ];
        $path = $request-&gt;path();
        foreach ($ignoredPatterns as $pattern) {
            if (fnmatch($pattern, $path)) {
                return true;
            }
        }
        return false;
    }
}</file><file path="app/Modules/Apm/OctaneApmManager.php">&lt;?php
namespace App\Modules\Apm;
use BadMethodCallException;
use Elastic\Apm\ElasticApm;
use Elastic\Apm\ExecutionSegmentInterface;
use Elastic\Apm\SpanInterface;
use Elastic\Apm\TransactionInterface;
use InvalidArgumentException;
use Psr\Log\LoggerInterface;
use Throwable;
class OctaneApmManager
{
    /**
     * Dictates if APM is disabled
     */
    private bool $disabled;
    /**
     * Dictates if the current transaction is being sampled
     */
    private bool $sampled;
    /**
     * The main outer transaction wrapping all child spans
     */
    private ?TransactionInterface $transaction = null;
    /**
     * Holds all stored spans indexed by their name
     */
    private array $spans = [];
    /**
     * APM configuration
     */
    private array $config;
    /**
     * Logger instance
     */
    private ?LoggerInterface $logger;
    /**
     * Custom context data
     */
    private array $customContext = [];
    /**
     * Transaction start time for performance tracking
     */
    private ?float $transactionStartTime = null;
    /**
     * Transaction metadata
     */
    private array $transactionMetadata = [];
    /**
     * Maximum number of spans per transaction
     */
    private int $maxSpans;
    /**
     * Current span count
     */
    private int $spanCount = 0;
    /**
     * Constructor
     */
    public function __construct(?LoggerInterface $logger = null, array $config = [])
    {
        $this-&gt;disabled = !class_exists(ElasticApm::class);
        $this-&gt;logger = $logger;
        $this-&gt;config = array_merge($this-&gt;getDefaultConfig(), $config);
        $this-&gt;sampled = $this-&gt;shouldSample();
        $this-&gt;maxSpans = $this-&gt;config[&apos;transaction&apos;][&apos;max_spans&apos;] ?? 500;
    }
    /**
     * Get default configuration
     */
    private function getDefaultConfig(): array
    {
        return [
            &apos;enabled&apos;         =&gt; true,
            &apos;sampling_rate&apos;   =&gt; 1.0,
            &apos;service_name&apos;    =&gt; &apos;baander&apos;,
            &apos;service_version&apos; =&gt; &apos;1.0.0&apos;,
            &apos;environment&apos;     =&gt; &apos;unknown&apos;,
            &apos;transaction&apos;     =&gt; [
                &apos;max_spans&apos;         =&gt; 500,
                &apos;stack_trace_limit&apos; =&gt; 50,
            ],
            &apos;context&apos;         =&gt; [
                &apos;sanitize_field_names&apos; =&gt; [&apos;password&apos;, &apos;token&apos;, &apos;secret&apos;, &apos;key&apos;, &apos;auth&apos;, &apos;authorization&apos;],
            ],
            &apos;ignore_patterns&apos; =&gt; [
                &apos;routes&apos;      =&gt; [],
                &apos;user_agents&apos; =&gt; [],
            ],
            &apos;monitoring&apos;      =&gt; [
                &apos;database&apos;    =&gt; true,
                &apos;cache&apos;       =&gt; true,
                &apos;http_client&apos; =&gt; true,
            ],
        ];
    }
    /**
     * Check if sampling should occur
     */
    private function shouldSample(): bool
    {
        if ($this-&gt;disabled) {
            return false;
        }
        $samplingRate = $this-&gt;config[&apos;sampling_rate&apos;] ?? 1.0;
        // Ensure the sampling rate is between 0 and 1
        $samplingRate = max(0.0, min(1.0, (float)$samplingRate));
        return mt_rand(1, 10000) / 10000 &lt;= $samplingRate;
    }
    /**
     * Begins a new transaction
     */
    public function beginTransaction(string $name, string $type, array $context = []): ?TransactionInterface
    {
        if (!$this-&gt;isEnabled()) {
            return null;
        }
        if ($this-&gt;shouldIgnoreTransaction($name, $context)) {
            return null;
        }
        try {
            $this-&gt;prepareForNextTransaction();
            $this-&gt;transactionStartTime = microtime(true);
            $this-&gt;transaction = ElasticApm::beginCurrentTransaction($name, $type);
            $this-&gt;setTransactionLimits();
            $this-&gt;addCustomContext($context);
            // Store transaction metadata
            $this-&gt;transactionMetadata = [
                &apos;name&apos;       =&gt; $name,
                &apos;type&apos;       =&gt; $type,
                &apos;started_at&apos; =&gt; $this-&gt;transactionStartTime,
            ];
            $this-&gt;spanCount = 0;
            return $this-&gt;transaction;
        } catch (Throwable $e) {
            $this-&gt;logError(&apos;Failed to begin transaction&apos;, $e, compact(&apos;name&apos;, &apos;type&apos;));
            return null;
        }
    }
    /**
     * Check if APM is available and enabled
     */
    public function isEnabled(): bool
    {
        return !$this-&gt;disabled &amp;&amp; $this-&gt;sampled &amp;&amp; ($this-&gt;config[&apos;enabled&apos;] ?? true);
    }
    /**
     * Check if a transaction should be ignored based on patterns
     */
    public function shouldIgnoreTransaction(string $transactionName, array $context = []): bool
    {
        if (!$this-&gt;config[&apos;enabled&apos;] ?? true) {
            return true;
        }
        // Check route patterns
        $ignoreRoutes = $this-&gt;config[&apos;ignore_patterns&apos;][&apos;routes&apos;] ?? [];
        if (array_any($ignoreRoutes, fn($pattern) =&gt; fnmatch($pattern, $transactionName))) {
            return true;
        }
        // Check user agent patterns
        $userAgent = $context[&apos;request&apos;][&apos;user_agent&apos;] ?? &apos;&apos;;
        if ($userAgent) {
            $ignoreUserAgents = $this-&gt;config[&apos;ignore_patterns&apos;][&apos;user_agents&apos;] ?? [];
            if (array_any($ignoreUserAgents, fn($pattern) =&gt; fnmatch($pattern, $userAgent))) {
                return true;
            }
        }
        // Check if transaction is health check or monitoring
        $healthCheckPatterns = [&apos;*/health&apos;, &apos;*/ping&apos;, &apos;*/status&apos;, &apos;*/metrics&apos;];
        return array_any($healthCheckPatterns, fn($pattern) =&gt; fnmatch($pattern, $transactionName));
    }
    /**
     * Prepares the manager and APM for the next request
     */
    private function prepareForNextTransaction(): void
    {
        $this-&gt;discardActiveSegments();
        $this-&gt;resetManager();
    }
    /**
     * Discards all currently active APM segments
     */
    private function discardActiveSegments(): void
    {
        try {
            // Discard current segments safely
            $currentTransaction = ElasticApm::getCurrentTransaction();
            if (!$currentTransaction-&gt;hasEnded()) {
                $this-&gt;discardSegment($currentTransaction);
            }
            $currentSegment = ElasticApm::getCurrentExecutionSegment();
            if (!$currentSegment-&gt;hasEnded()) {
                $this-&gt;discardSegment($currentSegment);
            }
            if ($this-&gt;transaction &amp;&amp; !$this-&gt;transaction-&gt;hasEnded()) {
                $this-&gt;discardSegment($this-&gt;transaction);
            }
            foreach ($this-&gt;spans as $span) {
                if (!$span-&gt;hasEnded()) {
                    $this-&gt;discardSegment($span);
                }
            }
        } catch (Throwable $e) {
            $this-&gt;logError(&apos;Failed to discard active segments&apos;, $e);
        }
    }
    /**
     * Discards the given execution segment
     */
    private function discardSegment(?ExecutionSegmentInterface $segment): void
    {
        if (!$segment || $segment-&gt;hasEnded()) {
            return;
        }
        try {
            $segment-&gt;discard();
        } catch (Throwable $e) {
            $this-&gt;logError(&apos;Failed to discard segment&apos;, $e);
        }
    }
    /**
     * Log an error with context
     */
    private function logError(string $message, Throwable $e, array $context = []): void
    {
        $this-&gt;logger?-&gt;error($message, [
            &apos;exception&apos; =&gt; $e-&gt;getMessage(),
            &apos;file&apos;      =&gt; $e-&gt;getFile(),
            &apos;line&apos;      =&gt; $e-&gt;getLine(),
            &apos;context&apos;   =&gt; $context,
            &apos;apm_state&apos; =&gt; $this-&gt;getTransactionStats(),
        ]);
    }
    /**
     * Get transaction statistics
     */
    public function getTransactionStats(): array
    {
        return [
            &apos;has_transaction&apos;      =&gt; !$this-&gt;hasNoTransactionInstance(),
            &apos;span_count&apos;           =&gt; $this-&gt;spanCount,
            &apos;max_spans&apos;            =&gt; $this-&gt;maxSpans,
            &apos;stored_spans&apos;         =&gt; count($this-&gt;spans),
            &apos;transaction_metadata&apos; =&gt; $this-&gt;transactionMetadata,
            &apos;custom_context_keys&apos;  =&gt; array_keys($this-&gt;customContext),
            &apos;sampled&apos;              =&gt; $this-&gt;sampled,
            &apos;enabled&apos;              =&gt; $this-&gt;isEnabled(),
        ];
    }
    /**
     * Returns true if there exists a transaction instance within the manager
     */
    public function hasNoTransactionInstance(): bool
    {
        return !$this-&gt;isEnabled() || !$this-&gt;transaction;
    }
    /**
     * Resets the manager state
     */
    private function resetManager(): void
    {
        $this-&gt;transaction = null;
        $this-&gt;transactionStartTime = null;
        $this-&gt;spans = [];
        $this-&gt;customContext = [];
        $this-&gt;transactionMetadata = [];
        $this-&gt;spanCount = 0;
    }
    /**
     * Set transaction limits from configuration
     */
    private function setTransactionLimits(): void
    {
        if (!$this-&gt;transaction) {
            return;
        }
        try {
            // Note: setMaxNumberOfSpans and setStackTraceLimit don&apos;t exist on transactions
            // These would typically be configured at the agent level via configuration
            // We can add them as labels for monitoring purposes
            if (isset($this-&gt;config[&apos;transaction&apos;][&apos;max_spans&apos;])) {
                $this-&gt;transaction-&gt;context()-&gt;setLabel(&apos;config.max_spans&apos;, (string)$this-&gt;config[&apos;transaction&apos;][&apos;max_spans&apos;]);
            }
            if (isset($this-&gt;config[&apos;transaction&apos;][&apos;stack_trace_limit&apos;])) {
                $this-&gt;transaction-&gt;context()-&gt;setLabel(&apos;config.stack_trace_limit&apos;, (string)$this-&gt;config[&apos;transaction&apos;][&apos;stack_trace_limit&apos;]);
            }
        } catch (Throwable $e) {
            $this-&gt;logError(&apos;Failed to set transaction limits&apos;, $e);
        }
    }
    /**
     * Add custom context to the current transaction
     */
    public function addCustomContext(array $context): void
    {
        $this-&gt;customContext = array_merge_recursive($this-&gt;customContext, $context);
        if (!$this-&gt;isEnabled() || !$this-&gt;transaction) {
            return;
        }
        try {
            $sanitizedContext = $this-&gt;sanitizeContext($context);
            // Use labels for custom data since setCustomContext/setUserContext don&apos;t exist
            foreach ($sanitizedContext as $key =&gt; $value) {
                if (is_array($value)) {
                    // Flatten arrays into labels with dot notation
                    $this-&gt;setNestedTransactionLabels($key, $value);
                } else {
                    $this-&gt;transaction-&gt;context()-&gt;setLabel($key, $this-&gt;sanitizeTagValue($value));
                }
            }
        } catch (Throwable $e) {
            $this-&gt;logError(&apos;Failed to add custom context&apos;, $e, [&apos;context_keys&apos; =&gt; array_keys($context)]);
        }
    }
    /**
     * Sanitize context data to remove sensitive information
     */
    private function sanitizeContext(array $context): array
    {
        $sanitizeFields = $this-&gt;config[&apos;context&apos;][&apos;sanitize_field_names&apos;] ?? [];
        $maxDepth = 10; // Prevent infinite recursion
        return $this-&gt;recursiveSanitize($context, $sanitizeFields, 0, $maxDepth);
    }
    /**
     * Recursively sanitize an array
     */
    private function recursiveSanitize(array $data, array $sensitiveFields, int $depth, int $maxDepth): array
    {
        if ($depth &gt;= $maxDepth) {
            return [&apos;[MAX_DEPTH_REACHED]&apos;];
        }
        foreach ($data as $key =&gt; $value) {
            $lowerKey = strtolower((string)$key);
            // Check if a key contains sensitive information
            $isSensitive = false;
            foreach ($sensitiveFields as $sensitiveField) {
                if (str_contains($lowerKey, strtolower($sensitiveField))) {
                    $isSensitive = true;
                    break;
                }
            }
            if ($isSensitive) {
                $data[$key] = &apos;[REDACTED]&apos;;
            } else if (is_array($value)) {
                $data[$key] = $this-&gt;recursiveSanitize($value, $sensitiveFields, $depth + 1, $maxDepth);
            } else if (is_object($value)) {
                $data[$key] = &apos;[OBJECT:&apos; . get_class($value) . &apos;]&apos;;
            } else if (is_resource($value)) {
                $data[$key] = &apos;[RESOURCE:&apos; . get_resource_type($value) . &apos;]&apos;;
            } else if (is_string($value) &amp;&amp; strlen($value) &gt; 10000) {
                // Truncate very long strings
                $data[$key] = substr($value, 0, 10000) . &apos;... [TRUNCATED]&apos;;
            }
        }
        return $data;
    }
    /**
     * Set nested labels on transaction
     */
    private function setNestedTransactionLabels(string $prefix, array $data, int $depth = 0): void
    {
        if ($depth &gt; 3) { // Limit nesting depth
            return;
        }
        foreach ($data as $key =&gt; $value) {
            $labelKey = $prefix . &apos;.&apos; . $key;
            if (is_array($value)) {
                $this-&gt;setNestedTransactionLabels($labelKey, $value, $depth + 1);
            } else {
                $this-&gt;transaction-&gt;context()-&gt;setLabel($labelKey, $this-&gt;sanitizeTagValue($value));
            }
        }
    }
    /**
     * Sanitize tag value
     */
    private function sanitizeTagValue($value): string
    {
        if (is_bool($value)) {
            return $value ? &apos;true&apos; : &apos;false&apos;;
        }
        if (is_numeric($value)) {
            return (string)$value;
        }
        if (is_array($value) || is_object($value)) {
            return &apos;[COMPLEX_VALUE]&apos;;
        }
        $stringValue = (string)$value;
        // Limit tag value length
        if (strlen($stringValue) &gt; 1024) {
            return substr($stringValue, 0, 1024) . &apos;...&apos;;
        }
        return $stringValue;
    }
    /**
     * Begins a new span and stores it for later retrieval
     */
    public function beginAndStoreSpan(string $name, string $type): ?SpanInterface
    {
        if (!$this-&gt;isEnabled() || $this-&gt;hasNoTransactionInstance()) {
            return null;
        }
        if (isset($this-&gt;spans[$name])) {
            throw new InvalidArgumentException(&apos;Nested stored spans with the same name is not supported&apos;);
        }
        if ($this-&gt;spanCount &gt;= $this-&gt;maxSpans) {
            $this-&gt;logger?-&gt;warning(&apos;Maximum span limit reached, dropping span&apos;, [
                &apos;span_name&apos;     =&gt; $name,
                &apos;max_spans&apos;     =&gt; $this-&gt;maxSpans,
                &apos;current_count&apos; =&gt; $this-&gt;spanCount,
            ]);
            return null;
        }
        try {
            $span = $this-&gt;transaction-&gt;beginChildSpan($name, $type);
            $this-&gt;spans[$name] = $span;
            $this-&gt;spanCount++;
            return $span;
        } catch (Throwable $e) {
            $this-&gt;logError(&apos;Failed to begin and store span&apos;, $e, compact(&apos;name&apos;, &apos;type&apos;));
            return null;
        }
    }
    /**
     * Create a new span (not stored)
     */
    public function createSpan(string $name, string $type, ?string $subtype = null, ?string $action = null): ?SpanInterface
    {
        if (!$this-&gt;isEnabled() || $this-&gt;hasNoTransactionInstance()) {
            return null;
        }
        if ($this-&gt;spanCount &gt;= $this-&gt;maxSpans) {
            return null;
        }
        try {
            $span = $this-&gt;transaction-&gt;beginChildSpan($name, $type, $subtype, $action);
            $this-&gt;spanCount++;
            return $span;
        } catch (Throwable $e) {
            $this-&gt;logError(&apos;Failed to create span&apos;, $e, compact(&apos;name&apos;, &apos;type&apos;, &apos;subtype&apos;, &apos;action&apos;));
            return null;
        }
    }
    /**
     * Add a custom tag to the current transaction
     */
    public function addCustomTag(string $key, $value): void
    {
        if (!$this-&gt;isEnabled() || !$this-&gt;transaction) {
            return;
        }
        try {
            // Sanitize and validate the tag value
            $sanitizedValue = $this-&gt;sanitizeTagValue($value);
            // Use the correct Elastic APM method via context
            $this-&gt;transaction-&gt;context()-&gt;setLabel($key, $sanitizedValue);
        } catch (Throwable $e) {
            $this-&gt;logError(&apos;Failed to add custom tag&apos;, $e, compact(&apos;key&apos;, &apos;value&apos;));
        }
    }
    /**
     * Set context on a span
     */
    public function setSpanContext(SpanInterface $span, array $context): void
    {
        if (!$this-&gt;isEnabled()) {
            return;
        }
        try {
            $sanitizedContext = $this-&gt;sanitizeContext($context);
            // Add context as labels on the span via context
            foreach ($sanitizedContext as $key =&gt; $value) {
                if (is_array($value)) {
                    // For nested arrays, flatten them
                    $this-&gt;setNestedSpanLabels($span, $key, $value);
                } else {
                    $span-&gt;context()-&gt;setLabel($key, $this-&gt;sanitizeTagValue($value));
                }
            }
        } catch (Throwable $e) {
            $this-&gt;logError(&apos;Failed to set span context&apos;, $e, [&apos;context_keys&apos; =&gt; array_keys($context)]);
        }
    }
    /**
     * Set nested labels on span
     */
    private function setNestedSpanLabels(SpanInterface $span, string $prefix, array $data, int $depth = 0): void
    {
        if ($depth &gt; 3) { // Limit nesting depth
            return;
        }
        foreach ($data as $key =&gt; $value) {
            $labelKey = $prefix . &apos;.&apos; . $key;
            if (is_array($value)) {
                $this-&gt;setNestedSpanLabels($span, $labelKey, $value, $depth + 1);
            } else {
                $span-&gt;context()-&gt;setLabel($labelKey, $this-&gt;sanitizeTagValue($value));
            }
        }
    }
    /**
     * Add tag to span
     */
    public function addSpanTag(SpanInterface $span, string $key, $value): void
    {
        if (!$this-&gt;isEnabled()) {
            return;
        }
        try {
            $span-&gt;context()-&gt;setLabel($key, $this-&gt;sanitizeTagValue($value));
        } catch (Throwable $e) {
            $this-&gt;logError(&apos;Failed to add span tag&apos;, $e, compact(&apos;key&apos;, &apos;value&apos;));
        }
    }
    /**
     * Record an exception in the current transaction
     */
    public function recordException(Throwable $exception, array $context = []): void
    {
        if (!$this-&gt;isEnabled()) {
            return;
        }
        try {
            $currentSegment = ElasticApm::getCurrentExecutionSegment();
            if (!$currentSegment-&gt;hasEnded()) {
                // Use the correct method from the API
                $errorId = $currentSegment-&gt;createErrorFromThrowable($exception);
                // Add context as labels if the error was created
                if ($errorId &amp;&amp; !empty($context)) {
                    $sanitizedContext = $this-&gt;sanitizeContext($context);
                    foreach ($sanitizedContext as $key =&gt; $value) {
                        if (!is_array($value)) {
                            $currentSegment-&gt;context()-&gt;setLabel(&apos;error.&apos; . $key, $this-&gt;sanitizeTagValue($value));
                        }
                    }
                }
                // Add transaction metadata as labels
                if ($errorId &amp;&amp; !empty($this-&gt;transactionMetadata)) {
                    foreach ($this-&gt;transactionMetadata as $key =&gt; $value) {
                        if (!is_array($value)) {
                            $currentSegment-&gt;context()-&gt;setLabel(&apos;transaction.&apos; . $key, $this-&gt;sanitizeTagValue($value));
                        }
                    }
                }
            }
        } catch (Throwable $e) {
            $this-&gt;logError(&apos;Failed to record exception&apos;, $e, [
                &apos;original_exception&apos; =&gt; $exception-&gt;getMessage(),
            ]);
        }
    }
    /**
     * Set the result of the transaction
     */
    public function setTransactionResult(?string $result): void
    {
        if ($transaction = $this-&gt;getTransaction()) {
            try {
                $transaction-&gt;setResult($result);
            } catch (Throwable $e) {
                $this-&gt;logError(&apos;Failed to set transaction result&apos;, $e, compact(&apos;result&apos;));
            }
        }
    }
    /**
     * Returns the current transaction
     */
    public function getTransaction(): ?TransactionInterface
    {
        if (!$this-&gt;isEnabled()) {
            return null;
        }
        return $this-&gt;transaction;
    }
    /**
     * Set the outcome of the transaction
     */
    public function setTransactionOutcome(string $outcome): void
    {
        if (!$this-&gt;isEnabled() || !$this-&gt;transaction) {
            return;
        }
        try {
            $this-&gt;transaction-&gt;setOutcome($outcome);
        } catch (Throwable $e) {
            $this-&gt;logError(&apos;Failed to set transaction outcome&apos;, $e, compact(&apos;outcome&apos;));
        }
    }
    /**
     * Ends the transaction
     */
    public function endTransaction(): void
    {
        if (!$this-&gt;isEnabled()) {
            return;
        }
        if ($this-&gt;hasNoTransactionInstance()) {
            throw new BadMethodCallException(&apos;Cannot end transaction before it has been started&apos;);
        }
        try {
            // End all remaining spans
            foreach (array_keys($this-&gt;spans) as $spanKey) {
                $this-&gt;endStoredSpan($spanKey);
            }
            // Add performance metrics
            $this-&gt;addPerformanceMetrics();
            // Add final transaction metadata
            $this-&gt;addTransactionMetadata();
            $this-&gt;endSegment($this-&gt;transaction);
            $this-&gt;resetManager();
        } catch (Throwable $e) {
            $this-&gt;logError(&apos;Failed to end transaction&apos;, $e);
            $this-&gt;resetManager();
        }
    }
    /**
     * Ends a stored span
     */
    public function endStoredSpan(string $name): void
    {
        if (!$this-&gt;isEnabled()) {
            return;
        }
        if (!isset($this-&gt;spans[$name])) {
            throw new InvalidArgumentException(sprintf(&apos;No stored span with name [%s] exists&apos;, $name));
        }
        try {
            $this-&gt;endSegment($this-&gt;spans[$name]);
            unset($this-&gt;spans[$name]);
        } catch (Throwable $e) {
            $this-&gt;logError(&apos;Failed to end stored span&apos;, $e, compact(&apos;name&apos;));
        }
    }
    /**
     * Ends the given execution segment
     */
    private function endSegment(?ExecutionSegmentInterface $segment): void
    {
        if (!$segment || $segment-&gt;hasEnded()) {
            return;
        }
        try {
            $segment-&gt;end();
        } catch (Throwable $e) {
            $this-&gt;logError(&apos;Failed to end segment&apos;, $e);
        }
    }
    /**
     * Add performance metrics to the transaction
     */
    private function addPerformanceMetrics(): void
    {
        if (!$this-&gt;transaction || !$this-&gt;transactionStartTime) {
            return;
        }
        try {
            $duration = (microtime(true) - $this-&gt;transactionStartTime) * 1000; // Convert to milliseconds
            // Add performance metrics as labels
            $this-&gt;transaction-&gt;context()-&gt;setLabel(&apos;performance.duration_ms&apos;, (string)round($duration, 2));
            $this-&gt;transaction-&gt;context()-&gt;setLabel(&apos;performance.memory_peak_mb&apos;, (string)round(memory_get_peak_usage(true) / 1024 / 1024, 2));
            $this-&gt;transaction-&gt;context()-&gt;setLabel(&apos;performance.memory_current_mb&apos;, (string)round(memory_get_usage(true) / 1024 / 1024, 2));
            $this-&gt;transaction-&gt;context()-&gt;setLabel(&apos;performance.span_count&apos;, (string)$this-&gt;spanCount);
        } catch (Throwable $e) {
            $this-&gt;logError(&apos;Failed to add performance metrics&apos;, $e);
        }
    }
    /**
     * Add transaction metadata
     */
    private function addTransactionMetadata(): void
    {
        if (!$this-&gt;transaction || empty($this-&gt;transactionMetadata)) {
            return;
        }
        try {
            $this-&gt;transactionMetadata[&apos;ended_at&apos;] = microtime(true);
            $this-&gt;transactionMetadata[&apos;duration_seconds&apos;] = $this-&gt;transactionMetadata[&apos;ended_at&apos;] - $this-&gt;transactionMetadata[&apos;started_at&apos;];
            // Add metadata as labels
            foreach ($this-&gt;transactionMetadata as $key =&gt; $value) {
                if (!is_array($value)) {
                    $this-&gt;transaction-&gt;context()-&gt;setLabel(&apos;metadata.&apos; . $key, $this-&gt;sanitizeTagValue($value));
                }
            }
        } catch (Throwable $e) {
            $this-&gt;logError(&apos;Failed to add transaction metadata&apos;, $e);
        }
    }
}</file><file path="app/Modules/Apm/Services/SwooleMetricsService.php">&lt;?php
namespace App\Modules\Apm\Services;
use App\Modules\Apm\Collectors\SwooleMetricsCollector;
use Illuminate\Support\Facades\Log;
use Laravel\Octane\Facades\Octane;
use Swoole\Timer;
class SwooleMetricsService
{
    private const TIMER_KEY = &apos;swoole_metrics_timer_id&apos;;
    private const RUNNING_KEY = &apos;swoole_metrics_running&apos;;
    public function __construct(
        private int $intervalSeconds = 60,
    )
    {
    }
    /**
     * Create a new instance with a specific interval
     */
    public static function withInterval(int $intervalSeconds): self
    {
        return new self($intervalSeconds);
    }
    /**
     * Collect metrics once
     */
    public function collectOnce(): void
    {
        if (!$this-&gt;isSwooleContext()) {
            try {
                Log::warning(&apos;Attempted to collect Swoole metrics outside Swoole context&apos;);
            } catch (\Throwable) {
                error_log(&apos;Attempted to collect Swoole metrics outside Swoole context&apos;);
            }
            return;
        }
        try {
            // Always create a fresh collector instance
            $collector = app(SwooleMetricsCollector::class);
            $collector-&gt;collectMetrics();
        } catch (\Throwable $e) {
            try {
                Log::error(&apos;Failed to collect Swoole metrics&apos;, [
                    &apos;exception&apos; =&gt; $e-&gt;getMessage(),
                ]);
            } catch (\Throwable) {
                error_log(&apos;Failed to collect Swoole metrics: &apos; . $e-&gt;getMessage());
            }
        }
    }
    /**
     * Check if we&apos;re running in Swoole context
     */
    private function isSwooleContext(): bool
    {
        return extension_loaded(&apos;swoole&apos;) &amp;&amp;
            (function_exists(&apos;swoole_get_local_ip&apos;) || class_exists(&apos;\Swoole\Coroutine&apos;));
    }
    /**
     * Set collection interval (updates the instance property but not persisted state)
     */
    public function setInterval(int $seconds): void
    {
        $wasRunning = $this-&gt;isRunning();
        if ($wasRunning) {
            $this-&gt;stop();
        }
        $this-&gt;intervalSeconds = $seconds;
        if ($wasRunning) {
            $this-&gt;start();
        }
    }
    public function isRunning(): bool
    {
        return $this-&gt;getRunningState();
    }
    private function getRunningState(): bool
    {
        if (!$this-&gt;hasOctaneTables()) {
            return false;
        }
        try {
            $key = $this-&gt;getWorkerKey(self::RUNNING_KEY);
            $result = Octane::table(&apos;metrics_state&apos;)-&gt;get($key);
            return (bool)($result[&apos;running&apos;] ?? false);
        } catch (\Throwable) {
            return false;
        }
    }
    /**
     * Check if Octane tables are available
     */
    private function hasOctaneTables(): bool
    {
        try {
            if (!class_exists(&apos;\Laravel\Octane\Facades\Octane&apos;)) {
                return false;
            }
            if (!method_exists(&apos;\Laravel\Octane\Facades\Octane&apos;, &apos;table&apos;)) {
                return false;
            }
            // Test if the table actually exists and is accessible
            $table = Octane::table(&apos;metrics_state&apos;);
            return $table !== null;
        } catch (\Throwable) {
            return false;
        }
    }
    /**
     * Get worker-specific key
     */
    private function getWorkerKey(string $key): string
    {
        return $key . &apos;_&apos; . $this-&gt;getWorkerId();
    }
    /**
     * Get current worker ID
     */
    private function getWorkerId(): string
    {
        // Try to get Swoole worker ID first
        if (function_exists(&apos;swoole_get_current_worker&apos;)) {
            try {
                $workerId = swoole_get_current_worker();
                if ($workerId !== false) {
                    return &apos;worker_&apos; . $workerId;
                }
            } catch (\Throwable) {
                // Fall through to PID-based approach
            }
        }
        return &apos;worker_&apos; . getmypid();
    }
    /**
     * Stop periodic metrics collection
     */
    public function stop(): void
    {
        $timerId = $this-&gt;getTimerId();
        if (!$timerId || !$this-&gt;isRunning()) {
            return;
        }
        Timer::clear($timerId);
        $this-&gt;setTimerState(null, false);
        try {
            Log::info(&apos;Swoole metrics collection stopped&apos;, [
                &apos;worker_id&apos; =&gt; $this-&gt;getWorkerId(),
            ]);
        } catch (\Throwable) {
            error_log(&apos;Swoole metrics collection stopped for worker: &apos; . $this-&gt;getWorkerId());
        }
    }
    /**
     * Get worker-specific timer state from Octane table
     */
    private function getTimerId(): ?int
    {
        if (!$this-&gt;hasOctaneTables()) {
            return null;
        }
        try {
            $key = $this-&gt;getWorkerKey(self::TIMER_KEY);
            $result = Octane::table(&apos;metrics_state&apos;)-&gt;get($key);
            return $result[&apos;timer_id&apos;] ?? null;
        } catch (\Throwable) {
            return null;
        }
    }
    /**
     * Set timer state in Octane table
     */
    private function setTimerState(?int $timerId, bool $running): void
    {
        if (!$this-&gt;hasOctaneTables()) {
            return;
        }
        try {
            $timerKey = $this-&gt;getWorkerKey(self::TIMER_KEY);
            $runningKey = $this-&gt;getWorkerKey(self::RUNNING_KEY);
            if ($timerId !== null) {
                Octane::table(&apos;metrics_state&apos;)-&gt;set($timerKey, [&apos;timer_id&apos; =&gt; $timerId]);
            } else {
                Octane::table(&apos;metrics_state&apos;)-&gt;del($timerKey);
            }
            Octane::table(&apos;metrics_state&apos;)-&gt;set($runningKey, [&apos;running&apos; =&gt; $running ? 1 : 0]);
        } catch (\Throwable $e) {
            error_log(&apos;Failed to set timer state: &apos; . $e-&gt;getMessage());
        }
    }
    /**
     * Start periodic metrics collection using Octane table for state management
     */
    public function start(): void
    {
        if ($this-&gt;isRunning() || !$this-&gt;isSwooleContext()) {
            return;
        }
        // Set up periodic timer to collect metrics
        $timerId = Timer::tick($this-&gt;intervalSeconds * 1000, function () {
            try {
                // Create a fresh collector instance for each collection
                // Use direct instantiation to avoid config issues in timer context
                $this-&gt;collectMetricsDirectly();
            } catch (\Throwable $e) {
                // Use error_log instead of Log facade in timer context
                error_log(&apos;Failed to collect Swoole metrics in timer: &apos; . $e-&gt;getMessage());
            }
        });
        // Store timer state in Octane table (worker-specific)
        $this-&gt;setTimerState($timerId, true);
        // Use error_log for logging in timer context to avoid config issues
        error_log(sprintf(
            &apos;Swoole metrics collection started - interval: %d seconds, timer_id: %d, worker_id: %s&apos;,
            $this-&gt;intervalSeconds,
            $timerId,
            $this-&gt;getWorkerId(),
        ));
    }
    /**
     * Collect metrics directly without using the service container
     */
    private function collectMetricsDirectly(): void
    {
        try {
            // Get Swoole server stats directly
            if (!function_exists(&apos;swoole_get_local_ip&apos;)) {
                return;
            }
            $server = \Swoole\Server::getInstance();
            if (!$server) {
                return;
            }
            $stats = $server-&gt;stats();
            // Log basic stats without using Laravel&apos;s logging system
            error_log(sprintf(
                &apos;Swoole metrics collected - connections: %d, requests: %d, workers: %d, memory: %d MB&apos;,
                $stats[&apos;connection_num&apos;] ?? 0,
                $stats[&apos;request_count&apos;] ?? 0,
                $stats[&apos;worker_num&apos;] ?? 0,
                round(memory_get_usage(true) / 1024 / 1024, 2),
            ));
        } catch (\Throwable $e) {
            error_log(&apos;Failed to collect Swoole metrics directly: &apos; . $e-&gt;getMessage());
        }
    }
    /**
     * Clean up any orphaned timers for this worker
     */
    public function cleanup(): void
    {
        if (!$this-&gt;hasOctaneTables()) {
            return;
        }
        try {
            $workerId = $this-&gt;getWorkerId();
            $timerKey = self::TIMER_KEY . &apos;_&apos; . $workerId;
            $runningKey = self::RUNNING_KEY . &apos;_&apos; . $workerId;
            // Clear any existing timer
            $result = Octane::table(&apos;metrics_state&apos;)-&gt;get($timerKey);
            if ($result &amp;&amp; isset($result[&apos;timer_id&apos;])) {
                Timer::clear($result[&apos;timer_id&apos;]);
            }
            // Clean up table entries
            Octane::table(&apos;metrics_state&apos;)-&gt;del($timerKey);
            Octane::table(&apos;metrics_state&apos;)-&gt;del($runningKey);
            try {
                Log::debug(&apos;Cleaned up Swoole metrics state&apos;, [
                    &apos;worker_id&apos; =&gt; $workerId,
                ]);
            } catch (\Throwable) {
                error_log(&apos;Cleaned up Swoole metrics state for worker: &apos; . $workerId);
            }
        } catch (\Throwable $e) {
            error_log(&apos;Failed to cleanup Swoole metrics state: &apos; . $e-&gt;getMessage());
        }
    }
}</file><file path="app/Modules/Blade/directives.php">&lt;?php
return [
    &apos;any_to_string&apos; =&gt; function ($value) {
        if (is_object($value)) {
            return json_encode($value, JSON_PRETTY_PRINT | JSON_UNESCAPED_SLASHES);
        }
        if (is_array($value)) {
            return implode(PHP_EOL, \App\Extensions\ArrExt::dotKeys($value));
        }
        return $value;
    },
    &apos;humanize_duration&apos; =&gt; function ($duration, $hoursPerDay = 24) {
        return (new \App\Modules\Humanize\HumanDuration($duration, $hoursPerDay))-&gt;humanize();
    },
    &apos;humanize_bytes&apos; =&gt; function ($bytes, $decimals = 2) {
        return \App\Modules\Humanize\humanize_bytes($bytes, $decimals);
    },
];</file><file path="app/Modules/BlurHash/Base83.php">&lt;?php
namespace App\Modules\BlurHash;
class Base83
{
    /**
     * Base 63 encoder/decoder character set.
     *
     * @var array&lt;int, string&gt;
     */
    public static array $characters = [
        &apos;0&apos;, &apos;1&apos;, &apos;2&apos;, &apos;3&apos;, &apos;4&apos;, &apos;5&apos;, &apos;6&apos;, &apos;7&apos;, &apos;8&apos;, &apos;9&apos;, &apos;A&apos;, &apos;B&apos;, &apos;C&apos;, &apos;D&apos;,
        &apos;E&apos;, &apos;F&apos;, &apos;G&apos;, &apos;H&apos;, &apos;I&apos;, &apos;J&apos;, &apos;K&apos;, &apos;L&apos;, &apos;M&apos;, &apos;N&apos;, &apos;O&apos;, &apos;P&apos;, &apos;Q&apos;, &apos;R&apos;,
        &apos;S&apos;, &apos;T&apos;, &apos;U&apos;, &apos;V&apos;, &apos;W&apos;, &apos;X&apos;, &apos;Y&apos;, &apos;Z&apos;, &apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;, &apos;e&apos;, &apos;f&apos;,
        &apos;g&apos;, &apos;h&apos;, &apos;i&apos;, &apos;j&apos;, &apos;k&apos;, &apos;l&apos;, &apos;m&apos;, &apos;n&apos;, &apos;o&apos;, &apos;p&apos;, &apos;q&apos;, &apos;r&apos;, &apos;s&apos;, &apos;t&apos;,
        &apos;u&apos;, &apos;v&apos;, &apos;w&apos;, &apos;x&apos;, &apos;y&apos;, &apos;z&apos;, &apos;#&apos;, &apos;$&apos;, &apos;%&apos;, &apos;*&apos;, &apos;+&apos;, &apos;,&apos;, &apos;-&apos;, &apos;.&apos;,
        &apos;:&apos;, &apos;;&apos;, &apos;=&apos;, &apos;?&apos;, &apos;@&apos;, &apos;[&apos;, &apos;]&apos;, &apos;^&apos;, &apos;_&apos;, &apos;{&apos;, &apos;|&apos;, &apos;}&apos;, &apos;~&apos;,
    ];
    /**
     * Base 63 encoder/decoder character index map.
     *
     * @var array&lt;int|string, int&lt;0, 82&gt;&gt;
     */
    protected static array $indexMap = [
        &apos;0&apos; =&gt; 0, &apos;1&apos; =&gt; 1, &apos;2&apos; =&gt; 2, &apos;3&apos; =&gt; 3, &apos;4&apos; =&gt; 4,
        &apos;5&apos; =&gt; 5, &apos;6&apos; =&gt; 6, &apos;7&apos; =&gt; 7, &apos;8&apos; =&gt; 8, &apos;9&apos; =&gt; 9,
        &apos;A&apos; =&gt; 10, &apos;B&apos; =&gt; 11, &apos;C&apos; =&gt; 12, &apos;D&apos; =&gt; 13, &apos;E&apos; =&gt; 14, &apos;F&apos; =&gt; 15,
        &apos;G&apos; =&gt; 16, &apos;H&apos; =&gt; 17, &apos;I&apos; =&gt; 18, &apos;J&apos; =&gt; 19, &apos;K&apos; =&gt; 20, &apos;L&apos; =&gt; 21,
        &apos;M&apos; =&gt; 22, &apos;N&apos; =&gt; 23, &apos;O&apos; =&gt; 24, &apos;P&apos; =&gt; 25, &apos;Q&apos; =&gt; 26, &apos;R&apos; =&gt; 27,
        &apos;S&apos; =&gt; 28, &apos;T&apos; =&gt; 29, &apos;U&apos; =&gt; 30, &apos;V&apos; =&gt; 31, &apos;W&apos; =&gt; 32, &apos;X&apos; =&gt; 33,
        &apos;Y&apos; =&gt; 34, &apos;Z&apos; =&gt; 35, &apos;a&apos; =&gt; 36, &apos;b&apos; =&gt; 37, &apos;c&apos; =&gt; 38, &apos;d&apos; =&gt; 39,
        &apos;e&apos; =&gt; 40, &apos;f&apos; =&gt; 41, &apos;g&apos; =&gt; 42, &apos;h&apos; =&gt; 43, &apos;i&apos; =&gt; 44, &apos;j&apos; =&gt; 45,
        &apos;k&apos; =&gt; 46, &apos;l&apos; =&gt; 47, &apos;m&apos; =&gt; 48, &apos;n&apos; =&gt; 49, &apos;o&apos; =&gt; 50, &apos;p&apos; =&gt; 51,
        &apos;q&apos; =&gt; 52, &apos;r&apos; =&gt; 53, &apos;s&apos; =&gt; 54, &apos;t&apos; =&gt; 55, &apos;u&apos; =&gt; 56, &apos;v&apos; =&gt; 57,
        &apos;w&apos; =&gt; 58, &apos;x&apos; =&gt; 59, &apos;y&apos; =&gt; 60, &apos;z&apos; =&gt; 61, &apos;#&apos; =&gt; 62, &apos;$&apos; =&gt; 63,
        &apos;%&apos; =&gt; 64, &apos;*&apos; =&gt; 65, &apos;+&apos; =&gt; 66, &apos;,&apos; =&gt; 67, &apos;-&apos; =&gt; 68, &apos;.&apos; =&gt; 69,
        &apos;:&apos; =&gt; 70, &apos;;&apos; =&gt; 71, &apos;=&apos; =&gt; 72, &apos;?&apos; =&gt; 73, &apos;@&apos; =&gt; 74, &apos;[&apos; =&gt; 75,
        &apos;]&apos; =&gt; 76, &apos;^&apos; =&gt; 77, &apos;_&apos; =&gt; 78, &apos;{&apos; =&gt; 79, &apos;|&apos; =&gt; 80, &apos;}&apos; =&gt; 81,
        &apos;~&apos; =&gt; 82,
    ];
    /**
     * Encode an integer to string.
     */
    public static function encode(int $value, int $length): string
    {
        $powOf83 = [1, 83, 6889, 571787, 47458321];
        return array_reduce(
            range($length - 1, 0),
            fn(string $carry, int $idx) =&gt; $carry . self::$characters[intdiv($value, $powOf83[$idx]) % 83],
            &apos;&apos;,
        );
    }
    /**
     * Decode a string to integer.
     */
    public static function decode(string $encoded): int
    {
        return array_reduce(
            str_split($encoded),
            fn(int $carry, string $char) =&gt; $carry * 83 + static::$indexMap[$char],
            0,
        );
    }
}</file><file path="app/Modules/BlurHash/BlurHash.php">&lt;?php
namespace App\Modules\BlurHash;
use App\Modules\BlurHash\Drivers\Driver;
use App\Modules\BlurHash\Drivers\GdDriver;
use App\Modules\BlurHash\Drivers\ImagickDriver;
use App\Modules\BlurHash\Exceptions\DriverNotFoundException;
use App\Modules\BlurHash\Exceptions\UnableToCreateImageException;
use App\Modules\BlurHash\Exceptions\UnableToGetColorException;
use App\Modules\BlurHash\Exceptions\UnableToSetPixelException;
use Imagick;
use Symfony\Component\HttpFoundation\File\UploadedFile;
class BlurHash
{
    /**
     * RGB Value to Linear Map
     *
     * Function calls and math calculations are costly in terms
     *  of processing. Therefore, we&apos;ve hard-coded all possible
     *  transfer values to optimize performance.
     *
     * @var array&lt;int, float&gt;
     */
    public static array $rgbToLinearMap = [
        0 =&gt; 0.0000,
        1 =&gt; 0.0003,
        2 =&gt; 0.0006,
        3 =&gt; 0.0009,
        4 =&gt; 0.0012,
        5 =&gt; 0.0015,
        6 =&gt; 0.0018,
        7 =&gt; 0.0021,
        8 =&gt; 0.0024,
        9 =&gt; 0.0027,
        10 =&gt; 0.0030,
        11 =&gt; 0.0033,
        12 =&gt; 0.0036,
        13 =&gt; 0.0040,
        14 =&gt; 0.0043,
        15 =&gt; 0.0047,
        16 =&gt; 0.0051,
        17 =&gt; 0.0056,
        18 =&gt; 0.0060,
        19 =&gt; 0.0065,
        20 =&gt; 0.0069,
        21 =&gt; 0.0074,
        22 =&gt; 0.0080,
        23 =&gt; 0.0085,
        24 =&gt; 0.0091,
        25 =&gt; 0.0097,
        26 =&gt; 0.0103,
        27 =&gt; 0.0109,
        28 =&gt; 0.0116,
        29 =&gt; 0.0122,
        30 =&gt; 0.0129,
        31 =&gt; 0.0137,
        32 =&gt; 0.0144,
        33 =&gt; 0.0152,
        34 =&gt; 0.0159,
        35 =&gt; 0.0168,
        36 =&gt; 0.0176,
        37 =&gt; 0.0185,
        38 =&gt; 0.0193,
        39 =&gt; 0.0202,
        40 =&gt; 0.0212,
        41 =&gt; 0.0221,
        42 =&gt; 0.0231,
        43 =&gt; 0.0241,
        44 =&gt; 0.0251,
        45 =&gt; 0.0262,
        46 =&gt; 0.0273,
        47 =&gt; 0.0284,
        48 =&gt; 0.0295,
        49 =&gt; 0.0307,
        50 =&gt; 0.0318,
        51 =&gt; 0.0331,
        52 =&gt; 0.0343,
        53 =&gt; 0.0356,
        54 =&gt; 0.0368,
        55 =&gt; 0.0382,
        56 =&gt; 0.0395,
        57 =&gt; 0.0409,
        58 =&gt; 0.0423,
        59 =&gt; 0.0437,
        60 =&gt; 0.0451,
        61 =&gt; 0.0466,
        62 =&gt; 0.0481,
        63 =&gt; 0.0497,
        64 =&gt; 0.0512,
        65 =&gt; 0.0528,
        66 =&gt; 0.0544,
        67 =&gt; 0.0561,
        68 =&gt; 0.0578,
        69 =&gt; 0.0595,
        70 =&gt; 0.0612,
        71 =&gt; 0.0630,
        72 =&gt; 0.0648,
        73 =&gt; 0.0666,
        74 =&gt; 0.0684,
        75 =&gt; 0.0703,
        76 =&gt; 0.0722,
        77 =&gt; 0.0742,
        78 =&gt; 0.0761,
        79 =&gt; 0.0781,
        80 =&gt; 0.0802,
        81 =&gt; 0.0822,
        82 =&gt; 0.0843,
        83 =&gt; 0.0865,
        84 =&gt; 0.0886,
        85 =&gt; 0.0908,
        86 =&gt; 0.0930,
        87 =&gt; 0.0953,
        88 =&gt; 0.0975,
        89 =&gt; 0.0998,
        90 =&gt; 0.1022,
        91 =&gt; 0.1046,
        92 =&gt; 0.1070,
        93 =&gt; 0.1094,
        94 =&gt; 0.1119,
        95 =&gt; 0.1144,
        96 =&gt; 0.1169,
        97 =&gt; 0.1195,
        98 =&gt; 0.1221,
        99 =&gt; 0.1247,
        100 =&gt; 0.1274,
        101 =&gt; 0.1301,
        102 =&gt; 0.1328,
        103 =&gt; 0.1356,
        104 =&gt; 0.1384,
        105 =&gt; 0.1412,
        106 =&gt; 0.1441,
        107 =&gt; 0.1470,
        108 =&gt; 0.1499,
        109 =&gt; 0.1529,
        110 =&gt; 0.1559,
        111 =&gt; 0.1589,
        112 =&gt; 0.1620,
        113 =&gt; 0.1651,
        114 =&gt; 0.1682,
        115 =&gt; 0.1714,
        116 =&gt; 0.1746,
        117 =&gt; 0.1778,
        118 =&gt; 0.1811,
        119 =&gt; 0.1844,
        120 =&gt; 0.1878,
        121 =&gt; 0.1912,
        122 =&gt; 0.1946,
        123 =&gt; 0.1980,
        124 =&gt; 0.2015,
        125 =&gt; 0.2050,
        126 =&gt; 0.2086,
        127 =&gt; 0.2122,
        128 =&gt; 0.2158,
        129 =&gt; 0.2195,
        130 =&gt; 0.2232,
        131 =&gt; 0.2269,
        132 =&gt; 0.2307,
        133 =&gt; 0.2345,
        134 =&gt; 0.2383,
        135 =&gt; 0.2422,
        136 =&gt; 0.2462,
        137 =&gt; 0.2501,
        138 =&gt; 0.2541,
        139 =&gt; 0.2581,
        140 =&gt; 0.2622,
        141 =&gt; 0.2663,
        142 =&gt; 0.2704,
        143 =&gt; 0.2746,
        144 =&gt; 0.2788,
        145 =&gt; 0.2831,
        146 =&gt; 0.2874,
        147 =&gt; 0.2917,
        148 =&gt; 0.2961,
        149 =&gt; 0.3005,
        150 =&gt; 0.3049,
        151 =&gt; 0.3094,
        152 =&gt; 0.3139,
        153 =&gt; 0.3185,
        154 =&gt; 0.3231,
        155 =&gt; 0.3277,
        156 =&gt; 0.3324,
        157 =&gt; 0.3371,
        158 =&gt; 0.3419,
        159 =&gt; 0.3467,
        160 =&gt; 0.3515,
        161 =&gt; 0.3564,
        162 =&gt; 0.3613,
        163 =&gt; 0.3662,
        164 =&gt; 0.3712,
        165 =&gt; 0.3762,
        166 =&gt; 0.3813,
        167 =&gt; 0.3864,
        168 =&gt; 0.3915,
        169 =&gt; 0.3967,
        170 =&gt; 0.4019,
        171 =&gt; 0.4072,
        172 =&gt; 0.4125,
        173 =&gt; 0.4178,
        174 =&gt; 0.4232,
        175 =&gt; 0.4286,
        176 =&gt; 0.4341,
        177 =&gt; 0.4396,
        178 =&gt; 0.4452,
        179 =&gt; 0.4507,
        180 =&gt; 0.4564,
        181 =&gt; 0.4620,
        182 =&gt; 0.4677,
        183 =&gt; 0.4735,
        184 =&gt; 0.4793,
        185 =&gt; 0.4851,
        186 =&gt; 0.4910,
        187 =&gt; 0.4969,
        188 =&gt; 0.5028,
        189 =&gt; 0.5088,
        190 =&gt; 0.5149,
        191 =&gt; 0.5209,
        192 =&gt; 0.5271,
        193 =&gt; 0.5332,
        194 =&gt; 0.5394,
        195 =&gt; 0.5457,
        196 =&gt; 0.5520,
        197 =&gt; 0.5583,
        198 =&gt; 0.5647,
        199 =&gt; 0.5711,
        200 =&gt; 0.5775,
        201 =&gt; 0.5840,
        202 =&gt; 0.5906,
        203 =&gt; 0.5972,
        204 =&gt; 0.6038,
        205 =&gt; 0.6104,
        206 =&gt; 0.6172,
        207 =&gt; 0.6239,
        208 =&gt; 0.6307,
        209 =&gt; 0.6375,
        210 =&gt; 0.6444,
        211 =&gt; 0.6514,
        212 =&gt; 0.6583,
        213 =&gt; 0.6653,
        214 =&gt; 0.6724,
        215 =&gt; 0.6795,
        216 =&gt; 0.6866,
        217 =&gt; 0.6938,
        218 =&gt; 0.7011,
        219 =&gt; 0.7083,
        220 =&gt; 0.7156,
        221 =&gt; 0.7230,
        222 =&gt; 0.7304,
        223 =&gt; 0.7379,
        224 =&gt; 0.7454,
        225 =&gt; 0.7529,
        226 =&gt; 0.7605,
        227 =&gt; 0.7681,
        228 =&gt; 0.7758,
        229 =&gt; 0.7835,
        230 =&gt; 0.7912,
        231 =&gt; 0.7991,
        232 =&gt; 0.8069,
        233 =&gt; 0.8148,
        234 =&gt; 0.8227,
        235 =&gt; 0.8307,
        236 =&gt; 0.8387,
        237 =&gt; 0.8468,
        238 =&gt; 0.8549,
        239 =&gt; 0.8631,
        240 =&gt; 0.8713,
        241 =&gt; 0.8796,
        242 =&gt; 0.8879,
        243 =&gt; 0.8962,
        244 =&gt; 0.9046,
        245 =&gt; 0.9130,
        246 =&gt; 0.9215,
        247 =&gt; 0.9301,
        248 =&gt; 0.9386,
        249 =&gt; 0.9473,
        250 =&gt; 0.9559,
        251 =&gt; 0.9646,
        252 =&gt; 0.9734,
        253 =&gt; 0.9822,
        254 =&gt; 0.9911,
        255 =&gt; 1.0000,
    ];
    /**
     * @var GdDriver|ImagickDriver
     */
    public Driver $driver;
    /**
     * Create a new BlurHash instance.
     *
     * @param  &apos;gd&apos;|&apos;imagick&apos;  $loader
     * @param  int&lt;1, 9&gt;  $componentX
     * @param  int&lt;1, 9&gt;  $componentY
     * @param  positive-int  $maxSize
     *
     * @throws DriverNotFoundException
     */
    public function __construct(
        string $loader = &apos;gd&apos;,
        public int $componentX = 4,
        public int $componentY = 3,
        int $maxSize = 64
    ) {
        $drivers = [
            &apos;gd&apos; =&gt; GdDriver::class,
            &apos;imagick&apos; =&gt; ImagickDriver::class,
        ];
        if (! isset($drivers[$loader])) {
            throw new DriverNotFoundException(
                sprintf(&apos;&quot;%s&quot; is not a valid driver.&apos;, $loader),
            );
        }
        $this-&gt;driver = new $drivers[$loader]($maxSize);
        $this-&gt;setComponentX($componentX)-&gt;setComponentY($componentY);
    }
    /**
     * Encode an image to BlurHash string.
     *
     * @throws UnableToGetColorException
     */
    public function encode(UploadedFile|string $data): string
    {
        if ($data instanceof UploadedFile) {
            $data = $data-&gt;getPathname();
        }
        $ac = $this-&gt;transform(
            $this-&gt;driver-&gt;colors($data),
        );
        /** @var array&lt;float&gt; $dc */
        $dc = array_shift($ac);
        $hash = Base83::encode($this-&gt;componentX - 1 + ($this-&gt;componentY - 1) * 9, 1);
        $maximum = 1;
        if (! count($ac)) {
            $hash .= Base83::encode(0, 1);
        } else {
            $actual = max(array_map(&apos;max&apos;, $ac));
            $quantised = max(0, min(82, intval($actual * 166 - 0.5)));
            $maximum = ($quantised + 1) / 166;
            $hash .= Base83::encode($quantised, 1);
        }
        $hash .= Base83::encode(($this-&gt;toSRGB($dc[0]) &lt;&lt; 16) + ($this-&gt;toSRGB($dc[1]) &lt;&lt; 8) + $this-&gt;toSRGB($dc[2]), 4);
        foreach ($ac as $factor) {
            $hash .= Base83::encode(self::encodeAC($factor, $maximum), 2);
        }
        return $hash;
    }
    /**
     * Decode a BlurHash string to an image instance.
     *
     * @param  positive-int  $width
     * @param  positive-int  $height
     *
     * @throws UnableToSetPixelException
     * @throws UnableToCreateImageException
     */
    public function decode(string $blurhash, int $width, int $height): object
    {
        $this-&gt;driver-&gt;create($width, $height);
        $size = Base83::decode($blurhash[0]);
        $sizeX = ($size % 9) + 1;
        $sizeY = intdiv($size, 9) + 1;
        $colors = [$this-&gt;toRGB(Base83::decode(substr($blurhash, 2, 4)))];
        $maximum = (Base83::decode($blurhash[1]) + 1) / 166;
        for ($i = 1, $total = $sizeX * $sizeY; $i &lt; $total; $i++) {
            $value = Base83::decode(substr($blurhash, $i * 2 + 4, 2));
            $colors[$i] = $this-&gt;decodeAC($value, $maximum);
        }
        for ($y = 0; $y &lt; $height; $y++) {
            for ($x = 0; $x &lt; $width; $x++) {
                $r = $g = $b = 0;
                $piXWidth = M_PI * $x / $width;
                $piYHeight = M_PI * $y / $height;
                for ($j = 0; $j &lt; $sizeY; $j++) {
                    $cosHeight = cos($piYHeight * $j);
                    $sizeXJ = $j * $sizeX;
                    for ($i = 0; $i &lt; $sizeX; $i++) {
                        $color = $colors[$i + $sizeXJ];
                        $basis = cos($piXWidth * $i) * $cosHeight;
                        $r += $color[0] * $basis;
                        $g += $color[1] * $basis;
                        $b += $color[2] * $basis;
                    }
                }
                $this-&gt;driver-&gt;pixel($x, $y, [$this-&gt;toSRGB($r), $this-&gt;toSRGB($g), $this-&gt;toSRGB($b)]);
            }
        }
        return $this-&gt;driver-&gt;image;
    }
    /**
     * Magic transform function.
     *
     * I don&apos;t know the meaning of the math calculation.
     *
     * @param  array&lt;int, array&lt;int, array&lt;int, float&gt;&gt;&gt;  $colors
     * @return array&lt;int, array&lt;int, float&gt;&gt;
     */
    protected function transform(array $colors): array
    {
        $factors = [];
        $scale = 1 / ($this-&gt;driver-&gt;width * $this-&gt;driver-&gt;height);
        for ($y = 0; $y &lt; $this-&gt;componentY; $y++) {
            $yHeight = M_PI * $y / $this-&gt;driver-&gt;height;
            for ($x = 0; $x &lt; $this-&gt;componentX; $x++) {
                $normalisation = $x === 0 &amp;&amp; $y === 0 ? 1 : 2;
                $xWidth = M_PI * $x / $this-&gt;driver-&gt;width;
                $r = $g = $b = 0;
                for ($i = 0; $i &lt; $this-&gt;driver-&gt;width; $i++) {
                    $cosWidth = $normalisation * cos($xWidth * $i);
                    for ($j = 0; $j &lt; $this-&gt;driver-&gt;height; $j++) {
                        $basis = $cosWidth * cos($yHeight * $j);
                        $color = $colors[$i][$j];
                        $r += $basis * $color[0];
                        $g += $basis * $color[1];
                        $b += $basis * $color[2];
                    }
                }
                $factors[] = [
                    round($r * $scale, 7),
                    round($g * $scale, 7),
                    round($b * $scale, 7),
                ];
            }
        }
        return $factors;
    }
    /**
     * @return array&lt;int, float&gt;
     */
    protected function toRGB(int $value): array
    {
        $r = ($value &gt;&gt; 16) &amp; 0xFF;
        $g = ($value &gt;&gt; 8) &amp; 0xFF;
        $b = $value &amp; 0xFF;
        return [
            self::$rgbToLinearMap[$r],
            self::$rgbToLinearMap[$g],
            self::$rgbToLinearMap[$b],
        ];
    }
    /**
     * @return int&lt;0, 255&gt;
     */
    protected function toSRGB(float $value): int
    {
        $value = max(0, min(1, $value));
        if ($value &lt;= 0.0031308) {
            $value = $value * 12.92 * 255 + 0.5;
        } else {
            $value = (1.055 * pow($value, 1 / 2.4) - 0.055) * 255 + 0.5;
        }
        return intval($value); // @phpstan-ignore-line
    }
    /**
     * Encode ac factor.
     *
     * @param  array&lt;int, float&gt;  $color
     */
    protected function encodeAC(array $color, float $max): int
    {
        $r = $this-&gt;quantise($this-&gt;pow($color[0] / $max, 0.5));
        $g = $this-&gt;quantise($this-&gt;pow($color[1] / $max, 0.5));
        $b = $this-&gt;quantise($this-&gt;pow($color[2] / $max, 0.5));
        return $r * 19 * 19 + $g * 19 + $b;
    }
    /**
     * @return array&lt;int, float&gt;
     */
    protected function decodeAC(int $value, float $max): array
    {
        $r = intdiv($value, 19 * 19);
        $g = intdiv($value, 19) % 19;
        $b = $value % 19;
        return [
            $this-&gt;pow(($r - 9) / 9, 2) * $max,
            $this-&gt;pow(($g - 9) / 9, 2) * $max,
            $this-&gt;pow(($b - 9) / 9, 2) * $max,
        ];
    }
    protected function quantise(float $value): int
    {
        return max(0, min(18, intval($value * 9 + 9.5)));
    }
    protected function pow(float $value, float $exp): float
    {
        return ($value &lt; 0 ? -1 : 1) * pow(abs($value), $exp);
    }
    /**
     * Set component x.
     *
     * @param  int&lt;1, 9&gt;  $componentX
     */
    public function setComponentX(int $componentX): self
    {
        $this-&gt;componentX = $this-&gt;normalizeComponent($componentX);
        return $this;
    }
    /**
     * Set component y.
     *
     * @param  int&lt;1, 9&gt;  $componentY
     */
    public function setComponentY(int $componentY): self
    {
        $this-&gt;componentY = $this-&gt;normalizeComponent($componentY);
        return $this;
    }
    /**
     * Restrict component value between 1 and 9.
     *
     * @param  int&lt;1, 9&gt;  $value
     * @return int&lt;1, 9&gt;
     */
    public function normalizeComponent(int $value): int
    {
        return max(1, min(9, $value));
    }
    /**
     * Set resized image max width.
     *
     * @param  positive-int  $maxSize
     */
    public function setMaxSize(int $maxSize): self
    {
        $this-&gt;driver-&gt;maxSize = max($maxSize, 1);
        return $this;
    }
}</file><file path="app/Modules/BlurHash/Drivers/Driver.php">&lt;?php
namespace App\Modules\BlurHash\Drivers;
use App\Modules\BlurHash\BlurHash;
use App\Modules\BlurHash\Exceptions\UnableToGetColorException;
abstract class Driver
{
    /**
     * Image width.
     */
    public int $width;
    /**
     * Image height.
     */
    public int $height;
    /**
     * Create a new driver instance.
     *
     * @param  positive-int  $maxSize
     */
    public function __construct(
        public int $maxSize,
    ) {
        //
    }
    /**
     * @return array&lt;int, array&lt;int, array{
     *     0: float,
     *     1: float,
     *     2: float,
     * }&gt;&gt;
     *
     * @throws UnableToGetColorException
     */
    public function colors(string $path): array
    {
        $origin = $this-&gt;read($path);
        $image = $this-&gt;resize($origin);
        [$this-&gt;width, $this-&gt;height] = $this-&gt;size($image);
        $colors = $cache = [];
        for ($x = 0; $x &lt; $this-&gt;width; $x++) {
            for ($y = 0; $y &lt; $this-&gt;height; $y++) {
                $rgb = $this-&gt;color($image, $x, $y);
                if ($rgb === false) {
                    throw new UnableToGetColorException(
                        sprintf(&apos;Unable to get color at x: %d, y: %d.&apos;, $x, $y),
                    );
                }
                $key = sprintf(&apos;%d-%d-%d&apos;, $rgb[0], $rgb[1], $rgb[2]);
                if (! isset($cache[$key])) {
                    $cache[$key] = [
                        BlurHash::$rgbToLinearMap[$rgb[0]],
                        BlurHash::$rgbToLinearMap[$rgb[1]],
                        BlurHash::$rgbToLinearMap[$rgb[2]],
                    ];
                }
                $colors[$x][$y] = $cache[$key];
            }
        }
        return $colors;
    }
    /**
     * Get resizing factor.
     *
     * @param  positive-int  $width
     * @param  positive-int  $height
     */
    public function scale(int $width, int $height): float
    {
        return max(
            $width / $this-&gt;maxSize,
            $height / $this-&gt;maxSize,
            1.0,
        );
    }
    /**
     * Reads an image from a path and returns an image resource based on the driver.
     */
    abstract public function read(string $path): object;
    /**
     * Resizes the image to a smaller version.
     */
    abstract public function resize(object $image): object;
    /**
     * Retrieves the image&apos;s width and height.
     *
     * @return array{
     *     0: positive-int,
     *     1: positive-int,
     * }
     */
    abstract public function size(object $image): array;
    /**
     * Obtains the color at a specific position.
     *
     * @return array{
     *     0: int&lt;0, 255&gt;,
     *     1: int&lt;0, 255&gt;,
     *     2: int&lt;0, 255&gt;,
     * }|false
     */
    abstract public function color(object $image, int $x, int $y): array|false;
    /**
     * Creates a new image with specified width and height.
     *
     * @param  positive-int  $width
     * @param  positive-int  $height
     */
    abstract public function create(int $width, int $height): static;
    /**
     * Applies a color at a specific position.
     *
     * @param  non-negative-int  $x
     * @param  non-negative-int  $y
     * @param array{
     *     0: int&lt;0, 255&gt;,
     *     1: int&lt;0, 255&gt;,
     *     2: int&lt;0, 255&gt;,
     * } $color
     */
    abstract public function pixel(int $x, int $y, array $color): bool;
}</file><file path="app/Modules/BlurHash/Drivers/GdDriver.php">&lt;?php
namespace App\Modules\BlurHash\Drivers;
use App\Modules\BlurHash\Exceptions\DriverNotFoundException;
use App\Modules\BlurHash\Exceptions\UnableToConvertColorException;
use App\Modules\BlurHash\Exceptions\UnableToCreateImageException;
use App\Modules\BlurHash\Exceptions\UnableToReadFileException;
use App\Modules\BlurHash\Exceptions\UnableToSetPixelException;
use App\Modules\BlurHash\Exceptions\UnsupportedFileException;
use GdImage;
class GdDriver extends Driver
{
    public GdImage $image;
    /**
     * Create a new GdDriver instance.
     *
     * @throws DriverNotFoundException
     */
    public function __construct(int $maxSize)
    {
        if (! extension_loaded(&apos;gd&apos;)) {
            throw new DriverNotFoundException(
                &apos;GD extension is not loaded.&apos;,
            );
        }
        parent::__construct($maxSize);
    }
    /**
     * {@inheritdoc}
     *
     * @throws DriverNotFoundException
     * @throws UnableToReadFileException
     * @throws UnsupportedFileException
     */
    public function read(string $path): GdImage
    {
        $supported = [
            IMAGETYPE_GIF =&gt; &apos;imagecreatefromgif&apos;,
            IMAGETYPE_JPEG =&gt; &apos;imagecreatefromjpeg&apos;,
            IMAGETYPE_PNG =&gt; &apos;imagecreatefrompng&apos;,
            IMAGETYPE_BMP =&gt; &apos;imagecreatefrombmp&apos;,
            IMAGETYPE_WBMP =&gt; &apos;imagecreatefromwbmp&apos;,
            IMAGETYPE_XBM =&gt; &apos;imagecreatefromxbm&apos;,
            IMAGETYPE_WEBP =&gt; &apos;imagecreatefromwebp&apos;,
        ];
        if (version_compare(PHP_VERSION, &apos;8.1.0&apos;, &apos;&gt;=&apos;)) {
            $supported[IMAGETYPE_AVIF] = &apos;imagecreatefromavif&apos;;
        }
        $type = exif_imagetype($path);
        if ($type === false || ! isset($supported[$type])) {
            throw new UnsupportedFileException(
                sprintf(&apos;The &quot;%s&quot; is not a supported image file.&apos;, $path),
            );
        }
        $callback = $supported[$type];
        if (! function_exists($callback)) {
            throw new DriverNotFoundException(
                sprintf(&apos;Function &quot;%s&quot; not found.&apos;, $callback),
            );
        }
        $image = call_user_func($callback, $path);
        if (! ($image instanceof GdImage)) {
            throw new UnableToReadFileException(
                sprintf(&apos;Unable to create an image resource from the &quot;%s&quot; file.&apos;, $path),
            );
        }
        return $image;
    }
    /**
     * {@inheritdoc}
     *
     * @param  GdImage  $origin
     *
     * @throws UnableToConvertColorException
     */
    public function resize(object $origin): GdImage
    {
        if (imagepalettetotruecolor($origin) === false) {
            throw new UnableToConvertColorException();
        }
        [$originWidth, $originHeight] = $this-&gt;size($origin);
        $scale = $this-&gt;scale($originWidth, $originHeight);
        if ($scale &lt;= 1.0) {
            return $origin;
        }
        $width = (int) ceil($originWidth / $scale);
        $height = (int) ceil($originHeight / $scale);
        $image = imagecreatetruecolor($width, $height);
        if ($image === false) {
            return $origin;
        }
        if (imagesavealpha($image, true) === false) {
            return $origin;
        }
        if (imagealphablending($image, false) === false) {
            return $origin;
        }
        $background = imagecolorallocatealpha($image, 0xFF, 0xFF, 0xFF, 127);
        if ($background === false) {
            return $origin;
        }
        if (imagefill($image, 0, 0, $background) === false) {
            return $origin;
        }
        if (imagealphablending($image, true) === false) {
            return $origin;
        }
        $resized = imagecopyresampled(
            $image,
            $origin,
            0,
            0,
            0,
            0,
            $width,
            $height,
            $originWidth,
            $originHeight,
        );
        if ($resized === false) {
            return $origin;
        }
        return $image;
    }
    /**
     * {@inheritdoc}
     *
     * @param  GdImage  $image
     */
    public function size(object $image): array
    {
        return [ // @phpstan-ignore-line
            imagesx($image),
            imagesy($image),
        ];
    }
    /**
     * {@inheritdoc}
     *
     * @param  GdImage  $image
     */
    public function color(object $image, int $x, int $y): array|false
    {
        $rgb = imagecolorat($image, $x, $y);
        if ($rgb === false) {
            return false;
        }
        return [
            ($rgb &gt;&gt; 16) &amp; 0xFF,
            ($rgb &gt;&gt; 8) &amp; 0xFF,
            $rgb &amp; 0xFF,
        ];
    }
    /**
     * {@inheritdoc}
     *
     * @throws UnableToCreateImageException
     */
    public function create(int $width, int $height): static
    {
        $image = imagecreatetruecolor($width, $height);
        if ($image === false) {
            throw new UnableToCreateImageException();
        }
        $this-&gt;image = $image;
        return $this;
    }
    /**
     * {@inheritdoc}
     *
     * @throws UnableToSetPixelException
     */
    public function pixel(int $x, int $y, array $color): bool
    {
        $draw = imagecolorallocate($this-&gt;image, ...$color);
        if ($draw === false) {
            throw new UnableToSetPixelException();
        }
        return imagesetpixel($this-&gt;image, $x, $y, $draw);
    }
}</file><file path="app/Modules/BlurHash/Drivers/ImagickDriver.php">&lt;?php
namespace App\Modules\BlurHash\Drivers;
use App\Modules\BlurHash\Exceptions\DriverNotFoundException;
use App\Modules\BlurHash\Exceptions\UnableToCreateImageException;
use App\Modules\BlurHash\Exceptions\UnableToSetPixelException;
use App\Modules\BlurHash\Exceptions\UnsupportedFileException;
use Imagick;
use ImagickDraw;
use ImagickDrawException;
use ImagickException;
use ImagickPixel;
use ImagickPixelException;
class ImagickDriver extends Driver
{
    public Imagick $image;
    /**
     * Create a new ImagickDriver instance.
     *
     * @throws DriverNotFoundException
     */
    public function __construct(int $maxSize)
    {
        if (! extension_loaded(&apos;imagick&apos;)) {
            throw new DriverNotFoundException(
                &apos;Imagick extension is not loaded.&apos;,
            );
        }
        parent::__construct($maxSize);
    }
    /**
     * {@inheritdoc}
     *
     * @throws UnsupportedFileException
     */
    public function read(string $path): Imagick
    {
        try {
            return new Imagick($path);
        } catch (ImagickException) {
            throw new UnsupportedFileException(
                sprintf(&apos;The &quot;%s&quot; is not a supported image file.&apos;, $path),
            );
        }
    }
    /**
     * {@inheritdoc}
     *
     * @param  Imagick  $image
     */
    public function resize(object $image): Imagick
    {
        try {
            $image-&gt;adaptiveResizeImage(
                $this-&gt;maxSize,
                $this-&gt;maxSize,
                true,
            );
            $image-&gt;setImageAlphaChannel(Imagick::ALPHACHANNEL_BACKGROUND);
            $image-&gt;setImageBackgroundColor(
                new ImagickPixel(&apos;rgba(255, 255, 255, 0)&apos;),
            );
        } catch (ImagickException) {
            // ignored
        }
        return $image;
    }
    /**
     * {@inheritdoc}
     *
     * @param  Imagick  $image
     *
     * @throws ImagickException
     */
    public function size(object $image): array
    {
        return [ // @phpstan-ignore-line
            $image-&gt;getImageWidth(),
            $image-&gt;getImageHeight(),
        ];
    }
    /**
     * {@inheritdoc}
     *
     * @param  Imagick  $image
     */
    public function color(object $image, int $x, int $y): array|false
    {
        try {
            $color = $image-&gt;getImagePixelColor($x, $y)-&gt;getColor(2);
            return [
                max(min($color[&apos;r&apos;], 255), 0),
                max(min($color[&apos;g&apos;], 255), 0),
                max(min($color[&apos;b&apos;], 255), 0),
            ];
        } catch (ImagickException|ImagickPixelException) {
            return false;
        }
    }
    /**
     * {@inheritdoc}
     *
     * @throws UnableToCreateImageException
     */
    public function create(int $width, int $height): static
    {
        $this-&gt;image = new Imagick();
        try {
            $this-&gt;image-&gt;newImage(
                $width,
                $height,
                new ImagickPixel(&apos;transparent&apos;),
            );
        } catch (ImagickException) {
            throw new UnableToCreateImageException();
        }
        return $this;
    }
    /**
     * {@inheritdoc}
     *
     * @throws UnableToSetPixelException
     */
    public function pixel(int $x, int $y, array $color): bool
    {
        try {
            $rga = sprintf(&apos;rgb(%s,%s,%s)&apos;, ...$color);
            $draw = new ImagickDraw();
            $draw-&gt;setFillColor(new ImagickPixel($rga));
            $draw-&gt;point($x, $y);
            if ($this-&gt;image-&gt;drawImage($draw) === false) {
                throw new UnableToSetPixelException();
            }
            return true;
        } catch (ImagickException|ImagickDrawException|ImagickPixelException) {
            throw new UnableToSetPixelException();
        }
    }
}</file><file path="app/Modules/BlurHash/Exceptions/BlurHashException.php">&lt;?php
namespace App\Modules\BlurHash\Exceptions;
use Exception;
abstract class BlurHashException extends Exception
{
    //
}</file><file path="app/Modules/BlurHash/Exceptions/DriverNotFoundException.php">&lt;?php
namespace App\Modules\BlurHash\Exceptions;
class DriverNotFoundException extends BlurHashException
{
    //
}</file><file path="app/Modules/BlurHash/Exceptions/UnableToConvertColorException.php">&lt;?php
namespace App\Modules\BlurHash\Exceptions;
class UnableToConvertColorException extends BlurHashException
{
    //
}</file><file path="app/Modules/BlurHash/Exceptions/UnableToCreateImageException.php">&lt;?php
namespace App\Modules\BlurHash\Exceptions;
class UnableToCreateImageException extends BlurHashException
{
    //
}</file><file path="app/Modules/BlurHash/Exceptions/UnableToGetColorException.php">&lt;?php
namespace App\Modules\BlurHash\Exceptions;
class UnableToGetColorException extends BlurHashException
{
    //
}</file><file path="app/Modules/BlurHash/Exceptions/UnableToReadFileException.php">&lt;?php
namespace App\Modules\BlurHash\Exceptions;
class UnableToReadFileException extends BlurHashException
{
    //
}</file><file path="app/Modules/BlurHash/Exceptions/UnableToSetPixelException.php">&lt;?php
namespace App\Modules\BlurHash\Exceptions;
class UnableToSetPixelException extends BlurHashException
{
    //
}</file><file path="app/Modules/BlurHash/Exceptions/UnsupportedFileException.php">&lt;?php
namespace App\Modules\BlurHash\Exceptions;
class UnsupportedFileException extends BlurHashException
{
    //
}</file><file path="app/Modules/BlurHash/Facades/BlurHash.php">&lt;?php
namespace App\Modules\BlurHash\Facades;
use GdImage;
use Illuminate\Support\Facades\Facade;
use Imagick;
/**
 * @method static string encode(mixed $data)
 * @method static GdImage|Imagick|Image decode(string $blurhash, int $width, int $height)
 * @method static \App\Modules\BlurHash\BlurHash setComponentX(int $componentX)
 * @method static \App\Modules\BlurHash\BlurHash setComponentY(int $componentY)
 * @method static \App\Modules\BlurHash\BlurHash setMaxSize(int $maxSize)
 */
class BlurHash extends Facade
{
    /**
     * Get the registered name of the component.
     */
    protected static function getFacadeAccessor(): string
    {
        return &apos;blurhash&apos;;
    }
}</file><file path="app/Modules/DeviceDetector/CacheRepository.php">&lt;?php
namespace App\Modules\DeviceDetector;
use DeviceDetector\Cache\CacheInterface;
use Illuminate\Cache\Repository;
class CacheRepository implements CacheInterface
{
    public function __construct(
        protected Repository $cache,
    )
    {
    }
    public function fetch(string $id)
    {
        return $this-&gt;cache-&gt;get($id);
    }
    public function contains(string $id): bool
    {
        return $this-&gt;cache-&gt;has($id);
    }
    public function save(string $id, $data, int $lifeTime = 3600): bool
    {
        return $this-&gt;cache-&gt;put($id, $data, $lifeTime);
    }
    public function delete(string $id): bool
    {
        return $this-&gt;cache-&gt;forget($id);
    }
    public function flushAll(): bool
    {
        return $this-&gt;cache-&gt;flush();
    }
}</file><file path="app/Modules/DeviceDetector/DeviceDetector.php">&lt;?php
namespace App\Modules\DeviceDetector;
use DeviceDetector\ClientHints;
use DeviceDetector\DeviceDetector as MatomoDeviceDetector;
use Illuminate\Http\Request;
class DeviceDetector
{
    public function __construct(
        protected CacheRepository $cacheRepository,
    )
    {
    }
    public function detect(string $userAgent, array $headers = []): MatomoDeviceDetector
    {
        $clientHints = ClientHints::factory(headers: $headers);
        $dd = new MatomoDeviceDetector(
            userAgent: $userAgent,
            clientHints: $clientHints,
        );
        $dd-&gt;setCache(cache: $this-&gt;cacheRepository);
        $dd-&gt;parse();
        return $dd;
    }
    public function detectRequest(Request $request): MatomoDeviceDetector
    {
        return $this-&gt;detect(
            userAgent: $request-&gt;userAgent() ?? &apos;&apos;,
            headers: (array)$request-&gt;server(),
        );
    }
}</file><file path="app/Modules/DeviceDetector/DeviceDetectorServiceProvider.php">&lt;?php
namespace App\Modules\DeviceDetector;
use Illuminate\Cache\Repository;
use Illuminate\Http\Request;
use Illuminate\Support\ServiceProvider;
class DeviceDetectorServiceProvider extends ServiceProvider
{
    /**
     * Register services.
     *
     * @return void
     */
    public function register(): void
    {
        $this-&gt;app-&gt;when(CacheRepository::class)
            -&gt;needs(Repository::class)
            -&gt;give(fn($app)
                =&gt; $app-&gt;cache-&gt;store(
                $app-&gt;config-&gt;get(&apos;device-detector.cache_store&apos;),
            ));
    }
    /**
     * Bootstrap services.
     *
     * @return void
     */
    public function boot(): void
    {
        $this-&gt;app-&gt;singleton(DeviceDetector::class, DeviceDetector::class);
        Request::macro(&apos;device&apos;, function () {
            /** @var \Illuminate\Http\Request $this */
            /** @phpstan-ignore-next-line */
            return app(DeviceDetector::class)-&gt;detectRequest($this);
        });
    }
}</file><file path="app/Modules/Eloquent/BaseBuilder.php">&lt;?php
namespace App\Modules\Eloquent;
use App\Modules\Pagination\JsonPaginator;
use Illuminate\Container\Container;
use Illuminate\Database\Eloquent\Builder;
class BaseBuilder extends Builder
{
    /**
     * Apply relations safely.
     *
     * @param array|null $allowedRelations
     * @param string|null $relations
     * @return $this
     */
    public function withRelations(?array $allowedRelations, ?string $relations)
    {
        if (empty($relations)) {
            return $this;
        }
        $relationsArray = array_filter(
            array_map(&apos;trim&apos;, explode(&apos;,&apos;, $relations)),
            fn($relation) =&gt; in_array($relation, $allowedRelations),
        );
        if (!empty($relationsArray)) {
            $this-&gt;with($relationsArray);
        }
        return $this;
    }
    /**
     * Select fields safely.
     *
     * @param array|null $allowedFields
     * @param string|null $fields
     * @return $this
     */
    public function selectFields(?array $allowedFields, ?string $fields)
    {
        if (empty($fields)) {
            return $this;
        }
        $fieldsArray = array_filter(
            array_map(&apos;trim&apos;, explode(&apos;,&apos;, $fields)),
            fn($field) =&gt; in_array($field, $allowedFields),
        );
        if (!empty($fieldsArray)) {
            $this-&gt;select($fieldsArray);
        }
        return $this;
    }
    public function paginate($perPage = null, $columns = [&apos;*&apos;], $pageName = &apos;page&apos;, $page = null, $total = null)
    {
        if ($page === null) {
            $qs = request()-&gt;query(&apos;limit&apos;);
            if ($qs &amp;&amp; filter_var($qs, FILTER_VALIDATE_INT)) {
                $perPage = $qs;
            }
        }
        return parent::paginate($perPage, $columns, $pageName, $page, $total);
    }
    protected function paginator($items, $total, $perPage, $currentPage, $options)
    {
        return Container::getInstance()-&gt;makeWith(JsonPaginator::class, compact(
            &apos;items&apos;, &apos;total&apos;, &apos;perPage&apos;, &apos;currentPage&apos;, &apos;options&apos;,
        ));
    }
}</file><file path="app/Modules/FFmpeg/Drivers/InteractsWithFilters.php">&lt;?php
namespace App\Modules\FFmpeg\Drivers;
use Closure;
use FFMpeg\Coordinate\Dimension;
use FFMpeg\Filters\Audio\SimpleFilter;
use FFMpeg\Filters\FilterInterface;
use FFMpeg\Filters\Video\ResizeFilter;
use Illuminate\Support\Collection;
use App\Modules\FFmpeg\FFMpeg\LegacyFilterMapping;
use App\Modules\FFmpeg\Filters\WatermarkFactory;
trait InteractsWithFilters
{
    /**
     * @var \Illuminate\Support\Collection
     */
    protected $pendingComplexFilters;
    /**
     * Returns an array with the filters applied to the underlying media object.
     *
     * @return array
     */
    public function getFilters(): array
    {
        return iterator_to_array($this-&gt;media-&gt;getFiltersCollection());
    }
    /**
     * Helper method to provide multiple ways to add a filter to the underlying
     * media object.
     *
     * @return self
     */
    public function addFilter(): self
    {
        $arguments = func_get_args();
        // to support &apos;[in]filter[out]&apos; complex filters
        if ($this-&gt;isAdvancedMedia() &amp;&amp; count($arguments) === 3) {
            $this-&gt;media-&gt;filters()-&gt;custom(...$arguments);
            return $this;
        }
        // use a callback to add a filter
        if ($arguments[0] instanceof Closure) {
            call_user_func_array($arguments[0], [$this-&gt;media-&gt;filters()]);
            return $this;
        }
        // use an object to add a filter
        if ($arguments[0] instanceof FilterInterface) {
            call_user_func_array([$this-&gt;media, &apos;addFilter&apos;], $arguments);
            return $this;
        }
        // use a single array with parameters to define a filter
        if (is_array($arguments[0])) {
            $this-&gt;media-&gt;addFilter(new SimpleFilter($arguments[0]));
            return $this;
        }
        // use all function arguments as a filter
        $this-&gt;media-&gt;addFilter(new SimpleFilter($arguments));
        return $this;
    }
    /**
     * Calls the callable with a WatermarkFactory instance and
     * adds the freshly generated WatermarkFilter.
     *
     * @param callable $withWatermarkFactory
     * @return self
     */
    public function addWatermark(callable $withWatermarkFactory): self
    {
        $withWatermarkFactory(
            $watermarkFactory = new WatermarkFactory(),
        );
        return $this-&gt;addFilter($watermarkFactory-&gt;get());
    }
    /**
     * Shortcut for adding a Resize filter.
     *
     * @param int $width
     * @param int $height
     * @param string $mode
     * @param boolean $forceStandards
     * @return self
     */
    public function resize($width, $height, $mode = ResizeFilter::RESIZEMODE_FIT, $forceStandards = true): self
    {
        $dimension = new Dimension($width, $height);
        $filter = new ResizeFilter($dimension, $mode, $forceStandards);
        return $this-&gt;addFilter($filter);
    }
    /**
     * Maps the arguments into a &apos;LegacyFilterMapping&apos; instance and
     * pushed it to the &apos;pendingComplexFilters&apos; collection. These
     * filters will be applied later on by the MediaExporter.
     */
    public function addFilterAsComplexFilter($in, $out, ...$arguments): self
    {
        $this-&gt;pendingComplexFilters-&gt;push(new LegacyFilterMapping(
            $in,
            $out,
            ...$arguments,
        ));
        return $this;
    }
    /**
     * Getter for the pending complex filters.
     *
     * @return \Illuminate\Support\Collection
     */
    public function getPendingComplexFilters(): Collection
    {
        return $this-&gt;pendingComplexFilters;
    }
}</file><file path="app/Modules/FFmpeg/Drivers/InteractsWithMediaStreams.php">&lt;?php
namespace App\Modules\FFmpeg\Drivers;
use FFMpeg\FFProbe\DataMapping\Stream;
use Illuminate\Support\Arr;
use App\Modules\FFmpeg\Filesystem\MediaCollection;
trait InteractsWithMediaStreams
{
    /**
     * Returns an array with all streams.
     *
     * @return array
     */
    public function getStreams(): array
    {
        if (!$this-&gt;isAdvancedMedia()) {
            return iterator_to_array($this-&gt;media-&gt;getStreams());
        }
        return $this-&gt;mediaCollection-&gt;map(function ($media) {
            return $this-&gt;fresh()-&gt;open(MediaCollection::make([$media]))-&gt;getStreams();
        })-&gt;collapse()-&gt;all();
    }
    /**
     * Gets the duration of the media from the first stream or from the format.
     */
    public function getDurationInMiliseconds(): int
    {
        $stream = Arr::first($this-&gt;getStreams());
        if ($stream-&gt;has(&apos;duration&apos;)) {
            return intval(round($stream-&gt;get(&apos;duration&apos;) * 1000));
        }
        $format = $this-&gt;getFormat();
        if ($format-&gt;has(&apos;duration&apos;)) {
            return intval(round($format-&gt;get(&apos;duration&apos;) * 1000));
        }
        throw new UnknownDurationException(&apos;Could not determine the duration of the media.&apos;);
    }
    public function getDurationInSeconds(): int
    {
        return round($this-&gt;getDurationInMiliseconds() / 1000);
    }
    /**
     * Gets the first audio streams of the media.
     */
    public function getAudioStream(): ?Stream
    {
        return Arr::first($this-&gt;getStreams(), function (Stream $stream) {
            return $stream-&gt;isAudio();
        });
    }
    /**
     * Gets the first video streams of the media.
     */
    public function getVideoStream(): ?Stream
    {
        return Arr::first($this-&gt;getStreams(), function (Stream $stream) {
            return $stream-&gt;isVideo();
        });
    }
}</file><file path="app/Modules/FFmpeg/Drivers/PHPFFMpeg.php">&lt;?php
namespace App\Modules\FFmpeg\Drivers;
use Alchemy\BinaryDriver\Listeners\ListenerInterface;
use Exception;
use FFMpeg\Coordinate\TimeCode;
use FFMpeg\Driver\FFMpegDriver;
use FFMpeg\FFMpeg;
use FFMpeg\Media\{AbstractMediaType, AdvancedMedia as BaseAdvancedMedia, Audio, Concat, Frame, Video};
use Illuminate\Support\{Arr, Collection, Traits\ForwardsCalls};
use App\Modules\FFmpeg\FFMpeg\{AdvancedMedia, AudioMedia, FFProbe, VideoMedia};
use App\Modules\FFmpeg\Filesystem\MediaCollection;
/**
 * @mixin \FFMpeg\Media\AbstractMediaType
 */
class PHPFFMpeg
{
    use ForwardsCalls, InteractsWithFilters, InteractsWithMediaStreams;
    /**
     * @var \FFMpeg\FFMpeg
     */
    private $ffmpeg;
    /**
     * @var \App\Modules\FFmpeg\Filesystem\MediaCollection
     */
    private $mediaCollection;
    /**
     * @var boolean
     */
    private $forceAdvanced = false;
    /**
     * @var \FFMpeg\Media\AbstractMediaType
     */
    private $media;
    /**
     * Callbacks that should be called just before the
     * underlying library hits the save method.
     */
    private array $beforeSavingCallbacks = [];
    public function __construct(FFMpeg $ffmpeg)
    {
        $this-&gt;ffmpeg = $ffmpeg;
        $this-&gt;pendingComplexFilters = new Collection();
    }
    /**
     * Returns a fresh instance of itself with only the underlying FFMpeg instance.
     */
    public function fresh(): self
    {
        return new static($this-&gt;ffmpeg);
    }
    public function get(): AbstractMediaType
    {
        return $this-&gt;media;
    }
    private function isAdvancedMedia(): bool
    {
        return $this-&gt;get() instanceof BaseAdvancedMedia;
    }
    public function isFrame(): bool
    {
        return $this-&gt;get() instanceof Frame;
    }
    public function isConcat(): bool
    {
        return $this-&gt;get() instanceof Concat;
    }
    public function isVideo(): bool
    {
        return $this-&gt;get() instanceof Video;
    }
    public function getMediaCollection(): MediaCollection
    {
        return $this-&gt;mediaCollection;
    }
    /**
     * Opens the MediaCollection if it&apos;s not been instanciated yet.
     */
    public function open(MediaCollection $mediaCollection): self
    {
        if ($this-&gt;media) {
            return $this;
        }
        $this-&gt;mediaCollection = $mediaCollection;
        if ($mediaCollection-&gt;count() === 1 &amp;&amp; !$this-&gt;forceAdvanced) {
            $media = Arr::first($mediaCollection-&gt;collection());
            $this-&gt;ffmpeg-&gt;setFFProbe(
                FFProbe::make($this-&gt;ffmpeg-&gt;getFFProbe())-&gt;setMedia($media),
            );
            $ffmpegMedia = $this-&gt;ffmpeg-&gt;open($media-&gt;getLocalPath());
            // this should be refactored to a factory...
            if ($ffmpegMedia instanceof Video) {
                $this-&gt;media = VideoMedia::make($ffmpegMedia);
            } else if ($ffmpegMedia instanceof Audio) {
                $this-&gt;media = AudioMedia::make($ffmpegMedia);
            } else {
                $this-&gt;media = $ffmpegMedia;
            }
            if (method_exists($this-&gt;media, &apos;setHeaders&apos;)) {
                $this-&gt;media-&gt;setHeaders(Arr::first($mediaCollection-&gt;getHeaders()) ?: []);
            }
        } else {
            $ffmpegMedia = $this-&gt;ffmpeg-&gt;openAdvanced($mediaCollection-&gt;getLocalPaths());
            $this-&gt;media = AdvancedMedia::make($ffmpegMedia)-&gt;setHeaders($mediaCollection-&gt;getHeaders());
        }
        return $this;
    }
    /**
     * @throws Exception
     */
    public function frame(TimeCode $timeCode): static
    {
        if (!$this-&gt;isVideo()) {
            throw new Exception(&apos;Opened media is not a video file.&apos;);
        }
        $this-&gt;media = $this-&gt;media-&gt;frame($timeCode);
        return $this;
    }
    public function concatWithoutTranscoding(): static
    {
        $localPaths = $this-&gt;mediaCollection-&gt;getLocalPaths();
        $this-&gt;media = $this-&gt;ffmpeg-&gt;open(Arr::first($localPaths))
            -&gt;concat($localPaths);
        return $this;
    }
    /**
     * Force &apos;openAdvanced&apos; when opening the MediaCollection
     */
    public function openAdvanced(MediaCollection $mediaCollection): self
    {
        $this-&gt;forceAdvanced = true;
        return $this-&gt;open($mediaCollection);
    }
    /**
     * Returns the FFMpegDriver of the underlying library.
     *
     * @return \FFMpeg\Driver\FFMpegDriver
     */
    private function getFFMpegDriver(): FFMpegDriver
    {
        return $this-&gt;get()-&gt;getFFMpegDriver();
    }
    /**
     * Add a Listener to the underlying library.
     *
     * @param \Alchemy\BinaryDriver\Listeners\ListenerInterface $listener
     * @return self
     */
    public function addListener(ListenerInterface $listener): self
    {
        $this-&gt;getFFMpegDriver()-&gt;listen($listener);
        return $this;
    }
    /**
     * Remove the Listener from the underlying library.
     *
     * @param \Alchemy\BinaryDriver\Listeners\ListenerInterface $listener
     * @return self
     */
    public function removeListener(ListenerInterface $listener): self
    {
        $this-&gt;getFFMpegDriver()-&gt;unlisten($listener);
        return $this;
    }
    /**
     * Adds a callable to the callbacks array.
     *
     * @param callable $callback
     * @return self
     */
    public function beforeSaving(callable $callback): self
    {
        $this-&gt;beforeSavingCallbacks[] = $callback;
        return $this;
    }
    /**
     * Set the callbacks on the Media.
     *
     * @return self
     */
    public function applyBeforeSavingCallbacks(): self
    {
        $media = $this-&gt;get();
        if (method_exists($media, &apos;setBeforeSavingCallbacks&apos;)) {
            $media-&gt;setBeforeSavingCallbacks($this-&gt;beforeSavingCallbacks);
        }
        return $this;
    }
    /**
     * Add an event handler to the underlying library.
     *
     * @param string $event
     * @param callable $callback
     * @return self
     */
    public function onEvent(string $event, callable $callback): self
    {
        $this-&gt;getFFMpegDriver()-&gt;on($event, $callback);
        return $this;
    }
    /**
     * Returns the underlying media object itself.
     */
    public function __invoke(): AbstractMediaType
    {
        return $this-&gt;get();
    }
    /**
     * Forwards the call to the underling media object and returns the result
     * if it&apos;s something different from the media object itself.
     */
    public function __call($method, $arguments)
    {
        $result = $this-&gt;forwardCallTo($media = $this-&gt;get(), $method, $arguments);
        return ($result === $media) ? $this : $result;
    }
}</file><file path="app/Modules/FFmpeg/Drivers/UnknownDurationException.php">&lt;?php
namespace App\Modules\FFmpeg\Drivers;
class UnknownDurationException extends \Exception
{
}</file><file path="app/Modules/FFmpeg/Exporters/EncodingException.php">&lt;?php
namespace App\Modules\FFmpeg\Exporters;
use Alchemy\BinaryDriver\Exception\ExecutionFailureException;
use FFMpeg\Exception\RuntimeException;
class EncodingException extends RuntimeException
{
    public static function decorate(RuntimeException $runtimeException): EncodingException
    {
        return tap(new static(
            $runtimeException-&gt;getMessage(),
            $runtimeException-&gt;getCode(),
            $runtimeException-&gt;getPrevious(),
        ), function (self $exception) {
            if (config(&apos;laravel-ffmpeg.set_command_and_error_output_on_exception&apos;, true)) {
                $exception-&gt;message = $exception-&gt;getAlchemyException()?-&gt;getMessage() ?: &quot;&quot;;
            }
        });
    }
    public function getCommand(): ?string
    {
        return $this-&gt;getAlchemyException()?-&gt;getCommand();
    }
    public function getErrorOutput(): ?string
    {
        return $this-&gt;getAlchemyException()?-&gt;getErrorOutput();
    }
    public function getAlchemyException(): ?ExecutionFailureException
    {
        return $this-&gt;getPrevious();
    }
}</file><file path="app/Modules/FFmpeg/Exporters/EncryptsHLSSegments.php">&lt;?php
namespace App\Modules\FFmpeg\Exporters;
use Closure;
use Illuminate\Filesystem\Filesystem;
use Illuminate\Support\Collection;
use App\Modules\FFmpeg\FFMpeg\StdListener;
use App\Modules\FFmpeg\Filesystem\{Disk, TemporaryDirectories};
trait EncryptsHLSSegments
{
    /**
     * The encryption key.
     *
     * @var string
     */
    private $encryptionKey;
    /**
     * The encryption key filename.
     *
     * @var string
     */
    private $encryptionKeyFilename;
    /**
     * Gets called whenever a new encryption key is set.
     *
     * @var callable
     */
    private $onNewEncryptionKey;
    /**
     * Disk to store the secrets.
     */
    private $encryptionSecretsRoot;
    /**
     * Encryption IV
     *
     * @var string
     */
    private $encryptionIV;
    /**
     * Wether to rotate the key on every segment.
     *
     * @var boolean
     */
    private $rotateEncryptiongKey = false;
    /**
     * Number of opened segments.
     *
     * @var integer
     */
    private $segmentsOpened = 0;
    /**
     * Number of segments that can use the same key.
     *
     * @var integer
     */
    private $segmentsPerKey = 1;
    /**
     * Listener that will rotate the key.
     *
     * @var \App\Modules\FFmpeg\FFMpeg\StdListener
     */
    private $listener;
    /**
     * A fresh filename and encryption key for the next round.
     *
     * @var array
     */
    private $nextEncryptionFilenameAndKey;
    /**
     * Creates a new encryption key.
     *
     * @return string
     */
    public static function generateEncryptionKey(): string
    {
        return random_bytes(16);
    }
    /**
     * Creates a new encryption key filename.
     *
     * @return string
     */
    public static function generateEncryptionKeyFilename(): string
    {
        return bin2hex(random_bytes(8)) . &apos;.key&apos;;
    }
    /**
     * Initialises the disk, info and IV for encryption and sets the key.
     *
     * @param string $key
     * @param string $filename
     * @return self
     */
    public function withEncryptionKey($key, $filename = &apos;secret.key&apos;): self
    {
        $this-&gt;encryptionKey = $key;
        $this-&gt;encryptionIV = bin2hex(static::generateEncryptionKey());
        $this-&gt;encryptionKeyFilename = $filename;
        $this-&gt;encryptionSecretsRoot = (new TemporaryDirectories(
            config(&apos;laravel-ffmpeg.temporary_files_encrypted_hls&apos;, sys_get_temp_dir()),
        ))-&gt;create();
        return $this;
    }
    /**
     * Enables encryption with rotating keys. The callable will receive every new
     * key and the integer sets the number of segments that can
     * use the same key.
     *
     * @param Closure $callback
     * @param int $segmentsPerKey
     * @return self
     */
    public function withRotatingEncryptionKey(Closure $callback, int $segmentsPerKey = 1): self
    {
        $this-&gt;rotateEncryptiongKey = true;
        $this-&gt;onNewEncryptionKey = $callback;
        $this-&gt;segmentsPerKey = $segmentsPerKey;
        return $this-&gt;withEncryptionKey(null, null);
    }
    /**
     * Rotates the key and returns the absolute path to the info file. This method
     * should be executed as fast as possible, or we might be too late for FFmpeg
     * opening the next segment. That&apos;s why we don&apos;t use the Disk-class magic.
     *
     * @return string
     */
    private function rotateEncryptionKey(): string
    {
        if ($this-&gt;nextEncryptionFilenameAndKey) {
            [$keyFilename, $encryptionKey] = $this-&gt;nextEncryptionFilenameAndKey;
        } else {
            $keyFilename = $this-&gt;encryptionKeyFilename ?: static::generateEncryptionKeyFilename();
            $encryptionKey = $this-&gt;encryptionKey ?: static::generateEncryptionKey();
        }
        // get the absolute path to the info file and encryption key
        $hlsKeyInfoPath = $this-&gt;encryptionSecretsRoot . &apos;/&apos; . HLSExporter::HLS_KEY_INFO_FILENAME;
        $keyPath = $this-&gt;encryptionSecretsRoot . &apos;/&apos; . $keyFilename;
        $normalizedKeyPath = Disk::normalizePath($keyPath);
        // store the encryption key
        file_put_contents($keyPath, $encryptionKey);
        // store an info file with a reference to the encryption key and IV
        file_put_contents(
            $hlsKeyInfoPath,
            $normalizedKeyPath . PHP_EOL . $normalizedKeyPath . PHP_EOL . $this-&gt;encryptionIV,
        );
        // prepare for the next round
        if ($this-&gt;rotateEncryptiongKey) {
            $this-&gt;nextEncryptionFilenameAndKey = [
                static::generateEncryptionKeyFilename(),
                static::generateEncryptionKey(),
            ];
        }
        // call the callback
        if ($this-&gt;onNewEncryptionKey) {
            call_user_func($this-&gt;onNewEncryptionKey, $keyFilename, $encryptionKey, $this-&gt;listener);
        }
        // return the absolute path to the info file
        return Disk::normalizePath($hlsKeyInfoPath);
    }
    /**
     * Returns an array with the encryption parameters.
     *
     * @return array
     */
    private function getEncrypedHLSParameters(): array
    {
        if (!$this-&gt;encryptionIV) {
            return [];
        }
        $keyInfoPath = $this-&gt;rotateEncryptionKey();
        $parameters = [&apos;-hls_key_info_file&apos;, $keyInfoPath];
        if ($this-&gt;rotateEncryptiongKey) {
            $parameters[] = &apos;-hls_flags&apos;;
            $parameters[] = &apos;periodic_rekey&apos;;
        }
        return $parameters;
    }
    /**
     * Adds a listener and handler to rotate the key on
     * every new HLS segment.
     *
     * @return void
     */
    private function addHandlerToRotateEncryptionKey()
    {
        if (!$this-&gt;rotateEncryptiongKey) {
            return;
        }
        $this-&gt;listener = new StdListener(HLSExporter::ENCRYPTION_LISTENER);
        $this-&gt;addListener($this-&gt;listener)
            -&gt;onEvent(HLSExporter::ENCRYPTION_LISTENER, function ($line) {
                if (!strpos($line, &quot;.keyinfo&apos; for reading&quot;)) {
                    return;
                }
                $this-&gt;segmentsOpened++;
                if ($this-&gt;segmentsOpened % $this-&gt;segmentsPerKey === 0) {
                    $this-&gt;rotateEncryptionKey();
                }
            });
    }
    /**
     * Remove the listener at the end of the export to
     * prevent duplicate event handlers.
     *
     * @return self
     */
    private function removeHandlerThatRotatesEncryptionKey(): self
    {
        if ($this-&gt;listener) {
            $this-&gt;listener-&gt;removeAllListeners();
            $this-&gt;removeListener($this-&gt;listener);
            $this-&gt;listener = null;
            $this-&gt;getFFMpegDriver()-&gt;removeAllListeners(HLSExporter::ENCRYPTION_LISTENER);
        }
        return $this;
    }
    /**
     * While encoding, the encryption keys are saved to a temporary directory.
     * With this method, we loop through all segment playlists and replace
     * the absolute path to the keys to a relative ones.
     *
     * @param \Illuminate\Support\Collection $playlistMedia
     * @return self
     */
    private function replaceAbsolutePathsHLSEncryption(Collection $playlistMedia): self
    {
        if (!$this-&gt;encryptionSecretsRoot) {
            return $this;
        }
        $playlistMedia-&gt;each(function ($playlistMedia) {
            $disk = $playlistMedia-&gt;getDisk();
            $path = $playlistMedia-&gt;getPath();
            $prefix = &apos;#EXT-X-KEY:METHOD=AES-128,URI=&quot;&apos;;
            $content = str_replace(
                $prefix . Disk::normalizePath($this-&gt;encryptionSecretsRoot) . &apos;/&apos;,
                $prefix,
                $disk-&gt;get($path),
            );
            $disk-&gt;put($path, $content);
        });
        return $this;
    }
    /**
     * Removes the encryption keys from the temporary disk.
     *
     * @return self
     */
    private function cleanupHLSEncryption(): self
    {
        if ($this-&gt;encryptionSecretsRoot) {
            (new Filesystem())-&gt;deleteDirectory($this-&gt;encryptionSecretsRoot);
        }
        return $this;
    }
}</file><file path="app/Modules/FFmpeg/Exporters/HandlesAdvancedMedia.php">&lt;?php
namespace App\Modules\FFmpeg\Exporters;
use FFMpeg\Format\FormatInterface;
use App\Modules\FFmpeg\FFMpeg\AdvancedOutputMapping;
use App\Modules\FFmpeg\Filesystem\Media;
trait HandlesAdvancedMedia
{
    /**
     * @var \Illuminate\Support\Collection
     */
    protected $maps;
    public function addFormatOutputMapping(FormatInterface $format, Media $output, array $outs, $forceDisableAudio = false, $forceDisableVideo = false)
    {
        $this-&gt;maps-&gt;push(
            new AdvancedOutputMapping($outs, $format, $output, $forceDisableAudio, $forceDisableVideo),
        );
        return $this;
    }
}</file><file path="app/Modules/FFmpeg/Exporters/HandlesConcatenation.php">&lt;?php
namespace App\Modules\FFmpeg\Exporters;
use App\Modules\FFmpeg\Filesystem\Media;
trait HandlesConcatenation
{
    /**
     * @var boolean
     */
    protected $concatWithTranscoding = false;
    /**
     * @var boolean
     */
    protected $concatWithVideo = false;
    /**
     * @var boolean
     */
    protected $concatWithAudio = false;
    public function concatWithTranscoding(bool $hasVideo = true, bool $hasAudio = true): self
    {
        $this-&gt;concatWithTranscoding = true;
        $this-&gt;concatWithVideo = $hasVideo;
        $this-&gt;concatWithAudio = $hasAudio;
        return $this;
    }
    private function addConcatFilterAndMapping(Media $outputMedia)
    {
        $sources = $this-&gt;driver-&gt;getMediaCollection()-&gt;map(function ($media, $key) {
            return &quot;[{$key}]&quot;;
        });
        $concatWithVideo = $this-&gt;concatWithVideo ? 1 : 0;
        $concatWithAudio = $this-&gt;concatWithAudio ? 1 : 0;
        $this-&gt;addFilter(
            $sources-&gt;implode(&apos;&apos;),
            &quot;concat=n={$sources-&gt;count()}:v={$concatWithVideo}:a={$concatWithAudio}&quot;,
            &apos;[concat]&apos;,
        )-&gt;addFormatOutputMapping($this-&gt;format, $outputMedia, [&apos;[concat]&apos;]);
    }
}</file><file path="app/Modules/FFmpeg/Exporters/HandlesFrames.php">&lt;?php
namespace App\Modules\FFmpeg\Exporters;
trait HandlesFrames
{
    /**
     * @var boolean
     */
    protected $mustBeAccurate = false;
    /**
     * @var boolean
     */
    protected $returnFrameContents = false;
    public function accurate(): self
    {
        $this-&gt;mustBeAccurate = true;
        return $this;
    }
    public function unaccurate(): self
    {
        $this-&gt;mustBeAccurate = false;
        return $this;
    }
    public function getAccuracy(): bool
    {
        return $this-&gt;mustBeAccurate;
    }
    public function getFrameContents(): string
    {
        $this-&gt;returnFrameContents = true;
        return $this-&gt;save();
    }
}</file><file path="app/Modules/FFmpeg/Exporters/HandlesTimelapse.php">&lt;?php
namespace App\Modules\FFmpeg\Exporters;
trait HandlesTimelapse
{
    /**
     * @var float
     */
    protected $timelapseFramerate;
    public function asTimelapseWithFramerate(float $framerate): self
    {
        $this-&gt;timelapseFramerate = $framerate;
        return $this;
    }
    protected function addTimelapseParametersToFormat()
    {
        $this-&gt;format-&gt;setInitialParameters(array_merge(
            $this-&gt;format-&gt;getInitialParameters() ?: [],
            [&apos;-framerate&apos;, $this-&gt;timelapseFramerate, &apos;-f&apos;, &apos;image2&apos;],
        ));
    }
}</file><file path="app/Modules/FFmpeg/Exporters/HasProgressListener.php">&lt;?php
namespace App\Modules\FFmpeg\Exporters;
use Closure;
use Evenement\EventEmitterInterface;
trait HasProgressListener
{
    /**
     * @var \Closure
     */
    protected $onProgressCallback;
    /**
     * @var float
     */
    protected $lastPercentage;
    /**
     * @var float
     */
    protected $lastRemaining = 0;
    /**
     * Setter for the callback.
     *
     * @param Closure $callback
     * @return self
     */
    public function onProgress(Closure $callback): self
    {
        $this-&gt;onProgressCallback = $callback;
        return $this;
    }
    /**
     * Only calls the callback if the percentage is below 100 and is different
     * from the previous emitted percentage.
     *
     * @param \Evenement\EventEmitterInterface $format
     * @return void
     */
    private function applyProgressListenerToFormat(EventEmitterInterface $format)
    {
        $format-&gt;removeAllListeners(&apos;progress&apos;);
        $format-&gt;on(&apos;progress&apos;, function ($media, $format, $percentage, $remaining = null, $rate = null) {
            if ($percentage !== $this-&gt;lastPercentage &amp;&amp; $percentage &lt; 100) {
                $this-&gt;lastPercentage = $percentage;
                $this-&gt;lastRemaining = $remaining ?: $this-&gt;lastRemaining;
                call_user_func($this-&gt;onProgressCallback, $this-&gt;lastPercentage, $this-&gt;lastRemaining, $rate);
            }
        });
    }
}</file><file path="app/Modules/FFmpeg/Exporters/HLSExporter.php">&lt;?php
namespace App\Modules\FFmpeg\Exporters;
use Closure;
use FFMpeg\Format\{Audio\DefaultAudio, AudioInterface, FormatInterface, Video\DefaultVideo};
use Illuminate\Support\Collection;
use App\Modules\FFmpeg\Filesystem\{Disk, Media};
use App\Modules\FFmpeg\MediaOpener;
class HLSExporter extends MediaExporter
{
    use EncryptsHLSSegments;
    public const HLS_KEY_INFO_FILENAME = &apos;hls_encryption.keyinfo&apos;;
    public const ENCRYPTION_LISTENER = &quot;listen-encryption-key&quot;;
    /**
     * @var integer
     */
    private $segmentLength = 10;
    /**
     * @var integer
     */
    private $keyFrameInterval = 48;
    /**
     * @var \Illuminate\Support\Collection
     */
    private $pendingFormats;
    /**
     * @var \App\Modules\FFmpeg\Exporters\PlaylistGenerator
     */
    private $playlistGenerator;
    /**
     * @var \Closure
     */
    private $segmentFilenameGenerator = null;
    /**
     * Setter for the segment length
     *
     * @param integer $length
     * @return self
     */
    public function setSegmentLength(int $length): self
    {
        $this-&gt;segmentLength = max(2, $length);
        return $this;
    }
    /**
     * Setter for the Key Frame interval
     *
     * @param integer $interval
     * @return self
     */
    public function setKeyFrameInterval(int $interval): self
    {
        $this-&gt;keyFrameInterval = max(2, $interval);
        return $this;
    }
    /**
     * Method to set a different playlist generator than
     * the default HLSPlaylistGenerator.
     *
     * @param \App\Modules\FFmpeg\Exporters\PlaylistGenerator $playlistGenerator
     * @return self
     */
    public function withPlaylistGenerator(PlaylistGenerator $playlistGenerator): self
    {
        $this-&gt;playlistGenerator = $playlistGenerator;
        return $this;
    }
    private function getPlaylistGenerator(): PlaylistGenerator
    {
        return $this-&gt;playlistGenerator ?: new HLSPlaylistGenerator();
    }
    /**
     * Setter for a callback that generates a segment filename.
     *
     * @param Closure $callback
     * @return self
     */
    public function useSegmentFilenameGenerator(Closure $callback): self
    {
        $this-&gt;segmentFilenameGenerator = $callback;
        return $this;
    }
    /**
     * Returns a default generator if none is set.
     *
     * @return callable
     */
    private function getSegmentFilenameGenerator(): callable
    {
        return $this-&gt;segmentFilenameGenerator
            ?: function ($name, $format, $key, $segments, $playlist) {
                $bitrate = $this-&gt;driver-&gt;getVideoStream()
                    ? $format-&gt;getKiloBitrate()
                    : $format-&gt;getAudioKiloBitrate();
                $segments(&quot;{$name}_{$key}_{$bitrate}_%05d.ts&quot;);
                $playlist(&quot;{$name}_{$key}_{$bitrate}.m3u8&quot;);
            };
    }
    /**
     * Calls the generator with the path (without extension), format and key.
     *
     * @param string $baseName
     * @param \FFMpeg\Format\AudioInterface $format
     * @param integer $key
     * @return array
     */
    private function getSegmentPatternAndFormatPlaylistPath(string $baseName, AudioInterface $format, int $key): array
    {
        $segmentsPattern = null;
        $formatPlaylistPath = null;
        call_user_func(
            $this-&gt;getSegmentFilenameGenerator(),
            $baseName,
            $format,
            $key,
            function ($path) use (&amp;$segmentsPattern) {
                $segmentsPattern = $path;
            },
            function ($path) use (&amp;$formatPlaylistPath) {
                $formatPlaylistPath = $path;
            },
        );
        return [$segmentsPattern, $formatPlaylistPath];
    }
    /**
     * Merges the HLS parameters to the given format.
     *
     * @param \FFMpeg\Format\Video\DefaultAudio $format
     * @param string $segmentsPattern
     * @param \App\Modules\FFmpeg\Filesystem\Disk $disk
     * @param integer $key
     * @return array
     */
    private function addHLSParametersToFormat(DefaultAudio $format, string $segmentsPattern, Disk $disk, int $key): array
    {
        $format-&gt;setAdditionalParameters(array_merge(
            $format-&gt;getAdditionalParameters() ?: [],
            $hlsParameters = [
                &apos;-sc_threshold&apos;,
                &apos;0&apos;,
                &apos;-g&apos;,
                $this-&gt;keyFrameInterval,
                &apos;-hls_playlist_type&apos;,
                &apos;vod&apos;,
                &apos;-hls_time&apos;,
                $this-&gt;segmentLength,
                &apos;-hls_segment_filename&apos;,
                $disk-&gt;makeMedia($segmentsPattern)-&gt;getLocalPath(),
                &apos;-master_pl_name&apos;,
                $this-&gt;generateTemporarySegmentPlaylistFilename($key),
            ],
            $this-&gt;getEncrypedHLSParameters(),
        ));
        return $hlsParameters;
    }
    /**
     * Gives the callback an HLSVideoFilters object that provides addFilter(),
     * addLegacyFilter(), addWatermark() and resize() helper methods. It
     * returns a mapping for the video and (optional) audio stream.
     *
     * @param callable $filtersCallback
     * @param integer $formatKey
     * @return array
     */
    private function applyFiltersCallback(callable $filtersCallback, int $formatKey): array
    {
        $filtersCallback(
            $hlsVideoFilters = new HLSVideoFilters($this-&gt;driver, $formatKey),
        );
        $filterCount = $hlsVideoFilters-&gt;count();
        $outs = [$filterCount ? HLSVideoFilters::glue($formatKey, $filterCount) : &apos;0:v&apos;];
        if ($this-&gt;getAudioStream()) {
            $outs[] = &apos;0:a&apos;;
        }
        return $outs;
    }
    /**
     * Returns the filename of a segment playlist by its key. We let FFmpeg generate a playlist
     * for each added format so we don&apos;t have to detect the bitrate and codec ourselves.
     * We use this as a reference so when can generate our own main playlist.
     *
     * @param int $key
     * @return string
     */
    public static function generateTemporarySegmentPlaylistFilename(int $key): string
    {
        return &quot;temporary_segment_playlist_{$key}.m3u8&quot;;
    }
    /**
     * Loops through each added format and then deletes the temporary
     * segment playlist, which we generate manually using the
     * HLSPlaylistGenerator.
     *
     * @param \App\Modules\FFmpeg\Filesystem\Media $media
     * @return self
     */
    private function cleanupSegmentPlaylistGuides(Media $media): self
    {
        $disk = $media-&gt;getDisk();
        $directory = $media-&gt;getDirectory();
        $this-&gt;pendingFormats-&gt;map(function ($formatAndCallback, $key) use ($disk, $directory) {
            $disk-&gt;delete($directory . static::generateTemporarySegmentPlaylistFilename($key));
        });
        return $this;
    }
    /**
     * Adds a mapping for each added format and automatically handles the mapping
     * for filters. Adds a handler to rotate the encryption key (optional).
     * Returns a media collection of all segment playlists.
     *
     * @param string $path
     * @return \Illuminate\Support\Collection
     * @throws \App\Modules\FFmpeg\Exporters\NoFormatException
     */
    private function prepareSaving(string $path = null): Collection
    {
        if (!$this-&gt;pendingFormats) {
            throw new NoFormatException();
        }
        $media = $this-&gt;getDisk()-&gt;makeMedia($path);
        $baseName = $media-&gt;getDirectory() . $media-&gt;getFilenameWithoutExtension();
        return $this-&gt;pendingFormats-&gt;map(function (array $formatAndCallback, $key) use ($baseName) {
            [$format, $filtersCallback] = $formatAndCallback;
            [$segmentsPattern, $formatPlaylistPath] = $this-&gt;getSegmentPatternAndFormatPlaylistPath(
                $baseName,
                $format,
                $key,
            );
            $disk = $this-&gt;getDisk()-&gt;clone();
            $this-&gt;addHLSParametersToFormat($format, $segmentsPattern, $disk, $key);
            if ($filtersCallback) {
                $outs = $this-&gt;applyFiltersCallback($filtersCallback, $key);
            }
            $formatPlaylistOutput = $disk-&gt;makeMedia($formatPlaylistPath);
            $this-&gt;addFormatOutputMapping($format, $formatPlaylistOutput, $outs ?? [&apos;0&apos;]);
            return $formatPlaylistOutput;
        })-&gt;tap(function () {
            $this-&gt;addHandlerToRotateEncryptionKey();
        });
    }
    /**
     * Prepares the saves command but returns the command instead.
     *
     * @param string $path
     * @return mixed
     */
    public function getCommand(string $path = null)
    {
        $this-&gt;prepareSaving($path);
        return parent::getCommand(null);
    }
    /**
     * Runs the export, generates the main playlist, and cleans up the
     * segment playlist guides and temporary HLS encryption keys.
     *
     * @param string $path
     * @return \App\Modules\FFmpeg\MediaOpener
     */
    public function save(string $mainPlaylistPath = null): MediaOpener
    {
        return $this-&gt;prepareSaving($mainPlaylistPath)-&gt;pipe(function ($segmentPlaylists) use ($mainPlaylistPath) {
            $result = parent::save();
            $playlist = $this-&gt;getPlaylistGenerator()-&gt;get(
                $segmentPlaylists-&gt;all(),
                $this-&gt;driver-&gt;fresh(),
            );
            $this-&gt;getDisk()-&gt;put($mainPlaylistPath, $playlist);
            $this-&gt;replaceAbsolutePathsHLSEncryption($segmentPlaylists)
                -&gt;cleanupSegmentPlaylistGuides($segmentPlaylists-&gt;first())
                -&gt;cleanupHLSEncryption()
                -&gt;removeHandlerThatRotatesEncryptionKey();
            return $result;
        });
    }
    /**
     * Initializes the $pendingFormats property when needed and adds the format
     * with the optional callback to add filters.
     *
     * @param \FFMpeg\Format\FormatInterface $format
     * @param callable $filtersCallback
     * @return self
     */
    public function addFormat(FormatInterface $format, callable $filtersCallback = null): self
    {
        if (!$this-&gt;pendingFormats) {
            $this-&gt;pendingFormats = new Collection();
        }
        if (!$format instanceof DefaultVideo &amp;&amp; $format instanceof DefaultAudio) {
            $originalFormat = clone $format;
            $format = new class () extends DefaultVideo {
                private array $audioCodecs = [];
                public function setAvailableAudioCodecs(array $audioCodecs)
                {
                    $this-&gt;audioCodecs = $audioCodecs;
                }
                public function getAvailableAudioCodecs(): array
                {
                    return $this-&gt;audioCodecs;
                }
                public function supportBFrames()
                {
                    return false;
                }
                public function getAvailableVideoCodecs()
                {
                    return [];
                }
            };
            $format-&gt;setAvailableAudioCodecs($originalFormat-&gt;getAvailableAudioCodecs());
            $format-&gt;setAudioCodec($originalFormat-&gt;getAudioCodec());
            $format-&gt;setAudioKiloBitrate($originalFormat-&gt;getAudioKiloBitrate());
            if ($originalFormat-&gt;getAudioChannels()) {
                $format-&gt;setAudioChannels($originalFormat-&gt;getAudioChannels());
            }
        }
        $this-&gt;pendingFormats-&gt;push([$format, $filtersCallback]);
        return $this;
    }
}</file><file path="app/Modules/FFmpeg/Exporters/HLSPlaylistGenerator.php">&lt;?php
namespace App\Modules\FFmpeg\Exporters;
use Illuminate\Support\Collection;
use App\Modules\FFmpeg\Drivers\PHPFFMpeg;
use App\Modules\FFmpeg\Filesystem\Media;
use App\Modules\FFmpeg\Http\DynamicHLSPlaylist;
use App\Modules\FFmpeg\MediaOpener;
use App\Modules\FFmpeg\Support\StreamParser;
class HLSPlaylistGenerator implements PlaylistGenerator
{
    public const string PLAYLIST_START = &apos;#EXTM3U&apos;;
    public const string PLAYLIST_END = &apos;#EXT-X-ENDLIST&apos;;
    /**
     * Return the line from the master playlist that references the given segment playlist.
     *
     * @param Media $segmentPlaylistMedia
     * @param string $key
     * @return string
     */
    private function getStreamInfoLine(Media $segmentPlaylistMedia, string $key): string
    {
        $segmentPlaylist = $segmentPlaylistMedia-&gt;getDisk()-&gt;get(
            $segmentPlaylistMedia-&gt;getDirectory() . HLSExporter::generateTemporarySegmentPlaylistFilename($key),
        );
        $lines = DynamicHLSPlaylist::parseLines($segmentPlaylist)-&gt;filter();
        return $lines-&gt;get($lines-&gt;search($segmentPlaylistMedia-&gt;getFilename()) - 1);
    }
    /**
     * Loops through all segment playlists and generates a main playlist. It finds
     * the relative paths to the segment playlists and adds the framerate when
     * to each playlist.
     *
     * @param array $segmentPlaylists
     * @param \App\Modules\FFmpeg\Drivers\PHPFFMpeg $driver
     * @return string
     */
    public function get(array $segmentPlaylists, PHPFFMpeg $driver): string
    {
        return Collection::make($segmentPlaylists)-&gt;map(function (Media $segmentPlaylist, $key) use ($driver) {
            $streamInfoLine = $this-&gt;getStreamInfoLine($segmentPlaylist, $key);
            $media = (new MediaOpener($segmentPlaylist-&gt;getDisk(), $driver))
                -&gt;openWithInputOptions($segmentPlaylist-&gt;getPath(), [&apos;-allowed_extensions&apos;, &apos;ALL&apos;]);
            if ($media-&gt;getVideoStream()) {
                if ($frameRate = StreamParser::new($media-&gt;getVideoStream())-&gt;getFrameRate()) {
                    $streamInfoLine .= &quot;,FRAME-RATE={$frameRate}&quot;;
                }
            }
            return [$streamInfoLine, $segmentPlaylist-&gt;getFilename()];
        })-&gt;collapse()
            -&gt;prepend(static::PLAYLIST_START)
            -&gt;push(static::PLAYLIST_END)
            -&gt;implode(PHP_EOL);
    }
}</file><file path="app/Modules/FFmpeg/Exporters/HLSVideoFilters.php">&lt;?php
namespace App\Modules\FFmpeg\Exporters;
use FFMpeg\Coordinate\Dimension;
use FFMpeg\Filters\AdvancedMedia\ComplexFilters;
use FFMpeg\Filters\Video\ResizeFilter;
use Illuminate\Support\Str;
use App\Modules\FFmpeg\Drivers\PHPFFMpeg;
use App\Modules\FFmpeg\Filters\WatermarkFactory;
class HLSVideoFilters
{
    public const string MAPPING_GLUE = &quot;_hls_&quot;;
    /**
     * @var \App\Modules\FFmpeg\Drivers\PHPFFMpeg
     */
    private $driver;
    /**
     * Key of the video in the HLS export.
     *
     * @var int
     */
    private $formatKey;
    /**
     * Number of filters added to this video.
     *
     * @var integer
     */
    private $filterCount = 0;
    public function __construct(PHPFFMpeg $driver, int $formatKey)
    {
        $this-&gt;driver = $driver;
        $this-&gt;formatKey = $formatKey;
    }
    public function count(): int
    {
        return $this-&gt;filterCount;
    }
    private function increaseFilterCount(): self
    {
        $this-&gt;filterCount++;
        return $this;
    }
    /**
     * Generates an input mapping for a new filter.
     *
     * @return string
     */
    private function input(): string
    {
        return $this-&gt;filterCount ? static::glue($this-&gt;formatKey, $this-&gt;filterCount) : &apos;[0]&apos;;
    }
    /**
     * Generates an output mapping for a new filter.
     *
     * @return string
     */
    private function output(): string
    {
        return static::glue($this-&gt;formatKey, $this-&gt;filterCount + 1);
    }
    /**
     * Adds a filter as a complex filter.
     */
    public function addLegacyFilter(...$arguments): self
    {
        $this-&gt;driver-&gt;addFilterAsComplexFilter($this-&gt;input(), $this-&gt;output(), ...$arguments);
        return $this-&gt;increaseFilterCount();
    }
    /**
     * Shortcut for the ResizeFilter.
     *
     * @param int $width
     * @param int $height
     * @param string $mode
     * @param boolean $forceStandards
     * @return self
     */
    public function resize($width, $height, $mode = ResizeFilter::RESIZEMODE_FIT, $forceStandards = true): self
    {
        $dimension = new Dimension($width, $height);
        $filter = new ResizeFilter($dimension, $mode, $forceStandards);
        return $this-&gt;addLegacyFilter($filter);
    }
    /**
     * Shortcut for the WatermarkFactory.
     *
     * @param callable $withWatermarkFactory
     * @return self
     */
    public function addWatermark(callable $withWatermarkFactory): self
    {
        $withWatermarkFactory($watermarkFactory = new WatermarkFactory());
        return $this-&gt;addLegacyFilter($watermarkFactory-&gt;get());
    }
    /**
     * Adds a scale filter to the video, will be replaced in favor of resize().
     *
     * @param int $width
     * @param int $height
     * @return self
     * @deprecated 7.4.0
     */
    public function scale($width, $height): self
    {
        return $this-&gt;addFilter(&quot;scale={$width}:{$height}&quot;);
    }
    /**
     * Adds a filter object or a callable to the driver and automatically
     * chooses the right input and output mapping.
     */
    public function addFilter(...$arguments): self
    {
        if (count($arguments) === 1 &amp;&amp; !is_callable($arguments[0])) {
            $this-&gt;driver-&gt;addFilter($this-&gt;input(), $arguments[0], $this-&gt;output());
        } else {
            $this-&gt;driver-&gt;addFilter(function (ComplexFilters $filters) use ($arguments) {
                $arguments[0]($filters, $this-&gt;input(), $this-&gt;output());
            });
        }
        return $this-&gt;increaseFilterCount();
    }
    public static function glue($format, $filter): string
    {
        return &quot;[v{$format}&quot; . static::MAPPING_GLUE . &quot;{$filter}]&quot;;
    }
    public static function beforeGlue($input): string
    {
        return Str::before($input, static::MAPPING_GLUE);
    }
}</file><file path="app/Modules/FFmpeg/Exporters/MediaExporter.php">&lt;?php
namespace App\Modules\FFmpeg\Exporters;
use FFMpeg\Exception\RuntimeException;
use FFMpeg\Format\FormatInterface;
use Illuminate\Support\Collection;
use Illuminate\Support\Traits\ForwardsCalls;
use App\Modules\FFmpeg\Drivers\PHPFFMpeg;
use App\Modules\FFmpeg\FFMpeg\{NullFormat, StdListener};
use App\Modules\FFmpeg\Filesystem\{Disk, Media};
use App\Modules\FFmpeg\Filters\TileFactory;
use App\Modules\FFmpeg\MediaOpener;
use App\Modules\FFmpeg\Support\ProcessOutput;
/**
 * @mixin \App\Modules\FFmpeg\Drivers\PHPFFMpeg
 */
class MediaExporter
{
    use ForwardsCalls, HandlesAdvancedMedia, HandlesConcatenation, HandlesFrames, HandlesTimelapse, HasProgressListener;
    /**
     * @var \App\Modules\FFmpeg\Drivers\PHPFFMpeg
     */
    protected $driver;
    /**
     * @var \FFMpeg\Format\FormatInterface
     */
    private $format;
    /**
     * @var string
     */
    protected $visibility;
    /**
     * @var \App\Modules\FFmpeg\Filesystem\Disk
     */
    private $toDisk;
    /**
     * Callbacks that should be called directly after the
     * underlying library completed the save method.
     *
     * @var array
     */
    private $afterSavingCallbacks = [];
    public function __construct(PHPFFMpeg $driver)
    {
        $this-&gt;driver = $driver;
        $this-&gt;maps = new Collection();
    }
    protected function getDisk(): Disk
    {
        if ($this-&gt;toDisk) {
            return $this-&gt;toDisk;
        }
        $media = $this-&gt;driver-&gt;getMediaCollection();
        /** @var Disk $disk */
        $disk = $media-&gt;first()-&gt;getDisk();
        return $this-&gt;toDisk = $disk-&gt;clone();
    }
    public function inFormat(FormatInterface $format): self
    {
        $this-&gt;format = $format;
        return $this;
    }
    public function toDisk($disk)
    {
        $this-&gt;toDisk = Disk::make($disk);
        return $this;
    }
    public function withVisibility(string $visibility)
    {
        $this-&gt;visibility = $visibility;
        return $this;
    }
    /**
     * Calls the callable with a TileFactory instance and
     * adds the freshly generated TileFilter.
     *
     * @param callable $withTileFactory
     * @return self
     */
    public function addTileFilter(callable $withTileFactory): self
    {
        $withTileFactory(
            $tileFactory = new TileFactory(),
        );
        $this-&gt;addFilter($filter = $tileFactory-&gt;get());
        if (!$tileFactory-&gt;vttOutputPath) {
            return $this;
        }
        return $this-&gt;afterSaving(function (MediaExporter $mediaExporter, Media $outputMedia) use ($filter, $tileFactory) {
            $generator = new VTTPreviewThumbnailsGenerator(
                $filter,
                $mediaExporter-&gt;driver-&gt;getDurationInSeconds(),
                $tileFactory-&gt;vttSequenceFilename ?: fn() =&gt; $outputMedia-&gt;getPath(),
            );
            $this-&gt;toDisk-&gt;put($tileFactory-&gt;vttOutputPath, $generator-&gt;getContents());
        });
    }
    /**
     * Returns the final command, useful for debugging purposes.
     *
     * @param string $path
     * @return mixed
     */
    public function getCommand(string $path = null)
    {
        $media = $this-&gt;prepareSaving($path);
        return $this-&gt;driver-&gt;getFinalCommand(
            $this-&gt;format ?: new NullFormat(),
            optional($media)-&gt;getLocalPath() ?: &apos;/dev/null&apos;,
        );
    }
    /**
     * Dump the final command and end the script.
     *
     * @param string $path
     * @return void
     */
    public function dd(string $path = null)
    {
        dd($this-&gt;getCommand($path));
    }
    /**
     * Adds a callable to the callbacks array.
     *
     * @param callable $callback
     * @return self
     */
    public function afterSaving(callable $callback): self
    {
        $this-&gt;afterSavingCallbacks[] = $callback;
        return $this;
    }
    private function prepareSaving(string $path = null): ?Media
    {
        $outputMedia = $path ? $this-&gt;getDisk()-&gt;makeMedia($path) : null;
        if ($this-&gt;concatWithTranscoding &amp;&amp; $outputMedia) {
            $this-&gt;addConcatFilterAndMapping($outputMedia);
        }
        if ($this-&gt;maps-&gt;isNotEmpty()) {
            $this-&gt;driver-&gt;getPendingComplexFilters()-&gt;each-&gt;apply($this-&gt;driver, $this-&gt;maps);
            $this-&gt;maps-&gt;map-&gt;apply($this-&gt;driver-&gt;get());
            return $outputMedia;
        }
        if ($this-&gt;format &amp;&amp; $this-&gt;onProgressCallback) {
            $this-&gt;applyProgressListenerToFormat($this-&gt;format);
        }
        if ($this-&gt;timelapseFramerate &gt; 0) {
            $this-&gt;addTimelapseParametersToFormat();
        }
        return $outputMedia;
    }
    protected function runAfterSavingCallbacks(Media $outputMedia = null)
    {
        foreach ($this-&gt;afterSavingCallbacks as $key =&gt; $callback) {
            call_user_func($callback, $this, $outputMedia);
            unset($this-&gt;afterSavingCallbacks[$key]);
        }
    }
    public function save(string $path = null)
    {
        $outputMedia = $this-&gt;prepareSaving($path);
        $this-&gt;driver-&gt;applyBeforeSavingCallbacks();
        if ($this-&gt;maps-&gt;isNotEmpty()) {
            return $this-&gt;saveWithMappings();
        }
        try {
            if ($this-&gt;driver-&gt;isConcat() &amp;&amp; $outputMedia) {
                $this-&gt;driver-&gt;saveFromSameCodecs($outputMedia-&gt;getLocalPath());
            } else if ($this-&gt;driver-&gt;isFrame()) {
                $data = $this-&gt;driver-&gt;save(
                    optional($outputMedia)-&gt;getLocalPath(),
                    $this-&gt;getAccuracy(),
                    $this-&gt;returnFrameContents,
                );
                if ($this-&gt;returnFrameContents) {
                    $this-&gt;runAfterSavingCallbacks($outputMedia);
                    return $data;
                }
            } else {
                $this-&gt;driver-&gt;save(
                    $this-&gt;format ?: new NullFormat(),
                    optional($outputMedia)-&gt;getLocalPath() ?: &apos;/dev/null&apos;,
                );
            }
        } catch (RuntimeException $exception) {
            throw EncodingException::decorate($exception);
        }
        if ($outputMedia) {
            $outputMedia-&gt;copyAllFromTemporaryDirectory($this-&gt;visibility);
            $outputMedia-&gt;setVisibility($this-&gt;visibility);
        }
        if ($this-&gt;onProgressCallback) {
            call_user_func($this-&gt;onProgressCallback, 100, 0, 0);
        }
        $this-&gt;runAfterSavingCallbacks($outputMedia);
        return $this-&gt;getMediaOpener();
    }
    public function getProcessOutput(): ProcessOutput
    {
        return tap(new StdListener(), function (StdListener $listener) {
            $this-&gt;addListener($listener)-&gt;save();
            $listener-&gt;removeAllListeners();
            $this-&gt;removeListener($listener);
        })-&gt;get();
    }
    private function saveWithMappings(): MediaOpener
    {
        if ($this-&gt;onProgressCallback) {
            $this-&gt;applyProgressListenerToFormat($this-&gt;maps-&gt;last()-&gt;getFormat());
        }
        try {
            $this-&gt;driver-&gt;save();
        } catch (RuntimeException $exception) {
            throw EncodingException::decorate($exception);
        }
        if ($this-&gt;onProgressCallback) {
            call_user_func($this-&gt;onProgressCallback, 100, 0, 0);
        }
        $this-&gt;maps-&gt;map-&gt;getOutputMedia()-&gt;each-&gt;copyAllFromTemporaryDirectory($this-&gt;visibility);
        return $this-&gt;getMediaOpener();
    }
    protected function getMediaOpener(): MediaOpener
    {
        return new MediaOpener(
            $this-&gt;driver-&gt;getMediaCollection()-&gt;last()-&gt;getDisk(),
            $this-&gt;driver,
            $this-&gt;driver-&gt;getMediaCollection(),
        );
    }
    /**
     * Forwards the call to the driver object and returns the result
     * if it&apos;s something different than the driver object itself.
     */
    public function __call($method, $arguments)
    {
        $result = $this-&gt;forwardCallTo($driver = $this-&gt;driver, $method, $arguments);
        return ($result === $driver) ? $this : $result;
    }
}</file><file path="app/Modules/FFmpeg/Exporters/NoFormatException.php">&lt;?php
namespace App\Modules\FFmpeg\Exporters;
use Exception;
class NoFormatException extends Exception
{
}</file><file path="app/Modules/FFmpeg/Exporters/PlaylistGenerator.php">&lt;?php
namespace App\Modules\FFmpeg\Exporters;
use App\Modules\FFmpeg\Drivers\PHPFFMpeg;
interface PlaylistGenerator
{
    public function get(array $playlistMedia, PHPFFMpeg $driver): string;
}</file><file path="app/Modules/FFmpeg/Exporters/VTTPreviewThumbnailsGenerator.php">&lt;?php
namespace App\Modules\FFmpeg\Exporters;
use Closure;
use Illuminate\Support\Collection;
use App\Modules\FFmpeg\Filters\TileFilter;
class VTTPreviewThumbnailsGenerator
{
    private TileFilter $tileFilter;
    private int $durationInSeconds;
    private Closure $sequenceFilenameResolver;
    public function __construct(TileFilter $tileFilter, int $durationInSeconds, Closure $sequenceFilenameResolver)
    {
        $this-&gt;tileFilter = $tileFilter;
        $this-&gt;durationInSeconds = $durationInSeconds;
        $this-&gt;sequenceFilenameResolver = $sequenceFilenameResolver;
    }
    /**
     * Returns the x,y,w,h position of the given thumb key.
     *
     * @param integer $thumbKey
     * @return string
     */
    private function getPositionOnTile(int $thumbKey): string
    {
        $row = (int)floor($thumbKey / $this-&gt;tileFilter-&gt;columns);
        $column = ($thumbKey - ($row * $this-&gt;tileFilter-&gt;columns)) % $this-&gt;tileFilter-&gt;columns;
        $dimension = $this-&gt;tileFilter-&gt;getCalculatedDimension();
        $width = $dimension-&gt;getWidth();
        $height = $dimension-&gt;getHeight();
        // base position
        $x = $column * $width;
        $y = $row * $height;
        // add margin
        $x += $this-&gt;tileFilter-&gt;margin;
        $y += $this-&gt;tileFilter-&gt;margin;
        // add padding
        $x += $this-&gt;tileFilter-&gt;padding * $column;
        $y += $this-&gt;tileFilter-&gt;padding * $row;
        return implode(&apos;,&apos;, [$x, $y, $width, $height]);
    }
    /**
     * Returns the formatted timestamp of the given thumb key.
     *
     * @param integer $thumbKey
     * @return string
     */
    private function getTimestamp(int $thumbKey): string
    {
        return sprintf(
            &apos;%02d:%02d:%02d.000&apos;,
            ($thumbKey * $this-&gt;tileFilter-&gt;interval) / 3600,
            ($thumbKey * $this-&gt;tileFilter-&gt;interval) / 60 % 60,
            ($thumbKey * $this-&gt;tileFilter-&gt;interval) % 60,
        );
    }
    /**
     * Generates the WebVTT contents.
     *
     * @return string
     */
    public function getContents(): string
    {
        $thumbsPerTile = $this-&gt;tileFilter-&gt;rows * $this-&gt;tileFilter-&gt;columns;
        $totalFiles = ceil(
            ($this-&gt;durationInSeconds / $this-&gt;tileFilter-&gt;interval) / $thumbsPerTile,
        );
        return Collection::range(1, $totalFiles * $thumbsPerTile)
            -&gt;map(function ($thumb) use ($thumbsPerTile) {
                $start = $this-&gt;getTimestamp($thumb - 1, $this-&gt;tileFilter-&gt;interval);
                $end = $this-&gt;getTimestamp($thumb, $this-&gt;tileFilter-&gt;interval);
                $fileKey = ceil($thumb / $thumbsPerTile);
                $filename = sprintf(
                    call_user_func($this-&gt;sequenceFilenameResolver, $fileKey),
                    $fileKey,
                );
                $positionOnTile = ($thumb - 1) % $thumbsPerTile;
                $position = $this-&gt;getPositionOnTile($positionOnTile);
                return implode(PHP_EOL, [
                    &quot;{$start} --&gt; {$end}&quot;,
                    &quot;{$filename}#xywh={$position}&quot;,
                ]);
            })
            -&gt;prepend(&quot;WEBVTT&quot;)
            -&gt;implode(PHP_EOL . PHP_EOL);
    }
}</file><file path="app/Modules/FFmpeg/FFMpeg/AdvancedMedia.php">&lt;?php
namespace App\Modules\FFmpeg\FFMpeg;
use FFMpeg\Media\AdvancedMedia as MediaAdvancedMedia;
use Illuminate\Support\Arr;
class AdvancedMedia extends MediaAdvancedMedia
{
    use InteractsWithBeforeSavingCallbacks;
    use InteractsWithHttpHeaders;
    /**
     * Create a new instance of this class with the instance of the underlying library.
     *
     * @param \FFMpeg\Media\AdvancedMedia $media
     * @return self
     */
    public static function make(MediaAdvancedMedia $media): self
    {
        return new static($media-&gt;getInputs(), $media-&gt;getFFMpegDriver(), FFProbe::make($media-&gt;getFFProbe()));
    }
    /**
     * Builds the command using the underlying library and then
     * prepends every input with its own set of headers.
     *
     * @return array
     */
    protected function buildCommand()
    {
        $command = parent::buildCommand();
        $inputKey = array_search(Arr::first($this-&gt;getInputs()), $command) - 1;
        foreach ($this-&gt;getInputs() as $key =&gt; $path) {
            $headers = $this-&gt;headers[$key];
            if (empty($headers)) {
                $inputKey += 2;
                continue;
            }
            $command = static::mergeBeforeKey($command, $inputKey, static::compileHeaders($headers));
            $inputKey += 4;
        }
        $command = $this-&gt;rebuildCommandWithCallbacks($command);
        return $command;
    }
}</file><file path="app/Modules/FFmpeg/FFMpeg/AdvancedOutputMapping.php">&lt;?php
namespace App\Modules\FFmpeg\FFMpeg;
use FFMpeg\Format\FormatInterface;
use FFMpeg\Format\Video\DefaultVideo;
use FFMpeg\Media\AdvancedMedia;
use Illuminate\Support\Collection;
use App\Modules\FFmpeg\Exporters\HLSVideoFilters;
use App\Modules\FFmpeg\Filesystem\Media;
/**
 * This class is basically a wrapper around the map() method
 * of a the \FFMpeg\Media\AdvancedMedia class.
 */
class AdvancedOutputMapping
{
    /**
     * @var array
     */
    private $outs;
    /**
     * @var \FFMpeg\Format\FormatInterface
     */
    private $format;
    /**
     * @var \App\Modules\FFmpeg\Filesystem\Media
     */
    private $output;
    /**
     * @var boolean
     */
    private $forceDisableAudio = false;
    /**
     * @var boolean
     */
    private $forceDisableVideo = false;
    public function __construct(array $outs, FormatInterface $format, Media $output, bool $forceDisableAudio = false, bool $forceDisableVideo = false)
    {
        $this-&gt;outs = $outs;
        $this-&gt;format = $format;
        $this-&gt;output = $output;
        $this-&gt;forceDisableAudio = $forceDisableAudio;
        $this-&gt;forceDisableVideo = $forceDisableVideo;
    }
    /**
     * Applies the attributes to the format and specifies the video
     * bitrate if it&apos;s missing.
     */
    public function apply(AdvancedMedia $advancedMedia): void
    {
        if ($this-&gt;format instanceof DefaultVideo) {
            $parameters = $this-&gt;format-&gt;getAdditionalParameters() ?: [];
            if (!in_array(&apos;-b:v&apos;, $parameters) &amp;&amp; $this-&gt;format-&gt;getKiloBitrate() !== 0) {
                $parameters = array_merge([&apos;-b:v&apos;, $this-&gt;format-&gt;getKiloBitrate() . &apos;k&apos;], $parameters);
            }
            $this-&gt;format-&gt;setAdditionalParameters($parameters);
        }
        $advancedMedia-&gt;map($this-&gt;outs, $this-&gt;format, $this-&gt;output-&gt;getLocalPath(), $this-&gt;forceDisableAudio, $this-&gt;forceDisableVideo);
    }
    public function getFormat(): FormatInterface
    {
        return $this-&gt;format;
    }
    public function getOutputMedia(): Media
    {
        return $this-&gt;output;
    }
    public function hasOut(string $out): bool
    {
        return Collection::make($this-&gt;outs)
            -&gt;map(function ($out) {
                return HLSVideoFilters::beforeGlue($out);
            })
            -&gt;contains(HLSVideoFilters::beforeGlue($out));
    }
}</file><file path="app/Modules/FFmpeg/FFMpeg/AudioMedia.php">&lt;?php
namespace App\Modules\FFmpeg\FFMpeg;
use FFMpeg\Media\Audio;
class AudioMedia extends Audio
{
    use RebuildsCommands;
    /**
     * Create a new instance of this class with the instance of the underlying library.
     *
     * @param \FFMpeg\Media\Audio $audio
     * @return self
     */
    public static function make(Audio $audio): self
    {
        return new static($audio-&gt;getPathfile(), $audio-&gt;getFFMpegDriver(), FFProbe::make($audio-&gt;getFFProbe()));
    }
}</file><file path="app/Modules/FFmpeg/FFMpeg/CopyFormat.php">&lt;?php
namespace App\Modules\FFmpeg\FFMpeg;
use FFMpeg\Format\Audio\DefaultAudio;
class CopyFormat extends DefaultAudio
{
    public function __construct()
    {
        $this-&gt;audioCodec = &apos;copy&apos;;
        $this-&gt;audioKiloBitrate = null;
    }
    /**
     * {@inheritdoc}
     */
    public function getExtraParams()
    {
        return [&apos;-codec&apos;, &apos;copy&apos;];
    }
    /**
     * {@inheritDoc}
     */
    public function getAvailableAudioCodecs()
    {
        return [&apos;copy&apos;];
    }
}</file><file path="app/Modules/FFmpeg/FFMpeg/CopyVideoFormat.php">&lt;?php
namespace App\Modules\FFmpeg\FFMpeg;
use FFMpeg\Format\Video\DefaultVideo;
class CopyVideoFormat extends DefaultVideo
{
    public function __construct()
    {
        $this-&gt;audioCodec = &apos;copy&apos;;
        $this-&gt;videoCodec = &apos;copy&apos;;
        $this-&gt;kiloBitrate = 0;
        $this-&gt;audioKiloBitrate = null;
    }
    /**
     * {@inheritDoc}
     */
    public function getAvailableAudioCodecs()
    {
        return [&apos;copy&apos;];
    }
    /**
     * {@inheritDoc}
     */
    public function getAvailableVideoCodecs()
    {
        return [&apos;copy&apos;];
    }
    /**
     * {@inheritDoc}
     */
    public function supportBFrames()
    {
        return false;
    }
}</file><file path="app/Modules/FFmpeg/FFMpeg/FFProbe.php">&lt;?php
namespace App\Modules\FFmpeg\FFMpeg;
use Alchemy\BinaryDriver\Exception\ExecutionFailureException;
use FFMpeg\Exception\RuntimeException;
use FFMpeg\FFProbe as FFMpegFFProbe;
class FFProbe extends FFMpegFFProbe
{
    /**
     * @var \App\Modules\FFmpeg\Filesystem\Media|\App\Modules\FFmpeg\Filesystem\MediaOnNetwork
     */
    protected $media;
    public function setMedia($media): self
    {
        $this-&gt;media = $media;
        return $this;
    }
    /**
     * Create a new instance of this class with the instance of the underlying library.
     */
    public static function make(?FFMpegFFProbe $probe = null): self
    {
        if ($probe instanceof FFProbe) {
            return $probe;
        }
        return new static($probe-&gt;getFFProbeDriver(), $probe-&gt;getCache());
    }
    private function shouldUseCustomProbe($pathfile): bool
    {
        if (!$this-&gt;media) {
            return false;
        }
        if ($this-&gt;media-&gt;getLocalPath() !== $pathfile) {
            return false;
        }
        if (empty($this-&gt;media-&gt;getCompiledInputOptions())) {
            return false;
        }
        if (!$this-&gt;getOptionsTester()-&gt;has(&apos;-show_streams&apos;)) {
            throw new RuntimeException(&apos;This version of ffprobe is too old and does not support `-show_streams` option, please upgrade&apos;);
        }
        return true;
    }
    /**
     * Probes the streams contained in a given file.
     *
     * @param string $pathfile
     * @return \FFMpeg\FFProbe\DataMapping\StreamCollection
     * @throws \FFMpeg\Exception\InvalidArgumentException
     * @throws \FFMpeg\Exception\RuntimeException
     */
    public function streams($pathfile)
    {
        if (!$this-&gt;shouldUseCustomProbe($pathfile)) {
            return parent::streams($pathfile);
        }
        return $this-&gt;probeStreams($pathfile, &apos;-show_streams&apos;, static::TYPE_STREAMS);
    }
    /**
     * Probes the format of a given file.
     *
     * @param string $pathfile
     * @return \FFMpeg\FFProbe\DataMapping\Format A Format object
     * @throws \FFMpeg\Exception\InvalidArgumentException
     * @throws \FFMpeg\Exception\RuntimeException
     */
    public function format($pathfile)
    {
        if (!$this-&gt;shouldUseCustomProbe($pathfile)) {
            return parent::format($pathfile);
        }
        return $this-&gt;probeStreams($pathfile, &apos;-show_format&apos;, static::TYPE_FORMAT);
    }
    /**
     * This is just copy-paste from FFMpeg\FFProbe...
     * It prepends the command with the input options.
     */
    private function probeStreams($pathfile, $command, $type, $allowJson = true)
    {
        $commands = array_merge(
            $this-&gt;media-&gt;getCompiledInputOptions(),
            [$pathfile, $command],
        );
        $parseIsToDo = false;
        if ($allowJson &amp;&amp; $this-&gt;getOptionsTester()-&gt;has(&apos;-print_format&apos;)) {
            // allowed in latest PHP-FFmpeg version
            $commands[] = &apos;-print_format&apos;;
            $commands[] = &apos;json&apos;;
        } else if ($allowJson &amp;&amp; $this-&gt;getOptionsTester()-&gt;has(&apos;-of&apos;)) {
            // option has changed in avconv 9
            $commands[] = &apos;-of&apos;;
            $commands[] = &apos;json&apos;;
        } else {
            $parseIsToDo = true;
        }
        try {
            $output = $this-&gt;getFFProbeDriver()-&gt;command($commands);
        } catch (ExecutionFailureException $e) {
            throw new RuntimeException(sprintf(&apos;Unable to probe %s&apos;, $pathfile), $e-&gt;getCode(), $e);
        }
        if ($parseIsToDo) {
            $data = $this-&gt;getParser()-&gt;parse($type, $output);
        } else {
            try {
                $data = @json_decode($output, true);
                if (JSON_ERROR_NONE !== json_last_error()) {
                    throw new RuntimeException(sprintf(&apos;Unable to parse json %s&apos;, $output));
                }
            } catch (RuntimeException $e) {
                return $this-&gt;probeStreams($pathfile, $command, $type, false);
            }
        }
        return $this-&gt;getMapper()-&gt;map($type, $data);
    }
}</file><file path="app/Modules/FFmpeg/FFMpeg/ImageFormat.php">&lt;?php
namespace App\Modules\FFmpeg\FFMpeg;
use FFMpeg\Format\Video\DefaultVideo;
class ImageFormat extends DefaultVideo
{
    public function __construct()
    {
        $this-&gt;kiloBitrate = 0;
        $this-&gt;audioKiloBitrate = null;
    }
    /**
     * Gets the kiloBitrate value.
     *
     * @return int
     */
    public function getKiloBitrate()
    {
        return $this-&gt;kiloBitrate;
    }
    /**
     * Returns the modulus used by the Resizable video.
     *
     * This used to calculate the target dimensions while maintaining the best
     * aspect ratio.
     *
     * @see http://www.undeadborn.net/tools/rescalculator.php
     *
     * @return int
     */
    public function getModulus()
    {
        return 0;
    }
    /**
     * Returns the video codec.
     *
     * @return string
     */
    public function getVideoCodec()
    {
        return null;
    }
    /**
     * Returns true if the current format supports B-Frames.
     *
     * @see https://wikipedia.org/wiki/Video_compression_picture_types
     *
     * @return bool
     */
    public function supportBFrames()
    {
        return false;
    }
    /**
     * Returns the list of available video codecs for this format.
     *
     * @return array
     */
    public function getAvailableVideoCodecs()
    {
        return [];
    }
    /**
     * Returns the list of additional parameters for this format.
     *
     * @return array
     */
    public function getAdditionalParameters()
    {
        return [&apos;-f&apos;, &apos;image2&apos;];
    }
    /**
     * Returns the list of initial parameters for this format.
     *
     * @return array
     */
    public function getInitialParameters()
    {
        return [];
    }
    /**
     * {@inheritdoc}
     */
    public function getExtraParams()
    {
        return [];
    }
    /**
     * {@inheritDoc}
     */
    public function getAvailableAudioCodecs()
    {
        return [];
    }
}</file><file path="app/Modules/FFmpeg/FFMpeg/InteractsWithBeforeSavingCallbacks.php">&lt;?php
namespace App\Modules\FFmpeg\FFMpeg;
trait InteractsWithBeforeSavingCallbacks
{
    /**
     * @var array
     */
    protected $beforeSavingCallbacks = [];
    public function setBeforeSavingCallbacks(array $beforeSavingCallbacks): self
    {
        $this-&gt;beforeSavingCallbacks = $beforeSavingCallbacks;
        return $this;
    }
    protected function rebuildCommandWithCallbacks($command)
    {
        foreach ($this-&gt;beforeSavingCallbacks as $key =&gt; $callback) {
            $newCommand = call_user_func($callback, $command);
            $command = !is_null($newCommand) ? $newCommand : $command;
            unset($this-&gt;beforeSavingCallbacks[$key]);
        }
        return $command;
    }
}</file><file path="app/Modules/FFmpeg/FFMpeg/InteractsWithHttpHeaders.php">&lt;?php
namespace App\Modules\FFmpeg\FFMpeg;
use Illuminate\Support\Collection;
trait InteractsWithHttpHeaders
{
    use InteractsWithInputPath;
    /**
     * @var array
     */
    protected $headers = [];
    public function getHeaders(): array
    {
        return $this-&gt;headers;
    }
    public function setHeaders(array $headers = []): self
    {
        $this-&gt;headers = $headers;
        return $this;
    }
    /**
     * Maps the headers into a key-value string for FFmpeg. Returns
     * an array of arguments to pass into the command.
     *
     * @param array $headers
     * @return array
     */
    public static function compileHeaders(array $headers = []): array
    {
        if (empty($headers)) {
            return [];
        }
        $headers = Collection::make($headers)-&gt;map(function ($value, $key) {
            return &quot;{$key}: {$value}&quot;;
        })-&gt;filter()-&gt;push(&quot;&quot;)-&gt;implode(&quot;\r\n&quot;);
        return [&apos;-headers&apos;, $headers];
    }
}</file><file path="app/Modules/FFmpeg/FFMpeg/InteractsWithInputPath.php">&lt;?php
namespace App\Modules\FFmpeg\FFMpeg;
trait InteractsWithInputPath
{
    /**
     * Searches in the $input array for the key bu the $path, and then
     * prepend the $values in front of that key.
     *
     * @param array $input
     * @param string $path
     * @param array $values
     * @return array
     */
    protected static function mergeBeforePathInput(array $input, string $path, array $values = []): array
    {
        $key = array_search($path, $input) - 1;
        return static::mergeBeforeKey($input, $key, $values);
    }
    /**
     * Prepend the given $values in front of the $key in $input.
     *
     * @param array $input
     * @param integer $key
     * @param array $values
     * @return array
     */
    protected static function mergeBeforeKey(array $input, int $key, array $values = []): array
    {
        return array_merge(
            array_slice($input, 0, $key),
            $values,
            array_slice($input, $key),
        );
    }
}</file><file path="app/Modules/FFmpeg/FFMpeg/LegacyFilterMapping.php">&lt;?php
namespace App\Modules\FFmpeg\FFMpeg;
use Illuminate\Support\Arr;
use Illuminate\Support\Collection;
use App\Modules\FFmpeg\Drivers\PHPFFMpeg;
use App\Modules\FFmpeg\Exporters\HLSVideoFilters;
use App\Modules\FFmpeg\Filesystem\MediaCollection;
class LegacyFilterMapping
{
    private $in;
    private $out;
    /**
     * @var array
     */
    private $arguments;
    public function __construct($in, $out, ...$arguments)
    {
        $this-&gt;in = $in;
        $this-&gt;out = $out;
        $this-&gt;arguments = $arguments;
    }
    /**
     * Removes all non-numeric characters from the &apos;in&apos; attribute.
     */
    public function normalizeIn(): int
    {
        return preg_replace(&quot;/[^0-9]/&quot;, &quot;&quot;, HLSVideoFilters::beforeGlue($this-&gt;in));
    }
    /**
     * Filters the given MediaCollection down to one item by
     * guessing the key by the &apos;in&apos; attribute.
     */
    private function singleMediaCollection(MediaCollection $mediaCollection): MediaCollection
    {
        $media = $mediaCollection-&gt;get($this-&gt;normalizeIn()) ?: $mediaCollection-&gt;first();
        return MediaCollection::make([$media]);
    }
    /**
     * Applies the filter to the FFMpeg driver.
     */
    public function apply(PHPFFMpeg $driver, Collection $maps): void
    {
        $freshDriver = $driver-&gt;fresh()
            -&gt;open($this-&gt;singleMediaCollection($driver-&gt;getMediaCollection()))
            -&gt;addFilter(...$this-&gt;arguments);
        $format = $maps-&gt;filter-&gt;hasOut($this-&gt;out)-&gt;first()-&gt;getFormat();
        Collection::make($freshDriver-&gt;getFilters())-&gt;map(function ($filter) use ($freshDriver, $format) {
            $parameters = $filter-&gt;apply($freshDriver-&gt;get(), $format);
            $parameters = Arr::where($parameters, function ($parameter) {
                return !in_array($parameter, [&apos;-vf&apos;, &apos;-filter:v&apos;, &apos;-filter_complex&apos;]);
            });
            return implode(&apos; &apos;, $parameters);
        })-&gt;each(function ($customCompiledFilter) use ($driver) {
            $driver-&gt;addFilter($this-&gt;in, $customCompiledFilter, $this-&gt;out);
        });
    }
}</file><file path="app/Modules/FFmpeg/FFMpeg/NullFormat.php">&lt;?php
namespace App\Modules\FFmpeg\FFMpeg;
use FFMpeg\Format\Audio\DefaultAudio;
class NullFormat extends DefaultAudio
{
    public function __construct()
    {
        $this-&gt;audioKiloBitrate = null;
    }
    /**
     * {@inheritdoc}
     */
    public function getExtraParams()
    {
        return [];
    }
    /**
     * {@inheritDoc}
     */
    public function getAvailableAudioCodecs()
    {
        return [];
    }
}</file><file path="app/Modules/FFmpeg/FFMpeg/ProgressListenerDecorator.php">&lt;?php
namespace App\Modules\FFmpeg\FFMpeg;
use FFMpeg\FFProbe;
use FFMpeg\Format\AudioInterface;
use FFMpeg\Format\ProgressableInterface;
use FFMpeg\Format\VideoInterface;
use FFMpeg\Media\MediaTypeInterface;
use Illuminate\Support\Traits\ForwardsCalls;
/**
 * Use this decorator to get access to the AbstractProgressListeners0
 * with the `getListeners` method.
 */
class ProgressListenerDecorator implements ProgressableInterface, AudioInterface
{
    use ForwardsCalls;
    /**
     * @var \FFMpeg\Format\AudioInterface|\FFMpeg\Format\VideoInterface
     */
    protected $format;
    /**
     * @var array
     */
    protected $listeners = [];
    public function __construct($format)
    {
        $this-&gt;format = $format;
    }
    public static function decorate($format)
    {
        if ($format instanceof VideoInterface) {
            return new VideoProgressListenerDecorator($format);
        }
        return new static($format);
    }
    public function getListeners(): array
    {
        return $this-&gt;listeners;
    }
    public function createProgressListener(MediaTypeInterface $media, FFProbe $ffprobe, $pass, $total, $duration = 0)
    {
        return tap($this-&gt;format-&gt;createProgressListener(...func_get_args()), function (array $listeners) {
            $this-&gt;listeners = array_merge($this-&gt;listeners, $listeners);
        });
    }
    public function on($event, callable $listener)
    {
        return $this-&gt;format-&gt;on(...func_get_args());
    }
    public function once($event, callable $listener)
    {
        return $this-&gt;format-&gt;once(...func_get_args());
    }
    public function removeListener($event, callable $listener)
    {
        return $this-&gt;format-&gt;removeListener(...func_get_args());
    }
    public function removeAllListeners($event = null)
    {
        return $this-&gt;format-&gt;removeAllListeners(...func_get_args());
    }
    public function listeners($event = null)
    {
        return $this-&gt;format-&gt;listeners(...func_get_args());
    }
    public function emit($event, array $arguments = [])
    {
        return $this-&gt;format-&gt;emit(...func_get_args());
    }
    public function getPasses()
    {
        return $this-&gt;format-&gt;getPasses(...func_get_args());
    }
    public function getExtraParams()
    {
        return $this-&gt;format-&gt;getExtraParams(...func_get_args());
    }
    public function getAudioKiloBitrate()
    {
        return $this-&gt;format-&gt;getAudioKiloBitrate(...func_get_args());
    }
    public function getAudioChannels()
    {
        return $this-&gt;format-&gt;getAudioChannels(...func_get_args());
    }
    public function getAudioCodec()
    {
        return $this-&gt;format-&gt;getAudioCodec(...func_get_args());
    }
    public function getAvailableAudioCodecs()
    {
        return $this-&gt;format-&gt;getAvailableAudioCodecs(...func_get_args());
    }
    public function __get($key)
    {
        return $this-&gt;format-&gt;{$key};
    }
    public function __call($method, $arguments)
    {
        return $this-&gt;forwardCallTo($this-&gt;format, $method, $arguments);
    }
}</file><file path="app/Modules/FFmpeg/FFMpeg/RebuildsCommands.php">&lt;?php
namespace App\Modules\FFmpeg\FFMpeg;
use FFMpeg\Format\FormatInterface;
use Illuminate\Support\Collection;
trait RebuildsCommands
{
    use InteractsWithBeforeSavingCallbacks;
    use InteractsWithHttpHeaders;
    /**
     * Builds the command using the underlying library and then
     * prepends the input with the headers.
     *
     * @param \FFMpeg\Format\FormatInterface $format
     * @param string $outputPathfile
     * @return array
     */
    protected function buildCommand(FormatInterface $format, $outputPathfile)
    {
        $command = parent::buildCommand($format, $outputPathfile);
        $command = $this-&gt;rebuildCommandWithHeaders($command);
        $command = $this-&gt;rebuildCommandWithCallbacks($command);
        return $command;
    }
    private function rebuildCommandWithHeaders($command)
    {
        if (empty($this-&gt;headers)) {
            return $command;
        }
        return Collection::make($command)-&gt;map(function ($command) {
            return static::mergeBeforePathInput(
                $command,
                $this-&gt;getPathfile(),
                static::compileHeaders($this-&gt;headers),
            );
        })-&gt;all();
    }
}</file><file path="app/Modules/FFmpeg/FFMpeg/StdListener.php">&lt;?php
namespace App\Modules\FFmpeg\FFMpeg;
use Alchemy\BinaryDriver\Listeners\ListenerInterface;
use Evenement\EventEmitter;
use App\Modules\FFmpeg\Support\ProcessOutput;
use Symfony\Component\Process\Process;
class StdListener extends EventEmitter implements ListenerInterface
{
    public const TYPE_ALL = &apos;all&apos;;
    /**
     * Name of the emitted event.
     *
     * @var string
     */
    private $eventName;
    /**
     * Container for the outputted lines.
     *
     * @var array
     */
    private $data = [
        self::TYPE_ALL =&gt; [],
        Process::ERR   =&gt; [],
        Process::OUT   =&gt; [],
    ];
    public function __construct(string $eventName = &apos;listen&apos;)
    {
        $this-&gt;eventName = $eventName;
    }
    /**
     * Handler for a new line of data.
     *
     * @param string $type
     * @param string $data
     * @return void
     */
    public function handle($type, $data)
    {
        $lines = preg_split(&apos;/\n|\r\n?/&apos;, $data);
        foreach ($lines as $line) {
            $this-&gt;emit($this-&gt;eventName, [$line, $type]);
            $line = trim($line);
            $this-&gt;data[$type][] = $line;
            $this-&gt;data[static::TYPE_ALL][] = $line;
        }
    }
    /**
     * Returns the collected output lines.
     *
     * @return array
     */
    public function get(): ProcessOutput
    {
        return new ProcessOutput(
            $this-&gt;data[static::TYPE_ALL],
            $this-&gt;data[Process::ERR],
            $this-&gt;data[Process::OUT],
        );
    }
    public function forwardedEvents()
    {
        return [$this-&gt;eventName];
    }
}</file><file path="app/Modules/FFmpeg/FFMpeg/VideoMedia.php">&lt;?php
namespace App\Modules\FFmpeg\FFMpeg;
use FFMpeg\Media\Video;
class VideoMedia extends Video
{
    use RebuildsCommands;
    /**
     * Create a new instance of this class with the instance of the underlying library.
     *
     * @param \FFMpeg\Media\Video $video
     * @return self
     */
    public static function make(Video $video): self
    {
        return new static($video-&gt;getPathfile(), $video-&gt;getFFMpegDriver(), $video-&gt;getFFProbe());
    }
}</file><file path="app/Modules/FFmpeg/FFMpeg/VideoProgressListenerDecorator.php">&lt;?php
namespace App\Modules\FFmpeg\FFMpeg;
use FFMpeg\Format\VideoInterface;
class VideoProgressListenerDecorator extends ProgressListenerDecorator implements VideoInterface
{
    public function getKiloBitrate()
    {
        return $this-&gt;format-&gt;getKiloBitrate(...func_get_args());
    }
    public function getModulus()
    {
        return $this-&gt;format-&gt;getModulus(...func_get_args());
    }
    public function getVideoCodec()
    {
        return $this-&gt;format-&gt;getVideoCodec(...func_get_args());
    }
    public function supportBFrames()
    {
        return $this-&gt;format-&gt;supportBFrames(...func_get_args());
    }
    public function getAvailableVideoCodecs()
    {
        return $this-&gt;format-&gt;getAvailableVideoCodecs(...func_get_args());
    }
    public function getAdditionalParameters()
    {
        return $this-&gt;format-&gt;getAdditionalParameters(...func_get_args());
    }
    public function getInitialParameters()
    {
        return $this-&gt;format-&gt;getInitialParameters(...func_get_args());
    }
    public function getAvailableAudioCodecs()
    {
        return $this-&gt;format-&gt;getAvailableAudioCodecs(...func_get_args());
    }
}</file><file path="app/Modules/FFmpeg/Filesystem/Disk.php">&lt;?php
namespace App\Modules\FFmpeg\Filesystem;
use Illuminate\Contracts\Filesystem\Filesystem;
use Illuminate\Support\Traits\ForwardsCalls;
/**
 * @mixin Filesystem
 */
class Disk
{
    use ForwardsCalls;
    /**
     * @var string|\Illuminate\Contracts\Filesystem\Filesystem
     */
    private $disk;
    /**
     * @var string
     */
    private $temporaryDirectory;
    /**
     * @var \Illuminate\Filesystem\FilesystemAdapter
     */
    private $filesystemAdapter;
    public function __construct($disk)
    {
        $this-&gt;disk = $disk;
    }
    /**
     * Little helper method to instantiate this class.
     */
    public static function make($disk): self
    {
        if ($disk instanceof self) {
            return $disk;
        }
        return new static($disk);
    }
    public static function makeTemporaryDisk(): self
    {
        $filesystemAdapter = Container::get(FilesystemManager::class)-&gt;createLocalDriver([
            &apos;root&apos; =&gt; Container::get(TemporaryDirectories::class)-&gt;create(),
        ]);
        return new static($filesystemAdapter);
    }
    /**
     * Creates a fresh instance, mostly used to force a new TemporaryDirectory.
     */
    public function clone(): self
    {
        return new Disk($this-&gt;disk);
    }
    /**
     * Creates a new TemporaryDirectory instance if none is set, otherwise
     * it returns the current one.
     */
    public function getTemporaryDirectory(): string
    {
        if ($this-&gt;temporaryDirectory) {
            return $this-&gt;temporaryDirectory;
        }
        return $this-&gt;temporaryDirectory = Container::get(TemporaryDirectories::class)-&gt;create();
    }
    public function makeMedia(string $path): Media
    {
        return Media::make($this, $path);
    }
    /**
     * Returns the name of the disk. It generates a name if the disk
     * is an instance of Flysystem.
     */
    public function getName(): string
    {
        if (is_string($this-&gt;disk)) {
            return $this-&gt;disk;
        }
        return get_class($this-&gt;getFlysystemAdapter()) . &quot;_&quot; . md5(spl_object_id($this-&gt;getFlysystemAdapter()));
    }
    public function getFilesystemAdapter(): Filesystem
    {
        if ($this-&gt;filesystemAdapter) {
            return $this-&gt;filesystemAdapter;
        }
        if ($this-&gt;disk instanceof Filesystem) {
            return $this-&gt;filesystemAdapter = $this-&gt;disk;
        }
        return $this-&gt;filesystemAdapter = Storage::disk($this-&gt;disk);
    }
    private function getFlysystemDriver(): LeagueFilesystem
    {
        return $this-&gt;getFilesystemAdapter()-&gt;getDriver();
    }
    private function getFlysystemAdapter(): FlysystemFilesystemAdapter
    {
        return $this-&gt;getFilesystemAdapter()-&gt;getAdapter();
    }
    public function isLocalDisk(): bool
    {
        return $this-&gt;getFlysystemAdapter() instanceof LocalFilesystemAdapter;
    }
    /**
     * Replaces backward slashes into forward slashes.
     *
     * @param string $path
     * @return string
     */
    public static function normalizePath(string $path): string
    {
        return str_replace(&apos;\\&apos;, &apos;/&apos;, $path);
    }
    /**
     * Get the full path for the file at the given &quot;short&quot; path.
     *
     * @param string $path
     * @return string
     */
    public function path(string $path): string
    {
        $path = $this-&gt;getFilesystemAdapter()-&gt;path($path);
        return $this-&gt;isLocalDisk() ? static::normalizePath($path) : $path;
    }
    /**
     * Forwards all calls to Laravel&apos;s FilesystemAdapter which will pass
     * dynamic methods call onto Flysystem.
     */
    public function __call($method, $parameters)
    {
        return $this-&gt;forwardCallTo($this-&gt;getFilesystemAdapter(), $method, $parameters);
    }
}</file><file path="app/Modules/FFmpeg/Filesystem/HasInputOptions.php">&lt;?php
namespace App\Modules\FFmpeg\Filesystem;
trait HasInputOptions
{
    /**
     * @var array
     */
    protected $inputOptions = [];
    public function getInputOptions(): array
    {
        return $this-&gt;inputOptions;
    }
    public function setInputOptions(array $options = []): self
    {
        $this-&gt;inputOptions = $options;
        return $this;
    }
    public function getCompiledInputOptions(): array
    {
        return $this-&gt;getInputOptions();
    }
}</file><file path="app/Modules/FFmpeg/Filesystem/Media.php">&lt;?php
namespace App\Modules\FFmpeg\Filesystem;
use Illuminate\Filesystem\FilesystemAdapter;
class Media
{
    use HasInputOptions;
    /**
     * @var Disk
     */
    private $disk;
    /**
     * @var string
     */
    private $path;
    /**
     * @var string
     */
    private $temporaryDirectory;
    public function __construct(Disk $disk, string $path)
    {
        $this-&gt;disk = $disk;
        $this-&gt;path = $path;
        $this-&gt;makeDirectory();
    }
    public static function make($disk, string $path): self
    {
        return new static(Disk::make($disk), $path);
    }
    public function getDisk(): Disk
    {
        return $this-&gt;disk;
    }
    public function getPath(): string
    {
        return $this-&gt;path;
    }
    public function getDirectory(): ?string
    {
        $directory = rtrim(pathinfo($this-&gt;getPath())[&apos;dirname&apos;], DIRECTORY_SEPARATOR);
        if ($directory === &apos;.&apos;) {
            $directory = &apos;&apos;;
        }
        if ($directory) {
            $directory .= DIRECTORY_SEPARATOR;
        }
        return $directory;
    }
    private function makeDirectory(): void
    {
        $disk = $this-&gt;getDisk();
        if (!$disk-&gt;isLocalDisk()) {
            $disk = $this-&gt;temporaryDirectoryDisk();
        }
        $directory = $this-&gt;getDirectory();
        if ($disk-&gt;has($directory)) {
            return;
        }
        $disk-&gt;makeDirectory($directory);
    }
    public function getFilenameWithoutExtension(): string
    {
        return pathinfo($this-&gt;getPath())[&apos;filename&apos;];
    }
    public function getFilename(): string
    {
        return pathinfo($this-&gt;getPath())[&apos;basename&apos;];
    }
    private function temporaryDirectoryDisk(): Disk
    {
        return Disk::make($this-&gt;temporaryDirectoryAdapter());
    }
    private function temporaryDirectoryAdapter(): FilesystemAdapter
    {
        if (!$this-&gt;temporaryDirectory) {
            $this-&gt;temporaryDirectory = $this-&gt;getDisk()-&gt;getTemporaryDirectory();
        }
        return app(&apos;filesystem&apos;)-&gt;createLocalDriver(
            [&apos;root&apos; =&gt; $this-&gt;temporaryDirectory],
        );
    }
    public function getLocalPath(): string
    {
        $disk = $this-&gt;getDisk();
        $path = $this-&gt;getPath();
        if ($disk-&gt;isLocalDisk()) {
            return $disk-&gt;path($path);
        }
        $temporaryDirectoryDisk = $this-&gt;temporaryDirectoryDisk();
        if ($disk-&gt;exists($path) &amp;&amp; !$temporaryDirectoryDisk-&gt;exists($path)) {
            $temporaryDirectoryDisk-&gt;writeStream($path, $disk-&gt;readStream($path));
        }
        return $temporaryDirectoryDisk-&gt;path($path);
    }
    public function copyAllFromTemporaryDirectory(string $visibility = null)
    {
        if (!$this-&gt;temporaryDirectory) {
            return $this;
        }
        $temporaryDirectoryDisk = $this-&gt;temporaryDirectoryDisk();
        $destinationAdapter = $this-&gt;getDisk()-&gt;getFilesystemAdapter();
        foreach ($temporaryDirectoryDisk-&gt;allFiles() as $path) {
            $destinationAdapter-&gt;writeStream($path, $temporaryDirectoryDisk-&gt;readStream($path));
            if ($visibility) {
                $destinationAdapter-&gt;setVisibility($path, $visibility);
            }
        }
        return $this;
    }
    public function setVisibility(string $visibility = null)
    {
        $disk = $this-&gt;getDisk();
        if ($visibility &amp;&amp; $disk-&gt;isLocalDisk()) {
            $disk-&gt;setVisibility($visibility);
        }
        return $this;
    }
}</file><file path="app/Modules/FFmpeg/Filesystem/MediaCollection.php">&lt;?php
namespace App\Modules\FFmpeg\Filesystem;
use Illuminate\Support\Collection;
use Illuminate\Support\Traits\ForwardsCalls;
/**
 * @mixin Collection
 */
class MediaCollection
{
    use ForwardsCalls;
    /**
     * @var Collection
     */
    private $items;
    public function __construct(array $items = [])
    {
        $this-&gt;items = new Collection($items);
    }
    public static function make(array $items = []): self
    {
        return new static($items);
    }
    /**
     * Returns an array with all locals paths of the Media items.
     */
    public function getLocalPaths(): array
    {
        return $this-&gt;items-&gt;map-&gt;getLocalPath()-&gt;all();
    }
    /**
     * Returns an array with all headers of the Media items.
     */
    public function getHeaders(): array
    {
        return $this-&gt;items-&gt;map(function ($media) {
            return $media instanceof MediaOnNetwork ? $media-&gt;getHeaders() : [];
        })-&gt;all();
    }
    public function collection(): Collection
    {
        return $this-&gt;items;
    }
    /**
     * Count the number of items in the collection.
     *
     * @return int
     */
    public function count(): int
    {
        return $this-&gt;items-&gt;count();
    }
    public function __call($method, $parameters)
    {
        return $this-&gt;forwardCallTo($this-&gt;collection(), $method, $parameters);
    }
}</file><file path="app/Modules/FFmpeg/Filesystem/MediaOnNetwork.php">&lt;?php
namespace App\Modules\FFmpeg\Filesystem;
use App\Modules\FFmpeg\FFMpeg\InteractsWithHttpHeaders;
class MediaOnNetwork
{
    use HasInputOptions, InteractsWithHttpHeaders;
    /**
     * @var string
     */
    private $path;
    public function __construct(string $path, array $headers = [])
    {
        $this-&gt;path = $path;
        $this-&gt;headers = $headers;
    }
    public static function make(string $path, array $headers = []): self
    {
        return new static($path, $headers);
    }
    public function getPath(): string
    {
        return $this-&gt;path;
    }
    public function getDisk(): Disk
    {
        return Disk::make(config(&apos;filesystems.default&apos;));
    }
    public function getLocalPath(): string
    {
        return $this-&gt;path;
    }
    public function getFilenameWithoutExtension(): string
    {
        return pathinfo($this-&gt;getPath())[&apos;filename&apos;];
    }
    public function getFilename(): string
    {
        return pathinfo($this-&gt;getPath())[&apos;basename&apos;];
    }
    public function getCompiledInputOptions(): array
    {
        return array_merge($this-&gt;getInputOptions(), $this-&gt;getCompiledHeaders());
    }
    public function getCompiledHeaders(): array
    {
        return static::compileHeaders($this-&gt;getHeaders());
    }
    /**
     * Downloads the Media from the internet and stores it in
     * a temporary directory.
     *
     * @param callable $withCurl
     * @return \App\Modules\FFmpeg\Filesystem\Media
     */
    public function toMedia(callable $withCurl = null): Media
    {
        $disk = Disk::makeTemporaryDisk();
        $curl = curl_init();
        curl_setopt($curl, CURLOPT_URL, $this-&gt;path);
        curl_setopt($curl, CURLOPT_RETURNTRANSFER, true);
        if (!empty($this-&gt;headers)) {
            $headers = Collection::make($this-&gt;headers)-&gt;map(function ($value, $header) {
                return &quot;{$header}: {$value}&quot;;
            })-&gt;all();
            curl_setopt($curl, CURLOPT_HTTPHEADER, $headers);
        }
        if ($withCurl) {
            $curl = $withCurl($curl) ?: $curl;
        }
        $contents = curl_exec($curl);
        curl_close($curl);
        $disk-&gt;getFilesystemAdapter()-&gt;put(
            $filename = $this-&gt;getFilename(),
            $contents,
        );
        return new Media($disk, $filename);
    }
}</file><file path="app/Modules/FFmpeg/Filesystem/TemporaryDirectories.php">&lt;?php
namespace App\Modules\FFmpeg\Filesystem;
use Illuminate\Filesystem\Filesystem;
class TemporaryDirectories
{
    /**
     * Root of the temporary directories.
     *
     * @var string
     */
    private $root;
    /**
     * Array of all directories
     *
     * @var array
     */
    private $directories = [];
    /**
     * Sets the root and removes the trailing slash.
     *
     * @param string $root
     */
    public function __construct(string $root)
    {
        $this-&gt;root = rtrim($root, DIRECTORY_SEPARATOR);
    }
    /**
     * Returns the full path a of new temporary directory.
     *
     * @return string
     */
    public function create(): string
    {
        $directory = $this-&gt;root . DIRECTORY_SEPARATOR . bin2hex(random_bytes(8));
        mkdir($directory, 0777, true);
        return $this-&gt;directories[] = $directory;
    }
    /**
     * Loop through all directories and delete them.
     */
    public function deleteAll(): void
    {
        $filesystem = new Filesystem();
        foreach ($this-&gt;directories as $directory) {
            $filesystem-&gt;deleteDirectory($directory);
        }
        $this-&gt;directories = [];
    }
}</file><file path="app/Modules/FFmpeg/Filters/TileFactory.php">&lt;?php
namespace App\Modules\FFmpeg\Filters;
use Closure;
class TileFactory
{
    public float $interval = 0;
    public int $width = -1;
    public int $height = -1;
    public int $columns;
    public int $rows;
    public int $padding = 0;
    public int $margin = 0;
    public ?int $quality = null;
    public ?string $vttOutputPath = null;
    public ?Closure $vttSequenceFilename = null;
    public static function make(): TileFactory
    {
        return new static();
    }
    /**
     * Setter for the output path of the VTT file and
     * the resolver for the tile sequence.
     *
     * @param string $outputPath
     * @param null|Closure|string $sequenceFilename
     * @return self
     */
    public function generateVTT(string $outputPath, $sequenceFilename = null): self
    {
        $this-&gt;vttOutputPath = $outputPath;
        $this-&gt;vttSequenceFilename = is_string($sequenceFilename)
            ? fn() =&gt; $sequenceFilename
            : $sequenceFilename;
        return $this;
    }
    public function interval(float $interval): self
    {
        $this-&gt;interval = $interval;
        return $this;
    }
    public function width(int $width): self
    {
        $this-&gt;width = $width;
        return $this;
    }
    public function height(int $height): self
    {
        $this-&gt;height = $height;
        return $this;
    }
    public function scale(int $width = null, int $height = null): self
    {
        return $this-&gt;width($width ?: -1)-&gt;height($height ?: -1);
    }
    public function grid(int $columns, int $rows): self
    {
        $this-&gt;columns = $columns;
        $this-&gt;rows = $rows;
        return $this;
    }
    public function padding(int $padding): self
    {
        $this-&gt;padding = $padding;
        return $this;
    }
    public function margin(int $margin): self
    {
        $this-&gt;margin = $margin;
        return $this;
    }
    public function quality(int $quality = null): self
    {
        $this-&gt;quality = $quality;
        return $this;
    }
    /**
     * Returns a new instance of the TileFilter.
     */
    public function get(): TileFilter
    {
        return new TileFilter(
            $this-&gt;interval,
            $this-&gt;width,
            $this-&gt;height,
            $this-&gt;columns,
            $this-&gt;rows,
            $this-&gt;padding,
            $this-&gt;margin,
            $this-&gt;quality,
        );
    }
}</file><file path="app/Modules/FFmpeg/Filters/TileFilter.php">&lt;?php
namespace App\Modules\FFmpeg\Filters;
use FFMpeg\Coordinate\Dimension;
use FFMpeg\FFProbe\DataMapping\Stream;
use FFMpeg\Filters\Video\VideoFilterInterface;
use FFMpeg\Format\VideoInterface;
use FFMpeg\Media\Video;
use App\Modules\FFmpeg\Support\StreamParser;
/**
 * Inspired by: https://github.com/protonemedia/laravel-ffmpeg/issues/335
 */
class TileFilter implements VideoFilterInterface
{
    public float $interval;
    public int $width;
    public int $height;
    public int $columns;
    public int $rows;
    public int $padding = 0;
    public int $margin = 0;
    public ?int $quality = null;
    public int $priority = 0;
    public ?Dimension $calculatedDimension = null;
    public function __construct(
        float $interval,
        int   $width,
        int   $height,
        int   $columns,
        int   $rows,
        int   $padding = 0,
        int   $margin = 0,
        ?int  $quality = null,
        int   $priority = 0,
    )
    {
        $this-&gt;interval = $interval;
        $this-&gt;width = $width;
        $this-&gt;height = $height;
        $this-&gt;columns = $columns;
        $this-&gt;rows = $rows;
        $this-&gt;padding = $padding;
        $this-&gt;margin = $margin;
        $this-&gt;quality = $quality;
        $this-&gt;priority = $priority;
    }
    /**
     * {@inheritdoc}
     */
    public function getPriority()
    {
        return $this-&gt;priority;
    }
    /**
     * Get name of the filter.
     *
     * @return string
     */
    public function getName()
    {
        return &apos;thumbnail_sprite&apos;;
    }
    /**
     * Get minimal version of ffmpeg starting with which this filter is supported.
     *
     * @return string
     */
    public function getMinimalFFMpegVersion(): string
    {
        return &apos;4.3&apos;;
    }
    /**
     * {@inheritdoc}
     */
    public function apply(Video $video, VideoInterface $format)
    {
        return $this-&gt;getCommands(
            $video-&gt;getStreams()-&gt;videos()-&gt;first(),
        );
    }
    public function getCalculatedDimension(): Dimension
    {
        return $this-&gt;calculatedDimension ?: new Dimension($this-&gt;width, $this-&gt;height);
    }
    private function calculateDimension(Dimension $streamDimension): Dimension
    {
        $width = $this-&gt;width;
        $height = $this-&gt;height;
        if ($width &gt; 0 &amp;&amp; $height &lt; 1) {
            $height = $streamDimension-&gt;getRatio()-&gt;calculateHeight($width);
        } else if ($height &gt; 0 &amp;&amp; $width &lt; 1) {
            $width = $streamDimension-&gt;getRatio()-&gt;calculateWidth($height);
        } else if ($width &lt; 1 &amp;&amp; $height &lt; 1) {
            $width = $streamDimension-&gt;getWidth();
            $height = $streamDimension-&gt;getHeight();
        }
        return $this-&gt;calculatedDimension = new Dimension($width, $height);
    }
    /**
     * @return array
     */
    protected function getCommands(Stream $stream)
    {
        $frameRateInterval = null;
        if ($frameRate = StreamParser::new($stream)-&gt;getFrameRate()) {
            $frameRateInterval = round($frameRate * $this-&gt;interval);
        }
        $dimension = $this-&gt;calculateDimension($stream-&gt;getDimensions());
        $select = $frameRateInterval
            ? &quot;select=not(mod(n\,{$frameRateInterval}))&quot;
            : &quot;select=not(mod(t\,{$this-&gt;interval}))&quot;;
        $commands = [
            &apos;-vsync&apos;,
            &apos;0&apos;,
        ];
        if (!is_null($this-&gt;quality)) {
            $commands = array_merge($commands, [
                &apos;-qscale:v&apos;,
                $this-&gt;quality,
            ]);
        }
        return array_merge($commands, [
            &apos;-vf&apos;,
            &quot;{$select},scale={$dimension-&gt;getWidth()}:{$dimension-&gt;getHeight()},tile={$this-&gt;columns}x{$this-&gt;rows}:margin={$this-&gt;margin}:padding={$this-&gt;padding}&quot;,
        ]);
    }
}</file><file path="app/Modules/FFmpeg/Filters/WatermarkFactory.php">&lt;?php
namespace App\Modules\FFmpeg\Filters;
use Illuminate\Support\Traits\ForwardsCalls;
use App\Modules\FFmpeg\Filesystem\Disk;
use App\Modules\FFmpeg\Filesystem\Media;
use App\Modules\FFmpeg\Filesystem\MediaOnNetwork;
use Spatie\Image\Image;
/**
 * Partly based on this PR:
 * https://github.com/PHP-FFMpeg/PHP-FFMpeg/pull/754/files
 */
class WatermarkFactory
{
    use ForwardsCalls;
    /** position constants */
    public const string LEFT = &apos;left&apos;;
    public const string RIGHT = &apos;right&apos;;
    public const string CENTER = &apos;center&apos;;
    public const string TOP = &apos;top&apos;;
    public const string BOTTOM = &apos;bottom&apos;;
    /**
     * @var \App\Modules\FFmpeg\Filesystem\Disk
     */
    private $disk;
    /**
     * @var \App\Modules\FFmpeg\Filesystem\Media
     */
    private $media;
    /**
     * Offset values.
     */
    private $top;
    private $right;
    private $bottom;
    private $left;
    /**
     * @var \Spatie\Image\Image
     */
    private $image;
    /**
     * Array with the horizontal (x) and verical (y) alignment.
     *
     * @var array
     */
    private $alignments = [];
    /**
     * Uses the &apos;filesystems.default&apos; disk as default.
     */
    public function __construct()
    {
        $this-&gt;disk = Disk::make(config(&apos;filesystems.default&apos;));
    }
    /**
     * Set the disk to open files from.
     */
    public function fromDisk($disk): self
    {
        $this-&gt;disk = Disk::make($disk);
        return $this;
    }
    /**
     * Instantiates a Media object for the given path.
     */
    public function open(string $path): self
    {
        $this-&gt;media = Media::make($this-&gt;disk, $path);
        return $this;
    }
    /**
     * Instantiates a MediaOnNetwork object for the given url and transforms
     * it into a Media object.
     *
     * @param string $path
     * @param array $headers
     * @param callable $withCurl
     * @return self
     */
    public function openUrl(string $path, array $headers = [], callable $withCurl = null): self
    {
        $this-&gt;media = MediaOnNetwork::make($path, $headers)-&gt;toMedia($withCurl);
        return $this;
    }
    /**
     * Sets the offset from to top.
     *
     * @param integer $offset
     * @return self
     */
    public function top($offset = 0): self
    {
        $this-&gt;top = $offset;
        $this-&gt;bottom = null;
        return $this;
    }
    /**
     * Sets the offset from the right.
     *
     * @param integer $offset
     * @return self
     */
    public function right($offset = 0): self
    {
        $this-&gt;right = $offset;
        $this-&gt;left = null;
        return $this;
    }
    /**
     * Sets the offset from the bottom.
     *
     * @param integer $offset
     * @return self
     */
    public function bottom($offset = 0): self
    {
        $this-&gt;bottom = $offset;
        $this-&gt;top = null;
        return $this;
    }
    /**
     * Sets the offset from the left.
     *
     * @param integer $offset
     * @return self
     */
    public function left($offset = 0): self
    {
        $this-&gt;left = $offset;
        $this-&gt;right = null;
        return $this;
    }
    /**
     * Setter for the horizontal alignment with an optional offset.
     *
     * @param string $alignment
     * @param integer $offset
     * @return self
     */
    public function horizontalAlignment(string $alignment, $offset = 0): self
    {
        switch ($alignment) {
            case self::LEFT:
                $this-&gt;alignments[&apos;x&apos;] = $offset;
                break;
            case self::CENTER:
                $this-&gt;alignments[&apos;x&apos;] = &quot;(W-w)/2+{$offset}&quot;;
                break;
            case self::RIGHT:
                $this-&gt;alignments[&apos;x&apos;] = &quot;W-w+{$offset}&quot;;
                break;
        }
        return $this;
    }
    /**
     * Setter for the vertical alignment with an optional offset.
     *
     * @param string $alignment
     * @param integer $offset
     * @return self
     */
    public function verticalAlignment(string $alignment, $offset = 0): self
    {
        switch ($alignment) {
            case self::TOP:
                $this-&gt;alignments[&apos;y&apos;] = $offset;
                break;
            case self::CENTER:
                $this-&gt;alignments[&apos;y&apos;] = &quot;(H-h)/2+{$offset}&quot;;
                break;
            case self::BOTTOM:
                $this-&gt;alignments[&apos;y&apos;] = &quot;H-h+{$offset}&quot;;
                break;
        }
        return $this;
    }
    /**
     * Returns the full path to the watermark file.
     *
     * @return string
     */
    public function getPath(): string
    {
        if (!$this-&gt;image) {
            return $this-&gt;media-&gt;getLocalPath();
        }
        $path = Disk::makeTemporaryDisk()
            -&gt;makeMedia($this-&gt;media-&gt;getFilename())
            -&gt;getLocalPath();
        $this-&gt;image-&gt;save($path);
        return $path;
    }
    /**
     * Returns a new instance of the WatermarkFilter.
     *
     * @return \FFMpeg\Filters\Video\WatermarkFilter
     */
    public function get(): WatermarkFilter
    {
        $path = $this-&gt;getPath();
        if (!empty($this-&gt;alignments)) {
            return new WatermarkFilter($path, $this-&gt;alignments);
        }
        $coordinates = [&apos;position&apos; =&gt; &apos;relative&apos;];
        foreach ([&apos;top&apos;, &apos;right&apos;, &apos;bottom&apos;, &apos;left&apos;] as $attribute) {
            if (is_null($this-&gt;$attribute)) {
                continue;
            }
            $coordinates[$attribute] = $this-&gt;$attribute;
        }
        return new WatermarkFilter($path, $coordinates);
    }
    /**
     * Returns an instance of Image.
     *
     * @return \Spatie\Image\Image
     */
    private function image(): Image
    {
        if (!$this-&gt;image) {
            $this-&gt;image = Image::load($this-&gt;media-&gt;getLocalPath());
        }
        return $this-&gt;image;
    }
    /**
     * Forwards calls to the Image manipulation class.
     */
    public function __call($method, $arguments)
    {
        $this-&gt;forwardCallTo($this-&gt;image(), $method, $arguments);
        return $this;
    }
}</file><file path="app/Modules/FFmpeg/Filters/WatermarkFilter.php">&lt;?php
namespace App\Modules\FFmpeg\Filters;
use FFMpeg\Filters\Video\WatermarkFilter as FFMpegWatermarkFilter;
class WatermarkFilter extends FFMpegWatermarkFilter
{
    protected $path;
    public function __construct($watermarkPath, array $coordinates = [], $priority = 0)
    {
        parent::__construct($watermarkPath, $coordinates, $priority);
        $this-&gt;path = $watermarkPath;
    }
    /**
     * Gets the commands from the base filter and normalizes the path.
     *
     * @return array
     */
    protected function getCommands()
    {
        $commands = parent::getCommands();
        $commands[1] = str_replace($this-&gt;path, static::normalizePath($this-&gt;path), $commands[1]);
        return $commands;
    }
    /**
     * Normalizes the path when running on Windows.
     *
     * @param string $path
     * @return string
     */
    public static function normalizePath(string $path): string
    {
        $path = windows_os() ? static::normalizeWindowsPath($path) : $path;
        return &quot;&apos;{$path}&apos;&quot;;
    }
    /**
     * Replaces the slashes and escapes the colon. For some
     * reason, this filter doesn&apos;t work on Windows with
     * absolute paths that contain forward slashes.
     *
     * @param string $path
     * @return string
     */
    public static function normalizeWindowsPath(string $path): string
    {
        $path = str_replace(&apos;/&apos;, &apos;\\&apos;, $path);
        $path = str_replace(&apos;\\&apos;, &apos;\\\\&apos;, $path);
        $path = str_replace(&apos;:&apos;, &apos;\\:&apos;, $path);
        return $path;
    }
}</file><file path="app/Modules/FFmpeg/Http/DynamicHLSPlaylist.php">&lt;?php
namespace App\Modules\FFmpeg\Http;
use Illuminate\Contracts\Support\Responsable;
use Illuminate\Support\Collection;
use Illuminate\Support\Facades\Response;
use Illuminate\Support\Str;
use App\Modules\FFmpeg\Filesystem\Disk;
use App\Modules\FFmpeg\Filesystem\Media;
class DynamicHLSPlaylist implements Responsable
{
    /**
     * @var \App\Modules\FFmpeg\Filesystem\Disk
     */
    private $disk;
    /**
     * @var \App\Modules\FFmpeg\Filesystem\Media
     */
    private $media;
    /**
     * Callable to retrieve the path to the given key.
     *
     * @var callable
     */
    private $keyResolver;
    /**
     * Callable to retrieve the path to the given media.
     *
     * @var callable
     */
    private $mediaResolver;
    /**
     * @var array
     */
    private $keyCache = [];
    /**
     * @var array
     */
    private $playlistCache = [];
    /**
     * @var array
     */
    private $mediaCache = [];
    /**
     * Uses the &apos;filesystems.default&apos; disk as default.
     */
    public function __construct($disk = null)
    {
        $this-&gt;fromDisk($disk ?: config(&apos;filesystems.default&apos;));
    }
    /**
     * Set the disk to open files from.
     */
    public function fromDisk($disk): self
    {
        $this-&gt;disk = Disk::make($disk);
        return $this;
    }
    /**
     * Instantiates a Media object for the given path and clears the cache.
     */
    public function open(string $path): self
    {
        $this-&gt;media = Media::make($this-&gt;disk, $path);
        $this-&gt;keyCache = [];
        $this-&gt;playlistCache = [];
        $this-&gt;mediaCache = [];
        return $this;
    }
    public function setMediaUrlResolver(callable $mediaResolver): self
    {
        $this-&gt;mediaResolver = $mediaResolver;
        return $this;
    }
    public function setPlaylistUrlResolver(callable $playlistResolver): self
    {
        $this-&gt;playlistResolver = $playlistResolver;
        return $this;
    }
    public function setKeyUrlResolver(callable $keyResolver): self
    {
        $this-&gt;keyResolver = $keyResolver;
        return $this;
    }
    /**
     * Returns the resolved key filename from the cache or resolves it.
     *
     * @param string $key
     * @return string
     */
    private function resolveKeyFilename(string $key): string
    {
        if (array_key_exists($key, $this-&gt;keyCache)) {
            return $this-&gt;keyCache[$key];
        }
        return $this-&gt;keyCache[$key] = call_user_func($this-&gt;keyResolver, $key);
    }
    /**
     * Returns the resolved media filename from the cache or resolves it.
     *
     * @param string $key
     * @return string
     */
    private function resolveMediaFilename(string $media): string
    {
        if (array_key_exists($media, $this-&gt;mediaCache)) {
            return $this-&gt;mediaCache[$media];
        }
        return $this-&gt;mediaCache[$media] = call_user_func($this-&gt;mediaResolver, $media);
    }
    /**
     * Returns the resolved playlist filename from the cache or resolves it.
     *
     * @param string $key
     * @return string
     */
    private function resolvePlaylistFilename(string $playlist): string
    {
        if (array_key_exists($playlist, $this-&gt;playlistCache)) {
            return $this-&gt;playlistCache[$playlist];
        }
        return $this-&gt;playlistCache[$playlist] = call_user_func($this-&gt;playlistResolver, $playlist);
    }
    /**
     * Parses the lines into a Collection
     *
     * @param string $lines
     * @return \Illuminate\Support\Collection
     */
    public static function parseLines(string $lines): Collection
    {
        return Collection::make(preg_split(&apos;/\n|\r\n?/&apos;, $lines));
    }
    /**
     * Returns a boolean wether the line contains a .M3U8 playlist filename
     * or a .TS segment filename.
     *
     * @param string $line
     * @return boolean
     */
    private static function lineHasMediaFilename(string $line): bool
    {
        return !Str::startsWith($line, &apos;#&apos;) &amp;&amp; Str::endsWith($line, [&apos;.m3u8&apos;, &apos;.ts&apos;]);
    }
    /**
     * Returns the filename of the encryption key.
     *
     * @param string $line
     * @return string|null
     */
    private static function extractKeyFromExtLine(string $line): ?string
    {
        preg_match_all(&apos;/#EXT-X-KEY:METHOD=AES-128,URI=&quot;([a-zA-Z0-9-_\/:]+.key)&quot;,IV=[a-z0-9]+/&apos;, $line, $matches);
        return $matches[1][0] ?? null;
    }
    /**
     * Returns the processed content of the playlist.
     *
     * @return string
     */
    public function get(): string
    {
        return $this-&gt;getProcessedPlaylist($this-&gt;media-&gt;getPath());
    }
    /**
     * Returns a collection of all processed segment playlists
     * and the processed main playlist.
     *
     * @return \Illuminate\Support\Collection
     */
    public function all(): Collection
    {
        return static::parseLines(
            $this-&gt;disk-&gt;get($this-&gt;media-&gt;getPath()),
        )-&gt;filter(function ($line) {
            return static::lineHasMediaFilename($line);
        })-&gt;mapWithKeys(function ($segmentPlaylist) {
            return [$segmentPlaylist =&gt; $this-&gt;getProcessedPlaylist($segmentPlaylist)];
        })-&gt;prepend(
            $this-&gt;getProcessedPlaylist($this-&gt;media-&gt;getPath()),
            $this-&gt;media-&gt;getPath(),
        );
    }
    /**
     * Processes the given playlist.
     *
     * @param string $playlistPath
     * @return string
     */
    public function getProcessedPlaylist(string $playlistPath): string
    {
        return static::parseLines($this-&gt;disk-&gt;get($playlistPath))-&gt;map(function (string $line) {
            if (static::lineHasMediaFilename($line)) {
                return Str::endsWith($line, &apos;.m3u8&apos;)
                    ? $this-&gt;resolvePlaylistFilename($line)
                    : $this-&gt;resolveMediaFilename($line);
            }
            $key = static::extractKeyFromExtLine($line);
            if (!$key) {
                return $line;
            }
            return str_replace(
                &apos;#EXT-X-KEY:METHOD=AES-128,URI=&quot;&apos; . $key . &apos;&quot;&apos;,
                &apos;#EXT-X-KEY:METHOD=AES-128,URI=&quot;&apos; . $this-&gt;resolveKeyFilename($key) . &apos;&quot;&apos;,
                $line,
            );
        })-&gt;implode(PHP_EOL);
    }
    public function toResponse($request)
    {
        return Response::make($this-&gt;get(), 200, [
            &apos;Content-Type&apos; =&gt; &apos;application/vnd.apple.mpegurl&apos;,
        ]);
    }
}</file><file path="app/Modules/FFmpeg/MediaOpener.php">&lt;?php
namespace App\Modules\FFmpeg;
use App\Modules\FFmpeg\Drivers\PHPFFMpeg;
use Illuminate\Container\Container;
use Illuminate\Filesystem\FilesystemManager;
use Illuminate\Support\Arr;
use Illuminate\Support\Traits\ForwardsCalls;
/**
 * @mixin PHPFFMpeg
 */
class MediaOpener
{
    use ForwardsCalls;
    /**
     * @var \App\Modules\FFmpeg\Filesystem\Disk
     */
    private $disk;
    /**
     * @var \App\Modules\FFmpeg\Drivers\PHPFFMpeg
     */
    private $driver;
    /**
     * @var \App\Modules\FFmpeg\Filesystem\MediaCollection
     */
    private $collection;
    /**
     * @var \FFMpeg\Coordinate\TimeCode
     */
    private $timecode;
    /**
     * Uses the &apos;filesystems.default&apos; disk from the config if none is given.
     * Gets the underlying PHPFFMpeg instance from the container if none is given.
     * Instantiates a fresh MediaCollection if none is given.
     */
    public function __construct($disk = null, PHPFFMpeg $driver = null, MediaCollection $mediaCollection = null)
    {
        $this-&gt;fromDisk($disk ?: config(&apos;plugin.webman-tech.laravel-filesystem.filesystems.default&apos;));
        $this-&gt;driver = ($driver ?: Container::get(PHPFFMpeg::class))-&gt;fresh();
        $this-&gt;collection = $mediaCollection ?: new MediaCollection();
    }
    public function clone(): self
    {
        return new MediaOpener(
            $this-&gt;disk,
            $this-&gt;driver,
            $this-&gt;collection,
        );
    }
    /**
     * Set the disk to open files from.
     */
    public function fromDisk($disk): self
    {
        $this-&gt;disk = Disk::make($disk);
        return $this;
    }
    /**
     * Alias for &apos;fromDisk&apos;, mostly for backwards compatibility.
     */
    public function fromFilesystem(Filesystem $filesystem): self
    {
        return $this-&gt;fromDisk($filesystem);
    }
    private static function makeLocalDiskFromPath(string $path): Disk
    {
        $adapter = Container::get(FilesystemManager::class)-&gt;createLocalDriver([
            &apos;root&apos; =&gt; $path,
        ]);
        return Disk::make($adapter);
    }
    /**
     * Instantiates a Media object for each given path.
     */
    public function open($paths): self
    {
        foreach (Arr::wrap($paths) as $path) {
            if ($path instanceof UploadFile) {
                $disk = static::makeLocalDiskFromPath($path-&gt;getPath());
                $media = Media::make($disk, $path-&gt;getFilename());
            } else {
                $media = Media::make($this-&gt;disk, $path);
            }
            $this-&gt;collection-&gt;push($media);
        }
        return $this;
    }
    /**
     * Instantiates a single Media object and sets the given options on the object.
     *
     * @param string $path
     * @param array $options
     * @return self
     */
    public function openWithInputOptions(string $path, array $options = []): self
    {
        $this-&gt;collection-&gt;push(
            Media::make($this-&gt;disk, $path)-&gt;setInputOptions($options),
        );
        return $this;
    }
    /**
     * Instantiates a MediaOnNetwork object for each given url.
     */
    public function openUrl($paths, array $headers = []): self
    {
        foreach (Arr::wrap($paths) as $path) {
            $this-&gt;collection-&gt;push(MediaOnNetwork::make($path, $headers));
        }
        return $this;
    }
    public function get(): MediaCollection
    {
        return $this-&gt;collection;
    }
    public function getDriver(): PHPFFMpeg
    {
        return $this-&gt;driver-&gt;open($this-&gt;collection);
    }
    /**
     * Forces the driver to open the collection with the `openAdvanced` method.
     */
    public function getAdvancedDriver(): PHPFFMpeg
    {
        return $this-&gt;driver-&gt;openAdvanced($this-&gt;collection);
    }
    /**
     * Shortcut to set the timecode by string.
     */
    public function getFrameFromString(string $timecode): self
    {
        return $this-&gt;getFrameFromTimecode(TimeCode::fromString($timecode));
    }
    /**
     * Shortcut to set the timecode by seconds.
     */
    public function getFrameFromSeconds(float $seconds): self
    {
        return $this-&gt;getFrameFromTimecode(TimeCode::fromSeconds($seconds));
    }
    public function getFrameFromTimecode(TimeCode $timecode): self
    {
        $this-&gt;timecode = $timecode;
        return $this;
    }
    /**
     * Returns an instance of MediaExporter with the driver and timecode (if set).
     */
    public function export(): MediaExporter
    {
        return tap(new MediaExporter($this-&gt;getDriver()), function (MediaExporter $mediaExporter) {
            if ($this-&gt;timecode) {
                $mediaExporter-&gt;frame($this-&gt;timecode);
            }
        });
    }
    /**
     * Returns an instance of HLSExporter with the driver forced to AdvancedMedia.
     */
    public function exportForHLS(): HLSExporter
    {
        return new HLSExporter($this-&gt;getAdvancedDriver());
    }
    /**
     * Returns an instance of MediaExporter with a TileFilter and ImageFormat.
     */
    public function exportTile(callable $withTileFactory): MediaExporter
    {
        return $this-&gt;export()
            -&gt;addTileFilter($withTileFactory)
            -&gt;inFormat(new ImageFormat());
    }
    public function exportFramesByAmount(int $amount, int $width = null, int $height = null, int $quality = null): MediaExporter
    {
        $interval = ($this-&gt;getDurationInSeconds() + 1) / $amount;
        return $this-&gt;exportFramesByInterval($interval, $width, $height, $quality);
    }
    public function exportFramesByInterval(float $interval, int $width = null, int $height = null, int $quality = null): MediaExporter
    {
        return $this-&gt;exportTile(
            fn(TileFactory $tileFactory)
                =&gt; $tileFactory
                -&gt;interval($interval)
                -&gt;grid(1, 1)
                -&gt;scale($width, $height)
                -&gt;quality($quality),
        );
    }
    public function cleanupTemporaryFiles(): self
    {
        Container::get(TemporaryDirectories::class)-&gt;deleteAll();
        return $this;
    }
    public function each($items, callable $callback): self
    {
        Collection::make($items)-&gt;each(function ($item, $key) use ($callback) {
            return $callback($this-&gt;clone(), $item, $key);
        });
        return $this;
    }
    /**
     * Returns the Media object from the driver.
     */
    public function __invoke(): AbstractMediaType
    {
        return $this-&gt;getDriver()-&gt;get();
    }
    /**
     * Forwards all calls to the underlying driver.
     * @return void
     */
    public function __call($method, $arguments)
    {
        $result = $this-&gt;forwardCallTo($driver = $this-&gt;getDriver(), $method, $arguments);
        return ($result === $driver) ? $this : $result;
    }
}</file><file path="app/Modules/FFmpeg/Support/Container.php">&lt;?php
namespace App\Modules\FFmpeg\Support;
/**
 * Class Container
 * @package support
 * @method static mixed get($name)
 * @method static mixed make($name, array $parameters)
 * @method static bool has($name)
 */
class Container
{
    /**
     * Instance
     * @param string $plugin
     * @return array|mixed|void|null
     */
    public static function instance()
    {
        return \support\Container::instance(&apos;brooke1220.webman-ffmpeg&apos;);
    }
    /**
     * @param string $name
     * @param array $arguments
     * @return mixed
     */
    public static function __callStatic(string $name, array $arguments)
    {
        return static::instance()-&gt;{$name}(... $arguments);
    }
}</file><file path="app/Modules/FFmpeg/Support/FFMpeg.php">&lt;?php
namespace App\Modules\FFmpeg\Support;
/**
 * @method static \App\Modules\FFmpeg\Http\DynamicHLSPlaylist dynamicHLSPlaylist($disk)
 * @method static \App\Modules\FFmpeg\MediaOpener fromDisk($disk)
 * @method static \App\Modules\FFmpeg\MediaOpener fromFilesystem(\Illuminate\Contracts\Filesystem\Filesystem $filesystem)
 * @method static \App\Modules\FFmpeg\MediaOpener open($path)
 * @method static \App\Modules\FFmpeg\MediaOpener openUrl($path, array $headers = [])
 * @method static \App\Modules\FFmpeg\MediaOpener cleanupTemporaryFiles()
 *
 * @see \App\Modules\FFmpeg\MediaOpener
 */
class FFMpeg
{
    public static function instance(): MediaOpenerFactory
    {
        return Container::get(&apos;webman-ffmpeg&apos;);
    }
    public static function __callStatic($name, $arguments)
    {
        return static::instance()-&gt;{$name}(...$arguments);
    }
}</file><file path="app/Modules/FFmpeg/Support/MediaOpenerFactory.php">&lt;?php
namespace App\Modules\FFmpeg\Support;
use Illuminate\Support\Traits\ForwardsCalls;
use App\Modules\FFmpeg\Drivers\PHPFFMpeg;
use App\Modules\FFmpeg\Http\DynamicHLSPlaylist;
use App\Modules\FFmpeg\MediaOpener;
class MediaOpenerFactory
{
    use ForwardsCalls;
    private $defaultDisk;
    private $driver;
    private $driverResolver;
    public function __construct(string $defaultDisk, PHPFFMpeg $driver = null, callable $driverResolver = null)
    {
        $this-&gt;defaultDisk = $defaultDisk;
        $this-&gt;driver = $driver;
        $this-&gt;driverResolver = $driverResolver;
    }
    private function driver(): PHPFFMpeg
    {
        if ($this-&gt;driver) {
            return $this-&gt;driver;
        }
        $resolver = $this-&gt;driverResolver;
        return $this-&gt;driver = $resolver();
    }
    public function new(): MediaOpener
    {
        return new MediaOpener($this-&gt;defaultDisk, $this-&gt;driver());
    }
    public function dynamicHLSPlaylist(): DynamicHLSPlaylist
    {
        return new DynamicHLSPlaylist($this-&gt;defaultDisk);
    }
    /**
     * Handle dynamic method calls into the MediaOpener.
     *
     * @param string $method
     * @param array $parameters
     * @return mixed
     */
    public function __call($method, $parameters)
    {
        return $this-&gt;forwardCallTo($this-&gt;new(), $method, $parameters);
    }
}</file><file path="app/Modules/FFmpeg/Support/ProcessOutput.php">&lt;?php
namespace App\Modules\FFmpeg\Support;
class ProcessOutput
{
    private $all;
    private $errors;
    private $out;
    public function __construct(array $all, array $errors, array $out)
    {
        $this-&gt;all = $all;
        $this-&gt;errors = $errors;
        $this-&gt;out = $out;
    }
    public function all(): array
    {
        return $this-&gt;all;
    }
    public function errors(): array
    {
        return $this-&gt;errors;
    }
    public function out(): array
    {
        return $this-&gt;out;
    }
}</file><file path="app/Modules/FFmpeg/Support/StreamParser.php">&lt;?php
namespace App\Modules\FFmpeg\Support;
use FFMpeg\FFProbe\DataMapping\Stream;
use Illuminate\Support\Str;
class StreamParser
{
    private Stream $stream;
    public function __construct(Stream $stream)
    {
        $this-&gt;stream = $stream;
    }
    public static function new(Stream $stream): StreamParser
    {
        return new static($stream);
    }
    public function getFrameRate(): ?string
    {
        $frameRate = trim(optional($this-&gt;stream)-&gt;get(&apos;avg_frame_rate&apos;));
        if (!$frameRate || Str::endsWith($frameRate, &apos;/0&apos;)) {
            return null;
        }
        if (Str::contains($frameRate, &apos;/&apos;)) {
            [$numerator, $denominator] = explode(&apos;/&apos;, $frameRate);
            $frameRate = $numerator / $denominator;
        }
        return $frameRate ? number_format($frameRate, 3, &apos;.&apos;, &apos;&apos;) : null;
    }
}</file><file path="app/Modules/Filesystem/Exceptions/UnreadablePathException.php">&lt;?php
namespace App\Modules\Filesystem\Exceptions;
class UnreadablePathException extends \RuntimeException
{
}</file><file path="app/Modules/Filesystem/MimeExtension.php">&lt;?php
namespace App\Modules\Filesystem;
class MimeExtension
{
    public const array EXT_MIME_MAP = [
        // images
        &apos;png&apos; =&gt; &apos;image/png&apos;,
        &apos;jpe&apos; =&gt; &apos;image/jpeg&apos;,
        &apos;jpeg&apos; =&gt; &apos;image/jpeg&apos;,
        &apos;jpg&apos; =&gt; &apos;image/jpeg&apos;,
        &apos;gif&apos; =&gt; &apos;image/gif&apos;,
        &apos;bmp&apos; =&gt; &apos;image/bmp&apos;,
        &apos;ico&apos; =&gt; &apos;image/vnd.microsoft.icon&apos;,
        &apos;tiff&apos; =&gt; &apos;image/tiff&apos;,
        &apos;tif&apos; =&gt; &apos;image/tiff&apos;,
        &apos;svg&apos; =&gt; &apos;image/svg+xml&apos;,
        &apos;svgz&apos; =&gt; &apos;image/svg+xml&apos;,
        // audio
        &apos;mp3&apos; =&gt; &apos;audio/mpeg&apos;,
        &apos;wav&apos; =&gt; &apos;audio/x-wav&apos;,
        &apos;ogg&apos; =&gt; &apos;audio/ogg&apos;,
        &apos;m4a&apos; =&gt; &apos;audio/x-m4a&apos;,
        &apos;flac&apos; =&gt; &apos;audio/x-flac&apos;,
        &apos;aac&apos; =&gt; &apos;audio/x-aac&apos;,
        &apos;wma&apos; =&gt; &apos;audio/x-ms-wma&apos;,
        &apos;mid&apos; =&gt; &apos;audio/midi&apos;,
        &apos;midi&apos; =&gt; &apos;audio/midi&apos;,
        &apos;kar&apos; =&gt; &apos;audio/midi&apos;,
        &apos;ra&apos; =&gt; &apos;audio/x-realaudio&apos;,
        &apos;ram&apos; =&gt; &apos;audio/x-pn-realaudio&apos;,
        &apos;rm&apos; =&gt; &apos;audio/x-pn-realaudio&apos;,
        &apos;rpm&apos; =&gt; &apos;audio/x-pn-realaudio-plugin&apos;,
        &apos;wax&apos; =&gt; &apos;audio/x-ms-wax&apos;,
        &apos;au&apos; =&gt; &apos;audio/basic&apos;,
        &apos;snd&apos; =&gt; &apos;audio/basic&apos;,
        &apos;aif&apos; =&gt; &apos;audio/x-aiff&apos;,
        &apos;m3u&apos; =&gt; &apos;audio/x-mpegurl&apos;,
        // video
        &apos;qt&apos; =&gt; &apos;video/quicktime&apos;,
        &apos;mov&apos; =&gt; &apos;video/quicktime&apos;,
    ];
    public static function getExtension(string $mime): string|null
    {
        return self::EXT_MIME_MAP[$mime] ?? null;
    }
    public static function getMime(string $extension): string|null
    {
        return array_search($extension, self::EXT_MIME_MAP, true) ?? null;
    }
}</file><file path="app/Modules/Filesystem/Path.php">&lt;?php
namespace App\Modules\Filesystem;
use App\Modules\Filesystem\Exceptions\UnreadablePathException;
class Path
{
    public static function exists(string $path): bool
    {
        $type = filetype($path);
        return $type === &apos;file&apos; || $type === &apos;dir&apos;;
    }
    public static function isReadable(string $path): bool
    {
        return is_readable($path);
    }
    public static function isDirectory(string $path): bool
    {
        return filetype($path) === &apos;dir&apos;;
    }
    public static function isFile(string $path): bool
    {
        return filetype($path) === &apos;file&apos;;
    }
    /**
     * @param string $path
     *
     * @return int
     */
    public static function size(string $path): int
    {
        if (!static::isReadable($path)) {
            throw new UnreadablePathException($path);
        }
        if (static::isDirectory($path)) {
            $stat = stat($path);
            return $stat[&apos;size&apos;];
        }
        return filesize($path);
    }
}</file><file path="app/Modules/Http/Concerns/DirectStreamableFile.php">&lt;?php
namespace App\Modules\Http\Concerns;
interface DirectStreamableFile
{
    /**
     * Get the path of the file
     */
    public function getPath(): string;
    /**
     * Get the size of the file in bytes
     */
    public function getSize(): int;
    /**
     * Get the mime type of the file
     */
    public function getMimeType(): string;
}</file><file path="app/Modules/Http/Resources/Json/JsonAnonymousResourceCollection.php">&lt;?php
namespace App\Modules\Http\Resources\Json;
use Illuminate\Http\Resources\Json\AnonymousResourceCollection;
class JsonAnonymousResourceCollection extends AnonymousResourceCollection
{
    protected function preparePaginatedResponse($request)
    {
        if ($this-&gt;preserveAllQueryParameters) {
            $this-&gt;resource-&gt;appends($request-&gt;query());
        } else if (!is_null($this-&gt;queryParameters)) {
            $this-&gt;resource-&gt;appends($this-&gt;queryParameters);
        }
        return (new JsonPaginatedResourceResponse($this))-&gt;toResponse($request);
    }
}</file><file path="app/Modules/Http/Resources/Json/JsonPaginatedResourceResponse.php">&lt;?php
namespace App\Modules\Http\Resources\Json;
use Illuminate\Http\Resources\Json\PaginatedResourceResponse;
class JsonPaginatedResourceResponse extends PaginatedResourceResponse
{
    protected function paginationInformation($request)
    {
        $paginated = $this-&gt;resource-&gt;resource-&gt;toArray();
        $default = [
            &apos;links&apos; =&gt; $this-&gt;paginationLinks($paginated),
            ...$this-&gt;meta($paginated),
        ];
        if (method_exists($this-&gt;resource, &apos;paginationInformation&apos;) ||
            $this-&gt;resource-&gt;hasMacro(&apos;paginationInformation&apos;)) {
            return $this-&gt;resource-&gt;paginationInformation($request, $paginated, $default);
        }
        return $default;
    }
}</file><file path="app/Modules/Humanize/bytes.php">&lt;?php
namespace App\Modules\Humanize;
function humanize_bytes(int|float $bytes, $decimals = 2): string
{
    if ($bytes &lt; 1024) {
        return $bytes . &apos; B&apos;;
    }
    $factor = floor(log($bytes, 1024));
    return sprintf(&quot;%.{$decimals}f &quot;, $bytes / (1024 ** $factor)) . [&apos;B&apos;, &apos;KB&apos;, &apos;MB&apos;, &apos;GB&apos;, &apos;TB&apos;, &apos;PB&apos;][$factor];
}</file><file path="app/Modules/LogStreamer/LogFileService.php">&lt;?php
namespace App\Modules\LogStreamer;
use Illuminate\Support\Collection;
use Illuminate\Support\Facades\File;
use Symfony\Component\Finder\SplFileInfo;
class LogFileService
{
    public function getFiles(): Collection
    {
        return collect(File::allFiles(storage_path(&apos;logs&apos;)))
            -&gt;filter(fn(SplFileInfo $log) =&gt; $log-&gt;getExtension() === &apos;log&apos;);
    }
    public function getSortedFiles()
    {
        return $this-&gt;getFiles()
            -&gt;map(function (SplFileInfo $log) {
                return [
                    &apos;fileName&apos; =&gt; $log-&gt;getRelativePathname(),
                ];
            })
            -&gt;sortByDesc(&apos;label&apos;)
            -&gt;values();
    }
}</file><file path="app/Modules/LogStreamer/SearchableLogFile.php">&lt;?php
namespace App\Modules\LogStreamer;
use Symfony\Component\Process\Process;
class SearchableLogFile
{
    public function __construct(
        public string $path,
    )
    {
    }
    /**
     * Calculates the number of lines in a file.
     *
     * @return int The number of lines in the file.
     */
    public function numberOfLines()
    {
        return (int)$this-&gt;execCommand(&apos;awk&apos;, &apos;END {print NR}&apos;, $this-&gt;path);
    }
    /**
     * Retrieves the content of a file starting from a specified line number
     *
     * @param int $lineNumber The line number to start retrieving the content from.
     * @return string The content of the file after the specified line number.
     */
    public function contentAfterLine(int $lineNumber)
    {
        return $this-&gt;execCommand(&apos;awk&apos;, &quot;NR &gt; {$lineNumber}&quot;, $this-&gt;path);
    }
    private function execCommand(string $command, ...$args)
    {
        $process = new Process(array_merge([$command], $args));
        $process-&gt;run();
        return $process-&gt;getOutput();
    }
}</file><file path="app/Modules/Lyrics/Lrc.php">&lt;?php
namespace App\Modules\Lyrics;
class Lrc
{
    public const string FILE_EXTENSION = &apos;lrc&apos;;
}</file><file path="app/Modules/MediaMeta/Encoding.php">&lt;?php
namespace App\Modules\MediaMeta;
/**
 * The Encoding interface defines constants for text encodings used in ID3v2 frames.
 */
interface Encoding
{
    /** The ISO-8859-1 encoding. */
    public const int ISO88591 = 0;
    /** The UTF-16 Unicode encoding with BOM. */
    public const int UTF16 = 1;
    /** The UTF-16BE Unicode encoding without BOM. */
    public const int UTF16BE = 2;
    /** The UTF-8 Unicode encoding. */
    public const int UTF8 = 3;
    /** The UTF-16LE Unicode encoding without BOM. */
    public const int UTF16LE = 4;
    /**
     * Returns the text encoding.
     */
    public function getEncoding(): int;
    /**
     * Sets the text encoding.
     */
    public function setEncoding(int $encoding): self;
}</file><file path="app/Modules/MediaMeta/Frame/Apic.php">&lt;?php
namespace App\Modules\MediaMeta\Frame;
use App\Modules\MediaMeta\Encoding;
/**
 * The Attached picture frame contains a picture directly related to the audio file.
 *
 * There may be several pictures attached to one file, each in their individual
 * APIC frame, but only one with the same content descriptor. There may only
 * be one picture with the same picture type.
 */
class Apic extends Frame
{
    /**
     * The list of image types.
     */
    public static array $types = [
        &apos;Other&apos;,
        &apos;32x32 pixels file icon (PNG only)&apos;,
        &apos;Other file icon&apos;,
        &apos;Cover (front)&apos;,
        &apos;Cover (back)&apos;,
        &apos;Leaflet page&apos;,
        &apos;Media (e.g. label side of CD)&apos;,
        &apos;Lead artist/lead performer/soloist&apos;,
        &apos;Artist/performer&apos;,
        &apos;Conductor&apos;,
        &apos;Band/Orchestra&apos;,
        &apos;Composer&apos;,
        &apos;Lyricist/text writer&apos;,
        &apos;Recording Location&apos;,
        &apos;During recording&apos;,
        &apos;During performance&apos;,
        &apos;Movie/video screen capture&apos;,
        &apos;A bright coloured fish&apos;,
        &apos;Illustration&apos;,
        &apos;Band/artist logotype&apos;,
        &apos;Publisher/Studio logotype&apos;,
    ];
    protected string $mimeType = &apos;image/unknown&apos;;
    protected int $imageType = 0;
    protected string $description = &apos;&apos;;
    protected string $imageData = &apos;&apos;;
    protected int $imageSize = 0;
    /**
     * @param array|null $data {
     *     mimeType: string, The MIME type.
     *     imageType: int, The image type.
     *     description: string, The description.
     *     imageData: string The image data.
     * }
     * @param int $encoding The encoding of the frame data.
     * @return void
     */
    public function __construct(
        ?array $data = null,
        int    $encoding = Encoding::UTF8,
    )
    {
        parent::__construct(&apos;APIC&apos;, $encoding);
        if ($data === null) {
            return;
        }
        $this-&gt;mimeType = $data[&apos;mimeType&apos;] ?? $this-&gt;mimeType;
        $this-&gt;imageType = $data[&apos;imageType&apos;] ?? $this-&gt;imageType;
        $this-&gt;description = $data[&apos;description&apos;] ?? $this-&gt;description;
        if (isset($data[&apos;imageData&apos;])) {
            $this-&gt;imageData = $data[&apos;imageData&apos;];
            $this-&gt;imageSize = strlen($this-&gt;imageData);
        }
    }
    /**
     * Returns the MIME type.
     */
    public function getMimeType(): string
    {
        return $this-&gt;mimeType;
    }
    /**
     * Sets the MIME type.
     */
    public function setMimeType(string $mimeType): self
    {
        $this-&gt;mimeType = $mimeType;
        return $this;
    }
    /**
     * Returns the image type.
     */
    public function getImageType(): int
    {
        return $this-&gt;imageType;
    }
    /**
     * Sets the image type.
     */
    public function setImageType(int $imageType): self
    {
        $this-&gt;imageType = $imageType;
        return $this;
    }
    /**
     * Returns the description.
     */
    public function getDescription(): string
    {
        return $this-&gt;description;
    }
    /**
     * Sets the description.
     */
    public function setDescription(string $description): self
    {
        $this-&gt;description = $description;
        return $this;
    }
    /**
     * Returns the image data.
     */
    public function getImageData(): string
    {
        return $this-&gt;imageData;
    }
    /**
     * Sets the image data.
     */
    public function setImageData(string $imageData): self
    {
        $this-&gt;imageData = $imageData;
        $this-&gt;imageSize = strlen($imageData);
        return $this;
    }
    /**
     * Returns the image size.
     */
    public function getImageSize(): int
    {
        return $this-&gt;imageSize;
    }
    /**
     * Parses the frame data.
     */
    public function parse(string $frameData): self
    {
        // The first byte is text encoding
        $encoding = ord($frameData[0]);
        // Find the null terminator for the MIME type
        $mimeTypeEnd = strpos($frameData, &quot;\0&quot;, 1);
        $this-&gt;mimeType = substr($frameData, 1, $mimeTypeEnd - 1);
        // Next byte is picture type
        $this-&gt;imageType = ord($frameData[$mimeTypeEnd + 1]);
        // Find the null terminator for the description
        $descriptionStart = $mimeTypeEnd + 2;
        $isUnicode = in_array($encoding, [Encoding::UTF16, Encoding::UTF16BE]);
        $nullTerminator = $isUnicode ? &quot;\0\0&quot; : &quot;\0&quot;;
        $descriptionEnd = strpos($frameData, $nullTerminator, $descriptionStart);
        $descriptionLength = $descriptionEnd - $descriptionStart;
        // Process description based on encoding
        $this-&gt;description = match ($encoding) {
            Encoding::UTF16, Encoding::UTF16BE =&gt; mb_convert_encoding(
                substr($frameData, $descriptionStart, $descriptionLength),
                &apos;UTF-8&apos;,
                &apos;UTF-16&apos;,
            ),
            Encoding::UTF16LE =&gt; mb_convert_encoding(
                substr($frameData, $descriptionStart, $descriptionLength),
                &apos;UTF-8&apos;,
                &apos;UTF-16LE&apos;,
            ),
            Encoding::UTF8 =&gt; substr($frameData, $descriptionStart, $descriptionLength),
            default =&gt; mb_convert_encoding(
                substr($frameData, $descriptionStart, $descriptionLength),
                &apos;UTF-8&apos;,
                &apos;ISO-8859-1&apos;,
            )
        };
        // Calculate image data start position
        $imageDataStart = $descriptionEnd + ($isUnicode ? 2 : 1);
        // The rest is image data
        $this-&gt;imageData = substr($frameData, $imageDataStart);
        $this-&gt;imageSize = strlen($this-&gt;imageData);
        return $this;
    }
    /**
     * Converts the frame to binary data.
     */
    public function toBytes(): string
    {
        // Determine if we&apos;re using Unicode
        $isUnicode = in_array($this-&gt;encoding, [Encoding::UTF16, Encoding::UTF16BE]);
        $nullTerminator = $isUnicode ? &quot;\0\0&quot; : &quot;\0&quot;;
        // Convert description to the specified encoding
        $encodedDescription = match ($this-&gt;encoding) {
            Encoding::UTF16, Encoding::UTF16BE =&gt; mb_convert_encoding($this-&gt;description, &apos;UTF-16&apos;, &apos;UTF-8&apos;),
            Encoding::UTF16LE =&gt; mb_convert_encoding($this-&gt;description, &apos;UTF-16LE&apos;, &apos;UTF-8&apos;),
            Encoding::UTF8 =&gt; $this-&gt;description,
            default =&gt; mb_convert_encoding($this-&gt;description, &apos;ISO-8859-1&apos;, &apos;UTF-8&apos;)
        };
        // Start with the encoding byte
        $data = chr($this-&gt;encoding);
        // Add the MIME type with null terminator
        $data .= $this-&gt;mimeType . &quot;\0&quot;;
        // Add the image type byte
        $data .= chr($this-&gt;imageType);
        // Add the description with null terminator
        $data .= $encodedDescription . $nullTerminator;
        // Add the image data
        $data .= $this-&gt;imageData;
        return $data;
    }
}</file><file path="app/Modules/MediaMeta/Frame/COMM.php">&lt;?php
namespace App\Modules\MediaMeta\Frame;
use App\Modules\MediaMeta\Encoding;
/**
 * COMM frame - Comments.
 *
 * The &apos;Comments&apos; frame is intended for any kind of full text information
 * that does not fit in any other frame. It consists of a description and
 * the actual text. There may be more than one comment frame in each tag,
 * but only one with the same language and description.
 */
class COMM extends Frame
{
    /**
     * Constructs the COMM frame with given parameters.
     */
    public function __construct(
        protected string $text = &apos;&apos;,
        protected string $description = &apos;&apos;,
        protected string $language = &apos;eng&apos;,
        int              $encoding = Encoding::UTF8,
    )
    {
        parent::__construct(&apos;COMM&apos;, $encoding);
        $this-&gt;language = substr($language, 0, 3);
    }
    /**
     * Returns the language code.
     */
    public function getLanguage(): string
    {
        return $this-&gt;language;
    }
    /**
     * Sets the language code.
     */
    public function setLanguage(string $language): self
    {
        $this-&gt;language = substr($language, 0, 3);
        return $this;
    }
    /**
     * Returns the description.
     */
    public function getDescription(): string
    {
        return $this-&gt;description;
    }
    /**
     * Sets the description.
     */
    public function setDescription(string $description): self
    {
        $this-&gt;description = $description;
        return $this;
    }
    /**
     * Returns the comment text.
     */
    public function getText(): string
    {
        return $this-&gt;text;
    }
    /**
     * Sets the comment text.
     */
    public function setText(string $text): self
    {
        $this-&gt;text = $text;
        return $this;
    }
    /**
     * Parses the frame data.
     */
    public function parse(string $frameData): self
    {
        // The first byte is text encoding
        $encoding = ord($frameData[0]);
        // The next 3 bytes are language
        $this-&gt;language = substr($frameData, 1, 3);
        // Find the null terminator for the description
        $descriptionStart = 4;
        $isUnicode = in_array($encoding, [Encoding::UTF16, Encoding::UTF16BE]);
        $nullTerminator = $isUnicode ? &quot;\0\0&quot; : &quot;\0&quot;;
        $descriptionEnd = strpos($frameData, $nullTerminator, $descriptionStart);
        $descriptionLength = $descriptionEnd - $descriptionStart;
        // Process description based on encoding
        $this-&gt;description = match ($encoding) {
            Encoding::UTF16, Encoding::UTF16BE =&gt; mb_convert_encoding(
                substr($frameData, $descriptionStart, $descriptionLength),
                &apos;UTF-8&apos;,
                &apos;UTF-16&apos;,
            ),
            Encoding::UTF16LE =&gt; mb_convert_encoding(
                substr($frameData, $descriptionStart, $descriptionLength),
                &apos;UTF-8&apos;,
                &apos;UTF-16LE&apos;,
            ),
            Encoding::UTF8 =&gt; substr($frameData, $descriptionStart, $descriptionLength),
            default =&gt; mb_convert_encoding(
                substr($frameData, $descriptionStart, $descriptionLength),
                &apos;UTF-8&apos;,
                &apos;ISO-8859-1&apos;,
            )
        };
        // Calculate text start position
        $textStart = $descriptionEnd + ($isUnicode ? 2 : 1);
        // The rest is text
        $text = substr($frameData, $textStart);
        // Process text based on encoding
        $this-&gt;text = match ($encoding) {
            Encoding::UTF16, Encoding::UTF16BE =&gt; mb_convert_encoding($text, &apos;UTF-8&apos;, &apos;UTF-16&apos;),
            Encoding::UTF16LE =&gt; mb_convert_encoding($text, &apos;UTF-8&apos;, &apos;UTF-16LE&apos;),
            Encoding::UTF8 =&gt; $text,
            default =&gt; mb_convert_encoding($text, &apos;UTF-8&apos;, &apos;ISO-8859-1&apos;)
        };
        return $this;
    }
    /**
     * Converts the frame to binary data.
     */
    public function toBytes(): string
    {
        // Determine if we&apos;re using Unicode
        $isUnicode = in_array($this-&gt;encoding, [Encoding::UTF16, Encoding::UTF16BE]);
        $nullTerminator = $isUnicode ? &quot;\0\0&quot; : &quot;\0&quot;;
        // Convert description to the specified encoding
        $encodedDescription = match ($this-&gt;encoding) {
            Encoding::UTF16, Encoding::UTF16BE =&gt; mb_convert_encoding($this-&gt;description, &apos;UTF-16&apos;, &apos;UTF-8&apos;),
            Encoding::UTF16LE =&gt; mb_convert_encoding($this-&gt;description, &apos;UTF-16LE&apos;, &apos;UTF-8&apos;),
            Encoding::UTF8 =&gt; $this-&gt;description,
            default =&gt; mb_convert_encoding($this-&gt;description, &apos;ISO-8859-1&apos;, &apos;UTF-8&apos;)
        };
        // Convert text to the specified encoding
        $encodedText = match ($this-&gt;encoding) {
            Encoding::UTF16, Encoding::UTF16BE =&gt; mb_convert_encoding($this-&gt;text, &apos;UTF-16&apos;, &apos;UTF-8&apos;),
            Encoding::UTF16LE =&gt; mb_convert_encoding($this-&gt;text, &apos;UTF-16LE&apos;, &apos;UTF-8&apos;),
            Encoding::UTF8 =&gt; $this-&gt;text,
            default =&gt; mb_convert_encoding($this-&gt;text, &apos;ISO-8859-1&apos;, &apos;UTF-8&apos;)
        };
        // Return the encoding byte, language, description with null terminator, and text
        return chr($this-&gt;encoding) . $this-&gt;language . $encodedDescription . $nullTerminator . $encodedText;
    }
}</file><file path="app/Modules/MediaMeta/Frame/EQUA.php">&lt;?php
namespace App\Modules\MediaMeta\Frame;
use App\Modules\MediaMeta\Encoding;
/**
 * EQUA frame - Equalization.
 *
 * The &apos;Equalization&apos; frame allows the user to adjust the audio to their taste by specifying
 * frequency adjustments. It contains an adjustment bit and a list of frequency/adjustment pairs.
 */
class EQUA extends Frame
{
    /**
     * Constructs the EQUA frame with given parameters.
     */
    public function __construct(
        protected bool  $adjustmentBit = false,
        protected array $adjustments = [],
    )
    {
        parent::__construct(&apos;EQUA&apos;, Encoding::UTF8);
    }
    /**
     * Returns the adjustment bit.
     */
    public function getAdjustmentBit(): bool
    {
        return $this-&gt;adjustmentBit;
    }
    /**
     * Sets the adjustment bit.
     */
    public function setAdjustmentBit(bool $adjustmentBit): self
    {
        $this-&gt;adjustmentBit = $adjustmentBit;
        return $this;
    }
    /**
     * Returns the frequency adjustments.
     */
    public function getAdjustments(): array
    {
        return $this-&gt;adjustments;
    }
    /**
     * Sets the frequency adjustments.
     */
    public function setAdjustments(array $adjustments): self
    {
        $this-&gt;adjustments = $adjustments;
        return $this;
    }
    /**
     * Adds a frequency adjustment.
     */
    public function addAdjustment(int $frequency, int $adjustment): self
    {
        $this-&gt;adjustments[$frequency] = $adjustment;
        return $this;
    }
    /**
     * Parses the frame data.
     */
    public function parse(string $frameData): self
    {
        // The first byte is the adjustment bit
        if (strlen($frameData) &lt; 1) {
            return $this;
        }
        $this-&gt;adjustmentBit = (bool)ord($frameData[0]);
        // Parse the frequency/adjustment pairs
        $offset = 1;
        $this-&gt;adjustments = [];
        while ($offset + 3 &lt; strlen($frameData)) {
            // Read the frequency (2 bytes)
            $frequency = (
                ord($frameData[$offset]) &lt;&lt; 8 |
                ord($frameData[$offset + 1])
            );
            $offset += 2;
            // Read the adjustment (1 byte)
            $adjustment = ord($frameData[$offset]);
            $offset++;
            // Store the adjustment
            $this-&gt;adjustments[$frequency] = $adjustment;
        }
        return $this;
    }
    /**
     * Converts the frame to binary data.
     */
    public function toBytes(): string
    {
        // Start with the adjustment bit byte
        $data = chr($this-&gt;adjustmentBit ? 1 : 0);
        // Add each frequency/adjustment pair
        foreach ($this-&gt;adjustments as $frequency =&gt; $adjustment) {
            // Add the frequency (2 bytes, big-endian)
            $data .= chr(($frequency &gt;&gt; 8) &amp; 0xFF);
            $data .= chr($frequency &amp; 0xFF);
            // Add the adjustment (1 byte)
            $data .= chr($adjustment);
        }
        return $data;
    }
}</file><file path="app/Modules/MediaMeta/Frame/ETCO.php">&lt;?php
namespace App\Modules\MediaMeta\Frame;
use App\Modules\MediaMeta\Encoding;
/**
 * ETCO frame - Event timing codes.
 *
 * The &apos;Event timing codes&apos; frame allows synchronization with key events in the audio.
 * It contains a time format byte and a list of events with their timestamps.
 */
class ETCO extends Frame
{
    /**
     * Event type constants.
     */
    public const int EVENT_PADDING = 0x00;
    public const int EVENT_END_OF_INITIAL_SILENCE = 0x01;
    public const int EVENT_INTRO_START = 0x02;
    public const int EVENT_MAIN_PART_START = 0x03;
    public const int EVENT_OUTRO_START = 0x04;
    public const int EVENT_OUTRO_END = 0x05;
    public const int EVENT_VERSE_START = 0x06;
    public const int EVENT_REFRAIN_START = 0x07;
    public const int EVENT_INTERLUDE_START = 0x08;
    public const int EVENT_THEME_START = 0x09;
    public const int EVENT_VARIATION_START = 0x0A;
    public const int EVENT_KEY_CHANGE = 0x0B;
    public const int EVENT_TIME_CHANGE = 0x0C;
    public const int EVENT_MOMENTARY_UNWANTED_NOISE = 0x0D;
    public const int EVENT_SUSTAINED_NOISE = 0x0E;
    public const int EVENT_SUSTAINED_NOISE_END = 0x0F;
    public const int EVENT_INTRO_END = 0x10;
    public const int EVENT_MAIN_PART_END = 0x11;
    public const int EVENT_VERSE_END = 0x12;
    public const int EVENT_REFRAIN_END = 0x13;
    public const int EVENT_THEME_END = 0x14;
    public const int EVENT_PROFANITY = 0x15;
    public const int EVENT_PROFANITY_END = 0x16;
    /**
     * Time format constants.
     */
    public const int FORMAT_MPEG_FRAMES = 1;
    public const int FORMAT_MILLISECONDS = 2;
    /**
     * Constructs the ETCO frame with given parameters.
     */
    public function __construct(
        protected array $events = [],
        protected int   $format = self::FORMAT_MILLISECONDS,
    )
    {
        parent::__construct(&apos;ETCO&apos;, Encoding::UTF8);
    }
    /**
     * Returns the time format.
     */
    public function getFormat(): int
    {
        return $this-&gt;format;
    }
    /**
     * Sets the time format.
     */
    public function setFormat(int $format): self
    {
        $this-&gt;format = $format;
        return $this;
    }
    /**
     * Returns the events with their timestamps.
     */
    public function getEvents(): array
    {
        return $this-&gt;events;
    }
    /**
     * Sets the events with their timestamps.
     */
    public function setEvents(array $events): self
    {
        $this-&gt;events = $events;
        ksort($this-&gt;events);
        return $this;
    }
    /**
     * Adds an event with its timestamp.
     */
    public function addEvent(int $timestamp, int $eventType): self
    {
        $this-&gt;events[$timestamp] = $eventType;
        ksort($this-&gt;events);
        return $this;
    }
    /**
     * Parses the frame data.
     */
    public function parse(string $frameData): self
    {
        // The first byte is time format
        if (strlen($frameData) &lt; 1) {
            return $this;
        }
        $this-&gt;format = ord($frameData[0]);
        // Parse the events
        $offset = 1;
        $this-&gt;events = [];
        while ($offset + 4 &lt; strlen($frameData)) {
            // Read the event type (1 byte)
            $eventType = ord($frameData[$offset]);
            $offset++;
            // Read the timestamp (4 bytes)
            $timestamp = (
                ord($frameData[$offset]) &lt;&lt; 24 |
                ord($frameData[$offset + 1]) &lt;&lt; 16 |
                ord($frameData[$offset + 2]) &lt;&lt; 8 |
                ord($frameData[$offset + 3])
            );
            $offset += 4;
            // Store the event
            $this-&gt;events[$timestamp] = $eventType;
        }
        // Sort events by timestamp
        ksort($this-&gt;events);
        return $this;
    }
    /**
     * Converts the frame to binary data.
     */
    public function toBytes(): string
    {
        // Start with the format byte
        $data = chr($this-&gt;format);
        // Add each event (event type byte followed by timestamp)
        foreach ($this-&gt;events as $timestamp =&gt; $eventType) {
            // Add the event type (1 byte)
            $data .= chr($eventType);
            // Add the timestamp (4 bytes, big-endian)
            $data .= chr(($timestamp &gt;&gt; 24) &amp; 0xFF);
            $data .= chr(($timestamp &gt;&gt; 16) &amp; 0xFF);
            $data .= chr(($timestamp &gt;&gt; 8) &amp; 0xFF);
            $data .= chr($timestamp &amp; 0xFF);
        }
        return $data;
    }
}</file><file path="app/Modules/MediaMeta/Frame/Frame.php">&lt;?php
namespace App\Modules\MediaMeta\Frame;
use App\Modules\MediaMeta\Encoding;
/**
 * Base class for ID3v2 frames.
 *
 * This class provides common functionality for all frame types.
 */
abstract class Frame implements Encoding
{
    /**
     * Constructs the Frame class with given parameters.
     */
    public function __construct(
        protected string $frameId {
            get {
                return $this-&gt;frameId;
            }
        },
        protected int    $encoding = Encoding::UTF8,
    )
    {
    }
    /**
     * Returns the text encoding.
     */
    public function getEncoding(): int
    {
        return $this-&gt;encoding;
    }
    /**
     * Sets the text encoding.
     */
    public function setEncoding(int $encoding): self
    {
        $this-&gt;encoding = $encoding;
        return $this;
    }
    /**
     * Parses the frame data.
     */
    abstract public function parse(string $frameData): self;
    /**
     * Converts the frame to binary data.
     */
    abstract public function toBytes(): string;
}</file><file path="app/Modules/MediaMeta/Frame/IPLS.php">&lt;?php
namespace App\Modules\MediaMeta\Frame;
use App\Modules\MediaMeta\Encoding;
/**
 * IPLS frame - Involved people list.
 *
 * The &apos;Involved people list&apos; frame is intended to store the names of those involved in the
 * creation of the audio file, and their involvement. The frame consists of pairs of names and
 * involvements, separated by null bytes.
 */
class IPLS extends Frame
{
    /**
     * Constructs the IPLS frame with given parameters.
     */
    public function __construct(
        protected array $people = [],
        int             $encoding = Encoding::UTF8,
    )
    {
        parent::__construct(&apos;IPLS&apos;, $encoding);
    }
    /**
     * Returns the involved people list.
     */
    public function getPeople(): array
    {
        return $this-&gt;people;
    }
    /**
     * Sets the involved people list.
     */
    public function setPeople(array $people): self
    {
        $this-&gt;people = $people;
        return $this;
    }
    /**
     * Adds a person to the involved people list.
     */
    public function addPerson(string $name, string $involvement): self
    {
        $this-&gt;people[] = [&apos;name&apos; =&gt; $name, &apos;involvement&apos; =&gt; $involvement];
        return $this;
    }
    /**
     * Parses the frame data.
     */
    public function parse(string $frameData): self
    {
        // The first byte is text encoding
        $encoding = ord($frameData[0]);
        $data = substr($frameData, 1);
        // Determine the null terminator based on encoding
        $isUnicode = in_array($encoding, [Encoding::UTF16, Encoding::UTF16BE]);
        $nullTerminator = $isUnicode ? &quot;\0\0&quot; : &quot;\0&quot;;
        // Split the data into pairs of names and involvements
        $this-&gt;people = [];
        $parts = explode($nullTerminator, $data);
        // Process pairs (name, involvement)
        for ($i = 0; $i &lt; count($parts) - 1; $i += 2) {
            $name = $parts[$i];
            $involvement = $parts[$i + 1] ?? &apos;&apos;;
            // Process name and involvement based on encoding
            $name = match ($encoding) {
                Encoding::UTF16, Encoding::UTF16BE =&gt; mb_convert_encoding($name, &apos;UTF-8&apos;, &apos;UTF-16&apos;),
                Encoding::UTF16LE =&gt; mb_convert_encoding($name, &apos;UTF-8&apos;, &apos;UTF-16LE&apos;),
                Encoding::UTF8 =&gt; $name,
                default =&gt; mb_convert_encoding($name, &apos;UTF-8&apos;, &apos;ISO-8859-1&apos;)
            };
            $involvement = match ($encoding) {
                Encoding::UTF16, Encoding::UTF16BE =&gt; mb_convert_encoding($involvement, &apos;UTF-8&apos;, &apos;UTF-16&apos;),
                Encoding::UTF16LE =&gt; mb_convert_encoding($involvement, &apos;UTF-8&apos;, &apos;UTF-16LE&apos;),
                Encoding::UTF8 =&gt; $involvement,
                default =&gt; mb_convert_encoding($involvement, &apos;UTF-8&apos;, &apos;ISO-8859-1&apos;)
            };
            $this-&gt;people[] = [&apos;name&apos; =&gt; $name, &apos;involvement&apos; =&gt; $involvement];
        }
        return $this;
    }
    /**
     * Converts the frame to binary data.
     */
    public function toBytes(): string
    {
        // Determine if we&apos;re using Unicode
        $isUnicode = in_array($this-&gt;encoding, [Encoding::UTF16, Encoding::UTF16BE]);
        $nullTerminator = $isUnicode ? &quot;\0\0&quot; : &quot;\0&quot;;
        // Start with the encoding byte
        $data = chr($this-&gt;encoding);
        // Add each person (name and involvement, separated by null bytes)
        foreach ($this-&gt;people as $person) {
            // Convert name to the specified encoding
            $encodedName = match ($this-&gt;encoding) {
                Encoding::UTF16, Encoding::UTF16BE =&gt; mb_convert_encoding($person[&apos;name&apos;], &apos;UTF-16&apos;, &apos;UTF-8&apos;),
                Encoding::UTF16LE =&gt; mb_convert_encoding($person[&apos;name&apos;], &apos;UTF-16LE&apos;, &apos;UTF-8&apos;),
                Encoding::UTF8 =&gt; $person[&apos;name&apos;],
                default =&gt; mb_convert_encoding($person[&apos;name&apos;], &apos;ISO-8859-1&apos;, &apos;UTF-8&apos;)
            };
            // Convert involvement to the specified encoding
            $encodedInvolvement = match ($this-&gt;encoding) {
                Encoding::UTF16, Encoding::UTF16BE =&gt; mb_convert_encoding($person[&apos;involvement&apos;], &apos;UTF-16&apos;, &apos;UTF-8&apos;),
                Encoding::UTF16LE =&gt; mb_convert_encoding($person[&apos;involvement&apos;], &apos;UTF-16LE&apos;, &apos;UTF-8&apos;),
                Encoding::UTF8 =&gt; $person[&apos;involvement&apos;],
                default =&gt; mb_convert_encoding($person[&apos;involvement&apos;], &apos;ISO-8859-1&apos;, &apos;UTF-8&apos;)
            };
            // Add the name, null terminator, involvement, and null terminator
            $data .= $encodedName . $nullTerminator . $encodedInvolvement . $nullTerminator;
        }
        return $data;
    }
}</file><file path="app/Modules/MediaMeta/Frame/LINK.php">&lt;?php
namespace App\Modules\MediaMeta\Frame;
use App\Modules\MediaMeta\Encoding;
/**
 * LINK frame - Linked information.
 *
 * The &apos;Linked information&apos; frame is used to link information from another ID3v2 tag that might
 * be present in another audio file or alone in a binary file. It consists of a frame identifier,
 * URL, and additional data.
 */
class LINK extends Frame
{
    /**
     * Constructs the LINK frame with given parameters.
     */
    public function __construct(
        protected string $frameIdentifier = &apos;&apos;,
        protected string $url = &apos;&apos;,
        protected string $additionalData = &apos;&apos;,
    )
    {
        parent::__construct(&apos;LINK&apos;, Encoding::UTF8);
    }
    /**
     * Returns the frame identifier.
     */
    public function getFrameIdentifier(): string
    {
        return $this-&gt;frameIdentifier;
    }
    /**
     * Sets the frame identifier.
     */
    public function setFrameIdentifier(string $frameIdentifier): self
    {
        $this-&gt;frameIdentifier = substr($frameIdentifier, 0, 4);
        return $this;
    }
    /**
     * Returns the URL.
     */
    public function getUrl(): string
    {
        return $this-&gt;url;
    }
    /**
     * Sets the URL.
     */
    public function setUrl(string $url): self
    {
        $this-&gt;url = $url;
        return $this;
    }
    /**
     * Returns the additional data.
     */
    public function getAdditionalData(): string
    {
        return $this-&gt;additionalData;
    }
    /**
     * Sets the additional data.
     */
    public function setAdditionalData(string $additionalData): self
    {
        $this-&gt;additionalData = $additionalData;
        return $this;
    }
    /**
     * Parses the frame data.
     */
    public function parse(string $frameData): self
    {
        // The first 4 bytes are the frame identifier
        if (strlen($frameData) &lt; 4) {
            return $this;
        }
        $this-&gt;frameIdentifier = substr($frameData, 0, 4);
        // Find the null terminator for the URL
        $urlStart = 4;
        $urlEnd = strpos($frameData, &quot;\0&quot;, $urlStart);
        if ($urlEnd === false) {
            $this-&gt;url = substr($frameData, $urlStart);
            return $this;
        }
        // Extract the URL
        $this-&gt;url = substr($frameData, $urlStart, $urlEnd - $urlStart);
        // Extract the additional data
        if ($urlEnd + 1 &lt; strlen($frameData)) {
            $this-&gt;additionalData = substr($frameData, $urlEnd + 1);
        }
        return $this;
    }
    /**
     * Converts the frame to binary data.
     */
    public function toBytes(): string
    {
        // Start with the frame identifier (4 bytes)
        $data = $this-&gt;frameIdentifier;
        // Add the URL with null terminator
        $data .= $this-&gt;url . &quot;\0&quot;;
        // Add the additional data
        $data .= $this-&gt;additionalData;
        return $data;
    }
}</file><file path="app/Modules/MediaMeta/Frame/MCDI.php">&lt;?php
namespace App\Modules\MediaMeta\Frame;
use App\Modules\MediaMeta\Encoding;
/**
 * MCDI frame - Music CD identifier.
 *
 * The &apos;Music CD identifier&apos; frame contains the binary data from the Table of Contents (TOC)
 * of the CD, which is used as a unique identifier for the CD.
 */
class MCDI extends Frame
{
    /**
     * Constructs the MCDI frame with given parameters.
     */
    public function __construct(
        protected string $cdToc = &apos;&apos;,
    )
    {
        parent::__construct(&apos;MCDI&apos;, Encoding::UTF8);
    }
    /**
     * Returns the CD TOC data.
     */
    public function getCdToc(): string
    {
        return $this-&gt;cdToc;
    }
    /**
     * Sets the CD TOC data.
     */
    public function setCdToc(string $cdToc): self
    {
        $this-&gt;cdToc = $cdToc;
        return $this;
    }
    /**
     * Parses the frame data.
     */
    public function parse(string $frameData): self
    {
        // The entire frame data is the CD TOC
        $this-&gt;cdToc = $frameData;
        return $this;
    }
    /**
     * Converts the frame to binary data.
     */
    public function toBytes(): string
    {
        // The entire frame data is the CD TOC
        return $this-&gt;cdToc;
    }
}</file><file path="app/Modules/MediaMeta/Frame/MVIN.php">&lt;?php
namespace App\Modules\MediaMeta\Frame;
use App\Modules\MediaMeta\Encoding;
/**
 * MVIN frame - Movement number.
 *
 * The &apos;Movement number&apos; frame is a numeric string containing the movement number of the
 * audio-file in a larger work. This may be extended with a &quot;/&quot; character and a numeric string
 * containing the total number of movements in the work. E.g. &quot;2/5&quot;.
 */
class MVIN extends TextFrame
{
    /**
     * Constructs the MVIN frame with given parameters.
     */
    public function __construct(string $movement = &apos;&apos;, int $encoding = Encoding::UTF8)
    {
        parent::__construct(&apos;MVIN&apos;, $movement, $encoding);
    }
    /**
     * Returns the movement number.
     */
    public function getMovement(): string
    {
        return $this-&gt;getText();
    }
    /**
     * Sets the movement number.
     */
    public function setMovement(string $movement): self
    {
        return $this-&gt;setText($movement);
    }
}</file><file path="app/Modules/MediaMeta/Frame/OWNE.php">&lt;?php
namespace App\Modules\MediaMeta\Frame;
use App\Modules\MediaMeta\Encoding;
/**
 * OWNE frame - Ownership frame.
 *
 * The &apos;Ownership&apos; frame contains information about the owner of the file.
 * It includes a price paid, date of purchase, and the seller name.
 */
class OWNE extends Frame
{
    /**
     * Constructs the OWNE frame with given parameters.
     */
    public function __construct(
        protected string $price = &apos;&apos;,
        protected string $date = &apos;&apos;,
        protected string $seller = &apos;&apos;,
        int              $encoding = Encoding::UTF8,
    )
    {
        parent::__construct(&apos;OWNE&apos;, $encoding);
    }
    /**
     * Returns the price paid.
     */
    public function getPrice(): string
    {
        return $this-&gt;price;
    }
    /**
     * Sets the price paid.
     */
    public function setPrice(string $price): self
    {
        $this-&gt;price = $price;
        return $this;
    }
    /**
     * Returns the date of purchase.
     */
    public function getDate(): string
    {
        return $this-&gt;date;
    }
    /**
     * Sets the date of purchase.
     */
    public function setDate(string $date): self
    {
        $this-&gt;date = $date;
        return $this;
    }
    /**
     * Returns the seller name.
     */
    public function getSeller(): string
    {
        return $this-&gt;seller;
    }
    /**
     * Sets the seller name.
     */
    public function setSeller(string $seller): self
    {
        $this-&gt;seller = $seller;
        return $this;
    }
    /**
     * Parses the frame data.
     */
    public function parse(string $frameData): self
    {
        // The first byte is text encoding
        $encoding = ord($frameData[0]);
        // Find the null terminator for the price
        $priceEnd = strpos($frameData, &quot;\0&quot;, 1);
        if ($priceEnd === false) {
            return $this;
        }
        // Extract the price
        $this-&gt;price = substr($frameData, 1, $priceEnd - 1);
        // Extract the date (8 characters, YYYYMMDD)
        $dateStart = $priceEnd + 1;
        if ($dateStart + 8 &lt;= strlen($frameData)) {
            $this-&gt;date = substr($frameData, $dateStart, 8);
        }
        // Extract the seller
        $sellerStart = $dateStart + 8;
        if ($sellerStart &lt; strlen($frameData)) {
            $sellerData = substr($frameData, $sellerStart);
            // Process seller based on encoding
            $this-&gt;seller = match ($encoding) {
                Encoding::UTF16, Encoding::UTF16BE =&gt; mb_convert_encoding($sellerData, &apos;UTF-8&apos;, &apos;UTF-16&apos;),
                Encoding::UTF16LE =&gt; mb_convert_encoding($sellerData, &apos;UTF-8&apos;, &apos;UTF-16LE&apos;),
                Encoding::UTF8 =&gt; $sellerData,
                default =&gt; mb_convert_encoding($sellerData, &apos;UTF-8&apos;, &apos;ISO-8859-1&apos;)
            };
        }
        return $this;
    }
    /**
     * Converts the frame to binary data.
     */
    public function toBytes(): string
    {
        // Convert seller to the specified encoding
        $encodedSeller = match ($this-&gt;encoding) {
            Encoding::UTF16, Encoding::UTF16BE =&gt; mb_convert_encoding($this-&gt;seller, &apos;UTF-16&apos;, &apos;UTF-8&apos;),
            Encoding::UTF16LE =&gt; mb_convert_encoding($this-&gt;seller, &apos;UTF-16LE&apos;, &apos;UTF-8&apos;),
            Encoding::UTF8 =&gt; $this-&gt;seller,
            default =&gt; mb_convert_encoding($this-&gt;seller, &apos;ISO-8859-1&apos;, &apos;UTF-8&apos;)
        };
        // Start with the encoding byte
        $data = chr($this-&gt;encoding);
        // Add the price with null terminator
        $data .= $this-&gt;price . &quot;\0&quot;;
        // Add the date (8 characters, YYYYMMDD)
        $data .= str_pad($this-&gt;date, 8, &apos;0&apos;, STR_PAD_LEFT);
        // Add the seller
        $data .= $encodedSeller;
        return $data;
    }
}</file><file path="app/Modules/MediaMeta/Frame/POPM.php">&lt;?php
namespace App\Modules\MediaMeta\Frame;
use App\Modules\MediaMeta\Encoding;
/**
 * POPM frame - Popularimeter.
 *
 * The &apos;Popularimeter&apos; frame is meant to specify how good an audio file is.
 * It contains a user email, a rating, and a play counter.
 */
class POPM extends Frame
{
    /**
     * Constructs the POPM frame with given parameters.
     */
    public function __construct(
        protected string $email = &apos;&apos;,
        protected int    $rating = 0,
        protected int    $counter = 0,
    )
    {
        parent::__construct(&apos;POPM&apos;, Encoding::UTF8);
    }
    /**
     * Returns the email.
     */
    public function getEmail(): string
    {
        return $this-&gt;email;
    }
    /**
     * Sets the email.
     */
    public function setEmail(string $email): self
    {
        $this-&gt;email = $email;
        return $this;
    }
    /**
     * Returns the rating.
     */
    public function getRating(): int
    {
        return $this-&gt;rating;
    }
    /**
     * Sets the rating.
     */
    public function setRating(int $rating): self
    {
        $this-&gt;rating = $rating;
        return $this;
    }
    /**
     * Returns the counter.
     */
    public function getCounter(): int
    {
        return $this-&gt;counter;
    }
    /**
     * Sets the counter.
     */
    public function setCounter(int $counter): self
    {
        $this-&gt;counter = $counter;
        return $this;
    }
    /**
     * Parses the frame data.
     */
    public function parse(string $frameData): self
    {
        // Find the null terminator for the email
        $emailEnd = strpos($frameData, &quot;\0&quot;);
        if ($emailEnd === false) {
            return $this;
        }
        // Extract the email
        $this-&gt;email = substr($frameData, 0, $emailEnd);
        // Extract the rating (1 byte)
        if ($emailEnd + 1 &lt; strlen($frameData)) {
            $this-&gt;rating = ord($frameData[$emailEnd + 1]);
        }
        // Extract the counter (variable length)
        if ($emailEnd + 2 &lt; strlen($frameData)) {
            $counterData = substr($frameData, $emailEnd + 2);
            $this-&gt;counter = 0;
            // Parse the counter as a big-endian integer
            for ($i = 0; $i &lt; strlen($counterData); $i++) {
                $this-&gt;counter = ($this-&gt;counter &lt;&lt; 8) | ord($counterData[$i]);
            }
        }
        return $this;
    }
    /**
     * Converts the frame to binary data.
     */
    public function toBytes(): string
    {
        // Start with the email and null terminator
        $data = $this-&gt;email . &quot;\0&quot;;
        // Add the rating (1 byte)
        $data .= chr($this-&gt;rating);
        // Add the counter (variable length)
        $counter = $this-&gt;counter;
        $counterBytes = &apos;&apos;;
        // Convert the counter to bytes (big-endian)
        while ($counter &gt; 0) {
            $counterBytes = chr($counter &amp; 0xFF) . $counterBytes;
            $counter &gt;&gt;= 8;
        }
        // If counter is 0, add a single byte
        if (empty($counterBytes)) {
            $counterBytes = &quot;\0&quot;;
        }
        return $data . $counterBytes;
    }
}</file><file path="app/Modules/MediaMeta/Frame/SYLT.php">&lt;?php
namespace App\Modules\MediaMeta\Frame;
use App\Modules\MediaMeta\Encoding;
/**
 * SYLT frame - Synchronized lyric/text.
 *
 * The &apos;Synchronized lyric/text&apos; frame is another way of incorporating the lyrics in the audio file,
 * but this time in sync with the audio. It might also be used to describe events occurring on a
 * stage or on the screen in sync with the audio.
 */
class SYLT extends Frame
{
    /**
     * Content type constants.
     */
    public const int TYPE_OTHER = 0;
    public const int TYPE_LYRICS = 1;
    public const int TYPE_TEXT_TRANSCRIPTION = 2;
    public const int TYPE_MOVEMENT_PART_NAME = 3;
    public const int TYPE_EVENTS = 4;
    public const int TYPE_CHORD = 5;
    public const int TYPE_TRIVIA = 6;
    public const int TYPE_URLS_TO_WEBPAGES = 7;
    public const int TYPE_URLS_TO_IMAGES = 8;
    /**
     * Time format constants.
     */
    public const int FORMAT_MPEG_FRAMES = 1;
    public const int FORMAT_MILLISECONDS = 2;
    /**
     * Constructs the SYLT frame with given parameters.
     */
    public function __construct(
        protected array  $events = [],
        protected string $description = &apos;&apos;,
        protected string $language = &apos;eng&apos;,
        protected int    $format = self::FORMAT_MILLISECONDS,
        protected int    $type = self::TYPE_LYRICS,
        int              $encoding = Encoding::UTF8,
    )
    {
        parent::__construct(&apos;SYLT&apos;, $encoding);
        $this-&gt;language = substr($language, 0, 3);
    }
    /**
     * Returns the language code.
     */
    public function getLanguage(): string
    {
        return $this-&gt;language;
    }
    /**
     * Sets the language code.
     */
    public function setLanguage(string $language): self
    {
        $this-&gt;language = substr($language, 0, 3);
        return $this;
    }
    /**
     * Returns the time format.
     */
    public function getFormat(): int
    {
        return $this-&gt;format;
    }
    /**
     * Sets the time format.
     */
    public function setFormat(int $format): self
    {
        $this-&gt;format = $format;
        return $this;
    }
    /**
     * Returns the content type.
     */
    public function getType(): int
    {
        return $this-&gt;type;
    }
    /**
     * Sets the content type.
     */
    public function setType(int $type): self
    {
        $this-&gt;type = $type;
        return $this;
    }
    /**
     * Returns the description.
     */
    public function getDescription(): string
    {
        return $this-&gt;description;
    }
    /**
     * Sets the description.
     */
    public function setDescription(string $description): self
    {
        $this-&gt;description = $description;
        return $this;
    }
    /**
     * Returns the events with their timestamps.
     */
    public function getEvents(): array
    {
        return $this-&gt;events;
    }
    /**
     * Sets the events with their timestamps.
     */
    public function setEvents(array $events): self
    {
        $this-&gt;events = $events;
        ksort($this-&gt;events);
        return $this;
    }
    /**
     * Parses the frame data.
     */
    public function parse(string $frameData): self
    {
        // The first byte is text encoding
        $encoding = ord($frameData[0]);
        // The next 3 bytes are language
        $this-&gt;language = substr($frameData, 1, 3);
        // The next byte is time format
        $this-&gt;format = ord($frameData[4]);
        // The next byte is content type
        $this-&gt;type = ord($frameData[5]);
        // Find the null terminator for the description
        $descriptionStart = 6;
        $isUnicode = in_array($encoding, [Encoding::UTF16, Encoding::UTF16BE]);
        $nullTerminator = $isUnicode ? &quot;\0\0&quot; : &quot;\0&quot;;
        $descriptionEnd = strpos($frameData, $nullTerminator, $descriptionStart);
        $descriptionLength = $descriptionEnd - $descriptionStart;
        // Process description based on encoding
        $this-&gt;description = match ($encoding) {
            Encoding::UTF16, Encoding::UTF16BE =&gt; mb_convert_encoding(
                substr($frameData, $descriptionStart, $descriptionLength),
                &apos;UTF-8&apos;,
                &apos;UTF-16&apos;,
            ),
            Encoding::UTF16LE =&gt; mb_convert_encoding(
                substr($frameData, $descriptionStart, $descriptionLength),
                &apos;UTF-8&apos;,
                &apos;UTF-16LE&apos;,
            ),
            Encoding::UTF8 =&gt; substr($frameData, $descriptionStart, $descriptionLength),
            default =&gt; mb_convert_encoding(
                substr($frameData, $descriptionStart, $descriptionLength),
                &apos;UTF-8&apos;,
                &apos;ISO-8859-1&apos;,
            )
        };
        // Parse the events
        $offset = $descriptionEnd + ($isUnicode ? 2 : 1);
        $this-&gt;events = [];
        while ($offset &lt; strlen($frameData)) {
            // Find the null terminator for the syllable
            $syllableStart = $offset;
            $syllableEnd = strpos($frameData, $nullTerminator, $syllableStart);
            if ($syllableEnd === false) {
                break;
            }
            $syllableLength = $syllableEnd - $syllableStart;
            // Process syllable based on encoding
            $syllable = match ($encoding) {
                Encoding::UTF16, Encoding::UTF16BE =&gt; mb_convert_encoding(
                    substr($frameData, $syllableStart, $syllableLength),
                    &apos;UTF-8&apos;,
                    &apos;UTF-16&apos;,
                ),
                Encoding::UTF16LE =&gt; mb_convert_encoding(
                    substr($frameData, $syllableStart, $syllableLength),
                    &apos;UTF-8&apos;,
                    &apos;UTF-16LE&apos;,
                ),
                Encoding::UTF8 =&gt; substr($frameData, $syllableStart, $syllableLength),
                default =&gt; mb_convert_encoding(
                    substr($frameData, $syllableStart, $syllableLength),
                    &apos;UTF-8&apos;,
                    &apos;ISO-8859-1&apos;,
                )
            };
            // Move offset past the null terminator
            $offset = $syllableEnd + ($isUnicode ? 2 : 1);
            // Read the timestamp (4 bytes)
            if ($offset + 4 &gt; strlen($frameData)) {
                break;
            }
            $timestamp = (
                ord($frameData[$offset]) &lt;&lt; 24 |
                ord($frameData[$offset + 1]) &lt;&lt; 16 |
                ord($frameData[$offset + 2]) &lt;&lt; 8 |
                ord($frameData[$offset + 3])
            );
            $offset += 4;
            // Store the event
            $this-&gt;events[$timestamp] = $syllable;
        }
        // Sort events by timestamp
        ksort($this-&gt;events);
        return $this;
    }
    /**
     * Converts the frame to binary data.
     */
    public function toBytes(): string
    {
        // Determine if we&apos;re using Unicode
        $isUnicode = in_array($this-&gt;encoding, [Encoding::UTF16, Encoding::UTF16BE]);
        $nullTerminator = $isUnicode ? &quot;\0\0&quot; : &quot;\0&quot;;
        // Convert description to the specified encoding
        $encodedDescription = match ($this-&gt;encoding) {
            Encoding::UTF16, Encoding::UTF16BE =&gt; mb_convert_encoding($this-&gt;description, &apos;UTF-16&apos;, &apos;UTF-8&apos;),
            Encoding::UTF16LE =&gt; mb_convert_encoding($this-&gt;description, &apos;UTF-16LE&apos;, &apos;UTF-8&apos;),
            Encoding::UTF8 =&gt; $this-&gt;description,
            default =&gt; mb_convert_encoding($this-&gt;description, &apos;ISO-8859-1&apos;, &apos;UTF-8&apos;)
        };
        // Start with the encoding byte, language, format, and type
        $data = chr($this-&gt;encoding) . $this-&gt;language . chr($this-&gt;format) . chr($this-&gt;type);
        // Add the description with null terminator
        $data .= $encodedDescription . $nullTerminator;
        // Add each event (syllable with null terminator followed by timestamp)
        foreach ($this-&gt;events as $timestamp =&gt; $syllable) {
            // Convert syllable to the specified encoding
            $encodedSyllable = match ($this-&gt;encoding) {
                Encoding::UTF16, Encoding::UTF16BE =&gt; mb_convert_encoding($syllable, &apos;UTF-16&apos;, &apos;UTF-8&apos;),
                Encoding::UTF16LE =&gt; mb_convert_encoding($syllable, &apos;UTF-16LE&apos;, &apos;UTF-8&apos;),
                Encoding::UTF8 =&gt; $syllable,
                default =&gt; mb_convert_encoding($syllable, &apos;ISO-8859-1&apos;, &apos;UTF-8&apos;)
            };
            // Add the syllable with null terminator
            $data .= $encodedSyllable . $nullTerminator;
            // Add the timestamp (4 bytes, big-endian)
            $data .= chr(($timestamp &gt;&gt; 24) &amp; 0xFF);
            $data .= chr(($timestamp &gt;&gt; 16) &amp; 0xFF);
            $data .= chr(($timestamp &gt;&gt; 8) &amp; 0xFF);
            $data .= chr($timestamp &amp; 0xFF);
        }
        return $data;
    }
}</file><file path="app/Modules/MediaMeta/Frame/TALB.php">&lt;?php
namespace App\Modules\MediaMeta\Frame;
use App\Modules\MediaMeta\Encoding;
/**
 * TALB frame - Album/Movie/Show title.
 *
 * The &apos;Album/Movie/Show title&apos; frame is intended for the title of the recording
 * (or source of sound) from which the audio in the file is taken.
 */
class TALB extends TextFrame
{
    /**
     * Constructs the TALB frame with given parameters.
     *
     * @param string $album The album
     * @param int $encoding The text encoding
     */
    public function __construct(string $album = &apos;&apos;, int $encoding = Encoding::UTF8)
    {
        parent::__construct(&apos;TALB&apos;, $album, $encoding);
    }
    /**
     * Returns the album.
     *
     * @return string
     */
    public function getAlbum(): string
    {
        return $this-&gt;getText();
    }
    /**
     * Sets the album.
     *
     * @param string $album The album
     * @return self
     */
    public function setAlbum(string $album): self
    {
        return $this-&gt;setText($album);
    }
}</file><file path="app/Modules/MediaMeta/Frame/TCOM.php">&lt;?php
namespace App\Modules\MediaMeta\Frame;
use App\Modules\MediaMeta\Encoding;
/**
 * TCOM frame - Composer.
 *
 * The &apos;Composer&apos; frame is intended for the name of the composer.
 */
class TCOM extends TextFrame
{
    /**
     * Constructs the TCOM frame with given parameters.
     */
    public function __construct(string $composer = &apos;&apos;, int $encoding = Encoding::UTF8)
    {
        parent::__construct(&apos;TCOM&apos;, $composer, $encoding);
    }
    /**
     * Returns the composer.
     */
    public function getComposer(): string
    {
        return $this-&gt;getText();
    }
    /**
     * Sets the composer.
     */
    public function setComposer(string $composer): self
    {
        return $this-&gt;setText($composer);
    }
}</file><file path="app/Modules/MediaMeta/Frame/TCON.php">&lt;?php
namespace App\Modules\MediaMeta\Frame;
use App\Modules\MediaMeta\Encoding;
/**
 * TCON frame - Content type (genre).
 *
 * The &apos;Content type&apos; frame represents the genre of the audio file.
 * In ID3v1, this was a numeric value, but in ID3v2 it can be any string.
 * For backward compatibility, the ID3v1 genres can be used by enclosing
 * the genre number in parentheses, e.g. &quot;(4)&quot; for &quot;Disco&quot;.
 */
class TCON extends TextFrame
{
    /**
     * The list of ID3v1 genres.
     *
     * @var array&lt;string&gt;
     */
    public static array $genres = [
        &apos;Blues&apos;,
        &apos;Classic Rock&apos;,
        &apos;Country&apos;,
        &apos;Dance&apos;,
        &apos;Disco&apos;,
        &apos;Funk&apos;,
        &apos;Grunge&apos;,
        &apos;Hip-Hop&apos;,
        &apos;Jazz&apos;,
        &apos;Metal&apos;,
        &apos;New Age&apos;,
        &apos;Oldies&apos;,
        &apos;Other&apos;,
        &apos;Pop&apos;,
        &apos;R&amp;B&apos;,
        &apos;Rap&apos;,
        &apos;Reggae&apos;,
        &apos;Rock&apos;,
        &apos;Techno&apos;,
        &apos;Industrial&apos;,
        &apos;Alternative&apos;,
        &apos;Ska&apos;,
        &apos;Death Metal&apos;,
        &apos;Pranks&apos;,
        &apos;Soundtrack&apos;,
        &apos;Euro-Techno&apos;,
        &apos;Ambient&apos;,
        &apos;Trip-Hop&apos;,
        &apos;Vocal&apos;,
        &apos;Jazz+Funk&apos;,
        &apos;Fusion&apos;,
        &apos;Trance&apos;,
        &apos;Classical&apos;,
        &apos;Instrumental&apos;,
        &apos;Acid&apos;,
        &apos;House&apos;,
        &apos;Game&apos;,
        &apos;Sound Clip&apos;,
        &apos;Gospel&apos;,
        &apos;Noise&apos;,
        &apos;AlternRock&apos;,
        &apos;Bass&apos;,
        &apos;Soul&apos;,
        &apos;Punk&apos;,
        &apos;Space&apos;,
        &apos;Meditative&apos;,
        &apos;Instrumental Pop&apos;,
        &apos;Instrumental Rock&apos;,
        &apos;Ethnic&apos;,
        &apos;Gothic&apos;,
        &apos;Darkwave&apos;,
        &apos;Techno-Industrial&apos;,
        &apos;Electronic&apos;,
        &apos;Pop-Folk&apos;,
        &apos;Eurodance&apos;,
        &apos;Dream&apos;,
        &apos;Southern Rock&apos;,
        &apos;Comedy&apos;,
        &apos;Cult&apos;,
        &apos;Gangsta&apos;,
        &apos;Top 40&apos;,
        &apos;Christian Rap&apos;,
        &apos;Pop/Funk&apos;,
        &apos;Jungle&apos;,
        &apos;Native American&apos;,
        &apos;Cabaret&apos;,
        &apos;New Wave&apos;,
        &apos;Psychadelic&apos;,
        &apos;Rave&apos;,
        &apos;Showtunes&apos;,
        &apos;Trailer&apos;,
        &apos;Lo-Fi&apos;,
        &apos;Tribal&apos;,
        &apos;Acid Punk&apos;,
        &apos;Acid Jazz&apos;,
        &apos;Polka&apos;,
        &apos;Retro&apos;,
        &apos;Musical&apos;,
        &apos;Rock &amp; Roll&apos;,
        &apos;Hard Rock&apos;,
        &apos;Folk&apos;,
        &apos;Folk-Rock&apos;,
        &apos;National Folk&apos;,
        &apos;Swing&apos;,
        &apos;Fast Fusion&apos;,
        &apos;Bebob&apos;,
        &apos;Latin&apos;,
        &apos;Revival&apos;,
        &apos;Celtic&apos;,
        &apos;Bluegrass&apos;,
        &apos;Avantgarde&apos;,
        &apos;Gothic Rock&apos;,
        &apos;Progressive Rock&apos;,
        &apos;Psychedelic Rock&apos;,
        &apos;Symphonic Rock&apos;,
        &apos;Slow Rock&apos;,
        &apos;Big Band&apos;,
        &apos;Chorus&apos;,
        &apos;Easy Listening&apos;,
        &apos;Acoustic&apos;,
        &apos;Humour&apos;,
        &apos;Speech&apos;,
        &apos;Chanson&apos;,
        &apos;Opera&apos;,
        &apos;Chamber Music&apos;,
        &apos;Sonata&apos;,
        &apos;Symphony&apos;,
        &apos;Booty Bass&apos;,
        &apos;Primus&apos;,
        &apos;Porn Groove&apos;,
        &apos;Satire&apos;,
        &apos;Slow Jam&apos;,
        &apos;Club&apos;,
        &apos;Tango&apos;,
        &apos;Samba&apos;,
        &apos;Folklore&apos;,
        &apos;Ballad&apos;,
        &apos;Power Ballad&apos;,
        &apos;Rhythmic Soul&apos;,
        &apos;Freestyle&apos;,
        &apos;Duet&apos;,
        &apos;Punk Rock&apos;,
        &apos;Drum Solo&apos;,
        &apos;A capella&apos;,
        &apos;Euro-House&apos;,
        &apos;Dance Hall&apos;,
    ];
    /**
     * Constructs the TCON frame with given parameters.
     *
     * @param string $genre The genre
     * @param int $encoding The text encoding
     */
    public function __construct(string $genre = &apos;&apos;, int $encoding = Encoding::UTF8)
    {
        parent::__construct(&apos;TCON&apos;, $genre, $encoding);
    }
    /**
     * Returns the genre.
     *
     * @return string
     */
    public function getGenre(): string
    {
        $genre = $this-&gt;getText();
        // Check if the genre is in the ID3v1 format (e.g. &quot;(4)&quot;)
        if (preg_match(&apos;/^\((\d+)\)$/&apos;, $genre, $matches)) {
            $genreId = (int)$matches[1];
            if (isset(self::$genres[$genreId])) {
                return self::$genres[$genreId];
            }
        }
        return $genre;
    }
    /**
     * Sets the genre.
     *
     * @param string $genre The genre
     * @return self
     */
    public function setGenre(string $genre): self
    {
        return $this-&gt;setText($genre);
    }
    /**
     * Sets the genre by ID3v1 genre ID.
     *
     * @param int $genreId The genre ID
     * @return self
     */
    public function setGenreById(int $genreId): self
    {
        if (isset(self::$genres[$genreId])) {
            return $this-&gt;setText(&quot;({$genreId})&quot;);
        }
        return $this-&gt;setText(&apos;&apos;);
    }
}</file><file path="app/Modules/MediaMeta/Frame/TDAT.php">&lt;?php
namespace App\Modules\MediaMeta\Frame;
use App\Modules\MediaMeta\Encoding;
/**
 * TDAT frame - Date.
 *
 * The &apos;Date&apos; frame is a numeric string in the DDMM format containing the date for the recording.
 * This field is always four characters long.
 */
class TDAT extends TextFrame
{
    /**
     * Constructs the TDAT frame with given parameters.
     */
    public function __construct(string $date = &apos;&apos;, int $encoding = Encoding::UTF8)
    {
        parent::__construct(&apos;TDAT&apos;, $date, $encoding);
    }
    /**
     * Returns the date.
     */
    public function getDate(): string
    {
        return $this-&gt;getText();
    }
    /**
     * Sets the date.
     */
    public function setDate(string $date): self
    {
        return $this-&gt;setText($date);
    }
}</file><file path="app/Modules/MediaMeta/Frame/TEXT.php">&lt;?php
namespace App\Modules\MediaMeta\Frame;
use App\Modules\MediaMeta\Encoding;
/**
 * TEXT frame - Lyricist/Text writer.
 *
 * The &apos;Lyricist/Text writer&apos; frame is intended for the writer of the text or lyrics in the recording.
 */
class TEXT extends TextFrame
{
    /**
     * Constructs the TEXT frame with given parameters.
     */
    public function __construct(string $lyricist = &apos;&apos;, int $encoding = Encoding::UTF8)
    {
        parent::__construct(&apos;TEXT&apos;, $lyricist, $encoding);
    }
    /**
     * Returns the lyricist/text writer.
     */
    public function getLyricist(): string
    {
        return $this-&gt;getText();
    }
    /**
     * Sets the lyricist/text writer.
     */
    public function setLyricist(string $lyricist): self
    {
        return $this-&gt;setText($lyricist);
    }
}</file><file path="app/Modules/MediaMeta/Frame/TextFrame.php">&lt;?php
namespace App\Modules\MediaMeta\Frame;
use App\Modules\MediaMeta\Encoding;
/**
 * Base class for ID3v2 text frames.
 *
 * Text frames are the most common frame type in ID3v2 tags.
 * They contain text information like title, artist, album, etc.
 */
class TextFrame extends Frame
{
    /**
     * Constructs the TextFrame class with given parameters.
     */
    public function __construct(
        string           $frameId,
        protected string $text = &apos;&apos;,
        int              $encoding = Encoding::UTF8,
    )
    {
        parent::__construct($frameId, $encoding);
    }
    /**
     * Returns the text content.
     */
    public function getText(): string
    {
        return $this-&gt;text;
    }
    /**
     * Sets the text content.
     */
    public function setText(string $text): self
    {
        $this-&gt;text = $text;
        return $this;
    }
    /**
     * Parses the frame data.
     */
    public function parse(string $frameData): self
    {
        // The first byte is text encoding
        $encoding = ord($frameData[0]);
        $text = substr($frameData, 1);
        // Process text based on encoding
        $this-&gt;text = match ($encoding) {
            Encoding::UTF16, Encoding::UTF16BE =&gt; mb_convert_encoding($text, &apos;UTF-8&apos;, &apos;UTF-16&apos;),
            Encoding::UTF16LE =&gt; mb_convert_encoding($text, &apos;UTF-8&apos;, &apos;UTF-16LE&apos;),
            Encoding::UTF8 =&gt; $text,
            default =&gt; mb_convert_encoding($text, &apos;UTF-8&apos;, &apos;ISO-8859-1&apos;)
        };
        return $this;
    }
    /**
     * Converts the frame to binary data.
     */
    public function toBytes(): string
    {
        // Convert text to the specified encoding
        $encodedText = match ($this-&gt;encoding) {
            Encoding::UTF16, Encoding::UTF16BE =&gt; mb_convert_encoding($this-&gt;text, &apos;UTF-16&apos;, &apos;UTF-8&apos;),
            Encoding::UTF16LE =&gt; mb_convert_encoding($this-&gt;text, &apos;UTF-16LE&apos;, &apos;UTF-8&apos;),
            Encoding::UTF8 =&gt; $this-&gt;text,
            default =&gt; mb_convert_encoding($this-&gt;text, &apos;ISO-8859-1&apos;, &apos;UTF-8&apos;)
        };
        // Return the encoding byte followed by the encoded text
        return chr($this-&gt;encoding) . $encodedText;
    }
}</file><file path="app/Modules/MediaMeta/Frame/TIT2.php">&lt;?php
namespace App\Modules\MediaMeta\Frame;
use App\Modules\MediaMeta\Encoding;
/**
 * TIT2 frame - Title/songname/content description.
 *
 * The &apos;Title/songname/content description&apos; frame is the actual name of the piece
 * (e.g. &quot;Adagio&quot;, &quot;Hurricane Donna&quot;).
 */
class TIT2 extends TextFrame
{
    /**
     * Constructs the TIT2 frame with given parameters.
     *
     * @param string $title The title
     * @param int $encoding The text encoding
     */
    public function __construct(string $title = &apos;&apos;, int $encoding = Encoding::UTF8)
    {
        parent::__construct(&apos;TIT2&apos;, $title, $encoding);
    }
    /**
     * Returns the title.
     *
     * @return string
     */
    public function getTitle(): string
    {
        return $this-&gt;getText();
    }
    /**
     * Sets the title.
     *
     * @param string $title The title
     * @return self
     */
    public function setTitle(string $title): self
    {
        return $this-&gt;setText($title);
    }
}</file><file path="app/Modules/MediaMeta/Frame/TLAN.php">&lt;?php
namespace App\Modules\MediaMeta\Frame;
use App\Modules\MediaMeta\Encoding;
/**
 * TLAN frame - Language(s).
 *
 * The &apos;Language(s)&apos; frame should contain the languages of the text or lyrics spoken or sung in the audio.
 * The language is represented with three characters according to ISO-639-2. If more than one language is used
 * in the text, their language codes should follow according to the amount of their usage.
 */
class TLAN extends TextFrame
{
    /**
     * Constructs the TLAN frame with given parameters.
     */
    public function __construct(string $language = &apos;&apos;, int $encoding = Encoding::UTF8)
    {
        parent::__construct(&apos;TLAN&apos;, $language, $encoding);
    }
    /**
     * Returns the language(s).
     */
    public function getLanguage(): string
    {
        return $this-&gt;getText();
    }
    /**
     * Sets the language(s).
     */
    public function setLanguage(string $language): self
    {
        return $this-&gt;setText($language);
    }
}</file><file path="app/Modules/MediaMeta/Frame/TLEN.php">&lt;?php
namespace App\Modules\MediaMeta\Frame;
use App\Modules\MediaMeta\Encoding;
/**
 * TLEN frame - Length.
 *
 * The &apos;Length&apos; frame contains the length of the audio file in milliseconds, represented as a numeric string.
 */
class TLEN extends TextFrame
{
    /**
     * Constructs the TLEN frame with given parameters.
     */
    public function __construct(string $length = &apos;&apos;, int $encoding = Encoding::UTF8)
    {
        parent::__construct(&apos;TLEN&apos;, $length, $encoding);
    }
    /**
     * Returns the length in milliseconds.
     */
    public function getLength(): string
    {
        return $this-&gt;getText();
    }
    /**
     * Sets the length in milliseconds.
     */
    public function setLength(string $length): self
    {
        return $this-&gt;setText($length);
    }
}</file><file path="app/Modules/MediaMeta/Frame/TORY.php">&lt;?php
namespace App\Modules\MediaMeta\Frame;
use App\Modules\MediaMeta\Encoding;
/**
 * TORY frame - Original release year.
 *
 * The &apos;Original release year&apos; frame is intended for the year when the original recording was released.
 * The frame is represented as a numeric string in the YYYY format.
 */
class TORY extends TextFrame
{
    /**
     * Constructs the TORY frame with given parameters.
     */
    public function __construct(string $year = &apos;&apos;, int $encoding = Encoding::UTF8)
    {
        parent::__construct(&apos;TORY&apos;, $year, $encoding);
    }
    /**
     * Returns the original release year.
     */
    public function getYear(): string
    {
        return $this-&gt;getText();
    }
    /**
     * Sets the original release year.
     */
    public function setYear(string $year): self
    {
        return $this-&gt;setText($year);
    }
}</file><file path="app/Modules/MediaMeta/Frame/TPE1.php">&lt;?php
namespace App\Modules\MediaMeta\Frame;
use App\Modules\MediaMeta\Encoding;
/**
 * TPE1 frame - Lead performer(s)/Soloist(s).
 *
 * The &apos;Lead performer(s)/Soloist(s)&apos; frame is used for the main artist(s).
 * They are separated with the &quot;/&quot; character.
 */
class TPE1 extends TextFrame
{
    /**
     * Constructs the TPE1 frame with given parameters.
     *
     * @param string $artist The artist
     * @param int $encoding The text encoding
     */
    public function __construct(string $artist = &apos;&apos;, int $encoding = Encoding::UTF8)
    {
        parent::__construct(&apos;TPE1&apos;, $artist, $encoding);
    }
    /**
     * Returns the artist.
     *
     * @return string
     */
    public function getArtist(): string
    {
        return $this-&gt;getText();
    }
    /**
     * Sets the artist.
     *
     * @param string $artist The artist
     * @return self
     */
    public function setArtist(string $artist): self
    {
        return $this-&gt;setText($artist);
    }
    /**
     * Returns the artists as an array.
     *
     * @return array&lt;string&gt;
     */
    public function getArtists(): array
    {
        return array_map(&apos;trim&apos;, explode(&apos;/&apos;, $this-&gt;getText()));
    }
    /**
     * Sets the artists from an array.
     *
     * @param array&lt;string&gt; $artists The artists
     * @return self
     */
    public function setArtists(array $artists): self
    {
        return $this-&gt;setText(implode(&apos;/&apos;, $artists));
    }
}</file><file path="app/Modules/MediaMeta/Frame/TPE2.php">&lt;?php
namespace App\Modules\MediaMeta\Frame;
use App\Modules\MediaMeta\Encoding;
/**
 * TPE2 frame - Band/orchestra/accompaniment.
 *
 * The &apos;Band/orchestra/accompaniment&apos; frame is used for additional information about the performers in the recording.
 */
class TPE2 extends TextFrame
{
    /**
     * Constructs the TPE2 frame with given parameters.
     */
    public function __construct(string $band = &apos;&apos;, int $encoding = Encoding::UTF8)
    {
        parent::__construct(&apos;TPE2&apos;, $band, $encoding);
    }
    /**
     * Returns the band/orchestra/accompaniment.
     */
    public function getBand(): string
    {
        return $this-&gt;getText();
    }
    /**
     * Sets the band/orchestra/accompaniment.
     */
    public function setBand(string $band): self
    {
        return $this-&gt;setText($band);
    }
}</file><file path="app/Modules/MediaMeta/Frame/TPE3.php">&lt;?php
namespace App\Modules\MediaMeta\Frame;
use App\Modules\MediaMeta\Encoding;
/**
 * TPE3 frame - Conductor/performer refinement.
 *
 * The &apos;Conductor/performer refinement&apos; frame is used for additional information about the conductor or performer.
 */
class TPE3 extends TextFrame
{
    /**
     * Constructs the TPE3 frame with given parameters.
     */
    public function __construct(string $conductor = &apos;&apos;, int $encoding = Encoding::UTF8)
    {
        parent::__construct(&apos;TPE3&apos;, $conductor, $encoding);
    }
    /**
     * Returns the conductor/performer refinement.
     */
    public function getConductor(): string
    {
        return $this-&gt;getText();
    }
    /**
     * Sets the conductor/performer refinement.
     */
    public function setConductor(string $conductor): self
    {
        return $this-&gt;setText($conductor);
    }
}</file><file path="app/Modules/MediaMeta/Frame/TPE4.php">&lt;?php
namespace App\Modules\MediaMeta\Frame;
use App\Modules\MediaMeta\Encoding;
/**
 * TPE4 frame - Interpreted, remixed, or otherwise modified by.
 *
 * The &apos;Interpreted, remixed, or otherwise modified by&apos; frame contains additional information about the person
 * who interpreted, remixed, or otherwise modified the recording.
 */
class TPE4 extends TextFrame
{
    /**
     * Constructs the TPE4 frame with given parameters.
     */
    public function __construct(string $modifier = &apos;&apos;, int $encoding = Encoding::UTF8)
    {
        parent::__construct(&apos;TPE4&apos;, $modifier, $encoding);
    }
    /**
     * Returns the interpreter/remixer/modifier.
     */
    public function getModifier(): string
    {
        return $this-&gt;getText();
    }
    /**
     * Sets the interpreter/remixer/modifier.
     */
    public function setModifier(string $modifier): self
    {
        return $this-&gt;setText($modifier);
    }
}</file><file path="app/Modules/MediaMeta/Frame/TPUB.php">&lt;?php
namespace App\Modules\MediaMeta\Frame;
use App\Modules\MediaMeta\Encoding;
/**
 * TPUB frame - Publisher.
 *
 * The &apos;Publisher&apos; frame contains the name of the label or publisher.
 */
class TPUB extends TextFrame
{
    /**
     * Constructs the TPUB frame with given parameters.
     */
    public function __construct(string $publisher = &apos;&apos;, int $encoding = Encoding::UTF8)
    {
        parent::__construct(&apos;TPUB&apos;, $publisher, $encoding);
    }
    /**
     * Returns the publisher.
     */
    public function getPublisher(): string
    {
        return $this-&gt;getText();
    }
    /**
     * Sets the publisher.
     */
    public function setPublisher(string $publisher): self
    {
        return $this-&gt;setText($publisher);
    }
}</file><file path="app/Modules/MediaMeta/Frame/TRCK.php">&lt;?php
namespace App\Modules\MediaMeta\Frame;
use App\Modules\MediaMeta\Encoding;
/**
 * TRCK frame - Track number/Position in set.
 *
 * The &apos;Track number/Position in set&apos; frame is a numeric string containing the order number of the
 * audio-file on its original recording. This may be extended with a &quot;/&quot; character and a numeric string
 * containing the total number of tracks/elements on the original recording. E.g. &quot;4/9&quot;.
 */
class TRCK extends TextFrame
{
    /**
     * Constructs the TRCK frame with given parameters.
     */
    public function __construct(string $track = &apos;&apos;, int $encoding = Encoding::UTF8)
    {
        parent::__construct(&apos;TRCK&apos;, $track, $encoding);
    }
    /**
     * Returns the track number.
     */
    public function getTrack(): string
    {
        return $this-&gt;getText();
    }
    /**
     * Sets the track number.
     */
    public function setTrack(string $track): self
    {
        return $this-&gt;setText($track);
    }
}</file><file path="app/Modules/MediaMeta/Frame/TSRC.php">&lt;?php
namespace App\Modules\MediaMeta\Frame;
use App\Modules\MediaMeta\Encoding;
/**
 * TSRC frame - ISRC (International Standard Recording Code).
 *
 * The &apos;ISRC&apos; frame should contain the International Standard Recording Code (ISRC) (12 characters).
 */
class TSRC extends TextFrame
{
    /**
     * Constructs the TSRC frame with given parameters.
     */
    public function __construct(string $isrc = &apos;&apos;, int $encoding = Encoding::UTF8)
    {
        parent::__construct(&apos;TSRC&apos;, $isrc, $encoding);
    }
    /**
     * Returns the ISRC.
     */
    public function getIsrc(): string
    {
        return $this-&gt;getText();
    }
    /**
     * Sets the ISRC.
     */
    public function setIsrc(string $isrc): self
    {
        return $this-&gt;setText($isrc);
    }
}</file><file path="app/Modules/MediaMeta/Frame/TYER.php">&lt;?php
namespace App\Modules\MediaMeta\Frame;
use App\Modules\MediaMeta\Encoding;
/**
 * TYER frame - Year.
 *
 * The &apos;Year&apos; frame is a numeric string with the year of the recording.
 * This frame is always four characters long (until the year 10000).
 */
class TYER extends TextFrame
{
    /**
     * Constructs the TYER frame with given parameters.
     *
     * @param string $year The year
     * @param int $encoding The text encoding
     */
    public function __construct(string $year = &apos;&apos;, int $encoding = Encoding::UTF8)
    {
        parent::__construct(&apos;TYER&apos;, $year, $encoding);
    }
    /**
     * Returns the year.
     *
     * @return string
     */
    public function getYear(): string
    {
        return $this-&gt;getText();
    }
    /**
     * Sets the year as an integer.
     *
     * @param int $year The year
     * @return self
     */
    public function setYearInt(int $year): self
    {
        return $this-&gt;setYear(sprintf(&apos;%04d&apos;, $year));
    }
    /**
     * Sets the year.
     *
     * @param string $year The year
     * @return self
     */
    public function setYear(string $year): self
    {
        // Ensure the year is a valid format (4 digits)
        if (preg_match(&apos;/^\d{4}$/&apos;, $year)) {
            return $this-&gt;setText($year);
        }
        return $this-&gt;setText(&apos;&apos;);
    }
}</file><file path="app/Modules/MediaMeta/Frame/USLT.php">&lt;?php
namespace App\Modules\MediaMeta\Frame;
use App\Modules\MediaMeta\Encoding;
/**
 * USLT frame - Unsynchronized lyric/text transcription.
 *
 * The &apos;Unsynchronized lyric/text transcription&apos; frame contains the lyrics of the song or a text transcription
 * of other vocal activities. It consists of a content descriptor, language code, and the actual text.
 */
class USLT extends Frame
{
    /**
     * Constructs the USLT frame with given parameters.
     */
    public function __construct(
        protected string $text = &apos;&apos;,
        protected string $description = &apos;&apos;,
        protected string $language = &apos;eng&apos;,
        int              $encoding = Encoding::UTF8,
    )
    {
        parent::__construct(&apos;USLT&apos;, $encoding);
        $this-&gt;language = substr($language, 0, 3);
    }
    /**
     * Returns the language code.
     */
    public function getLanguage(): string
    {
        return $this-&gt;language;
    }
    /**
     * Sets the language code.
     */
    public function setLanguage(string $language): self
    {
        $this-&gt;language = substr($language, 0, 3);
        return $this;
    }
    /**
     * Returns the description.
     */
    public function getDescription(): string
    {
        return $this-&gt;description;
    }
    /**
     * Sets the description.
     */
    public function setDescription(string $description): self
    {
        $this-&gt;description = $description;
        return $this;
    }
    /**
     * Returns the lyric text.
     */
    public function getText(): string
    {
        return $this-&gt;text;
    }
    /**
     * Sets the lyric text.
     */
    public function setText(string $text): self
    {
        $this-&gt;text = $text;
        return $this;
    }
    /**
     * Parses the frame data.
     */
    public function parse(string $frameData): self
    {
        // The first byte is text encoding
        $encoding = ord($frameData[0]);
        // The next 3 bytes are language
        $this-&gt;language = substr($frameData, 1, 3);
        // Find the null terminator for the description
        $descriptionStart = 4;
        $isUnicode = in_array($encoding, [Encoding::UTF16, Encoding::UTF16BE]);
        $nullTerminator = $isUnicode ? &quot;\0\0&quot; : &quot;\0&quot;;
        $descriptionEnd = strpos($frameData, $nullTerminator, $descriptionStart);
        $descriptionLength = $descriptionEnd - $descriptionStart;
        // Process description based on encoding
        $this-&gt;description = match ($encoding) {
            Encoding::UTF16, Encoding::UTF16BE =&gt; mb_convert_encoding(
                substr($frameData, $descriptionStart, $descriptionLength),
                &apos;UTF-8&apos;,
                &apos;UTF-16&apos;,
            ),
            Encoding::UTF16LE =&gt; mb_convert_encoding(
                substr($frameData, $descriptionStart, $descriptionLength),
                &apos;UTF-8&apos;,
                &apos;UTF-16LE&apos;,
            ),
            Encoding::UTF8 =&gt; substr($frameData, $descriptionStart, $descriptionLength),
            default =&gt; mb_convert_encoding(
                substr($frameData, $descriptionStart, $descriptionLength),
                &apos;UTF-8&apos;,
                &apos;ISO-8859-1&apos;,
            )
        };
        // Calculate text start position
        $textStart = $descriptionEnd + ($isUnicode ? 2 : 1);
        // The rest is text
        $text = substr($frameData, $textStart);
        // Process text based on encoding
        $this-&gt;text = match ($encoding) {
            Encoding::UTF16, Encoding::UTF16BE =&gt; mb_convert_encoding($text, &apos;UTF-8&apos;, &apos;UTF-16&apos;),
            Encoding::UTF16LE =&gt; mb_convert_encoding($text, &apos;UTF-8&apos;, &apos;UTF-16LE&apos;),
            Encoding::UTF8 =&gt; $text,
            default =&gt; mb_convert_encoding($text, &apos;UTF-8&apos;, &apos;ISO-8859-1&apos;)
        };
        return $this;
    }
    /**
     * Converts the frame to binary data.
     */
    public function toBytes(): string
    {
        // Determine if we&apos;re using Unicode
        $isUnicode = in_array($this-&gt;encoding, [Encoding::UTF16, Encoding::UTF16BE]);
        $nullTerminator = $isUnicode ? &quot;\0\0&quot; : &quot;\0&quot;;
        // Convert description to the specified encoding
        $encodedDescription = match ($this-&gt;encoding) {
            Encoding::UTF16, Encoding::UTF16BE =&gt; mb_convert_encoding($this-&gt;description, &apos;UTF-16&apos;, &apos;UTF-8&apos;),
            Encoding::UTF16LE =&gt; mb_convert_encoding($this-&gt;description, &apos;UTF-16LE&apos;, &apos;UTF-8&apos;),
            Encoding::UTF8 =&gt; $this-&gt;description,
            default =&gt; mb_convert_encoding($this-&gt;description, &apos;ISO-8859-1&apos;, &apos;UTF-8&apos;)
        };
        // Convert text to the specified encoding
        $encodedText = match ($this-&gt;encoding) {
            Encoding::UTF16, Encoding::UTF16BE =&gt; mb_convert_encoding($this-&gt;text, &apos;UTF-16&apos;, &apos;UTF-8&apos;),
            Encoding::UTF16LE =&gt; mb_convert_encoding($this-&gt;text, &apos;UTF-16LE&apos;, &apos;UTF-8&apos;),
            Encoding::UTF8 =&gt; $this-&gt;text,
            default =&gt; mb_convert_encoding($this-&gt;text, &apos;ISO-8859-1&apos;, &apos;UTF-8&apos;)
        };
        // Return the encoding byte, language, description with null terminator, and text
        return chr($this-&gt;encoding) . $this-&gt;language . $encodedDescription . $nullTerminator . $encodedText;
    }
}</file><file path="app/Modules/MediaMeta/Id3v1.php">&lt;?php
namespace App\Modules\MediaMeta;
use Exception;
/**
 * This class represents a file containing ID3v1 tags.
 *
 * ID3v1 is a simple tagging format that stores metadata at the end of the audio file.
 * It has fixed-length fields for title, artist, album, year, comment, and genre.
 */
class Id3v1
{
    /** @var string */
    private string $title = &apos;&apos;;
    /** @var string */
    private string $artist = &apos;&apos;;
    /** @var string */
    private string $album = &apos;&apos;;
    /** @var string */
    private string $year = &apos;&apos;;
    /** @var string */
    private string $comment = &apos;&apos;;
    /** @var integer */
    private int $track = 0;
    /** @var integer */
    private int $genre = 255;
    /**
     * The genre list.
     *
     * @var array
     */
    public static array $genres = [
        &apos;Blues&apos;, &apos;Classic Rock&apos;, &apos;Country&apos;, &apos;Dance&apos;, &apos;Disco&apos;, &apos;Funk&apos;, &apos;Grunge&apos;,
        &apos;Hip-Hop&apos;, &apos;Jazz&apos;, &apos;Metal&apos;, &apos;New Age&apos;, &apos;Oldies&apos;, &apos;Other&apos;, &apos;Pop&apos;, &apos;R&amp;B&apos;,
        &apos;Rap&apos;, &apos;Reggae&apos;, &apos;Rock&apos;, &apos;Techno&apos;, &apos;Industrial&apos;, &apos;Alternative&apos;, &apos;Ska&apos;,
        &apos;Death Metal&apos;, &apos;Pranks&apos;, &apos;Soundtrack&apos;, &apos;Euro-Techno&apos;, &apos;Ambient&apos;,
        &apos;Trip-Hop&apos;, &apos;Vocal&apos;, &apos;Jazz+Funk&apos;, &apos;Fusion&apos;, &apos;Trance&apos;, &apos;Classical&apos;,
        &apos;Instrumental&apos;, &apos;Acid&apos;, &apos;House&apos;, &apos;Game&apos;, &apos;Sound Clip&apos;, &apos;Gospel&apos;,
        &apos;Noise&apos;, &apos;AlternRock&apos;, &apos;Bass&apos;, &apos;Soul&apos;, &apos;Punk&apos;, &apos;Space&apos;, &apos;Meditative&apos;,
        &apos;Instrumental Pop&apos;, &apos;Instrumental Rock&apos;, &apos;Ethnic&apos;, &apos;Gothic&apos;,
        &apos;Darkwave&apos;, &apos;Techno-Industrial&apos;, &apos;Electronic&apos;, &apos;Pop-Folk&apos;, &apos;Eurodance&apos;,
        &apos;Dream&apos;, &apos;Southern Rock&apos;, &apos;Comedy&apos;, &apos;Cult&apos;, &apos;Gangsta&apos;, &apos;Top 40&apos;,
        &apos;Christian Rap&apos;, &apos;Pop/Funk&apos;, &apos;Jungle&apos;, &apos;Native American&apos;, &apos;Cabaret&apos;,
        &apos;New Wave&apos;, &apos;Psychadelic&apos;, &apos;Rave&apos;, &apos;Showtunes&apos;, &apos;Trailer&apos;, &apos;Lo-Fi&apos;,
        &apos;Tribal&apos;, &apos;Acid Punk&apos;, &apos;Acid Jazz&apos;, &apos;Polka&apos;, &apos;Retro&apos;, &apos;Musical&apos;,
        &apos;Rock &amp; Roll&apos;, &apos;Hard Rock&apos;, &apos;Folk&apos;, &apos;Folk-Rock&apos;, &apos;National Folk&apos;,
        &apos;Swing&apos;, &apos;Fast Fusion&apos;, &apos;Bebob&apos;, &apos;Latin&apos;, &apos;Revival&apos;, &apos;Celtic&apos;,
        &apos;Bluegrass&apos;, &apos;Avantgarde&apos;, &apos;Gothic Rock&apos;, &apos;Progressive Rock&apos;,
        &apos;Psychedelic Rock&apos;, &apos;Symphonic Rock&apos;, &apos;Slow Rock&apos;, &apos;Big Band&apos;,
        &apos;Chorus&apos;, &apos;Easy Listening&apos;, &apos;Acoustic&apos;, &apos;Humour&apos;, &apos;Speech&apos;, &apos;Chanson&apos;,
        &apos;Opera&apos;, &apos;Chamber Music&apos;, &apos;Sonata&apos;, &apos;Symphony&apos;, &apos;Booty Bass&apos;, &apos;Primus&apos;,
        &apos;Porn Groove&apos;, &apos;Satire&apos;, &apos;Slow Jam&apos;, &apos;Club&apos;, &apos;Tango&apos;, &apos;Samba&apos;,
        &apos;Folklore&apos;, &apos;Ballad&apos;, &apos;Power Ballad&apos;, &apos;Rhythmic Soul&apos;, &apos;Freestyle&apos;,
        &apos;Duet&apos;, &apos;Punk Rock&apos;, &apos;Drum Solo&apos;, &apos;A capella&apos;, &apos;Euro-House&apos;,
        &apos;Dance Hall&apos;, 255 =&gt; &apos;Unknown&apos;,
    ];
    private string $filePath;
    /**
     * Constructs the Id3v1 class with given file.
     *
     * @param string $filePath The path to the audio file
     * @throws Exception if the file cannot be read or does not contain ID3v1 tags
     */
    public function __construct(string $filePath)
    {
        $this-&gt;filePath = $filePath;
        $this-&gt;parse();
    }
    /**
     * Parses the ID3v1 tag from the file.
     *
     * @throws Exception if the file cannot be read or does not contain ID3v1 tags
     */
    private function parse(): void
    {
        if (!file_exists($this-&gt;filePath)) {
            throw new Exception(&quot;File not found: {$this-&gt;filePath}&quot;);
        }
        $handle = fopen($this-&gt;filePath, &apos;rb&apos;);
        if (!$handle) {
            throw new Exception(&quot;Cannot open file: {$this-&gt;filePath}&quot;);
        }
        // ID3v1 tag is always at the end of the file and is 128 bytes long
        fseek($handle, -128, SEEK_END);
        $tag = fread($handle, 128);
        fclose($handle);
        // Check if the file has an ID3v1 tag
        if (!str_starts_with($tag, &apos;TAG&apos;)) {
            throw new Exception(&quot;File does not contain ID3v1 tag&quot;);
        }
        // Parse the tag
        $this-&gt;title = trim(substr($tag, 3, 30));
        $this-&gt;artist = trim(substr($tag, 33, 30));
        $this-&gt;album = trim(substr($tag, 63, 30));
        $this-&gt;year = trim(substr($tag, 93, 4));
        // Check for ID3v1.1 (with track number)
        if (ord(substr($tag, 125, 1)) === 0 &amp;&amp; ord(substr($tag, 126, 1)) !== 0) {
            $this-&gt;comment = trim(substr($tag, 97, 28));
            $this-&gt;track = ord(substr($tag, 126, 1));
        } else {
            $this-&gt;comment = trim(substr($tag, 97, 30));
            $this-&gt;track = 0;
        }
        $this-&gt;genre = ord(substr($tag, 127, 1));
    }
    /**
     * Returns the title.
     *
     * @return string
     */
    public function getTitle(): string
    {
        return $this-&gt;title;
    }
    /**
     * Returns the artist.
     *
     * @return string
     */
    public function getArtist(): string
    {
        return $this-&gt;artist;
    }
    /**
     * Returns the album.
     *
     * @return string
     */
    public function getAlbum(): string
    {
        return $this-&gt;album;
    }
    /**
     * Returns the year.
     *
     * @return string
     */
    public function getYear(): string
    {
        return $this-&gt;year;
    }
    /**
     * Returns the comment.
     *
     * @return string
     */
    public function getComment(): string
    {
        return $this-&gt;comment;
    }
    /**
     * Returns the track number.
     *
     * @return integer
     */
    public function getTrack(): int
    {
        return $this-&gt;track;
    }
    /**
     * Returns the genre.
     *
     * @return string
     */
    public function getGenre(): string
    {
        return self::$genres[$this-&gt;genre] ?? &apos;Unknown&apos;;
    }
    /**
     * Returns the genre ID.
     *
     * @return integer
     */
    public function getGenreId(): int
    {
        return $this-&gt;genre;
    }
    /**
     * Sets the title.
     *
     * @param string $title The title
     * @return self
     */
    public function setTitle(string $title): self
    {
        $this-&gt;title = substr($title, 0, 30);
        return $this;
    }
    /**
     * Sets the artist.
     *
     * @param string $artist The artist
     * @return self
     */
    public function setArtist(string $artist): self
    {
        $this-&gt;artist = substr($artist, 0, 30);
        return $this;
    }
    /**
     * Sets the album.
     *
     * @param string $album The album
     * @return self
     */
    public function setAlbum(string $album): self
    {
        $this-&gt;album = substr($album, 0, 30);
        return $this;
    }
    /**
     * Sets the year.
     *
     * @param string $year The year
     * @return self
     */
    public function setYear(string $year): self
    {
        $this-&gt;year = substr($year, 0, 4);
        return $this;
    }
    /**
     * Sets the comment.
     *
     * @param string $comment The comment
     * @return self
     */
    public function setComment(string $comment): self
    {
        $this-&gt;comment = substr($comment, 0, 28);
        return $this;
    }
    /**
     * Sets the track number.
     *
     * @param integer $track The track number
     * @return self
     */
    public function setTrack(int $track): self
    {
        $this-&gt;track = min(255, max(0, $track));
        return $this;
    }
    /**
     * Sets the genre ID.
     *
     * @param integer $genreId The genre ID
     * @return self
     */
    public function setGenreId(int $genreId): self
    {
        $this-&gt;genre = min(255, max(0, $genreId));
        return $this;
    }
    /**
     * Sets the genre by name.
     *
     * @param string $genre The genre name
     * @return self
     */
    public function setGenre(string $genre): self
    {
        $genreId = array_search($genre, self::$genres);
        if ($genreId !== false) {
            $this-&gt;genre = $genreId;
        }
        return $this;
    }
    /**
     * Writes the ID3v1 tag to the file.
     *
     * @throws Exception if the file cannot be written
     */
    public function write(): void
    {
        $handle = fopen($this-&gt;filePath, &apos;r+b&apos;);
        if (!$handle) {
            throw new Exception(&quot;Cannot open file for writing: {$this-&gt;filePath}&quot;);
        }
        // Prepare the tag data
        $tag = &apos;TAG&apos;;
        $tag .= str_pad($this-&gt;title, 30, &quot;\0&quot;);
        $tag .= str_pad($this-&gt;artist, 30, &quot;\0&quot;);
        $tag .= str_pad($this-&gt;album, 30, &quot;\0&quot;);
        $tag .= str_pad($this-&gt;year, 4, &quot;\0&quot;);
        // Handle ID3v1.1 (with track number)
        if ($this-&gt;track &gt; 0) {
            $tag .= str_pad($this-&gt;comment, 28, &quot;\0&quot;);
            $tag .= &quot;\0&quot;;
            $tag .= chr($this-&gt;track);
        } else {
            $tag .= str_pad($this-&gt;comment, 30, &quot;\0&quot;);
        }
        $tag .= chr($this-&gt;genre);
        // Check if the file already has an ID3v1 tag
        fseek($handle, -128, SEEK_END);
        $existingTag = fread($handle, 3);
        if ($existingTag === &apos;TAG&apos;) {
            // Overwrite the existing tag
            fseek($handle, -128, SEEK_END);
        } else {
            // Append the tag to the end of the file
            fseek($handle, 0, SEEK_END);
        }
        fwrite($handle, $tag);
        fclose($handle);
    }
}</file><file path="app/Modules/MediaMeta/Id3v2.php">&lt;?php
namespace App\Modules\MediaMeta;
use App\Modules\MediaMeta\Frame\Apic;
use App\Modules\MediaMeta\Frame\COMM;
use App\Modules\MediaMeta\Frame\EQUA;
use App\Modules\MediaMeta\Frame\ETCO;
use App\Modules\MediaMeta\Frame\Frame;
use App\Modules\MediaMeta\Frame\IPLS;
use App\Modules\MediaMeta\Frame\LINK;
use App\Modules\MediaMeta\Frame\MCDI;
use App\Modules\MediaMeta\Frame\MVIN;
use App\Modules\MediaMeta\Frame\OWNE;
use App\Modules\MediaMeta\Frame\POPM;
use App\Modules\MediaMeta\Frame\SYLT;
use App\Modules\MediaMeta\Frame\TALB;
use App\Modules\MediaMeta\Frame\TCOM;
use App\Modules\MediaMeta\Frame\TCON;
use App\Modules\MediaMeta\Frame\TDAT;
use App\Modules\MediaMeta\Frame\TEXT;
use App\Modules\MediaMeta\Frame\TextFrame;
use App\Modules\MediaMeta\Frame\TIT2;
use App\Modules\MediaMeta\Frame\TLAN;
use App\Modules\MediaMeta\Frame\TLEN;
use App\Modules\MediaMeta\Frame\TORY;
use App\Modules\MediaMeta\Frame\TPE1;
use App\Modules\MediaMeta\Frame\TPE2;
use App\Modules\MediaMeta\Frame\TPE3;
use App\Modules\MediaMeta\Frame\TPE4;
use App\Modules\MediaMeta\Frame\TPUB;
use App\Modules\MediaMeta\Frame\TRCK;
use App\Modules\MediaMeta\Frame\TSRC;
use App\Modules\MediaMeta\Frame\USLT;
use App\Modules\MediaMeta\Frame\TYER;
use Exception;
/**
 * This class represents a file containing ID3v2 tags.
 *
 * ID3v2 is a flexible tagging format that stores metadata at the beginning of the audio file.
 * It supports various types of frames for different kinds of metadata, including images.
 */
class Id3v2
{
    /** @var string */
    private $filePath;
    /** @var int */
    private $version = 0;
    /** @var array */
    private $frames = [];
    /** @var int */
    private $encoding = Encoding::UTF8;
    /**
     * Constructs the Id3v2 class with given file.
     *
     * @param string $filePath The path to the audio file
     * @param array $options Options for reading the tag
     * @throws Exception if the file cannot be read or does not contain ID3v2 tags
     */
    public function __construct(string $filePath, array $options = [])
    {
        $this-&gt;filePath = $filePath;
        if (isset($options[&apos;encoding&apos;])) {
            $this-&gt;encoding = $options[&apos;encoding&apos;];
        }
        $this-&gt;parse();
    }
    /**
     * Parses the ID3v2 tag from the file.
     *
     * @throws Exception if the file cannot be read or does not contain ID3v2 tags
     */
    private function parse(): void
    {
        if (!file_exists($this-&gt;filePath)) {
            throw new Exception(&quot;File not found: {$this-&gt;filePath}&quot;);
        }
        $handle = fopen($this-&gt;filePath, &apos;rb&apos;);
        if (!$handle) {
            throw new Exception(&quot;Cannot open file: {$this-&gt;filePath}&quot;);
        }
        // Read the ID3v2 header (10 bytes)
        $header = fread($handle, 10);
        // Check if the file has an ID3v2 tag
        if (!str_starts_with($header, &apos;ID3&apos;)) {
            fclose($handle);
            throw new Exception(&quot;File does not contain ID3v2 tag&quot;);
        }
        // Parse the header
        $this-&gt;version = ord($header[3]);
        // Check if the version is supported
        if ($this-&gt;version &lt; 3 || $this-&gt;version &gt; 4) {
            fclose($handle);
            throw new Exception(&quot;Unsupported ID3v2 version: {$this-&gt;version}&quot;);
        }
        // Get the tag size (bytes 6-9, 7-bit format)
        $size = (
            (ord($header[6]) &amp; 0x7F) &lt;&lt; 21 |
            (ord($header[7]) &amp; 0x7F) &lt;&lt; 14 |
            (ord($header[8]) &amp; 0x7F) &lt;&lt; 7 |
            (ord($header[9]) &amp; 0x7F)
        );
        // Read the entire tag
        fseek($handle, 10); // Skip the header
        $tagData = fread($handle, $size);
        fclose($handle);
        // Parse the frames
        $this-&gt;parseFrames($tagData);
    }
    /**
     * Parses the frames from the tag data.
     *
     * @param string $tagData The tag data
     */
    private function parseFrames(string $tagData): void
    {
        $offset = 0;
        $tagSize = strlen($tagData);
        while ($offset &lt; $tagSize) {
            // Check if we&apos;ve reached padding (0x00 bytes)
            if (ord($tagData[$offset]) === 0) {
                break;
            }
            // Frame ID is 4 bytes
            $frameId = substr($tagData, $offset, 4);
            $offset += 4;
            // Frame size is 4 bytes
            $frameSize = (
                ord($tagData[$offset]) &lt;&lt; 24 |
                ord($tagData[$offset + 1]) &lt;&lt; 16 |
                ord($tagData[$offset + 2]) &lt;&lt; 8 |
                ord($tagData[$offset + 3])
            );
            $offset += 4;
            // Frame flags are 2 bytes (skip for now)
            $offset += 2;
            // Read the frame data
            $frameData = substr($tagData, $offset, $frameSize);
            $offset += $frameSize;
            // Process the frame based on its ID
            $this-&gt;processFrame($frameId, $frameData);
        }
    }
    /**
     * Processes a frame based on its ID.
     *
     * @param string $frameId The frame ID
     * @param string $frameData The frame data
     */
    private function processFrame(string $frameId, string $frameData): void
    {
        // Store the frame data by ID
        if (!isset($this-&gt;frames[$frameId])) {
            $this-&gt;frames[$frameId] = [];
        }
        // Create the appropriate frame object based on the frame ID
        $frame = $this-&gt;createFrame($frameId, $frameData);
        if ($frame !== null) {
            $this-&gt;frames[$frameId][] = $frame;
        } else {
            // For unknown frames, store the raw data
            $this-&gt;frames[$frameId][] = $frameData;
        }
    }
    /**
     * Creates a frame object based on the frame ID.
     */
    private function createFrame(string $frameId, string $frameData): ?Frame
    {
        $frame = match ($frameId) {
            &apos;TIT2&apos; =&gt; new TIT2(encoding: $this-&gt;encoding),
            &apos;TPE1&apos; =&gt; new TPE1(encoding: $this-&gt;encoding),
            &apos;TPE2&apos; =&gt; new TPE2(encoding: $this-&gt;encoding),
            &apos;TPE3&apos; =&gt; new TPE3(encoding: $this-&gt;encoding),
            &apos;TPE4&apos; =&gt; new TPE4(encoding: $this-&gt;encoding),
            &apos;TALB&apos; =&gt; new TALB(encoding: $this-&gt;encoding),
            &apos;TCON&apos; =&gt; new TCON(encoding: $this-&gt;encoding),
            &apos;TYER&apos; =&gt; new TYER(encoding: $this-&gt;encoding),
            &apos;TCOM&apos; =&gt; new TCOM(encoding: $this-&gt;encoding),
            &apos;TDAT&apos; =&gt; new TDAT(encoding: $this-&gt;encoding),
            &apos;TEXT&apos; =&gt; new TEXT(encoding: $this-&gt;encoding),
            &apos;TLAN&apos; =&gt; new TLAN(encoding: $this-&gt;encoding),
            &apos;TLEN&apos; =&gt; new TLEN(encoding: $this-&gt;encoding),
            &apos;TORY&apos; =&gt; new TORY(encoding: $this-&gt;encoding),
            &apos;TPUB&apos; =&gt; new TPUB(encoding: $this-&gt;encoding),
            &apos;TSRC&apos; =&gt; new TSRC(encoding: $this-&gt;encoding),
            &apos;TRCK&apos; =&gt; new TRCK(encoding: $this-&gt;encoding),
            &apos;MVIN&apos; =&gt; new MVIN(encoding: $this-&gt;encoding),
            &apos;APIC&apos; =&gt; new Apic(encoding: $this-&gt;encoding),
            &apos;COMM&apos; =&gt; new COMM(encoding: $this-&gt;encoding),
            &apos;USLT&apos; =&gt; new USLT(encoding: $this-&gt;encoding),
            &apos;SYLT&apos; =&gt; new SYLT(encoding: $this-&gt;encoding),
            &apos;POPM&apos; =&gt; new POPM(),
            &apos;OWNE&apos; =&gt; new OWNE(encoding: $this-&gt;encoding),
            &apos;IPLS&apos; =&gt; new IPLS(encoding: $this-&gt;encoding),
            &apos;LINK&apos; =&gt; new LINK(),
            &apos;MCDI&apos; =&gt; new MCDI(),
            &apos;ETCO&apos; =&gt; new ETCO(),
            &apos;EQUA&apos; =&gt; new EQUA(),
            default =&gt; str_starts_with($frameId, &apos;T&apos;)
                ? new TextFrame($frameId, encoding: $this-&gt;encoding)
                : null
        };
        // Parse the frame data if a frame was created
        return $frame?-&gt;parse($frameData);
    }
    /**
     * Returns all frames with the given identifier.
     *
     * @param string $identifier The frame identifier
     * @return array The frames
     */
    public function getFramesByIdentifier(string $identifier): array
    {
        return $this-&gt;frames[$identifier] ?? [];
    }
    /**
     * Returns the APIC frame (APIC).
     *
     *
     * @return Apic|null The APIC frame, or null if not available
     */
    public function getApicFrame(): ?Apic
    {
        $frames = $this-&gt;getFramesByIdentifier(&apos;APIC&apos;);
        if (count($frames) === 0) {
            return null;
        }
        return $frames[0];
    }
    /**
     * Sets the APIC frame (APIC).
     *
     * @param string $imagePath The path to the image file
     * @param string $imageType The image type (e.g. &quot;image/jpeg&quot;)
     * @return self
     */
    public function setApicFrame(string $imagePath, string $imageType): self
    {
        $mimeType = new \finfo(FILEINFO_MIME_TYPE)-&gt;file($imagePath);
        if ($mimeType === false) {
            return $this;
        }
        $frame = new Apic(
            data: [
                &apos;mimeType&apos;  =&gt; $mimeType,
                &apos;imageType&apos; =&gt; $imageType,
                &apos;imageData&apos; =&gt; file_get_contents($imagePath),
            ],
            encoding: $this-&gt;encoding,
        );
        $this-&gt;frames[&apos;APIC&apos;] = [$frame];
        return $this;
    }
    /**
     * Returns the title frame (TIT2).
     *
     * @return TIT2|null The title frame, or null if not available
     */
    public function getTIT2Frame(): ?TIT2
    {
        $frames = $this-&gt;getFramesByIdentifier(&apos;TIT2&apos;);
        if (count($frames) === 0) {
            return null;
        }
        return $frames[0];
    }
    /**
     * Sets the title frame (TIT2).
     *
     * @param string $title The title
     * @return self
     */
    public function setTIT2Frame(string $title): self
    {
        $frame = new TIT2($title, $this-&gt;encoding);
        $this-&gt;frames[&apos;TIT2&apos;] = [$frame];
        return $this;
    }
    /**
     * Returns the artist frame (TPE1).
     *
     * @return TPE1|null The artist frame, or null if not available
     */
    public function getTPE1Frame(): ?TPE1
    {
        $frames = $this-&gt;getFramesByIdentifier(&apos;TPE1&apos;);
        if (count($frames) === 0) {
            return null;
        }
        return $frames[0];
    }
    /**
     * Sets the artist frame (TPE1).
     *
     * @param string $artist The artist
     * @return self
     */
    public function setTPE1Frame(string $artist): self
    {
        $frame = new TPE1($artist, $this-&gt;encoding);
        $this-&gt;frames[&apos;TPE1&apos;] = [$frame];
        return $this;
    }
    /**
     * Returns the album frame (TALB).
     *
     * @return TALB|null The album frame, or null if not available
     */
    public function getTALBFrame(): ?TALB
    {
        $frames = $this-&gt;getFramesByIdentifier(&apos;TALB&apos;);
        if (count($frames) === 0) {
            return null;
        }
        return $frames[0];
    }
    /**
     * Sets the album frame (TALB).
     *
     * @param string $album The album
     * @return self
     */
    public function setTALBFrame(string $album): self
    {
        $frame = new TALB($album, $this-&gt;encoding);
        $this-&gt;frames[&apos;TALB&apos;] = [$frame];
        return $this;
    }
    /**
     * Returns the genre frame (TCON).
     *
     * @return TCON|null The genre frame, or null if not available
     */
    public function getTCONFrame(): ?TCON
    {
        $frames = $this-&gt;getFramesByIdentifier(&apos;TCON&apos;);
        if (count($frames) === 0) {
            return null;
        }
        return $frames[0];
    }
    /**
     * Sets the genre frame (TCON).
     *
     * @param string $genre The genre
     * @return self
     */
    public function setTCONFrame(string $genre): self
    {
        $frame = new TCON($genre, $this-&gt;encoding);
        $this-&gt;frames[&apos;TCON&apos;] = [$frame];
        return $this;
    }
    /**
     * Returns the year frame (TYER).
     *
     * @return TYER|null The year frame, or null if not available
     */
    public function getTYERFrame(): ?TYER
    {
        $frames = $this-&gt;getFramesByIdentifier(&apos;TYER&apos;);
        if (count($frames) === 0) {
            return null;
        }
        return $frames[0];
    }
    /**
     * Sets the year frame (TYER).
     *
     * @param string $year The year
     * @return self
     */
    public function setTYERFrame(string $year): self
    {
        $frame = new TYER($year, $this-&gt;encoding);
        $this-&gt;frames[&apos;TYER&apos;] = [$frame];
        return $this;
    }
    /**
     * Returns the comment frames (COMM).
     *
     * @return array&lt;COMM&gt; The comment frames
     */
    public function getCOMMFrames(): array
    {
        return $this-&gt;getFramesByIdentifier(&apos;COMM&apos;);
    }
    /**
     * Returns the first comment frame (COMM).
     *
     * @return COMM|null The comment frame, or null if not available
     */
    public function getCOMMFrame(): ?COMM
    {
        $frames = $this-&gt;getCOMMFrames();
        if (count($frames) === 0) {
            return null;
        }
        return $frames[0];
    }
    /**
     * Returns a comment frame with the given description.
     *
     * @param string $description The description
     * @return COMM|null The comment frame, or null if not available
     */
    public function getCOMMFrameByDescription(string $description): ?COMM
    {
        $frames = $this-&gt;getCOMMFrames();
        return array_find($frames, fn($frame) =&gt; $frame-&gt;getDescription() === $description);
    }
    /**
     * Sets a comment frame (COMM).
     *
     * @param string $text The comment text
     * @param string $description The description
     * @param string $language The language code
     * @return self
     */
    public function setCOMMFrame(string $text, string $description = &apos;&apos;, string $language = &apos;eng&apos;): self
    {
        $frame = new COMM($text, $description, $language, $this-&gt;encoding);
        // Check if a frame with the same description already exists
        $frames = $this-&gt;getCOMMFrames();
        $existingFrames = [];
        $found = false;
        foreach ($frames as $existingFrame) {
            if ($existingFrame-&gt;getDescription() === $description) {
                $existingFrames[] = $frame;
                $found = true;
            } else {
                $existingFrames[] = $existingFrame;
            }
        }
        if (!$found) {
            $existingFrames[] = $frame;
        }
        $this-&gt;frames[&apos;COMM&apos;] = $existingFrames;
        return $this;
    }
    /**
     * Removes all comment frames (COMM).
     *
     * @return self
     */
    public function removeCOMMFrames(): self
    {
        $this-&gt;frames[&apos;COMM&apos;] = [];
        return $this;
    }
    /**
     * Removes a comment frame with the given description.
     *
     * @param string $description The description
     * @return self
     */
    public function removeCOMMFrameByDescription(string $description): self
    {
        $frames = $this-&gt;getCOMMFrames();
        $filteredFrames = array_filter($frames, fn($frame) =&gt; $frame-&gt;getDescription() !== $description);
        $this-&gt;frames[&apos;COMM&apos;] = array_values($filteredFrames);
        return $this;
    }
    /**
     * Returns the composer frame (TCOM).
     *
     * @return TCOM|null The composer frame, or null if not available
     */
    public function getTCOMFrame(): ?TCOM
    {
        $frames = $this-&gt;getFramesByIdentifier(&apos;TCOM&apos;);
        if (count($frames) === 0) {
            return null;
        }
        return $frames[0];
    }
    /**
     * Sets the composer frame (TCOM).
     *
     * @param string $composer The composer
     * @return self
     */
    public function setTCOMFrame(string $composer): self
    {
        $frame = new TCOM($composer, $this-&gt;encoding);
        $this-&gt;frames[&apos;TCOM&apos;] = [$frame];
        return $this;
    }
    /**
     * Returns the date frame (TDAT).
     *
     * @return TDAT|null The date frame, or null if not available
     */
    public function getTDATFrame(): ?TDAT
    {
        $frames = $this-&gt;getFramesByIdentifier(&apos;TDAT&apos;);
        if (count($frames) === 0) {
            return null;
        }
        return $frames[0];
    }
    /**
     * Sets the date frame (TDAT).
     *
     * @param string $date The date (DDMM format)
     * @return self
     */
    public function setTDATFrame(string $date): self
    {
        $frame = new TDAT($date, $this-&gt;encoding);
        $this-&gt;frames[&apos;TDAT&apos;] = [$frame];
        return $this;
    }
    /**
     * Returns the lyricist/text writer frame (TEXT).
     *
     * @return TEXT|null The lyricist/text writer frame, or null if not available
     */
    public function getTEXTFrame(): ?TEXT
    {
        $frames = $this-&gt;getFramesByIdentifier(&apos;TEXT&apos;);
        if (count($frames) === 0) {
            return null;
        }
        return $frames[0];
    }
    /**
     * Sets the lyricist/text writer frame (TEXT).
     *
     * @param string $lyricist The lyricist/text writer
     * @return self
     */
    public function setTEXTFrame(string $lyricist): self
    {
        $frame = new TEXT($lyricist, $this-&gt;encoding);
        $this-&gt;frames[&apos;TEXT&apos;] = [$frame];
        return $this;
    }
    /**
     * Returns the language frame (TLAN).
     *
     * @return TLAN|null The language frame, or null if not available
     */
    public function getTLANFrame(): ?TLAN
    {
        $frames = $this-&gt;getFramesByIdentifier(&apos;TLAN&apos;);
        if (count($frames) === 0) {
            return null;
        }
        return $frames[0];
    }
    /**
     * Sets the language frame (TLAN).
     *
     * @param string $language The language code(s)
     * @return self
     */
    public function setTLANFrame(string $language): self
    {
        $frame = new TLAN($language, $this-&gt;encoding);
        $this-&gt;frames[&apos;TLAN&apos;] = [$frame];
        return $this;
    }
    /**
     * Returns the length frame (TLEN).
     *
     * @return TLEN|null The length frame, or null if not available
     */
    public function getTLENFrame(): ?TLEN
    {
        $frames = $this-&gt;getFramesByIdentifier(&apos;TLEN&apos;);
        if (count($frames) === 0) {
            return null;
        }
        return $frames[0];
    }
    /**
     * Sets the length frame (TLEN).
     *
     * @param string $length The length in milliseconds
     * @return self
     */
    public function setTLENFrame(string $length): self
    {
        $frame = new TLEN($length, $this-&gt;encoding);
        $this-&gt;frames[&apos;TLEN&apos;] = [$frame];
        return $this;
    }
    /**
     * Returns the original release year frame (TORY).
     *
     * @return TORY|null The original release year frame, or null if not available
     */
    public function getTORYFrame(): ?TORY
    {
        $frames = $this-&gt;getFramesByIdentifier(&apos;TORY&apos;);
        if (count($frames) === 0) {
            return null;
        }
        return $frames[0];
    }
    /**
     * Sets the original release year frame (TORY).
     *
     * @param string $year The original release year
     * @return self
     */
    public function setTORYFrame(string $year): self
    {
        $frame = new TORY($year, $this-&gt;encoding);
        $this-&gt;frames[&apos;TORY&apos;] = [$frame];
        return $this;
    }
    /**
     * Returns the band/orchestra/accompaniment frame (TPE2).
     *
     * @return TPE2|null The band/orchestra/accompaniment frame, or null if not available
     */
    public function getTPE2Frame(): ?TPE2
    {
        $frames = $this-&gt;getFramesByIdentifier(&apos;TPE2&apos;);
        if (count($frames) === 0) {
            return null;
        }
        return $frames[0];
    }
    /**
     * Sets the band/orchestra/accompaniment frame (TPE2).
     *
     * @param string $band The band/orchestra/accompaniment
     * @return self
     */
    public function setTPE2Frame(string $band): self
    {
        $frame = new TPE2($band, $this-&gt;encoding);
        $this-&gt;frames[&apos;TPE2&apos;] = [$frame];
        return $this;
    }
    /**
     * Returns the conductor/performer refinement frame (TPE3).
     *
     * @return TPE3|null The conductor/performer refinement frame, or null if not available
     */
    public function getTPE3Frame(): ?TPE3
    {
        $frames = $this-&gt;getFramesByIdentifier(&apos;TPE3&apos;);
        if (count($frames) === 0) {
            return null;
        }
        return $frames[0];
    }
    /**
     * Sets the conductor/performer refinement frame (TPE3).
     *
     * @param string $conductor The conductor/performer refinement
     * @return self
     */
    public function setTPE3Frame(string $conductor): self
    {
        $frame = new TPE3($conductor, $this-&gt;encoding);
        $this-&gt;frames[&apos;TPE3&apos;] = [$frame];
        return $this;
    }
    /**
     * Returns the interpreted, remixed, or otherwise modified by frame (TPE4).
     *
     * @return TPE4|null The interpreted, remixed, or otherwise modified by frame, or null if not available
     */
    public function getTPE4Frame(): ?TPE4
    {
        $frames = $this-&gt;getFramesByIdentifier(&apos;TPE4&apos;);
        if (count($frames) === 0) {
            return null;
        }
        return $frames[0];
    }
    /**
     * Sets the interpreted, remixed, or otherwise modified by frame (TPE4).
     *
     * @param string $modifier The interpreter/remixer/modifier
     * @return self
     */
    public function setTPE4Frame(string $modifier): self
    {
        $frame = new TPE4($modifier, $this-&gt;encoding);
        $this-&gt;frames[&apos;TPE4&apos;] = [$frame];
        return $this;
    }
    /**
     * Returns the publisher frame (TPUB).
     *
     * @return TPUB|null The publisher frame, or null if not available
     */
    public function getTPUBFrame(): ?TPUB
    {
        $frames = $this-&gt;getFramesByIdentifier(&apos;TPUB&apos;);
        if (count($frames) === 0) {
            return null;
        }
        return $frames[0];
    }
    /**
     * Sets the publisher frame (TPUB).
     *
     * @param string $publisher The publisher
     * @return self
     */
    public function setTPUBFrame(string $publisher): self
    {
        $frame = new TPUB($publisher, $this-&gt;encoding);
        $this-&gt;frames[&apos;TPUB&apos;] = [$frame];
        return $this;
    }
    /**
     * Returns the ISRC frame (TSRC).
     *
     * @return TSRC|null The ISRC frame, or null if not available
     */
    public function getTSRCFrame(): ?TSRC
    {
        $frames = $this-&gt;getFramesByIdentifier(&apos;TSRC&apos;);
        if (count($frames) === 0) {
            return null;
        }
        return $frames[0];
    }
    /**
     * Sets the ISRC frame (TSRC).
     *
     * @param string $isrc The ISRC
     * @return self
     */
    public function setTSRCFrame(string $isrc): self
    {
        $frame = new TSRC($isrc, $this-&gt;encoding);
        $this-&gt;frames[&apos;TSRC&apos;] = [$frame];
        return $this;
    }
    /**
     * Returns the track number frame (TRCK).
     *
     * @return TRCK|null The track number frame, or null if not available
     */
    public function getTRCKFrame(): ?TRCK
    {
        $frames = $this-&gt;getFramesByIdentifier(&apos;TRCK&apos;);
        if (count($frames) === 0) {
            return null;
        }
        return $frames[0];
    }
    /**
     * Sets the track number frame (TRCK).
     *
     * @param string $track The track number
     * @return self
     */
    public function setTRCKFrame(string $track): self
    {
        $frame = new TRCK($track, $this-&gt;encoding);
        $this-&gt;frames[&apos;TRCK&apos;] = [$frame];
        return $this;
    }
    /**
     * Returns the movement number frame (MVIN).
     *
     * @return MVIN|null The movement number frame, or null if not available
     */
    public function getMVINFrame(): ?MVIN
    {
        $frames = $this-&gt;getFramesByIdentifier(&apos;MVIN&apos;);
        if (count($frames) === 0) {
            return null;
        }
        return $frames[0];
    }
    /**
     * Returns the unsynchronized lyric/text transcription frames (USLT).
     *
     * @return array&lt;USLT&gt; The unsynchronized lyric/text transcription frames
     */
    public function getUSLTFrames(): array
    {
        return $this-&gt;getFramesByIdentifier(&apos;USLT&apos;);
    }
    /**
     * Returns the first unsynchronized lyric/text transcription frame (USLT).
     *
     * @return USLT|null The unsynchronized lyric/text transcription frame, or null if not available
     */
    public function getUSLTFrame(): ?USLT
    {
        $frames = $this-&gt;getUSLTFrames();
        if (count($frames) === 0) {
            return null;
        }
        return $frames[0];
    }
    /**
     * Returns an unsynchronized lyric/text transcription frame with the given description.
     *
     * @param string $description The description
     * @return USLT|null The unsynchronized lyric/text transcription frame, or null if not available
     */
    public function getUSLTFrameByDescription(string $description): ?USLT
    {
        $frames = $this-&gt;getUSLTFrames();
        return array_find($frames, fn($frame) =&gt; $frame-&gt;getDescription() === $description);
    }
    /**
     * Returns the synchronized lyric/text frames (SYLT).
     *
     * @return array&lt;SYLT&gt; The synchronized lyric/text frames
     */
    public function getSYLTFrames(): array
    {
        return $this-&gt;getFramesByIdentifier(&apos;SYLT&apos;);
    }
    /**
     * Returns the first synchronized lyric/text frame (SYLT).
     *
     * @return SYLT|null The synchronized lyric/text frame, or null if not available
     */
    public function getSYLTFrame(): ?SYLT
    {
        $frames = $this-&gt;getSYLTFrames();
        if (count($frames) === 0) {
            return null;
        }
        return $frames[0];
    }
    /**
     * Returns a synchronized lyric/text frame with the given description.
     *
     * @param string $description The description
     * @return SYLT|null The synchronized lyric/text frame, or null if not available
     */
    public function getSYLTFrameByDescription(string $description): ?SYLT
    {
        $frames = $this-&gt;getSYLTFrames();
        return array_find($frames, fn($frame) =&gt; $frame-&gt;getDescription() === $description);
    }
    /**
     * Returns the popularimeter frames (POPM).
     *
     * @return array&lt;POPM&gt; The popularimeter frames
     */
    public function getPOPMFrames(): array
    {
        return $this-&gt;getFramesByIdentifier(&apos;POPM&apos;);
    }
    /**
     * Returns the first popularimeter frame (POPM).
     *
     * @return POPM|null The popularimeter frame, or null if not available
     */
    public function getPOPMFrame(): ?POPM
    {
        $frames = $this-&gt;getPOPMFrames();
        if (count($frames) === 0) {
            return null;
        }
        return $frames[0];
    }
    /**
     * Returns a popularimeter frame with the given email.
     *
     * @param string $email The email
     * @return POPM|null The popularimeter frame, or null if not available
     */
    public function getPOPMFrameByEmail(string $email): ?POPM
    {
        $frames = $this-&gt;getPOPMFrames();
        return array_find($frames, fn($frame) =&gt; $frame-&gt;getEmail() === $email);
    }
    /**
     * Returns the ownership frame (OWNE).
     *
     * @return OWNE|null The ownership frame, or null if not available
     */
    public function getOWNEFrame(): ?OWNE
    {
        $frames = $this-&gt;getFramesByIdentifier(&apos;OWNE&apos;);
        if (count($frames) === 0) {
            return null;
        }
        return $frames[0];
    }
    /**
     * Returns the involved people list frame (IPLS).
     *
     * @return IPLS|null The involved people list frame, or null if not available
     */
    public function getIPLSFrame(): ?IPLS
    {
        $frames = $this-&gt;getFramesByIdentifier(&apos;IPLS&apos;);
        if (count($frames) === 0) {
            return null;
        }
        return $frames[0];
    }
    /**
     * Returns the linked information frames (LINK).
     *
     * @return array&lt;LINK&gt; The linked information frames
     */
    public function getLINKFrames(): array
    {
        return $this-&gt;getFramesByIdentifier(&apos;LINK&apos;);
    }
    /**
     * Returns the first linked information frame (LINK).
     *
     * @return LINK|null The linked information frame, or null if not available
     */
    public function getLINKFrame(): ?LINK
    {
        $frames = $this-&gt;getLINKFrames();
        if (count($frames) === 0) {
            return null;
        }
        return $frames[0];
    }
    /**
     * Returns the music CD identifier frame (MCDI).
     *
     * @return MCDI|null The music CD identifier frame, or null if not available
     */
    public function getMCDIFrame(): ?MCDI
    {
        $frames = $this-&gt;getFramesByIdentifier(&apos;MCDI&apos;);
        if (count($frames) === 0) {
            return null;
        }
        return $frames[0];
    }
    /**
     * Returns the event timing codes frame (ETCO).
     *
     * @return ETCO|null The event timing codes frame, or null if not available
     */
    public function getETCOFrame(): ?ETCO
    {
        $frames = $this-&gt;getFramesByIdentifier(&apos;ETCO&apos;);
        if (count($frames) === 0) {
            return null;
        }
        return $frames[0];
    }
    /**
     * Returns the equalization frame (EQUA).
     *
     * @return EQUA|null The equalization frame, or null if not available
     */
    public function getEQUAFrame(): ?EQUA
    {
        $frames = $this-&gt;getFramesByIdentifier(&apos;EQUA&apos;);
        if (count($frames) === 0) {
            return null;
        }
        return $frames[0];
    }
    /**
     * Returns the version of the ID3v2 tag.
     *
     * @return integer
     */
    public function getVersion(): int
    {
        return $this-&gt;version;
    }
    /**
     * Writes the ID3v2 tag to the file.
     *
     * @throws Exception if the file cannot be written
     */
    public function write(): void
    {
        // Open the file for reading and writing
        $handle = fopen($this-&gt;filePath, &apos;r+b&apos;);
        if (!$handle) {
            throw new Exception(&quot;Cannot open file for writing: {$this-&gt;filePath}&quot;);
        }
        // Read the entire file content
        fseek($handle, 0, SEEK_END);
        $fileSize = ftell($handle);
        fseek($handle, 0, SEEK_SET);
        $fileContent = fread($handle, $fileSize);
        // Check if the file already has an ID3v2 tag
        $hasTag = str_starts_with($fileContent, &apos;ID3&apos;);
        $existingTagSize = 0;
        if ($hasTag) {
            // Calculate the existing tag size
            $existingTagSize = 10 + (
                    (ord($fileContent[6]) &amp; 0x7F) &lt;&lt; 21 |
                    (ord($fileContent[7]) &amp; 0x7F) &lt;&lt; 14 |
                    (ord($fileContent[8]) &amp; 0x7F) &lt;&lt; 7 |
                    (ord($fileContent[9]) &amp; 0x7F)
                );
            // Remove the existing tag
            $fileContent = substr($fileContent, $existingTagSize);
        }
        // Serialize all frames
        $framesData = &apos;&apos;;
        foreach ($this-&gt;frames as $frameId =&gt; $frames) {
            foreach ($frames as $frame) {
                if ($frame instanceof Frame) {
                    // Get the frame data
                    $frameData = $frame-&gt;toBytes();
                    // Calculate the frame size
                    $frameSize = strlen($frameData);
                    // Create the frame header (10 bytes)
                    $frameHeader = $frameId;
                    $frameHeader .= chr(($frameSize &gt;&gt; 24) &amp; 0xFF);
                    $frameHeader .= chr(($frameSize &gt;&gt; 16) &amp; 0xFF);
                    $frameHeader .= chr(($frameSize &gt;&gt; 8) &amp; 0xFF);
                    $frameHeader .= chr($frameSize &amp; 0xFF);
                    $frameHeader .= &quot;\0\0&quot;; // Flags
                    // Add the frame to the tag
                    $framesData .= $frameHeader . $frameData;
                }
            }
        }
        // Calculate the tag size (excluding the header)
        $tagSize = strlen($framesData);
        // Create the tag header (10 bytes)
        $tagHeader = &apos;ID3&apos;;
        $tagHeader .= chr($this-&gt;version); // Version
        $tagHeader .= &quot;\0&quot;; // Revision
        $tagHeader .= &quot;\0&quot;; // Flags
        // Size is stored as 7-bit bytes (the high bit is always cleared)
        $tagHeader .= chr(($tagSize &gt;&gt; 21) &amp; 0x7F);
        $tagHeader .= chr(($tagSize &gt;&gt; 14) &amp; 0x7F);
        $tagHeader .= chr(($tagSize &gt;&gt; 7) &amp; 0x7F);
        $tagHeader .= chr($tagSize &amp; 0x7F);
        // Write the tag and file content
        fseek($handle, 0, SEEK_SET);
        fwrite($handle, $tagHeader . $framesData . $fileContent);
        fclose($handle);
    }
}</file><file path="app/Modules/MediaMeta/MediaMeta.php">&lt;?php
namespace App\Modules\MediaMeta;
use App\Modules\MediaMeta\Frame\Apic;
use Exception;
use FFMpeg\FFMpeg;
use FFMpeg\FFProbe\DataMapping\StreamCollection;
use Illuminate\Support\Facades\Log;
use Illuminate\Support\Str;
/**
 * MediaMeta provides a unified interface for reading ID3 tags from audio files.
 * It supports both ID3v1 and ID3v2 formats and can extract image data from APIC tags.
 */
class MediaMeta
{
    // Image type constants
    public const IMAGE_OTHER = 0;
    public const IMAGE_FILE_ICON = 1;
    public const IMAGE_OTHER_FILE_ICON = 2;
    public const IMAGE_COVER_FRONT = 3;
    public const IMAGE_COVER_BACK = 4;
    public const IMAGE_LEAFLET = 5;
    public const IMAGE_MEDIA = 6;
    public const IMAGE_LEAD_ARTIST = 7;
    public const IMAGE_ARTIST = 8;
    public const IMAGE_CONDUCTOR = 9;
    public const IMAGE_BAND = 10;
    public const IMAGE_COMPOSER = 11;
    public const IMAGE_LYRICIST = 12;
    public const IMAGE_RECORDING_LOCATION = 13;
    public const IMAGE_DURING_RECORDING = 14;
    public const IMAGE_DURING_PERFORMANCE = 15;
    public const IMAGE_SCREEN_CAPTURE = 16;
    public const IMAGE_FISH = 17;
    public const IMAGE_ILLUSTRATION = 18;
    public const IMAGE_BAND_LOGO = 19;
    public const IMAGE_PUBLISHER_LOGO = 20;
    /**
     * @var string The path to the audio file
     */
    protected string $filePath;
    /**
     * @var Id3v1|null The ID3v1 tag reader
     */
    protected ?Id3v1 $id3v1 = null;
    /**
     * @var Id3v2|null The ID3v2 tag reader
     */
    protected ?Id3v2 $id3v2 = null;
    /**
     * @var int The preferred text encoding for ID3v2 tags
     */
    protected int $encoding = Encoding::UTF8;
    private const string LOG_TAG = &apos;MediaMeta &apos;;
    private ?FFMpeg $ffmpeg = null;
    private StreamCollection|null $streamCollection = null;
    /**
     * Create a new MediaMeta instance.
     *
     * @param string $filePath The path to the audio file
     * @param int $encoding The preferred text encoding for ID3v2 tags (default: UTF-8)
     */
    public function __construct(string $filePath, int $encoding = Encoding::UTF8)
    {
        $this-&gt;filePath = $filePath;
        $this-&gt;encoding = $encoding;
    }
    /**
     * Get the preferred text encoding for ID3v2 tags.
     *
     * @return int The encoding constant from Encoding
     */
    public function getEncoding(): int
    {
        return $this-&gt;encoding;
    }
    /**
     * Set the preferred text encoding for ID3v2 tags.
     *
     * @param int $encoding The encoding constant from Encoding
     * @return self
     */
    public function setEncoding(int $encoding): self
    {
        $this-&gt;encoding = $encoding;
        // Reset ID3v2 reader to apply new encoding
        $this-&gt;id3v2 = null;
        return $this;
    }
    /**
     * Get the ID3v1 tag reader.
     *
     * @return Id3v1 The ID3v1 tag reader, or null if the file doesn&apos;t have ID3v1 tags
     * @throws Exception
     */
    public function getID3v1(): Id3v1
    {
        $this-&gt;id3v1 = new Id3v1($this-&gt;filePath);
        return $this-&gt;id3v1;
    }
    /**
     * Get the ID3v2 tag reader.
     *
     * @return Id3v2 The ID3v2 tag reader, or null if the file doesn&apos;t have ID3v2 tags
     * @throws Exception
     */
    public function getID3v2(): Id3v2
    {
        $options = [
            &apos;encoding&apos; =&gt; $this-&gt;encoding,
        ];
        $this-&gt;id3v2 = new Id3v2($this-&gt;filePath, $options);
        return $this-&gt;id3v2;
    }
    /**
     * Get the title of the audio file.
     *
     * @return string|null The title, or null if not available
     */
    public function getTitle(): ?string
    {
        // Try ID3v2 first
        try {
            $id3v2 = $this-&gt;getID3v2();
            $frame = $id3v2-&gt;getTIT2Frame();
            if ($frame) {
                return $frame-&gt;getTitle();
            }
        } catch (Exception $e) {
            Log::debug(self::LOG_TAG . &apos;getTitle: Failed to retrieve title from ID3v2 tags&apos;, [
                &apos;error&apos;     =&gt; $e-&gt;getMessage(),
                &apos;file&apos;      =&gt; $this-&gt;filePath,
                &apos;exception&apos; =&gt; $e,
            ]);
        }
        // Fall back to ID3v1
        try {
            $id3v1 = $this-&gt;getID3v1();
            return $id3v1-&gt;getTitle();
        } catch (Exception $e) {
            Log::debug(self::LOG_TAG . &apos;getTitle: Failed to retrieve title from ID3v1 tags&apos;, [
                &apos;error&apos;     =&gt; $e-&gt;getMessage(),
                &apos;file&apos;      =&gt; $this-&gt;filePath,
                &apos;exception&apos; =&gt; $e,
            ]);
        }
        return null;
    }
    /**
     * Get the title frame of the audio file.
     *
     * @return Frame\TIT2|null The title frame, or null if not available
     */
    public function getTitleFrame(): ?Frame\TIT2
    {
        try {
            $id3v2 = $this-&gt;getID3v2();
            return $id3v2-&gt;getTIT2Frame();
        } catch (Exception $e) {
            Log::debug(self::LOG_TAG . &apos;getTitleFrame: Failed to retrieve title frame from ID3v2 tags&apos;, [
                &apos;error&apos;     =&gt; $e-&gt;getMessage(),
                &apos;file&apos;      =&gt; $this-&gt;filePath,
                &apos;exception&apos; =&gt; $e,
            ]);
        }
        return null;
    }
    /**
     * Get the track number
     *
     * @return int|null
     */
    public function getTrackNumber(): ?int
    {
        try {
            $id3v2 = $this-&gt;getID3v2();
            $track = $id3v2-&gt;getTRCKFrame()-&gt;getTrack();
            if ($track) {
                $track = preg_replace(&apos;/\/.*$/&apos;, &apos;&apos;, $track);
                return $track !== &apos;&apos; ? (int)$track : null;
            }
            return null;
        } catch (Exception $e) {
            Log::debug(self::LOG_TAG . &apos;getTrackNumber: Failed to retrieve track number from ID3v2 tags&apos;, [
                &apos;error&apos;     =&gt; $e-&gt;getMessage(),
                &apos;file&apos;      =&gt; $this-&gt;filePath,
                &apos;exception&apos; =&gt; $e,
            ]);
        }
        // Fallback to id3v1
        try {
            $this-&gt;getID3v1();
            return $this-&gt;getID3v1()-&gt;getTrack();
        } catch (Exception $e) {
            Log::debug(self::LOG_TAG . &apos;getTrackNumber: Failed to retrieve track number from ID3v1 tags&apos;, [
                &apos;error&apos;     =&gt; $e-&gt;getMessage(),
                &apos;file&apos;      =&gt; $this-&gt;filePath,
                &apos;exception&apos; =&gt; $e,
            ]);
        }
        return null;
    }
    /**
     * Get the artist of the audio file.
     *
     * @return array|string|null The artist(s), or null if not available
     */
    public function getArtist(): array|string|null
    {
        // Try ID3v2 first
        try {
            $id3v2 = $this-&gt;getID3v2();
            $frame = $id3v2-&gt;getTpe1Frame();
            if ($frame) {
                return $frame-&gt;getArtists();
            }
        } catch (Exception $e) {
            Log::debug(self::LOG_TAG . &apos;getArtist: Failed to retrieve artist from ID3v2 tags&apos;, [
                &apos;error&apos;     =&gt; $e-&gt;getMessage(),
                &apos;file&apos;      =&gt; $this-&gt;filePath,
                &apos;exception&apos; =&gt; $e,
            ]);
        }
        // Fall back to ID3v1
        try {
            $id3v1 = $this-&gt;getID3v1();
            return $id3v1-&gt;getArtist();
        } catch (Exception $e) {
            Log::debug(self::LOG_TAG . &apos;getArtist: Failed to retrieve artist from ID3v1 tags&apos;, [
                &apos;error&apos;     =&gt; $e-&gt;getMessage(),
                &apos;file&apos;      =&gt; $this-&gt;filePath,
                &apos;exception&apos; =&gt; $e,
            ]);
        }
        return null;
    }
    /**
     * Get the artist frame of the audio file.
     *
     * @return Frame\TPE1|null The artist frame, or null if not available
     */
    public function getArtistFrame(): ?Frame\TPE1
    {
        try {
            $id3v2 = $this-&gt;getID3v2();
            return $id3v2-&gt;getTPE1Frame();
        } catch (Exception $e) {
            Log::debug(self::LOG_TAG . &apos;getArtistFrame: Failed to retrieve artist frame from ID3v2 tags&apos;, [
                &apos;error&apos;     =&gt; $e-&gt;getMessage(),
                &apos;file&apos;      =&gt; $this-&gt;filePath,
                &apos;exception&apos; =&gt; $e,
            ]);
        }
        return null;
    }
    /**
     * Get the artists of the audio file as an array.
     *
     * @return array&lt;string&gt; The artists, or an empty array if not available
     */
    public function getArtists(): array
    {
        $frame = $this-&gt;getArtistFrame();
        if ($frame) {
            return $frame-&gt;getArtists();
        }
        $artist = $this-&gt;getArtist();
        if ($artist) {
            return [$artist];
        }
        return [];
    }
    /**
     * Get the album of the audio file.
     *
     * @return string|null The album, or null if not available
     */
    public function getAlbum(): ?string
    {
        // Try ID3v2 first
        try {
            $id3v2 = $this-&gt;getID3v2();
            $frame = $id3v2-&gt;getTALBFrame();
            if ($frame) {
                return $frame-&gt;getAlbum();
            }
        } catch (Exception $e) {
            Log::debug(self::LOG_TAG . &apos;getAlbum: Failed to retrieve album from ID3v2 tags&apos;, [
                &apos;error&apos;     =&gt; $e-&gt;getMessage(),
                &apos;file&apos;      =&gt; $this-&gt;filePath,
                &apos;exception&apos; =&gt; $e,
            ]);
        }
        // Fall back to ID3v1
        try {
            $id3v1 = $this-&gt;getID3v1();
            return $id3v1-&gt;getAlbum();
        } catch (Exception $e) {
            Log::error(self::LOG_TAG . &apos;getAlbum: Failed to retrieve album from ID3v1 tags&apos;, [
                &apos;error&apos;     =&gt; $e-&gt;getMessage(),
                &apos;file&apos;      =&gt; $this-&gt;filePath,
                &apos;exception&apos; =&gt; $e,
            ]);
        }
        return null;
    }
    /**
     * Get the album frame of the audio file.
     *
     * @return Frame\TALB|null The album frame, or null if not available
     */
    public function getAlbumFrame(): ?Frame\TALB
    {
        try {
            $id3v2 = $this-&gt;getID3v2();
            return $id3v2-&gt;getTALBFrame();
        } catch (Exception $e) {
            Log::debug(self::LOG_TAG . &apos;getAlbumFrame: Failed to retrieve album frame from ID3v2 tags&apos;, [
                &apos;error&apos;     =&gt; $e-&gt;getMessage(),
                &apos;file&apos;      =&gt; $this-&gt;filePath,
                &apos;exception&apos; =&gt; $e,
            ]);
        }
        return null;
    }
    /**
     * Get the genre of the audio file.
     *
     * @return string|null The genre, or null if not available
     */
    public function getGenre(): ?string
    {
        // Try ID3v2 first
        try {
            $id3v2 = $this-&gt;getID3v2();
            $frame = $id3v2-&gt;getTCONFrame();
            if ($frame) {
                return $frame-&gt;getGenre();
            }
        } catch (Exception $e) {
            Log::debug(self::LOG_TAG . &apos;getGenre: Failed to retrieve genre from ID3v2 tags&apos;, [
                &apos;error&apos;     =&gt; $e-&gt;getMessage(),
                &apos;file&apos;      =&gt; $this-&gt;filePath,
                &apos;exception&apos; =&gt; $e,
            ]);
        }
        // Fall back to ID3v1
        try {
            $id3v1 = $this-&gt;getID3v1();
            return $id3v1-&gt;getGenre();
        } catch (Exception $e) {
            Log::debug(self::LOG_TAG . &apos;getGenre: Failed to retrieve genre from ID3v1 tags&apos;, [
                &apos;error&apos;     =&gt; $e-&gt;getMessage(),
                &apos;file&apos;      =&gt; $this-&gt;filePath,
                &apos;exception&apos; =&gt; $e,
            ]);
        }
        return null;
    }
    /**
     * Get the genre frame of the audio file.
     *
     * @return Frame\TCON|null The genre frame, or null if not available
     */
    public function getGenreFrame(): ?Frame\TCON
    {
        try {
            $id3v2 = $this-&gt;getID3v2();
            return $id3v2-&gt;getTCONFrame();
        } catch (Exception $e) {
            Log::debug(self::LOG_TAG . &apos;getGenreFrame: Failed to retrieve genre frame from ID3v2 tags&apos;, [
                &apos;error&apos;     =&gt; $e-&gt;getMessage(),
                &apos;file&apos;      =&gt; $this-&gt;filePath,
                &apos;exception&apos; =&gt; $e,
            ]);
        }
        return null;
    }
    /**
     * Get the year of the audio file.
     *
     * @return string|null The year, or null if not available
     */
    public function getYear(): ?string
    {
        // Try ID3v2 first
        try {
            $id3v2 = $this-&gt;getID3v2();
            $frame = $id3v2-&gt;getTYERFrame();
            if ($frame) {
                return $frame-&gt;getYear();
            }
        } catch (Exception $e) {
            Log::debug(self::LOG_TAG . &apos;getYear: Failed to retrieve year from ID3v2 tags&apos;, [
                &apos;error&apos;     =&gt; $e-&gt;getMessage(),
                &apos;file&apos;      =&gt; $this-&gt;filePath,
                &apos;exception&apos; =&gt; $e,
            ]);
        }
        // Fall back to ID3v1
        try {
            $id3v1 = $this-&gt;getID3v1();
            return $id3v1-&gt;getYear();
        } catch (Exception $e) {
            Log::debug(self::LOG_TAG . &apos;getYear: Failed to retrieve year from ID3v1 tags&apos;, [
                &apos;error&apos;     =&gt; $e-&gt;getMessage(),
                &apos;file&apos;      =&gt; $this-&gt;filePath,
                &apos;exception&apos; =&gt; $e,
            ]);
        }
        return null;
    }
    /**
     * Get the year frame of the audio file.
     *
     * @return Frame\TYER|null The year frame, or null if not available
     */
    public function getYearFrame(): ?Frame\TYER
    {
        try {
            $id3v2 = $this-&gt;getID3v2();
            return $id3v2-&gt;getTYERFrame();
        } catch (Exception $e) {
            Log::debug(self::LOG_TAG . &apos;getYearFrame: Failed to retrieve year frame from ID3v2 tags&apos;, [
                &apos;error&apos;     =&gt; $e-&gt;getMessage(),
                &apos;file&apos;      =&gt; $this-&gt;filePath,
                &apos;exception&apos; =&gt; $e,
            ]);
        }
        return null;
    }
    /**
     * Get the comments of the audio file.
     *
     * @return array&lt;Frame\COMM&gt; The comment frames, or an empty array if not available
     */
    public function getComments(): array
    {
        try {
            $id3v2 = $this-&gt;getID3v2();
            return $id3v2-&gt;getCOMMFrames();
        } catch (Exception $e) {
            Log::debug(self::LOG_TAG . &apos;getComments: Failed to retrieve comment frames from ID3v2 tags&apos;, [
                &apos;error&apos;     =&gt; $e-&gt;getMessage(),
                &apos;file&apos;      =&gt; $this-&gt;filePath,
                &apos;exception&apos; =&gt; $e,
            ]);
        }
        return [];
    }
    /**
     * Get the first comment of the audio file.
     *
     * @return string|null The comment text, or null if not available
     */
    public function getComment(): ?string
    {
        $frame = $this-&gt;getCommentFrame();
        if ($frame) {
            return $frame-&gt;getText();
        }
        // Fall back to ID3v1
        try {
            $id3v1 = $this-&gt;getID3v1();
            return $id3v1-&gt;getComment();
        } catch (Exception $e) {
            Log::debug(self::LOG_TAG . &apos;getComment: Failed to retrieve comment from ID3v1 tags&apos;, [
                &apos;error&apos;     =&gt; $e-&gt;getMessage(),
                &apos;file&apos;      =&gt; $this-&gt;filePath,
                &apos;exception&apos; =&gt; $e,
            ]);
        }
        return null;
    }
    /**
     * Get the first comment frame of the audio file.
     *
     * @return Frame\COMM|null The comment frame, or null if not available
     */
    public function getCommentFrame(): ?Frame\COMM
    {
        try {
            $id3v2 = $this-&gt;getID3v2();
            return $id3v2-&gt;getCOMMFrame();
        } catch (Exception $e) {
            Log::debug(self::LOG_TAG . &apos;getCommentFrame: Failed to retrieve comment frame from ID3v2 tags&apos;, [
                &apos;error&apos;     =&gt; $e-&gt;getMessage(),
                &apos;file&apos;      =&gt; $this-&gt;filePath,
                &apos;exception&apos; =&gt; $e,
            ]);
        }
        return null;
    }
    /**
     * Get a comment frame with the given description.
     *
     * @param string $description The description
     * @return Frame\COMM|null The comment frame, or null if not available
     */
    public function getCommentFrameByDescription(string $description): ?Frame\COMM
    {
        try {
            $id3v2 = $this-&gt;getID3v2();
            return $id3v2-&gt;getCOMMFrameByDescription($description);
        } catch (Exception $e) {
            Log::debug(self::LOG_TAG . &apos;getCommentFrameByDescription: Failed to retrieve comment frame by description from ID3v2 tags&apos;, [
                &apos;error&apos;       =&gt; $e-&gt;getMessage(),
                &apos;file&apos;        =&gt; $this-&gt;filePath,
                &apos;description&apos; =&gt; $description,
                &apos;exception&apos;   =&gt; $e,
            ]);
        }
        return null;
    }
    /**
     * Get all APIC frames (images) from the audio file.
     *
     * @return array&lt;Apic&gt; An array of APIC frames, or an empty array if none are available
     */
    public function getImages(): array
    {
        $images = [];
        try {
            $id3v2 = $this-&gt;getID3v2();
            $frames = $id3v2-&gt;getFramesByIdentifier(&apos;APIC&apos;);
            if (count($frames) &gt; 0) {
                $images = $frames;
            }
        } catch (Exception $e) {
            Log::debug(self::LOG_TAG . &apos;getImages: Failed to retrieve image frames from ID3v2 tags&apos;, [
                &apos;error&apos;     =&gt; $e-&gt;getMessage(),
                &apos;file&apos;      =&gt; $this-&gt;filePath,
                &apos;exception&apos; =&gt; $e,
            ]);
        }
        return $images;
    }
    /**
     * Get APIC frames (images) of a specific type from the audio file.
     *
     * @param int $imageType The image type (use the IMAGE_* constants)
     * @return array&lt;Apic&gt; An array of APIC frames of the specified type, or an empty array if none are available
     */
    public function getImagesByType(int $imageType): array
    {
        $images = [];
        $allImages = $this-&gt;getImages();
        foreach ($allImages as $image) {
            if ($image-&gt;getImageType() === $imageType) {
                $images[] = $image;
            }
        }
        return $images;
    }
    /**
     * Get the first APIC frame (image) of a specific type from the audio file.
     *
     * @param int $imageType The image type (use the IMAGE_* constants)
     * @return Apic|null The first APIC frame of the specified type, or null if not available
     */
    public function getImageByType(int $imageType): ?Apic
    {
        $images = $this-&gt;getImagesByType($imageType);
        return count($images) &gt; 0 ? $images[0] : null;
    }
    /**
     * Get the first APIC frame (image) from the audio file.
     *
     * @return Apic|null The first APIC frame, or null if not available
     */
    public function getImage(): ?Apic
    {
        $images = $this-&gt;getImages();
        return count($images) &gt; 0 ? $images[0] : null;
    }
    /**
     * Get the front cover image from the audio file.
     *
     * @return Apic|null The front cover image, or null if not available
     */
    public function getFrontCoverImage(): ?Apic
    {
        return $this-&gt;getImageByType(self::IMAGE_COVER_FRONT);
    }
    /**
     * Get the back cover image from the audio file.
     *
     * @return Apic|null The back cover image, or null if not available
     */
    public function getBackCoverImage(): ?Apic
    {
        return $this-&gt;getImageByType(self::IMAGE_COVER_BACK);
    }
    /**
     * Get the artist image from the audio file.
     *
     * @return Apic|null The artist image, or null if not available
     */
    public function getArtistImage(): ?Apic
    {
        return $this-&gt;getImageByType(self::IMAGE_ARTIST);
    }
    /**
     * Get the image data from the first APIC frame.
     *
     * @return string|null The image data, or null if not available
     */
    public function getImageData(): ?string
    {
        $image = $this-&gt;getImage();
        return $image?-&gt;getImageData();
    }
    /**
     * Get the image data from a specific type of APIC frame.
     *
     * @param int $imageType The image type (use the IMAGE_* constants)
     * @return string|null The image data, or null if not available
     */
    public function getImageDataByType(int $imageType): ?string
    {
        $image = $this-&gt;getImageByType($imageType);
        return $image?-&gt;getImageData();
    }
    /**
     * Get the front cover image data from the audio file.
     *
     * @return string|null The front cover image data, or null if not available
     */
    public function getFrontCoverImageData(): ?string
    {
        return $this-&gt;getImageDataByType(self::IMAGE_COVER_FRONT);
    }
    /**
     * Get the MIME type of the first APIC frame.
     *
     * @return string|null The MIME type, or null if not available
     */
    public function getImageMimeType(): ?string
    {
        $image = $this-&gt;getImage();
        return $image?-&gt;getMimeType();
    }
    /**
     * Get the MIME type of a specific type of APIC frame.
     *
     * @param int $imageType The image type (use the IMAGE_* constants)
     * @return string|null The MIME type, or null if not available
     */
    public function getImageMimeTypeByType(int $imageType): ?string
    {
        $image = $this-&gt;getImageByType($imageType);
        return $image?-&gt;getMimeType();
    }
    /**
     * Get the image type of the first APIC frame.
     *
     * @return int|null The image type, or null if not available
     */
    public function getImageType(): ?int
    {
        $image = $this-&gt;getImage();
        return $image?-&gt;getImageType();
    }
    /**
     * Get the image description of the first APIC frame.
     *
     * @return string|null The image description, or null if not available
     */
    public function getImageDescription(): ?string
    {
        $image = $this-&gt;getImage();
        return $image?-&gt;getDescription();
    }
    /**
     * Get the image description of a specific type of APIC frame.
     *
     * @param int $imageType The image type (use the IMAGE_* constants)
     * @return string|null The image description, or null if not available
     */
    public function getImageDescriptionByType(int $imageType): ?string
    {
        $image = $this-&gt;getImageByType($imageType);
        return $image?-&gt;getDescription();
    }
    public function isAudioFile(): bool
    {
        return Str::startsWith($this-&gt;getMimeType(), &apos;audio/&apos;);
    }
    public function getMimeType(): string
    {
        return new \finfo(FILEINFO_MIME_TYPE)-&gt;file($this-&gt;filePath);
    }
    public function probeLength()
    {
        $stream = $this-&gt;getStreams()-&gt;first();
        if (!$stream) {
            return 0;
        }
        return (float)$stream-&gt;get(&apos;duration&apos;);
    }
    private function getStreams()
    {
        if (!$this-&gt;ffmpeg) {
            $this-&gt;ffmpeg = FFMpeg::create();
        }
        if ($this-&gt;streamCollection === null) {
            $this-&gt;streamCollection = $this-&gt;ffmpeg-&gt;getFFProbe()-&gt;streams($this-&gt;filePath);
        }
        return $this-&gt;streamCollection;
    }
}</file><file path="app/Modules/MediaMeta/MediaMetaTest.php">&lt;?php
namespace App\Modules\MediaMeta;
/**
 * Simple test script for the MediaMeta class.
 * 
 * Usage: php MediaMetaTest.php &lt;path_to_audio_file&gt;
 */
require_once __DIR__ . &apos;/../../../vendor/autoload.php&apos;;
// Check if a file path was provided
if ($argc &lt; 2) {
    echo &quot;Usage: php MediaMetaTest.php &lt;path_to_audio_file&gt;\n&quot;;
    exit(1);
}
$filePath = $argv[1];
// Check if the file exists
if (!file_exists($filePath)) {
    echo &quot;Error: File not found: $filePath\n&quot;;
    exit(1);
}
try {
    // Create a MediaMeta instance
    $mediaMeta = new MediaMeta($filePath);
    // Display basic metadata
    echo &quot;File: $filePath\n&quot;;
    echo &quot;Title: &quot; . ($mediaMeta-&gt;getTitle() ?? &apos;N/A&apos;) . &quot;\n&quot;;
    echo &quot;Artist: &quot; . ($mediaMeta-&gt;getArtist() ?? &apos;N/A&apos;) . &quot;\n&quot;;
    echo &quot;Album: &quot; . ($mediaMeta-&gt;getAlbum() ?? &apos;N/A&apos;) . &quot;\n&quot;;
    echo &quot;Genre: &quot; . ($mediaMeta-&gt;getGenre() ?? &apos;N/A&apos;) . &quot;\n&quot;;
    echo &quot;Year: &quot; . ($mediaMeta-&gt;getYear() ?? &apos;N/A&apos;) . &quot;\n&quot;;
    echo &quot;Comment: &quot; . ($mediaMeta-&gt;getComment() ?? &apos;N/A&apos;) . &quot;\n&quot;;
    // Display artists as array
    $artists = $mediaMeta-&gt;getArtists();
    if (count($artists) &gt; 0) {
        echo &quot;\nArtists:\n&quot;;
        foreach ($artists as $index =&gt; $artist) {
            echo &quot;[$index] $artist\n&quot;;
        }
    }
    // Display comments
    $comments = $mediaMeta-&gt;getComments();
    if (count($comments) &gt; 0) {
        echo &quot;\nComments:\n&quot;;
        foreach ($comments as $index =&gt; $comment) {
            echo &quot;[$index] Language: &quot; . $comment-&gt;getLanguage() . &quot;\n&quot;;
            echo &quot;     Description: &quot; . $comment-&gt;getDescription() . &quot;\n&quot;;
            echo &quot;     Text: &quot; . $comment-&gt;getText() . &quot;\n&quot;;
        }
    }
    // Display image information
    $images = $mediaMeta-&gt;getImages();
    echo &quot;\nImages found: &quot; . count($images) . &quot;\n&quot;;
    if (count($images) &gt; 0) {
        echo &quot;\nImage Types:\n&quot;;
        foreach ($images as $index =&gt; $image) {
            $type = $image-&gt;getImageType();
            $typeName = isset(Apic::$types[$type]) 
                ? Apic::$types[$type] 
                : &quot;Unknown ($type)&quot;;
            echo &quot;[$index] Type: $typeName\n&quot;;
            echo &quot;     MIME: &quot; . $image-&gt;getMimeType() . &quot;\n&quot;;
            echo &quot;     Size: &quot; . strlen($image-&gt;getImageData()) . &quot; bytes\n&quot;;
            echo &quot;     Description: &quot; . $image-&gt;getDescription() . &quot;\n&quot;;
        }
        // Check for front cover specifically
        $frontCover = $mediaMeta-&gt;getFrontCoverImage();
        if ($frontCover) {
            echo &quot;\nFront Cover Found:\n&quot;;
            echo &quot;MIME: &quot; . $frontCover-&gt;getMimeType() . &quot;\n&quot;;
            echo &quot;Size: &quot; . strlen($frontCover-&gt;getImageData()) . &quot; bytes\n&quot;;
            // Save the front cover to a file
            $extension = $frontCover-&gt;getMimeType() === &apos;image/jpeg&apos; ? &apos;jpg&apos; : 
                        ($frontCover-&gt;getMimeType() === &apos;image/png&apos; ? &apos;png&apos; : &apos;img&apos;);
            $outputFile = __DIR__ . &apos;/front_cover.&apos; . $extension;
            file_put_contents($outputFile, $frontCover-&gt;getImageData());
            echo &quot;Front cover saved to: $outputFile\n&quot;;
        } else {
            echo &quot;\nNo front cover found.\n&quot;;
        }
    }
    // Test different encodings
    echo &quot;\nTesting different encodings:\n&quot;;
    // UTF-8
    $mediaMeta-&gt;setEncoding(Encoding::UTF8);
    echo &quot;UTF-8 Title: &quot; . ($mediaMeta-&gt;getTitle() ?? &apos;N/A&apos;) . &quot;\n&quot;;
    // UTF-16
    $mediaMeta-&gt;setEncoding(Encoding::UTF16);
    echo &quot;UTF-16 Title: &quot; . ($mediaMeta-&gt;getTitle() ?? &apos;N/A&apos;) . &quot;\n&quot;;
    // UTF-16LE
    $mediaMeta-&gt;setEncoding(Encoding::UTF16LE);
    echo &quot;UTF-16LE Title: &quot; . ($mediaMeta-&gt;getTitle() ?? &apos;N/A&apos;) . &quot;\n&quot;;
    // ISO-8859-1
    $mediaMeta-&gt;setEncoding(Encoding::ISO88591);
    echo &quot;ISO-8859-1 Title: &quot; . ($mediaMeta-&gt;getTitle() ?? &apos;N/A&apos;) . &quot;\n&quot;;
    echo &quot;\nTest completed successfully.\n&quot;;
} catch (\Exception $e) {
    echo &quot;Error: &quot; . $e-&gt;getMessage() . &quot;\n&quot;;
    exit(1);
}</file><file path="app/Modules/MediaMeta/README.md"># MediaMeta

MediaMeta provides a unified interface for reading ID3 tags from audio files. It supports both ID3v1 and ID3v2 formats and can extract image data from APIC tags.

## Features

- Read ID3v1 and ID3v2 tags from audio files
- Extract common metadata (title, artist, album, genre, year, comments)
- Extract image data from APIC tags
- Support for different image types (front cover, back cover, artist, etc.)
- Support for different character encodings (UTF-8, UTF-16, UTF-16LE, ISO-8859-1)
- Support for multiple artists and comments
- Direct access to frame objects for advanced usage

## Usage

### Basic Usage

```php
// Create a MediaMeta instance
$mediaMeta = new MediaMeta(&apos;/path/to/audio/file.mp3&apos;);

// Get basic metadata
$title = $mediaMeta-&gt;getTitle();
$artist = $mediaMeta-&gt;getArtist();
$album = $mediaMeta-&gt;getAlbum();
$genre = $mediaMeta-&gt;getGenre();
$year = $mediaMeta-&gt;getYear();
$comment = $mediaMeta-&gt;getComment();

// Get multiple artists
$artists = $mediaMeta-&gt;getArtists();
foreach ($artists as $artist) {
    echo &quot;Artist: $artist\n&quot;;
}

// Get multiple comments
$comments = $mediaMeta-&gt;getComments();
foreach ($comments as $comment) {
    echo &quot;Comment: &quot; . $comment-&gt;getText() . &quot;\n&quot;;
    echo &quot;Language: &quot; . $comment-&gt;getLanguage() . &quot;\n&quot;;
    echo &quot;Description: &quot; . $comment-&gt;getDescription() . &quot;\n&quot;;
}

// Get the front cover image
$frontCover = $mediaMeta-&gt;getFrontCoverImage();
if ($frontCover) {
    $imageData = $frontCover-&gt;getImageData();
    $mimeType = $frontCover-&gt;getMimeType();
    $description = $frontCover-&gt;getDescription();

    // Save the image to a file
    file_put_contents(&apos;cover.jpg&apos;, $imageData);
}
```

### Working with Different Image Types

```php
// Get all images
$images = $mediaMeta-&gt;getImages();

// Get images of a specific type
$frontCovers = $mediaMeta-&gt;getImagesByType(MediaMeta::IMAGE_COVER_FRONT);
$backCovers = $mediaMeta-&gt;getImagesByType(MediaMeta::IMAGE_COVER_BACK);
$artistImages = $mediaMeta-&gt;getImagesByType(MediaMeta::IMAGE_ARTIST);

// Get the first image of a specific type
$frontCover = $mediaMeta-&gt;getImageByType(MediaMeta::IMAGE_COVER_FRONT);
$backCover = $mediaMeta-&gt;getImageByType(MediaMeta::IMAGE_COVER_BACK);
$artistImage = $mediaMeta-&gt;getImageByType(MediaMeta::IMAGE_ARTIST);

// Convenience methods for common image types
$frontCover = $mediaMeta-&gt;getFrontCoverImage();
$backCover = $mediaMeta-&gt;getBackCoverImage();
$artistImage = $mediaMeta-&gt;getArtistImage();

// Get image data directly
$frontCoverData = $mediaMeta-&gt;getFrontCoverImageData();
$imageDataByType = $mediaMeta-&gt;getImageDataByType(MediaMeta::IMAGE_COVER_FRONT);
```

### Working with Different Character Encodings

```php
// Create a MediaMeta instance with a specific encoding
$mediaMeta = new MediaMeta(&apos;/path/to/audio/file.mp3&apos;, Encoding::UTF8);

// Change the encoding
$mediaMeta-&gt;setEncoding(Encoding::UTF16);
$mediaMeta-&gt;setEncoding(Encoding::UTF16LE);
$mediaMeta-&gt;setEncoding(Encoding::ISO88591);

// Get the current encoding
$encoding = $mediaMeta-&gt;getEncoding();
```

### Working with Frame Objects Directly

```php
// Get frame objects directly
$titleFrame = $mediaMeta-&gt;getTitleFrame();
$artistFrame = $mediaMeta-&gt;getArtistFrame();
$albumFrame = $mediaMeta-&gt;getAlbumFrame();
$genreFrame = $mediaMeta-&gt;getGenreFrame();
$yearFrame = $mediaMeta-&gt;getYearFrame();
$commentFrame = $mediaMeta-&gt;getCommentFrame();

// Work with frame objects
if ($titleFrame) {
    echo &quot;Title: &quot; . $titleFrame-&gt;getTitle() . &quot;\n&quot;;
    $titleFrame-&gt;setTitle(&quot;New Title&quot;);
}

if ($artistFrame) {
    echo &quot;Artist: &quot; . $artistFrame-&gt;getArtist() . &quot;\n&quot;;
    $artistFrame-&gt;setArtist(&quot;New Artist&quot;);

    // Work with multiple artists
    $artists = $artistFrame-&gt;getArtists();
    $artistFrame-&gt;setArtists([&quot;Artist 1&quot;, &quot;Artist 2&quot;]);
}

if ($commentFrame) {
    echo &quot;Comment: &quot; . $commentFrame-&gt;getText() . &quot;\n&quot;;
    echo &quot;Language: &quot; . $commentFrame-&gt;getLanguage() . &quot;\n&quot;;
    echo &quot;Description: &quot; . $commentFrame-&gt;getDescription() . &quot;\n&quot;;

    $commentFrame-&gt;setText(&quot;New Comment&quot;);
    $commentFrame-&gt;setLanguage(&quot;eng&quot;);
    $commentFrame-&gt;setDescription(&quot;New Description&quot;);
}

// Get a specific comment by description
$commentFrame = $mediaMeta-&gt;getCommentFrameByDescription(&quot;Lyrics&quot;);
if ($commentFrame) {
    echo &quot;Lyrics: &quot; . $commentFrame-&gt;getText() . &quot;\n&quot;;
}
```

## Testing

A test script is provided to verify that the `MediaMeta` class works correctly with various audio files:

```bash
php app/Modules/MediaMeta/MediaMetaTest.php /path/to/audio/file.mp3
```

The test script will display basic metadata, list all images found in the file, and test different character encodings.

## Image Types

The following image types are supported:

- `MediaMeta::IMAGE_OTHER` (0): Other
- `MediaMeta::IMAGE_FILE_ICON` (1): 32x32 pixels file icon (PNG only)
- `MediaMeta::IMAGE_OTHER_FILE_ICON` (2): Other file icon
- `MediaMeta::IMAGE_COVER_FRONT` (3): Cover (front)
- `MediaMeta::IMAGE_COVER_BACK` (4): Cover (back)
- `MediaMeta::IMAGE_LEAFLET` (5): Leaflet page
- `MediaMeta::IMAGE_MEDIA` (6): Media (e.g. label side of CD)
- `MediaMeta::IMAGE_LEAD_ARTIST` (7): Lead artist/lead performer/soloist
- `MediaMeta::IMAGE_ARTIST` (8): Artist/performer
- `MediaMeta::IMAGE_CONDUCTOR` (9): Conductor
- `MediaMeta::IMAGE_BAND` (10): Band/Orchestra
- `MediaMeta::IMAGE_COMPOSER` (11): Composer
- `MediaMeta::IMAGE_LYRICIST` (12): Lyricist/text writer
- `MediaMeta::IMAGE_RECORDING_LOCATION` (13): Recording Location
- `MediaMeta::IMAGE_DURING_RECORDING` (14): During recording
- `MediaMeta::IMAGE_DURING_PERFORMANCE` (15): During performance
- `MediaMeta::IMAGE_SCREEN_CAPTURE` (16): Movie/video screen capture
- `MediaMeta::IMAGE_FISH` (17): A bright coloured fish
- `MediaMeta::IMAGE_ILLUSTRATION` (18): Illustration
- `MediaMeta::IMAGE_BAND_LOGO` (19): Band/artist logotype
- `MediaMeta::IMAGE_PUBLISHER_LOGO` (20): Publisher/Studio logotype</file><file path="app/Modules/Nanoid/Concerns/HasNanoPublicId.php">&lt;?php
namespace App\Modules\Nanoid\Concerns;
use App\Modules\Nanoid\NanoId;
trait HasNanoPublicId
{
    public static function bootHasNanoPublicId()
    {
        static::creating(function ($model) {
            $model-&gt;public_id = NanoId::generateId();
        });
    }
}</file><file path="app/Modules/Nanoid/NanoId.php">&lt;?php
namespace App\Modules\Nanoid;
use Illuminate\Support\Facades\Facade;
class NanoId extends Facade
{
    protected static function getFacadeAccessor()
    {
        return NanoIdService::class;
    }
}</file><file path="app/Modules/Nanoid/NanoIdServiceProvider.php">&lt;?php
namespace App\Modules\Nanoid;
use Illuminate\Support\ServiceProvider;
class NanoIdServiceProvider extends ServiceProvider
{
    public function boot()
    {
        $this-&gt;app-&gt;singleton(NanoIdService::class, NanoIdService::class);
    }
}</file><file path="app/Modules/OpenApi/Concerns/CastsDtoToSchema.php">&lt;?php
namespace App\Modules\OpenApi\Concerns;
use Closure;
use Dedoc\Scramble\Support\Generator\{Parameter, Schema};
use Dedoc\Scramble\Support\OperationExtensions\RulesExtractor\RulesToParameters;
use Illuminate\Validation\NestedRules;
use Laravel\SerializableClosure\Support\ReflectionClosure;
use ReflectionClass;
use ReflectionException;
use ReflectionObject;
use Spatie\LaravelData\Attributes\DataCollectionOf;
use Spatie\LaravelData\Data;
use Spatie\LaravelData\Support\DataProperty;
trait CastsDtoToSchema
{
    public function schemaFromDto(string $className): Schema
    {
        if (!class_exists($className) || !is_a($className, Data::class, true)) {
            throw new \Exception(&quot;$className is not a valid Data object&quot;);
        }
        return Schema::createFromParameters($this-&gt;parametersFromDto($className));
    }
    /**
     * @return Parameter[]
     *
     * @throws \ReflectionException
     */
    public function parametersFromDto(string $className): array
    {
        return (new RulesToParameters($this-&gt;rulesFromDto($className), [], $this-&gt;openApiTransformer))-&gt;handle();
    }
    /**
     * @return array&lt;string, mixed&gt;
     *
     * @throws \ReflectionException
     */
    public function rulesFromDto(string $className): array
    {
        return $this-&gt;unwrapRules($this-&gt;rulesFromDtoNoRecursion($className));
    }
    /**
     * @return array&lt;string, mixed&gt;
     *
     * @throws \ReflectionException
     */
    public function rulesFromDtoNoRecursion(string $className): array
    {
        if (!class_exists($className) || !is_a($className, Data::class, true)) {
            throw new \Exception(&quot;$className is not a valid Data object&quot;);
        }
        $dataObject = (new ReflectionClass($className))-&gt;newInstanceWithoutConstructor();
        return $dataObject-&gt;getValidationRules([]);
    }
    /**
     * @param array&lt;string, mixed&gt; $rules
     * @return array&lt;string, mixed&gt;
     *
     * @throws ReflectionException
     */
    protected function unwrapRules(array $rules): array
    {
        foreach ($rules as $key =&gt; $rule) {
            if (!$rule instanceof NestedRules) {
                continue;
            }
            unset($rules[$key]);
            return $this-&gt;unwrapRules([
                ...$rules,
                ...$this-&gt;expandRules($rule, $key),
            ]);
        }
        return $rules;
    }
    /**
     * @return array&lt;string, mixed&gt;
     *
     * @throws \ReflectionException
     */
    protected function expandRules(NestedRules $rule, string $parentKey = &apos;&apos;): array
    {
        $closure = (new ReflectionObject($rule))-&gt;getProperty(&apos;callback&apos;)-&gt;getValue($rule);
        if (!$closure instanceof Closure) {
            return [];
        }
        $useVariables = (new ReflectionClosure($closure))-&gt;getUseVariables();
        if (!(($prop = ($useVariables[&apos;dataProperty&apos;] ?? null)) instanceof DataProperty)) {
            return [];
        }
        $attribute = $prop-&gt;attributes
            -&gt;filter(fn($attribute) =&gt; is_a($attribute-&gt;class, DataCollectionOf::class, true))
            -&gt;first();
        $rules = $this-&gt;rulesFromDtoNoRecursion($attribute-&gt;class);
        foreach ($rules as $key =&gt; $rule) {
            $rules[&quot;$parentKey.$key&quot;] = $rule;
            unset($rules[$key]);
        }
        return $rules;
    }
}</file><file path="app/Modules/OpenApi/LaravelDataRequestExtension.php">&lt;?php
namespace App\Modules\OpenApi;
use App\Modules\OpenApi\Concerns\CastsDtoToSchema;
use Dedoc\Scramble\Extensions\OperationExtension;
use Dedoc\Scramble\Support\Generator\{Operation, RequestBodyObject};
use Dedoc\Scramble\Support\RouteInfo;
use ReflectionNamedType;
use Spatie\LaravelData\Data;
class LaravelDataRequestExtension extends OperationExtension
{
    use CastsDtoToSchema;
    /**
     * @return void
     */
    public function handle(Operation $operation, RouteInfo $routeInfo)
    {
        if (($method = $routeInfo-&gt;reflectionMethod()) === null) {
            return;
        }
        foreach ($method-&gt;getParameters() as $parameter) {
            /* Doing this check inline since PHPStan complains otherwise */
            if (
                !(($type = $parameter-&gt;getType()) instanceof ReflectionNamedType) ||
                !is_a($type-&gt;getName(), Data::class, true)
            ) {
                continue;
            }
            $this-&gt;handleRequestData($operation, $type);
        }
    }
    protected function handleRequestData(Operation $operation, ReflectionNamedType $type): void
    {
        $name = $type-&gt;getName();
        $supportsBody = in_array($operation-&gt;method, [&apos;post&apos;, &apos;put&apos;, &apos;patch&apos;, &apos;delete&apos;], true);
        if (!$supportsBody) {
            $operation-&gt;addParameters($this-&gt;parametersFromDto($name));
            return;
        }
        $operation-&gt;addRequestBodyObject(
            RequestBodyObject::make()-&gt;setContent(&apos;application/json&apos;, $this-&gt;schemaFromDto($name)),
        );
    }
}</file><file path="app/Modules/OpenApi/LaravelDataToSchema.php">&lt;?php
namespace App\Modules\OpenApi;
use App\Modules\OpenApi\Concerns\CastsDtoToSchema;
use App\OpenApi\Generic;
use Dedoc\Scramble\Extensions\TypeToSchemaExtension;
use Dedoc\Scramble\Support\Type\{ObjectType, Type};
use Exception;
use Illuminate\Http\Response;
use Spatie\LaravelData\Data;
class LaravelDataToSchema extends TypeToSchemaExtension
{
    use CastsDtoToSchema;
    public function shouldHandle(Type $type): bool
    {
        return $type instanceof ObjectType
            &amp;&amp; $type-&gt;isInstanceOf(Data::class);
    }
    /**
     * @return mixed
     * @throws Exception
     */
    public function toSchema(Type $type)
    {
        if ($type instanceof ObjectType) {
            return $this-&gt;schemaFromDto($type-&gt;name);
        }
        return parent::toSchema($type);
    }
    /**
     * @param Generic $type
     * @throws \ReflectionException
     */
    public function toResponse(Type $type)
    {
        return Response::make(200)
            -&gt;setContent(
                &apos;application/json&apos;,
                $this-&gt;schemaFromDto($type-&gt;name),
            );
    }
}</file><file path="app/Modules/Pagination/JsonPaginator.php">&lt;?php
namespace App\Modules\Pagination;
use Illuminate\Pagination\LengthAwarePaginator;
class JsonPaginator extends LengthAwarePaginator
{
    protected array $queryParams = [
        &apos;page&apos; =&gt; &apos;page&apos;,
    ];
    public function toArray(): array
    {
        return [
            &apos;data&apos;        =&gt; $this-&gt;items-&gt;toArray(),
            &apos;total&apos;       =&gt; $this-&gt;total(),
            &apos;count&apos;       =&gt; $this-&gt;count(),
            &apos;limit&apos;       =&gt; $this-&gt;perPage(),
            &apos;currentPage&apos; =&gt; $this-&gt;currentPage(),
            &apos;nextPage&apos;    =&gt; $this-&gt;nextPage(),
            &apos;lastPage&apos;    =&gt; $this-&gt;lastPage(),
        ];
    }
    public function appends($key, $value = null): JsonPaginator|static
    {
        if (is_array($key)) {
            foreach ($key as $k =&gt; $v) {
                $this-&gt;query[$this-&gt;queryParams[$k] ?? $k] = $v;
            }
        } else {
            $this-&gt;query[$this-&gt;queryParams[$key] ?? $key] = $value;
        }
        return $this;
    }
    public function withPath($path): JsonPaginator|static
    {
        $this-&gt;path = $path;
        return $this;
    }
    public function currentPage(): int|string
    {
        $pageName = $this-&gt;queryParams[&apos;page&apos;];
        $defaultPage = $this-&gt;pageName;
        $page = LengthAwarePaginator::resolveCurrentPage($pageName);
        return $this-&gt;isValidPageNumber($page) ? $page : $defaultPage;
    }
    public function nextPage()
    {
        if ($this-&gt;hasMorePages()) {
            return $this-&gt;currentPage() + 1;
        }
        return null;
    }
}</file><file path="app/Modules/PhpInfoParser/Collections/Items.php">&lt;?php
namespace App\Modules\PhpInfoParser\Collections;
use Illuminate\Support\Collection;
class Items extends Collection
{
    public function localValue()
    {
        return $this-&gt;get(1);
    }
    public function appendLocalValue($text): void
    {
        $this-&gt;put(1, $this-&gt;get(1) . $text);
    }
}</file><file path="app/Modules/PhpInfoParser/Collections/Lines.php">&lt;?php
namespace App\Modules\PhpInfoParser\Collections;
use Illuminate\Support\Collection;
class Lines extends Collection
{
    protected int $index = 0;
    /**
     * Moves one line forward, regardless of what it is
     */
    public function step(): string|null
    {
        $this-&gt;index++;
        return $this-&gt;current();
    }
    /**
     * Advances to the next usable line and returns the new line
     */
    public function advance(): string|null
    {
        do {
            $this-&gt;index++;
        } while ($this-&gt;shouldIgnore());
        return $this-&gt;current();
    }
    /**
     * Similar to the above advance() method, except this returns
     * the CURRENT line before advancing
     */
    public function consume(): string|null
    {
        $current = $this-&gt;current();
        $this-&gt;advance();
        return $current;
    }
    public function consumeUntil(callable $callback): Collection
    {
        $lines = new static;
        do {
            $current = $this-&gt;current();
            $lines-&gt;push($current);
            $this-&gt;step();
        } while (!$callback($current));
        return $lines;
    }
    public function shouldIgnore(): bool
    {
        return $this-&gt;currentIsBlank() // || str_contains($this-&gt;current(), &apos;_______________________________________________________________________&apos;)
            || in_array($this-&gt;current(), [&apos;Configuration&apos;]);
    }
    public function currentIsBlank(): bool
    {
        return $this-&gt;current() === &apos;&apos;;
    }
    public function previousIsBlank(): bool
    {
        return $this-&gt;previous() === &apos;&apos;;
    }
    public function nextIsBlank(): bool
    {
        return $this-&gt;next() === &apos;&apos;;
    }
    public function current(): string|null
    {
        return $this-&gt;get($this-&gt;index);
    }
    public function previous(): string|null
    {
        return $this-&gt;get($this-&gt;index - 1);
    }
    public function next(): string|null
    {
        return $this-&gt;get($this-&gt;index + 1);
    }
    public function isDivider(): bool
    {
        return str_contains($this-&gt;current(), &apos;_______________________________________________________________________&apos;);
    }
    public function isModuleName(): bool
    {
        return !$this-&gt;hasItems() &amp;&amp; $this-&gt;nextIsBlank() &amp;&amp; !$this-&gt;isGroupTitle() &amp;&amp; strlen($this-&gt;current()) &lt; 50;
    }
    public function isGroupTitle(): bool
    {
        // Some group titles have obvious signals
        if (str_contains($this-&gt;current(), &quot;                     &quot;) || in_array($this-&gt;current(), [&quot;Module Name&quot;])) {
            return true;
        }
        // Some look like group titles but aren&apos;t
        if ($this-&gt;current() == &quot;PHP License&quot;) {
            return false;
        }
        // Otherwise we have a pattern
        return !$this-&gt;hasItems() &amp;&amp; !$this-&gt;nextIsBlank() &amp;&amp; strlen($this-&gt;current()) &lt; 50;
    }
    public function isTableHeading(): bool
    {
        return in_array($this-&gt;items()-&gt;first(), [
            &apos;Directive&apos;,
            &apos;Variable&apos;,
            &apos;Contribution&apos;,
            &apos;Module&apos;,
        ]);
    }
    public function isNote(): bool
    {
        return !$this-&gt;hasItems() &amp;&amp; !$this-&gt;isDivider() &amp;&amp; !$this-&gt;isGroupTitle() &amp;&amp; strlen($this-&gt;current()) &gt; 50;
    }
    public function items(): Items
    {
        $items = Items::make(explode(&quot; =&gt; &quot;, $this-&gt;current()));
        // A few weird cases we need to fix
        if ($items-&gt;first() == &quot;Features&quot; &amp;&amp; $items-&gt;count() == 1) {
            $items-&gt;put(1, null);
        }
        return $items;
    }
    public function hasItems(): bool
    {
        return $this-&gt;items()-&gt;count() &gt; 1;
    }
    public function consumeItems(): Items
    {
        $items = $this-&gt;items();
        $this-&gt;advance();
        return $items;
    }
    public function startAt($contents): string|null
    {
        if ($index = $this-&gt;search($contents)) {
            $this-&gt;index = $index;
            return $this-&gt;current();
        }
        return null;
    }
}</file><file path="app/Modules/PhpInfoParser/Concerns/ConfigAliases.php">&lt;?php
namespace App\Modules\PhpInfoParser\Concerns;
use App\Modules\PhpInfoParser\Result;
/**
 * @mixin Result
 */
trait ConfigAliases
{
    protected array $aliases = [
        &apos;os&apos;,
        &apos;hostname&apos;,
    ];
    protected function getOs(): string
    {
        return explode(&apos; &apos;, $this-&gt;config(&apos;System&apos;))[0];
    }
    protected function getHostname(): string
    {
        return explode(&apos; &apos;, $this-&gt;config(&apos;System&apos;))[1];
    }
}</file><file path="app/Modules/PhpInfoParser/Info.php">&lt;?php
namespace App\Modules\PhpInfoParser;
use App\Modules\PhpInfoParser\Parsers\{HtmlParser, TextParser};
use InvalidArgumentException;
class Info
{
    public static function capture(): Result
    {
        ob_start();
        phpinfo();
        $contents = ob_get_clean();
        return PHP_SAPI === &apos;cli&apos; ? static::fromText($contents) : static::fromHtml($contents);
    }
    public static function getModules()
    {
        $info = self::capture();
        $modules = [];
        foreach ($info-&gt;modules() as $k =&gt; $module) {
            $name = $module-&gt;name();
            $section = [
                &apos;section&apos; =&gt; $name,
                &apos;values&apos;  =&gt; [],
            ];
            foreach ($module-&gt;configs() as $config) {
                $section[&apos;values&apos;][] = [
                    &apos;key&apos;   =&gt; $config-&gt;name(),
                    &apos;value&apos; =&gt; $config-&gt;value(),
                ];
            }
            $modules[] = $section;
        }
        return $modules;
    }
    public static function fromHtml($contents): HtmlParser
    {
        return new HtmlParser($contents);
    }
    public static function fromText($contents): TextParser
    {
        return new TextParser($contents);
    }
    public static function detect($contents): Result
    {
        return match (true) {
            HtmlParser::canParse($contents) =&gt; new HtmlParser($contents),
            TextParser::canParse($contents) =&gt; new TextParser($contents),
            default =&gt; throw new InvalidArgumentException(&quot;Content provided does not appear to be valid phpinfo() output&quot;)
        };
    }
    public static function __callStatic($method, $arguments)
    {
        return static::capture()-&gt;$method(...$arguments);
    }
}</file><file path="app/Modules/PhpInfoParser/Models/Config.php">&lt;?php
namespace App\Modules\PhpInfoParser\Models;
use Illuminate\Support\{Collection, Str};
use JsonSerializable;
class Config implements JsonSerializable
{
    public function __construct(protected string $name, protected $localValue, protected $masterValue = false)
    {
    }
    public static function fromValues(Collection $values): static
    {
        return new static($values-&gt;get(0), $values-&gt;get(1) === &apos;no value&apos;
            ? null
            : $values-&gt;get(1), $values-&gt;get(2) === &apos;no value&apos;
            ? null
            : $values-&gt;get(2, false));
    }
    public function key(): string
    {
        return $this-&gt;name == &quot;Names&quot; ? &quot;config_names_&quot; . md5($this-&gt;value()) : &apos;config_&apos; . Str::slug($this-&gt;name);
    }
    public function name(): string
    {
        return $this-&gt;name;
    }
    public function value($which = &quot;local&quot;): string|null
    {
        return $which === &quot;master&quot; ? $this-&gt;masterValue() : $this-&gt;localValue();
    }
    public function localValue(): string|null
    {
        return $this-&gt;localValue;
    }
    public function hasMasterValue(): bool
    {
        return $this-&gt;masterValue !== false;
    }
    public function masterValue(): string|null
    {
        return $this-&gt;hasMasterValue() ? $this-&gt;masterValue : null;
    }
    public function __toString()
    {
        return (string)$this-&gt;value();
    }
    public function jsonSerialize(): mixed
    {
        return [
            &apos;key&apos;            =&gt; $this-&gt;key(),
            &quot;name&quot;           =&gt; $this-&gt;name(),
            &quot;hasMasterValue&quot; =&gt; $this-&gt;hasMasterValue(),
            &quot;localValue&quot;     =&gt; $this-&gt;localValue() ?? &apos;no value&apos;,
            &quot;masterValue&quot;    =&gt; $this-&gt;hasMasterValue() ? ($this-&gt;masterValue() ?? &apos;no value&apos;) : null,
        ];
    }
}</file><file path="app/Modules/PhpInfoParser/Models/Group.php">&lt;?php
namespace App\Modules\PhpInfoParser\Models;
use Illuminate\Support\{Collection, Str};
use JsonSerializable;
class Group implements JsonSerializable
{
    public function __construct(protected Collection $configs, protected ?Collection $headings = null, protected $name = null, protected $note = null)
    {
    }
    public static function simple($name, $configName, $contents): static
    {
        return new static(collect([new Config($configName, $contents)]), null, $name);
    }
    public static function noteOnly($note): Group
    {
        return (new static(collect()))-&gt;addNote($note);
    }
    public function addNote($note): self
    {
        $this-&gt;note = $note;
        return $this;
    }
    public function key(): string
    {
        return $this-&gt;name()
            ? &apos;group_&apos; . Str::slug($this-&gt;name())
            : &apos;group_&apos; . md5($this-&gt;configs()-&gt;map-&gt;name()
                -&gt;implode(&apos;,&apos;));
    }
    public function name(): string|null
    {
        return $this-&gt;name;
    }
    public function note(): string|null
    {
        return $this-&gt;note;
    }
    public function configs(): Collection
    {
        return $this-&gt;configs;
    }
    public function hasHeadings(): bool
    {
        return $this-&gt;headings?-&gt;count() &gt; 0;
    }
    public function headings(): Collection
    {
        return $this-&gt;hasHeadings() ? $this-&gt;headings : collect();
    }
    public function heading($index): string|null
    {
        return $this-&gt;headings-&gt;get($index);
    }
    public function shortHeading($index): string|null
    {
        return $this-&gt;shorten($this-&gt;headings-&gt;get($index));
    }
    protected function shorten($heading): string|null
    {
        return trim(str_replace(&apos;Value&apos;, &apos;&apos;, $heading));
    }
    public function jsonSerialize(): mixed
    {
        return [
            &apos;key&apos;           =&gt; $this-&gt;key(),
            &apos;name&apos;          =&gt; $this-&gt;name(),
            &apos;headings&apos;      =&gt; $this-&gt;headings(),
            &apos;shortHeadings&apos; =&gt; $this-&gt;headings()-&gt;map(fn($heading) =&gt; $this-&gt;shorten($heading)),
            &apos;configs&apos;       =&gt; $this-&gt;configs()-&gt;values(),
            &apos;note&apos;          =&gt; $this-&gt;note(),
        ];
    }
}</file><file path="app/Modules/PhpInfoParser/Models/Module.php">&lt;?php
namespace App\Modules\PhpInfoParser\Models;
use Illuminate\Support\{Collection, Str};
use JsonSerializable;
class Module implements JsonSerializable
{
    public function __construct(protected string $name, protected Collection $groups)
    {
    }
    public function key(): string
    {
        return &apos;module_&apos; . Str::slug($this-&gt;name);
    }
    public function combinedKeyFor(Config $config): string
    {
        return $this-&gt;key() . &apos;_&apos; . $config-&gt;key();
    }
    public function name(): string
    {
        return $this-&gt;name;
    }
    public function groups(): Collection
    {
        return $this-&gt;groups;
    }
    public function hasConfig($key): bool
    {
        return $this-&gt;configs()-&gt;first(function (Config $config) use ($key) {
                return $config-&gt;key() === &apos;config_&apos; . Str::slug($key);
            }) !== null;
    }
    public function config($key, $which = &quot;local&quot;): string|null
    {
        return $this-&gt;configs()-&gt;first(function (Config $config) use ($key) {
            return $config-&gt;key() === &apos;config_&apos; . Str::slug($key);
        })?-&gt;value($which);
    }
    public function configs(): Collection
    {
        return $this-&gt;groups()-&gt;flatMap-&gt;configs();
    }
    public function jsonSerialize(): mixed
    {
        return [
            &apos;key&apos;    =&gt; $this-&gt;key(),
            &apos;name&apos;   =&gt; $this-&gt;name(),
            &apos;groups&apos; =&gt; $this-&gt;groups()-&gt;values(),
        ];
    }
}</file><file path="app/Modules/PhpInfoParser/Parsers/HtmlParser.php">&lt;?php
namespace App\Modules\PhpInfoParser\Parsers;
use DOMDocument;
use DOMElement;
use DOMNode;
use DOMText;
use DOMXPath;
use App\Modules\PhpInfoParser\Models\{Config, Group, Module};
use App\Modules\PhpInfoParser\Result;
use Illuminate\Support\Collection;
class HtmlParser extends Result
{
    protected DOMXpath $xpath;
    public static function canParse(string $contents): bool
    {
        return str_contains($contents, &apos;phpinfo()&lt;/title&gt;&apos;) &amp;&amp; str_contains($contents, &apos;&lt;h1 class=&quot;p&quot;&gt;PHP Version &apos;);
    }
    protected function parse(): void
    {
        $this-&gt;version = str_replace(&apos;PHP Version &apos;, &apos;&apos;, $this-&gt;xpath()-&gt;query(&apos;//body//h1&apos;)[0]-&gt;nodeValue);
        // For modules, we start by looking at all &lt;h2&gt; tags
        $this-&gt;modules = collect($this-&gt;xpath()-&gt;query(&apos;//body//h2&apos;))
            // Don&apos;t need the license in our collection
            -&gt;reject(fn(DOMElement $heading) =&gt; $heading-&gt;nodeValue === &apos;PHP License&apos;)
            // Create the Module instance with all configs listed below the heading
            -&gt;map(fn(DOMElement $heading) =&gt; new Module($heading-&gt;nodeValue, $this-&gt;findGroupedConfigsFor($heading)));
        $this-&gt;modules-&gt;prepend(new Module(&apos;General&apos;, collect([
            new Group(collect($this-&gt;xpath()-&gt;query(&apos;//body//table[2]/tr&apos;))
                // We know that the general table rows only have two columns
                -&gt;map(fn(DOMElement $row) =&gt; new Config(trim($row-&gt;firstChild-&gt;nodeValue), trim($row-&gt;lastChild-&gt;nodeValue)))),
        ])));
        // Credits
        $this-&gt;modules-&gt;push(new Module($this-&gt;xpath()
                                            -&gt;query(&apos;//body//h1&apos;)[2]-&gt;nodeValue, $this-&gt;findGroupedConfigsFor($this-&gt;xpath()
                                                                                                                  -&gt;query(&apos;//body//h1&apos;)[2])));
        // License
        $this-&gt;modules-&gt;push(new Module(collect($this-&gt;xpath()-&gt;query(&apos;//body//h2&apos;))-&gt;last()-&gt;nodeValue, collect([
            Group::noteOnly(collect(collect($this-&gt;xpath()
                -&gt;query(&apos;//body//table//td&apos;))-&gt;last()-&gt;childNodes)-&gt;map-&gt;nodeValue-&gt;implode(&quot;\n\n&quot;)),
        ])));
    }
    protected function findGroupedConfigsFor(DOMElement $heading): Collection
    {
        $groups = collect();
        $current = $heading;
        // Modules often have multiple tables, we need to keep looking at siblings until it&apos;s no longer a table
        while ($current-&gt;nextSibling-&gt;nodeName === &apos;table&apos;) {
            $current = $current-&gt;nextSibling;
            $firstRowIndex = 0;
            $note = null;
            $title = null;
            // If there is a single column in our first row, it could be a title (credits) OR a license note (like mbstring)
            if ($current-&gt;childNodes[0]-&gt;childNodes-&gt;length === 1) {
                // The only way to really know it check the length, titles will be short
                if (strlen($current-&gt;childNodes[0]-&gt;childNodes[0]-&gt;nodeValue) &gt; 50) {
                    // This is a note, add it to our most recent group
                    $groups-&gt;last()
                        -&gt;addNote(// A note might have multiple child nodes due to &lt;br&gt; tags, gather them up with line break characters
                            collect($current-&gt;childNodes[0]-&gt;childNodes[0]-&gt;childNodes)-&gt;map-&gt;nodeValue-&gt;filter()
                                -&gt;implode(&quot;\n&quot;),
                        );
                    continue;
                } else {
                    // This is a group title
                    $title = $current-&gt;childNodes[0]-&gt;childNodes[0]-&gt;nodeValue;
                    $firstRowIndex = 1;
                }
            }
            // See if this table has a header row
            $headings = in_array($current-&gt;childNodes[$firstRowIndex]?-&gt;firstChild-&gt;nodeValue, [
                &apos;Directive&apos;,
                &apos;Variable&apos;,
                &apos;Contribution&apos;,
                &apos;Module&apos;,
            ]) ? collect($current-&gt;childNodes[$firstRowIndex]-&gt;childNodes)-&gt;map-&gt;nodeValue : collect();
            // We don&apos;t want to handle empty tables
            if ($current-&gt;childNodes[$firstRowIndex] === null) {
                continue;
            }
            // See if this table just has values (some credits tables are like this)
            if ($current-&gt;childNodes[$firstRowIndex]-&gt;childNodes-&gt;length === 1) {
                $groups-&gt;push(new Group(collect([
                    new Config(&apos;Names&apos;, $current-&gt;childNodes[$firstRowIndex]-&gt;childNodes[0]-&gt;nodeValue),
                ]), $headings, $title));
                continue;
            }
            $groups-&gt;push(new Group(collect($current-&gt;childNodes)
                // We only want &lt;tr&gt; nodes
                -&gt;filter(fn($node) =&gt; $node instanceof DOMElement &amp;&amp; $node-&gt;nodeName === &apos;tr&apos; &amp;&amp; $node-&gt;childNodes-&gt;length &gt; 1)
                // Get rid of header rows
                -&gt;reject(fn(DOMElement $node) =&gt; in_array($node-&gt;firstChild-&gt;nodeValue, [
                    &apos;Directive&apos;,
                    &apos;Variable&apos;,
                    &apos;Contribution&apos;,
                    &apos;Module&apos;,
                ]))
                // Parse out the field values
                -&gt;map(fn(DOMElement $row) =&gt; $this-&gt;rowToValues($row))
                // And turn into a Config object
                -&gt;map(fn(Collection $values) =&gt; Config::fromValues($values)), $headings, $title));
        }
        return $groups;
    }
    protected function rowToValues(DOMElement $row): Collection
    {
        return collect($row-&gt;childNodes)-&gt;reject(fn($node) =&gt; $node instanceof DOMText)
            -&gt;map(fn(DOMNode $cell) =&gt; trim($cell-&gt;nodeValue));
    }
    protected function xpath(): DOMXPath
    {
        if (!isset($this-&gt;xpath)) {
            $document = new DOMDocument;
            $document-&gt;loadHTML(str_replace([
                &quot;\r\n&quot;,
                &quot;\n&quot;,
            ], &apos;&apos;, $this-&gt;contents), LIBXML_NOERROR);
            $this-&gt;xpath = new DOMXpath($document);
        }
        return $this-&gt;xpath;
    }
}</file><file path="app/Modules/PhpInfoParser/Parsers/TextParser.php">&lt;?php
namespace App\Modules\PhpInfoParser\Parsers;
use App\Modules\PhpInfoParser\Collections\Lines;
use App\Modules\PhpInfoParser\Models\{Config, Group, Module};
use App\Modules\PhpInfoParser\Result;
class TextParser extends Result
{
    protected Lines $lines;
    public static function canParse(string $contents): bool
    {
        return str_contains(str_replace(&quot;\r\n&quot;, &quot;\n&quot;, $contents), &quot;phpinfo()\nPHP Version&quot;)
            &amp;&amp; count(explode(&apos;_______________________________________________________________________&apos;, $contents)) &gt;= 2;
    }
    protected function parse(): void
    {
        $this-&gt;contents = str_replace(&quot;\r\n&quot;, &quot;\n&quot;, $this-&gt;contents);
        $this-&gt;lines = new Lines(explode(&quot;\n&quot;, $this-&gt;contents));
        // Our first line is just phpinfo()
        $this-&gt;lines-&gt;advance();
        $this-&gt;version = $this-&gt;lines-&gt;consumeItems()-&gt;last();
        // Ok now we start with General info
        $this-&gt;modules = collect([$this-&gt;processModule(&apos;General&apos;)]);
        // Now we have a divider
        $this-&gt;lines-&gt;advance();
        // Now go through all the rest
        $this-&gt;processModules();
        $this-&gt;lines-&gt;advance();
        // These will find and jump to the right spot, should it exist
        $this-&gt;processCredits();
        $this-&gt;processLicense();
    }
    protected function processModules()
    {
        while ($this-&gt;lines-&gt;isModuleName()) {
            $this-&gt;modules-&gt;push($this-&gt;processModule($this-&gt;lines-&gt;consume()));
        }
    }
    protected function processModule($name)
    {
        return new Module($name, $this-&gt;processGroups());
    }
    protected function processGroups()
    {
        $groups = collect();
        while ($group = $this-&gt;processGroup()) {
            $groups-&gt;push($group);
        }
        return $groups;
    }
    protected function processGroup(): Group|false
    {
        $configs = collect();
        $headings = collect();
        $name = &apos;&apos;;
        $note = &apos;&apos;;
        // If we have a group title, it comes first
        if ($this-&gt;lines-&gt;isGroupTitle()) {
            $name = $this-&gt;lines-&gt;consume();
        }
        // Then headings, optionally
        if ($this-&gt;lines-&gt;isTableHeading()) {
            $headings = collect(explode(&apos; =&gt; &apos;, $this-&gt;lines-&gt;consume()));
        }
        // We should have config entries with items by now, or else we can&apos;t proceed
        if (!$this-&gt;lines-&gt;hasItems()) {
            return false;
        }
        $count = $this-&gt;lines-&gt;items()-&gt;count();
        while ($config = $this-&gt;processConfig()) {
            $configs-&gt;push($config);
            if ($this-&gt;lines-&gt;items()-&gt;count() !== $count) {
                // The number of values just changed, we need to start a new group
                break;
            }
        }
        if ($this-&gt;lines-&gt;isNote()) {
            $note = $this-&gt;lines-&gt;consumeUntil(fn($line) =&gt; $line === &apos;&apos;)-&gt;filter()-&gt;implode(&quot;\n&quot;);
            $this-&gt;lines-&gt;advance();
        }
        return new Group($configs, $headings, $name, trim($note));
    }
    protected function processConfig(): Config|false
    {
        if (!$this-&gt;lines-&gt;hasItems()) {
            return false;
        }
        $items = $this-&gt;lines-&gt;consumeItems();
        // A value might be split across multiple lines, each ending with a comma
        while (str_ends_with((string)$items-&gt;localValue(), &apos;,&apos;)) {
            $items-&gt;appendLocalValue(&quot;\n&quot; . $this-&gt;lines-&gt;consume());
        }
        // A value might be an Array dump, across multiple lines
        if (str_ends_with((string)$items-&gt;localValue(), &apos;Array&apos;)) {
            $items-&gt;appendLocalValue(&quot;\n&quot; . $this-&gt;lines-&gt;consumeUntil(fn($line) =&gt; $line == &apos;)&apos;)-&gt;implode(&quot;\n&quot;));
            $this-&gt;lines-&gt;advance();
        }
        return Config::fromValues($items);
    }
    protected function processCredits(): void
    {
        // First make sure we have credits
        if (!$this-&gt;lines-&gt;startAt(&apos;PHP Credits&apos;)) {
            return;
        }
        // Our credit groups are a bit odd. Some are simple with just a list of names, which can look
        // like a &quot;note&quot; to this parser. We&apos;re going to walk through each of these manually.
        $moduleName = $this-&gt;lines-&gt;consume();
        $groups = collect();
        // PHP Group
        $groups-&gt;push(Group::simple($this-&gt;lines-&gt;consume(), &apos;Names&apos;, $this-&gt;lines-&gt;consume()));
        // Language Design &amp; Concept
        $groups-&gt;push(Group::simple($this-&gt;lines-&gt;consume(), &apos;Names&apos;, $this-&gt;lines-&gt;consume()));
        // PHP Authors
        $groups-&gt;push($this-&gt;processGroup());
        // SAPI Modules
        $groups-&gt;push($this-&gt;processGroup());
        // Module Authors
        $groups-&gt;push($this-&gt;processGroup());
        // PHP Documentation
        $groups-&gt;push($this-&gt;processGroup());
        // PHP Quality Assurance Team
        $groups-&gt;push(Group::simple($this-&gt;lines-&gt;consume(), &apos;Names&apos;, $this-&gt;lines-&gt;consume()));
        // Websites and Infrastructure team
        $groups-&gt;push($this-&gt;processGroup());
        $this-&gt;modules-&gt;push(new Module($moduleName, $groups));
    }
    protected function processLicense(): void
    {
        // First make sure we have a license, and jump to that position
        if (!$this-&gt;lines-&gt;startAt(&apos;PHP License&apos;)) {
            return;
        }
        $this-&gt;modules-&gt;push(new Module($this-&gt;lines-&gt;consume(), collect([
            Group::noteOnly($this-&gt;lines-&gt;consumeUntil(fn($line) =&gt; str_contains($line, &apos;license@php.net&apos;))
                -&gt;implode(&quot;\n&quot;)),
        ])));
    }
}</file><file path="app/Modules/PhpInfoParser/Result.php">&lt;?php
namespace App\Modules\PhpInfoParser;
use InvalidArgumentException;
use JsonSerializable;
use App\Modules\PhpInfoParser\Concerns\ConfigAliases;
use App\Modules\PhpInfoParser\Models\{Config, Module};
use Illuminate\Support\{Collection, Str};
abstract class Result implements JsonSerializable
{
    use ConfigAliases;
    protected string $version;
    protected Collection $modules;
    protected Collection $configs;
    public function __construct(protected string $contents)
    {
        if (!static::canParse($contents)) {
            throw new InvalidArgumentException(&apos;Content provided does not appear to be valid phpinfo() output&apos;);
        }
        $this-&gt;parse();
    }
    abstract public static function canParse(string $contents): bool;
    abstract protected function parse(): void;
    public function version(): string
    {
        return $this-&gt;version;
    }
    public function module($key): Module|null
    {
        return $this-&gt;modules()-&gt;first(function (Module $module) use ($key) {
            return $module-&gt;key() === &apos;module_&apos; . Str::slug($key);
        });
    }
    public function hasModule($key): bool
    {
        return !!$this-&gt;module($key);
    }
    public function modules(): Collection
    {
        return $this-&gt;modules;
    }
    public function hasConfig($key): bool
    {
        return $this-&gt;configs()-&gt;first(function ($config) use ($key) {
                return $config-&gt;key() === &apos;config_&apos; . Str::slug($key);
            }) !== null;
    }
    public function config($key, $which = &apos;local&apos;): string|null
    {
        if (in_array($key, $this-&gt;aliases)) {
            $aliasMethod = &apos;get&apos; . ucfirst($key);
            return $this-&gt;$aliasMethod();
        }
        return $this-&gt;configs()-&gt;first(function (Config $config) use ($key) {
            return $config-&gt;key() === &apos;config_&apos; . Str::slug($key);
        })?-&gt;value($which);
    }
    public function configs(): Collection
    {
        if (!isset($this-&gt;configs)) {
            $this-&gt;configs = $this-&gt;modules()-&gt;flatMap-&gt;configs();
        }
        return $this-&gt;configs;
    }
    public function jsonSerialize(): mixed
    {
        return [
            &apos;version&apos; =&gt; $this-&gt;version(),
            &apos;modules&apos; =&gt; $this-&gt;modules()-&gt;values(),
        ];
    }
}</file><file path="app/Modules/QueueMonitor/Contracts/MonitoredJobContract.php">&lt;?php
namespace App\Modules\QueueMonitor\Contracts;
interface MonitoredJobContract
{
    public function queueProgress(int $progress): void;
    public function queueProgressChunk(int $collectionCount, int $perChunk): void;
    /**
     * @param array&lt;mixed, mixed&gt; $data
     * @param bool $merge
     *
     * @return void
     */
    public function queueData(array $data, bool $merge = false): void;
    public static function keepMonitorOnSuccess(): bool;
    public function progressCooldown(): int;
    /**
     * @return array&lt;mixed, mixed&gt;|null
     */
    public function initialMonitorData(): ?array;
}</file><file path="app/Modules/Recommendation/Algorithms/CosineSimilarity.php">&lt;?php
namespace App\Modules\Recommendation\Algorithms;
use App\Modules\Recommendation\Contracts\AlgorithmInterface;
class CosineSimilarity implements AlgorithmInterface
{
    public function __construct(
        private readonly array $a,
        private readonly array $b,
    )
    {
    }
    public function calculate()
    {
        // Get all dimensions from both vectors
        $dimensions = array_unique(array_merge(array_keys($this-&gt;a), array_keys($this-&gt;b)));
        // Calculate dot product
        $dotProduct = 0;
        $normA = 0;
        $normB = 0;
        foreach ($dimensions as $dimension) {
            $valueA = $this-&gt;a[$dimension] ?? 0;
            $valueB = $this-&gt;b[$dimension] ?? 0;
            $dotProduct += $valueA * $valueB;
            $normA += $valueA * $valueA;
            $normB += $valueB * $valueB;
        }
        $normA = sqrt($normA);
        $normB = sqrt($normB);
        // Avoid division by zero
        if ($normA == 0 || $normB == 0) {
            return 0;
        }
        // Cosine similarity formula: dot product / (|A| * |B|)
        return $dotProduct / ($normA * $normB);
    }
}</file><file path="app/Modules/Recommendation/Algorithms/EuclideanDistance.php">&lt;?php
namespace App\Modules\Recommendation\Algorithms;
use App\Modules\Recommendation\Contracts\AlgorithmInterface;
class EuclideanDistance implements AlgorithmInterface
{
    public function __construct(
        private readonly array $a,
        private readonly array $b,
    )
    {
    }
    public function calculate(bool $returnDistance = false)
    {
        // Ensure both vectors have the same dimensions
        $dimensions = array_unique(array_merge(array_keys($this-&gt;a), array_keys($this-&gt;b)));
        $sum = 0;
        foreach ($dimensions as $dimension) {
            $valA = $this-&gt;a[$dimension] ?? 0;
            $valB = $this-&gt;b[$dimension] ?? 0;
            $diff = $valA - $valB;
            $sum += $diff * $diff;
        }
        $distance = sqrt($sum);
        // For similarity, normalize to [0,1] range
        if (!$returnDistance) {
            // Compute maximum possible distance for normalization
            // For vectors in range [0,1], max distance is sqrt(dimensions)
            $maxDistance = sqrt(count($dimensions));
            return 1 - min($distance / $maxDistance, 1.0);
        }
        return $distance;
    }
}</file><file path="app/Modules/Recommendation/Algorithms/HammingDistance.php">&lt;?php
namespace App\Modules\Recommendation\Algorithms;
use App\Modules\Recommendation\Contracts\AlgorithmInterface;
class HammingDistance implements AlgorithmInterface
{
    public function __construct(
        private readonly string $a,
        private readonly string $b,
        private readonly bool $returnDistance = false,
    )
    {
    }
    public function calculate()
    {
        // Make both strings the same length with proper padding
        $maxLength = max(strlen($this-&gt;a), strlen($this-&gt;b));
        $firstStr = str_pad($this-&gt;a, $maxLength, &apos; &apos;);
        $secondStr = str_pad($this-&gt;b, $maxLength, &apos; &apos;);
        // Count differing characters
        $distance = 0;
        for ($i = 0; $i &lt; $maxLength; $i++) {
            if ($firstStr[$i] !== $secondStr[$i]) {
                $distance++;
            }
        }
        if ($this-&gt;returnDistance) {
            return $distance;
        }
        // Return similarity score (normalized to [0,1])
        return ($maxLength &gt; 0) ? ($maxLength - $distance) / $maxLength : 1.0;
    }
    // Add method for comparing binary feature arrays
    public static function forFeatureArrays(array $a, array $b): float
    {
        $features = array_unique(array_merge(array_keys($a), array_keys($b)));
        $distance = 0;
        foreach ($features as $feature) {
            if (($a[$feature] ?? 0) != ($b[$feature] ?? 0)) {
                $distance++;
            }
        }
        return ($features) ? ($distance / count($features)) : 0;
    }
}</file><file path="app/Modules/Recommendation/Algorithms/MinMaxNorm.php">&lt;?php
namespace App\Modules\Recommendation\Algorithms;
use App\Modules\Recommendation\Contracts\AlgorithmInterface;
class MinMaxNorm
{
    public function __construct(
        private readonly array $values,
        private readonly float|int|null $min = null,
        private readonly float|int|null $max = null,
    )
    {
    }
    public function calculate()
    {
        $norm = [];
        $min = $this-&gt;min ?? min($this-&gt;values);
        $max = $this-&gt;max ?? max($this-&gt;values);
        // Handle edge case where max equals min (prevent division by zero)
        if ($max === $min) {
            return array_fill(0, count($this-&gt;values), 0.5); // Return middle value
        }
        foreach ($this-&gt;values as $key =&gt; $value) {
            $numerator = $value - $min;
            $denominator = $max - $min;
            $minMaxNorm = $numerator / $denominator;
            $norm[$key] = $minMaxNorm; // Preserve keys
        }
        return $norm;
    }
    // Add a static method to normalize multiple feature arrays together
    public static function normalizeFeatures(array $featureSets): array
    {
        $normalizedSets = [];
        $features = [];
        // First, collect all feature values to determine global min/max
        foreach ($featureSets as $set) {
            foreach ($set as $feature =&gt; $value) {
                $features[$feature][] = $value;
            }
        }
        // Calculate min/max for each feature
        $featureMinMax = [];
        foreach ($features as $feature =&gt; $values) {
            $featureMinMax[$feature] = [
                &apos;min&apos; =&gt; min($values),
                &apos;max&apos; =&gt; max($values)
            ];
        }
        // Normalize each feature set
        foreach ($featureSets as $setKey =&gt; $set) {
            $normalizedSets[$setKey] = [];
            foreach ($set as $feature =&gt; $value) {
                $min = $featureMinMax[$feature][&apos;min&apos;];
                $max = $featureMinMax[$feature][&apos;max&apos;];
                if ($max === $min) {
                    $normalizedSets[$setKey][$feature] = 0.5;
                } else {
                    $normalizedSets[$setKey][$feature] = ($value - $min) / ($max - $min);
                }
            }
        }
        return $normalizedSets;
    }
}</file><file path="app/Modules/Recommendation/Algorithms/TfIdf.php">&lt;?php
namespace App\Modules\Recommendation\Algorithms;
use App\Modules\Recommendation\Contracts\AlgorithmInterface;
class TfIdf implements AlgorithmInterface
{
    /**
     * @var array Collection of documents (arrays of terms)
     */
    private array $documents;
    /**
     * Constructor
     *
     * @param array $documents Array of documents (arrays of terms)
     */
    public function __construct(array $documents)
    {
        $this-&gt;documents = $documents;
    }
    /**
     * Calculate TF-IDF for a collection of documents
     *
     * @return array TF-IDF vectors for each document
     */
    public function calculate(): array
    {
        $documentCount = count($this-&gt;documents);
        if ($documentCount === 0) {
            return [];
        }
        // Get all unique terms
        $allTerms = [];
        foreach ($this-&gt;documents as $document) {
            foreach ($document as $term) {
                $allTerms[$term] = true;
            }
        }
        $allTerms = array_keys($allTerms);
        // Calculate term frequencies for each document
        $termFrequencies = [];
        foreach ($this-&gt;documents as $docId =&gt; $document) {
            $termFrequencies[$docId] = $this-&gt;calculateTermFrequency($document);
        }
        // Calculate inverse document frequency for each term
        $idf = [];
        foreach ($allTerms as $term) {
            $documentsWithTerm = 0;
            foreach ($this-&gt;documents as $document) {
                if (in_array($term, $document)) {
                    $documentsWithTerm++;
                }
            }
            // IDF formula: log(total documents / documents containing term)
            $idf[$term] = log($documentCount / max(1, $documentsWithTerm));
        }
        // Calculate TF-IDF vectors
        $tfidfVectors = [];
        foreach ($termFrequencies as $docId =&gt; $tf) {
            $tfidfVectors[$docId] = [];
            foreach ($allTerms as $term) {
                $termTf = $tf[$term] ?? 0;
                $tfidfVectors[$docId][$term] = $termTf * ($idf[$term] ?? 0);
            }
        }
        return $tfidfVectors;
    }
    /**
     * Calculate term frequency for a document
     *
     * @param array $document Array of terms
     * @return array Term frequencies
     */
    private function calculateTermFrequency(array $document): array
    {
        $tf = [];
        $totalTerms = count($document);
        foreach ($document as $term) {
            if (!isset($tf[$term])) {
                $tf[$term] = 0;
            }
            $tf[$term]++;
        }
        // Normalize by document length
        if ($totalTerms &gt; 0) {
            foreach ($tf as $term =&gt; $count) {
                $tf[$term] = $count / $totalTerms;
            }
        }
        return $tf;
    }
}</file><file path="app/Modules/Recommendation/Calculators/ContentBasedCalculator.php">&lt;?php
namespace App\Modules\Recommendation\Calculators;
use App\Modules\Recommendation\Algorithms\{CosineSimilarity, TfIdf};
use App\Modules\Recommendation\Contracts\CalculatorInterface;
use Illuminate\Database\Eloquent\Collection;
use Illuminate\Database\Eloquent\Model;
class ContentBasedCalculator implements CalculatorInterface
{
    /**
     * Calculate recommendations based on content similarity
     *
     * @param mixed $sourceData Source model(s) to calculate recommendations for
     * @param array $configuration Configuration parameters for calculation
     * @return array Array of recommendations [sourceId =&gt; [targetId =&gt; score]]
     */
    public function calculate($sourceData, array $configuration): array
    {
        // Ensure we have a collection of models
        $models = $this-&gt;normalizeSourceData($sourceData);
        if ($models-&gt;isEmpty()) {
            return [];
        }
        $maxRecommendations = $configuration[&apos;count&apos;] ?? config(&apos;recommendation.defaults.count&apos;, 10);
        $contentField = $configuration[&apos;content_field&apos;] ?? &apos;description&apos;;
        $recommendations = [];
        // Extract content from all models
        $documents = [];
        $modelIds = [];
        foreach ($models as $model) {
            if (isset($model-&gt;$contentField)) {
                $content = $this-&gt;processContent($model-&gt;$contentField);
                if (!empty($content)) {
                    $modelIds[] = $model-&gt;getKey();
                    $documents[] = $content;
                }
            }
        }
        // If we have fewer than 2 documents, we can&apos;t calculate recommendations
        if (count($documents) &lt; 2) {
            return [];
        }
        // Calculate TF-IDF vectors
        $tfidf = new TfIdf($documents);
        $tfidfVectors = $tfidf-&gt;calculate();
        // Calculate similarity between each pair of models
        foreach ($modelIds as $i =&gt; $sourceId) {
            $similarities = [];
            foreach ($modelIds as $j =&gt; $targetId) {
                // Skip self-comparison
                if ($sourceId === $targetId) {
                    continue;
                }
                $sourceVector = $tfidfVectors[$i];
                $targetVector = $tfidfVectors[$j];
                // Calculate cosine similarity
                $cosineSimilarity = new CosineSimilarity($sourceVector, $targetVector);
                $similarityScore = $cosineSimilarity-&gt;calculate() * 100;
                if ($similarityScore &gt; 0) {
                    $similarities[$targetId] = $similarityScore;
                }
            }
            // Sort by similarity score (descending) and limit to max recommendations
            arsort($similarities);
            $recommendations[$sourceId] = array_slice($similarities, 0, $maxRecommendations, true);
        }
        return $recommendations;
    }
    /**
     * Process content text into a bag of words
     *
     * @param string $content
     * @return array
     */
    private function processContent(string $content): array
    {
        // Convert to lowercase
        $content = strtolower($content);
        // Remove special characters and numbers
        $content = preg_replace(&apos;/[^\p{L}\s]/u&apos;, &apos; &apos;, $content);
        // Split into words
        $words = preg_split(&apos;/\s+/&apos;, $content, -1, PREG_SPLIT_NO_EMPTY);
        // Remove common stopwords
        $stopwords = [&apos;the&apos;, &apos;and&apos;, &apos;a&apos;, &apos;to&apos;, &apos;of&apos;, &apos;in&apos;, &apos;is&apos;, &apos;that&apos;, &apos;it&apos;, &apos;with&apos;, &apos;for&apos;, &apos;as&apos;, &apos;on&apos;, &apos;at&apos;];
        $words = array_diff($words, $stopwords);
        return $words;
    }
    /**
     * Normalize source data to a collection of models
     *
     * @param mixed $sourceData
     * @return \Illuminate\Database\Eloquent\Collection
     */
    private function normalizeSourceData($sourceData): Collection
    {
        if ($sourceData instanceof Model) {
            return collect([$sourceData]);
        }
        if ($sourceData instanceof Collection) {
            return $sourceData;
        }
        if (is_array($sourceData)) {
            return collect($sourceData);
        }
        // Query all models of the specified class
        if (is_string($sourceData) &amp;&amp; class_exists($sourceData)) {
            return $sourceData::all();
        }
        return collect([]);
    }
}</file><file path="app/Modules/Recommendation/Calculators/DatabaseRelationCalculator.php">&lt;?php
namespace App\Modules\Recommendation\Calculators;
use App\Modules\Recommendation\Contracts\CalculatorInterface;
use Illuminate\Support\Facades\DB;
use InvalidArgumentException;
class DatabaseRelationCalculator implements CalculatorInterface
{
    /**
     * Calculate recommendations based on database relationships
     *
     * @param mixed $sourceData Source model(s) to calculate recommendations for
     * @param array $configuration Configuration parameters for calculation
     * @return array Array of recommendations [sourceId =&gt; [targetId =&gt; score]]
     * @throws InvalidArgumentException
     */
    public function calculate($sourceData, array $configuration): array
    {
        // Validate required configuration parameters
        $this-&gt;validateConfiguration($configuration);
        // Extract configuration parameters
        $dataTable = $configuration[&apos;data_table&apos;];
        $dataField = $configuration[&apos;data_field&apos;];
        $groupField = $configuration[&apos;group_field&apos;];
        $maxRecommendations = $configuration[&apos;count&apos;] ?? config(&apos;recommendation.defaults.count&apos;, 10);
        // Query the database to get relationship data
        $query = DB::table($dataTable)
            -&gt;select(
                DB::raw(&quot;{$groupField} as group_field&quot;),
                DB::raw(&quot;{$dataField} as data_field&quot;)
            );
        // Apply data filters if specified
        if (isset($configuration[&apos;data_table_filter&apos;]) &amp;&amp; is_array($configuration[&apos;data_table_filter&apos;])) {
            foreach ($configuration[&apos;data_table_filter&apos;] as $field =&gt; $filterConfig) {
                $this-&gt;applyFilter($query, $field, $filterConfig);
            }
        }
        $relationData = $query-&gt;get();
        // Group the data by the group field
        $groupedData = [];
        foreach ($relationData as $row) {
            if (!isset($groupedData[$row-&gt;group_field])) {
                $groupedData[$row-&gt;group_field] = [];
            }
            $groupedData[$row-&gt;group_field][] = $row-&gt;data_field;
        }
        // Calculate co-occurrence based recommendations
        $recommendations = $this-&gt;calculateCoOccurrenceRecommendations(
            $groupedData,
            $maxRecommendations
        );
        return $recommendations;
    }
    /**
     * Validate that required configuration parameters are present
     *
     * @param array $configuration
     * @return void
     * @throws InvalidArgumentException
     */
    private function validateConfiguration(array $configuration): void
    {
        $requiredParams = [&apos;data_table&apos;, &apos;data_field&apos;, &apos;group_field&apos;];
        foreach ($requiredParams as $param) {
            if (!isset($configuration[$param])) {
                throw new InvalidArgumentException(&quot;Missing required configuration parameter: {$param}&quot;);
            }
        }
    }
    /**
     * Apply a filter to the database query
     *
     * @param \Illuminate\Database\Query\Builder $query
     * @param string $field
     * @param mixed $filterConfig
     * @return void
     */
    private function applyFilter($query, string $field, $filterConfig): void
    {
        // Handle array format filter [operator, value]
        if (is_array($filterConfig) &amp;&amp; count($filterConfig) === 2) {
            [$operator, $value] = $filterConfig;
            // Handle callable value (dynamic filters)
            if (is_callable($value)) {
                $value = $value();
            }
            // Apply appropriate filter based on operator
            switch (strtoupper($operator)) {
                case &apos;=&apos;:
                    $query-&gt;where($field, $value);
                    break;
                case &apos;IN&apos;:
                    $query-&gt;whereIn($field, (array)$value);
                    break;
                case &apos;NOT IN&apos;:
                    $query-&gt;whereNotIn($field, (array)$value);
                    break;
                case &apos;BETWEEN&apos;:
                    if (is_array($value) &amp;&amp; count($value) === 2) {
                        $query-&gt;whereBetween($field, $value);
                    }
                    break;
                default:
                    $query-&gt;where($field, $operator, $value);
            }
        }
        // Handle direct value comparison (equals)
        else {
            $query-&gt;where($field, $filterConfig);
        }
    }
    /**
     * Calculate recommendations based on co-occurrence in groups
     *
     * @param array $groupedData
     * @param int $maxRecommendations
     * @return array
     */
    private function calculateCoOccurrenceRecommendations(array $groupedData, int $maxRecommendations): array
    {
        $coOccurrenceScores = [];
        $recommendations = [];
        // Calculate co-occurrence scores
        foreach ($groupedData as $group) {
            foreach ($group as $item1) {
                foreach ($group as $item2) {
                    // Skip self-recommendations
                    if ($item1 === $item2) {
                        continue;
                    }
                    if (!isset($coOccurrenceScores[$item1])) {
                        $coOccurrenceScores[$item1] = [];
                    }
                    if (!isset($coOccurrenceScores[$item1][$item2])) {
                        $coOccurrenceScores[$item1][$item2] = 0;
                    }
                    // Increment co-occurrence score
                    $coOccurrenceScores[$item1][$item2]++;
                }
            }
        }
        // Sort and limit recommendations
        foreach ($coOccurrenceScores as $sourceId =&gt; $targets) {
            arsort($targets);
            $recommendations[$sourceId] = array_slice($targets, 0, $maxRecommendations, true);
        }
        return $recommendations;
    }
}</file><file path="app/Modules/Recommendation/Calculators/SimilarityCalculator.php">&lt;?php
namespace App\Modules\Recommendation\Calculators;
use App\Modules\Recommendation\Algorithms\{EuclideanDistance, HammingDistance, JaccardIndex, MinMaxNorm};
use App\Modules\Recommendation\Contracts\CalculatorInterface;
use Illuminate\Database\Eloquent\Collection;
use Illuminate\Database\Eloquent\Model;
class SimilarityCalculator implements CalculatorInterface
{
    /**
     * Calculate recommendations based on similarity metrics
     *
     * @param mixed $sourceData Source model(s) to calculate recommendations for
     * @param array $configuration Configuration parameters for calculation
     * @return array Array of recommendations [sourceId =&gt; [targetId =&gt; score]]
     */
    public function calculate($sourceData, array $configuration): array
    {
        // Ensure we have a collection of models
        $models = $this-&gt;normalizeSourceData($sourceData);
        if ($models-&gt;isEmpty()) {
            return [];
        }
        $maxRecommendations = $configuration[&apos;count&apos;] ?? config(&apos;recommendation.defaults.count&apos;, 10);
        $recommendations = [];
        // Cache extracted features to avoid redundant processing
        $cachedTaxonomies = [];
        $cachedFeatures = [];
        $cachedNumericValues = [];
        // Extract all features once for better performance
        foreach ($models as $model) {
            $modelId = $model-&gt;getKey();
            if (isset($configuration[&apos;similarity_taxonomy_attributes&apos;])) {
                $cachedTaxonomies[$modelId] = $this-&gt;generateTaxonomies(
                    $model,
                    $configuration[&apos;similarity_taxonomy_attributes&apos;]
                );
            }
            if (isset($configuration[&apos;similarity_feature_attributes&apos;])) {
                $cachedFeatures[$modelId] = $this-&gt;extractFeatures(
                    $model,
                    $configuration[&apos;similarity_feature_attributes&apos;]
                );
            }
            if (isset($configuration[&apos;similarity_numeric_value_attributes&apos;])) {
                $cachedNumericValues[$modelId] = $this-&gt;extractNumericValues(
                    $model,
                    $configuration[&apos;similarity_numeric_value_attributes&apos;]
                );
            }
        }
        // Normalize numeric values across all models
        $normalizedNumericValues = [];
        if (!empty($cachedNumericValues)) {
            $normalizedNumericValues = MinMaxNorm::normalizeFeatures($cachedNumericValues);
        }
        // Calculate similarity between each pair of models
        foreach ($models as $sourceModel) {
            $sourceId = $sourceModel-&gt;getKey();
            $similarities = [];
            foreach ($models as $targetModel) {
                $targetId = $targetModel-&gt;getKey();
                // Skip self-comparison
                if ($sourceId === $targetId) {
                    continue;
                }
                $similarityScore = $this-&gt;calculateSimilarityScore(
                    $sourceId,
                    $targetId,
                    $configuration,
                    $cachedTaxonomies,
                    $cachedFeatures,
                    $normalizedNumericValues
                );
                // Only include models with non-zero similarity
                if ($similarityScore &gt; 0) {
                    $similarities[$targetId] = $similarityScore;
                }
            }
            // Sort by similarity score (descending) and limit to max recommendations
            arsort($similarities);
            $recommendations[$sourceId] = array_slice($similarities, 0, $maxRecommendations, true);
        }
        return $recommendations;
    }
    /**
     * Normalize source data to a collection of models
     *
     * @param mixed $sourceData
     * @return \Illuminate\Database\Eloquent\Collection
     */
    private function normalizeSourceData($sourceData): Collection
    {
        if ($sourceData instanceof Model) {
            return collect([$sourceData]);
        }
        if ($sourceData instanceof Collection) {
            return $sourceData;
        }
        if (is_array($sourceData)) {
            return collect($sourceData);
        }
        // Query all models of the specified class
        if (is_string($sourceData) &amp;&amp; class_exists($sourceData)) {
            return $sourceData::all();
        }
        return collect([]);
    }
    /**
     * Calculate similarity score between two models
     *
     * @param int|string $sourceId
     * @param int|string $targetId
     * @param array $configuration
     * @param array $cachedTaxonomies
     * @param array $cachedFeatures
     * @param array $normalizedNumericValues
     * @return float Similarity score between 0-100
     */
    private function calculateSimilarityScore(
        $sourceId,
        $targetId,
        array $configuration,
        array $cachedTaxonomies,
        array $cachedFeatures,
        array $normalizedNumericValues
    ): float {
        $weights = [
            &apos;taxonomy&apos; =&gt; $configuration[&apos;similarity_taxonomy_weight&apos;] ?? 1.0,
            &apos;feature&apos;  =&gt; $configuration[&apos;similarity_feature_weight&apos;] ?? 0.0,
            &apos;numeric&apos;  =&gt; $configuration[&apos;similarity_numeric_value_weight&apos;] ?? 0.0,
        ];
        $scores = [
            &apos;taxonomy&apos; =&gt; 0,
            &apos;feature&apos;  =&gt; 0,
            &apos;numeric&apos;  =&gt; 0,
        ];
        // Calculate taxonomy similarity if configured
        if ($weights[&apos;taxonomy&apos;] &gt; 0 &amp;&amp;
            !empty($configuration[&apos;similarity_taxonomy_attributes&apos;]) &amp;&amp;
            isset($cachedTaxonomies[$sourceId]) &amp;&amp;
            isset($cachedTaxonomies[$targetId])) {
            $sourceTaxonomies = $cachedTaxonomies[$sourceId];
            $targetTaxonomies = $cachedTaxonomies[$targetId];
            if (!empty($sourceTaxonomies) &amp;&amp; !empty($targetTaxonomies)) {
                try {
                    $jaccardIndex = JaccardIndex::fromArrays($sourceTaxonomies, $targetTaxonomies);
                    $scores[&apos;taxonomy&apos;] = $jaccardIndex-&gt;calculate() * 100;
                } catch (\Throwable $e) {
                    // Handle calculation errors gracefully
                    $scores[&apos;taxonomy&apos;] = 0;
                }
            }
        }
        // Calculate feature similarity if configured
        if ($weights[&apos;feature&apos;] &gt; 0 &amp;&amp;
            !empty($configuration[&apos;similarity_feature_attributes&apos;]) &amp;&amp;
            isset($cachedFeatures[$sourceId]) &amp;&amp;
            isset($cachedFeatures[$targetId])) {
            $sourceFeatures = $cachedFeatures[$sourceId];
            $targetFeatures = $cachedFeatures[$targetId];
            if (!empty($sourceFeatures) &amp;&amp; !empty($targetFeatures)) {
                try {
                    // Calculate feature similarity using Hamming distance for feature arrays
                    $hammingDistance = HammingDistance::forFeatureArrays($sourceFeatures, $targetFeatures);
                    $scores[&apos;feature&apos;] = (1 - $hammingDistance) * 100;
                } catch (\Throwable $e) {
                    $scores[&apos;feature&apos;] = 0;
                }
            }
        }
        // Calculate numeric similarity if configured
        if ($weights[&apos;numeric&apos;] &gt; 0 &amp;&amp;
            !empty($configuration[&apos;similarity_numeric_value_attributes&apos;]) &amp;&amp;
            isset($normalizedNumericValues[$sourceId]) &amp;&amp;
            isset($normalizedNumericValues[$targetId])) {
            $normalizedSource = $normalizedNumericValues[$sourceId];
            $normalizedTarget = $normalizedNumericValues[$targetId];
            if (!empty($normalizedSource) &amp;&amp; !empty($normalizedTarget)) {
                try {
                    $euclideanDistance = new EuclideanDistance($normalizedSource, $normalizedTarget);
                    // The improved EuclideanDistance class handles similarity calculation correctly
                    $scores[&apos;numeric&apos;] = $euclideanDistance-&gt;calculate(false) * 100;
                } catch (\Throwable $e) {
                    $scores[&apos;numeric&apos;] = 0;
                }
            }
        }
        // Calculate weighted average of scores
        $totalWeight = array_sum($weights);
        if ($totalWeight === 0) {
            return 0;
        }
        $weightedScore = 0;
        foreach ($scores as $type =&gt; $score) {
            $weightedScore += ($score * $weights[$type]);
        }
        return $weightedScore / $totalWeight;
    }
    /**
     * Generate taxonomies (categorical data) from model
     *
     * @param Model $model
     * @param array $taxonomyFields
     * @return array
     */
    private function generateTaxonomies(Model $model, array $taxonomyFields): array
    {
        $taxonomies = [];
        foreach ($taxonomyFields as $relationField) {
            if (is_array($relationField)) {
                // Handle relation =&gt; attribute format
                foreach ($relationField as $relation =&gt; $attribute) {
                    if (method_exists($model, $relation)) {
                        $relatedModels = $model-&gt;$relation;
                        if ($relatedModels) {
                            if ($relatedModels instanceof Collection) {
                                foreach ($relatedModels as $relatedModel) {
                                    if (isset($relatedModel-&gt;$attribute)) {
                                        $taxonomies[] = $relation . &apos;:&apos; . $relatedModel-&gt;$attribute;
                                    }
                                }
                            } else if (isset($relatedModels-&gt;$attribute)) {
                                $taxonomies[] = $relation . &apos;:&apos; . $relatedModels-&gt;$attribute;
                            }
                        }
                    }
                }
            } else {
                // Handle direct attributes
                if (isset($model-&gt;$relationField)) {
                    $taxonomies[] = $relationField . &apos;:&apos; . $model-&gt;$relationField;
                }
            }
        }
        return $taxonomies;
    }
    /**
     * Extract boolean feature values from model
     *
     * @param Model $model
     * @param array $featureFields
     * @return array
     */
    private function extractFeatures(Model $model, array $featureFields): array
    {
        $features = [];
        foreach ($featureFields as $field) {
            $features[$field] = isset($model-&gt;$field) &amp;&amp; $model-&gt;$field ? 1 : 0;
        }
        return $features;
    }
    /**
     * Extract numeric values from model
     *
     * @param Model $model
     * @param array $numericFields
     * @return array
     */
    private function extractNumericValues(Model $model, array $numericFields): array
    {
        $numericValues = [];
        foreach ($numericFields as $field) {
            $numericValues[$field] = isset($model-&gt;$field) ? (float)$model-&gt;$field : 0;
        }
        return $numericValues;
    }
}</file><file path="app/Modules/Recommendation/Concerns/Recommendable.php">&lt;?php
namespace App\Modules\Recommendation\Concerns;
interface Recommendable
{
    /**
     * Returns the array of configuration for the model.
     * [
     *     &apos;recommendation_name_1&apos; =&gt; [
     *         &apos;recommendation_algorithm&apos;         =&gt; &apos;db_relation&apos;, // db_relation, similarity
     *         &apos;recommendation_data_table&apos;        =&gt; &apos;recommendation_data_table&apos;,
     *         &apos;recommendation_data_table_filter&apos; =&gt; [
     *             &apos;field&apos; =&gt; &apos;value&apos;
     *         ],
     *         &apos;recommendation_data_field&apos;        =&gt; &apos;recommendation_data_field&apos;,
     *         &apos;recommendation_data_field_type&apos;   =&gt; &apos;recommendation_data_field_type&apos;,
     *         &apos;recommendation_group_field&apos;       =&gt; &apos;recommendation_group_field&apos;,
     *         &apos;recommendation_count&apos;             =&gt; 5,
     *         &apos;recommendation_order&apos;             =&gt; &apos;desc&apos;
     *     ],
     *     &apos;recommendation_name_2&apos; =&gt; [
     *         &apos;recommendation_algorithm&apos;            =&gt; &apos;similarity&apos;, // db_relation, similarity
     *         &apos;similarity_feature_weight&apos;           =&gt; 1,
     *         &apos;similarity_numeric_value_weight&apos;     =&gt; 1,
     *         &apos;similarity_numeric_value_high_range&apos; =&gt; 1,
     *         &apos;similarity_taxonomy_weight&apos;          =&gt; 1,
     *         &apos;similarity_feature_attributes&apos;       =&gt; [
     *             &apos;attribute1&apos;, &apos;attribute2&apos;
     *         ],
     *         &apos;similarity_numeric_value_attributes&apos; =&gt; [
     *             &apos;attribute1&apos;, &apos;attribute2&apos;
     *         ],
     *         &apos;similarity_taxonomy_attributes&apos;      =&gt; [
     *             [
     *                  &apos;relation&apos; =&gt; &apos;attribute&apos;
     *             ]
     *         ],
     *         &apos;recommendation_count&apos;                =&gt; 5,
     *         &apos;recommendation_order&apos;                =&gt; &apos;desc&apos;
     *     ]
     * ]
     *
     * @return array
     */
    public static function getRecommendationConfig(): array;
}</file><file path="app/Modules/Recommendation/Contracts/AlgorithmInterface.php">&lt;?php
namespace App\Modules\Recommendation\Contracts;
interface AlgorithmInterface
{
    public function calculate();
}</file><file path="app/Modules/Recommendation/Contracts/CalculatorInterface.php">&lt;?php
namespace App\Modules\Recommendation\Contracts;
interface CalculatorInterface
{
    /**
     * Calculate recommendations for the given source model(s)
     *
     * @param mixed $sourceData Source model(s) to calculate recommendations for
     * @param array $configuration Configuration parameters for the calculation
     * @return array Array of recommendations [sourceId =&gt; [targetId =&gt; score]]
     */
    public function calculate($sourceData, array $configuration): array;
}</file><file path="app/Modules/Recommendation/HasRecommendation.php">&lt;?php
namespace App\Modules\Recommendation;
use App\Jobs\Recommendation\GenerateRecommendationsJob;
use App\Modules\Recommendation\Services\RecommendationService;
use Illuminate\Support\Collection;
use Illuminate\Support\Facades\App;
trait HasRecommendation
{
    /**
     * Get recommendations for this model
     *
     * @param string $recommendationName
     * @return Collection
     */
    public function getRecommendations(string $recommendationName): Collection
    {
        return App::make(RecommendationService::class)
            -&gt;getRecommendations($this, $recommendationName);
    }
    /**
     * Get recommendations with specified relationships loaded
     *
     * @param string $recommendationName
     * @param array $relationships
     * @return Collection
     */
    public function getRecommendationsWithRelations(string $recommendationName, array $relationships): Collection
    {
        $recommendations = $this-&gt;getRecommendations($recommendationName);
        return $recommendations-&gt;isEmpty()
            ? $recommendations
            : $recommendations-&gt;load($relationships);
    }
    /**
     * Generate recommendations for this specific model instance
     *
     * @param string $recommendationName
     * @return int Number of recommendations generated
     */
    public function generateRecommendationsForSelf(string $recommendationName): int
    {
        return App::make(RecommendationService::class)
            -&gt;generateRecommendationsForModel($this, $recommendationName);
    }
    /**
     * Generate recommendations for all models of this class
     *
     * @param string $recommendationName
     * @return int Number of recommendations generated
     */
    public static function generateRecommendations(string $recommendationName): int
    {
        return App::make(RecommendationService::class)
            -&gt;generateRecommendations(static::class, $recommendationName);
    }
    /**
     * Schedule recommendation generation as a background job
     *
     * @param string $recommendationName
     * @return void
     */
    public static function scheduleRecommendationGeneration(string $recommendationName): void
    {
        dispatch(new GenerateRecommendationsJob(static::class, $recommendationName));
    }
    /**
     * Clear recommendation cache for all models of this class
     *
     * @param string $recommendationName
     * @return void
     */
    public static function clearRecommendationCache(string $recommendationName): void
    {
        App::make(RecommendationService::class)
            -&gt;clearRecommendationCache(static::class, $recommendationName);
    }
}</file><file path="app/Modules/Recommendation/Services/RecommendationService.php">&lt;?php
namespace App\Modules\Recommendation\Services;
use App\Models\Recommendation;
use App\Modules\Recommendation\Contracts\CalculatorInterface;
use Illuminate\Database\Eloquent\Model;
use Illuminate\Support\Collection;
use Illuminate\Support\Facades\Cache;
use Illuminate\Support\Facades\DB;
use InvalidArgumentException;
use Psr\Log\LoggerInterface;
class RecommendationService
{
    /**
     * Registered recommendation calculators
     *
     * @var array&lt;string, CalculatorInterface&gt;
     */
    private array $calculators = [];
    /**
     * @var LoggerInterface
     */
    private LoggerInterface $logger;
    /**
     * Constructor with dependency injection
     */
    public function __construct(LoggerInterface $logger)
    {
        $this-&gt;logger = $logger;
    }
    /**
     * Register a calculator for a specific algorithm
     *
     * @param string $algorithm
     * @param CalculatorInterface $calculator
     * @return $this
     */
    public function registerCalculator(string $algorithm, CalculatorInterface $calculator): self
    {
        $this-&gt;calculators[$algorithm] = $calculator;
        return $this;
    }
    /**
     * Get calculator for an algorithm
     *
     * @param string $algorithm
     * @return CalculatorInterface
     * @throws InvalidArgumentException
     */
    public function getCalculator(string $algorithm): CalculatorInterface
    {
        if (!isset($this-&gt;calculators[$algorithm])) {
            throw new InvalidArgumentException(&quot;No calculator registered for algorithm: {$algorithm}&quot;);
        }
        return $this-&gt;calculators[$algorithm];
    }
    /**
     * Get available algorithms
     *
     * @return array
     */
    public function getAvailableAlgorithms(): array
    {
        return array_keys($this-&gt;calculators);
    }
    /**
     * Get recommendations for a model with optional caching
     *
     * @param Model $model
     * @param string $name
     * @param bool $refresh Force refresh even when cache is enabled
     * @return Collection
     */
    public function getRecommendations(Model $model, string $name, bool $refresh = false): Collection
    {
        $cacheEnabled = config(&apos;recommendation.cache.enabled&apos;, true) &amp;&amp; !$refresh;
        $cacheTtl = config(&apos;recommendation.cache.ttl&apos;, 3600);
        if (!$cacheEnabled) {
            return $this-&gt;fetchRecommendations($model, $name);
        }
        $modelClass = get_class($model);
        $cacheKey = &quot;recommendations:{$model-&gt;getTable()}:{$model-&gt;getKey()}:{$name}&quot;;
        $tagName = &quot;recommendations:{$modelClass}:{$name}&quot;;
        // Use cache tags if the cache store supports them
        if (Cache::getStore() instanceof \Illuminate\Cache\TaggableStore) {
            return Cache::tags($tagName)-&gt;remember($cacheKey, $cacheTtl, function () use ($model, $name) {
                return $this-&gt;fetchRecommendations($model, $name);
            });
        }
        // Fall back to regular caching if tags not supported
        return Cache::remember($cacheKey, $cacheTtl, function () use ($model, $name) {
            return $this-&gt;fetchRecommendations($model, $name);
        });
    }
    /**
     * Fetch recommendations from the database
     *
     * @param Model $model
     * @param string $name
     * @return Collection
     */
    private function fetchRecommendations(Model $model, string $name): Collection
    {
        $configMethod = &apos;getRecommendationConfig&apos;;
        if (!method_exists($model, $configMethod)) {
            $this-&gt;logger-&gt;warning(&quot;Model &quot; . get_class($model) . &quot; doesn&apos;t implement getRecommendationConfig method&quot;);
            return collect();
        }
        $config = $model-&gt;$configMethod()[$name] ?? null;
        if ($config === null) {
            $this-&gt;logger-&gt;warning(&quot;No recommendation config found for &quot; . get_class($model) . &quot; with name &apos;{$name}&apos;&quot;);
            return collect();
        }
        $targetType = $config[&apos;data_field_type&apos;] ?? get_class($model);
        // Get recommendations with their position values
        $recommendations = Recommendation::whereSourceType(get_class($model))
            -&gt;whereName($name)
            -&gt;whereTargetType($targetType)
            -&gt;whereSourceId($model-&gt;getKey())
            -&gt;orderBy(&apos;position&apos;) // Use the explicit position for ordering
            -&gt;get();
        if ($recommendations-&gt;isEmpty()) {
            return collect();
        }
        // Extract target IDs while maintaining their order
        $orderedTargetIds = $recommendations-&gt;pluck(&apos;target_id&apos;)-&gt;toArray();
        // Load eager relations if specified
        $eagerLoad = $config[&apos;with&apos;] ?? [];
        $query = $targetType::whereIn(&apos;id&apos;, $orderedTargetIds);
        if (!empty($eagerLoad)) {
            $query-&gt;with($eagerLoad);
        }
        // Get the result models
        $result = $query-&gt;get();
        // Apply custom ordering based on configuration
        $order = $config[&apos;order&apos;] ?? config(&apos;recommendation.defaults.order&apos;, &apos;desc&apos;);
        if ($order === &apos;random&apos;) {
            return $result-&gt;shuffle();
        }
        // Create a position lookup table
        $positionMap = [];
        foreach ($recommendations as $recommendation) {
            $positionMap[$recommendation-&gt;target_id] = $recommendation-&gt;position;
        }
        // Order by the explicit position
        $orderedResult = $result-&gt;sortBy(function ($model) use ($positionMap) {
            return $positionMap[$model-&gt;getKey()] ?? PHP_INT_MAX;
        });
        // Reverse the order if we want ascending order of scores (which means descending order of positions)
        if ($order === &apos;asc&apos;) {
            return $orderedResult-&gt;reverse();
        }
        return $orderedResult;
    }
    /**
     * Generate recommendations for all models of a specific class
     *
     * @param string $modelClass
     * @param string $name
     * @param array $options Additional options for generation
     * @return int
     */
    public function generateRecommendations(string $modelClass, string $name, array $options = []): int
    {
        $configMethod = &apos;getRecommendationConfig&apos;;
        if (!method_exists($modelClass, $configMethod)) {
            $this-&gt;logger-&gt;warning(&quot;Model {$modelClass} doesn&apos;t implement {$configMethod}&quot;);
            return 0;
        }
        $config = $modelClass::$configMethod()[$name] ?? null;
        if ($config === null) {
            $this-&gt;logger-&gt;warning(&quot;No recommendation config found for {$modelClass} with name &apos;{$name}&apos;&quot;);
            return 0;
        }
        $algorithm = $config[&apos;algorithm&apos;] ?? &apos;db_relation&apos;;
        try {
            $calculator = $this-&gt;getCalculator($algorithm);
        } catch (InvalidArgumentException $e) {
            $this-&gt;logger-&gt;error(&quot;Failed to get calculator: &quot; . $e-&gt;getMessage());
            return 0;
        }
        // Get source data - either all models or a filtered subset
        $query = $modelClass::query();
        if (isset($options[&apos;filter&apos;]) &amp;&amp; is_callable($options[&apos;filter&apos;])) {
            $options[&apos;filter&apos;]($query);
        }
        $models = $query-&gt;get();
        $this-&gt;logger-&gt;info(&quot;Generating recommendations for {$name} using {$algorithm} algorithm on &quot; . $models-&gt;count() . &quot; models&quot;);
        // Calculate recommendations
        try {
            $recommendations = $calculator-&gt;calculate($models, $config);
            return $this-&gt;saveRecommendations($modelClass, $name, $recommendations, $config);
        } catch (\Throwable $e) {
            $this-&gt;logger-&gt;error(&quot;Error generating recommendations: &quot; . $e-&gt;getMessage());
            return 0;
        }
    }
    /**
     * Save calculated recommendations to the database
     *
     * @param string $modelClass
     * @param string $name
     * @param array $recommendations
     * @param array $config
     * @return int
     */
    private function saveRecommendations(
        string $modelClass,
        string $name,
        array $recommendations,
        array $config
    ): int {
        $targetType = $config[&apos;data_field_type&apos;] ?? $modelClass;
        $insertedCount = 0;
        $batchSize = $config[&apos;batch_size&apos;] ?? 1000;
        // Use a transaction for better performance and data integrity
        DB::transaction(function () use (
            $modelClass,
            $name,
            $recommendations,
            $targetType,
            &amp;$insertedCount,
            $batchSize
        ) {
            // Delete existing recommendations
            Recommendation::where(&apos;source_type&apos;, $modelClass)
                -&gt;where(&apos;name&apos;, $name)
                -&gt;delete();
            // Prepare data for bulk insert
            $recommendationsToInsert = [];
            $now = now();
            foreach ($recommendations as $sourceId =&gt; $targets) {
                // Process each source&apos;s targets
                $position = 1; // Start position at 1
                // Sort targets by score descending (higher scores first)
                arsort($targets);
                foreach ($targets as $targetId =&gt; $score) {
                    $recommendationsToInsert[] = [
                        &apos;source_type&apos; =&gt; $modelClass,
                        &apos;source_id&apos; =&gt; $sourceId,
                        &apos;target_type&apos; =&gt; $targetType,
                        &apos;target_id&apos; =&gt; $targetId,
                        &apos;score&apos; =&gt; $score, // Store original score for filtering/reference
                        &apos;position&apos; =&gt; $position, // Add explicit position for ordering
                        &apos;name&apos; =&gt; $name,
                        &apos;created_at&apos; =&gt; $now,
                        &apos;updated_at&apos; =&gt; $now,
                    ];
                    $insertedCount++;
                    $position++; // Increment position for next item
                    // Insert in batches to prevent memory issues
                    if (count($recommendationsToInsert) &gt;= $batchSize) {
                        Recommendation::insert($recommendationsToInsert);
                        $recommendationsToInsert = [];
                    }
                }
            }
            // Insert any remaining recommendations
            if (!empty($recommendationsToInsert)) {
                Recommendation::insert($recommendationsToInsert);
            }
        });
        // Clear cache for this recommendation set
        $this-&gt;clearRecommendationCache($modelClass, $name);
        $this-&gt;logger-&gt;info(&quot;Saved {$insertedCount} recommendations for {$modelClass}:{$name}&quot;);
        return $insertedCount;
    }
    /**
     * Clear cache for a specific model instance
     *
     * @param Model $model
     * @param string $name
     * @return void
     */
    public function clearModelRecommendationCache(Model $model, string $name): void
    {
        $modelClass = get_class($model);
        $cacheKey = &quot;recommendations:{$model-&gt;getTable()}:{$model-&gt;getKey()}:$name&quot;;
        $tagName = &quot;recommendations:$modelClass:$name&quot;;
        if (Cache::getStore() instanceof \Illuminate\Cache\TaggableStore) {
            Cache::tags($tagName)-&gt;forget($cacheKey);
            return;
        }
        Cache::forget($cacheKey);
    }
    /**
     * Clear cache for a specific recommendation set
     *
     * @param string $modelClass
     * @param string $name
     * @return void
     */
    public function clearRecommendationCache(string $modelClass, string $name): void
    {
        // For stores that support tags, use tag-based clearing
        if (Cache::getStore() instanceof \Illuminate\Cache\TaggableStore) {
            $tagName = &quot;recommendations:{$modelClass}:{$name}&quot;;
            Cache::tags($tagName)-&gt;flush();
            return;
        }
        $model = new $modelClass;
        $tablePrefix = $model-&gt;getTable();
        // For Redis specifically, we can use pattern matching
        if (method_exists(Cache::getStore(), &apos;getRedis&apos;)) {
            try {
                $redis = Cache::getStore()-&gt;getRedis();
                $pattern = &quot;laravel:recommendations:{$tablePrefix}:*:{$name}&quot;;
                // Use SCAN instead of KEYS for production safety
                $cursor = &apos;0&apos;;
                do {
                    [$cursor, $keys] = $redis-&gt;scan($cursor, &apos;MATCH&apos;, $pattern, &apos;COUNT&apos;, 100);
                    // Delete the keys if any found
                    if (!empty($keys)) {
                        $redis-&gt;del($keys);
                    }
                } while ($cursor != &apos;0&apos;);
                return;
            } catch (\Exception $e) {
                $this-&gt;logger-&gt;warning(&quot;Redis cache clearing failed: &quot; . $e-&gt;getMessage());
            }
        }
        $this-&gt;logger-&gt;warning(
            &quot;Cannot efficiently clear recommendation cache for {$modelClass}:{$name}. &quot; .
            &quot;Consider using a cache store that supports tags.&quot;
        );
    }
    /**
     * Generate recommendations for a specific model instance
     *
     * @param Model $model
     * @param string $name
     * @return int
     */
    public function generateRecommendationsForModel(Model $model, string $name): int
    {
        $configMethod = &apos;getRecommendationConfig&apos;;
        if (!method_exists($model, $configMethod)) {
            return 0;
        }
        $config = $model-&gt;$configMethod()[$name] ?? null;
        if ($config === null) {
            return 0;
        }
        $algorithm = $config[&apos;algorithm&apos;] ?? &apos;db_relation&apos;;
        try {
            $calculator = $this-&gt;getCalculator($algorithm);
        } catch (InvalidArgumentException $e) {
            $this-&gt;logger-&gt;error(&quot;Failed to get calculator: &quot; . $e-&gt;getMessage());
            return 0;
        }
        // Calculate recommendations for this specific model
        try {
            $recommendations = $calculator-&gt;calculate($model, $config);
        } catch (\Throwable $e) {
            $this-&gt;logger-&gt;error(&quot;Error generating recommendations for model: &quot; . $e-&gt;getMessage());
            return 0;
        }
        // Save recommendations only for this model
        $modelClass = get_class($model);
        $targetType = $config[&apos;data_field_type&apos;] ?? $modelClass;
        $insertedCount = 0;
        DB::transaction(function () use ($model, $modelClass, $name, $recommendations, $targetType, &amp;$insertedCount) {
            // Delete existing recommendations for this model
            Recommendation::where(&apos;source_type&apos;, $modelClass)
                -&gt;where(&apos;name&apos;, $name)
                -&gt;where(&apos;source_id&apos;, $model-&gt;getKey())
                -&gt;delete();
            // Insert new recommendations
            $now = now();
            if (isset($recommendations[$model-&gt;getKey()])) {
                $position = 1;
                $targets = $recommendations[$model-&gt;getKey()];
                // Sort by score descending
                arsort($targets);
                foreach ($targets as $targetId =&gt; $score) {
                    Recommendation::create([
                        &apos;source_type&apos; =&gt; $modelClass,
                        &apos;source_id&apos; =&gt; $model-&gt;getKey(),
                        &apos;target_type&apos; =&gt; $targetType,
                        &apos;target_id&apos; =&gt; $targetId,
                        &apos;score&apos; =&gt; $score,
                        &apos;position&apos; =&gt; $position,
                        &apos;name&apos; =&gt; $name,
                        &apos;created_at&apos; =&gt; $now,
                        &apos;updated_at&apos; =&gt; $now,
                    ]);
                    $insertedCount++;
                    $position++;
                }
            }
        });
        // Clear cache for this model
        $this-&gt;clearModelRecommendationCache($model, $name);
        return $insertedCount;
    }
}</file><file path="app/Modules/Transcoder/TranscoderConfig.php">&lt;?php
namespace App\Modules\Transcoder;
class TranscoderConfig
{
    public function getLoggerName()
    {
        return &apos;transcoder&apos;;
    }
    public function getDefaultFormat()
    {
        return &apos;mp4&apos;;
    }
}</file><file path="app/Modules/Transcoder/TranscoderContextFactory.php">&lt;?php
namespace App\Modules\Transcoder;
use Baander\Transcoder\TranscoderContext;
class TranscoderContextFactory
{
    public static function create(): TranscoderContext
    {
        $logger = new \Monolog\Logger(&apos;TranscoderLogger&apos;);
        return new TranscoderContext(
            ffmpegPath: config(&apos;ffmpeg.ffmpeg.binaries&apos;),
            ffprobePath: config(&apos;ffmpeg.ffprobe.binaries&apos;),
            transcodeOutputPath: config(&apos;ffmpeg.temporary_files_root&apos;),
            readyTimeOut: config(&apos;transcoder.ready_time_out&apos;),
            transcodeTimeOut: config(&apos;transcoder.transcode_time_out&apos;),
            logger: $logger,
            transcoderLogfilePath: config(&apos;transcoder.log_file_path&apos;),
            redisHost: config(&apos;database.redis.transcodes.host&apos;),
            redisPassword: config(&apos;database.redis.transcodes.password&apos;),
            redisPort: config(&apos;database.redis.transcodes.port&apos;),
            redisDb: config(&apos;database.redis.transcodes.database&apos;),
        );
    }
}</file><file path="app/Modules/Translation/LocaleString.php">&lt;?php
namespace App\Modules\Translation;
class LocaleString
{
    public const string LOCALE_STRING_DELIMITER = &apos;$_︸_$&apos;;
    public static function delimitString(string $value): string
    {
        return self::applyDelimiter($value);
    }
    public static function removeDelimiters(string $value): string
    {
        return self::stripDelimiter($value);
    }
    public static function isLocaleString(string $value): bool
    {
        return str_contains($value, self::LOCALE_STRING_DELIMITER);
    }
    private static function applyDelimiter(string $value): string
    {
        return self::LOCALE_STRING_DELIMITER . $value . self::LOCALE_STRING_DELIMITER;
    }
    private static function stripDelimiter(string $value): string
    {
        return str_replace(self::LOCALE_STRING_DELIMITER, &apos;&apos;, $value);
    }
}</file><file path="app/Modules/Webauthn/Actions/FindPasskeyToAuthenticateAction.php">&lt;?php
namespace App\Modules\Webauthn\Actions;
use App\Models\Passkey;
use App\Modules\Webauthn\WebauthnService;
use Throwable;
use Webauthn\AuthenticatorAssertionResponse;
use Webauthn\AuthenticatorAssertionResponseValidator;
use Webauthn\CeremonyStep\CeremonyStepManagerFactory;
use Webauthn\PublicKeyCredential;
use Webauthn\PublicKeyCredentialRequestOptions;
use Webauthn\PublicKeyCredentialSource;
class FindPasskeyToAuthenticateAction
{
    public function execute(
        string $publicKeyCredentialJson,
        string $passkeyOptionsJson,
    ): ?Passkey
    {
        $publicKeyCredential = $this-&gt;determinePublicKeyCredential($publicKeyCredentialJson);
        if (!$publicKeyCredential) {
            return null;
        }
        $passkey = Passkey::firstWhere(&apos;credential_id&apos;, $publicKeyCredential-&gt;rawId);
        if (!$passkey) {
            return null;
        }
        /** @var PublicKeyCredentialRequestOptions $passkeyOptions */
        $passkeyOptions = app(WebauthnService::class)-&gt;deserialize(
            $passkeyOptionsJson,
            PublicKeyCredentialRequestOptions::class,
        );
        $publicKeyCredentialSource = $this-&gt;determinePublicKeyCredentialSource(
            $publicKeyCredential,
            $passkeyOptions,
            $passkey,
        );
        if (!$publicKeyCredentialSource) {
            return null;
        }
        $this-&gt;updatePasskey($passkey, $publicKeyCredentialSource);
        return $passkey;
    }
    public function determinePublicKeyCredential(
        string $publicKeyCredentialJson,
    ): ?PublicKeyCredential
    {
        $publicKeyCredential = app(WebauthnService::class)-&gt;deserialize(
            $publicKeyCredentialJson,
            PublicKeyCredential::class,
        );
        if (!$publicKeyCredential-&gt;response instanceof AuthenticatorAssertionResponse) {
            return null;
        }
        return $publicKeyCredential;
    }
    protected function determinePublicKeyCredentialSource(
        PublicKeyCredential               $publicKeyCredential,
        PublicKeyCredentialRequestOptions $passkeyOptions,
        Passkey                           $passkey,
    ): ?PublicKeyCredentialSource
    {
        $csmFactory = new CeremonyStepManagerFactory;
        $requestCsm = $csmFactory-&gt;requestCeremony();
        try {
            $validator = AuthenticatorAssertionResponseValidator::create($requestCsm);
            $publicKeyCredentialSource = $validator-&gt;check(
                publicKeyCredentialSource: $passkey-&gt;data,
                authenticatorAssertionResponse: $publicKeyCredential-&gt;response,
                publicKeyCredentialRequestOptions: $passkeyOptions,
                host: parse_url(config(&apos;app.url&apos;), PHP_URL_HOST),
                userHandle: null,
            );
        } catch (Throwable) {
            return null;
        }
        return $publicKeyCredentialSource;
    }
    protected function updatePasskey(
        Passkey                   $passkey,
        PublicKeyCredentialSource $publicKeyCredentialSource,
    ): self
    {
        $passkey-&gt;update([
            &apos;data&apos;         =&gt; $publicKeyCredentialSource,
            &apos;last_used_at&apos; =&gt; now(),
        ]);
        return $this;
    }
}</file><file path="app/Modules/Webauthn/Actions/GeneratePasskeyAuthenticationOptionsAction.php">&lt;?php
namespace App\Modules\Webauthn\Actions;
use App\Modules\Webauthn\PasskeyService;
use App\Modules\Webauthn\WebauthnService;
use Illuminate\Support\Facades\Session;
use Illuminate\Support\Str;
use Webauthn\PublicKeyCredentialRequestOptions;
class GeneratePasskeyAuthenticationOptionsAction
{
    public function execute(string $email): string
    {
        $service = app(PasskeyService::class);
        $allowedCredentials = $service-&gt;getAllowedCredentials($email);
        $options = new PublicKeyCredentialRequestOptions(
            challenge: Str::random(),
            rpId: parse_url(config(&apos;app.url&apos;), PHP_URL_HOST),
            allowCredentials: $allowedCredentials,
        );
        $options = app(WebauthnService::class)-&gt;serialize($options);
        Session::flash(&apos;passkey-authentication-options&apos;, $options);
        return $options;
    }
}</file><file path="app/Modules/Webauthn/Actions/GeneratePasskeyRegisterOptionsAction.php">&lt;?php
namespace App\Modules\Webauthn\Actions;
use App\Modules\Webauthn\Concerns\HasPasskeys;
use App\Modules\Webauthn\Models\PublicKeyCredentialCreationOptionsData;
use App\Modules\Webauthn\WebauthnService;
use Illuminate\Support\Str;
use Webauthn\AuthenticatorSelectionCriteria;
use Webauthn\PublicKeyCredentialCreationOptions;
use Webauthn\PublicKeyCredentialRpEntity;
use Webauthn\PublicKeyCredentialUserEntity;
class GeneratePasskeyRegisterOptionsAction
{
    public function execute(
        HasPasskeys $authenticatable,
        bool        $asJson = true,
    ): string|PublicKeyCredentialCreationOptions
    {
        $authenticatorSelectionCriteria = AuthenticatorSelectionCriteria::create(
            authenticatorAttachment: AuthenticatorSelectionCriteria::AUTHENTICATOR_ATTACHMENT_NO_PREFERENCE,
            residentKey: AuthenticatorSelectionCriteria::RESIDENT_KEY_REQUIREMENT_REQUIRED,
        );
        $options = new PublicKeyCredentialCreationOptions(
            rp: $this-&gt;relatedPartyEntity(),
            user: $this-&gt;generateUserEntity($authenticatable),
            challenge: $this-&gt;challenge(),
            authenticatorSelection: $authenticatorSelectionCriteria,
        );
        if ($asJson) {
            $options = app(WebauthnService::class)-&gt;serialize($options);
        }
        return $options;
    }
    protected function relatedPartyEntity(): PublicKeyCredentialRpEntity
    {
        return new PublicKeyCredentialRpEntity(
            name: config(&apos;webauthn.relying_party.name&apos;),
            id: config(&apos;webauthn.relying_party.id&apos;),
            icon: config(&apos;webauthn.relying_party.icon&apos;),
        );
    }
    public function generateUserEntity(HasPasskeys $authenticatable): PublicKeyCredentialUserEntity
    {
        return new PublicKeyCredentialUserEntity(
            name: $authenticatable-&gt;getPassKeyName(),
            id: $authenticatable-&gt;getPassKeyId(),
            displayName: $authenticatable-&gt;getPassKeyDisplayName(),
        );
    }
    public function authenticatorSelection()
    {
    }
    protected function challenge(): string
    {
        return Str::random();
    }
    private function getCredential(PublicKeyCredentialUserEntity $userEntity)
    {
    }
    private function getServerPublicKeyCredentialCreationOptionsRequest(string $content)
    {
        return app(WebauthnService::class)-&gt;deserialize($content, PublicKeyCredentialCreationOptionsData::class);
    }
}</file><file path="app/Modules/Webauthn/Actions/StorePasskeyAction.php">&lt;?php
namespace App\Modules\Webauthn\Actions;
use App\Models\Passkey;
use App\Modules\Webauthn\Concerns\HasPasskeys;
use App\Modules\Webauthn\Exceptions\InvalidPasskey;
use App\Modules\Webauthn\PasskeyService;
use Throwable;
use Webauthn\AuthenticatorAttestationResponse;
use Webauthn\AuthenticatorAttestationResponseValidator;
use Webauthn\CeremonyStep\CeremonyStepManagerFactory;
use Webauthn\PublicKeyCredentialSource;
class StorePasskeyAction
{
    public function execute(
        HasPasskeys $authenticatable,
        string      $passkeyJson,
        string      $passkeyOptionsJson,
        string      $hostName,
        array       $additionalProperties = [],
    ): Passkey
    {
        $publicKeyCredentialSource = $this-&gt;determinePublicKeyCredentialSource(
            $passkeyJson,
            $passkeyOptionsJson,
            $hostName,
        );
        return $authenticatable-&gt;passkeys()-&gt;create([
            ...$additionalProperties,
            &apos;data&apos; =&gt; $publicKeyCredentialSource,
        ]);
    }
    protected function determinePublicKeyCredentialSource(
        string $passkeyJson,
        string $passkeyOptionsJson,
        string $hostName,
    ): PublicKeyCredentialSource
    {
        $passkeyOptions = $this-&gt;getService()-&gt;makePublicKeyCredentialCreationOptions($passkeyOptionsJson);
        $publicKeyCredential = $this-&gt;getService()-&gt;getPublicKeyCredentialByPasskey($passkeyJson);
        if (!$publicKeyCredential-&gt;response instanceof AuthenticatorAttestationResponse) {
            throw InvalidPasskey::invalidPublicKeyCredential();
        }
        $csmFactory = new CeremonyStepManagerFactory;
        $creationCsm = $csmFactory-&gt;creationCeremony();
        try {
            $publicKeyCredentialSource = AuthenticatorAttestationResponseValidator::create($creationCsm)-&gt;check(
                authenticatorAttestationResponse: $publicKeyCredential-&gt;response,
                publicKeyCredentialCreationOptions: $passkeyOptions,
                host: $hostName,
            );
        } catch (Throwable $exception) {
            throw InvalidPasskey::invalidAuthenticatorAttestationResponse($exception);
        }
        return $publicKeyCredentialSource;
    }
    /**
     * @return PasskeyService
     */
    private function getService()
    {
        return app(PasskeyService::class);
    }
}</file><file path="app/Modules/Webauthn/Concerns/HasPasskeys.php">&lt;?php
namespace App\Modules\Webauthn\Concerns;
use Illuminate\Database\Eloquent\Relations\HasMany;
interface HasPasskeys
{
    public function passkeys(): HasMany;
    public function getPassKeyName(): string;
    public function getPassKeyId(): string;
    public function getPassKeyDisplayName(): string;
}</file><file path="app/Modules/Webauthn/CounterChecker.php">&lt;?php
namespace App\Modules\Webauthn;
use App\Modules\Webauthn\Exceptions\CurrentCountExceededSource;
use Webauthn\PublicKeyCredentialSource;
class CounterChecker implements \Webauthn\Counter\CounterChecker
{
    public function check(PublicKeyCredentialSource $publicKeyCredentialSource, int $currentCounter): void
    {
        if ($currentCounter &gt; $publicKeyCredentialSource-&gt;counter) {
            CurrentCountExceededSource::throw($currentCounter, $publicKeyCredentialSource-&gt;counter);
        }
    }
}</file><file path="app/Modules/Webauthn/Exceptions/CurrentCountExceededSource.php">&lt;?php
namespace App\Modules\Webauthn\Exceptions;
class CurrentCountExceededSource extends \Exception
{
    public static function throw(int $current, int $source): self
    {
        return new self(&quot;The current count has exceeded the source count. Possible cloned passkey! Current: $current Source: $source&quot;);
    }
}</file><file path="app/Modules/Webauthn/Exceptions/InvalidPasskey.php">&lt;?php
namespace App\Modules\Webauthn\Exceptions;
use Exception;
use Throwable;
class InvalidPasskey extends Exception
{
    public static function invalidJson(): self
    {
        return new self(&apos;The given passkey should be formatted as json. Please check the format and try again.&apos;);
    }
    public static function invalidPublicKeyCredential(): self
    {
        return new self(&apos;The given passkey is not a valid public key credential. Please check the format and try again.&apos;);
    }
    public static function invalidAuthenticatorAttestationResponse(Throwable $exception): self
    {
        return new self(
            &apos;The given passkey could not be validated. Please check the format and try again.&apos;,
            previous: $exception,
        );
    }
}</file><file path="app/Modules/Webauthn/Exceptions/InvalidPasskeyOptions.php">&lt;?php
namespace App\Modules\Webauthn\Exceptions;
use Exception;
class InvalidPasskeyOptions extends Exception
{
    public static function invalidJson(): self
    {
        return new self(&apos;The given passkey options should be formatted as json. Please check the format and try again.&apos;);
    }
}</file><file path="app/Modules/Webauthn/Models/PublicKeyCredentialCreationOptionsData.php">&lt;?php
namespace App\Modules\Webauthn\Models;
use Spatie\LaravelData\Data;
use Webauthn\AuthenticatorSelectionCriteria;
use Webauthn\PublicKeyCredentialCreationOptions;
class PublicKeyCredentialCreationOptionsData extends Data
{
    public function __construct(
        /** @var PublicKeyCredentialCreationOptions */
        public ?string $attestation = null,
        /** @var AuthenticatorSelectionCriteria */
        public ?string $userVerification = null,
        /** @var AuthenticatorSelectionCriteria */
        public ?string $residentKey = null,
        /** @var AuthenticatorSelectionCriteria */
        public ?string $authenticatorAttachment = null,
        /** @var array&lt;string, mixed&gt;|null */
        public ?array  $extensions = null,
    )
    {
    }
}</file><file path="app/Modules/Webauthn/PasskeyService.php">&lt;?php
namespace App\Modules\Webauthn;
use App\Models\Passkey;
use App\Modules\Webauthn\Exceptions\InvalidPasskey;
use App\Modules\Webauthn\Exceptions\InvalidPasskeyOptions;
use Webauthn\PublicKeyCredential;
use Webauthn\PublicKeyCredentialCreationOptions;
use Webauthn\PublicKeyCredentialUserEntity;
class PasskeyService
{
    /**
     * Retrieves a PublicKeyCredential instance from a JSON string.
     *
     * @param string $json A JSON string representing the public key credential.
     * @return PublicKeyCredential The deserialized public key credential object.
     * @throws InvalidPasskey If the provided JSON is not valid.
     */
    public function getPublicKeyCredentialByPasskey(string $json)
    {
        if (!json_validate($json)) {
            throw InvalidPasskey::invalidJson();
        }
        /** @var PublicKeyCredential $publicKeyCredential */
        $publicKeyCredential = app(WebauthnService::class)-&gt;deserialize(
            $json,
            PublicKeyCredential::class,
        );
        return $publicKeyCredential;
    }
    public function getAllowedCredentials(PublicKeyCredentialUserEntity $userEntity)
    {
        $registered = Passkey::whereId($userEntity-&gt;id)-&gt;get();
        $allowedCredentials = $registered-&gt;map(function (Passkey $passkey) {
            return $passkey-&gt;data();
        });
        return $allowedCredentials-&gt;toArray();
    }
    /**
     * Generates PublicKeyCredentialCreationOptions from a JSON string.
     *
     * @param string $passkeyOptionsJson A JSON string representing the passkey creation options.
     * @return PublicKeyCredentialCreationOptions The deserialized passkey creation options object.
     * @throws InvalidPasskeyOptions If the provided JSON is not valid.
     */
    public function makePublicKeyCredentialCreationOptions(string $passkeyOptionsJson)
    {
        if (!json_validate($passkeyOptionsJson)) {
            throw InvalidPasskeyOptions::invalidJson();
        }
        /** @var PublicKeyCredentialCreationOptions $passkeyOptions */
        $passkeyOptions = app(WebauthnService::class)-&gt;deserialize(
            $passkeyOptionsJson,
            PublicKeyCredentialCreationOptions::class,
        );
        return $passkeyOptions;
    }
}</file><file path="app/Modules/Webauthn/WebauthnService.php">&lt;?php
namespace App\Modules\Webauthn;
use Symfony\Component\Serializer\SerializerInterface;
use Webauthn\AttestationStatement\AttestationStatementSupportManager;
class WebauthnService
{
    public function __construct(
        private readonly AttestationStatementSupportManager $attestationStatementSupportManager,
        private readonly SerializerInterface                $serializer,
    )
    {
    }
    public function serialize(mixed $value)
    {
        return $this-&gt;serializer-&gt;serialize($value, &apos;json&apos;);
    }
    public function deserialize(string $value, string $targetClass)
    {
        return $this-&gt;serializer-&gt;deserialize($value, $targetClass, &apos;json&apos;);
    }
}</file><file path="app/Observers/VideoObserver.php">&lt;?php
namespace App\Observers;
use App\Http\Integrations\Transcoder\TranscoderClient;
use App\Models\Video;
class VideoObserver
{
    /**
     * Handle the Video &quot;created&quot; event.
     */
    public function created(Video $video): void
    {
        $service = app(TranscoderClient::class);
        $service-&gt;enqueueProbe($video-&gt;path);
    }
    public function updating(Video $video)
    {
        if ($video-&gt;wasChanged(&apos;probe&apos;)) {
            if (isset($video-&gt;probe[&apos;video&apos;][&apos;width&apos;]) &amp;&amp; isset($video-&gt;probe[&apos;video&apos;][&apos;height&apos;])) {
                $video-&gt;width = (int)$video-&gt;probe[&apos;video&apos;][&apos;width&apos;];
                $video-&gt;height = (int)$video-&gt;probe[&apos;video&apos;][&apos;height&apos;];
            }
            if (isset($video-&gt;probe[&apos;video&apos;][&apos;frame_rate&apos;])) {
                $video-&gt;framerate = (int)$video-&gt;probe[&apos;video&apos;][&apos;frame_rate&apos;];
            }
            if (isset($video-&gt;probe[&apos;duration_seconds&apos;])) {
                $video-&gt;duration = floor($video-&gt;probe[&apos;duration_seconds&apos;]);
            }
            if (isset($video-&gt;probe[&apos;video&apos;][&apos;bitrate&apos;])) {
                $video-&gt;video_bitrate = (int)$video-&gt;probe[&apos;video&apos;][&apos;bitrate&apos;];
            }
        }
    }
}</file><file path="app/Policies/PlaylistPolicy.php">&lt;?php
namespace App\Policies;
use App\Models\{Playlist, User};
class PlaylistPolicy
{
    public function view(User $user, Playlist $playlist)
    {
        return $playlist-&gt;is_public || $playlist-&gt;user_id === $user-&gt;id;
    }
    public function addSong(User $user, Playlist $playlist)
    {
        return $playlist-&gt;canAddSongs($user);
    }
    public function update(User $user, Playlist $playlist)
    {
        return $playlist-&gt;canEdit($user);
    }
    public function delete(User $user, Playlist $playlist)
    {
        return $playlist-&gt;user_id === $user-&gt;id;
    }
}</file><file path="app/Providers/EventServiceProvider.php">&lt;?php
namespace App\Providers;
use Illuminate\Auth\Events\Registered;
use Illuminate\Auth\Listeners\SendEmailVerificationNotification;
use Illuminate\Foundation\Support\Providers\EventServiceProvider as ServiceProvider;
use Illuminate\Support\Facades\Event;
class EventServiceProvider extends ServiceProvider
{
    /**
     * The event to listener mappings for the application.
     *
     * @var array&lt;class-string, array&lt;int, class-string&gt;&gt;
     */
    protected $listen = [
        Registered::class =&gt; [
            SendEmailVerificationNotification::class,
        ],
    ];
    /**
     * Register any events for your application.
     */
    public function boot(): void
    {
        //
    }
    /**
     * Determine if events and listeners should be automatically discovered.
     */
    public function shouldDiscoverEvents(): bool
    {
        return false;
    }
}</file><file path="app/Providers/IntegrationsServiceProvider.php">&lt;?php
namespace App\Providers;
use App\Http\Integrations\CoverArtArchive\CoverArtArchiveClient;
use App\Http\Integrations\MusicBrainz\MusicBrainzClient;
use App\Services\GuzzleService;
use Illuminate\Support\ServiceProvider;
class IntegrationsServiceProvider extends ServiceProvider
{
    /**
     * Register services.
     */
    public function register(): void
    {
        $this-&gt;app-&gt;singleton(CoverArtArchiveClient::class, function () {
            return new CoverArtArchiveClient(app(GuzzleService::class)-&gt;getClient());
        });
        $this-&gt;app-&gt;singleton(MusicBrainzClient::class, function () {
            return new MusicBrainzClient(app(GuzzleService::class)-&gt;getClient());
        });
    }
    /**
     * Bootstrap services.
     */
    public function provides(): array
    {
        return [
          CoverArtArchiveClient::class,
          MusicBrainzClient::class,
        ];
    }
}</file><file path="app/Providers/LogConfigurationServiceProvider.php">&lt;?php
namespace App\Providers;
use Illuminate\Support\ServiceProvider;
class LogConfigurationServiceProvider extends ServiceProvider
{
    /**
     * Register services.
     */
    public function register(): void
    {
        $this-&gt;configureLoggingChannels();
    }
    /**
     * Determine if the current process is a queue worker.
     *
     * @return bool
     */
    protected function isQueueWorker(): bool
    {
        return $this-&gt;app-&gt;bound(&apos;queue.worker&apos;);
    }
    /**
     * Configure logging channels dynamically.
     *
     * @return void
     */
    protected function configureLoggingChannels()
    {
        $logChannel = config(&apos;logging.default&apos;);
        if ($this-&gt;isQueueWorker()) {
            $logChannel = storage_path(&apos;logs/queue-worker.log&apos;);
            config([&apos;logging.channels.single.path&apos; =&gt; $logChannel]);
            config([&apos;logging.channels.daily.path&apos; =&gt; $logChannel]);
            config([&apos;logging.channels.emergency.path&apos; =&gt; $logChannel]);
        }
    }
}</file><file path="app/Providers/QueueMonitorProvider.php">&lt;?php
namespace App\Providers;
use App\Services\QueueMonitorService;
use Illuminate\Queue\Events\{JobExceptionOccurred, JobFailed, JobProcessed, JobProcessing, JobQueued};
use Illuminate\Queue\QueueManager;
use Illuminate\Support\Facades\Event;
use Illuminate\Support\ServiceProvider;
class QueueMonitorProvider extends ServiceProvider
{
    /**
     * Bootstrap services.
     */
    public function boot(): void
    {
        $service = app(QueueMonitorService::class);
        if (class_exists(&apos;Laravel\Horizon\Events\JobPushed&apos;)) {
            Event::listen(&apos;Laravel\Horizon\Events\JobPushed&apos;, function ($event) use ($service) {
                $service-&gt;handleJobPushed($event);
            });
        } else {
            Event::listen(JobQueued::class, function (JobQueued $event) use ($service) {
                $service-&gt;handleJobQueued($event);
            });
        }
        $manager = app(QueueManager::class);
        $manager-&gt;before(function (JobProcessing $event) use ($service) {
            $service-&gt;handleJobProcessing($event);
        });
        $manager-&gt;after(function (JobProcessed $event) use ($service) {
            $service-&gt;handleJobProcessed($event);
        });
        $manager-&gt;failing(function (JobFailed $event) use ($service) {
            $service-&gt;handleJobFailed($event);
        });
        $manager-&gt;exceptionOccurred(function (JobExceptionOccurred $event) use ($service) {
            $service-&gt;handleJobExceptionOccurred($event);
        });
    }
}</file><file path="app/Providers/RecommendationServiceProvider.php">&lt;?php
namespace App\Providers;
use App\Modules\Recommendation\Calculators\ContentBasedCalculator;
use App\Modules\Recommendation\Calculators\DatabaseRelationCalculator;
use App\Modules\Recommendation\Calculators\SimilarityCalculator;
use App\Modules\Recommendation\Services\RecommendationService;
use Illuminate\Support\ServiceProvider;
class RecommendationServiceProvider extends ServiceProvider
{
    /**
     * Register services.
     *
     * @return void
     */
    public function register()
    {
        $this-&gt;app-&gt;singleton(RecommendationService::class, function ($app) {
            $service = new RecommendationService($app[&apos;log&apos;]);
            // Register the calculators
            $service-&gt;registerCalculator(&apos;db_relation&apos;, new DatabaseRelationCalculator());
            $service-&gt;registerCalculator(&apos;similarity&apos;, new SimilarityCalculator());
            $service-&gt;registerCalculator(&apos;content_based&apos;, new ContentBasedCalculator());
            return $service;
        });
    }
    /**
     * Bootstrap services.
     *
     * @return void
     */
    public function boot()
    {
        //
    }
}</file><file path="app/Providers/StreamServiceProvider.php">&lt;?php
namespace App\Providers;
use Illuminate\Support\ServiceProvider;
use App\Services\Streaming\StreamService;
use App\Services\Streaming\Handlers\HLSStreamService;
use App\Services\Streaming\Handlers\DASHStreamService;
use Baander\Transcoder\Application;
use Amp\Redis\RedisClient;
use Amp\Redis\RedisConfig;
class StreamServiceProvider extends ServiceProvider
{
    public function register()
    {
        $this-&gt;app-&gt;scoped(StreamService::class, function ($app) {
            $protocolHandlers = [
                &apos;hls&apos; =&gt; $app-&gt;make(HLSStreamService::class),
                &apos;dash&apos; =&gt; $app-&gt;make(DASHStreamService::class),
                // Add RTMP, WebRTC, or other protocols here
            ];
            return new StreamService($protocolHandlers);
        });
        $this-&gt;app-&gt;scoped(HLSStreamService::class, function ($app) {
            return new HLSStreamService($app-&gt;make(Application::class));
        });
        $this-&gt;app-&gt;scoped(DASHStreamService::class, function ($app) {
            return new DASHStreamService($app-&gt;make(Application::class));
        });
    }
}</file><file path="app/Services/DownloadService.php">&lt;?php
namespace App\Services;
class DownloadService
{
    public function __construct(private readonly GuzzleService $guzzleService)
    {
    }
    public function downloadUrl(string $url): mixed
    {
        $response = $this-&gt;guzzleService-&gt;getAsync($url);
        return $response-&gt;wait();
    }
}</file><file path="app/Services/GuzzleService.php">&lt;?php
namespace App\Services;
use GuzzleHttp\Client;
use GuzzleHttp\Promise\PromiseInterface;
class GuzzleService
{
    private static ?Client $client = null;
    public function getClient(): Client
    {
        return static::$client ?? new Client([
            &apos;timeout&apos;     =&gt; 10.0,
            &apos;http_errors&apos; =&gt; false,
        ]);
    }
    public function getAsync(string $uri, array $options = []): PromiseInterface
    {
        return $this-&gt;getClient()-&gt;getAsync($uri, $options);
    }
    public function postAsync(string $uri, array $options = []): PromiseInterface
    {
        return $this-&gt;getClient()-&gt;postAsync($uri, $options);
    }
}</file><file path="app/Services/Metadata/LocalMetadataService.php">&lt;?php
namespace App\Services\Metadata;
use App\Models\Album;
use Illuminate\Support\Facades\Log;
class LocalMetadataService
{
    /**
     * Enhance album metadata using local data analysis
     */
    public function enhanceAlbumMetadata(Album $album): array
    {
        $results = [
            &apos;album&apos; =&gt; null,
            &apos;artists&apos; =&gt; [],
            &apos;songs&apos; =&gt; [],
            &apos;genres&apos; =&gt; [],
            &apos;quality_score&apos; =&gt; 0.3, // Lower than external sources but better than nothing
            &apos;source&apos; =&gt; &apos;local_analysis&apos;,
        ];
        try {
            // Analyze album based on existing data
            $albumData = $this-&gt;analyzeAlbumData($album);
            $genresData = $this-&gt;analyzeGenres($album);
            $artistsData = $this-&gt;analyzeArtists($album);
            $songsData = $this-&gt;analyzeSongs($album);
            $results = [
                &apos;album&apos; =&gt; $albumData,
                &apos;artists&apos; =&gt; $artistsData,
                &apos;songs&apos; =&gt; $songsData,
                &apos;genres&apos; =&gt; $genresData,
                &apos;quality_score&apos; =&gt; $this-&gt;calculateLocalQualityScore($album),
                &apos;source&apos; =&gt; &apos;local_analysis&apos;,
            ];
            Log::info(&apos;Local metadata enhancement completed&apos;, [
                &apos;album_id&apos; =&gt; $album-&gt;id,
                &apos;genres_found&apos; =&gt; count($genresData),
                &apos;quality_score&apos; =&gt; $results[&apos;quality_score&apos;]
            ]);
        } catch (\Exception $e) {
            Log::error(&apos;Local metadata enhancement failed&apos;, [
                &apos;album_id&apos; =&gt; $album-&gt;id,
                &apos;error&apos; =&gt; $e-&gt;getMessage()
            ]);
        }
        return $results;
    }
    private function analyzeAlbumData(Album $album): array
    {
        return [
            &apos;title&apos; =&gt; $album-&gt;title,
            &apos;year&apos; =&gt; $album-&gt;year,
            &apos;track_count&apos; =&gt; $album-&gt;songs()-&gt;count(),
            &apos;total_duration&apos; =&gt; $album-&gt;songs()-&gt;sum(&apos;length&apos;),
            &apos;external_source&apos; =&gt; &apos;local_analysis&apos;,
        ];
    }
    private function analyzeGenres(Album $album): array
    {
        // Analyze genres from song metadata or file metadata
        $genres = [];
        // Get genres from associated songs
        $songGenres = $album-&gt;songs()
            -&gt;whereNotNull(&apos;genre&apos;)
            -&gt;pluck(&apos;genre&apos;)
            -&gt;flatMap(function ($genre) {
                return explode(&apos;,&apos;, $genre);
            })
            -&gt;map(function ($genre) {
                return trim($genre);
            })
            -&gt;filter()
            -&gt;unique()
            -&gt;values()
            -&gt;toArray();
        $genres = array_merge($genres, $songGenres);
        // For Thai music, try to detect common Thai genres
        $thaiGenres = $this-&gt;detectThaiGenres($album);
        $genres = array_merge($genres, $thaiGenres);
        return array_unique($genres);
    }
    private function detectThaiGenres(Album $album): array
    {
        $genres = [];
        $title = strtolower($album-&gt;title);
        $artistName = strtolower($album-&gt;artists-&gt;first()-&gt;name ?? &apos;&apos;);
        // Simple heuristics for Thai music genres
        if (preg_match(&apos;/[\p{Thai}]/u&apos;, $album-&gt;title) || preg_match(&apos;/[\p{Thai}]/u&apos;, $artistName)) {
            // If contains Thai characters, likely Thai music
            $genres[] = &apos;Thai Pop&apos;;
            // Additional heuristics based on common Thai words or patterns
            if (str_contains($title, &apos;ลูกทุ่ง&apos;)) {
                $genres[] = &apos;Luk Thung&apos;;
            } elseif (str_contains($title, &apos;มอลำ&apos;)) {
                $genres[] = &apos;Mor Lam&apos;;
            } elseif (str_contains($title, &apos;สตริง&apos;)) {
                $genres[] = &apos;String&apos;;
            }
        }
        // Analyze numeric artist names (common in Thai indie scene)
        if (preg_match(&apos;/^\d+$/&apos;, $artistName)) {
            $genres[] = &apos;Indie&apos;;
            $genres[] = &apos;Alternative&apos;;
        }
        return $genres;
    }
    private function analyzeArtists(Album $album): array
    {
        return $album-&gt;artists-&gt;map(function ($artist) {
            return [
                &apos;name&apos; =&gt; $artist-&gt;name,
                &apos;album_count&apos; =&gt; $artist-&gt;albums()-&gt;count(),
                &apos;song_count&apos; =&gt; $artist-&gt;songs()-&gt;count(),
                &apos;external_source&apos; =&gt; &apos;local_analysis&apos;,
            ];
        })-&gt;toArray();
    }
    private function analyzeSongs(Album $album): array
    {
        return $album-&gt;songs-&gt;map(function ($song) {
            return [
                &apos;title&apos; =&gt; $song-&gt;title,
                &apos;track&apos; =&gt; $song-&gt;track,
                &apos;length&apos; =&gt; $song-&gt;length,
                &apos;file_format&apos; =&gt; pathinfo($song-&gt;file_path, PATHINFO_EXTENSION),
                &apos;external_source&apos; =&gt; &apos;local_analysis&apos;,
            ];
        })-&gt;toArray();
    }
    private function calculateLocalQualityScore(Album $album): float
    {
        $score = 0.1; // Base score
        // Add points for available data
        if ($album-&gt;year) $score += 0.1;
        if ($album-&gt;artists-&gt;isNotEmpty()) $score += 0.1;
        if ($album-&gt;songs-&gt;isNotEmpty()) $score += 0.1;
        // Add points for data richness
        $songCount = $album-&gt;songs()-&gt;count();
        if ($songCount &gt; 0) $score += min(0.2, $songCount * 0.02);
        // Add points for metadata completeness
        $songsWithLength = $album-&gt;songs()-&gt;whereNotNull(&apos;length&apos;)-&gt;count();
        if ($songCount &gt; 0 &amp;&amp; $songsWithLength &gt; 0) {
            $score += ($songsWithLength / $songCount) * 0.2;
        }
        return min($score, 0.6); // Cap at 0.6 for local analysis
    }
}</file><file path="app/Services/Metadata/MetadataSyncService.php">&lt;?php
namespace App\Services\Metadata;
use App\Models\{Album, Artist, Song};
use App\Services\Metadata\Search\{
    AlbumSearchService,
    ArtistSearchService,
    SongSearchService
};
use App\Services\Metadata\Processing\MetadataProcessor;
use App\Services\MetadataMatching\QualityValidator;
use App\Services\Metadata\LocalMetadataService;
use Illuminate\Support\Facades\Log;
class MetadataSyncService
{
    public function __construct(
        private readonly AlbumSearchService $albumSearchService,
        private readonly ArtistSearchService $artistSearchService,
        private readonly SongSearchService $songSearchService,
        private readonly MetadataProcessor $metadataProcessor,
        private readonly QualityValidator $qualityValidator,
        private readonly LocalMetadataService $localMetadataService
    ) {}
    /**
     * Sync metadata for a specific album
     */
    public function syncAlbum(Album $album): array
    {
        try {
            Log::debug(&apos;Starting metadata sync for album&apos;, [
                &apos;album_id&apos; =&gt; $album-&gt;id,
                &apos;title&apos; =&gt; $album-&gt;title,
                &apos;artists&apos; =&gt; $album-&gt;artists-&gt;pluck(&apos;name&apos;)-&gt;toArray()
            ]);
            $searchResults = $this-&gt;albumSearchService-&gt;searchAllSources($album);
            $bestMatch = $this-&gt;selectBestMatch($searchResults);
            if ($bestMatch) {
                $results = $this-&gt;metadataProcessor-&gt;processAlbumMetadata($bestMatch, $album);
                Log::debug(&apos;Album metadata processed successfully&apos;, [
                    &apos;album_id&apos; =&gt; $album-&gt;id,
                    &apos;source&apos; =&gt; $results[&apos;source&apos;],
                    &apos;quality_score&apos; =&gt; $results[&apos;quality_score&apos;]
                ]);
                return $results;
            }
            // Fallback to local metadata analysis
            Log::debug(&apos;No external match found, using local analysis&apos;, [&apos;album_id&apos; =&gt; $album-&gt;id]);
            return $this-&gt;localMetadataService-&gt;enhanceAlbumMetadata($album);
        } catch (\Exception $e) {
            Log::error(&apos;Album metadata sync failed&apos;, [
                &apos;album_id&apos; =&gt; $album-&gt;id,
                &apos;error&apos; =&gt; $e-&gt;getMessage()
            ]);
            return $this-&gt;getEmptyAlbumResult();
        }
    }
    /**
     * Sync metadata for a specific artist
     */
    public function syncArtist(Artist $artist): array
    {
        try {
            Log::debug(&apos;Starting metadata sync for artist&apos;, [
                &apos;artist_id&apos; =&gt; $artist-&gt;id,
                &apos;name&apos; =&gt; $artist-&gt;name
            ]);
            $searchResults = $this-&gt;artistSearchService-&gt;searchAllSources($artist);
            $bestMatch = $this-&gt;selectBestMatch($searchResults);
            if ($bestMatch) {
                $results = $this-&gt;metadataProcessor-&gt;processArtistMetadata($bestMatch, $artist);
                Log::debug(&apos;Artist metadata processed successfully&apos;, [
                    &apos;artist_id&apos; =&gt; $artist-&gt;id,
                    &apos;source&apos; =&gt; $results[&apos;source&apos;],
                    &apos;quality_score&apos; =&gt; $results[&apos;quality_score&apos;]
                ]);
                return $results;
            }
            Log::debug(&apos;No suitable match found for artist&apos;, [&apos;artist_id&apos; =&gt; $artist-&gt;id]);
            return $this-&gt;getEmptyArtistResult();
        } catch (\Exception $e) {
            Log::error(&apos;Artist metadata sync failed&apos;, [
                &apos;artist_id&apos; =&gt; $artist-&gt;id,
                &apos;error&apos; =&gt; $e-&gt;getMessage()
            ]);
            return $this-&gt;getEmptyArtistResult();
        }
    }
    /**
     * Sync metadata for a specific song
     */
    public function syncSong(Song $song): array
    {
        try {
            Log::debug(&apos;Starting metadata sync for song&apos;, [
                &apos;song_id&apos; =&gt; $song-&gt;id,
                &apos;title&apos; =&gt; $song-&gt;title,
                &apos;album&apos; =&gt; $song-&gt;album?-&gt;title
            ]);
            $searchResults = $this-&gt;songSearchService-&gt;searchAllSources($song);
            $bestMatch = $this-&gt;selectBestMatch($searchResults);
            if ($bestMatch) {
                $results = $this-&gt;metadataProcessor-&gt;processSongMetadata($bestMatch, $song);
                Log::debug(&apos;Song metadata processed successfully&apos;, [
                    &apos;song_id&apos; =&gt; $song-&gt;id,
                    &apos;source&apos; =&gt; $results[&apos;source&apos;],
                    &apos;quality_score&apos; =&gt; $results[&apos;quality_score&apos;]
                ]);
                return $results;
            }
            Log::debug(&apos;No suitable match found for song&apos;, [&apos;song_id&apos; =&gt; $song-&gt;id]);
            return $this-&gt;getEmptySongResult();
        } catch (\Exception $e) {
            Log::error(&apos;Song metadata sync failed&apos;, [
                &apos;song_id&apos; =&gt; $song-&gt;id,
                &apos;error&apos; =&gt; $e-&gt;getMessage()
            ]);
            return $this-&gt;getEmptySongResult();
        }
    }
    /**
     * Batch sync entire album with all its songs
     */
    public function syncAlbumComplete(Album $album): array
    {
        Log::info(&apos;Starting complete album sync&apos;, [&apos;album_id&apos; =&gt; $album-&gt;id]);
        // 1. Sync album metadata
        $albumResult = $this-&gt;syncAlbum($album);
        // 2. Sync artist metadata
        $artistResults = [];
        foreach ($album-&gt;artists as $artist) {
            $artistResults[$artist-&gt;id] = $this-&gt;syncArtist($artist);
        }
        // 3. Sync song metadata (with album context)
        $songResults = [];
        foreach ($album-&gt;songs as $song) {
            $songResults[$song-&gt;id] = $this-&gt;songSearchService-&gt;searchWithAlbumContext($song, $albumResult);
        }
        return [
            &apos;album&apos; =&gt; $albumResult,
            &apos;artists&apos; =&gt; $artistResults,
            &apos;songs&apos; =&gt; $songResults,
            &apos;summary&apos; =&gt; [
                &apos;total_songs&apos; =&gt; count($songResults),
                &apos;successful_songs&apos; =&gt; count(array_filter($songResults, fn($r) =&gt; ($r[&apos;quality_score&apos;] ?? 0) &gt; 0)),
                &apos;total_artists&apos; =&gt; count($artistResults),
                &apos;successful_artists&apos; =&gt; count(array_filter($artistResults, fn($r) =&gt; ($r[&apos;quality_score&apos;] ?? 0) &gt; 0)),
                &apos;album_quality&apos; =&gt; $albumResult[&apos;quality_score&apos;] ?? 0
            ]
        ];
    }
    /**
     * Select the best match from multiple search results
     */
    private function selectBestMatch(array $searchResults): ?array
    {
        $validResults = array_filter($searchResults, fn($result) =&gt; $result !== null);
        if (empty($validResults)) {
            return null;
        }
        if (count($validResults) === 1) {
            return reset($validResults);
        }
        // Return the result with the highest quality score
        return collect($validResults)
            -&gt;sortByDesc(&apos;quality_score&apos;)
            -&gt;first();
    }
    private function getEmptyAlbumResult(): array
    {
        return [
            &apos;album&apos; =&gt; null,
            &apos;artists&apos; =&gt; [],
            &apos;songs&apos; =&gt; [],
            &apos;genres&apos; =&gt; [],
            &apos;quality_score&apos; =&gt; 0,
            &apos;source&apos; =&gt; null,
        ];
    }
    private function getEmptyArtistResult(): array
    {
        return [
            &apos;artist&apos; =&gt; null,
            &apos;albums&apos; =&gt; [],
            &apos;quality_score&apos; =&gt; 0,
            &apos;source&apos; =&gt; null,
        ];
    }
    private function getEmptySongResult(): array
    {
        return [
            &apos;song&apos; =&gt; null,
            &apos;artists&apos; =&gt; [],
            &apos;genres&apos; =&gt; [],
            &apos;lyrics&apos; =&gt; null,
            &apos;quality_score&apos; =&gt; 0,
            &apos;source&apos; =&gt; null,
        ];
    }
}</file><file path="app/Services/Metadata/Processing/MetadataProcessor.php">&lt;?php
namespace App\Services\Metadata\Processing;
use App\Models\{Album, Artist, Song};
class MetadataProcessor
{
    public function processAlbumMetadata(array $metadata, Album $album): array
    {
        $data = $metadata[&apos;data&apos;];
        $source = $metadata[&apos;source&apos;];
        return [
            &apos;album&apos; =&gt; $this-&gt;extractAlbumData($data, $source),
            &apos;artists&apos; =&gt; $this-&gt;extractArtistsData($data, $source),
            &apos;songs&apos; =&gt; $this-&gt;extractSongsData($data, $source, $album),
            &apos;genres&apos; =&gt; $this-&gt;extractGenresData($data, $source),
            &apos;quality_score&apos; =&gt; $metadata[&apos;quality_score&apos;],
            &apos;source&apos; =&gt; $source,
        ];
    }
    public function processArtistMetadata(array $metadata, Artist $artist): array
    {
        $data = $metadata[&apos;data&apos;];
        $source = $metadata[&apos;source&apos;];
        return [
            &apos;artist&apos; =&gt; $this-&gt;extractArtistData($data, $source),
            &apos;albums&apos; =&gt; $this-&gt;extractArtistAlbumsData($data, $source),
            &apos;quality_score&apos; =&gt; $metadata[&apos;quality_score&apos;],
            &apos;source&apos; =&gt; $source,
        ];
    }
    public function processSongMetadata(array $metadata, Song $song): array
    {
        $data = $metadata[&apos;data&apos;];
        $source = $metadata[&apos;source&apos;];
        return [
            &apos;song&apos; =&gt; $this-&gt;extractSongData($data, $source),
            &apos;artists&apos; =&gt; $this-&gt;extractSongArtistsData($data, $source),
            &apos;genres&apos; =&gt; $this-&gt;extractSongGenresData($data, $source),
            &apos;lyrics&apos; =&gt; $this-&gt;extractLyricsData($data, $source),
            &apos;quality_score&apos; =&gt; $metadata[&apos;quality_score&apos;],
            &apos;source&apos; =&gt; $source,
        ];
    }
    private function extractAlbumData(array $data, string $source): array
    {
        return match ($source) {
            &apos;musicbrainz&apos; =&gt; [
                &apos;title&apos; =&gt; $data[&apos;title&apos;] ?? null,
                &apos;year&apos; =&gt; isset($data[&apos;date&apos;]) ? (int)substr($data[&apos;date&apos;], 0, 4) : null,
                &apos;external_id&apos; =&gt; $data[&apos;id&apos;] ?? null,
                &apos;external_source&apos; =&gt; &apos;musicbrainz&apos;,
                &apos;barcode&apos; =&gt; $data[&apos;barcode&apos;] ?? null,
                &apos;status&apos; =&gt; $data[&apos;status&apos;] ?? null,
                &apos;packaging&apos; =&gt; $data[&apos;packaging&apos;] ?? null,
                &apos;label&apos; =&gt; isset($data[&apos;label-info&apos;][0][&apos;label&apos;][&apos;name&apos;]) ? $data[&apos;label-info&apos;][0][&apos;label&apos;][&apos;name&apos;] : null,
                &apos;catalog_number&apos; =&gt; $data[&apos;label-info&apos;][0][&apos;catalog-number&apos;] ?? null,
                &apos;country&apos; =&gt; $data[&apos;country&apos;] ?? null,
                &apos;disambiguation&apos; =&gt; $data[&apos;disambiguation&apos;] ?? null,
            ],
            &apos;discogs&apos; =&gt; [
                &apos;title&apos; =&gt; $data[&apos;title&apos;] ?? null,
                &apos;year&apos; =&gt; $data[&apos;year&apos;] ?? null,
                &apos;external_id&apos; =&gt; $data[&apos;id&apos;] ?? null,
                &apos;external_source&apos; =&gt; &apos;discogs&apos;,
                &apos;label&apos; =&gt; isset($data[&apos;labels&apos;][0][&apos;name&apos;]) ? $data[&apos;labels&apos;][0][&apos;name&apos;] : null,
                &apos;catalog_number&apos; =&gt; $data[&apos;labels&apos;][0][&apos;catno&apos;] ?? null,
                &apos;format&apos; =&gt; isset($data[&apos;formats&apos;][0][&apos;name&apos;]) ? $data[&apos;formats&apos;][0][&apos;name&apos;] : null,
                &apos;country&apos; =&gt; $data[&apos;country&apos;] ?? null,
                &apos;notes&apos; =&gt; $data[&apos;notes&apos;] ?? null,
                &apos;master_id&apos; =&gt; $data[&apos;master_id&apos;] ?? null,
            ],
            default =&gt; [],
        };
    }
    private function extractArtistsData(array $data, string $source): array
    {
        $artists = [];
        switch ($source) {
            case &apos;musicbrainz&apos;:
                if (isset($data[&apos;artist-credit&apos;])) {
                    foreach ($data[&apos;artist-credit&apos;] as $credit) {
                        if (isset($credit[&apos;artist&apos;])) {
                            $artists[] = [
                                &apos;name&apos; =&gt; $credit[&apos;artist&apos;][&apos;name&apos;],
                                &apos;external_id&apos; =&gt; $credit[&apos;artist&apos;][&apos;id&apos;],
                                &apos;external_source&apos; =&gt; &apos;musicbrainz&apos;,
                                &apos;sort_name&apos; =&gt; $credit[&apos;artist&apos;][&apos;sort-name&apos;] ?? null,
                                &apos;disambiguation&apos; =&gt; $credit[&apos;artist&apos;][&apos;disambiguation&apos;] ?? null,
                                &apos;type&apos; =&gt; $credit[&apos;artist&apos;][&apos;type&apos;] ?? null,
                                &apos;join_phrase&apos; =&gt; $credit[&apos;joinphrase&apos;] ?? null,
                            ];
                        }
                    }
                }
                break;
            case &apos;discogs&apos;:
                if (isset($data[&apos;artists&apos;])) {
                    foreach ($data[&apos;artists&apos;] as $artist) {
                        $artists[] = [
                            &apos;name&apos; =&gt; $artist[&apos;name&apos;],
                            &apos;external_id&apos; =&gt; $artist[&apos;id&apos;] ?? null,
                            &apos;external_source&apos; =&gt; &apos;discogs&apos;,
                            &apos;role&apos; =&gt; $artist[&apos;role&apos;] ?? null,
                            &apos;join&apos; =&gt; $artist[&apos;join&apos;] ?? null,
                            &apos;anv&apos; =&gt; $artist[&apos;anv&apos;] ?? null, // Artist Name Variation
                        ];
                    }
                }
                break;
        }
        return $artists;
    }
    private function extractSongsData(array $data, string $source, Album $album): array
    {
        $songs = [];
        switch ($source) {
            case &apos;musicbrainz&apos;:
                if (isset($data[&apos;media&apos;])) {
                    $trackNumber = 1;
                    foreach ($data[&apos;media&apos;] as $medium) {
                        if (isset($medium[&apos;tracks&apos;])) {
                            foreach ($medium[&apos;tracks&apos;] as $track) {
                                $songs[] = [
                                    &apos;title&apos; =&gt; $track[&apos;title&apos;],
                                    &apos;track&apos; =&gt; $track[&apos;position&apos;] ?? $trackNumber,
                                    &apos;length&apos; =&gt; isset($track[&apos;length&apos;]) ? (int)$track[&apos;length&apos;] : null,
                                    &apos;external_id&apos; =&gt; $track[&apos;recording&apos;][&apos;id&apos;] ?? null,
                                    &apos;external_source&apos; =&gt; &apos;musicbrainz&apos;,
                                    &apos;disc&apos; =&gt; $medium[&apos;position&apos;] ?? 1,
                                    &apos;isrc&apos; =&gt; $track[&apos;recording&apos;][&apos;isrcs&apos;][0] ?? null,
                                ];
                                $trackNumber++;
                            }
                        }
                    }
                }
                break;
            case &apos;discogs&apos;:
                if (isset($data[&apos;tracklist&apos;])) {
                    foreach ($data[&apos;tracklist&apos;] as $track) {
                        $songs[] = [
                            &apos;title&apos; =&gt; $track[&apos;title&apos;],
                            &apos;track&apos; =&gt; $track[&apos;position&apos;] ?? null,
                            &apos;length&apos; =&gt; isset($track[&apos;duration&apos;]) ? $this-&gt;parseDuration($track[&apos;duration&apos;]) : null,
                            &apos;external_source&apos; =&gt; &apos;discogs&apos;,
                            &apos;type&apos; =&gt; $track[&apos;type_&apos;] ?? &apos;track&apos;,
                        ];
                    }
                }
                break;
        }
        return $songs;
    }
    private function extractGenresData(array $data, string $source): array
    {
        $genres = [];
        switch ($source) {
            case &apos;musicbrainz&apos;:
                if (isset($data[&apos;genres&apos;])) {
                    foreach ($data[&apos;genres&apos;] as $genre) {
                        $genres[] = $genre[&apos;name&apos;] ?? $genre;
                    }
                }
                if (isset($data[&apos;tags&apos;])) {
                    foreach ($data[&apos;tags&apos;] as $tag) {
                        if (($tag[&apos;count&apos;] ?? 0) &gt; 0) { // Only include tags with positive count
                            $genres[] = $tag[&apos;name&apos;];
                        }
                    }
                }
                break;
            case &apos;discogs&apos;:
                if (isset($data[&apos;genres&apos;])) {
                    $genres = array_merge($genres, $data[&apos;genres&apos;]);
                }
                if (isset($data[&apos;styles&apos;])) {
                    $genres = array_merge($genres, $data[&apos;styles&apos;]);
                }
                break;
        }
        return array_unique(array_filter($genres));
    }
    private function extractArtistData(array $data, string $source): array
    {
        return match ($source) {
            &apos;musicbrainz&apos; =&gt; [
                &apos;name&apos; =&gt; $data[&apos;name&apos;] ?? null,
                &apos;sort_name&apos; =&gt; $data[&apos;sort-name&apos;] ?? null,
                &apos;type&apos; =&gt; $data[&apos;type&apos;] ?? null,
                &apos;gender&apos; =&gt; $data[&apos;gender&apos;] ?? null,
                &apos;country&apos; =&gt; $data[&apos;country&apos;] ?? null,
                &apos;area&apos; =&gt; $data[&apos;area&apos;][&apos;name&apos;] ?? null,
                &apos;begin_area&apos; =&gt; $data[&apos;begin-area&apos;][&apos;name&apos;] ?? null,
                &apos;life_span_begin&apos; =&gt; $data[&apos;life-span&apos;][&apos;begin&apos;] ?? null,
                &apos;life_span_end&apos; =&gt; $data[&apos;life-span&apos;][&apos;end&apos;] ?? null,
                &apos;life_span_ended&apos; =&gt; $data[&apos;life-span&apos;][&apos;ended&apos;] ?? false,
                &apos;disambiguation&apos; =&gt; $data[&apos;disambiguation&apos;] ?? null,
                &apos;external_id&apos; =&gt; $data[&apos;id&apos;] ?? null,
                &apos;external_source&apos; =&gt; &apos;musicbrainz&apos;,
            ],
            &apos;discogs&apos; =&gt; [
                &apos;name&apos; =&gt; $data[&apos;name&apos;] ?? null,
                &apos;real_name&apos; =&gt; $data[&apos;realname&apos;] ?? null,
                &apos;profile&apos; =&gt; $data[&apos;profile&apos;] ?? null,
                &apos;external_id&apos; =&gt; $data[&apos;id&apos;] ?? null,
                &apos;external_source&apos; =&gt; &apos;discogs&apos;,
                &apos;data_quality&apos; =&gt; $data[&apos;data_quality&apos;] ?? null,
                &apos;name_variations&apos; =&gt; $data[&apos;namevariations&apos;] ?? [],
                &apos;aliases&apos; =&gt; isset($data[&apos;aliases&apos;]) ? array_column($data[&apos;aliases&apos;], &apos;name&apos;) : [],
                &apos;urls&apos; =&gt; $data[&apos;urls&apos;] ?? [],
            ],
            default =&gt; [],
        };
    }
    private function extractArtistAlbumsData(array $data, string $source): array
    {
        $albums = [];
        switch ($source) {
            case &apos;musicbrainz&apos;:
                if (isset($data[&apos;release-groups&apos;])) {
                    foreach ($data[&apos;release-groups&apos;] as $releaseGroup) {
                        $albums[] = [
                            &apos;title&apos; =&gt; $releaseGroup[&apos;title&apos;],
                            &apos;type&apos; =&gt; $releaseGroup[&apos;primary-type&apos;] ?? null,
                            &apos;secondary_types&apos; =&gt; $releaseGroup[&apos;secondary-types&apos;] ?? [],
                            &apos;first_release_date&apos; =&gt; $releaseGroup[&apos;first-release-date&apos;] ?? null,
                            &apos;external_id&apos; =&gt; $releaseGroup[&apos;id&apos;],
                            &apos;external_source&apos; =&gt; &apos;musicbrainz&apos;,
                            &apos;disambiguation&apos; =&gt; $releaseGroup[&apos;disambiguation&apos;] ?? null,
                        ];
                    }
                }
                break;
            case &apos;discogs&apos;:
                if (isset($data[&apos;releases&apos;])) {
                    foreach ($data[&apos;releases&apos;] as $release) {
                        $albums[] = [
                            &apos;title&apos; =&gt; $release[&apos;title&apos;],
                            &apos;year&apos; =&gt; $release[&apos;year&apos;] ?? null,
                            &apos;format&apos; =&gt; $release[&apos;format&apos;] ?? null,
                            &apos;label&apos; =&gt; $release[&apos;label&apos;] ?? null,
                            &apos;catalog_number&apos; =&gt; $release[&apos;catno&apos;] ?? null,
                            &apos;external_id&apos; =&gt; $release[&apos;id&apos;],
                            &apos;external_source&apos; =&gt; &apos;discogs&apos;,
                            &apos;role&apos; =&gt; $release[&apos;role&apos;] ?? null,
                            &apos;type&apos; =&gt; $release[&apos;type&apos;] ?? null,
                        ];
                    }
                }
                break;
        }
        return $albums;
    }
    private function extractSongData(array $data, string $source): array
    {
        return match ($source) {
            &apos;musicbrainz&apos; =&gt; [
                &apos;title&apos; =&gt; $data[&apos;title&apos;] ?? null,
                &apos;length&apos; =&gt; isset($data[&apos;length&apos;]) ? (int)$data[&apos;length&apos;] : null,
                &apos;external_id&apos; =&gt; $data[&apos;id&apos;] ?? null,
                &apos;external_source&apos; =&gt; &apos;musicbrainz&apos;,
                &apos;disambiguation&apos; =&gt; $data[&apos;disambiguation&apos;] ?? null,
                &apos;isrc&apos; =&gt; $data[&apos;isrcs&apos;][0] ?? null,
            ],
            &apos;discogs&apos; =&gt; [
                &apos;title&apos; =&gt; $data[&apos;title&apos;] ?? null,
                &apos;length&apos; =&gt; isset($data[&apos;duration&apos;]) ? $this-&gt;parseDuration($data[&apos;duration&apos;]) : null,
                &apos;external_source&apos; =&gt; &apos;discogs&apos;,
                &apos;type&apos; =&gt; $data[&apos;type_&apos;] ?? &apos;track&apos;,
                &apos;position&apos; =&gt; $data[&apos;position&apos;] ?? null,
            ],
            default =&gt; [],
        };
    }
    private function extractSongArtistsData(array $data, string $source): array
    {
        $artists = [];
        switch ($source) {
            case &apos;musicbrainz&apos;:
                if (isset($data[&apos;artist-credit&apos;])) {
                    foreach ($data[&apos;artist-credit&apos;] as $credit) {
                        if (isset($credit[&apos;artist&apos;])) {
                            $artists[] = [
                                &apos;name&apos; =&gt; $credit[&apos;artist&apos;][&apos;name&apos;],
                                &apos;external_id&apos; =&gt; $credit[&apos;artist&apos;][&apos;id&apos;],
                                &apos;external_source&apos; =&gt; &apos;musicbrainz&apos;,
                                &apos;join_phrase&apos; =&gt; $credit[&apos;joinphrase&apos;] ?? null,
                            ];
                        }
                    }
                }
                break;
            case &apos;discogs&apos;:
                if (isset($data[&apos;release_artists&apos;])) {
                    foreach ($data[&apos;release_artists&apos;] as $artist) {
                        $artists[] = [
                            &apos;name&apos; =&gt; is_array($artist) ? $artist[&apos;name&apos;] : $artist,
                            &apos;external_id&apos; =&gt; is_array($artist) ? ($artist[&apos;id&apos;] ?? null) : null,
                            &apos;external_source&apos; =&gt; &apos;discogs&apos;,
                        ];
                    }
                }
                break;
        }
        return $artists;
    }
    private function extractSongGenresData(array $data, string $source): array
    {
        $genres = [];
        switch ($source) {
            case &apos;musicbrainz&apos;:
                if (isset($data[&apos;genres&apos;])) {
                    foreach ($data[&apos;genres&apos;] as $genre) {
                        $genres[] = $genre[&apos;name&apos;] ?? $genre;
                    }
                }
                if (isset($data[&apos;tags&apos;])) {
                    foreach ($data[&apos;tags&apos;] as $tag) {
                        if (($tag[&apos;count&apos;] ?? 0) &gt; 0) {
                            $genres[] = $tag[&apos;name&apos;];
                        }
                    }
                }
                break;
            case &apos;discogs&apos;:
                if (isset($data[&apos;release_genres&apos;])) {
                    $genres = array_merge($genres, $data[&apos;release_genres&apos;]);
                }
                break;
        }
        return array_unique(array_filter($genres));
    }
    private function extractLyricsData(array $data, string $source): ?string
    {
        // Neither MusicBrainz nor Discogs typically provide lyrics
        // This could be extended to integrate with lyrics services
        return null;
    }
    /**
     * Parse duration string from various formats to milliseconds
     */
    private function parseDuration(string $duration): ?int
    {
        // Handle formats like &quot;3:45&quot;, &quot;3:45.123&quot;, &quot;225000&quot; (ms), etc.
        if (is_numeric($duration)) {
            return (int)$duration;
        }
        if (preg_match(&apos;/^(\d+):(\d+)(?:\.(\d+))?$/&apos;, $duration, $matches)) {
            $minutes = (int)$matches[1];
            $seconds = (int)$matches[2];
            $milliseconds = isset($matches[3]) ? (int)str_pad($matches[3], 3, &apos;0&apos;) : 0;
            return ($minutes * 60 + $seconds) * 1000 + $milliseconds;
        }
        return null;
    }
}</file><file path="app/Services/Metadata/Search/AlbumSearchService.php">&lt;?php
namespace App\Services\Metadata\Search;
use App\Models\Album;
use App\Http\Integrations\MusicBrainz\MusicBrainzClient;
use App\Http\Integrations\Discogs\DiscogsClient;
use App\Http\Integrations\MusicBrainz\Filters\ReleaseFilter as MusicBrainzReleaseFilter;
use App\Http\Integrations\Discogs\Filters\ReleaseFilter as DiscogsReleaseFilter;
use App\Services\MetadataMatching\{MatchingStrategy, QualityValidator};
use Illuminate\Support\Facades\Log;
class AlbumSearchService
{
    public function __construct(
        private readonly MusicBrainzClient $musicBrainzClient,
        private readonly DiscogsClient $discogsClient,
        private readonly MatchingStrategy $matchingStrategy,
        private readonly QualityValidator $qualityValidator
    ) {}
    /**
     * Search all sources for album metadata
     */
    public function searchAllSources(Album $album): array
    {
        return [
            &apos;musicbrainz&apos; =&gt; $this-&gt;searchMusicBrainz($album),
            &apos;discogs&apos; =&gt; $this-&gt;searchDiscogs($album),
        ];
    }
    /**
     * Search MusicBrainz for album
     */
    public function searchMusicBrainz(Album $album): ?array
    {
        try {
            $filter = new MusicBrainzReleaseFilter();
            $filter-&gt;setTitle($album-&gt;title);
            if ($album-&gt;artists-&gt;isNotEmpty()) {
                $filter-&gt;setArtistName($album-&gt;artists-&gt;first()-&gt;name);
            }
            if ($album-&gt;year) {
                $filter-&gt;setDate($album-&gt;year);
            }
            Log::debug(&apos;Searching MusicBrainz for album&apos;, [
                &apos;album_id&apos; =&gt; $album-&gt;id,
                &apos;title&apos; =&gt; $album-&gt;title,
                &apos;artist&apos; =&gt; $album-&gt;artists-&gt;first()-&gt;name ?? null
            ]);
            $searchResults = $this-&gt;musicBrainzClient-&gt;search-&gt;release($filter);
            if ($searchResults-&gt;isEmpty()) {
                return null;
            }
            // Smart filtering using Collection methods
            $relevantResults = $searchResults
                -&gt;filter(fn($release) =&gt; $this-&gt;isRelevantMatch($release, $album))
                -&gt;sortByDesc(fn($release) =&gt; $this-&gt;calculateRelevanceScore($release, $album))
                -&gt;take(5);
            if ($relevantResults-&gt;isEmpty()) {
                return null;
            }
            $bestMatch = $relevantResults-&gt;first();
            $detailedData = $this-&gt;musicBrainzClient-&gt;lookup-&gt;release($bestMatch-&gt;id);
            return [
                &apos;source&apos; =&gt; &apos;musicbrainz&apos;,
                &apos;data&apos; =&gt; $detailedData-&gt;toArray(),
                &apos;quality_score&apos; =&gt; $this-&gt;qualityValidator-&gt;scoreAlbumMatch($detailedData-&gt;toArray(), $album),
                &apos;search_results_count&apos; =&gt; $searchResults-&gt;count(),
                &apos;filtered_results_count&apos; =&gt; $relevantResults-&gt;count()
            ];
        } catch (\Exception $e) {
            Log::warning(&apos;MusicBrainz album search failed&apos;, [
                &apos;album_id&apos; =&gt; $album-&gt;id,
                &apos;error&apos; =&gt; $e-&gt;getMessage()
            ]);
            return null;
        }
    }
    /**
     * Search Discogs for album
     */
    public function searchDiscogs(Album $album): ?array
    {
        try {
            $filter = new DiscogsReleaseFilter();
            $filter-&gt;setTitle($album-&gt;title);
            if ($album-&gt;artists-&gt;isNotEmpty()) {
                $filter-&gt;setArtist($album-&gt;artists-&gt;first()-&gt;name);
            }
            if ($album-&gt;year) {
                $filter-&gt;setYear($album-&gt;year);
            }
            Log::debug(&apos;Searching Discogs for album&apos;, [
                &apos;album_id&apos; =&gt; $album-&gt;id,
                &apos;title&apos; =&gt; $album-&gt;title,
                &apos;artist&apos; =&gt; $album-&gt;artists-&gt;first()-&gt;name ?? null
            ]);
            $searchResults = $this-&gt;discogsClient-&gt;search-&gt;release($filter);
            if ($searchResults-&gt;isEmpty()) {
                return null;
            }
            $relevantResults = $searchResults
                -&gt;filter(fn($release) =&gt; $this-&gt;isRelevantDiscogsMatch($release, $album))
                -&gt;sortByDesc(fn($release) =&gt; $this-&gt;calculateDiscogsRelevanceScore($release, $album))
                -&gt;take(5);
            if ($relevantResults-&gt;isEmpty()) {
                return null;
            }
            $bestMatch = $relevantResults-&gt;first();
            $detailedData = $this-&gt;discogsClient-&gt;lookup-&gt;release($bestMatch-&gt;id);
            return [
                &apos;source&apos; =&gt; &apos;discogs&apos;,
                &apos;data&apos; =&gt; $detailedData-&gt;toArray(),
                &apos;quality_score&apos; =&gt; $this-&gt;qualityValidator-&gt;scoreAlbumMatch($detailedData-&gt;toArray(), $album),
                &apos;search_results_count&apos; =&gt; $searchResults-&gt;count(),
                &apos;pagination&apos; =&gt; $this-&gt;discogsClient-&gt;search-&gt;getPagination()
            ];
        } catch (\Exception $e) {
            Log::warning(&apos;Discogs album search failed&apos;, [
                &apos;album_id&apos; =&gt; $album-&gt;id,
                &apos;error&apos; =&gt; $e-&gt;getMessage()
            ]);
            return null;
        }
    }
    /**
     * Advanced multi-strategy search
     */
    public function searchAdvanced(Album $album): array
    {
        Log::debug(&apos;Performing advanced search for album&apos;, [&apos;album_id&apos; =&gt; $album-&gt;id]);
        // Strategy 1: Exact title + artist
        $exactFilter = new MusicBrainzReleaseFilter();
        $exactFilter-&gt;setTitle($album-&gt;title);
        if ($album-&gt;artists-&gt;isNotEmpty()) {
            $exactFilter-&gt;setArtistName($album-&gt;artists-&gt;first()-&gt;name);
        }
        $exactResults = $this-&gt;musicBrainzClient-&gt;search-&gt;release($exactFilter);
        // Strategy 2: Title only (fuzzy)
        $fuzzyFilter = new MusicBrainzReleaseFilter();
        $fuzzyFilter-&gt;setTitle($album-&gt;title);
        $fuzzyResults = $this-&gt;musicBrainzClient-&gt;search-&gt;release($fuzzyFilter);
        // Strategy 3: Artist-based
        $artistResults = collect();
        if ($album-&gt;artists-&gt;isNotEmpty()) {
            $artistFilter = new MusicBrainzReleaseFilter();
            $artistFilter-&gt;setArtistName($album-&gt;artists-&gt;first()-&gt;name);
            $artistResults = $this-&gt;musicBrainzClient-&gt;search-&gt;release($artistFilter);
        }
        // Combine and deduplicate
        $allResults = $exactResults
            -&gt;merge($fuzzyResults)
            -&gt;merge($artistResults)
            -&gt;unique(&apos;id&apos;)
            -&gt;filter(fn($release) =&gt; $this-&gt;isRelevantMatch($release, $album))
            -&gt;sortByDesc(fn($release) =&gt; $this-&gt;calculateRelevanceScore($release, $album));
        return [
            &apos;strategies&apos; =&gt; [
                &apos;exact&apos; =&gt; [&apos;count&apos; =&gt; $exactResults-&gt;count(), &apos;results&apos; =&gt; $exactResults-&gt;take(3)],
                &apos;fuzzy&apos; =&gt; [&apos;count&apos; =&gt; $fuzzyResults-&gt;count(), &apos;results&apos; =&gt; $fuzzyResults-&gt;take(3)],
                &apos;artist&apos; =&gt; [&apos;count&apos; =&gt; $artistResults-&gt;count(), &apos;results&apos; =&gt; $artistResults-&gt;take(3)],
            ],
            &apos;combined&apos; =&gt; [
                &apos;total_count&apos; =&gt; $allResults-&gt;count(),
                &apos;top_results&apos; =&gt; $allResults-&gt;take(10),
                &apos;best_match&apos; =&gt; $allResults-&gt;first()
            ]
        ];
    }
    private function isRelevantMatch($release, Album $album): bool
    {
        if (empty($release-&gt;title)) {
            return false;
        }
        $titleSimilarity = similar_text(
            strtolower($release-&gt;title),
            strtolower($album-&gt;title)
        );
        return $titleSimilarity &gt; 50;
    }
    private function isRelevantDiscogsMatch($release, Album $album): bool
    {
        if (empty($release-&gt;title)) {
            return false;
        }
        // Discogs titles often include artist name, so be more flexible
        $titleSimilarity = similar_text(
            strtolower($release-&gt;title),
            strtolower($album-&gt;title)
        );
        return $titleSimilarity &gt; 30;
    }
    private function calculateRelevanceScore($release, Album $album): float
    {
        $score = 0;
        // Title match (0-100)
        $score += similar_text(strtolower($release-&gt;title), strtolower($album-&gt;title));
        // Artist match if available
        if (!empty($release-&gt;artist_credit) &amp;&amp; $album-&gt;artists-&gt;isNotEmpty()) {
            $releaseArtist = $release-&gt;artist_credit[0][&apos;artist&apos;][&apos;name&apos;] ?? &apos;&apos;;
            $albumArtist = $album-&gt;artists-&gt;first()-&gt;name;
            $score += similar_text(strtolower($releaseArtist), strtolower($albumArtist)) * 0.5;
        }
        // Year match if available
        if (!empty($release-&gt;date) &amp;&amp; !empty($album-&gt;year)) {
            $releaseYear = substr($release-&gt;date, 0, 4);
            if ($releaseYear == $album-&gt;year) {
                $score += 30;
            }
        }
        return $score;
    }
    private function calculateDiscogsRelevanceScore($release, Album $album): float
    {
        $score = 0;
        // Title match (more flexible for Discogs)
        $score += similar_text(strtolower($release-&gt;title), strtolower($album-&gt;title)) * 0.8;
        // Artist match
        if (isset($release-&gt;artists) &amp;&amp; $album-&gt;artists-&gt;isNotEmpty()) {
            $releaseArtist = is_array($release-&gt;artists) ? ($release-&gt;artists[0][&apos;name&apos;] ?? &apos;&apos;) : $release-&gt;artists;
            $albumArtist = $album-&gt;artists-&gt;first()-&gt;name;
            $score += similar_text(strtolower($releaseArtist), strtolower($albumArtist)) * 0.3;
        }
        // Year match
        if (!empty($release-&gt;year) &amp;&amp; !empty($album-&gt;year)) {
            if ($release-&gt;year == $album-&gt;year) {
                $score += 40;
            }
        }
        return $score;
    }
}</file><file path="app/Services/Metadata/Search/ArtistSearchService.php">&lt;?php
namespace App\Services\Metadata\Search;
use App\Models\Artist;
use App\Http\Integrations\MusicBrainz\MusicBrainzClient;
use App\Http\Integrations\Discogs\DiscogsClient;
use App\Http\Integrations\MusicBrainz\Filters\ArtistFilter as MusicBrainzArtistFilter;
use App\Http\Integrations\Discogs\Filters\ArtistFilter as DiscogsArtistFilter;
use App\Services\MetadataMatching\{MatchingStrategy, QualityValidator};
use Illuminate\Support\Facades\Log;
class ArtistSearchService
{
    public function __construct(
        private readonly MusicBrainzClient $musicBrainzClient,
        private readonly DiscogsClient $discogsClient,
        private readonly MatchingStrategy $matchingStrategy,
        private readonly QualityValidator $qualityValidator
    ) {}
    /**
     * Search all sources for artist metadata
     */
    public function searchAllSources(Artist $artist): array
    {
        return [
            &apos;musicbrainz&apos; =&gt; $this-&gt;searchMusicBrainz($artist),
            &apos;discogs&apos; =&gt; $this-&gt;searchDiscogs($artist),
        ];
    }
    /**
     * Search MusicBrainz for artist
     */
    public function searchMusicBrainz(Artist $artist): ?array
    {
        try {
            $filter = new MusicBrainzArtistFilter();
            $filter-&gt;setName($artist-&gt;name);
            Log::debug(&apos;Searching MusicBrainz for artist&apos;, [
                &apos;artist_id&apos; =&gt; $artist-&gt;id,
                &apos;name&apos; =&gt; $artist-&gt;name
            ]);
            $searchResults = $this-&gt;musicBrainzClient-&gt;search-&gt;artist($filter);
            if ($searchResults-&gt;isEmpty()) {
                return null;
            }
            $relevantResults = $searchResults
                -&gt;filter(fn($artistModel) =&gt; $this-&gt;isRelevantMatch($artistModel, $artist))
                -&gt;sortByDesc(fn($artistModel) =&gt; $this-&gt;calculateRelevanceScore($artistModel, $artist))
                -&gt;take(5);
            if ($relevantResults-&gt;isEmpty()) {
                return null;
            }
            $bestMatch = $relevantResults-&gt;first();
            $detailedData = $this-&gt;musicBrainzClient-&gt;lookup-&gt;artist($bestMatch-&gt;id);
            return [
                &apos;source&apos; =&gt; &apos;musicbrainz&apos;,
                &apos;data&apos; =&gt; $detailedData-&gt;toArray(),
                &apos;quality_score&apos; =&gt; $this-&gt;qualityValidator-&gt;scoreArtistMatch($detailedData-&gt;toArray(), $artist),
                &apos;search_results_count&apos; =&gt; $searchResults-&gt;count()
            ];
        } catch (\Exception $e) {
            Log::warning(&apos;MusicBrainz artist search failed&apos;, [
                &apos;artist_id&apos; =&gt; $artist-&gt;id,
                &apos;error&apos; =&gt; $e-&gt;getMessage()
            ]);
            return null;
        }
    }
    /**
     * Search Discogs for artist
     */
    public function searchDiscogs(Artist $artist): ?array
    {
        try {
            $filter = new DiscogsArtistFilter();
            $filter-&gt;setTitle($artist-&gt;name);
            Log::debug(&apos;Searching Discogs for artist&apos;, [
                &apos;artist_id&apos; =&gt; $artist-&gt;id,
                &apos;name&apos; =&gt; $artist-&gt;name
            ]);
            $searchResults = $this-&gt;discogsClient-&gt;search-&gt;artist($filter);
            if ($searchResults-&gt;isEmpty()) {
                return null;
            }
            $relevantResults = $searchResults
                -&gt;filter(fn($artistModel) =&gt; $this-&gt;isRelevantDiscogsMatch($artistModel, $artist))
                -&gt;sortByDesc(fn($artistModel) =&gt; $this-&gt;calculateDiscogsRelevanceScore($artistModel, $artist))
                -&gt;take(5);
            if ($relevantResults-&gt;isEmpty()) {
                return null;
            }
            $bestMatch = $relevantResults-&gt;first();
            $detailedData = $this-&gt;discogsClient-&gt;lookup-&gt;artist($bestMatch-&gt;id);
            return [
                &apos;source&apos; =&gt; &apos;discogs&apos;,
                &apos;data&apos; =&gt; $detailedData-&gt;toArray(),
                &apos;quality_score&apos; =&gt; $this-&gt;qualityValidator-&gt;scoreArtistMatch($detailedData-&gt;toArray(), $artist),
                &apos;search_results_count&apos; =&gt; $searchResults-&gt;count(),
                &apos;pagination&apos; =&gt; $this-&gt;discogsClient-&gt;search-&gt;getPagination()
            ];
        } catch (\Exception $e) {
            Log::warning(&apos;Discogs artist search failed&apos;, [
                &apos;artist_id&apos; =&gt; $artist-&gt;id,
                &apos;error&apos; =&gt; $e-&gt;getMessage()
            ]);
            return null;
        }
    }
    /**
     * Search for artist with fuzzy matching
     */
    public function searchFuzzy(Artist $artist): array
    {
        $results = [];
        // Try variations of the artist name
        $variations = $this-&gt;generateArtistNameVariations($artist-&gt;name);
        foreach ($variations as $variation) {
            // Try MusicBrainz
            $filter = new MusicBrainzArtistFilter();
            $filter-&gt;setName($variation);
            try {
                $searchResults = $this-&gt;musicBrainzClient-&gt;search-&gt;artist($filter);
                if (!$searchResults-&gt;isEmpty()) {
                    $results[&apos;musicbrainz_&apos; . $variation] = $searchResults-&gt;take(3);
                }
            } catch (\Exception $e) {
                Log::debug(&apos;Fuzzy search variation failed&apos;, [
                    &apos;variation&apos; =&gt; $variation,
                    &apos;error&apos; =&gt; $e-&gt;getMessage()
                ]);
            }
        }
        return $results;
    }
    /**
     * Generate artist name variations for fuzzy matching
     */
    private function generateArtistNameVariations(string $name): array
    {
        $variations = [$name];
        // Remove common prefixes/suffixes
        $cleanName = preg_replace(&apos;/^(the\s+|a\s+|an\s+)/i&apos;, &apos;&apos;, $name);
        if ($cleanName !== $name) {
            $variations[] = $cleanName;
        }
        // Add &quot;The&quot; prefix if not present
        if (!preg_match(&apos;/^the\s+/i&apos;, $name)) {
            $variations[] = &apos;The &apos; . $name;
        }
        // Replace special characters
        $normalized = preg_replace(&apos;/[^\w\s]/&apos;, &apos;&apos;, $name);
        if ($normalized !== $name) {
            $variations[] = $normalized;
        }
        // Remove duplicates and return
        return array_unique($variations);
    }
    private function isRelevantMatch($artistModel, Artist $artist): bool
    {
        if (empty($artistModel-&gt;name)) {
            return false;
        }
        $similarity = similar_text(
            strtolower($artistModel-&gt;name),
            strtolower($artist-&gt;name)
        );
        return $similarity &gt; 70;
    }
    private function isRelevantDiscogsMatch($artistModel, Artist $artist): bool
    {
        if (empty($artistModel-&gt;title)) {
            return false;
        }
        $similarity = similar_text(
            strtolower($artistModel-&gt;title),
            strtolower($artist-&gt;name)
        );
        return $similarity &gt; 70;
    }
    private function calculateRelevanceScore($artistModel, Artist $artist): float
    {
        $baseScore = similar_text(strtolower($artistModel-&gt;name), strtolower($artist-&gt;name));
        // Bonus for exact matches
        if (strtolower($artistModel-&gt;name) === strtolower($artist-&gt;name)) {
            $baseScore += 50;
        }
        // Bonus for disambiguation matches (like &quot;Artist (band)&quot;)
        if (str_contains(strtolower($artistModel-&gt;name), strtolower($artist-&gt;name))) {
            $baseScore += 20;
        }
        return $baseScore;
    }
    private function calculateDiscogsRelevanceScore($artistModel, Artist $artist): float
    {
        $baseScore = similar_text(strtolower($artistModel-&gt;title), strtolower($artist-&gt;name));
        // Bonus for exact matches
        if (strtolower($artistModel-&gt;title) === strtolower($artist-&gt;name)) {
            $baseScore += 50;
        }
        return $baseScore;
    }
}</file><file path="app/Services/Metadata/Search/SongSearchService.php">&lt;?php
namespace App\Services\Metadata\Search;
use App\Models\Song;
use App\Http\Integrations\MusicBrainz\MusicBrainzClient;
use App\Http\Integrations\Discogs\DiscogsClient;
use App\Http\Integrations\MusicBrainz\Filters\RecordingFilter;
use App\Http\Integrations\Discogs\Filters\ReleaseFilter as DiscogsReleaseFilter;
use App\Services\MetadataMatching\{MatchingStrategy, QualityValidator};
use Illuminate\Support\Facades\Log;
class SongSearchService
{
    public function __construct(
        private readonly MusicBrainzClient $musicBrainzClient,
        private readonly DiscogsClient $discogsClient,
        private readonly MatchingStrategy $matchingStrategy,
        private readonly QualityValidator $qualityValidator
    ) {}
    /**
     * Search all sources for song metadata
     */
    public function searchAllSources(Song $song): array
    {
        return [
            &apos;musicbrainz&apos; =&gt; $this-&gt;searchMusicBrainz($song),
            &apos;discogs&apos; =&gt; $this-&gt;searchDiscogs($song),
        ];
    }
    /**
     * Search with album context for better accuracy
     */
    public function searchWithAlbumContext(Song $song, array $albumMetadata): array
    {
        if (empty($albumMetadata) || ($albumMetadata[&apos;quality_score&apos;] ?? 0) === 0) {
            return $this-&gt;searchAllSources($song);
        }
        // Extract song data from album metadata
        $songData = $this-&gt;findSongInAlbumMetadata($song, $albumMetadata);
        if ($songData) {
            return [
                &apos;song&apos; =&gt; $songData,
                &apos;artists&apos; =&gt; $this-&gt;extractSongArtists($songData, $albumMetadata[&apos;source&apos;]),
                &apos;genres&apos; =&gt; $this-&gt;extractSongGenres($songData, $albumMetadata[&apos;source&apos;]),
                &apos;lyrics&apos; =&gt; null,
                &apos;quality_score&apos; =&gt; $this-&gt;qualityValidator-&gt;scoreSongMatch($songData, $song),
                &apos;source&apos; =&gt; $albumMetadata[&apos;source&apos;] . &apos;_album_context&apos;,
            ];
        }
        // Fallback to individual search
        return $this-&gt;searchAllSources($song);
    }
    /**
     * Search MusicBrainz for song
     */
    public function searchMusicBrainz(Song $song): ?array
    {
        try {
            $filter = new RecordingFilter();
            $filter-&gt;setTitle($song-&gt;title);
            if ($song-&gt;artists-&gt;isNotEmpty()) {
                $filter-&gt;setArtistName($song-&gt;artists-&gt;first()-&gt;name);
            }
            if ($song-&gt;album) {
                $filter-&gt;setRelease($song-&gt;album-&gt;title);
            }
            Log::debug(&apos;Searching MusicBrainz for song&apos;, [
                &apos;song_id&apos; =&gt; $song-&gt;id,
                &apos;title&apos; =&gt; $song-&gt;title,
                &apos;artist&apos; =&gt; $song-&gt;artists-&gt;first()-&gt;name ?? null
            ]);
            $searchResults = $this-&gt;musicBrainzClient-&gt;search-&gt;recording($filter);
            if ($searchResults-&gt;isEmpty()) {
                return null;
            }
            $relevantResults = $searchResults
                -&gt;filter(fn($recording) =&gt; $this-&gt;isRelevantMatch($recording, $song))
                -&gt;sortByDesc(fn($recording) =&gt; $this-&gt;calculateRelevanceScore($recording, $song))
                -&gt;take(5);
            if ($relevantResults-&gt;isEmpty()) {
                return null;
            }
            $bestMatch = $relevantResults-&gt;first();
            $detailedData = $this-&gt;musicBrainzClient-&gt;lookup-&gt;recording($bestMatch-&gt;id);
            return [
                &apos;source&apos; =&gt; &apos;musicbrainz&apos;,
                &apos;data&apos; =&gt; $detailedData-&gt;toArray(),
                &apos;quality_score&apos; =&gt; $this-&gt;qualityValidator-&gt;scoreSongMatch($detailedData-&gt;toArray(), $song)
            ];
        } catch (\Exception $e) {
            Log::warning(&apos;MusicBrainz song search failed&apos;, [
                &apos;song_id&apos; =&gt; $song-&gt;id,
                &apos;error&apos; =&gt; $e-&gt;getMessage()
            ]);
            return null;
        }
    }
    /**
     * Search Discogs for song (via release context)
     */
    public function searchDiscogs(Song $song): ?array
    {
        try {
            if (!$song-&gt;album) {
                return null;
            }
            $filter = new DiscogsReleaseFilter();
            $filter-&gt;setTitle($song-&gt;album-&gt;title);
            if ($song-&gt;album-&gt;artists-&gt;isNotEmpty()) {
                $filter-&gt;setArtist($song-&gt;album-&gt;artists-&gt;first()-&gt;name);
            }
            Log::debug(&apos;Searching Discogs for song via album&apos;, [
                &apos;song_id&apos; =&gt; $song-&gt;id,
                &apos;song_title&apos; =&gt; $song-&gt;title,
                &apos;album_title&apos; =&gt; $song-&gt;album-&gt;title
            ]);
            $searchResults = $this-&gt;discogsClient-&gt;search-&gt;release($filter);
            if ($searchResults-&gt;isEmpty()) {
                return null;
            }
            // Look for the song in each release&apos;s tracklist
            foreach ($searchResults-&gt;take(5) as $release) {
                $detailedData = $this-&gt;discogsClient-&gt;lookup-&gt;release($release-&gt;id);
                $trackData = $this-&gt;findTrackInDiscogs($detailedData-&gt;toArray(), $song);
                if ($trackData) {
                    return [
                        &apos;source&apos; =&gt; &apos;discogs&apos;,
                        &apos;data&apos; =&gt; $trackData,
                        &apos;release_data&apos; =&gt; $detailedData-&gt;toArray(),
                        &apos;quality_score&apos; =&gt; $this-&gt;qualityValidator-&gt;scoreSongMatch($trackData, $song)
                    ];
                }
            }
            return null;
        } catch (\Exception $e) {
            Log::warning(&apos;Discogs song search failed&apos;, [
                &apos;song_id&apos; =&gt; $song-&gt;id,
                &apos;error&apos; =&gt; $e-&gt;getMessage()
            ]);
            return null;
        }
    }
    private function findSongInAlbumMetadata(Song $song, array $albumMetadata): ?array
    {
        $data = $albumMetadata[&apos;data&apos;] ?? [];
        $source = $albumMetadata[&apos;source&apos;];
        return match ($source) {
            &apos;musicbrainz&apos; =&gt; $this-&gt;findSongInMusicBrainzRelease($data, $song),
            &apos;discogs&apos; =&gt; $this-&gt;findTrackInDiscogs($data, $song),
            default =&gt; null,
        };
    }
    private function findSongInMusicBrainzRelease(array $releaseData, Song $song): ?array
    {
        if (!isset($releaseData[&apos;media&apos;])) {
            return null;
        }
        foreach ($releaseData[&apos;media&apos;] as $medium) {
            if (!isset($medium[&apos;tracks&apos;])) {
                continue;
            }
            foreach ($medium[&apos;tracks&apos;] as $track) {
                $similarity = $this-&gt;matchingStrategy-&gt;calculateSongSimilarity($track, $song);
                if ($similarity &gt;= 0.8) {
                    // Get detailed recording data if available
                    if (isset($track[&apos;recording&apos;][&apos;id&apos;])) {
                        try {
                            $recordingData = $this-&gt;musicBrainzClient-&gt;lookup-&gt;recording($track[&apos;recording&apos;][&apos;id&apos;]);
                            return array_merge($track, $recordingData-&gt;toArray());
                        } catch (\Exception) {
                            // Return basic track data if detailed lookup fails
                        }
                    }
                    return $track;
                }
            }
        }
        return null;
    }
    private function findTrackInDiscogs(array $releaseData, Song $song): ?array
    {
        if (!isset($releaseData[&apos;tracklist&apos;])) {
            return null;
        }
        foreach ($releaseData[&apos;tracklist&apos;] as $track) {
            $similarity = $this-&gt;matchingStrategy-&gt;calculateSongSimilarity($track, $song);
            if ($similarity &gt;= 0.8) {
                // Enhance track data with release context
                $track[&apos;release_artists&apos;] = $releaseData[&apos;artists&apos;] ?? [];
                $track[&apos;release_genres&apos;] = array_merge(
                    $releaseData[&apos;genres&apos;] ?? [],
                    $releaseData[&apos;styles&apos;] ?? []
                );
                return $track;
            }
        }
        return null;
    }
    private function extractSongArtists($songData, string $source): array
    {
        $artists = [];
        switch ($source) {
            case &apos;musicbrainz&apos;:
                if (isset($songData[&apos;artist-credit&apos;])) {
                    foreach ($songData[&apos;artist-credit&apos;] as $credit) {
                        if (isset($credit[&apos;artist&apos;])) {
                            $artists[] = [
                                &apos;name&apos; =&gt; $credit[&apos;artist&apos;][&apos;name&apos;],
                                &apos;external_id&apos; =&gt; $credit[&apos;artist&apos;][&apos;id&apos;],
                                &apos;external_source&apos; =&gt; &apos;musicbrainz&apos;,
                            ];
                        }
                    }
                }
                break;
            case &apos;discogs&apos;:
                if (isset($songData[&apos;release_artists&apos;])) {
                    foreach ($songData[&apos;release_artists&apos;] as $artist) {
                        $artists[] = [
                            &apos;name&apos; =&gt; $artist[&apos;name&apos;] ?? $artist,
                            &apos;external_id&apos; =&gt; $artist[&apos;id&apos;] ?? null,
                            &apos;external_source&apos; =&gt; &apos;discogs&apos;,
                        ];
                    }
                }
                break;
        }
        return $artists;
    }
    private function extractSongGenres($songData, string $source): array
    {
        $genres = [];
        switch ($source) {
            case &apos;musicbrainz&apos;:
                if (isset($songData[&apos;genres&apos;])) {
                    foreach ($songData[&apos;genres&apos;] as $genre) {
                        $genres[] = $genre[&apos;name&apos;] ?? $genre;
                    }
                }
                if (isset($songData[&apos;tags&apos;])) {
                    foreach ($songData[&apos;tags&apos;] as $tag) {
                        $genres[] = $tag[&apos;name&apos;] ?? $tag;
                    }
                }
                break;
            case &apos;discogs&apos;:
                if (isset($songData[&apos;release_genres&apos;])) {
                    $genres = array_merge($genres, $songData[&apos;release_genres&apos;]);
                }
                break;
        }
        return array_unique($genres);
    }
    private function isRelevantMatch($recording, Song $song): bool
    {
        if (empty($recording-&gt;title)) {
            return false;
        }
        $similarity = similar_text(
            strtolower($recording-&gt;title),
            strtolower($song-&gt;title)
        );
        return $similarity &gt; 70;
    }
    private function calculateRelevanceScore($recording, Song $song): float
    {
        $score = similar_text(strtolower($recording-&gt;title), strtolower($song-&gt;title));
        // Bonus for artist match
        if (isset($recording-&gt;artist_credit) &amp;&amp; $song-&gt;artists-&gt;isNotEmpty()) {
            $recordingArtist = $recording-&gt;artist_credit[0][&apos;artist&apos;][&apos;name&apos;] ?? &apos;&apos;;
            $songArtist = $song-&gt;artists-&gt;first()-&gt;name;
            $score += similar_text(strtolower($recordingArtist), strtolower($songArtist)) * 0.3;
        }
        // Bonus for length match (if available)
        if (isset($recording-&gt;length) &amp;&amp; $song-&gt;length) {
            $lengthDiff = abs($recording-&gt;length - $song-&gt;length);
            if ($lengthDiff &lt; 5000) { // within 5 seconds
                $score += 20;
            }
        }
        return $score;
    }
}</file><file path="app/Services/MetadataMatching/MatchingStrategy.php">&lt;?php
namespace App\Services\MetadataMatching;
use App\Models\Album;
use App\Models\Artist;
use App\Models\Song;
class MatchingStrategy
{
    /**
     * Find the best album match from search results
     */
    public function findBestAlbumMatch(array $results, Album $album): ?array
    {
        $bestMatch = null;
        $bestScore = 0;
        Log::debug(&apos;Finding best album match&apos;, [
            &apos;album_id&apos; =&gt; $album-&gt;id,
            &apos;results_count&apos; =&gt; count($results),
            &apos;album_title&apos; =&gt; $album-&gt;title
        ]);
        foreach ($results as $index =&gt; $result) {
            $score = $this-&gt;calculateAlbumMatchScore($result, $album);
            Log::debug(&apos;Album match score calculated&apos;, [
                &apos;album_id&apos; =&gt; $album-&gt;id,
                &apos;result_index&apos; =&gt; $index,
                &apos;result_title&apos; =&gt; $result[&apos;title&apos;] ?? &apos;unknown&apos;,
                &apos;score&apos; =&gt; $score,
                &apos;threshold&apos; =&gt; 0.5 // Lowered threshold
            ]);
            if ($score &gt; $bestScore &amp;&amp; $score &gt;= 0.5) { // Lowered from 0.7 to 0.5
                $bestScore = $score;
                $bestMatch = $result;
            }
        }
        if ($bestMatch) {
            Log::debug(&apos;Best match found&apos;, [
                &apos;album_id&apos; =&gt; $album-&gt;id,
                &apos;match_title&apos; =&gt; $bestMatch[&apos;title&apos;] ?? &apos;unknown&apos;,
                &apos;final_score&apos; =&gt; $bestScore
            ]);
        } else {
            Log::debug(&apos;No suitable match found&apos;, [
                &apos;album_id&apos; =&gt; $album-&gt;id,
                &apos;best_score_achieved&apos; =&gt; $bestScore
            ]);
        }
        return $bestMatch;
    }
    /**
     * Find the best artist match from search results
     */
    public function findBestArtistMatch(array $results, Artist $artist): ?array
    {
        $bestMatch = null;
        $bestScore = 0;
        foreach ($results as $result) {
            $score = $this-&gt;calculateArtistMatchScore($result, $artist);
            if ($score &gt; $bestScore &amp;&amp; $score &gt;= 0.6) { // Lowered from 0.8 to 0.6
                $bestScore = $score;
                $bestMatch = $result;
            }
        }
        return $bestMatch;
    }
    /**
     * Find the best song match from search results
     */
    public function findBestSongMatch(array $results, Song $song): ?array
    {
        $bestMatch = null;
        $bestScore = 0;
        foreach ($results as $result) {
            $score = $this-&gt;calculateSongMatchScore($result, $song);
            if ($score &gt; $bestScore &amp;&amp; $score &gt;= 0.6) { // Lowered from 0.75 to 0.6
                $bestScore = $score;
                $bestMatch = $result;
            }
        }
        return $bestMatch;
    }
    /**
     * Calculate similarity between a track result and a song
     */
    public function calculateSongSimilarity(array $trackData, Song $song): float
    {
        $score = 0;
        $maxScore = 0;
        // Title similarity (weight: 50%)
        $titleSimilarity = $this-&gt;calculateStringSimilarity(
            $trackData[&apos;title&apos;] ?? &apos;&apos;,
            $song-&gt;title
        );
        $score += $titleSimilarity * 0.5;
        $maxScore += 0.5;
        // Track position match (weight: 20%)
        if (isset($trackData[&apos;position&apos;]) &amp;&amp; $song-&gt;track) {
            $trackPosition = $this-&gt;normalizeTrackPosition($trackData[&apos;position&apos;]);
            if ($trackPosition === $song-&gt;track) {
                $score += 0.2;
            } elseif (abs($trackPosition - $song-&gt;track) &lt;= 1) {
                $score += 0.1; // Close track position gets partial credit
            }
        }
        $maxScore += 0.2;
        // Duration match (weight: 20%)
        if ($song-&gt;length) {
            $trackDuration = $this-&gt;extractDuration($trackData);
            if ($trackDuration) {
                $durationDiff = abs($trackDuration - $song-&gt;length);
                $tolerance = max(10000, $song-&gt;length * 0.1); // 10 seconds or 10% tolerance
                if ($durationDiff &lt;= $tolerance) {
                    $score += 0.2 * (1 - ($durationDiff / $tolerance));
                }
            }
        }
        $maxScore += 0.2;
        // Artist match (weight: 10%)
        if ($song-&gt;artists-&gt;isNotEmpty()) {
            $artistSimilarity = $this-&gt;calculateTrackArtistSimilarity($trackData, $song);
            $score += $artistSimilarity * 0.1;
        }
        $maxScore += 0.1;
        return $maxScore &gt; 0 ? $score / $maxScore : 0;
    }
    private function calculateAlbumMatchScore(array $result, Album $album): float
    {
        $score = 0;
        $maxScore = 0;
        // Title similarity (weight: 60% - increased importance)
        $titleSimilarity = $this-&gt;calculateStringSimilarity(
            $result[&apos;title&apos;] ?? &apos;&apos;,
            $album-&gt;title
        );
        $score += $titleSimilarity * 0.6;
        $maxScore += 0.6;
        Log::debug(&apos;Album title similarity&apos;, [
            &apos;album_id&apos; =&gt; $album-&gt;id,
            &apos;local_title&apos; =&gt; $album-&gt;title,
            &apos;result_title&apos; =&gt; $result[&apos;title&apos;] ?? &apos;&apos;,
            &apos;similarity&apos; =&gt; $titleSimilarity
        ]);
        // Year match (weight: 20%)
        $yearScore = 0;
        if ($album-&gt;year &amp;&amp; isset($result[&apos;date&apos;])) {
            $resultYear = (int)substr($result[&apos;date&apos;], 0, 4);
            if ($resultYear === $album-&gt;year) {
                $yearScore = 1.0;
            } elseif (abs($resultYear - $album-&gt;year) &lt;= 2) { // More lenient
                $yearScore = 0.7;
            } elseif (abs($resultYear - $album-&gt;year) &lt;= 5) {
                $yearScore = 0.4;
            }
        } elseif ($album-&gt;year &amp;&amp; isset($result[&apos;year&apos;])) {
            if ($result[&apos;year&apos;] === $album-&gt;year) {
                $yearScore = 1.0;
            } elseif (abs($result[&apos;year&apos;] - $album-&gt;year) &lt;= 2) {
                $yearScore = 0.7;
            } elseif (abs($result[&apos;year&apos;] - $album-&gt;year) &lt;= 5) {
                $yearScore = 0.4;
            }
        } else {
            $yearScore = 0.5; // Neutral if no year data
        }
        $score += $yearScore * 0.2;
        $maxScore += 0.2;
        // Artist similarity (weight: 20% - reduced from 40%)
        $artistScore = 0.5; // Default neutral score
        if ($album-&gt;artists-&gt;isNotEmpty()) {
            $artistScore = $this-&gt;calculateArtistSimilarity($result, $album);
        }
        $score += $artistScore * 0.2;
        $maxScore += 0.2;
        $finalScore = $maxScore &gt; 0 ? $score / $maxScore : 0;
        Log::debug(&apos;Album match score breakdown&apos;, [
            &apos;album_id&apos; =&gt; $album-&gt;id,
            &apos;title_score&apos; =&gt; $titleSimilarity,
            &apos;year_score&apos; =&gt; $yearScore,
            &apos;artist_score&apos; =&gt; $artistScore,
            &apos;final_score&apos; =&gt; $finalScore
        ]);
        return $finalScore;
    }
    private function calculateArtistMatchScore(array $result, Artist $artist): float
    {
        // Name similarity (weight: 100%)
        return $this-&gt;calculateStringSimilarity(
            $result[&apos;name&apos;] ?? &apos;&apos;,
            $artist-&gt;name
        );
    }
    private function calculateSongMatchScore(array $result, Song $song): float
    {
        $score = 0;
        $maxScore = 0;
        // Title similarity (weight: 40%)
        $titleSimilarity = $this-&gt;calculateStringSimilarity(
            $result[&apos;title&apos;] ?? &apos;&apos;,
            $song-&gt;title
        );
        $score += $titleSimilarity * 0.4;
        $maxScore += 0.4;
        // Length match (weight: 30%)
        if ($song-&gt;length &amp;&amp; isset($result[&apos;length&apos;])) {
            $lengthDiff = abs((int)$result[&apos;length&apos;] - $song-&gt;length);
            $tolerance = max(10000, $song-&gt;length * 0.1); // 10 seconds or 10% tolerance
            if ($lengthDiff &lt;= $tolerance) {
                $lengthScore = 1 - ($lengthDiff / $tolerance);
                $score += $lengthScore * 0.3;
            }
        }
        $maxScore += 0.3;
        // Artist similarity (weight: 20%)
        if ($song-&gt;artists-&gt;isNotEmpty()) {
            $artistScore = $this-&gt;calculateRecordingArtistSimilarity($result, $song);
            $score += $artistScore * 0.2;
        }
        $maxScore += 0.2;
        // Album/Release context (weight: 10%)
        if ($song-&gt;album &amp;&amp; isset($result[&apos;releases&apos;])) {
            $albumScore = $this-&gt;calculateReleaseContextSimilarity($result[&apos;releases&apos;], $song-&gt;album);
            $score += $albumScore * 0.1;
        }
        $maxScore += 0.1;
        return $maxScore &gt; 0 ? $score / $maxScore : 0;
    }
    private function calculateArtistSimilarity(array $result, Album $album): float
    {
        $albumArtists = $album-&gt;artists-&gt;pluck(&apos;name&apos;)-&gt;toArray();
        if (empty($albumArtists)) {
            return 0;
        }
        $resultArtists = [];
        // Extract artist names from different possible structures
        if (isset($result[&apos;artist-credit&apos;])) {
            foreach ($result[&apos;artist-credit&apos;] as $credit) {
                if (isset($credit[&apos;artist&apos;][&apos;name&apos;])) {
                    $resultArtists[] = $credit[&apos;artist&apos;][&apos;name&apos;];
                }
            }
        } elseif (isset($result[&apos;artists&apos;])) {
            foreach ($result[&apos;artists&apos;] as $artist) {
                $resultArtists[] = $artist[&apos;name&apos;] ?? $artist;
            }
        }
        if (empty($resultArtists)) {
            return 0;
        }
        return $this-&gt;calculateArtistListSimilarity($albumArtists, $resultArtists);
    }
    private function calculateTrackArtistSimilarity(array $trackData, Song $song): float
    {
        $songArtists = $song-&gt;artists-&gt;pluck(&apos;name&apos;)-&gt;toArray();
        if (empty($songArtists)) {
            return 0;
        }
        $trackArtists = [];
        // Extract artist names from track data
        if (isset($trackData[&apos;artists&apos;])) {
            foreach ($trackData[&apos;artists&apos;] as $artist) {
                $trackArtists[] = $artist[&apos;name&apos;] ?? $artist;
            }
        } elseif (isset($trackData[&apos;release_artists&apos;])) {
            foreach ($trackData[&apos;release_artists&apos;] as $artist) {
                $trackArtists[] = $artist[&apos;name&apos;] ?? $artist;
            }
        }
        if (empty($trackArtists)) {
            return 0;
        }
        return $this-&gt;calculateArtistListSimilarity($songArtists, $trackArtists);
    }
    private function calculateRecordingArtistSimilarity(array $result, Song $song): float
    {
        $songArtists = $song-&gt;artists-&gt;pluck(&apos;name&apos;)-&gt;toArray();
        if (empty($songArtists)) {
            return 0;
        }
        $resultArtists = [];
        if (isset($result[&apos;artist-credit&apos;])) {
            foreach ($result[&apos;artist-credit&apos;] as $credit) {
                if (isset($credit[&apos;artist&apos;][&apos;name&apos;])) {
                    $resultArtists[] = $credit[&apos;artist&apos;][&apos;name&apos;];
                }
            }
        }
        if (empty($resultArtists)) {
            return 0;
        }
        return $this-&gt;calculateArtistListSimilarity($songArtists, $resultArtists);
    }
    private function calculateReleaseContextSimilarity(array $releases, Album $album): float
    {
        $bestSimilarity = 0;
        foreach ($releases as $release) {
            $releaseSimilarity = $this-&gt;calculateStringSimilarity(
                $release[&apos;title&apos;] ?? &apos;&apos;,
                $album-&gt;title
            );
            $bestSimilarity = max($bestSimilarity, $releaseSimilarity);
        }
        return $bestSimilarity;
    }
    private function calculateArtistListSimilarity(array $artists1, array $artists2): float
    {
        $bestSimilarity = 0;
        foreach ($artists1 as $artist1) {
            foreach ($artists2 as $artist2) {
                $similarity = $this-&gt;calculateStringSimilarity($artist1, $artist2);
                $bestSimilarity = max($bestSimilarity, $similarity);
            }
        }
        return $bestSimilarity;
    }
    private function calculateStringSimilarity(string $string1, string $string2): float
    {
        if (empty($string1) || empty($string2)) {
            return 0;
        }
        // Normalize strings for comparison
        $normalized1 = $this-&gt;normalizeString($string1);
        $normalized2 = $this-&gt;normalizeString($string2);
        // Exact match
        if ($normalized1 === $normalized2) {
            return 1.0;
        }
        // Use similar_text for fuzzy matching
        $similarity = 0;
        similar_text($normalized1, $normalized2, $similarity);
        // Also try Levenshtein distance for short strings
        if (strlen($normalized1) &lt; 100 &amp;&amp; strlen($normalized2) &lt; 100) {
            $maxLen = max(strlen($normalized1), strlen($normalized2));
            if ($maxLen &gt; 0) {
                $levenshtein = levenshtein($normalized1, $normalized2);
                $levenshteinSimilarity = (1 - ($levenshtein / $maxLen)) * 100;
                // Use the better of the two similarity measures
                $similarity = max($similarity, $levenshteinSimilarity);
            }
        }
        return min($similarity / 100, 1.0); // Ensure we don&apos;t exceed 1.0
    }
    private function normalizeString(string $string): string
    {
        // Convert to lowercase
        $normalized = strtolower($string);
        // Remove common articles and prepositions (less aggressive)
        $normalized = preg_replace(&apos;/\b(the|a|an)\b/&apos;, &apos;&apos;, $normalized);
        // Remove special characters but keep spaces and alphanumeric
        $normalized = preg_replace(&apos;/[^\w\s]/&apos;, &apos; &apos;, $normalized);
        $normalized = preg_replace(&apos;/\s+/&apos;, &apos; &apos;, $normalized);
        return trim($normalized);
    }
    private function normalizeTrackPosition(string $position): int
    {
        // Handle various track position formats like &quot;A1&quot;, &quot;1&quot;, &quot;01&quot;, etc.
        $position = preg_replace(&apos;/[^0-9]/&apos;, &apos;&apos;, $position);
        return (int) $position ?: 1;
    }
    private function extractDuration(array $trackData): ?int
    {
        if (isset($trackData[&apos;length&apos;])) {
            return (int) $trackData[&apos;length&apos;];
        }
        if (isset($trackData[&apos;duration&apos;])) {
            return $this-&gt;parseDuration($trackData[&apos;duration&apos;]);
        }
        return null;
    }
    private function parseDuration(string $duration): ?int
    {
        $parts = explode(&apos;:&apos;, $duration);
        if (count($parts) === 2) {
            return (((int)$parts[0] * 60) + (int)$parts[1]) * 1000;
        } elseif (count($parts) === 3) {
            return (((int)$parts[0] * 3600) + ((int)$parts[1] * 60) + (int)$parts[2]) * 1000;
        }
        return null;
    }
}</file><file path="app/Services/MetadataMatching/QualityValidator.php">&lt;?php
namespace App\Services\MetadataMatching;
use App\Models\Album;
use App\Models\Artist;
use App\Models\Song;
class QualityValidator
{
    /**
     * Score the quality of an album match
     */
    public function scoreAlbumMatch(array $metadata, Album $album): float
    {
        $score = 0;
        $factors = 0;
        // Check if essential fields are present
        if (!empty($metadata[&apos;title&apos;])) {
            $score += 1;
        }
        $factors++;
        // Check if artist information is present
        if ($this-&gt;hasArtistInfo($metadata)) {
            $score += 1;
        }
        $factors++;
        // Check if track listing is present
        if ($this-&gt;hasTrackListing($metadata)) {
            $score += 1;
        }
        $factors++;
        // Check if release date is present
        if ($this-&gt;hasReleaseDate($metadata)) {
            $score += 1;
        }
        $factors++;
        // Check if genre information is present
        if ($this-&gt;hasGenreInfo($metadata)) {
            $score += 0.5;
        }
        $factors += 0.5;
        // Bonus for complete metadata
        if ($this-&gt;isCompleteMetadata($metadata)) {
            $score += 0.5;
        }
        $factors += 0.5;
        return $factors &gt; 0 ? $score / $factors : 0;
    }
    /**
     * Score the quality of an artist match
     */
    public function scoreArtistMatch(array $metadata, Artist $artist): float
    {
        $score = 0;
        $factors = 0;
        // Check if name is present
        if (isset($metadata[&apos;name&apos;]) &amp;&amp; !empty($metadata[&apos;name&apos;])) {
            $score += 1;
        }
        $factors++;
        // Check if discography is present
        if ($this-&gt;hasDiscography($metadata)) {
            $score += 1;
        }
        $factors++;
        // Check if additional info is present (bio, type, etc.)
        if ($this-&gt;hasArtistDetails($metadata)) {
            $score += 0.5;
        }
        $factors += 0.5;
        return $factors &gt; 0 ? $score / $factors : 0;
    }
    /**
     * Validate that a match meets minimum quality standards
     */
    public function isValidMatch(array $metadata, float $qualityScore): bool
    {
        // Minimum quality score threshold
        if ($qualityScore &lt; 0.6) {
            return false;
        }
        // Must have basic required fields
        if (!isset($metadata[&apos;title&apos;]) &amp;&amp; !isset($metadata[&apos;name&apos;])) {
            return false;
        }
        return true;
    }
    /**
     * Score the quality of a song match
     */
    public function scoreSongMatch(array $metadata, Song $song): float
    {
        $score = 0;
        $factors = 0;
        // Check if essential fields are present
        if (!empty($metadata[&apos;title&apos;])) {
            $score += 1;
        }
        $factors++;
        // Check if duration information is present
        if ($this-&gt;hasDurationInfo($metadata)) {
            $score += 1;
        }
        $factors++;
        // Check if artist information is present
        if ($this-&gt;hasArtistInfo($metadata)) {
            $score += 1;
        }
        $factors++;
        // Check if track position is present
        if ($this-&gt;hasTrackPosition($metadata)) {
            $score += 0.5;
        }
        $factors += 0.5;
        // Check if genre information is present
        if ($this-&gt;hasGenreInfo($metadata)) {
            $score += 0.5;
        }
        $factors += 0.5;
        // Bonus for complete song metadata
        if ($this-&gt;isCompleteSongMetadata($metadata)) {
            $score += 0.5;
        }
        $factors += 0.5;
        return $factors &gt; 0 ? $score / $factors : 0;
    }
    /**
     * Validate that a song match meets minimum quality standards
     */
    public function isValidSongMatch(array $metadata, float $qualityScore): bool
    {
        // Minimum quality score threshold for songs
        if ($qualityScore &lt; 0.6) {
            return false;
        }
        // Must have title
        if (!isset($metadata[&apos;title&apos;]) || empty($metadata[&apos;title&apos;])) {
            return false;
        }
        return true;
    }
    /**
     * Check if the song metadata is complete enough for high-confidence matching
     */
    public function isHighConfidenceSongMatch(array $metadata, Song $song, float $qualityScore): bool
    {
        if ($qualityScore &lt; 0.8) {
            return false;
        }
        // High confidence requires title and at least one additional matching field
        $hasTitle = isset($metadata[&apos;title&apos;]) &amp;&amp; !empty($metadata[&apos;title&apos;]);
        $hasDuration = $this-&gt;hasDurationInfo($metadata);
        $hasArtist = $this-&gt;hasArtistInfo($metadata);
        $hasPosition = $this-&gt;hasTrackPosition($metadata);
        $matchingFields = 0;
        if ($hasTitle) $matchingFields++;
        if ($hasDuration) $matchingFields++;
        if ($hasArtist) $matchingFields++;
        if ($hasPosition) $matchingFields++;
        return $matchingFields &gt;= 3; // Need at least 3 matching fields
    }
    private function hasDurationInfo(array $metadata): bool
    {
        return isset($metadata[&apos;length&apos;]) ||
            isset($metadata[&apos;duration&apos;]) ||
            isset($metadata[&apos;track-length&apos;]);
    }
    private function hasTrackPosition(array $metadata): bool
    {
        return isset($metadata[&apos;position&apos;]) ||
            isset($metadata[&apos;track&apos;]) ||
            isset($metadata[&apos;track-number&apos;]);
    }
    private function isCompleteSongMetadata(array $metadata): bool
    {
        $requiredFields = [&apos;title&apos;];
        $optionalFields = [&apos;length&apos;, &apos;duration&apos;, &apos;position&apos;, &apos;artist-credit&apos;, &apos;artists&apos;];
        if (array_any($requiredFields, fn($field) =&gt; !isset($metadata[$field]))) {
            return false;
        }
        $presentOptionalFields = 0;
        foreach ($optionalFields as $field) {
            if (isset($metadata[$field])) {
                $presentOptionalFields++;
            }
        }
        // Consider complete if at least 60% of optional fields are present
        return $presentOptionalFields &gt;= (count($optionalFields) * 0.6);
    }
    private function hasArtistInfo(array $metadata): bool
    {
        return isset($metadata[&apos;artist-credit&apos;]) ||
            isset($metadata[&apos;artists&apos;]) ||
            isset($metadata[&apos;artist&apos;]);
    }
    private function hasTrackListing(array $metadata): bool
    {
        return isset($metadata[&apos;media&apos;]) ||
            isset($metadata[&apos;tracklist&apos;]) ||
            isset($metadata[&apos;tracks&apos;]);
    }
    private function hasReleaseDate(array $metadata): bool
    {
        return isset($metadata[&apos;date&apos;]) ||
            isset($metadata[&apos;year&apos;]) ||
            isset($metadata[&apos;release-date&apos;]);
    }
    private function hasGenreInfo(array $metadata): bool
    {
        return isset($metadata[&apos;genres&apos;]) ||
            isset($metadata[&apos;styles&apos;]) ||
            isset($metadata[&apos;tags&apos;]);
    }
    private function isCompleteMetadata(array $metadata): bool
    {
        $requiredFields = [&apos;title&apos;];
        $optionalFields = [&apos;date&apos;, &apos;year&apos;, &apos;genres&apos;, &apos;styles&apos;, &apos;media&apos;, &apos;tracklist&apos;];
        foreach ($requiredFields as $field) {
            if (!isset($metadata[$field])) {
                return false;
            }
        }
        $presentOptionalFields = 0;
        foreach ($optionalFields as $field) {
            if (isset($metadata[$field])) {
                $presentOptionalFields++;
            }
        }
        // Consider complete if at least 50% of optional fields are present
        return $presentOptionalFields &gt;= (count($optionalFields) * 0.5);
    }
    private function hasDiscography(array $metadata): bool
    {
        return isset($metadata[&apos;releases&apos;]) ||
            isset($metadata[&apos;albums&apos;]) ||
            isset($metadata[&apos;discography&apos;]);
    }
    private function hasArtistDetails(array $metadata): bool
    {
        return isset($metadata[&apos;type&apos;]) ||
            isset($metadata[&apos;country&apos;]) ||
            isset($metadata[&apos;life-span&apos;]) ||
            isset($metadata[&apos;disambiguation&apos;]) ||
            isset($metadata[&apos;profile&apos;]);
    }
}</file><file path="app/Services/MetadataSearch/AlbumSearchService.php">&lt;?php
namespace App\Services\MetadataSearch;
use App\Models\Album;
use App\Http\Integrations\MusicBrainz\MusicBrainzClient;
use App\Http\Integrations\Discogs\DiscogsClient;
use App\Http\Integrations\MusicBrainz\Filters\ReleaseFilter as MusicBrainzReleaseFilter;
use App\Http\Integrations\Discogs\Filters\ReleaseFilter as DiscogsReleaseFilter;
use App\Services\MetadataMatching\{MatchingStrategy, QualityValidator};
use Illuminate\Support\Facades\Log;
class AlbumSearchService
{
    public function __construct(
        private readonly MusicBrainzClient $musicBrainzClient,
        private readonly DiscogsClient $discogsClient,
        private readonly MatchingStrategy $matchingStrategy,
        private readonly QualityValidator $qualityValidator
    ) {}
    /**
     * Search all sources for album metadata
     */
    public function searchAllSources(Album $album): array
    {
        return [
            &apos;musicbrainz&apos; =&gt; $this-&gt;searchMusicBrainz($album),
            &apos;discogs&apos; =&gt; $this-&gt;searchDiscogs($album),
        ];
    }
    /**
     * Search MusicBrainz for album
     */
    public function searchMusicBrainz(Album $album): ?array
    {
        try {
            $filter = new MusicBrainzReleaseFilter();
            $filter-&gt;setTitle($album-&gt;title);
            if ($album-&gt;artists-&gt;isNotEmpty()) {
                $filter-&gt;setArtistName($album-&gt;artists-&gt;first()-&gt;name);
            }
            $searchResults = $this-&gt;musicBrainzClient-&gt;search-&gt;release($filter);
            if ($searchResults-&gt;isEmpty()) {
                return null;
            }
            // Smart filtering using Collection methods
            $relevantResults = $searchResults
                -&gt;filter(fn($release) =&gt; $this-&gt;isRelevantMatch($release, $album))
                -&gt;sortByDesc(fn($release) =&gt; $this-&gt;calculateRelevanceScore($release, $album))
                -&gt;take(5);
            if ($relevantResults-&gt;isEmpty()) {
                return null;
            }
            $bestMatch = $relevantResults-&gt;first();
            $detailedData = $this-&gt;musicBrainzClient-&gt;lookup-&gt;release($bestMatch-&gt;id);
            return [
                &apos;source&apos; =&gt; &apos;musicbrainz&apos;,
                &apos;data&apos; =&gt; $detailedData,
                &apos;quality_score&apos; =&gt; $this-&gt;qualityValidator-&gt;scoreAlbumMatch($detailedData-&gt;toArray(), $album),
                &apos;search_results_count&apos; =&gt; $searchResults-&gt;count(),
                &apos;filtered_results_count&apos; =&gt; $relevantResults-&gt;count()
            ];
        } catch (\Exception $e) {
            Log::warning(&apos;MusicBrainz album search failed&apos;, [
                &apos;album_id&apos; =&gt; $album-&gt;id,
                &apos;error&apos; =&gt; $e-&gt;getMessage()
            ]);
            return null;
        }
    }
    /**
     * Search Discogs for album
     */
    public function searchDiscogs(Album $album): ?array
    {
        try {
            $filter = new DiscogsReleaseFilter();
            $filter-&gt;setTitle($album-&gt;title);
            if ($album-&gt;artists-&gt;isNotEmpty()) {
                $filter-&gt;setArtist($album-&gt;artists-&gt;first()-&gt;name);
            }
            $searchResults = $this-&gt;discogsClient-&gt;search-&gt;release($filter);
            if ($searchResults-&gt;isEmpty()) {
                return null;
            }
            $relevantResults = $searchResults
                -&gt;filter(fn($release) =&gt; $this-&gt;isRelevantDiscogsMatch($release, $album))
                -&gt;sortByDesc(fn($release) =&gt; $this-&gt;calculateDiscogsRelevanceScore($release, $album))
                -&gt;take(5);
            if ($relevantResults-&gt;isEmpty()) {
                return null;
            }
            $bestMatch = $relevantResults-&gt;first();
            $detailedData = $this-&gt;discogsClient-&gt;lookup-&gt;release($bestMatch-&gt;id);
            return [
                &apos;source&apos; =&gt; &apos;discogs&apos;,
                &apos;data&apos; =&gt; $detailedData,
                &apos;quality_score&apos; =&gt; $this-&gt;qualityValidator-&gt;scoreAlbumMatch($detailedData-&gt;toArray(), $album),
                &apos;search_results_count&apos; =&gt; $searchResults-&gt;count(),
                &apos;pagination&apos; =&gt; $this-&gt;discogsClient-&gt;search-&gt;getPagination()
            ];
        } catch (\Exception $e) {
            Log::warning(&apos;Discogs album search failed&apos;, [
                &apos;album_id&apos; =&gt; $album-&gt;id,
                &apos;error&apos; =&gt; $e-&gt;getMessage()
            ]);
            return null;
        }
    }
    /**
     * Advanced multi-strategy search
     */
    public function searchAdvanced(Album $album): array
    {
        // Strategy 1: Exact title + artist
        $exactFilter = new MusicBrainzReleaseFilter();
        $exactFilter-&gt;setTitle($album-&gt;title);
        if ($album-&gt;artists-&gt;isNotEmpty()) {
            $exactFilter-&gt;setArtistName($album-&gt;artists-&gt;first()-&gt;name);
        }
        $exactResults = $this-&gt;musicBrainzClient-&gt;search-&gt;release($exactFilter);
        // Strategy 2: Title only (fuzzy)
        $fuzzyFilter = new MusicBrainzReleaseFilter();
        $fuzzyFilter-&gt;setTitle($album-&gt;title);
        $fuzzyResults = $this-&gt;musicBrainzClient-&gt;search-&gt;release($fuzzyFilter);
        // Strategy 3: Artist-based
        $artistResults = collect();
        if ($album-&gt;artists-&gt;isNotEmpty()) {
            $artistFilter = new MusicBrainzReleaseFilter();
            $artistFilter-&gt;setArtistName($album-&gt;artists-&gt;first()-&gt;name);
            $artistResults = $this-&gt;musicBrainzClient-&gt;search-&gt;release($artistFilter);
        }
        // Combine and deduplicate
        $allResults = $exactResults
            -&gt;merge($fuzzyResults)
            -&gt;merge($artistResults)
            -&gt;unique(&apos;id&apos;)
            -&gt;filter(fn($release) =&gt; $this-&gt;isRelevantMatch($release, $album))
            -&gt;sortByDesc(fn($release) =&gt; $this-&gt;calculateRelevanceScore($release, $album));
        return [
            &apos;strategies&apos; =&gt; [
                &apos;exact&apos; =&gt; [&apos;count&apos; =&gt; $exactResults-&gt;count(), &apos;results&apos; =&gt; $exactResults-&gt;take(3)],
                &apos;fuzzy&apos; =&gt; [&apos;count&apos; =&gt; $fuzzyResults-&gt;count(), &apos;results&apos; =&gt; $fuzzyResults-&gt;take(3)],
                &apos;artist&apos; =&gt; [&apos;count&apos; =&gt; $artistResults-&gt;count(), &apos;results&apos; =&gt; $artistResults-&gt;take(3)],
            ],
            &apos;combined&apos; =&gt; [
                &apos;total_count&apos; =&gt; $allResults-&gt;count(),
                &apos;top_results&apos; =&gt; $allResults-&gt;take(10),
                &apos;best_match&apos; =&gt; $allResults-&gt;first()
            ]
        ];
    }
    private function isRelevantMatch($release, Album $album): bool
    {
        if (empty($release-&gt;title)) {
            return false;
        }
        $titleSimilarity = similar_text(
            strtolower($release-&gt;title),
            strtolower($album-&gt;title)
        );
        return $titleSimilarity &gt; 50;
    }
    private function isRelevantDiscogsMatch($release, Album $album): bool
    {
        if (empty($release-&gt;title)) {
            return false;
        }
        // Discogs titles often include artist name, so be more flexible
        $titleSimilarity = similar_text(
            strtolower($release-&gt;title),
            strtolower($album-&gt;title)
        );
        return $titleSimilarity &gt; 30;
    }
    private function calculateRelevanceScore($release, Album $album): float
    {
        $score = 0;
        // Title match (0-100)
        $score += similar_text(strtolower($release-&gt;title), strtolower($album-&gt;title));
        // Year match if available
        if (!empty($release-&gt;date) &amp;&amp; !empty($album-&gt;year)) {
            $releaseYear = substr($release-&gt;date, 0, 4);
            if ($releaseYear == $album-&gt;year) {
                $score += 30;
            }
        }
        return $score;
    }
    private function calculateDiscogsRelevanceScore($release, Album $album): float
    {
        $score = 0;
        // Title match (more flexible for Discogs)
        $score += similar_text(strtolower($release-&gt;title), strtolower($album-&gt;title)) * 0.8;
        // Year match
        if (!empty($release-&gt;year) &amp;&amp; !empty($album-&gt;year)) {
            if ($release-&gt;year == $album-&gt;year) {
                $score += 40;
            }
        }
        return $score;
    }
}</file><file path="app/Services/MetadataSearch/ArtistSearchService.php">&lt;?php
namespace App\Services\MetadataSearch;
use App\Models\Artist;
use App\Http\Integrations\MusicBrainz\MusicBrainzClient;
use App\Http\Integrations\Discogs\DiscogsClient;
use App\Http\Integrations\MusicBrainz\Filters\ArtistFilter as MusicBrainzArtistFilter;
use App\Http\Integrations\Discogs\Filters\ArtistFilter as DiscogsArtistFilter;
use App\Services\MetadataMatching\{MatchingStrategy, QualityValidator};
use Illuminate\Support\Facades\Log;
class ArtistSearchService
{
    public function __construct(
        private readonly MusicBrainzClient $musicBrainzClient,
        private readonly DiscogsClient $discogsClient,
        private readonly MatchingStrategy $matchingStrategy,
        private readonly QualityValidator $qualityValidator
    ) {}
    /**
     * Search all sources for artist metadata
     */
    public function searchAllSources(Artist $artist): array
    {
        return [
            &apos;musicbrainz&apos; =&gt; $this-&gt;searchMusicBrainz($artist),
            &apos;discogs&apos; =&gt; $this-&gt;searchDiscogs($artist),
        ];
    }
    /**
     * Search MusicBrainz for artist
     */
    public function searchMusicBrainz(Artist $artist): ?array
    {
        try {
            $filter = new MusicBrainzArtistFilter();
            $filter-&gt;setName($artist-&gt;name);
            $searchResults = $this-&gt;musicBrainzClient-&gt;search-&gt;artist($filter);
            if ($searchResults-&gt;isEmpty()) {
                return null;
            }
            $relevantResults = $searchResults
                -&gt;filter(fn($artistModel) =&gt; $this-&gt;isRelevantMatch($artistModel, $artist))
                -&gt;sortByDesc(fn($artistModel) =&gt; $this-&gt;calculateRelevanceScore($artistModel, $artist))
                -&gt;take(5);
            if ($relevantResults-&gt;isEmpty()) {
                return null;
            }
            $bestMatch = $relevantResults-&gt;first();
            $detailedData = $this-&gt;musicBrainzClient-&gt;lookup-&gt;artist($bestMatch-&gt;id);
            return [
                &apos;source&apos; =&gt; &apos;musicbrainz&apos;,
                &apos;data&apos; =&gt; $detailedData,
                &apos;quality_score&apos; =&gt; $this-&gt;qualityValidator-&gt;scoreArtistMatch($detailedData-&gt;toArray(), $artist),
                &apos;search_results_count&apos; =&gt; $searchResults-&gt;count()
            ];
        } catch (\Exception $e) {
            Log::warning(&apos;MusicBrainz artist search failed&apos;, [
                &apos;artist_id&apos; =&gt; $artist-&gt;id,
                &apos;error&apos; =&gt; $e-&gt;getMessage()
            ]);
            return null;
        }
    }
    /**
     * Search Discogs for artist
     */
    public function searchDiscogs(Artist $artist): ?array
    {
        try {
            $filter = new DiscogsArtistFilter();
            $filter-&gt;setTitle($artist-&gt;name);
            $searchResults = $this-&gt;discogsClient-&gt;search-&gt;artist($filter);
            if ($searchResults-&gt;isEmpty()) {
                return null;
            }
            $relevantResults = $searchResults
                -&gt;filter(fn($artistModel) =&gt; $this-&gt;isRelevantDiscogsMatch($artistModel, $artist))
                -&gt;sortByDesc(fn($artistModel) =&gt; $this-&gt;calculateDiscogsRelevanceScore($artistModel, $artist))
                -&gt;take(5);
            if ($relevantResults-&gt;isEmpty()) {
                return null;
            }
            $bestMatch = $relevantResults-&gt;first();
            $detailedData = $this-&gt;discogsClient-&gt;lookup-&gt;artist($bestMatch-&gt;id);
            return [
                &apos;source&apos; =&gt; &apos;discogs&apos;,
                &apos;data&apos; =&gt; $detailedData,
                &apos;quality_score&apos; =&gt; $this-&gt;qualityValidator-&gt;scoreArtistMatch($detailedData-&gt;toArray(), $artist),
                &apos;search_results_count&apos; =&gt; $searchResults-&gt;count(),
                &apos;pagination&apos; =&gt; $this-&gt;discogsClient-&gt;search-&gt;getPagination()
            ];
        } catch (\Exception $e) {
            Log::warning(&apos;Discogs artist search failed&apos;, [
                &apos;artist_id&apos; =&gt; $artist-&gt;id,
                &apos;error&apos; =&gt; $e-&gt;getMessage()
            ]);
            return null;
        }
    }
    private function isRelevantMatch($artistModel, Artist $artist): bool
    {
        if (empty($artistModel-&gt;name)) {
            return false;
        }
        $similarity = similar_text(
            strtolower($artistModel-&gt;name),
            strtolower($artist-&gt;name)
        );
        return $similarity &gt; 70;
    }
    private function isRelevantDiscogsMatch($artistModel, Artist $artist): bool
    {
        if (empty($artistModel-&gt;title)) {
            return false;
        }
        $similarity = similar_text(
            strtolower($artistModel-&gt;title),
            strtolower($artist-&gt;name)
        );
        return $similarity &gt; 70;
    }
    private function calculateRelevanceScore($artistModel, Artist $artist): float
    {
        return similar_text(strtolower($artistModel-&gt;name), strtolower($artist-&gt;name));
    }
    private function calculateDiscogsRelevanceScore($artistModel, Artist $artist): float
    {
        return similar_text(strtolower($artistModel-&gt;title), strtolower($artist-&gt;name));
    }
}</file><file path="app/Services/MetadataSearch/SongSearchService.php">&lt;?php
namespace App\Services\MetadataSearch;
use App\Models\Song;
use App\Http\Integrations\MusicBrainz\MusicBrainzClient;
use App\Http\Integrations\Discogs\DiscogsClient;
use App\Http\Integrations\MusicBrainz\Filters\RecordingFilter;
use App\Http\Integrations\Discogs\Filters\ReleaseFilter as DiscogsReleaseFilter;
use App\Services\MetadataMatching\{MatchingStrategy, QualityValidator};
use Illuminate\Support\Facades\Log;
class SongSearchService
{
    public function __construct(
        private readonly MusicBrainzClient $musicBrainzClient,
        private readonly DiscogsClient $discogsClient,
        private readonly MatchingStrategy $matchingStrategy,
        private readonly QualityValidator $qualityValidator
    ) {}
    /**
     * Search all sources for song metadata
     */
    public function searchAllSources(Song $song): array
    {
        return [
            &apos;musicbrainz&apos; =&gt; $this-&gt;searchMusicBrainz($song),
            &apos;discogs&apos; =&gt; $this-&gt;searchDiscogs($song),
        ];
    }
    /**
     * Search with album context for better accuracy
     */
    public function searchWithAlbumContext(Song $song, array $albumMetadata): array
    {
        if (empty($albumMetadata) || $albumMetadata[&apos;quality_score&apos;] === 0) {
            return $this-&gt;searchAllSources($song);
        }
        // Extract song data from album metadata
        $songData = $this-&gt;findSongInAlbumMetadata($song, $albumMetadata);
        if ($songData) {
            return [
                &apos;song&apos; =&gt; $songData,
                &apos;artists&apos; =&gt; $this-&gt;extractSongArtists($songData, $albumMetadata[&apos;source&apos;]),
                &apos;genres&apos; =&gt; $this-&gt;extractSongGenres($songData, $albumMetadata[&apos;source&apos;]),
                &apos;lyrics&apos; =&gt; null,
                &apos;quality_score&apos; =&gt; $this-&gt;qualityValidator-&gt;scoreSongMatch($songData, $song),
                &apos;source&apos; =&gt; $albumMetadata[&apos;source&apos;] . &apos;_album_context&apos;,
            ];
        }
        // Fallback to individual search
        return $this-&gt;searchAllSources($song);
    }
    /**
     * Search MusicBrainz for song
     */
    public function searchMusicBrainz(Song $song): ?array
    {
        try {
            $filter = new RecordingFilter();
            $filter-&gt;setTitle($song-&gt;title);
            if ($song-&gt;artists-&gt;isNotEmpty()) {
                $filter-&gt;setArtistName($song-&gt;artists-&gt;first()-&gt;name);
            }
            $searchResults = $this-&gt;musicBrainzClient-&gt;search-&gt;recording($filter);
            if ($searchResults-&gt;isEmpty()) {
                return null;
            }
            $relevantResults = $searchResults
                -&gt;filter(fn($recording) =&gt; $this-&gt;isRelevantMatch($recording, $song))
                -&gt;sortByDesc(fn($recording) =&gt; $this-&gt;calculateRelevanceScore($recording, $song))
                -&gt;take(5);
            if ($relevantResults-&gt;isEmpty()) {
                return null;
            }
            $bestMatch = $relevantResults-&gt;first();
            $detailedData = $this-&gt;musicBrainzClient-&gt;lookup-&gt;recording($bestMatch-&gt;id);
            return [
                &apos;source&apos; =&gt; &apos;musicbrainz&apos;,
                &apos;data&apos; =&gt; $detailedData,
                &apos;quality_score&apos; =&gt; $this-&gt;qualityValidator-&gt;scoreSongMatch($detailedData-&gt;toArray(), $song)
            ];
        } catch (\Exception $e) {
            Log::warning(&apos;MusicBrainz song search failed&apos;, [
                &apos;song_id&apos; =&gt; $song-&gt;id,
                &apos;error&apos; =&gt; $e-&gt;getMessage()
            ]);
            return null;
        }
    }
    /**
     * Search Discogs for song (via release context)
     */
    public function searchDiscogs(Song $song): ?array
    {
        try {
            if (!$song-&gt;album) {
                return null;
            }
            $filter = new DiscogsReleaseFilter();
            $filter-&gt;setTitle($song-&gt;album-&gt;title);
            if ($song-&gt;album-&gt;artists-&gt;isNotEmpty()) {
                $filter-&gt;setArtist($song-&gt;album-&gt;artists-&gt;first()-&gt;name);
            }
            $searchResults = $this-&gt;discogsClient-&gt;search-&gt;release($filter);
            if ($searchResults-&gt;isEmpty()) {
                return null;
            }
            // Look for the song in each release&apos;s tracklist
            foreach ($searchResults-&gt;take(5) as $release) {
                $detailedData = $this-&gt;discogsClient-&gt;lookup-&gt;release($release-&gt;id);
                $trackData = $this-&gt;findTrackInDiscogs($detailedData-&gt;toArray(), $song);
                if ($trackData) {
                    return [
                        &apos;source&apos; =&gt; &apos;discogs&apos;,
                        &apos;data&apos; =&gt; $trackData,
                        &apos;release_data&apos; =&gt; $detailedData,
                        &apos;quality_score&apos; =&gt; $this-&gt;qualityValidator-&gt;scoreSongMatch($trackData, $song)
                    ];
                }
            }
            return null;
        } catch (\Exception $e) {
            Log::warning(&apos;Discogs song search failed&apos;, [
                &apos;song_id&apos; =&gt; $song-&gt;id,
                &apos;error&apos; =&gt; $e-&gt;getMessage()
            ]);
            return null;
        }
    }
    private function findSongInAlbumMetadata(Song $song, array $albumMetadata): ?array
    {
        $data = $albumMetadata[&apos;data&apos;];
        $source = $albumMetadata[&apos;source&apos;];
        return match ($source) {
            &apos;musicbrainz&apos; =&gt; $this-&gt;findSongInMusicBrainzRelease($data, $song),
            &apos;discogs&apos; =&gt; $this-&gt;findTrackInDiscogs($data, $song),
            default =&gt; null,
        };
    }
    private function findSongInMusicBrainzRelease($releaseData, Song $song): ?array
    {
        if (!isset($releaseData[&apos;media&apos;])) {
            return null;
        }
        foreach ($releaseData[&apos;media&apos;] as $medium) {
            if (!isset($medium[&apos;tracks&apos;])) {
                continue;
            }
            foreach ($medium[&apos;tracks&apos;] as $track) {
                $similarity = $this-&gt;matchingStrategy-&gt;calculateSongSimilarity($track, $song);
                if ($similarity &gt;= 0.8) {
                    return $track;
                }
            }
        }
        return null;
    }
    private function findTrackInDiscogs(array $releaseData, Song $song): ?array
    {
        if (!isset($releaseData[&apos;tracklist&apos;])) {
            return null;
        }
        foreach ($releaseData[&apos;tracklist&apos;] as $track) {
            $similarity = $this-&gt;matchingStrategy-&gt;calculateSongSimilarity($track, $song);
            if ($similarity &gt;= 0.8) {
                // Enhance track data with release context
                $track[&apos;release_artists&apos;] = $releaseData[&apos;artists&apos;] ?? [];
                $track[&apos;release_genres&apos;] = array_merge(
                    $releaseData[&apos;genres&apos;] ?? [],
                    $releaseData[&apos;styles&apos;] ?? []
                );
                return $track;
            }
        }
        return null;
    }
    private function extractSongArtists($songData, string $source): array
    {
        // Implementation depends on source format
        return [];
    }
    private function extractSongGenres($songData, string $source): array
    {
        // Implementation depends on source format
        return [];
    }
    private function isRelevantMatch($recording, Song $song): bool
    {
        if (empty($recording-&gt;title)) {
            return false;
        }
        $similarity = similar_text(
            strtolower($recording-&gt;title),
            strtolower($song-&gt;title)
        );
        return $similarity &gt; 70;
    }
    private function calculateRelevanceScore($recording, Song $song): float
    {
        return similar_text(strtolower($recording-&gt;title), strtolower($song-&gt;title));
    }
}</file><file path="app/Services/QueueMetrics/Models/QueueMetric.php">&lt;?php
namespace App\Services\QueueMetrics\Models;
use Spatie\LaravelData\Data;
class QueueMetric extends Data
{
    public function __construct(
        public string  $title,
        public float   $value,
        public ?int    $previousValue = null,
        public string  $format = &apos;%d&apos;,
        public ?string $formattedValue = null,
        public ?string $formattedPreviousValue = null,
    )
    {
        $this-&gt;formattedValue = sprintf($format, $this-&gt;value);
        if ($this-&gt;previousValue) {
            $this-&gt;formattedPreviousValue = sprintf($format, $this-&gt;previousValue);
        }
    }
}</file><file path="app/Services/Streaming/Handlers/DASHStreamService.php">&lt;?php
namespace App\Services\Streaming\Handlers;
use App\Services\Streaming\StreamServiceInterface;
use Baander\Common\Streaming\TranscodeOptions;
use Baander\Transcoder\Application;
class DASHStreamService implements StreamServiceInterface
{
    private Application $application;
    public function __construct(Application $application)
    {
        $this-&gt;application = $application;
    }
    public function startStream(string $sessionId, TranscodeOptions $options, int $startTime = 0): void
    {
        // DASH-specific preparation logic (e.g., manifest creation)
        $this-&gt;application-&gt;startTranscoding($sessionId, $options, $startTime);
    }
    public function stopStream(string $sessionId): void
    {
        $this-&gt;application-&gt;stopTranscoding($sessionId);
    }
    public function seekStream(string $sessionId, TranscodeOptions $options, int $seekTime): void
    {
        $this-&gt;application-&gt;seek($sessionId, $options, $seekTime);
    }
}</file><file path="app/Services/Streaming/Handlers/HLSStreamService.php">&lt;?php
namespace App\Services\Streaming\Handlers;
use App\Services\Streaming\StreamServiceInterface;
use Baander\Common\Streaming\TranscodeOptions;
use Baander\Transcoder\Application;
class HLSStreamService implements StreamServiceInterface
{
    private Application $application;
    public function __construct(Application $application)
    {
        $this-&gt;application = $application;
    }
    public function startStream(string $sessionId, TranscodeOptions $options, int $startTime = 0): void
    {
        // Customize HLS-specific preparations here if needed
        $this-&gt;application-&gt;startTranscoding($sessionId, $options, $startTime);
    }
    public function stopStream(string $sessionId): void
    {
        $this-&gt;application-&gt;stopTranscoding($sessionId);
    }
    public function seekStream(string $sessionId, TranscodeOptions $options, int $seekTime): void
    {
        $this-&gt;application-&gt;seek($sessionId, $options, $seekTime);
    }
}</file><file path="app/Services/Streaming/StreamService.php">&lt;?php
namespace App\Services\Streaming;
use  App\Models\TranscodingSession;
use Baander\Common\Streaming\TranscodeOptions;
class StreamService implements StreamServiceInterface
{
    private array $protocolHandlers;
    public function __construct(array $protocolHandlers = [])
    {
        $this-&gt;protocolHandlers = $protocolHandlers;
    }
    public function startStream(string $sessionId, TranscodeOptions $options, int $startTime = 0): void
    {
        TranscodingSession::create([
            &apos;session_id&apos; =&gt; $sessionId,
            &apos;protocol&apos;   =&gt; $options-&gt;protocol,
            &apos;options&apos;    =&gt; $options,
        ]);
        $handler = $this-&gt;resolveHandler($options-&gt;protocol);
        $handler-&gt;startStream($sessionId, $options, $startTime);
    }
    public function stopStream(string $sessionId): void
    {
        TranscodingSession::whereSessionId($sessionId)-&gt;delete();
        foreach ($this-&gt;protocolHandlers as $handler) {
            $handler-&gt;stopStream($sessionId);
        }
    }
    public function seekStream(string $sessionId, TranscodeOptions $options, int $seekTime): void
    {
        $handler = $this-&gt;resolveHandler($options-&gt;protocol);
        $handler-&gt;seekStream($sessionId, $options, $seekTime);
    }
    private function resolveHandler(string $protocol): StreamServiceInterface
    {
        if (!isset($this-&gt;protocolHandlers[$protocol])) {
            throw new \InvalidArgumentException(&quot;Protocol {$protocol} not supported.&quot;);
        }
        return $this-&gt;protocolHandlers[$protocol];
    }
}</file><file path="app/Services/Streaming/StreamServiceInterface.php">&lt;?php
namespace App\Services\Streaming;
use Baander\Common\Streaming\TranscodeOptions;
interface StreamServiceInterface
{
    public function startStream(string $sessionId, TranscodeOptions $options, int $startTime = 0): void;
    public function stopStream(string $sessionId): void;
    public function seekStream(string $sessionId, TranscodeOptions $options, int $seekTime): void;
}</file><file path="app/Services/SystemMetricsCollectorService.php">&lt;?php
namespace App\Services;
class SystemMetricsCollectorService
{
    public function memoryUsage()
    {
        return memory_get_usage();
    }
    public function systemLoadAverage()
    {
        return sys_getloadavg();
    }
    public function swooleVm()
    {
        return swoole_get_vm_status();
    }
}</file><file path="app/Services/SystemMonitor.php">&lt;?php
namespace App\Services;
class SystemMonitor
{
    private array $previousCpuStats = [];
    /**
     * Get comprehensive system load information
     */
    public function getSystemLoad(): array
    {
        return [
            &apos;cpu&apos; =&gt; $this-&gt;getCpuUsage(),
            &apos;memory&apos; =&gt; $this-&gt;getMemoryUsage(),
            &apos;timestamp&apos; =&gt; now()-&gt;toISOString(),
        ];
    }
    /**
     * Get CPU usage information
     */
    public function getCpuUsage(): array
    {
        $loadAvg = sys_getloadavg();
        $cpuCount = $this-&gt;getCpuCoreCount();
        return [
            &apos;load_average&apos; =&gt; [
                &apos;1_min&apos; =&gt; round($loadAvg[0], 2),
                &apos;5_min&apos; =&gt; round($loadAvg[1], 2),
                &apos;15_min&apos; =&gt; round($loadAvg[2], 2),
            ],
            &apos;load_percentage&apos; =&gt; [
                &apos;1_min&apos; =&gt; round(($loadAvg[0] / $cpuCount) * 100, 2),
                &apos;5_min&apos; =&gt; round(($loadAvg[1] / $cpuCount) * 100, 2),
                &apos;15_min&apos; =&gt; round(($loadAvg[2] / $cpuCount) * 100, 2),
            ],
            &apos;cores&apos; =&gt; $this-&gt;getPerCoreUsage(),
            &apos;core_count&apos; =&gt; $cpuCount,
            &apos;overall_percentage&apos; =&gt; $this-&gt;getOverallCpuPercentage(),
        ];
    }
    /**
     * Get memory usage information
     */
    public function getMemoryUsage(): array
    {
        $meminfo = $this-&gt;parseMeminfo();
        $totalMb = round($meminfo[&apos;MemTotal&apos;] / 1024, 2);
        $availableMb = round($meminfo[&apos;MemAvailable&apos;] / 1024, 2);
        $usedMb = round($totalMb - $availableMb, 2);
        $usedPercentage = $totalMb &gt; 0 ? round(($usedMb / $totalMb) * 100, 2) : 0;
        return [
            &apos;total_mb&apos; =&gt; $totalMb,
            &apos;used_mb&apos; =&gt; $usedMb,
            &apos;available_mb&apos; =&gt; $availableMb,
            &apos;used_percentage&apos; =&gt; $usedPercentage,
            &apos;available_percentage&apos; =&gt; round(100 - $usedPercentage, 2),
            &apos;buffers_mb&apos; =&gt; round($meminfo[&apos;Buffers&apos;] / 1024, 2),
            &apos;cached_mb&apos; =&gt; round($meminfo[&apos;Cached&apos;] / 1024, 2),
            &apos;swap&apos; =&gt; [
                &apos;total_mb&apos; =&gt; round($meminfo[&apos;SwapTotal&apos;] / 1024, 2),
                &apos;used_mb&apos; =&gt; round(($meminfo[&apos;SwapTotal&apos;] - $meminfo[&apos;SwapFree&apos;]) / 1024, 2),
                &apos;free_mb&apos; =&gt; round($meminfo[&apos;SwapFree&apos;] / 1024, 2),
                &apos;used_percentage&apos; =&gt; $meminfo[&apos;SwapTotal&apos;] &gt; 0
                    ? round((($meminfo[&apos;SwapTotal&apos;] - $meminfo[&apos;SwapFree&apos;]) / $meminfo[&apos;SwapTotal&apos;]) * 100, 2)
                    : 0,
            ],
        ];
    }
    /**
     * Get per-core CPU usage
     */
    public function getPerCoreUsage(): array
    {
        $cores = [];
        $stat = file_get_contents(&apos;/proc/stat&apos;);
        if (!$stat) {
            return [];
        }
        $lines = explode(&quot;\n&quot;, $stat);
        foreach ($lines as $line) {
            if (preg_match(&apos;/^cpu(\d+)\s+(.+)/&apos;, $line, $matches)) {
                $coreId = (int) $matches[1];
                $values = array_map(&apos;intval&apos;, preg_split(&apos;/\s+/&apos;, trim($matches[2])));
                // CPU time values: user, nice, system, idle, iowait, irq, softirq, steal
                $idle = $values[3] + ($values[4] ?? 0); // idle + iowait
                $total = array_sum($values);
                $usage = $total &gt; 0 ? round((($total - $idle) / $total) * 100, 2) : 0;
                $cores[] = [
                    &apos;core_id&apos; =&gt; $coreId,
                    &apos;usage_percentage&apos; =&gt; $usage,
                    &apos;user&apos; =&gt; round(($values[0] / $total) * 100, 2),
                    &apos;system&apos; =&gt; round(($values[2] / $total) * 100, 2),
                    &apos;idle&apos; =&gt; round(($idle / $total) * 100, 2),
                    &apos;iowait&apos; =&gt; round(($values[4] ?? 0 / $total) * 100, 2),
                ];
            }
        }
        return $cores;
    }
    /**
     * Get overall CPU percentage (real-time calculation)
     */
    public function getOverallCpuPercentage(): float
    {
        $stat = file_get_contents(&apos;/proc/stat&apos;);
        if (!$stat) {
            return 0.0;
        }
        // Get the first line (overall CPU stats)
        $lines = explode(&quot;\n&quot;, $stat);
        $cpuLine = $lines[0];
        if (!preg_match(&apos;/^cpu\s+(.+)/&apos;, $cpuLine, $matches)) {
            return 0.0;
        }
        $values = array_map(&apos;intval&apos;, preg_split(&apos;/\s+/&apos;, trim($matches[1])));
        // Calculate current usage
        $idle = $values[3] + ($values[4] ?? 0); // idle + iowait
        $total = array_sum($values);
        // If we have previous stats, calculate the difference
        if (!empty($this-&gt;previousCpuStats)) {
            $totalDiff = $total - $this-&gt;previousCpuStats[&apos;total&apos;];
            $idleDiff = $idle - $this-&gt;previousCpuStats[&apos;idle&apos;];
            if ($totalDiff &gt; 0) {
                $usage = round((($totalDiff - $idleDiff) / $totalDiff) * 100, 2);
            } else {
                $usage = 0.0;
            }
        } else {
            $usage = $total &gt; 0 ? round((($total - $idle) / $total) * 100, 2) : 0.0;
        }
        // Store current stats for next calculation
        $this-&gt;previousCpuStats = [
            &apos;total&apos; =&gt; $total,
            &apos;idle&apos; =&gt; $idle,
        ];
        return $usage;
    }
    /**
     * Get CPU core count
     */
    public function getCpuCoreCount(): int
    {
        // Try nproc first (most reliable)
        $output = shell_exec(&apos;nproc 2&gt;/dev/null&apos;);
        if ($output) {
            return (int) trim($output);
        }
        // Fallback: count from /proc/cpuinfo
        $cpuinfo = file_get_contents(&apos;/proc/cpuinfo&apos;);
        if ($cpuinfo) {
            return substr_count($cpuinfo, &apos;processor&apos;);
        }
        return 1; // Ultimate fallback
    }
    /**
     * Parse /proc/meminfo into an array
     */
    protected function parseMeminfo(): array
    {
        $meminfo = file_get_contents(&apos;/proc/meminfo&apos;);
        $memdata = [];
        if (!$meminfo) {
            return $memdata;
        }
        foreach (explode(&quot;\n&quot;, $meminfo) as $line) {
            if (preg_match(&apos;/^(\w+):\s*(\d+)\s*kB/&apos;, $line, $matches)) {
                $memdata[$matches[1]] = (int) $matches[2];
            }
        }
        // Set defaults for missing values
        $defaults = [
            &apos;MemTotal&apos; =&gt; 0,
            &apos;MemAvailable&apos; =&gt; $memdata[&apos;MemFree&apos;] ?? 0,
            &apos;MemFree&apos; =&gt; 0,
            &apos;Buffers&apos; =&gt; 0,
            &apos;Cached&apos; =&gt; 0,
            &apos;SwapTotal&apos; =&gt; 0,
            &apos;SwapFree&apos; =&gt; 0,
        ];
        return array_merge($defaults, $memdata);
    }
    /**
     * Get disk usage for specified path
     */
    public function getDiskUsage(string $path = &apos;/&apos;): array
    {
        $totalBytes = disk_total_space($path);
        $freeBytes = disk_free_space($path);
        $usedBytes = $totalBytes - $freeBytes;
        return [
            &apos;path&apos; =&gt; $path,
            &apos;total_mb&apos; =&gt; round($totalBytes / (1024 * 1024), 2),
            &apos;used_mb&apos; =&gt; round($usedBytes / (1024 * 1024), 2),
            &apos;free_mb&apos; =&gt; round($freeBytes / (1024 * 1024), 2),
            &apos;used_percentage&apos; =&gt; $totalBytes &gt; 0 ? round(($usedBytes / $totalBytes) * 100, 2) : 0,
            &apos;free_percentage&apos; =&gt; $totalBytes &gt; 0 ? round(($freeBytes / $totalBytes) * 100, 2) : 0,
        ];
    }
    /**
     * Get system uptime
     */
    public function getUptime(): array
    {
        $uptime = file_get_contents(&apos;/proc/uptime&apos;);
        if (!$uptime) {
            return [&apos;seconds&apos; =&gt; 0, &apos;formatted&apos; =&gt; &apos;Unknown&apos;];
        }
        $uptimeSeconds = (float) explode(&apos; &apos;, $uptime)[0];
        $days = floor($uptimeSeconds / 86400);
        $hours = floor(($uptimeSeconds % 86400) / 3600);
        $minutes = floor(($uptimeSeconds % 3600) / 60);
        return [
            &apos;seconds&apos; =&gt; round($uptimeSeconds, 2),
            &apos;formatted&apos; =&gt; sprintf(&apos;%dd %dh %dm&apos;, $days, $hours, $minutes),
            &apos;days&apos; =&gt; $days,
            &apos;hours&apos; =&gt; $hours,
            &apos;minutes&apos; =&gt; $minutes,
        ];
    }
    /**
     * Get system health summary
     */
    public function getHealthSummary(): array
    {
        $cpu = $this-&gt;getCpuUsage();
        $memory = $this-&gt;getMemoryUsage();
        $disk = $this-&gt;getDiskUsage();
        return [
            &apos;status&apos; =&gt; $this-&gt;determineHealthStatus($cpu, $memory, $disk),
            &apos;cpu_load_1min&apos; =&gt; $cpu[&apos;load_percentage&apos;][&apos;1_min&apos;],
            &apos;cpu_overall_percentage&apos; =&gt; $cpu[&apos;overall_percentage&apos;],
            &apos;memory_used_percentage&apos; =&gt; $memory[&apos;used_percentage&apos;],
            &apos;disk_used_percentage&apos; =&gt; $disk[&apos;used_percentage&apos;],
            &apos;uptime&apos; =&gt; $this-&gt;getUptime()[&apos;formatted&apos;],
            &apos;timestamp&apos; =&gt; now()-&gt;toISOString(),
        ];
    }
    /**
     * Determine overall system health status
     */
    protected function determineHealthStatus(array $cpu, array $memory, array $disk): string
    {
        $cpuLoad = $cpu[&apos;load_percentage&apos;][&apos;1_min&apos;];
        $memoryUsage = $memory[&apos;used_percentage&apos;];
        $diskUsage = $disk[&apos;used_percentage&apos;];
        if ($cpuLoad &gt; 90 || $memoryUsage &gt; 95 || $diskUsage &gt; 95) {
            return &apos;critical&apos;;
        }
        if ($cpuLoad &gt; 80 || $memoryUsage &gt; 85 || $diskUsage &gt; 85) {
            return &apos;warning&apos;;
        }
        return &apos;healthy&apos;;
    }
}</file><file path="app/Services/TranscoderService.php">&lt;?php
namespace App\Services;
use Baander\Transcoder\Application;
class TranscoderService
{
    private $application;
    public function __construct(Application $application)
    {
        $this-&gt;application = $application;
    }
    public function startTranscoding(string $sessionId, array $options, int $startTime = 0): void
    {
        $transcodeOptions = $this-&gt;mapTranscodeOptions($options);
        $this-&gt;application-&gt;startTranscoding($sessionId, $transcodeOptions, $startTime);
    }
    public function stopTranscoding(string $sessionId): void
    {
        $this-&gt;application-&gt;stopTranscoding($sessionId);
    }
    public function seek(string $sessionId, array $options, int $seekTime): void
    {
        $transcodeOptions = $this-&gt;mapTranscodeOptions($options);
        $this-&gt;application-&gt;seek($sessionId, $transcodeOptions, $seekTime);
    }
    private function mapTranscodeOptions(array $options): \Baander\Common\Streaming\TranscodeOptions
    {
        $videoProfile = new \Baander\Common\Streaming\VideoProfile(
            $options[&apos;video_profile&apos;][&apos;width&apos;] ?? null,
            $options[&apos;video_profile&apos;][&apos;height&apos;] ?? null,
            $options[&apos;video_profile&apos;][&apos;bitrate&apos;] ?? null
        );
        $audioProfile = new \Baander\Common\Streaming\AudioProfile(
            $options[&apos;audio_profile&apos;][&apos;bitrate&apos;] ?? null
        );
        return new \Baander\Common\Streaming\TranscodeOptions(
            $options[&apos;input_file_path&apos;],
            $options[&apos;output_directory_path&apos;],
            $videoProfile,
            $audioProfile
        );
    }
}</file><file path="bin/dev_refresh.sh">#!/usr/bin/env bash
cd /var/www/html
/usr/bin/composer du
php artisan optimize:clear
php artisan clear-compiled
php artisan setup:dev --fresh</file><file path="bin/lint.php">&lt;?php
/**
 * Detects potential design issues in files within the provided directory.
 *
 * @param string $rootDir The root directory to start scanning
 *
 * @return array
 */
function detectDesignIssues(string $rootDir): array {
    $issues = [];
    $directoryIterator = new RecursiveIteratorIterator(new RecursiveDirectoryIterator($rootDir));
    foreach ($directoryIterator as $fileInfo) {
        if ($fileInfo-&gt;isFile() &amp;&amp; $fileInfo-&gt;getExtension() === &apos;php&apos;) {
            $fileContent = file_get_contents($fileInfo-&gt;getPathname());
            $filePath = $fileInfo-&gt;getPathname();
            // Detect fat controllers
            if (str_contains($filePath, &apos;Controller&apos;)) {
                if (substr_count($fileContent, &apos;function&apos;) &gt; 5) {
                    $issues[] = &quot;Fat controller detected: $filePath&quot;;
                }
            }
            // Detect fat models
            if (str_contains($filePath, &apos;Model&apos;)) {
                if (substr_count($fileContent, &apos;function&apos;) &gt; 15) { // Adjusted threshold to 15
                    $issues[] = &quot;Fat model detected: $filePath&quot;;
                }
            }
            // Detect code duplication
            if (substr_count($fileContent, &apos;-&gt;&apos;) &gt; 20) {
                $issues[] = &quot;Potential code duplication detected: $filePath&quot;;
            }
            // Detect high cyclomatic complexity
            $functionMatches = [];
            preg_match_all(&apos;/function\s+\w+\s*\(/&apos;, $fileContent, $functionMatches);
            foreach ($functionMatches[0] as $functionMatch) {
                $startPos = strpos($fileContent, $functionMatch);
                $functionBody = substr($fileContent, $startPos);
                if (preg_match_all(&apos;/\b(if|else|for|foreach|while|case|catch)\b/&apos;, $functionBody, $complexityMatches) &gt; 10) {
                    $issues[] = &quot;High cyclomatic complexity in function: $functionMatch in file: $filePath&quot;;
                }
            }
        }
    }
    return $issues;
}
$appDirectory = __DIR__ . &apos;/../app&apos;;
// Detect design issues in the app directory
$designIssues = detectDesignIssues($appDirectory);
// Print detected issues
foreach ($designIssues as $issue) {
    echo $issue . &quot;\n&quot;;
}</file><file path="bootstrap/app.php">&lt;?php
/*
|--------------------------------------------------------------------------
| Create The Application
|--------------------------------------------------------------------------
|
| The first thing we will do is create a new Laravel application instance
| which serves as the &quot;glue&quot; for all the components of Laravel, and is
| the IoC container for the system binding all of the various parts.
|
*/
$app = new Illuminate\Foundation\Application(
    $_ENV[&apos;APP_BASE_PATH&apos;] ?? dirname(__DIR__)
);
/*
|--------------------------------------------------------------------------
| Bind Important Interfaces
|--------------------------------------------------------------------------
|
| Next, we need to bind some important interfaces into the container so
| we will be able to resolve them when needed. The kernels serve the
| incoming requests to this application from both the web and CLI.
|
*/
$app-&gt;singleton(
    Illuminate\Contracts\Http\Kernel::class,
    App\Http\Kernel::class
);
$app-&gt;singleton(
    Illuminate\Contracts\Console\Kernel::class,
    App\Console\Kernel::class
);
$app-&gt;singleton(
    Illuminate\Contracts\Debug\ExceptionHandler::class,
    App\Exceptions\Handler::class
);
/*
|--------------------------------------------------------------------------
| Return The Application
|--------------------------------------------------------------------------
|
| This script returns the application instance. The instance is given to
| the calling script so we can separate the building of the instances
| from the actual running of the application and sending responses.
|
*/
return $app;</file><file path="bootstrap/cache/.gitignore">*
!.gitignore</file><file path="config/apm.php">&lt;?php
// config/apm.php
return [
    &apos;enabled&apos; =&gt; env(&apos;APM_ENABLED&apos;, true),
    &apos;sampling_rate&apos; =&gt; env(&apos;APM_SAMPLING_RATE&apos;, 1.0),
    &apos;service_name&apos; =&gt; env(&apos;APM_SERVICE_NAME&apos;, &apos;bander-app&apos;),
    &apos;service_version&apos; =&gt; env(&apos;APM_SERVICE_VERSION&apos;, &apos;1.0.0&apos;),
    &apos;environment&apos; =&gt; env(&apos;APP_ENV&apos;, &apos;production&apos;),
    &apos;server_url&apos; =&gt; env(&apos;ELASTIC_APM_SERVER_URL&apos;),
    &apos;secret_token&apos; =&gt; env(&apos;ELASTIC_APM_SECRET_TOKEN&apos;),
    &apos;transaction&apos; =&gt; [
        &apos;max_spans&apos; =&gt; env(&apos;APM_MAX_SPANS&apos;, 500),
        &apos;stack_trace_limit&apos; =&gt; env(&apos;APM_STACK_TRACE_LIMIT&apos;, 50),
        &apos;capture_body&apos; =&gt; env(&apos;APM_CAPTURE_BODY&apos;, &apos;errors&apos;),
    ],
    &apos;ignore_patterns&apos; =&gt; [
        &apos;routes&apos; =&gt; [
            &apos;/health*&apos;,
            &apos;/metrics*&apos;,
            &apos;/_ignition*&apos;,
            &apos;/telescope*&apos;,
            &apos;/horizon*&apos;,
        ],
        &apos;user_agents&apos; =&gt; [
            &apos;kube-probe*&apos;,
            &apos;GoogleHC*&apos;,
            &apos;ELB-HealthChecker*&apos;,
        ],
    ],
    &apos;context&apos; =&gt; [
        &apos;capture_headers&apos; =&gt; env(&apos;APM_CAPTURE_HEADERS&apos;, true),
        &apos;capture_env&apos; =&gt; env(&apos;APM_CAPTURE_ENV&apos;, false),
        &apos;sanitize_field_names&apos; =&gt; [
            &apos;password&apos;,
            &apos;passwd&apos;,
            &apos;pwd&apos;,
            &apos;secret&apos;,
            &apos;token&apos;,
            &apos;key&apos;,
            &apos;auth&apos;,
            &apos;credit&apos;,
            &apos;card&apos;,
            &apos;authorization&apos;,
            &apos;cookie&apos;,
            &apos;session&apos;,
        ],
    ],
    &apos;monitoring&apos; =&gt; [
        &apos;auth&apos; =&gt; env(&apos;APM_MONITOR_AUTH&apos;, true),
        &apos;database&apos; =&gt; env(&apos;APM_MONITOR_DATABASE&apos;, true),
        &apos;cache&apos; =&gt; env(&apos;APM_MONITOR_CACHE&apos;, true),
        &apos;http_client&apos; =&gt; env(&apos;APM_MONITOR_HTTP_CLIENT&apos;, true),
        &apos;redis&apos; =&gt; env(&apos;APM_MONITOR_REDIS&apos;, true),
        &apos;queue&apos; =&gt; env(&apos;APM_MONITOR_QUEUE&apos;, true),
        &apos;always_sample_responses&apos; =&gt; (bool)env(&apos;APM_ALWAYS_SAMPLE_RESPONSES&apos;, false),
    ],
    &apos;swoole&apos; =&gt; [
        &apos;monitor_workers&apos; =&gt; env(&apos;APM_SWOOLE_MONITOR_WORKERS&apos;, true),
        &apos;monitor_coroutines&apos; =&gt; env(&apos;APM_SWOOLE_MONITOR_COROUTINES&apos;, true),
        &apos;worker_metrics_interval&apos; =&gt; env(&apos;APM_SWOOLE_METRICS_INTERVAL&apos;, 60), // seconds
        &apos;max_coroutine_spans&apos; =&gt; env(&apos;APM_SWOOLE_MAX_COROUTINE_SPANS&apos;, 100),
    ],
    &apos;performance&apos; =&gt; [
        &apos;slow_request_threshold_ms&apos; =&gt; env(&apos;APM_SLOW_REQUEST_THRESHOLD&apos;, 2000),
        &apos;memory_threshold_mb&apos; =&gt; env(&apos;APM_MEMORY_THRESHOLD&apos;, 256),
    ],
];</file><file path="config/broadcasting.php">&lt;?php
return [
    /*
    |--------------------------------------------------------------------------
    | Default Broadcaster
    |--------------------------------------------------------------------------
    |
    | This option controls the default broadcaster that will be used by the
    | framework when an event needs to be broadcast. You may set this to
    | any of the connections defined in the &quot;connections&quot; array below.
    |
    | Supported: &quot;pusher&quot;, &quot;ably&quot;, &quot;redis&quot;, &quot;log&quot;, &quot;null&quot;
    |
    */
    &apos;default&apos; =&gt; env(&apos;BROADCAST_DRIVER&apos;, &apos;null&apos;),
    /*
    |--------------------------------------------------------------------------
    | Broadcast Connections
    |--------------------------------------------------------------------------
    |
    | Here you may define all of the broadcast connections that will be used
    | to broadcast events to other systems or over websockets. Samples of
    | each available type of connection are provided inside this array.
    |
    */
    &apos;connections&apos; =&gt; [
        &apos;reverb&apos; =&gt; [
            &apos;driver&apos; =&gt; &apos;reverb&apos;,
            &apos;key&apos; =&gt; env(&apos;REVERB_APP_KEY&apos;),
            &apos;secret&apos; =&gt; env(&apos;REVERB_APP_SECRET&apos;),
            &apos;app_id&apos; =&gt; env(&apos;REVERB_APP_ID&apos;),
            &apos;options&apos; =&gt; [
                &apos;host&apos; =&gt; env(&apos;REVERB_HOST&apos;),
                &apos;port&apos; =&gt; env(&apos;REVERB_PORT&apos;, 443),
                &apos;scheme&apos; =&gt; env(&apos;REVERB_SCHEME&apos;, &apos;https&apos;),
                &apos;useTLS&apos; =&gt; env(&apos;REVERB_SCHEME&apos;, &apos;https&apos;) === &apos;https&apos;,
            ],
            &apos;client_options&apos; =&gt; [
                // Guzzle client options: https://docs.guzzlephp.org/en/stable/request-options.html
            ],
        ],
        &apos;pusher&apos; =&gt; [
            &apos;driver&apos;         =&gt; &apos;pusher&apos;,
            &apos;key&apos;            =&gt; env(&apos;PUSHER_APP_KEY&apos;),
            &apos;secret&apos;         =&gt; env(&apos;PUSHER_APP_SECRET&apos;),
            &apos;app_id&apos;         =&gt; env(&apos;PUSHER_APP_ID&apos;),
            &apos;options&apos;        =&gt; [
                &apos;cluster&apos;   =&gt; env(&apos;PUSHER_APP_CLUSTER&apos;),
                &apos;host&apos;      =&gt; env(&apos;PUSHER_HOST&apos;) ?: &apos;api-&apos; . env(&apos;PUSHER_APP_CLUSTER&apos;, &apos;mt1&apos;) . &apos;.pusher.com&apos;,
                &apos;port&apos;      =&gt; env(&apos;PUSHER_PORT&apos;, 443),
                &apos;scheme&apos;    =&gt; env(&apos;PUSHER_SCHEME&apos;, &apos;https&apos;),
                &apos;encrypted&apos; =&gt; true,
                &apos;useTLS&apos;    =&gt; env(&apos;PUSHER_SCHEME&apos;, &apos;https&apos;) === &apos;https&apos;,
            ],
            &apos;client_options&apos; =&gt; [
                // Guzzle client options: https://docs.guzzlephp.org/en/stable/request-options.html
            ],
        ],
        &apos;ably&apos; =&gt; [
            &apos;driver&apos; =&gt; &apos;ably&apos;,
            &apos;key&apos;    =&gt; env(&apos;ABLY_KEY&apos;),
        ],
        &apos;redis&apos; =&gt; [
            &apos;driver&apos;     =&gt; &apos;redis&apos;,
            &apos;connection&apos; =&gt; &apos;default&apos;,
        ],
        &apos;log&apos; =&gt; [
            &apos;driver&apos; =&gt; &apos;log&apos;,
        ],
        &apos;null&apos; =&gt; [
            &apos;driver&apos; =&gt; &apos;null&apos;,
        ],
    ],
];</file><file path="config/eloquent-filtering.php">&lt;?php
declare(strict_types=1);
return [
    &apos;default_allowed_sort_list&apos; =&gt; &apos;none&apos;,
    &apos;suppress&apos; =&gt; [
        &apos;filter&apos; =&gt; [
            &apos;invalid&apos;          =&gt; false,
            &apos;missing&apos;          =&gt; false,
            &apos;malformed_format&apos; =&gt; false,
            &apos;denied&apos;           =&gt; false,
        ],
        &apos;sort&apos; =&gt; [
            &apos;malformed_format&apos; =&gt; false,
            &apos;denied&apos;           =&gt; false,
        ],
    ],
    &apos;custom_filters&apos; =&gt; [
    ],
];</file><file path="config/ffmpeg.php">&lt;?php
return [
    &apos;ffmpeg&apos; =&gt; [
        &apos;binaries&apos; =&gt; env(&apos;FFMPEG_BINARIES&apos;, &apos;ffmpeg&apos;),
        &apos;threads&apos; =&gt; 12,   // set to false to disable the default &apos;threads&apos; filter
    ],
    &apos;ffprobe&apos; =&gt; [
        &apos;binaries&apos; =&gt; env(&apos;FFPROBE_BINARIES&apos;, &apos;ffprobe&apos;),
    ],
    &apos;timeout&apos; =&gt; 3600,
    &apos;log_channel&apos; =&gt; env(&apos;LOG_CHANNEL&apos;, &apos;stack&apos;),   // set to false to completely disable logging
    &apos;temporary_files_root&apos; =&gt; env(&apos;FFMPEG_TEMPORARY_FILES_ROOT&apos;, sys_get_temp_dir()),
    &apos;temporary_files_encrypted_hls&apos; =&gt; env(&apos;FFMPEG_TEMPORARY_ENCRYPTED_HLS&apos;, env(&apos;FFMPEG_TEMPORARY_FILES_ROOT&apos;, sys_get_temp_dir())),
];</file><file path="config/filesystems.php">&lt;?php
return [
    /*
    |--------------------------------------------------------------------------
    | Default Filesystem Disk
    |--------------------------------------------------------------------------
    |
    | Here you may specify the default filesystem disk that should be used
    | by the framework. The &quot;local&quot; disk, as well as a variety of cloud
    | based disks are available to your application. Just store away!
    |
    */
    &apos;default&apos; =&gt; env(&apos;FILESYSTEM_DISK&apos;, &apos;local&apos;),
    /*
    |--------------------------------------------------------------------------
    | Filesystem Disks
    |--------------------------------------------------------------------------
    |
    | Here you may configure as many filesystem &quot;disks&quot; as you wish, and you
    | may even configure multiple disks of the same driver. Defaults have
    | been set up for each driver as an example of the required values.
    |
    | Supported Drivers: &quot;local&quot;, &quot;ftp&quot;, &quot;sftp&quot;, &quot;s3&quot;
    |
    */
    &apos;disks&apos; =&gt; [
        &apos;local&apos; =&gt; [
            &apos;driver&apos; =&gt; &apos;local&apos;,
            &apos;root&apos;   =&gt; storage_path(&apos;app&apos;),
            &apos;throw&apos;  =&gt; false,
        ],
        &apos;public&apos; =&gt; [
            &apos;driver&apos;     =&gt; &apos;local&apos;,
            &apos;root&apos;       =&gt; storage_path(&apos;app/public&apos;),
            &apos;url&apos;        =&gt; env(&apos;APP_URL&apos;) . &apos;/storage&apos;,
            &apos;visibility&apos; =&gt; &apos;public&apos;,
            &apos;throw&apos;      =&gt; false,
        ],
        &apos;s3&apos; =&gt; [
            &apos;driver&apos;                  =&gt; &apos;s3&apos;,
            &apos;key&apos;                     =&gt; env(&apos;AWS_ACCESS_KEY_ID&apos;),
            &apos;secret&apos;                  =&gt; env(&apos;AWS_SECRET_ACCESS_KEY&apos;),
            &apos;region&apos;                  =&gt; env(&apos;AWS_DEFAULT_REGION&apos;),
            &apos;bucket&apos;                  =&gt; env(&apos;AWS_BUCKET&apos;),
            &apos;url&apos;                     =&gt; env(&apos;AWS_URL&apos;),
            &apos;endpoint&apos;                =&gt; env(&apos;AWS_ENDPOINT&apos;),
            &apos;use_path_style_endpoint&apos; =&gt; env(&apos;AWS_USE_PATH_STYLE_ENDPOINT&apos;, false),
            &apos;throw&apos;                   =&gt; false,
        ],
    ],
    /*
    |--------------------------------------------------------------------------
    | Symbolic Links
    |--------------------------------------------------------------------------
    |
    | Here you may configure the symbolic links that will be created when the
    | `storage:link` Artisan command is executed. The array keys should be
    | the locations of the links and the values should be their targets.
    |
    */
    &apos;links&apos; =&gt; [
        public_path(&apos;storage&apos;) =&gt; storage_path(&apos;app/public&apos;),
    ],
];</file><file path="config/fortify.php">&lt;?php
use Laravel\Fortify\Features;
return [
    /*
    |--------------------------------------------------------------------------
    | Fortify Guard
    |--------------------------------------------------------------------------
    |
    | Here you may specify which authentication guard Fortify will use while
    | authenticating users. This value should correspond with one of your
    | guards that is already present in your &quot;auth&quot; configuration file.
    |
    */
    &apos;guard&apos; =&gt; &apos;web&apos;,
    /*
    |--------------------------------------------------------------------------
    | Fortify Password Broker
    |--------------------------------------------------------------------------
    |
    | Here you may specify which password broker Fortify can use when a user
    | is resetting their password. This configured value should match one
    | of your password brokers setup in your &quot;auth&quot; configuration file.
    |
    */
    &apos;passwords&apos; =&gt; &apos;users&apos;,
    /*
    |--------------------------------------------------------------------------
    | Username / Email
    |--------------------------------------------------------------------------
    |
    | This value defines which model attribute should be considered as your
    | application&apos;s &quot;username&quot; field. Typically, this might be the email
    | address of the users but you are free to change this value here.
    |
    | Out of the box, Fortify expects forgot password and reset password
    | requests to have a field named &apos;email&apos;. If the application uses
    | another name for the field you may define it below as needed.
    |
    */
    &apos;username&apos; =&gt; &apos;email&apos;,
    &apos;email&apos; =&gt; &apos;email&apos;,
    /*
    |--------------------------------------------------------------------------
    | Lowercase Usernames
    |--------------------------------------------------------------------------
    |
    | This value defines whether usernames should be lowercased before saving
    | them in the database, as some database system string fields are case
    | sensitive. You may disable this for your application if necessary.
    |
    */
    &apos;lowercase_usernames&apos; =&gt; true,
    /*
    |--------------------------------------------------------------------------
    | Home Path
    |--------------------------------------------------------------------------
    |
    | Here you may configure the path where users will get redirected during
    | authentication or password reset when the operations are successful
    | and the user is authenticated. You are free to change this value.
    |
    */
    &apos;home&apos; =&gt; &apos;/&apos;,
    /*
    |--------------------------------------------------------------------------
    | Fortify Routes Prefix / Subdomain
    |--------------------------------------------------------------------------
    |
    | Here you may specify which prefix Fortify will assign to all the routes
    | that it registers with the application. If necessary, you may change
    | subdomain under which all of the Fortify routes will be available.
    |
    */
    &apos;prefix&apos; =&gt; &apos;&apos;,
    &apos;domain&apos; =&gt; null,
    /*
    |--------------------------------------------------------------------------
    | Fortify Routes Middleware
    |--------------------------------------------------------------------------
    |
    | Here you may specify which middleware Fortify will assign to the routes
    | that it registers with the application. If necessary, you may change
    | these middleware but typically this provided default is preferred.
    |
    */
    &apos;middleware&apos; =&gt; [&apos;web&apos;],
    /*
    |--------------------------------------------------------------------------
    | Rate Limiting
    |--------------------------------------------------------------------------
    |
    | By default, Fortify will throttle logins to five requests per minute for
    | every email and IP address combination. However, if you would like to
    | specify a custom rate limiter to call then you may specify it here.
    |
    */
    &apos;limiters&apos; =&gt; [
        &apos;login&apos;      =&gt; &apos;login&apos;,
        &apos;two-factor&apos; =&gt; &apos;two-factor&apos;,
    ],
    /*
    |--------------------------------------------------------------------------
    | Register View Routes
    |--------------------------------------------------------------------------
    |
    | Here you may specify if the routes returning views should be disabled as
    | you may not need them when building your own application. This may be
    | especially true if you&apos;re writing a custom single-page application.
    |
    */
    &apos;views&apos; =&gt; false,
    /*
    |--------------------------------------------------------------------------
    | Features
    |--------------------------------------------------------------------------
    |
    | Some of the Fortify features are optional. You may disable the features
    | by removing them from this array. You&apos;re free to only remove some of
    | these features or you can even remove all of these if you need to.
    |
    */
    &apos;features&apos; =&gt; [
//        Features::registration(),
        Features::resetPasswords(),
        Features::emailVerification(),
        Features::twoFactorAuthentication([
            &apos;confirm&apos;         =&gt; true,
            &apos;confirmPassword&apos; =&gt; true,
            // &apos;window&apos; =&gt; 0,
        ]),
    ],
];</file><file path="config/hashing.php">&lt;?php
return [
    /*
    |--------------------------------------------------------------------------
    | Default Hash Driver
    |--------------------------------------------------------------------------
    |
    | This option controls the default hash driver that will be used to hash
    | passwords for your application. By default, the bcrypt algorithm is
    | used; however, you remain free to modify this option if you wish.
    |
    | Supported: &quot;bcrypt&quot;, &quot;argon&quot;, &quot;argon2id&quot;
    |
    */
    &apos;driver&apos; =&gt; &apos;argon2id&apos;,
    /*
    |--------------------------------------------------------------------------
    | Bcrypt Options
    |--------------------------------------------------------------------------
    |
    | Here you may specify the configuration options that should be used when
    | passwords are hashed using the Bcrypt algorithm. This will allow you
    | to control the amount of time it takes to hash the given password.
    |
    */
    &apos;bcrypt&apos; =&gt; [
        &apos;rounds&apos; =&gt; env(&apos;BCRYPT_ROUNDS&apos;, 12),
        &apos;verify&apos; =&gt; true,
    ],
    /*
    |--------------------------------------------------------------------------
    | Argon Options
    |--------------------------------------------------------------------------
    |
    | Here you may specify the configuration options that should be used when
    | passwords are hashed using the Argon algorithm. These will allow you
    | to control the amount of time it takes to hash the given password.
    |
    */
    &apos;argon&apos; =&gt; [
        &apos;memory&apos;  =&gt; env(&apos;ARGON_MEMORY&apos;, 65536),
        &apos;threads&apos; =&gt; env(&apos;ARGON_THREADS&apos;, 1),
        &apos;time&apos;    =&gt; env(&apos;ARGON_TIME&apos;, 4),
        &apos;verify&apos;  =&gt; env(&apos;HASH_VERIFY&apos;, true),
    ],
    /*
    |--------------------------------------------------------------------------
    | Rehash On Login
    |--------------------------------------------------------------------------
    |
    | Setting this option to true will tell Laravel to automatically rehash
    | the user&apos;s password during login if the configured work factor for
    | the algorithm has changed, allowing graceful upgrades of hashes.
    |
    */
    &apos;rehash_on_login&apos; =&gt; true,
];</file><file path="config/horizon.php">&lt;?php
use Illuminate\Support\Str;
return [
    /*
    |--------------------------------------------------------------------------
    | Horizon Domain
    |--------------------------------------------------------------------------
    |
    | This is the subdomain where Horizon will be accessible from. If this
    | setting is null, Horizon will reside under the same domain as the
    | application. Otherwise, this value will serve as the subdomain.
    |
    */
    &apos;domain&apos; =&gt; env(&apos;HORIZON_DOMAIN&apos;),
    /*
    |--------------------------------------------------------------------------
    | Horizon Path
    |--------------------------------------------------------------------------
    |
    | This is the URI path where Horizon will be accessible from. Feel free
    | to change this path to anything you like. Note that the URI will not
    | affect the paths of its internal API that aren&apos;t exposed to users.
    |
    */
    &apos;path&apos; =&gt; env(&apos;HORIZON_PATH&apos;, &apos;/-/horizon&apos;),
    /*
    |--------------------------------------------------------------------------
    | Horizon Redis Connection
    |--------------------------------------------------------------------------
    |
    | This is the name of the Redis connection where Horizon will store the
    | meta information required for it to function. It includes the list
    | of supervisors, failed jobs, job metrics, and other information.
    |
    */
    &apos;use&apos; =&gt; &apos;horizon&apos;,
    /*
    |--------------------------------------------------------------------------
    | Horizon Redis Prefix
    |--------------------------------------------------------------------------
    |
    | This prefix will be used when storing all Horizon data in Redis. You
    | may modify the prefix when you are running multiple installations
    | of Horizon on the same server so that they don&apos;t have problems.
    |
    */
    &apos;prefix&apos; =&gt; env(
        &apos;HORIZON_PREFIX&apos;,
        Str::slug(env(&apos;APP_NAME&apos;, &apos;baander&apos;), &apos;_&apos;) . &apos;_horizon:&apos;
    ),
    /*
    |--------------------------------------------------------------------------
    | Horizon Route Middleware
    |--------------------------------------------------------------------------
    |
    | These middleware will get attached onto each Horizon route, giving you
    | the chance to add your own middleware to this list or change any of
    | the existing middleware. Or, you can simply stick with this list.
    |
    */
    &apos;middleware&apos; =&gt; [&apos;web&apos;],
    /*
    |--------------------------------------------------------------------------
    | Queue Wait Time Thresholds
    |--------------------------------------------------------------------------
    |
    | This option allows you to configure when the LongWaitDetected event
    | will be fired. Every connection / queue combination may have its
    | own, unique threshold (in seconds) before this event is fired.
    |
    */
    &apos;waits&apos; =&gt; [
        &apos;redis:default&apos; =&gt; 60,
    ],
    /*
    |--------------------------------------------------------------------------
    | Job Trimming Times
    |--------------------------------------------------------------------------
    |
    | Here you can configure for how long (in minutes) you desire Horizon to
    | persist the recent and failed jobs. Typically, recent jobs are kept
    | for one hour while all failed jobs are stored for an entire week.
    |
    */
    &apos;trim&apos; =&gt; [
        &apos;recent&apos; =&gt; 60,
        &apos;pending&apos; =&gt; 60,
        &apos;completed&apos; =&gt; 60,
        &apos;recent_failed&apos; =&gt; 10080,
        &apos;failed&apos; =&gt; 10080,
        &apos;monitored&apos; =&gt; 10080,
    ],
    /*
    |--------------------------------------------------------------------------
    | Silenced Jobs
    |--------------------------------------------------------------------------
    |
    | Silencing a job will instruct Horizon to not place the job in the list
    | of completed jobs within the Horizon dashboard. This setting may be
    | used to fully remove any noisy jobs from the completed jobs list.
    |
    */
    &apos;silenced&apos; =&gt; [
        // App\Jobs\ExampleJob::class,
    ],
    /*
    |--------------------------------------------------------------------------
    | Metrics
    |--------------------------------------------------------------------------
    |
    | Here you can configure how many snapshots should be kept to display in
    | the metrics graph. This will get used in combination with Horizon&apos;s
    | `horizon:snapshot` schedule to define how long to retain metrics.
    |
    */
    &apos;metrics&apos; =&gt; [
        &apos;trim_snapshots&apos; =&gt; [
            &apos;job&apos; =&gt; 24,
            &apos;queue&apos; =&gt; 24,
        ],
    ],
    /*
    |--------------------------------------------------------------------------
    | Fast Termination
    |--------------------------------------------------------------------------
    |
    | When this option is enabled, Horizon&apos;s &quot;terminate&quot; command will not
    | wait on all of the workers to terminate unless the --wait option
    | is provided. Fast termination can shorten deployment delay by
    | allowing a new instance of Horizon to start while the last
    | instance will continue to terminate each of its workers.
    |
    */
    &apos;fast_termination&apos; =&gt; false,
    /*
    |--------------------------------------------------------------------------
    | Memory Limit (MB)
    |--------------------------------------------------------------------------
    |
    | This value describes the maximum amount of memory the Horizon master
    | supervisor may consume before it is terminated and restarted. For
    | configuring these limits on your workers, see the next section.
    |
    */
    &apos;memory_limit&apos; =&gt; 128,
    /*
    |--------------------------------------------------------------------------
    | Queue Worker Configuration
    |--------------------------------------------------------------------------
    |
    | Here you may define the queue worker settings used by your application
    | in all environments. These supervisors and settings handle all your
    | queued jobs and will be provisioned by Horizon during deployment.
    |
    */
    &apos;defaults&apos; =&gt; [
        &apos;supervisor-1&apos; =&gt; [
            &apos;connection&apos; =&gt; &apos;redis&apos;,
            &apos;queue&apos; =&gt; [&apos;default&apos;],
            &apos;balance&apos; =&gt; &apos;auto&apos;,
            &apos;autoScalingStrategy&apos; =&gt; &apos;time&apos;,
            &apos;maxProcesses&apos; =&gt; 1,
            &apos;maxTime&apos; =&gt; 0,
            &apos;maxJobs&apos; =&gt; 0,
            &apos;memory&apos; =&gt; 128,
            &apos;tries&apos; =&gt; 1,
            &apos;timeout&apos; =&gt; 60,
            &apos;nice&apos; =&gt; 0,
        ],
    ],
    &apos;environments&apos; =&gt; [
        &apos;production&apos; =&gt; [
            &apos;supervisor-1&apos; =&gt; [
                &apos;maxProcesses&apos; =&gt; 10,
                &apos;balanceMaxShift&apos; =&gt; 1,
                &apos;balanceCooldown&apos; =&gt; 3,
            ],
        ],
        &apos;local&apos; =&gt; [
            &apos;supervisor-1&apos; =&gt; [
                &apos;maxProcesses&apos; =&gt; 3,
            ],
        ],
    ],
];</file><file path="config/image.php">&lt;?php
return [
    &apos;storage&apos;    =&gt; [
        &apos;artists&apos; =&gt; storage_path(&apos;app/images/artists&apos;),
        &apos;covers&apos;  =&gt; storage_path(&apos;app/images/covers&apos;),
    ],
    &apos;dimensions&apos; =&gt; [
        &apos;artists&apos; =&gt; [
            &apos;height&apos; =&gt; 800,
            &apos;width&apos;  =&gt; 800,
        ],
        &apos;covers&apos;  =&gt; [
            &apos;height&apos; =&gt; 800,
            &apos;width&apos;  =&gt; 800,
        ],
    ],
];</file><file path="config/log-viewer.php">&lt;?php
return [
    /*
    |--------------------------------------------------------------------------
    | Log Viewer
    |--------------------------------------------------------------------------
    | Log Viewer can be disabled, so it&apos;s no longer accessible via browser.
    |
    */
    &apos;enabled&apos; =&gt; env(&apos;LOG_VIEWER_ENABLED&apos;, true),
    &apos;api_only&apos; =&gt; env(&apos;LOG_VIEWER_API_ONLY&apos;, false),
    &apos;require_auth_in_production&apos; =&gt; true,
    /*
    |--------------------------------------------------------------------------
    | Log Viewer Domain
    |--------------------------------------------------------------------------
    | You may change the domain where Log Viewer should be active.
    | If the domain is empty, all domains will be valid.
    |
    */
    &apos;route_domain&apos; =&gt; null,
    /*
    |--------------------------------------------------------------------------
    | Log Viewer Route
    |--------------------------------------------------------------------------
    | Log Viewer will be available under this URL.
    |
    */
    &apos;route_path&apos; =&gt; &apos;system/log-viewer&apos;,
    /*
    |--------------------------------------------------------------------------
    | Back to system URL
    |--------------------------------------------------------------------------
    | When set, displays a link to easily get back to this URL.
    | Set to `null` to hide this link.
    |
    | Optional label to display for the above URL.
    |
    */
    &apos;back_to_system_url&apos; =&gt; config(&apos;app.url&apos;, null),
    &apos;back_to_system_label&apos; =&gt; null, // Displayed by default: &quot;Back to {{ app.name }}&quot;
    /*
    |--------------------------------------------------------------------------
    | Log Viewer time zone.
    |--------------------------------------------------------------------------
    | The time zone in which to display the times in the UI. Defaults to
    | the application&apos;s timezone defined in config/app.php.
    |
    */
    &apos;timezone&apos; =&gt; null,
    /*
    |--------------------------------------------------------------------------
    | Log Viewer route middleware.
    |--------------------------------------------------------------------------
    | Optional middleware to use when loading the initial Log Viewer page.
    |
    */
    &apos;middleware&apos; =&gt; [
        &apos;web&apos;,
        \Opcodes\LogViewer\Http\Middleware\AuthorizeLogViewer::class,
    ],
    /*
    |--------------------------------------------------------------------------
    | Log Viewer API middleware.
    |--------------------------------------------------------------------------
    | Optional middleware to use on every API request. The same API is also
    | used from within the Log Viewer user interface.
    |
    */
    &apos;api_middleware&apos; =&gt; [
        \Opcodes\LogViewer\Http\Middleware\EnsureFrontendRequestsAreStateful::class,
        \Opcodes\LogViewer\Http\Middleware\AuthorizeLogViewer::class,
    ],
    &apos;api_stateful_domains&apos; =&gt; env(&apos;LOG_VIEWER_API_STATEFUL_DOMAINS&apos;) ? explode(&apos;,&apos;, env(&apos;LOG_VIEWER_API_STATEFUL_DOMAINS&apos;)) : null,
    /*
    |--------------------------------------------------------------------------
    | Log Viewer Remote hosts.
    |--------------------------------------------------------------------------
    | Log Viewer supports viewing Laravel logs from remote hosts. They must
    | be running Log Viewer as well. Below you can define the hosts you
    | would like to show in this Log Viewer instance.
    |
    */
    &apos;hosts&apos; =&gt; [
        &apos;local&apos; =&gt; [
            &apos;name&apos; =&gt; ucfirst(env(&apos;APP_ENV&apos;, &apos;local&apos;)),
        ],
        // &apos;staging&apos; =&gt; [
        //     &apos;name&apos; =&gt; &apos;Staging&apos;,
        //     &apos;host&apos; =&gt; &apos;https://staging.example.com/log-viewer&apos;,
        //     &apos;auth&apos; =&gt; [      // Example of HTTP Basic auth
        //         &apos;username&apos; =&gt; &apos;username&apos;,
        //         &apos;password&apos; =&gt; &apos;password&apos;,
        //     ],
        // ],
        //
        // &apos;production&apos; =&gt; [
        //     &apos;name&apos; =&gt; &apos;Production&apos;,
        //     &apos;host&apos; =&gt; &apos;https://example.com/log-viewer&apos;,
        //     &apos;auth&apos; =&gt; [      // Example of Bearer token auth
        //         &apos;token&apos; =&gt; env(&apos;LOG_VIEWER_PRODUCTION_TOKEN&apos;),
        //     ],
        //     &apos;headers&apos; =&gt; [
        //         &apos;X-Foo&apos; =&gt; &apos;Bar&apos;,
        //     ],
        // ],
    ],
    /*
    |--------------------------------------------------------------------------
    | Include file patterns
    |--------------------------------------------------------------------------
    |
    */
    &apos;include_files&apos; =&gt; [
        &apos;*.log&apos;,
        &apos;**/*.log&apos;,
    ],
    /*
    |--------------------------------------------------------------------------
    | Exclude file patterns.
    |--------------------------------------------------------------------------
    | This will take precedence over included files.
    |
    */
    &apos;exclude_files&apos; =&gt; [
        // &apos;my_secret.log&apos;
    ],
    /*
    |--------------------------------------------------------------------------
    | Hide unknown files.
    |--------------------------------------------------------------------------
    | The include/exclude options above might catch files which are not
    | logs supported by Log Viewer. In that case, you can hide them
    | from the UI and API calls by setting this to true.
    |
    */
    &apos;hide_unknown_files&apos; =&gt; true,
    /*
    |--------------------------------------------------------------------------
    |  Shorter stack trace filters.
    |--------------------------------------------------------------------------
    | Lines containing any of these strings will be excluded from the full log.
    | This setting is only active when the function is enabled via the user interface.
    |
    */
    &apos;shorter_stack_trace_excludes&apos; =&gt; [
        &apos;/vendor/symfony/&apos;,
        &apos;/vendor/laravel/framework/&apos;,
        &apos;/vendor/barryvdh/laravel-debugbar/&apos;,
    ],
    /*
    |--------------------------------------------------------------------------
    | Cache driver
    |--------------------------------------------------------------------------
    | Cache driver to use for storing the log indices. Indices are used to speed up
    | log navigation. Defaults to your application&apos;s default cache driver.
    |
    */
    &apos;cache_driver&apos; =&gt; env(&apos;LOG_VIEWER_CACHE_DRIVER&apos;, null),
    /*
    |--------------------------------------------------------------------------
    | Cache key prefix
    |--------------------------------------------------------------------------
    | Log Viewer prefixes all the cache keys created with this value. If for
    | some reason you would like to change this prefix, you can do so here.
    | The format of Log Viewer cache keys is:
    | {prefix}:{version}:{rest-of-the-key}
    |
    */
    &apos;cache_key_prefix&apos; =&gt; &apos;lv&apos;,
    /*
    |--------------------------------------------------------------------------
    | Chunk size when scanning log files lazily
    |--------------------------------------------------------------------------
    | The size in MB of files to scan before updating the progress bar when searching across all files.
    |
    */
    &apos;lazy_scan_chunk_size_in_mb&apos; =&gt; 50,
    &apos;strip_extracted_context&apos; =&gt; true,
];</file><file path="config/mail.php">&lt;?php
return [
    /*
    |--------------------------------------------------------------------------
    | Default Mailer
    |--------------------------------------------------------------------------
    |
    | This option controls the default mailer that is used to send any email
    | messages sent by your application. Alternative mailers may be setup
    | and used as needed; however, this mailer will be used by default.
    |
    */
    &apos;default&apos; =&gt; env(&apos;MAIL_MAILER&apos;, &apos;smtp&apos;),
    /*
    |--------------------------------------------------------------------------
    | Mailer Configurations
    |--------------------------------------------------------------------------
    |
    | Here you may configure all of the mailers used by your application plus
    | their respective settings. Several examples have been configured for
    | you and you are free to add your own as your application requires.
    |
    | Laravel supports a variety of mail &quot;transport&quot; drivers to be used while
    | sending an e-mail. You will specify which one you are using for your
    | mailers below. You are free to add additional mailers as required.
    |
    | Supported: &quot;smtp&quot;, &quot;sendmail&quot;, &quot;mailgun&quot;, &quot;ses&quot;, &quot;ses-v2&quot;,
    |            &quot;postmark&quot;, &quot;log&quot;, &quot;array&quot;, &quot;failover&quot;, &quot;roundrobin&quot;
    |
    */
    &apos;mailers&apos; =&gt; [
        &apos;smtp&apos; =&gt; [
            &apos;transport&apos;    =&gt; &apos;smtp&apos;,
            &apos;url&apos;          =&gt; env(&apos;MAIL_URL&apos;),
            &apos;host&apos;         =&gt; env(&apos;MAIL_HOST&apos;, &apos;smtp.mailgun.org&apos;),
            &apos;port&apos;         =&gt; env(&apos;MAIL_PORT&apos;, 587),
            &apos;encryption&apos;   =&gt; env(&apos;MAIL_ENCRYPTION&apos;, &apos;tls&apos;),
            &apos;username&apos;     =&gt; env(&apos;MAIL_USERNAME&apos;),
            &apos;password&apos;     =&gt; env(&apos;MAIL_PASSWORD&apos;),
            &apos;timeout&apos;      =&gt; null,
            &apos;local_domain&apos; =&gt; env(&apos;MAIL_EHLO_DOMAIN&apos;),
        ],
        &apos;ses&apos; =&gt; [
            &apos;transport&apos; =&gt; &apos;ses&apos;,
        ],
        &apos;postmark&apos; =&gt; [
            &apos;transport&apos; =&gt; &apos;postmark&apos;,
            // &apos;message_stream_id&apos; =&gt; null,
            // &apos;client&apos; =&gt; [
            //     &apos;timeout&apos; =&gt; 5,
            // ],
        ],
        &apos;mailgun&apos; =&gt; [
            &apos;transport&apos; =&gt; &apos;mailgun&apos;,
            // &apos;client&apos; =&gt; [
            //     &apos;timeout&apos; =&gt; 5,
            // ],
        ],
        &apos;sendmail&apos; =&gt; [
            &apos;transport&apos; =&gt; &apos;sendmail&apos;,
            &apos;path&apos;      =&gt; env(&apos;MAIL_SENDMAIL_PATH&apos;, &apos;/usr/sbin/sendmail -bs -i&apos;),
        ],
        &apos;log&apos; =&gt; [
            &apos;transport&apos; =&gt; &apos;log&apos;,
            &apos;channel&apos;   =&gt; env(&apos;MAIL_LOG_CHANNEL&apos;),
        ],
        &apos;array&apos; =&gt; [
            &apos;transport&apos; =&gt; &apos;array&apos;,
        ],
        &apos;failover&apos; =&gt; [
            &apos;transport&apos; =&gt; &apos;failover&apos;,
            &apos;mailers&apos;   =&gt; [
                &apos;smtp&apos;,
                &apos;log&apos;,
            ],
        ],
        &apos;roundrobin&apos; =&gt; [
            &apos;transport&apos; =&gt; &apos;roundrobin&apos;,
            &apos;mailers&apos;   =&gt; [
                &apos;ses&apos;,
                &apos;postmark&apos;,
            ],
        ],
    ],
    /*
    |--------------------------------------------------------------------------
    | Global &quot;From&quot; Address
    |--------------------------------------------------------------------------
    |
    | You may wish for all e-mails sent by your application to be sent from
    | the same address. Here, you may specify a name and address that is
    | used globally for all e-mails that are sent by your application.
    |
    */
    &apos;from&apos; =&gt; [
        &apos;address&apos; =&gt; env(&apos;MAIL_FROM_ADDRESS&apos;, &apos;hello@example.com&apos;),
        &apos;name&apos;    =&gt; env(&apos;MAIL_FROM_NAME&apos;, &apos;Example&apos;),
    ],
    /*
    |--------------------------------------------------------------------------
    | Markdown Mail Settings
    |--------------------------------------------------------------------------
    |
    | If you are using Markdown based email rendering, you may configure your
    | theme and component paths here, allowing you to customize the design
    | of the emails. Or, you may simply stick with the Laravel defaults!
    |
    */
    &apos;markdown&apos; =&gt; [
        &apos;theme&apos; =&gt; &apos;default&apos;,
        &apos;paths&apos; =&gt; [
            resource_path(&apos;views/vendor/mail&apos;),
        ],
    ],
];</file><file path="config/opcache.php">&lt;?php
return [
    &apos;url&apos;         =&gt; env(&apos;OPCACHE_URL&apos;, config(&apos;app.url&apos;)),
    &apos;prefix&apos;      =&gt; &apos;/system/api/opcache&apos;,
    &apos;verify&apos;      =&gt; true,
    &apos;headers&apos;     =&gt; [],
    &apos;directories&apos; =&gt; [
        base_path(&apos;app&apos;),
        base_path(&apos;bootstrap&apos;),
        base_path(&apos;public&apos;),
        base_path(&apos;resources&apos;),
        base_path(&apos;routes&apos;),
        base_path(&apos;storage&apos;),
        base_path(&apos;vendor&apos;),
    ],
    &apos;exclude&apos;     =&gt; [
        &apos;test&apos;,
        &apos;Test&apos;,
        &apos;tests&apos;,
        &apos;Tests&apos;,
        &apos;stub&apos;,
        &apos;Stub&apos;,
        &apos;stubs&apos;,
        &apos;Stubs&apos;,
        &apos;dumper&apos;,
        &apos;Dumper&apos;,
        &apos;Autoload&apos;,
    ],
];</file><file path="config/passport.php">&lt;?php
return [
    /*
    |--------------------------------------------------------------------------
    | Passport Guard
    |--------------------------------------------------------------------------
    |
    | Here you may specify which authentication guard Passport will use when
    | authenticating users. This value should correspond with one of your
    | guards that is already present in your &quot;auth&quot; configuration file.
    |
    */
    &apos;guard&apos; =&gt; &apos;api&apos;,
    /*
    |--------------------------------------------------------------------------
    | Encryption Keys
    |--------------------------------------------------------------------------
    |
    | Passport uses encryption keys while generating secure access tokens for
    | your application. By default, the keys are stored as local files but
    | can be set via environment variables when that is more convenient.
    |
    */
    &apos;private_key&apos; =&gt; env(&apos;PASSPORT_PRIVATE_KEY&apos;),
    &apos;public_key&apos; =&gt; env(&apos;PASSPORT_PUBLIC_KEY&apos;),
    /*
    |--------------------------------------------------------------------------
    | Passport Database Connection
    |--------------------------------------------------------------------------
    |
    | By default, Passport&apos;s models will utilize your application&apos;s default
    | database connection. If you wish to use a different connection you
    | may specify the configured name of the database connection here.
    |
    */
    &apos;connection&apos; =&gt; env(&apos;PASSPORT_CONNECTION&apos;),
];</file><file path="config/permission.php">&lt;?php
return [
    &apos;models&apos; =&gt; [
        /*
         * When using the &quot;HasPermissions&quot; trait from this package, we need to know which
         * Eloquent model should be used to retrieve your permissions. Of course, it
         * is often just the &quot;Permission&quot; model but you may use whatever you like.
         *
         * The model you want to use as a Permission model needs to implement the
         * `Spatie\Permission\Contracts\Permission` contract.
         */
        &apos;permission&apos; =&gt; Spatie\Permission\Models\Permission::class,
        /*
         * When using the &quot;HasRoles&quot; trait from this package, we need to know which
         * Eloquent model should be used to retrieve your roles. Of course, it
         * is often just the &quot;Role&quot; model but you may use whatever you like.
         *
         * The model you want to use as a Role model needs to implement the
         * `Spatie\Permission\Contracts\Role` contract.
         */
        &apos;role&apos; =&gt; Spatie\Permission\Models\Role::class,
    ],
    &apos;table_names&apos; =&gt; [
        /*
         * When using the &quot;HasRoles&quot; trait from this package, we need to know which
         * table should be used to retrieve your roles. We have chosen a basic
         * default value but you may easily change it to any table you like.
         */
        &apos;roles&apos; =&gt; &apos;roles&apos;,
        /*
         * When using the &quot;HasPermissions&quot; trait from this package, we need to know which
         * table should be used to retrieve your permissions. We have chosen a basic
         * default value but you may easily change it to any table you like.
         */
        &apos;permissions&apos; =&gt; &apos;permissions&apos;,
        /*
         * When using the &quot;HasPermissions&quot; trait from this package, we need to know which
         * table should be used to retrieve your models permissions. We have chosen a
         * basic default value but you may easily change it to any table you like.
         */
        &apos;model_has_permissions&apos; =&gt; &apos;model_has_permissions&apos;,
        /*
         * When using the &quot;HasRoles&quot; trait from this package, we need to know which
         * table should be used to retrieve your models roles. We have chosen a
         * basic default value but you may easily change it to any table you like.
         */
        &apos;model_has_roles&apos; =&gt; &apos;model_has_roles&apos;,
        /*
         * When using the &quot;HasRoles&quot; trait from this package, we need to know which
         * table should be used to retrieve your roles permissions. We have chosen a
         * basic default value but you may easily change it to any table you like.
         */
        &apos;role_has_permissions&apos; =&gt; &apos;role_has_permissions&apos;,
    ],
    &apos;column_names&apos; =&gt; [
        /*
         * Change this if you want to name the related pivots other than defaults
         */
        &apos;role_pivot_key&apos;       =&gt; null, //default &apos;role_id&apos;,
        &apos;permission_pivot_key&apos; =&gt; null, //default &apos;permission_id&apos;,
        /*
         * Change this if you want to name the related model primary key other than
         * `model_id`.
         *
         * For example, this would be nice if your primary keys are all UUIDs. In
         * that case, name this `model_uuid`.
         */
        &apos;model_morph_key&apos; =&gt; &apos;model_id&apos;,
        /*
         * Change this if you want to use the teams feature and your related model&apos;s
         * foreign key is other than `team_id`.
         */
        &apos;team_foreign_key&apos; =&gt; &apos;team_id&apos;,
    ],
    /*
     * When set to true, the method for checking permissions will be registered on the gate.
     * Set this to false if you want to implement custom logic for checking permissions.
     */
    &apos;register_permission_check_method&apos; =&gt; true,
    /*
     * When set to true, Laravel\Octane\Events\OperationTerminated event listener will be registered
     * this will refresh permissions on every TickTerminated, TaskTerminated and RequestTerminated
     * NOTE: This should not be needed in most cases, but an Octane/Vapor combination benefited from it.
     */
    &apos;register_octane_reset_listener&apos;   =&gt; false,
    /*
     * Teams Feature.
     * When set to true the package implements teams using the &apos;team_foreign_key&apos;.
     * If you want the migrations to register the &apos;team_foreign_key&apos;, you must
     * set this to true before doing the migration.
     * If you already did the migration then you must make a new migration to also
     * add &apos;team_foreign_key&apos; to &apos;roles&apos;, &apos;model_has_roles&apos;, and &apos;model_has_permissions&apos;
     * (view the latest version of this package&apos;s migration file)
     */
    &apos;teams&apos; =&gt; false,
    /*
     * Passport Client Credentials Grant
     * When set to true the package will use Passports Client to check permissions
     */
    &apos;use_passport_client_credentials&apos; =&gt; false,
    /*
     * When set to true, the required permission names are added to exception messages.
     * This could be considered an information leak in some contexts, so the default
     * setting is false here for optimum safety.
     */
    &apos;display_permission_in_exception&apos; =&gt; false,
    /*
     * When set to true, the required role names are added to exception messages.
     * This could be considered an information leak in some contexts, so the default
     * setting is false here for optimum safety.
     */
    &apos;display_role_in_exception&apos; =&gt; false,
    /*
     * By default wildcard permission lookups are disabled.
     * See documentation to understand supported syntax.
     */
    &apos;enable_wildcard_permission&apos; =&gt; false,
    /*
     * The class to use for interpreting wildcard permissions.
     * If you need to modify delimiters, override the class and specify its name here.
     */
    // &apos;permission.wildcard_permission&apos; =&gt; Spatie\Permission\WildcardPermission::class,
    /* Cache-specific settings */
    &apos;cache&apos; =&gt; [
        /*
         * By default all permissions are cached for 24 hours to speed up performance.
         * When permissions or roles are updated the cache is flushed automatically.
         */
        &apos;expiration_time&apos; =&gt; \DateInterval::createFromDateString(&apos;24 hours&apos;),
        /*
         * The cache key used to store all permissions.
         */
        &apos;key&apos; =&gt; &apos;spatie.permission.cache&apos;,
        /*
         * You may optionally indicate a specific cache driver to use for permission and
         * role caching using any of the `store` drivers listed in the cache.php config
         * file. Using &apos;default&apos; here means to use the `default` set in cache.php.
         */
        &apos;store&apos; =&gt; &apos;redis-secret&apos;,
    ],
];</file><file path="config/queue.php">&lt;?php
return [
    /*
    |--------------------------------------------------------------------------
    | Default Queue Connection Name
    |--------------------------------------------------------------------------
    |
    | Laravel&apos;s queue API supports an assortment of back-ends via a single
    | API, giving you convenient access to each back-end using the same
    | syntax for every one. Here you may define a default connection.
    |
    */
    &apos;default&apos; =&gt; env(&apos;QUEUE_CONNECTION&apos;, &apos;sync&apos;),
    /*
    |--------------------------------------------------------------------------
    | Queue Connections
    |--------------------------------------------------------------------------
    |
    | Here you may configure the connection information for each server that
    | is used by your application. A default configuration has been added
    | for each back-end shipped with Laravel. You are free to add more.
    |
    | Drivers: &quot;sync&quot;, &quot;database&quot;, &quot;beanstalkd&quot;, &quot;sqs&quot;, &quot;redis&quot;, &quot;null&quot;
    |
    */
    &apos;connections&apos; =&gt; [
        &apos;sync&apos; =&gt; [
            &apos;driver&apos; =&gt; &apos;sync&apos;,
        ],
        &apos;database&apos; =&gt; [
            &apos;driver&apos;       =&gt; &apos;database&apos;,
            &apos;table&apos;        =&gt; &apos;jobs&apos;,
            &apos;queue&apos;        =&gt; &apos;default&apos;,
            &apos;retry_after&apos;  =&gt; 90,
            &apos;after_commit&apos; =&gt; false,
        ],
        &apos;redis&apos; =&gt; [
            &apos;driver&apos; =&gt; &apos;redis&apos;,
            &apos;connection&apos; =&gt; &apos;default&apos;,
            &apos;queue&apos; =&gt; env(&apos;REDIS_QUEUE&apos;, &apos;default&apos;),
            &apos;retry_after&apos; =&gt; 90,
            &apos;block_for&apos; =&gt; null,
            &apos;after_commit&apos; =&gt; false,
        ],
        // Development connection using Octane task workers
        &apos;octane&apos; =&gt; [
            &apos;driver&apos; =&gt; &apos;sync&apos;, // Uses Octane&apos;s task workers when available
        ],
    ],
    /*
    |--------------------------------------------------------------------------
    | Job Batching
    |--------------------------------------------------------------------------
    |
    | The following options configure the database and table that store job
    | batching information. These options can be updated to any database
    | connection and table which has been defined by your application.
    |
    */
    &apos;batching&apos; =&gt; [
        &apos;database&apos; =&gt; env(&apos;DB_CONNECTION&apos;, &apos;mysql&apos;),
        &apos;table&apos;    =&gt; &apos;job_batches&apos;,
    ],
    /*
    |--------------------------------------------------------------------------
    | Failed Queue Jobs
    |--------------------------------------------------------------------------
    |
    | These options configure the behavior of failed queue job logging so you
    | can control which database and table are used to store the jobs that
    | have failed. You may change them to any database / table you wish.
    |
    */
    &apos;failed&apos; =&gt; [
        &apos;driver&apos;   =&gt; env(&apos;QUEUE_FAILED_DRIVER&apos;, &apos;database-uuids&apos;),
        &apos;database&apos; =&gt; env(&apos;DB_CONNECTION&apos;, &apos;mysql&apos;),
        &apos;table&apos;    =&gt; &apos;failed_jobs&apos;,
    ],
];</file><file path="config/recommendation.php">&lt;?php
return [
    /*
    |--------------------------------------------------------------------------
    | Default Recommendation Settings
    |--------------------------------------------------------------------------
    |
    | Default settings for recommendations when not specified in the model config
    |
    */
    &apos;defaults&apos; =&gt; [
        &apos;count&apos; =&gt; 10,  // Default number of recommendations to return
        &apos;order&apos; =&gt; &apos;desc&apos;, // Default ordering (desc, asc, random)
    ],
    /*
    |--------------------------------------------------------------------------
    | Caching Configuration
    |--------------------------------------------------------------------------
    |
    | Configure caching behavior for recommendations
    |
    */
    &apos;cache&apos; =&gt; [
        &apos;enabled&apos; =&gt; true,  // Enable caching by default
        &apos;ttl&apos; =&gt; 3600,      // Cache TTL in seconds (1 hour)
    ],
    /*
    |--------------------------------------------------------------------------
    | Batch Processing
    |--------------------------------------------------------------------------
    |
    | Configuration for batch processing of recommendations
    |
    */
    &apos;batch&apos; =&gt; [
        &apos;size&apos; =&gt; 1000,  // Default batch size for insertions
    ],
    /*
    |--------------------------------------------------------------------------
    | Algorithm Settings
    |--------------------------------------------------------------------------
    |
    | Settings for specific recommendation algorithms
    |
    */
    &apos;algorithms&apos; =&gt; [
        &apos;similarity&apos; =&gt; [
            &apos;default_weights&apos; =&gt; [
                &apos;taxonomy&apos; =&gt; 1.0,
                &apos;feature&apos; =&gt; 0.5,
                &apos;numeric&apos; =&gt; 0.5,
            ],
        ],
        &apos;content_based&apos; =&gt; [
            &apos;default_content_field&apos; =&gt; &apos;description&apos;,
            &apos;stopwords&apos; =&gt; [&apos;the&apos;, &apos;and&apos;, &apos;a&apos;, &apos;to&apos;, &apos;of&apos;, &apos;in&apos;, &apos;is&apos;, &apos;that&apos;, &apos;it&apos;, &apos;with&apos;, &apos;for&apos;, &apos;as&apos;, &apos;on&apos;, &apos;at&apos;],
        ],
    ],
];
/**
 * /**
 *  Define recommendation configurations for this model
 *
 * @return array
 * /
 * public function getRecommendationConfig(): array
 * {
 * return [
 * &apos;similar_products&apos; =&gt; [
 * &apos;algorithm&apos; =&gt; &apos;similarity&apos;,
 * &apos;count&apos; =&gt; 6,
 * &apos;similarity_taxonomy_attributes&apos; =&gt; [
 * [&apos;categories&apos; =&gt; &apos;name&apos;],
 * [&apos;tags&apos; =&gt; &apos;name&apos;],
 * ],
 * &apos;similarity_feature_attributes&apos; =&gt; [
 * &apos;is_featured&apos;, &apos;is_new&apos;, &apos;is_on_sale&apos;
 * ],
 * &apos;similarity_numeric_value_attributes&apos; =&gt; [
 * &apos;price&apos;, &apos;rating&apos;
 * ],
 * &apos;similarity_taxonomy_weight&apos; =&gt; 1.0,
 * &apos;similarity_feature_weight&apos; =&gt; 0.5,
 * &apos;similarity_numeric_value_weight&apos; =&gt; 0.7,
 * &apos;order&apos; =&gt; &apos;desc&apos;,
 * &apos;with&apos; =&gt; [&apos;media&apos;, &apos;categories&apos;], // eager load these relations
 * ],
 * &apos;content_similar&apos; =&gt; [
 * &apos;algorithm&apos; =&gt; &apos;content_based&apos;,
 * &apos;content_field&apos; =&gt; &apos;description&apos;,
 * &apos;count&apos; =&gt; 4,
 * ],
 * &apos;frequently_bought_together&apos; =&gt; [
 * &apos;algorithm&apos; =&gt; &apos;db_relation&apos;,
 * &apos;data_table&apos; =&gt; &apos;order_items&apos;,
 * &apos;data_field&apos; =&gt; &apos;product_id&apos;,
 * &apos;group_field&apos; =&gt; &apos;order_id&apos;,
 * &apos;count&apos; =&gt; 3,
 * &apos;data_table_filter&apos; =&gt; [
 * &apos;created_at&apos; =&gt; [&apos;&gt;&apos;, now()-&gt;subMonths(6)],
 * ],
 * ],
 * ];
 * }
 */
/**
 * use App\Models\Product;
 * use App\Modules\Recommendation\Services\RecommendationService;
 *
 * class ProductController extends Controller
 * {
 * protected RecommendationService $recommendationService;
 *
 * public function __construct(RecommendationService $recommendationService)
 * {
 * $this-&gt;recommendationService = $recommendationService;
 * }
 *
 * public function show(Product $product)
 * {
 * // Get existing recommendations
 * $similarProducts = $this-&gt;recommendationService-&gt;getRecommendations($product, &apos;similar_products&apos;);
 * $contentSimilar = $this-&gt;recommendationService-&gt;getRecommendations($product, &apos;content_similar&apos;);
 * $frequentlyBoughtTogether = $this-&gt;recommendationService-&gt;getRecommendations($product, &apos;frequently_bought_together&apos;);
 *
 * return view(&apos;products.show&apos;, [
 * &apos;product&apos; =&gt; $product,
 * &apos;similarProducts&apos; =&gt; $similarProducts,
 * &apos;contentSimilar&apos; =&gt; $contentSimilar,
 * &apos;frequentlyBoughtTogether&apos; =&gt; $frequentlyBoughtTogether,
 * ]);
 * }
 *
 * public function generateRecommendations()
 * {
 * // Generate recommendations for all products
 * $similarCount = $this-&gt;recommendationService-&gt;generateRecommendations(Product::class, &apos;similar_products&apos;);
 * $contentCount = $this-&gt;recommendationService-&gt;generateRecommendations(Product::class, &apos;content_similar&apos;);
 * $fbTogether = $this-&gt;recommendationService-&gt;generateRecommendations(Product::class, &apos;frequently_bought_together&apos;);
 *
 * return response()-&gt;json([
 * &apos;similar_products&apos; =&gt; $similarCount,
 * &apos;content_similar&apos; =&gt; $contentCount,
 * &apos;frequently_bought_together&apos; =&gt; $fbTogether,
 * ]);
 * }
 *
 * public function refreshRecommendations(Product $product)
 * {
 * // Generate recommendations for a specific product
 * $similarCount = $this-&gt;recommendationService-&gt;generateRecommendationsForModel($product, &apos;similar_products&apos;);
 * $contentCount = $this-&gt;recommendationService-&gt;generateRecommendationsForModel($product, &apos;content_similar&apos;);
 * $fbTogether = $this-&gt;recommendationService-&gt;generateRecommendationsForModel($product, &apos;frequently_bought_together&apos;);
 *
 * return response()-&gt;json([
 * &apos;similar_products&apos; =&gt; $similarCount,
 * &apos;content_similar&apos; =&gt; $contentCount,
 * &apos;frequently_bought_together&apos; =&gt; $fbTogether,
 * ]);
 * }
 * }
 */</file><file path="config/scanner.php">&lt;?php
return [
    &apos;music&apos; =&gt; [
        &apos;directory_chunk_size&apos; =&gt; env(&apos;MUSIC_SCANNER_DIRECTORY_CHUNK_SIZE&apos;, 10),
    ],
];</file><file path="config/schema-rules.php">&lt;?php
return [
    /**
     * In MySQL for instance there is no native boolean data type.
     * Laravel creates a tinyint(1) if you migrate a boolean.
     * Switch this off if you want an actual tinyint
     * validation rule to be generated...
     */
    &apos;tinyint1_to_bool&apos; =&gt; env(&apos;SCHEMA_RULES_TINYINT1_TO_BOOL&apos;, true),
    /**
     * The min default length for a required string validation rule is 1 character.
     * Changes this to what ever fits best for you!
     */
    &apos;string_min_length&apos; =&gt; env(&apos;SCHEMA_RULES_STRING_MIN_LENGTH&apos;, 1),
    /**
     * Always skip these columns
     */
    &apos;skip_columns&apos; =&gt; [&apos;created_at&apos;, &apos;updated_at&apos;, &apos;deleted_at&apos;],
];</file><file path="config/view.php">&lt;?php
return [
    /*
    |--------------------------------------------------------------------------
    | View Storage Paths
    |--------------------------------------------------------------------------
    |
    | Most templating systems load templates from disk. Here you may specify
    | an array of paths that should be checked for your views. Of course
    | the usual Laravel view path has already been registered for you.
    |
    */
    &apos;paths&apos; =&gt; [
        resource_path(&apos;views&apos;),
    ],
    /*
    |--------------------------------------------------------------------------
    | Compiled View Path
    |--------------------------------------------------------------------------
    |
    | This option determines where all the compiled Blade templates will be
    | stored for your application. Typically, this is within the storage
    | directory. However, as usual, you are free to change this value.
    |
    */
    &apos;compiled&apos; =&gt; env(
        &apos;VIEW_COMPILED_PATH&apos;,
        realpath(storage_path(&apos;framework/views&apos;)),
    ),
];</file><file path="config/ziggy.php">&lt;?php
return [
    &apos;output&apos; =&gt; [
        &apos;path&apos; =&gt; &apos;resources/app/ziggy.js&apos;
    ]
];</file><file path="database/.gitignore">*.sqlite*</file><file path="database/factories/AlbumArtistFactory.php">&lt;?php
namespace Database\Factories;
use Illuminate\Database\Eloquent\Factories\Factory;
/**
 * @extends \Illuminate\Database\Eloquent\Factories\Factory&lt;\App\Models\AlbumArtist&gt;
 */
class AlbumArtistFactory extends Factory
{
    /**
     * Define the model&apos;s default state.
     *
     * @return array&lt;string, mixed&gt;
     */
    public function definition(): array
    {
        return [
            //
        ];
    }
}</file><file path="database/factories/AlbumFactory.php">&lt;?php
namespace Database\Factories;
use Illuminate\Database\Eloquent\Factories\Factory;
/**
 * @extends \Illuminate\Database\Eloquent\Factories\Factory&lt;\App\Models\Album&gt;
 */
class AlbumFactory extends Factory
{
    /**
     * Define the model&apos;s default state.
     *
     * @return array&lt;string, mixed&gt;
     */
    public function definition(): array
    {
        return [
            //
        ];
    }
}</file><file path="database/factories/ArtistFactory.php">&lt;?php
namespace Database\Factories;
use Illuminate\Database\Eloquent\Factories\Factory;
/**
 * @extends \Illuminate\Database\Eloquent\Factories\Factory&lt;\App\Models\artist&gt;
 */
class ArtistFactory extends Factory
{
    /**
     * Define the model&apos;s default state.
     *
     * @return array&lt;string, mixed&gt;
     */
    public function definition(): array
    {
        return [
            //
        ];
    }
}</file><file path="database/factories/GenreFactory.php">&lt;?php
namespace Database\Factories;
use Illuminate\Database\Eloquent\Factories\Factory;
/**
 * @extends \Illuminate\Database\Eloquent\Factories\Factory&lt;\App\Models\Genre&gt;
 */
class GenreFactory extends Factory
{
    /**
     * Define the model&apos;s default state.
     *
     * @return array&lt;string, mixed&gt;
     */
    public function definition(): array
    {
        return [
            //
        ];
    }
}</file><file path="database/factories/GenreSongFactory.php">&lt;?php
namespace Database\Factories;
use Illuminate\Database\Eloquent\Factories\Factory;
/**
 * @extends \Illuminate\Database\Eloquent\Factories\Factory&lt;\App\Models\GenreSong&gt;
 */
class GenreSongFactory extends Factory
{
    /**
     * Define the model&apos;s default state.
     *
     * @return array&lt;string, mixed&gt;
     */
    public function definition(): array
    {
        return [
            //
        ];
    }
}</file><file path="database/factories/ImageFactory.php">&lt;?php
namespace Database\Factories;
use Illuminate\Database\Eloquent\Factories\Factory;
/**
 * @extends \Illuminate\Database\Eloquent\Factories\Factory&lt;\App\Models\Image&gt;
 */
class ImageFactory extends Factory
{
    /**
     * Define the model&apos;s default state.
     *
     * @return array&lt;string, mixed&gt;
     */
    public function definition(): array
    {
        return [
            //
        ];
    }
}</file><file path="database/factories/LibraryFactory.php">&lt;?php
namespace Database\Factories;
use Illuminate\Database\Eloquent\Factories\Factory;
/**
 * @extends \Illuminate\Database\Eloquent\Factories\Factory&lt;\App\Models\Library&gt;
 */
class LibraryFactory extends Factory
{
    /**
     * Define the model&apos;s default state.
     *
     * @return array&lt;string, mixed&gt;
     */
    public function definition(): array
    {
        return [
            //
        ];
    }
}</file><file path="database/factories/MovieFactory.php">&lt;?php
namespace Database\Factories;
use Illuminate\Database\Eloquent\Factories\Factory;
/**
 * @extends \Illuminate\Database\Eloquent\Factories\Factory&lt;\App\Models\Movie&gt;
 */
class MovieFactory extends Factory
{
    /**
     * Define the model&apos;s default state.
     *
     * @return array&lt;string, mixed&gt;
     */
    public function definition(): array
    {
        return [
            //
        ];
    }
}</file><file path="database/factories/MovieVideoFactory.php">&lt;?php
namespace Database\Factories;
use Illuminate\Database\Eloquent\Factories\Factory;
/**
 * @extends \Illuminate\Database\Eloquent\Factories\Factory&lt;\App\Models\MovieVideo&gt;
 */
class MovieVideoFactory extends Factory
{
    /**
     * Define the model&apos;s default state.
     *
     * @return array&lt;string, mixed&gt;
     */
    public function definition(): array
    {
        return [
            //
        ];
    }
}</file><file path="database/factories/PasskeyFactory.php">&lt;?php
namespace Database\Factories;
use Illuminate\Database\Eloquent\Factories\Factory;
/**
 * @extends \Illuminate\Database\Eloquent\Factories\Factory&lt;\App\Models\Passkey&gt;
 */
class PasskeyFactory extends Factory
{
    /**
     * Define the model&apos;s default state.
     *
     * @return array&lt;string, mixed&gt;
     */
    public function definition(): array
    {
        return [
            &apos;name&apos; =&gt; $this-&gt;faker-&gt;word(),
            &apos;authenticatable_id&apos; =&gt; UserFactory::new(),
            &apos;credential_id&apos; =&gt; $this-&gt;faker-&gt;sentence,
            &apos;data&apos; =&gt; $this-&gt;dummyPublicKeyCredentialSource(),
        ];
    }
    protected function dummyPublicKeyCredentialSource(): PublicKeyCredentialSource
    {
        return PublicKeyCredentialSource::create(
            base64_decode(
                &apos;eHouz/Zi7+BmByHjJ/tx9h4a1WZsK4IzUmgGjkhyOodPGAyUqUp/B9yUkflXY3yHWsNtsrgCXQ3HjAIFUeZB+w==&apos;,
                true
            ),
            PublicKeyCredentialDescriptor::CREDENTIAL_TYPE_PUBLIC_KEY,
            [],
            &apos;none&apos;,
            $trustPath ?? EmptyTrustPath::create(),
            Uuid::fromString(&apos;00000000-0000-0000-0000-000000000000&apos;),
            base64_decode(
                &apos;pQECAyYgASFYIJV56vRrFusoDf9hm3iDmllcxxXzzKyO9WruKw4kWx7zIlgg/nq63l8IMJcIdKDJcXRh9hoz0L+nVwP1Oxil3/oNQYs=&apos;,
                true
            ),
            &apos;foo&apos;,
            100,
        );
    }
}</file><file path="database/factories/Player/PlayerStateFactory.php">&lt;?php
namespace Database\Factories\Player;
use Illuminate\Database\Eloquent\Factories\Factory;
/**
 * @extends \Illuminate\Database\Eloquent\Factories\Factory&lt;\App\Models\Player\PlayerState&gt;
 */
class PlayerStateFactory extends Factory
{
    /**
     * Define the model&apos;s default state.
     *
     * @return array&lt;string, mixed&gt;
     */
    public function definition(): array
    {
        return [
            //
        ];
    }
}</file><file path="database/factories/PlaylistFactory.php">&lt;?php
namespace Database\Factories;
use Illuminate\Database\Eloquent\Factories\Factory;
/**
 * @extends \Illuminate\Database\Eloquent\Factories\Factory&lt;\App\Models\Playlist&gt;
 */
class PlaylistFactory extends Factory
{
    /**
     * Define the model&apos;s default state.
     *
     * @return array&lt;string, mixed&gt;
     */
    public function definition(): array
    {
        return [
            //
        ];
    }
}</file><file path="database/factories/PlaylistSongFactory.php">&lt;?php
namespace Database\Factories;
use Illuminate\Database\Eloquent\Factories\Factory;
/**
 * @extends \Illuminate\Database\Eloquent\Factories\Factory&lt;\App\Models\PlaylistSong&gt;
 */
class PlaylistSongFactory extends Factory
{
    /**
     * Define the model&apos;s default state.
     *
     * @return array&lt;string, mixed&gt;
     */
    public function definition(): array
    {
        return [
            //
        ];
    }
}</file><file path="database/factories/PlaylistStatisticFactory.php">&lt;?php
namespace Database\Factories;
use Illuminate\Database\Eloquent\Factories\Factory;
/**
 * @extends \Illuminate\Database\Eloquent\Factories\Factory&lt;\App\Models\PlaylistStatistic&gt;
 */
class PlaylistStatisticFactory extends Factory
{
    /**
     * Define the model&apos;s default state.
     *
     * @return array&lt;string, mixed&gt;
     */
    public function definition(): array
    {
        return [
            //
        ];
    }
}</file><file path="database/factories/SongFactory.php">&lt;?php
namespace Database\Factories;
use Illuminate\Database\Eloquent\Factories\Factory;
/**
 * @extends \Illuminate\Database\Eloquent\Factories\Factory&lt;\App\Models\Song&gt;
 */
class SongFactory extends Factory
{
    /**
     * Define the model&apos;s default state.
     *
     * @return array&lt;string, mixed&gt;
     */
    public function definition(): array
    {
        return [
            //
        ];
    }
}</file><file path="database/factories/TranscodingSessionFactory.php">&lt;?php
namespace Database\Factories;
use Illuminate\Database\Eloquent\Factories\Factory;
/**
 * @extends \Illuminate\Database\Eloquent\Factories\Factory&lt;\App\Models\TranscodingSession&gt;
 */
class TranscodingSessionFactory extends Factory
{
    /**
     * Define the model&apos;s default state.
     *
     * @return array&lt;string, mixed&gt;
     */
    public function definition(): array
    {
        return [
            //
        ];
    }
}</file><file path="database/factories/UserFactory.php">&lt;?php
namespace Database\Factories;
use Illuminate\Database\Eloquent\Factories\Factory;
use Illuminate\Support\Facades\Hash;
use Illuminate\Support\Str;
/**
 * @extends \Illuminate\Database\Eloquent\Factories\Factory&lt;\App\Models\User&gt;
 */
class UserFactory extends Factory
{
    /**
     * The current password being used by the factory.
     */
    protected static ?string $password;
    /**
     * Define the model&apos;s default state.
     *
     * @return array&lt;string, mixed&gt;
     */
    public function definition(): array
    {
        return [
            &apos;name&apos;              =&gt; fake()-&gt;name(),
            &apos;email&apos;             =&gt; fake()-&gt;unique()-&gt;safeEmail(),
            &apos;email_verified_at&apos; =&gt; now(),
            &apos;password&apos;          =&gt; static::$password ??= Hash::make(&apos;password&apos;),
            &apos;remember_token&apos;    =&gt; Str::random(10),
        ];
    }
    /**
     * Indicate that the model&apos;s email address should be unverified.
     */
    public function unverified(): static
    {
        return $this-&gt;state(fn(array $attributes) =&gt; [
            &apos;email_verified_at&apos; =&gt; null,
        ]);
    }
}</file><file path="database/factories/UserLibraryFactory.php">&lt;?php
namespace Database\Factories;
use Illuminate\Database\Eloquent\Factories\Factory;
/**
 * @extends \Illuminate\Database\Eloquent\Factories\Factory&lt;\App\Models\UserLibrary&gt;
 */
class UserLibraryFactory extends Factory
{
    /**
     * Define the model&apos;s default state.
     *
     * @return array&lt;string, mixed&gt;
     */
    public function definition(): array
    {
        return [
            //
        ];
    }
}</file><file path="database/factories/UserMediaActivityFactory.php">&lt;?php
namespace Database\Factories;
use Illuminate\Database\Eloquent\Factories\Factory;
/**
 * @extends \Illuminate\Database\Eloquent\Factories\Factory&lt;\App\Models\UserMediaActivity&gt;
 */
class UserMediaActivityFactory extends Factory
{
    /**
     * Define the model&apos;s default state.
     *
     * @return array&lt;string, mixed&gt;
     */
    public function definition(): array
    {
        return [
            //
        ];
    }
}</file><file path="database/factories/VideoFactory.php">&lt;?php
namespace Database\Factories;
use Illuminate\Database\Eloquent\Factories\Factory;
/**
 * @extends \Illuminate\Database\Eloquent\Factories\Factory&lt;\App\Models\Video&gt;
 */
class VideoFactory extends Factory
{
    /**
     * Define the model&apos;s default state.
     *
     * @return array&lt;string, mixed&gt;
     */
    public function definition(): array
    {
        return [
            //
        ];
    }
}</file><file path="database/migrations/1900_01_01_000000_create_citext_extension.php">&lt;?php
use Illuminate\Database\Migrations\Migration;
use Tpetry\PostgresqlEnhanced\Support\Facades\Schema;
return new class extends Migration
{
    /**
     * Run the migrations.
     */
    public function up(): void
    {
        Schema::createExtensionIfNotExists(&apos;citext&apos;);
    }
    /**
     * Reverse the migrations.
     */
    public function down(): void
    {
        Schema::dropExtensionIfExists(&apos;citext&apos;);
    }
};</file><file path="database/migrations/1900_01_01_000001_create_uuidossp_extension.php">&lt;?php
use Illuminate\Database\Migrations\Migration;
use Tpetry\PostgresqlEnhanced\Support\Facades\Schema;
return new class extends Migration
{
    /**
     * Run the migrations.
     */
    public function up(): void
    {
        Schema::createExtensionIfNotExists(&apos;uuid-ossp&apos;);
    }
    /**
     * Reverse the migrations.
     */
    public function down(): void
    {
        Schema::dropExtensionIfExists(&apos;uuid-ossp&apos;);
    }
};</file><file path="database/migrations/2014_10_12_100000_create_password_reset_tokens_table.php">&lt;?php
use Illuminate\Database\Migrations\Migration;
use Tpetry\PostgresqlEnhanced\Schema\Blueprint;
use Tpetry\PostgresqlEnhanced\Support\Facades\Schema;
return new class extends Migration
{
    /**
     * Run the migrations.
     */
    public function up(): void
    {
        Schema::create(&apos;password_reset_tokens&apos;, function (Blueprint $table) {
            $table-&gt;text(&apos;email&apos;)-&gt;primary();
            $table-&gt;text(&apos;token&apos;);
            $table-&gt;timestampTz(&apos;created_at&apos;)-&gt;nullable();
        });
    }
    /**
     * Reverse the migrations.
     */
    public function down(): void
    {
        Schema::dropIfExists(&apos;password_reset_tokens&apos;);
    }
};</file><file path="database/migrations/2019_05_31_042934_create_versions_table.php">&lt;?php
use Illuminate\Database\Migrations\Migration;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\Schema;
return new class extends Migration
{
    /**
     * Run the migrations.
     */
    public function up()
    {
        Schema::create(&apos;versions&apos;, function (Blueprint $table) {
            $uuid = config(&apos;versionable.uuid&apos;);
            $uuid ? $table-&gt;uuid(&apos;id&apos;)-&gt;primary() : $table-&gt;bigIncrements(&apos;id&apos;);
            $table-&gt;foreignId(&apos;user_id&apos;)
                -&gt;references(&apos;id&apos;)
                -&gt;on(&apos;users&apos;)
                -&gt;cascadeOnDelete()
                -&gt;cascadeOnUpdate();
            $uuid ? $table-&gt;uuidMorphs(&apos;versionable&apos;) : $table-&gt;morphs(&apos;versionable&apos;);
            $table-&gt;jsonb(&apos;contents&apos;)-&gt;nullable();
            $table-&gt;timestampsTz();
        });
    }
    /**
     * Reverse the migrations.
     */
    public function down()
    {
        Schema::dropIfExists(&apos;versions&apos;);
    }
};</file><file path="database/migrations/2019_08_19_000000_create_failed_jobs_table.php">&lt;?php
use Illuminate\Database\Migrations\Migration;
use Tpetry\PostgresqlEnhanced\Schema\Blueprint;
use Tpetry\PostgresqlEnhanced\Support\Facades\Schema;
return new class extends Migration
{
    /**
     * Run the migrations.
     */
    public function up(): void
    {
        Schema::create(&apos;failed_jobs&apos;, function (Blueprint $table) {
            $table-&gt;id();
            $table-&gt;uuid()-&gt;unique();
            $table-&gt;text(&apos;connection&apos;);
            $table-&gt;text(&apos;queue&apos;);
            $table-&gt;text(&apos;payload&apos;);
            $table-&gt;text(&apos;exception&apos;);
            $table-&gt;timestampTz(&apos;failed_at&apos;)-&gt;useCurrent();
        });
    }
    /**
     * Reverse the migrations.
     */
    public function down(): void
    {
        Schema::dropIfExists(&apos;failed_jobs&apos;);
    }
};</file><file path="database/migrations/2020_07_03_163707_add_deleted_at_to_versions.php">&lt;?php
use Illuminate\Database\Migrations\Migration;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\Schema;
return new class extends Migration
{
    /**
     * Run the migrations.
     *
     * @return void
     */
    public function up()
    {
        Schema::table(&apos;versions&apos;, function (Blueprint $table) {
            $table-&gt;softDeletesTz();
        });
    }
    /**
     * Reverse the migrations.
     *
     * @return void
     */
    public function down()
    {
        Schema::table(&apos;versions&apos;, function (Blueprint $table) {
            $table-&gt;dropSoftDeletes();
        });
    }
};</file><file path="database/migrations/2021_03_18_160750_make_user_nullable.php">&lt;?php
use Illuminate\Database\Migrations\Migration;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\Schema;
return new class extends Migration
{
    /**
     * Run the migrations.
     *
     * @return void
     */
    public function up()
    {
        Schema::table(&apos;versions&apos;, function (Blueprint $table) {
            $table-&gt;unsignedBigInteger(config(&apos;versionable.user_foreign_key&apos;, &apos;user_id&apos;))-&gt;nullable()-&gt;change();
        });
    }
    /**
     * Reverse the migrations.
     *
     * @return void
     */
    public function down()
    {
        Schema::table(&apos;versions&apos;, function (Blueprint $table) {
            $table-&gt;unsignedBigInteger(config(&apos;versionable.user_foreign_key&apos;, &apos;user_id&apos;))-&gt;nullable(false)-&gt;change();
        });
    }
};</file><file path="database/migrations/2023_06_07_000001_create_pulse_tables.php">&lt;?php
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\Schema;
use Laravel\Pulse\Support\PulseMigration;
return new class extends PulseMigration
{
    /**
     * Run the migrations.
     */
    public function up(): void
    {
        if (! $this-&gt;shouldRun()) {
            return;
        }
        Schema::create(&apos;pulse_values&apos;, function (Blueprint $table) {
            $table-&gt;id();
            $table-&gt;unsignedInteger(&apos;timestamp&apos;);
            $table-&gt;string(&apos;type&apos;);
            $table-&gt;mediumText(&apos;key&apos;);
            match ($this-&gt;driver()) {
                &apos;mysql&apos; =&gt; $table-&gt;char(&apos;key_hash&apos;, 16)-&gt;charset(&apos;binary&apos;)-&gt;virtualAs(&apos;unhex(md5(`key`))&apos;),
                &apos;pgsql&apos; =&gt; $table-&gt;uuid(&apos;key_hash&apos;)-&gt;storedAs(&apos;md5(&quot;key&quot;)::uuid&apos;),
                &apos;sqlite&apos; =&gt; $table-&gt;string(&apos;key_hash&apos;),
            };
            $table-&gt;mediumText(&apos;value&apos;);
            $table-&gt;index(&apos;timestamp&apos;); // For trimming...
            $table-&gt;index(&apos;type&apos;); // For fast lookups and purging...
            $table-&gt;unique([&apos;type&apos;, &apos;key_hash&apos;]); // For data integrity and upserts...
        });
        Schema::create(&apos;pulse_entries&apos;, function (Blueprint $table) {
            $table-&gt;id();
            $table-&gt;unsignedInteger(&apos;timestamp&apos;);
            $table-&gt;string(&apos;type&apos;);
            $table-&gt;mediumText(&apos;key&apos;);
            match ($this-&gt;driver()) {
                &apos;mysql&apos; =&gt; $table-&gt;char(&apos;key_hash&apos;, 16)-&gt;charset(&apos;binary&apos;)-&gt;virtualAs(&apos;unhex(md5(`key`))&apos;),
                &apos;pgsql&apos; =&gt; $table-&gt;uuid(&apos;key_hash&apos;)-&gt;storedAs(&apos;md5(&quot;key&quot;)::uuid&apos;),
                &apos;sqlite&apos; =&gt; $table-&gt;string(&apos;key_hash&apos;),
            };
            $table-&gt;bigInteger(&apos;value&apos;)-&gt;nullable();
            $table-&gt;index(&apos;timestamp&apos;); // For trimming...
            $table-&gt;index(&apos;type&apos;); // For purging...
            $table-&gt;index(&apos;key_hash&apos;); // For mapping...
            $table-&gt;index([&apos;timestamp&apos;, &apos;type&apos;, &apos;key_hash&apos;, &apos;value&apos;]); // For aggregate queries...
        });
        Schema::create(&apos;pulse_aggregates&apos;, function (Blueprint $table) {
            $table-&gt;id();
            $table-&gt;unsignedInteger(&apos;bucket&apos;);
            $table-&gt;unsignedMediumInteger(&apos;period&apos;);
            $table-&gt;string(&apos;type&apos;);
            $table-&gt;mediumText(&apos;key&apos;);
            match ($this-&gt;driver()) {
                &apos;mysql&apos; =&gt; $table-&gt;char(&apos;key_hash&apos;, 16)-&gt;charset(&apos;binary&apos;)-&gt;virtualAs(&apos;unhex(md5(`key`))&apos;),
                &apos;pgsql&apos; =&gt; $table-&gt;uuid(&apos;key_hash&apos;)-&gt;storedAs(&apos;md5(&quot;key&quot;)::uuid&apos;),
                &apos;sqlite&apos; =&gt; $table-&gt;string(&apos;key_hash&apos;),
            };
            $table-&gt;string(&apos;aggregate&apos;);
            $table-&gt;decimal(&apos;value&apos;, 20, 2);
            $table-&gt;unsignedInteger(&apos;count&apos;)-&gt;nullable();
            $table-&gt;unique([&apos;bucket&apos;, &apos;period&apos;, &apos;type&apos;, &apos;aggregate&apos;, &apos;key_hash&apos;]); // Force &quot;on duplicate update&quot;...
            $table-&gt;index([&apos;period&apos;, &apos;bucket&apos;]); // For trimming...
            $table-&gt;index(&apos;type&apos;); // For purging...
            $table-&gt;index([&apos;period&apos;, &apos;type&apos;, &apos;aggregate&apos;, &apos;bucket&apos;]); // For aggregate queries...
        });
    }
    /**
     * Reverse the migrations.
     */
    public function down(): void
    {
        Schema::dropIfExists(&apos;pulse_values&apos;);
        Schema::dropIfExists(&apos;pulse_entries&apos;);
        Schema::dropIfExists(&apos;pulse_aggregates&apos;);
    }
};</file><file path="database/migrations/2024_04_07_120726_create_libraries_table.php">&lt;?php
use Illuminate\Database\Migrations\Migration;
use Tpetry\PostgresqlEnhanced\Schema\Blueprint;
use Tpetry\PostgresqlEnhanced\Support\Facades\Schema;
return new class extends Migration
{
    /**
     * Run the migrations.
     */
    public function up(): void
    {
        Schema::create(&apos;libraries&apos;, function (Blueprint $table) {
            $table-&gt;id();
            $table-&gt;caseInsensitiveText(&apos;name&apos;);
            $table-&gt;text(&apos;slug&apos;)-&gt;unique();
            $table-&gt;text(&apos;path&apos;);
            $table-&gt;enum(&apos;type&apos;, [&apos;music&apos;, &apos;podcast&apos;, &apos;audiobook&apos;, &apos;movie&apos;, &apos;tv_show&apos;]);
            $table-&gt;unsignedInteger(&apos;order&apos;);
            $table-&gt;timestampTz(&apos;last_scan&apos;)-&gt;nullable();
            $table-&gt;timestampsTz();
        });
    }
    /**
     * Reverse the migrations.
     */
    public function down(): void
    {
        Schema::dropIfExists(&apos;libraries&apos;);
    }
};</file><file path="database/migrations/2024_08_11_200722_add_two_factor_columns_to_users_table.php">&lt;?php
use Illuminate\Database\Migrations\Migration;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\Schema;
use Laravel\Fortify\Fortify;
return new class extends Migration
{
    /**
     * Run the migrations.
     */
    public function up(): void
    {
        Schema::table(&apos;users&apos;, function (Blueprint $table) {
            $table-&gt;text(&apos;two_factor_secret&apos;)
                -&gt;after(&apos;password&apos;)
                -&gt;nullable();
            $table-&gt;text(&apos;two_factor_recovery_codes&apos;)
                -&gt;after(&apos;two_factor_secret&apos;)
                -&gt;nullable();
            if (Fortify::confirmsTwoFactorAuthentication()) {
                $table-&gt;timestamp(&apos;two_factor_confirmed_at&apos;)
                    -&gt;after(&apos;two_factor_recovery_codes&apos;)
                    -&gt;nullable();
            }
        });
    }
    /**
     * Reverse the migrations.
     */
    public function down(): void
    {
        Schema::table(&apos;users&apos;, function (Blueprint $table) {
            $table-&gt;dropColumn(array_merge([
                &apos;two_factor_secret&apos;,
                &apos;two_factor_recovery_codes&apos;,
            ], Fortify::confirmsTwoFactorAuthentication() ? [
                &apos;two_factor_confirmed_at&apos;,
            ] : []));
        });
    }
};</file><file path="database/migrations/2024_09_13_224442_create_permission_tables.php">&lt;?php
use Illuminate\Database\Migrations\Migration;
use Tpetry\PostgresqlEnhanced\Schema\Blueprint;
use Tpetry\PostgresqlEnhanced\Support\Facades\Schema;
return new class extends Migration {
    /**
     * Run the migrations.
     */
    public function up(): void
    {
        $teams = config(&apos;permission.teams&apos;);
        $tableNames = config(&apos;permission.table_names&apos;);
        $columnNames = config(&apos;permission.column_names&apos;);
        $pivotRole = $columnNames[&apos;role_pivot_key&apos;] ?? &apos;role_id&apos;;
        $pivotPermission = $columnNames[&apos;permission_pivot_key&apos;] ?? &apos;permission_id&apos;;
        if (empty($tableNames)) {
            throw new \Exception(&apos;Error: config/permission.php not loaded. Run [php artisan config:clear] and try again.&apos;);
        }
        if ($teams &amp;&amp; empty($columnNames[&apos;team_foreign_key&apos;] ?? null)) {
            throw new \Exception(&apos;Error: team_foreign_key on config/permission.php not loaded. Run [php artisan config:clear] and try again.&apos;);
        }
        Schema::create($tableNames[&apos;permissions&apos;], function (Blueprint $table) {
            //$table-&gt;engine(&apos;InnoDB&apos;);
            $table-&gt;bigIncrements(&apos;id&apos;); // permission id
            $table-&gt;text(&apos;name&apos;);       // For MyISAM use text(&apos;name&apos;, 225); // (or 166 for InnoDB with Redundant/Compact row format)
            $table-&gt;text(&apos;guard_name&apos;); // For MyISAM use text(&apos;guard_name&apos;, 25);
            $table-&gt;timestampsTz();
            $table-&gt;unique([&apos;name&apos;, &apos;guard_name&apos;]);
        });
        Schema::create($tableNames[&apos;roles&apos;], function (Blueprint $table) use ($teams, $columnNames) {
            //$table-&gt;engine(&apos;InnoDB&apos;);
            $table-&gt;bigIncrements(&apos;id&apos;); // role id
            if ($teams || config(&apos;permission.testing&apos;)) { // permission.testing is a fix for sqlite testing
                $table-&gt;unsignedBigInteger($columnNames[&apos;team_foreign_key&apos;])-&gt;nullable();
                $table-&gt;index($columnNames[&apos;team_foreign_key&apos;], &apos;roles_team_foreign_key_index&apos;);
            }
            $table-&gt;text(&apos;name&apos;);       // For MyISAM use text(&apos;name&apos;, 225); // (or 166 for InnoDB with Redundant/Compact row format)
            $table-&gt;text(&apos;guard_name&apos;); // For MyISAM use text(&apos;guard_name&apos;, 25);
            $table-&gt;timestampsTz();
            if ($teams || config(&apos;permission.testing&apos;)) {
                $table-&gt;unique([$columnNames[&apos;team_foreign_key&apos;], &apos;name&apos;, &apos;guard_name&apos;]);
            } else {
                $table-&gt;unique([&apos;name&apos;, &apos;guard_name&apos;]);
            }
        });
        Schema::create($tableNames[&apos;model_has_permissions&apos;], function (Blueprint $table) use ($tableNames, $columnNames, $pivotPermission, $teams) {
            $table-&gt;unsignedBigInteger($pivotPermission);
            $table-&gt;text(&apos;model_type&apos;);
            $table-&gt;unsignedBigInteger($columnNames[&apos;model_morph_key&apos;]);
            $table-&gt;index([$columnNames[&apos;model_morph_key&apos;], &apos;model_type&apos;], &apos;model_has_permissions_model_id_model_type_index&apos;);
            $table-&gt;foreign($pivotPermission)
                -&gt;references(&apos;id&apos;) // permission id
                -&gt;on($tableNames[&apos;permissions&apos;])
                -&gt;onDelete(&apos;cascade&apos;);
            if ($teams) {
                $table-&gt;unsignedBigInteger($columnNames[&apos;team_foreign_key&apos;]);
                $table-&gt;index($columnNames[&apos;team_foreign_key&apos;], &apos;model_has_permissions_team_foreign_key_index&apos;);
                $table-&gt;primary([$columnNames[&apos;team_foreign_key&apos;], $pivotPermission, $columnNames[&apos;model_morph_key&apos;], &apos;model_type&apos;],
                    &apos;model_has_permissions_permission_model_type_primary&apos;);
            } else {
                $table-&gt;primary([$pivotPermission, $columnNames[&apos;model_morph_key&apos;], &apos;model_type&apos;],
                    &apos;model_has_permissions_permission_model_type_primary&apos;);
            }
        });
        Schema::create($tableNames[&apos;model_has_roles&apos;], function (Blueprint $table) use ($tableNames, $columnNames, $pivotRole, $teams) {
            $table-&gt;unsignedBigInteger($pivotRole);
            $table-&gt;text(&apos;model_type&apos;);
            $table-&gt;unsignedBigInteger($columnNames[&apos;model_morph_key&apos;]);
            $table-&gt;index([$columnNames[&apos;model_morph_key&apos;], &apos;model_type&apos;], &apos;model_has_roles_model_id_model_type_index&apos;);
            $table-&gt;foreign($pivotRole)
                -&gt;references(&apos;id&apos;) // role id
                -&gt;on($tableNames[&apos;roles&apos;])
                -&gt;onDelete(&apos;cascade&apos;);
            if ($teams) {
                $table-&gt;unsignedBigInteger($columnNames[&apos;team_foreign_key&apos;]);
                $table-&gt;index($columnNames[&apos;team_foreign_key&apos;], &apos;model_has_roles_team_foreign_key_index&apos;);
                $table-&gt;primary([$columnNames[&apos;team_foreign_key&apos;], $pivotRole, $columnNames[&apos;model_morph_key&apos;], &apos;model_type&apos;],
                    &apos;model_has_roles_role_model_type_primary&apos;);
            } else {
                $table-&gt;primary([$pivotRole, $columnNames[&apos;model_morph_key&apos;], &apos;model_type&apos;],
                    &apos;model_has_roles_role_model_type_primary&apos;);
            }
        });
        Schema::create($tableNames[&apos;role_has_permissions&apos;], function (Blueprint $table) use ($tableNames, $pivotRole, $pivotPermission) {
            $table-&gt;unsignedBigInteger($pivotPermission);
            $table-&gt;unsignedBigInteger($pivotRole);
            $table-&gt;foreign($pivotPermission)
                -&gt;references(&apos;id&apos;) // permission id
                -&gt;on($tableNames[&apos;permissions&apos;])
                -&gt;onDelete(&apos;cascade&apos;);
            $table-&gt;foreign($pivotRole)
                -&gt;references(&apos;id&apos;) // role id
                -&gt;on($tableNames[&apos;roles&apos;])
                -&gt;onDelete(&apos;cascade&apos;);
            $table-&gt;primary([$pivotPermission, $pivotRole], &apos;role_has_permissions_permission_id_role_id_primary&apos;);
        });
        app(&apos;cache&apos;)
            -&gt;store(config(&apos;permission.cache.store&apos;) != &apos;default&apos; ? config(&apos;permission.cache.store&apos;) : null)
            -&gt;forget(config(&apos;permission.cache.key&apos;));
    }
    /**
     * Reverse the migrations.
     */
    public function down(): void
    {
        $tableNames = config(&apos;permission.table_names&apos;);
        if (empty($tableNames)) {
            throw new \Exception(&apos;Error: config/permission.php not found and defaults could not be merged. Please publish the package configuration before proceeding, or drop the tables manually.&apos;);
        }
        Schema::drop($tableNames[&apos;role_has_permissions&apos;]);
        Schema::drop($tableNames[&apos;model_has_roles&apos;]);
        Schema::drop($tableNames[&apos;model_has_permissions&apos;]);
        Schema::drop($tableNames[&apos;roles&apos;]);
        Schema::drop($tableNames[&apos;permissions&apos;]);
    }
};</file><file path="database/migrations/2024_09_13_232859_create_user_library_table.php">&lt;?php
use Illuminate\Database\Migrations\Migration;
use Tpetry\PostgresqlEnhanced\Schema\Blueprint;
use Tpetry\PostgresqlEnhanced\Support\Facades\Schema;
return new class extends Migration {
    /**
     * Run the migrations.
     */
    public function up(): void
    {
        Schema::create(&apos;user_library&apos;, function (Blueprint $table) {
            $table-&gt;id();
            $table-&gt;foreignId(&apos;user_id&apos;)
                -&gt;references(&apos;id&apos;)
                -&gt;on(&apos;users&apos;)
                -&gt;cascadeOnDelete()
                -&gt;cascadeOnUpdate();
            $table-&gt;foreignId(&apos;library_id&apos;)
                -&gt;references(&apos;id&apos;)
                -&gt;on(&apos;libraries&apos;)
                -&gt;cascadeOnDelete()
                -&gt;cascadeOnUpdate();
            $table-&gt;timestampsTz();
            $table-&gt;unique([&apos;user_id&apos;, &apos;library_id&apos;]);
        });
    }
    /**
     * Reverse the migrations.
     */
    public function down(): void
    {
        Schema::dropIfExists(&apos;user_libraries&apos;);
    }
};</file><file path="database/migrations/2024_10_04_212603_create_genre_song_table.php">&lt;?php
use Illuminate\Database\Migrations\Migration;
use Tpetry\PostgresqlEnhanced\Schema\Blueprint;
use Tpetry\PostgresqlEnhanced\Support\Facades\Schema;
return new class extends Migration
{
    /**
     * Run the migrations.
     */
    public function up(): void
    {
        Schema::create(&apos;genre_song&apos;, function (Blueprint $table) {
            $table-&gt;id();
            $table-&gt;foreignId(&apos;genre_id&apos;)
                -&gt;references(&apos;id&apos;)
                -&gt;on(&apos;genres&apos;)
                -&gt;cascadeOnDelete()
                -&gt;cascadeOnUpdate();
            $table-&gt;foreignId(&apos;song_id&apos;)
                -&gt;references(&apos;id&apos;)
                -&gt;on(&apos;songs&apos;)
                -&gt;cascadeOnDelete()
                -&gt;cascadeOnUpdate();
            $table-&gt;unique([&apos;genre_id&apos;, &apos;song_id&apos;]);
            $table-&gt;index(&apos;song_id&apos;);
            $table-&gt;index(&apos;genre_id&apos;);
        });
    }
    /**
     * Reverse the migrations.
     */
    public function down(): void
    {
        Schema::dropIfExists(&apos;genre_song&apos;);
    }
};</file><file path="database/migrations/2024_10_05_162336_create_album_artists_table.php">&lt;?php
use Illuminate\Database\Migrations\Migration;
use Tpetry\PostgresqlEnhanced\Schema\Blueprint;
use Tpetry\PostgresqlEnhanced\Support\Facades\Schema;
return new class extends Migration
{
    /**
     * Run the migrations.
     */
    public function up(): void
    {
        Schema::create(&apos;album_artist&apos;, function (Blueprint $table) {
            $table-&gt;id();
            $table-&gt;foreignId(&apos;album_id&apos;)
                -&gt;references(&apos;id&apos;)
                -&gt;on(&apos;albums&apos;)
                -&gt;cascadeOnDelete()
                -&gt;cascadeOnUpdate();
            $table-&gt;foreignId(&apos;artist_id&apos;)
                -&gt;references(&apos;id&apos;)
                -&gt;on(&apos;artists&apos;)
                -&gt;cascadeOnDelete()
                -&gt;cascadeOnUpdate();
            $table-&gt;unique([&apos;album_id&apos;, &apos;artist_id&apos;]);
            $table-&gt;index(&apos;album_id&apos;);
            $table-&gt;index(&apos;artist_id&apos;);
        });
    }
    /**
     * Reverse the migrations.
     */
    public function down(): void
    {
        Schema::dropIfExists(&apos;album_artists&apos;);
    }
};</file><file path="database/migrations/2024_10_06_014632_create_oauth_auth_codes_table.php">&lt;?php
use Illuminate\Database\Migrations\Migration;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\Schema;
return new class extends Migration
{
    /**
     * Run the migrations.
     */
    public function up(): void
    {
        Schema::create(&apos;oauth_auth_codes&apos;, function (Blueprint $table) {
            $table-&gt;char(&apos;id&apos;, 80)-&gt;primary();
            $table-&gt;foreignId(&apos;user_id&apos;)-&gt;index();
            $table-&gt;foreignUuid(&apos;client_id&apos;);
            $table-&gt;text(&apos;scopes&apos;)-&gt;nullable();
            $table-&gt;boolean(&apos;revoked&apos;);
            $table-&gt;dateTimeTz(&apos;expires_at&apos;)-&gt;nullable();
        });
    }
    /**
     * Reverse the migrations.
     */
    public function down(): void
    {
        Schema::dropIfExists(&apos;oauth_auth_codes&apos;);
    }
    /**
     * Get the migration connection name.
     */
    public function getConnection(): ?string
    {
        return $this-&gt;connection ?? config(&apos;passport.connection&apos;);
    }
};</file><file path="database/migrations/2024_10_06_014633_create_oauth_access_tokens_table.php">&lt;?php
use Illuminate\Database\Migrations\Migration;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\Schema;
return new class extends Migration
{
    /**
     * Run the migrations.
     */
    public function up(): void
    {
        Schema::create(&apos;oauth_access_tokens&apos;, function (Blueprint $table) {
            $table-&gt;char(&apos;id&apos;, 80)-&gt;primary();
            $table-&gt;foreignId(&apos;user_id&apos;)-&gt;nullable()-&gt;index();
            $table-&gt;foreignUuid(&apos;client_id&apos;);
            $table-&gt;text(&apos;name&apos;)-&gt;nullable();
            $table-&gt;text(&apos;scopes&apos;)-&gt;nullable();
            $table-&gt;boolean(&apos;revoked&apos;);
            $table-&gt;timestampsTz();
            $table-&gt;dateTimeTz(&apos;expires_at&apos;)-&gt;nullable();
        });
    }
    /**
     * Reverse the migrations.
     */
    public function down(): void
    {
        Schema::dropIfExists(&apos;oauth_access_tokens&apos;);
    }
    /**
     * Get the migration connection name.
     */
    public function getConnection(): ?string
    {
        return $this-&gt;connection ?? config(&apos;passport.connection&apos;);
    }
};</file><file path="database/migrations/2024_10_06_014634_create_oauth_refresh_tokens_table.php">&lt;?php
use Illuminate\Database\Migrations\Migration;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\Schema;
return new class extends Migration
{
    /**
     * Run the migrations.
     */
    public function up(): void
    {
        Schema::create(&apos;oauth_refresh_tokens&apos;, function (Blueprint $table) {
            $table-&gt;char(&apos;id&apos;, 80)-&gt;primary();
            $table-&gt;char(&apos;access_token_id&apos;, 80)-&gt;index();
            $table-&gt;boolean(&apos;revoked&apos;);
            $table-&gt;dateTimeTz(&apos;expires_at&apos;)-&gt;nullable();
        });
    }
    /**
     * Reverse the migrations.
     */
    public function down(): void
    {
        Schema::dropIfExists(&apos;oauth_refresh_tokens&apos;);
    }
    /**
     * Get the migration connection name.
     */
    public function getConnection(): ?string
    {
        return $this-&gt;connection ?? config(&apos;passport.connection&apos;);
    }
};</file><file path="database/migrations/2024_10_06_014635_create_oauth_clients_table.php">&lt;?php
use Illuminate\Database\Migrations\Migration;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\Schema;
return new class extends Migration
{
    /**
     * Run the migrations.
     */
    public function up(): void
    {
        Schema::create(&apos;oauth_clients&apos;, function (Blueprint $table) {
            $table-&gt;uuid(&apos;id&apos;)-&gt;primary();
            $table-&gt;foreignId(&apos;user_id&apos;)-&gt;nullable()-&gt;index();
            $table-&gt;text(&apos;name&apos;);
            $table-&gt;text(&apos;secret&apos;)-&gt;nullable();
            $table-&gt;text(&apos;provider&apos;)-&gt;nullable();
            $table-&gt;text(&apos;redirect_uris&apos;);
            $table-&gt;text(&apos;grant_types&apos;);
            $table-&gt;boolean(&apos;revoked&apos;);
            $table-&gt;timestampsTz();
        });
    }
    /**
     * Reverse the migrations.
     */
    public function down(): void
    {
        Schema::dropIfExists(&apos;oauth_clients&apos;);
    }
    /**
     * Get the migration connection name.
     */
    public function getConnection(): ?string
    {
        return $this-&gt;connection ?? config(&apos;passport.connection&apos;);
    }
};</file><file path="database/migrations/2025_02_26_225139_create_transcoding_sessions_table.php">&lt;?php
use Illuminate\Database\Migrations\Migration;
use Tpetry\PostgresqlEnhanced\Schema\Blueprint;
use Tpetry\PostgresqlEnhanced\Support\Facades\Schema;
return new class extends Migration
{
    /**
     * Run the migrations.
     */
    public function up(): void
    {
        Schema::create(&apos;transcoding_sessions&apos;, function (Blueprint $table) {
            $table-&gt;id();
            $table-&gt;uuid(&apos;session_id&apos;)-&gt;unique();
            $table-&gt;string(&apos;protocol&apos;);
            $table-&gt;jsonb(&apos;options&apos;);
            $table-&gt;timestampsTz();
        });
    }
    /**
     * Reverse the migrations.
     */
    public function down(): void
    {
        Schema::dropIfExists(&apos;transcoding_sessions&apos;);
    }
};</file><file path="database/migrations/2025_05_11_113239_create_playlists_table.php">&lt;?php
use Illuminate\Database\Migrations\Migration;
use Tpetry\PostgresqlEnhanced\Schema\Blueprint;
use Tpetry\PostgresqlEnhanced\Support\Facades\Schema;
return new class extends Migration
{
    /**
     * Run the migrations.
     */
    public function up(): void
    {
        Schema::create(&apos;playlists&apos;, function (Blueprint $table) {
            $table-&gt;id();
            $table-&gt;text(&apos;public_id&apos;)-&gt;unique();
            $table-&gt;foreignId(&apos;user_id&apos;)
                -&gt;constrained()
                -&gt;onDelete(&apos;cascade&apos;);
            $table-&gt;caseInsensitiveText(&apos;name&apos;);
            $table-&gt;text(&apos;description&apos;)-&gt;nullable();
            $table-&gt;boolean(&apos;is_public&apos;)-&gt;default(false);
            $table-&gt;boolean(&apos;is_collaborative&apos;)-&gt;default(false);
            $table-&gt;boolean(&apos;is_smart&apos;)-&gt;default(false);
            $table-&gt;jsonb(&apos;smart_rules&apos;)-&gt;nullable();
            $table-&gt;timestampsTz();
        });
    }
    /**
     * Reverse the migrations.
     */
    public function down(): void
    {
        Schema::dropIfExists(&apos;playlists&apos;);
    }
};</file><file path="database/migrations/2025_05_11_113343_create_playlist_song_table.php">&lt;?php
use Illuminate\Database\Migrations\Migration;
use Tpetry\PostgresqlEnhanced\Schema\Blueprint;
use Tpetry\PostgresqlEnhanced\Support\Facades\Schema;
return new class extends Migration {
    /**
     * Run the migrations.
     */
    public function up(): void
    {
        Schema::create(&apos;playlist_song&apos;, function (Blueprint $table) {
            $table-&gt;id();
            $table-&gt;foreignId(&apos;playlist_id&apos;)
                -&gt;constrained()
                -&gt;onDelete(&apos;cascade&apos;);
            $table-&gt;foreignId(&apos;song_id&apos;)
                -&gt;constrained()
                -&gt;onDelete(&apos;cascade&apos;);
            $table-&gt;integer(&apos;position&apos;)-&gt;default(0);
            $table-&gt;timestampsTz();
            $table-&gt;unique([&apos;playlist_id&apos;, &apos;song_id&apos;]);
        });
    }
    /**
     * Reverse the migrations.
     */
    public function down(): void
    {
        Schema::dropIfExists(&apos;playlist_song&apos;);
    }
};</file><file path="database/migrations/2025_05_11_115840_create_playlist_collaborator_table.php">&lt;?php
use Illuminate\Database\Migrations\Migration;
use Tpetry\PostgresqlEnhanced\Schema\Blueprint;
use Tpetry\PostgresqlEnhanced\Support\Facades\Schema;
return new class extends Migration
{
    /**
     * Run the migrations.
     */
    public function up(): void
    {
        Schema::create(&apos;playlist_collaborator&apos;, function (Blueprint $table) {
            $table-&gt;id();
            $table-&gt;foreignId(&apos;playlist_id&apos;)
                -&gt;constrained()
                -&gt;onDelete(&apos;cascade&apos;);
            $table-&gt;foreignId(&apos;user_id&apos;)
                -&gt;constrained()
                -&gt;onDelete(&apos;cascade&apos;);
            $table-&gt;text(&apos;role&apos;)-&gt;default(&apos;editor&apos;);
            $table-&gt;timestampsTz();
            $table-&gt;unique([&apos;playlist_id&apos;, &apos;user_id&apos;]);
        });
    }
    /**
     * Reverse the migrations.
     */
    public function down(): void
    {
        Schema::dropIfExists(&apos;playlist_collaborator&apos;);
    }
};</file><file path="database/migrations/2025_05_11_120239_create_playlist_statistics_table.php">&lt;?php
use Illuminate\Database\Migrations\Migration;
use Tpetry\PostgresqlEnhanced\Schema\Blueprint;
use Tpetry\PostgresqlEnhanced\Support\Facades\Schema;
return new class extends Migration
{
    /**
     * Run the migrations.
     */
    public function up(): void
    {
        Schema::create(&apos;playlist_statistics&apos;, function (Blueprint $table) {
            $table-&gt;id();
            $table-&gt;foreignId(&apos;playlist_id&apos;)
                -&gt;constrained()
                -&gt;onDelete(&apos;cascade&apos;);
            $table-&gt;integer(&apos;views&apos;)-&gt;default(0);
            $table-&gt;integer(&apos;plays&apos;)-&gt;default(0);
            $table-&gt;integer(&apos;shares&apos;)-&gt;default(0);
            $table-&gt;integer(&apos;favorites&apos;)-&gt;default(0);
            $table-&gt;timestampsTz();
        });
    }
    /**
     * Reverse the migrations.
     */
    public function down(): void
    {
        Schema::dropIfExists(&apos;playlist_statistics&apos;);
    }
};</file><file path="database/migrations/2025_05_31_195952_create_recommendations_table.php">&lt;?php
use Illuminate\Database\Migrations\Migration;
use Tpetry\PostgresqlEnhanced\Schema\Blueprint;
use Tpetry\PostgresqlEnhanced\Support\Facades\Schema;
return new class extends Migration
{
    /**
     * Run the migrations.
     */
    public function up(): void
    {
        Schema::create(&apos;recommendations&apos;, function (Blueprint $table) {
            $table-&gt;id();
            $table-&gt;string(&apos;name&apos;)-&gt;default(&apos;default&apos;);
            $table-&gt;morphs(&apos;source&apos;);
            $table-&gt;morphs(&apos;target&apos;);
            $table-&gt;bigInteger(&apos;score&apos;)-&gt;default(0);
            $table-&gt;unsignedInteger(&apos;position&apos;)-&gt;nullable();
            $table-&gt;timestampsTz();
            $table-&gt;index([&apos;source_type&apos;, &apos;source_id&apos;, &apos;name&apos;, &apos;position&apos;], &apos;idx_recommendation_source_position&apos;);
            $table-&gt;index([&apos;source_type&apos;, &apos;source_id&apos;, &apos;target_type&apos;, &apos;target_id&apos;], &apos;idx_recommendation_source_target&apos;);
            $table-&gt;index(&apos;score&apos;, &apos;idx_recommendation_score&apos;);
        });
    }
    /**
     * Reverse the migrations.
     */
    public function down(): void
    {
        Schema::dropIfExists(&apos;recommendations&apos;);
    }
};</file><file path="database/migrations/2025_06_07_180140_create_movies_table.php">&lt;?php
use Illuminate\Database\Migrations\Migration;
use Tpetry\PostgresqlEnhanced\Schema\Blueprint;
use Tpetry\PostgresqlEnhanced\Support\Facades\Schema;
return new class extends Migration
{
    /**
     * Run the migrations.
     */
    public function up(): void
    {
        Schema::create(&apos;movies&apos;, function (Blueprint $table) {
            $table-&gt;id();
            $table-&gt;foreignId(&apos;library_id&apos;)
                -&gt;references(&apos;id&apos;)
                -&gt;on(&apos;libraries&apos;)
                -&gt;cascadeOnDelete();
            $table-&gt;caseInsensitiveText(&apos;title&apos;);
            $table-&gt;text(&apos;slug&apos;)-&gt;unique();
            $table-&gt;integer(&apos;year&apos;)-&gt;nullable();
            $table-&gt;text(&apos;summary&apos;)-&gt;nullable();
            $table-&gt;timestampsTz();
        });
    }
    /**
     * Reverse the migrations.
     */
    public function down(): void
    {
        Schema::dropIfExists(&apos;movies&apos;);
    }
};</file><file path="database/migrations/2025_06_07_181520_create_videos_table.php">&lt;?php
use Illuminate\Database\Migrations\Migration;
use Tpetry\PostgresqlEnhanced\Schema\Blueprint;
use Tpetry\PostgresqlEnhanced\Support\Facades\Schema;
return new class extends Migration
{
    /**
     * Run the migrations.
     */
    public function up(): void
    {
        Schema::create(&apos;videos&apos;, function (Blueprint $table) {
            $table-&gt;id();
            $table-&gt;text(&apos;path&apos;);
            $table-&gt;text(&apos;hash&apos;)-&gt;unique();
            $table-&gt;integer(&apos;duration&apos;)-&gt;nullable();
            $table-&gt;integer(&apos;height&apos;)-&gt;nullable();
            $table-&gt;integer(&apos;width&apos;)-&gt;nullable();
            $table-&gt;integer(&apos;video_bitrate&apos;)-&gt;nullable();
            $table-&gt;integer(&apos;framerate&apos;)-&gt;nullable();
            $table-&gt;jsonb(&apos;probe&apos;)-&gt;nullable();
            $table-&gt;timestampsTz();
        });
    }
    /**
     * Reverse the migrations.
     */
    public function down(): void
    {
        Schema::dropIfExists(&apos;videos&apos;);
    }
};</file><file path="database/migrations/2025_06_07_186232_create_movie_video_table.php">&lt;?php
use Illuminate\Database\Migrations\Migration;
use Tpetry\PostgresqlEnhanced\Schema\Blueprint;
use Tpetry\PostgresqlEnhanced\Support\Facades\Schema;
return new class extends Migration
{
    /**
     * Run the migrations.
     */
    public function up(): void
    {
        Schema::create(&apos;movie_video&apos;, function (Blueprint $table) {
            $table-&gt;id();
            $table-&gt;foreignId(&apos;movie_id&apos;)
                -&gt;references(&apos;id&apos;)
                -&gt;on(&apos;movies&apos;)
                -&gt;cascadeOnDelete();
            $table-&gt;foreignId(&apos;video_id&apos;)
                -&gt;references(&apos;id&apos;)
                -&gt;on(&apos;videos&apos;)
                -&gt;cascadeOnDelete();
            $table-&gt;integer(&apos;order&apos;)-&gt;default(0);
            $table-&gt;index(&apos;movie_id&apos;, &apos;idx_movie_id&apos;);
        });
    }
    /**
     * Reverse the migrations.
     */
    public function down(): void
    {
        Schema::dropIfExists(&apos;movie_video&apos;);
    }
};</file><file path="database/migrations/2025_06_08_102241_add_mbid_discogs_ids.php">&lt;?php
use Illuminate\Database\Migrations\Migration;
use Tpetry\PostgresqlEnhanced\Schema\Blueprint;
use Tpetry\PostgresqlEnhanced\Support\Facades\Schema;
return new class extends Migration
{
    /**
     * Run the migrations.
     */
    public function up(): void
    {
        Schema::table(&apos;artists&apos;, function (Blueprint $table) {
           $table-&gt;bigInteger(&apos;discogs_id&apos;)-&gt;nullable();
           $table-&gt;uuid(&apos;mbid&apos;)-&gt;nullable();
        });
        Schema::table(&apos;albums&apos;, function (Blueprint $table) {
            $table-&gt;bigInteger(&apos;discogs_id&apos;)-&gt;nullable();
            $table-&gt;uuid(&apos;mbid&apos;)-&gt;nullable();
        });
    }
    /**
     * Reverse the migrations.
     */
    public function down(): void
    {
        Schema::table(&apos;artists&apos;, function (Blueprint $table) {
            $table-&gt;dropColumn([&apos;discogs_id&apos;, &apos;mbid&apos;]);
        });
        Schema::table(&apos;albums&apos;, function (Blueprint $table) {
            $table-&gt;dropColumn([&apos;discogs_id&apos;, &apos;mbid&apos;]);
        });
    }
};</file><file path="database/seeders/AclSeed.php">&lt;?php
namespace Database\Seeders;
use App\Auth\AclFactory;
use App\Auth\Role as RoleEnum;
use Illuminate\Database\Seeder;
use Spatie\Permission\Models\Permission;
use Spatie\Permission\Models\Role;
class AclSeed extends Seeder
{
    /**
     * Run the database seeds.
     */
    public function run(): void
    {
        // Reset permission cache
        app()[\Spatie\Permission\PermissionRegistrar::class]-&gt;forgetCachedPermissions();
        AclFactory::createPermissionsFor(&apos;albums&apos;);
        AclFactory::createPermissionsFor(&apos;libraries&apos;);
        AclFactory::createPermissionsFor(&apos;users&apos;);
        AclFactory::createPermission(&apos;user&apos;, &apos;viewLimited&apos;);
        AclFactory::createPermission(&apos;libraries&apos;, &apos;edit-metadata&apos;);
        AclFactory::createPermission(&apos;albums&apos;, &apos;edit-metadata&apos;);
        AclFactory::createPermission(&apos;artists&apos;, &apos;edit-metadata&apos;);
        AclFactory::createPermission(&apos;genre&apos;, &apos;edit-metadata&apos;);
        AclFactory::createPermission(&apos;songs&apos;, &apos;edit-metadata&apos;);
        $admin = Role::create([&apos;name&apos; =&gt; RoleEnum::Admin-&gt;value]);
        $admin-&gt;givePermissionTo(Permission::all());
        $sep = AclFactory::SEPARATOR;
        $user = Role::create([&apos;name&apos; =&gt; RoleEnum::User-&gt;value]);
        $user-&gt;givePermissionTo([
            &apos;user&apos; . $sep . &apos;viewLimited&apos;,
        ]);
    }
}</file><file path="Discogs.postman_collection-v2.1.json">{
	&quot;info&quot;: {
		&quot;_postman_id&quot;: &quot;7d9408a6-a04b-49aa-94b0-bfe85218b9d7&quot;,
		&quot;name&quot;: &quot;Discogs&quot;,
		&quot;schema&quot;: &quot;https://schema.getpostman.com/json/collection/v2.1.0/collection.json&quot;
	},
	&quot;item&quot;: [
		{
			&quot;name&quot;: &quot;Authentication&quot;,
			&quot;item&quot;: [
				{
					&quot;name&quot;: &quot;Request Token&quot;,
					&quot;event&quot;: [
						{
							&quot;listen&quot;: &quot;test&quot;,
							&quot;script&quot;: {
								&quot;id&quot;: &quot;5e6c9eeb-a6e7-4edc-9e15-ef801f3c5cbf&quot;,
								&quot;exec&quot;: [
									&quot;var querystring = require(&apos;querystring&apos;)&quot;,
									&quot;&quot;,
									&quot;pm.test(\&quot;oauth_token and oauth_token_secret are set as enviroment variables\&quot;, function () {&quot;,
									&quot;    var data = querystring.parse(pm.response.text());&quot;,
									&quot;    pm.environment.set(\&quot;oauth_token\&quot;, data.oauth_token);&quot;,
									&quot;    pm.environment.set(\&quot;oauth_token_secret\&quot;, data.oauth_token_secret);&quot;,
									&quot;});&quot;,
									&quot;&quot;,
									&quot;pm.test(\&quot;To get the oauth_verifier open this url in your browser https://discogs.com/oauth/authorize?oauth_token=\&quot; + pm.environment.get(\&quot;oauth_token\&quot;))&quot;
								],
								&quot;type&quot;: &quot;text/javascript&quot;
							}
						}
					],
					&quot;request&quot;: {
						&quot;auth&quot;: {
							&quot;type&quot;: &quot;noauth&quot;
						},
						&quot;method&quot;: &quot;GET&quot;,
						&quot;header&quot;: [
							{
								&quot;warning&quot;: &quot;This is a duplicate header and will be overridden by the Authorization header generated by Postman.&quot;,
								&quot;key&quot;: &quot;Authorization&quot;,
								&quot;value&quot;: &quot;OAuth oauth_consumer_key=\&quot;{{consumer_key}}\&quot;,oauth_signature_method=\&quot;PLAINTEXT\&quot;,oauth_timestamp=\&quot;{{$timestamp}}\&quot;,oauth_nonce=\&quot;{{$guid}}\&quot;,oauth_version=\&quot;1.0\&quot;,oauth_signature=\&quot;{{consumer_secret}}&amp;\&quot;, oauth_callback=\&quot;your_callback\&quot;&quot;,
								&quot;type&quot;: &quot;text&quot;
							},
							{
								&quot;key&quot;: &quot;Content-Type&quot;,
								&quot;value&quot;: &quot;application/x-www-form-urlencoded&quot;,
								&quot;type&quot;: &quot;text&quot;
							},
							{
								&quot;key&quot;: &quot;User-Agent&quot;,
								&quot;value&quot;: &quot;{{user_agent}}&quot;,
								&quot;type&quot;: &quot;text&quot;
							}
						],
						&quot;url&quot;: {
							&quot;raw&quot;: &quot;{{url}}/oauth/request_token&quot;,
							&quot;host&quot;: [
								&quot;{{url}}&quot;
							],
							&quot;path&quot;: [
								&quot;oauth&quot;,
								&quot;request_token&quot;
							]
						},
						&quot;description&quot;: &quot;Generate the request token.\n\n[https://www.discogs.com/developers/#page:authentication,header:authentication-request-token-url](https://www.discogs.com/developers/#page:authentication,header:authentication-request-token-url)&quot;
					},
					&quot;response&quot;: []
				},
				{
					&quot;name&quot;: &quot;Access Token&quot;,
					&quot;event&quot;: [
						{
							&quot;listen&quot;: &quot;test&quot;,
							&quot;script&quot;: {
								&quot;id&quot;: &quot;5e6c9eeb-a6e7-4edc-9e15-ef801f3c5cbf&quot;,
								&quot;exec&quot;: [
									&quot;var querystring = require(&apos;querystring&apos;)&quot;,
									&quot;&quot;,
									&quot;pm.test(\&quot;oauth_token and oauth_token_secret are set as enviroment variables\&quot;, function () {&quot;,
									&quot;    var data = querystring.parse(pm.response.text());&quot;,
									&quot;    pm.environment.set(\&quot;oauth_token\&quot;, data.oauth_token);&quot;,
									&quot;    pm.environment.set(\&quot;oauth_token_secret\&quot;, data.oauth_token_secret);&quot;,
									&quot;});&quot;
								],
								&quot;type&quot;: &quot;text/javascript&quot;
							}
						}
					],
					&quot;request&quot;: {
						&quot;auth&quot;: {
							&quot;type&quot;: &quot;noauth&quot;
						},
						&quot;method&quot;: &quot;POST&quot;,
						&quot;header&quot;: [
							{
								&quot;warning&quot;: &quot;This is a duplicate header and will be overridden by the Authorization header generated by Postman.&quot;,
								&quot;key&quot;: &quot;Authorization&quot;,
								&quot;value&quot;: &quot;OAuth oauth_consumer_key=\&quot;{{consumer_key}}\&quot;, oauth_nonce=\&quot;{{$guid}}\&quot;, oauth_token=\&quot;{{oauth_token}}\&quot;, oauth_signature=\&quot;{{consumer_secret}}&amp;{{oauth_token_secret}}\&quot;, oauth_signature_method=\&quot;PLAINTEXT\&quot;, oauth_timestamp=\&quot;{{$timestamp}}\&quot;, oauth_verifier=\&quot;{{oauth_verifier}}\&quot;&quot;,
								&quot;type&quot;: &quot;text&quot;
							},
							{
								&quot;key&quot;: &quot;Content-Type&quot;,
								&quot;value&quot;: &quot;application/x-www-form-urlencoded&quot;,
								&quot;type&quot;: &quot;text&quot;
							},
							{
								&quot;key&quot;: &quot;User-Agent&quot;,
								&quot;value&quot;: &quot;{{user_agent}}&quot;,
								&quot;type&quot;: &quot;text&quot;
							}
						],
						&quot;body&quot;: {
							&quot;mode&quot;: &quot;raw&quot;,
							&quot;raw&quot;: &quot;&quot;
						},
						&quot;url&quot;: {
							&quot;raw&quot;: &quot;{{url}}/oauth/access_token&quot;,
							&quot;host&quot;: [
								&quot;{{url}}&quot;
							],
							&quot;path&quot;: [
								&quot;oauth&quot;,
								&quot;access_token&quot;
							]
						},
						&quot;description&quot;: &quot;Generate the access token.\n\n[https://www.discogs.com/developers/#page:authentication,header:authentication-access-token-url](https://www.discogs.com/developers/#page:authentication,header:authentication-access-token-url)&quot;
					},
					&quot;response&quot;: []
				}
			],
			&quot;description&quot;: &quot;Visit [https://www.discogs.com/developers/#page:authentication](https://www.discogs.com/developers/#page:authentication) for full documentation.&quot;,
			&quot;event&quot;: [
				{
					&quot;listen&quot;: &quot;prerequest&quot;,
					&quot;script&quot;: {
						&quot;id&quot;: &quot;6c3c9cc4-cdc1-4355-8b48-a37663f1ab74&quot;,
						&quot;type&quot;: &quot;text/javascript&quot;,
						&quot;exec&quot;: [
							&quot;&quot;
						]
					}
				},
				{
					&quot;listen&quot;: &quot;test&quot;,
					&quot;script&quot;: {
						&quot;id&quot;: &quot;719b1629-28b7-48bf-a7be-650de3bea15c&quot;,
						&quot;type&quot;: &quot;text/javascript&quot;,
						&quot;exec&quot;: [
							&quot;&quot;
						]
					}
				}
			],
			&quot;protocolProfileBehavior&quot;: {}
		},
		{
			&quot;name&quot;: &quot;Database&quot;,
			&quot;item&quot;: [
				{
					&quot;name&quot;: &quot;Releases&quot;,
					&quot;request&quot;: {
						&quot;method&quot;: &quot;GET&quot;,
						&quot;header&quot;: [
							{
								&quot;key&quot;: &quot;Content-Type&quot;,
								&quot;name&quot;: &quot;Content-Type&quot;,
								&quot;value&quot;: &quot;application/x-www-form-urlencoded&quot;,
								&quot;type&quot;: &quot;text&quot;
							},
							{
								&quot;key&quot;: &quot;User-Agent&quot;,
								&quot;value&quot;: &quot;{{user_agent}}&quot;,
								&quot;type&quot;: &quot;text&quot;
							}
						],
						&quot;url&quot;: {
							&quot;raw&quot;: &quot;{{url}}/releases/{release_id}?{curr_abbr}&quot;,
							&quot;host&quot;: [
								&quot;{{url}}&quot;
							],
							&quot;path&quot;: [
								&quot;releases&quot;,
								&quot;{release_id}&quot;
							],
							&quot;query&quot;: [
								{
									&quot;key&quot;: &quot;{curr_abbr}&quot;,
									&quot;value&quot;: null
								}
							]
						},
						&quot;description&quot;: &quot;The Release resource represents a particular physical or digital object released by one or more Artists.\n\n[https://www.discogs.com/developers/#page:database,header:database-release](https://www.discogs.com/developers/#page:database,header:database-release)&quot;
					},
					&quot;response&quot;: []
				},
				{
					&quot;name&quot;: &quot;Release rating by user&quot;,
					&quot;request&quot;: {
						&quot;method&quot;: &quot;GET&quot;,
						&quot;header&quot;: [
							{
								&quot;key&quot;: &quot;Content-Type&quot;,
								&quot;value&quot;: &quot;application/x-www-form-urlencoded&quot;,
								&quot;type&quot;: &quot;text&quot;
							},
							{
								&quot;key&quot;: &quot;User-Agent&quot;,
								&quot;value&quot;: &quot;{{user_agent}}&quot;,
								&quot;type&quot;: &quot;text&quot;
							}
						],
						&quot;url&quot;: {
							&quot;raw&quot;: &quot;{{url}}/releases/{release_id}/rating/{username}&quot;,
							&quot;host&quot;: [
								&quot;{{url}}&quot;
							],
							&quot;path&quot;: [
								&quot;releases&quot;,
								&quot;{release_id}&quot;,
								&quot;rating&quot;,
								&quot;{username}&quot;
							]
						},
						&quot;description&quot;: &quot;Retrieves the release’s rating for a given user.\n\n[https://www.discogs.com/developers/#page:database,header:database-release-rating-by-user](https://www.discogs.com/developers/#page:database,header:database-release-rating-by-user)&quot;
					},
					&quot;response&quot;: []
				},
				{
					&quot;name&quot;: &quot;Release rating by user&quot;,
					&quot;request&quot;: {
						&quot;method&quot;: &quot;PUT&quot;,
						&quot;header&quot;: [
							{
								&quot;key&quot;: &quot;Content-Type&quot;,
								&quot;name&quot;: &quot;Content-Type&quot;,
								&quot;value&quot;: &quot;application/json&quot;,
								&quot;type&quot;: &quot;text&quot;
							},
							{
								&quot;key&quot;: &quot;User-Agent&quot;,
								&quot;type&quot;: &quot;text&quot;,
								&quot;value&quot;: &quot;{{user_agent}}&quot;
							}
						],
						&quot;body&quot;: {
							&quot;mode&quot;: &quot;raw&quot;,
							&quot;raw&quot;: &quot;&quot;
						},
						&quot;url&quot;: {
							&quot;raw&quot;: &quot;{{url}}/releases/{release_id}/rating/{{username}}&quot;,
							&quot;host&quot;: [
								&quot;{{url}}&quot;
							],
							&quot;path&quot;: [
								&quot;releases&quot;,
								&quot;{release_id}&quot;,
								&quot;rating&quot;,
								&quot;{{username}}&quot;
							]
						},
						&quot;description&quot;: &quot;Updates the release’s rating for a given user. Authentication as the user is required. \n\nThe \&quot;rating\&quot; parameter must be sent inside a JSON object inside the request body.\n\n[https://www.discogs.com/developers/#page:database,header:database-release-rating-by-user](https://www.discogs.com/developers/#page:database,header:database-release-rating-by-user)&quot;
					},
					&quot;response&quot;: []
				},
				{
					&quot;name&quot;: &quot;Release rating by user&quot;,
					&quot;request&quot;: {
						&quot;method&quot;: &quot;DELETE&quot;,
						&quot;header&quot;: [
							{
								&quot;key&quot;: &quot;Content-Type&quot;,
								&quot;value&quot;: &quot;application/x-www-form-urlencoded&quot;,
								&quot;type&quot;: &quot;text&quot;
							},
							{
								&quot;key&quot;: &quot;User-Agent&quot;,
								&quot;value&quot;: &quot;{{user_agent}}&quot;,
								&quot;type&quot;: &quot;text&quot;
							}
						],
						&quot;body&quot;: {
							&quot;mode&quot;: &quot;raw&quot;,
							&quot;raw&quot;: &quot;&quot;
						},
						&quot;url&quot;: {
							&quot;raw&quot;: &quot;{{url}}/releases/{release_id}/rating/{{username}}&quot;,
							&quot;host&quot;: [
								&quot;{{url}}&quot;
							],
							&quot;path&quot;: [
								&quot;releases&quot;,
								&quot;{release_id}&quot;,
								&quot;rating&quot;,
								&quot;{{username}}&quot;
							]
						},
						&quot;description&quot;: &quot;Deletes the release’s rating for a given user. Authentication as the user is required.\n\n[https://www.discogs.com/developers/#page:database,header:database-release-rating-by-user](https://www.discogs.com/developers/#page:database,header:database-release-rating-by-user)&quot;
					},
					&quot;response&quot;: []
				},
				{
					&quot;name&quot;: &quot;Community release rating&quot;,
					&quot;request&quot;: {
						&quot;method&quot;: &quot;GET&quot;,
						&quot;header&quot;: [
							{
								&quot;key&quot;: &quot;Content-Type&quot;,
								&quot;name&quot;: &quot;Content-Type&quot;,
								&quot;type&quot;: &quot;text&quot;,
								&quot;value&quot;: &quot;application/x-www-form-urlencoded&quot;
							},
							{
								&quot;key&quot;: &quot;User-Agent&quot;,
								&quot;type&quot;: &quot;text&quot;,
								&quot;value&quot;: &quot;{{user_agent}}&quot;
							}
						],
						&quot;url&quot;: {
							&quot;raw&quot;: &quot;{{url}}/releases/{release_id}/rating&quot;,
							&quot;host&quot;: [
								&quot;{{url}}&quot;
							],
							&quot;path&quot;: [
								&quot;releases&quot;,
								&quot;{release_id}&quot;,
								&quot;rating&quot;
							]
						},
						&quot;description&quot;: &quot;The Community Release Rating endpoint retrieves the average rating and the total number of user ratings for a given release.\n\n[https://www.discogs.com/developers/#page:database,header:database-community-release-rating](https://www.discogs.com/developers/#page:database,header:database-community-release-rating)&quot;
					},
					&quot;response&quot;: []
				},
				{
					&quot;name&quot;: &quot;Master release&quot;,
					&quot;request&quot;: {
						&quot;method&quot;: &quot;GET&quot;,
						&quot;header&quot;: [
							{
								&quot;key&quot;: &quot;Content-Type&quot;,
								&quot;name&quot;: &quot;Content-Type&quot;,
								&quot;type&quot;: &quot;text&quot;,
								&quot;value&quot;: &quot;application/x-www-form-urlencoded&quot;
							},
							{
								&quot;key&quot;: &quot;User-Agent&quot;,
								&quot;type&quot;: &quot;text&quot;,
								&quot;value&quot;: &quot;{{user_agent}}&quot;
							}
						],
						&quot;url&quot;: {
							&quot;raw&quot;: &quot;{{url}}/masters/{master_id}&quot;,
							&quot;host&quot;: [
								&quot;{{url}}&quot;
							],
							&quot;path&quot;: [
								&quot;masters&quot;,
								&quot;{master_id}&quot;
							]
						},
						&quot;description&quot;: &quot;The Master resource represents a set of similar Releases. Masters (also known as “master releases”) have a “main release” which is often the chronologically earliest.\n\n[https://www.discogs.com/developers/#page:database,header:database-master-release](https://www.discogs.com/developers/#page:database,header:database-master-release)&quot;
					},
					&quot;response&quot;: []
				},
				{
					&quot;name&quot;: &quot;Master release versions&quot;,
					&quot;request&quot;: {
						&quot;method&quot;: &quot;GET&quot;,
						&quot;header&quot;: [
							{
								&quot;key&quot;: &quot;Content-Type&quot;,
								&quot;name&quot;: &quot;Content-Type&quot;,
								&quot;type&quot;: &quot;text&quot;,
								&quot;value&quot;: &quot;application/x-www-form-urlencoded&quot;
							},
							{
								&quot;key&quot;: &quot;User-Agent&quot;,
								&quot;type&quot;: &quot;text&quot;,
								&quot;value&quot;: &quot;{{user_agent}}&quot;
							}
						],
						&quot;url&quot;: {
							&quot;raw&quot;: &quot;{{url}}/masters/{master_id}/versions?page={page}&amp;per_page={per_page}&quot;,
							&quot;host&quot;: [
								&quot;{{url}}&quot;
							],
							&quot;path&quot;: [
								&quot;masters&quot;,
								&quot;{master_id}&quot;,
								&quot;versions&quot;
							],
							&quot;query&quot;: [
								{
									&quot;key&quot;: &quot;page&quot;,
									&quot;value&quot;: &quot;{page}&quot;
								},
								{
									&quot;key&quot;: &quot;per_page&quot;,
									&quot;value&quot;: &quot;{per_page}&quot;
								}
							]
						},
						&quot;description&quot;: &quot;Retrieves a list of all Releases that are versions of this master. Accepts Pagination parameters.\n\n[https://www.discogs.com/developers/#page:database,header:database-master-release-versions](https://www.discogs.com/developers/#page:database,header:database-master-release-versions)&quot;
					},
					&quot;response&quot;: []
				},
				{
					&quot;name&quot;: &quot;Artist&quot;,
					&quot;request&quot;: {
						&quot;method&quot;: &quot;GET&quot;,
						&quot;header&quot;: [
							{
								&quot;key&quot;: &quot;Content-Type&quot;,
								&quot;name&quot;: &quot;Content-Type&quot;,
								&quot;type&quot;: &quot;text&quot;,
								&quot;value&quot;: &quot;application/x-www-form-urlencoded&quot;
							},
							{
								&quot;key&quot;: &quot;User-Agent&quot;,
								&quot;type&quot;: &quot;text&quot;,
								&quot;value&quot;: &quot;{{user_agent}}&quot;
							}
						],
						&quot;url&quot;: {
							&quot;raw&quot;: &quot;{{url}}/artists/{artist_id}&quot;,
							&quot;host&quot;: [
								&quot;{{url}}&quot;
							],
							&quot;path&quot;: [
								&quot;artists&quot;,
								&quot;{artist_id}&quot;
							]
						},
						&quot;description&quot;: &quot;Get an artist\n\n[https://www.discogs.com/developers/#page:database,header:database-artist](https://www.discogs.com/developers/#page:database,header:database-artist)&quot;
					},
					&quot;response&quot;: []
				},
				{
					&quot;name&quot;: &quot;Artist releases&quot;,
					&quot;request&quot;: {
						&quot;method&quot;: &quot;GET&quot;,
						&quot;header&quot;: [
							{
								&quot;key&quot;: &quot;Content-Type&quot;,
								&quot;name&quot;: &quot;Content-Type&quot;,
								&quot;type&quot;: &quot;text&quot;,
								&quot;value&quot;: &quot;application/x-www-form-urlencoded&quot;
							},
							{
								&quot;key&quot;: &quot;User-Agent&quot;,
								&quot;type&quot;: &quot;text&quot;,
								&quot;value&quot;: &quot;{{user_agent}}&quot;
							}
						],
						&quot;url&quot;: {
							&quot;raw&quot;: &quot;{{url}}/artists/{artist_id}/releases?sort={sort}&amp;sort_order={sort_order}&quot;,
							&quot;host&quot;: [
								&quot;{{url}}&quot;
							],
							&quot;path&quot;: [
								&quot;artists&quot;,
								&quot;{artist_id}&quot;,
								&quot;releases&quot;
							],
							&quot;query&quot;: [
								{
									&quot;key&quot;: &quot;sort&quot;,
									&quot;value&quot;: &quot;{sort}&quot;
								},
								{
									&quot;key&quot;: &quot;sort_order&quot;,
									&quot;value&quot;: &quot;{sort_order}&quot;
								}
							]
						},
						&quot;description&quot;: &quot;Returns a list of Releases and Masters associated with the Artist. Accepts Pagination.\n\n[https://www.discogs.com/developers/#page:database,header:database-artist-releases](https://www.discogs.com/developers/#page:database,header:database-artist-releases)&quot;
					},
					&quot;response&quot;: []
				},
				{
					&quot;name&quot;: &quot;Label&quot;,
					&quot;request&quot;: {
						&quot;method&quot;: &quot;GET&quot;,
						&quot;header&quot;: [
							{
								&quot;key&quot;: &quot;Content-Type&quot;,
								&quot;name&quot;: &quot;Content-Type&quot;,
								&quot;type&quot;: &quot;text&quot;,
								&quot;value&quot;: &quot;application/x-www-form-urlencoded&quot;
							},
							{
								&quot;key&quot;: &quot;User-Agent&quot;,
								&quot;type&quot;: &quot;text&quot;,
								&quot;value&quot;: &quot;{{user_agent}}&quot;
							}
						],
						&quot;url&quot;: {
							&quot;raw&quot;: &quot;{{url}}/labels/{label_id}&quot;,
							&quot;host&quot;: [
								&quot;{{url}}&quot;
							],
							&quot;path&quot;: [
								&quot;labels&quot;,
								&quot;{label_id}&quot;
							]
						},
						&quot;description&quot;: &quot;Get a label\n\n[https://www.discogs.com/developers/#page:database,header:database-label](https://www.discogs.com/developers/#page:database,header:database-label)&quot;
					},
					&quot;response&quot;: []
				},
				{
					&quot;name&quot;: &quot;All label releases&quot;,
					&quot;request&quot;: {
						&quot;method&quot;: &quot;GET&quot;,
						&quot;header&quot;: [
							{
								&quot;key&quot;: &quot;Content-Type&quot;,
								&quot;name&quot;: &quot;Content-Type&quot;,
								&quot;type&quot;: &quot;text&quot;,
								&quot;value&quot;: &quot;application/x-www-form-urlencoded&quot;
							},
							{
								&quot;key&quot;: &quot;User-Agent&quot;,
								&quot;type&quot;: &quot;text&quot;,
								&quot;value&quot;: &quot;{{user_agent}}&quot;
							}
						],
						&quot;url&quot;: {
							&quot;raw&quot;: &quot;{{url}}/labels/{label_id}/releases?page={page}&amp;per_page={per_page}&quot;,
							&quot;host&quot;: [
								&quot;{{url}}&quot;
							],
							&quot;path&quot;: [
								&quot;labels&quot;,
								&quot;{label_id}&quot;,
								&quot;releases&quot;
							],
							&quot;query&quot;: [
								{
									&quot;key&quot;: &quot;page&quot;,
									&quot;value&quot;: &quot;{page}&quot;
								},
								{
									&quot;key&quot;: &quot;per_page&quot;,
									&quot;value&quot;: &quot;{per_page}&quot;
								}
							]
						},
						&quot;description&quot;: &quot;Returns a list of Releases associated with the label. Accepts Pagination parameters.\n\n[https://www.discogs.com/developers/#page:database,header:database-all-label-releases](https://www.discogs.com/developers/#page:database,header:database-all-label-releases)&quot;
					},
					&quot;response&quot;: []
				},
				{
					&quot;name&quot;: &quot;Search&quot;,
					&quot;request&quot;: {
						&quot;method&quot;: &quot;GET&quot;,
						&quot;header&quot;: [
							{
								&quot;key&quot;: &quot;Content-Type&quot;,
								&quot;name&quot;: &quot;Content-Type&quot;,
								&quot;type&quot;: &quot;text&quot;,
								&quot;value&quot;: &quot;application/x-www-form-urlencoded&quot;
							},
							{
								&quot;key&quot;: &quot;User-Agent&quot;,
								&quot;type&quot;: &quot;text&quot;,
								&quot;value&quot;: &quot;{{user_agent}}&quot;
							}
						],
						&quot;url&quot;: {
							&quot;raw&quot;: &quot;{{url}}/database/search?query={page}&amp;type={type}&quot;,
							&quot;host&quot;: [
								&quot;{{url}}&quot;
							],
							&quot;path&quot;: [
								&quot;database&quot;,
								&quot;search&quot;
							],
							&quot;query&quot;: [
								{
									&quot;key&quot;: &quot;query&quot;,
									&quot;value&quot;: &quot;{page}&quot;
								},
								{
									&quot;key&quot;: &quot;type&quot;,
									&quot;value&quot;: &quot;{type}&quot;
								}
							]
						},
						&quot;description&quot;: &quot;Issue a search query to our database. This endpoint accepts pagination parameters. Authentication (as any user) is required.\n\n[https://www.discogs.com/developers/#page:database,header:database-search](https://www.discogs.com/developers/#page:database,header:database-search)&quot;
					},
					&quot;response&quot;: []
				}
			],
			&quot;description&quot;: &quot;Visit [https://www.discogs.com/developers/#page:database](https://www.discogs.com/developers/#page:database) for full documentation.&quot;,
			&quot;event&quot;: [
				{
					&quot;listen&quot;: &quot;prerequest&quot;,
					&quot;script&quot;: {
						&quot;id&quot;: &quot;af7ce01b-7da1-4935-86c3-1cc7940883c0&quot;,
						&quot;type&quot;: &quot;text/javascript&quot;,
						&quot;exec&quot;: [
							&quot;&quot;
						]
					}
				},
				{
					&quot;listen&quot;: &quot;test&quot;,
					&quot;script&quot;: {
						&quot;id&quot;: &quot;a58e171e-e71c-4c65-b870-e69f90750af5&quot;,
						&quot;type&quot;: &quot;text/javascript&quot;,
						&quot;exec&quot;: [
							&quot;&quot;
						]
					}
				}
			],
			&quot;protocolProfileBehavior&quot;: {}
		},
		{
			&quot;name&quot;: &quot;Marketplace&quot;,
			&quot;item&quot;: [
				{
					&quot;name&quot;: &quot;Inventory&quot;,
					&quot;request&quot;: {
						&quot;method&quot;: &quot;GET&quot;,
						&quot;header&quot;: [
							{
								&quot;key&quot;: &quot;Content-Type&quot;,
								&quot;name&quot;: &quot;Content-Type&quot;,
								&quot;type&quot;: &quot;text&quot;,
								&quot;value&quot;: &quot;application/x-www-form-urlencoded&quot;
							},
							{
								&quot;key&quot;: &quot;User-Agent&quot;,
								&quot;type&quot;: &quot;text&quot;,
								&quot;value&quot;: &quot;{{user_agent}}&quot;
							}
						],
						&quot;url&quot;: {
							&quot;raw&quot;: &quot;{{url}}/users/{{username}}/inventory?string={status}&amp;sort={sort}&amp;sort_order={sort_order}&quot;,
							&quot;host&quot;: [
								&quot;{{url}}&quot;
							],
							&quot;path&quot;: [
								&quot;users&quot;,
								&quot;{{username}}&quot;,
								&quot;inventory&quot;
							],
							&quot;query&quot;: [
								{
									&quot;key&quot;: &quot;string&quot;,
									&quot;value&quot;: &quot;{status}&quot;
								},
								{
									&quot;key&quot;: &quot;sort&quot;,
									&quot;value&quot;: &quot;{sort}&quot;
								},
								{
									&quot;key&quot;: &quot;sort_order&quot;,
									&quot;value&quot;: &quot;{sort_order}&quot;
								}
							]
						},
						&quot;description&quot;: &quot;Returns the list of listings in a user’s inventory. Accepts Pagination parameters.\nBasic information about each listing and the corresponding release is provided, suitable for display in a list. For detailed information about the release, make another API call to fetch the corresponding Release.\n\nIf you are not authenticated as the inventory owner, only items that have a status of For Sale will be visible.\nIf you are authenticated as the inventory owner you will get additional weight, format_quantity, external_id, and location keys.\nIf the user is authorized, the listing will contain a in_cart boolean field indicating whether or not this listing is in their cart.\n\n[https://www.discogs.com/developers/#page:marketplace,header:marketplace-inventory](https://www.discogs.com/developers/#page:marketplace,header:marketplace-inventory)&quot;
					},
					&quot;response&quot;: []
				},
				{
					&quot;name&quot;: &quot;Listing&quot;,
					&quot;request&quot;: {
						&quot;method&quot;: &quot;GET&quot;,
						&quot;header&quot;: [
							{
								&quot;key&quot;: &quot;Content-Type&quot;,
								&quot;name&quot;: &quot;Content-Type&quot;,
								&quot;type&quot;: &quot;text&quot;,
								&quot;value&quot;: &quot;application/x-www-form-urlencoded&quot;
							},
							{
								&quot;key&quot;: &quot;User-Agent&quot;,
								&quot;type&quot;: &quot;text&quot;,
								&quot;value&quot;: &quot;{{user_agent}}&quot;
							}
						],
						&quot;url&quot;: {
							&quot;raw&quot;: &quot;{{url}}/marketplace/listings/{listing_id}?curr_abbr={curr_abbr}&quot;,
							&quot;host&quot;: [
								&quot;{{url}}&quot;
							],
							&quot;path&quot;: [
								&quot;marketplace&quot;,
								&quot;listings&quot;,
								&quot;{listing_id}&quot;
							],
							&quot;query&quot;: [
								{
									&quot;key&quot;: &quot;curr_abbr&quot;,
									&quot;value&quot;: &quot;{curr_abbr}&quot;
								}
							]
						},
						&quot;description&quot;: &quot;View the data associated with a listing.\nIf the authorized user is the listing owner the listing will include the weight, format_quantity, external_id, and location keys. If the user is authorized, the listing will contain a in_cart boolean field indicating whether or not this listing is in their cart.\n\n[https://www.discogs.com/developers/#page:marketplace,header:marketplace-listing](https://www.discogs.com/developers/#page:marketplace,header:marketplace-listing)&quot;
					},
					&quot;response&quot;: []
				},
				{
					&quot;name&quot;: &quot;Listing&quot;,
					&quot;request&quot;: {
						&quot;method&quot;: &quot;POST&quot;,
						&quot;header&quot;: [
							{
								&quot;key&quot;: &quot;Content-Type&quot;,
								&quot;name&quot;: &quot;Content-Type&quot;,
								&quot;type&quot;: &quot;text&quot;,
								&quot;value&quot;: &quot;application/x-www-form-urlencoded&quot;
							},
							{
								&quot;key&quot;: &quot;User-Agent&quot;,
								&quot;type&quot;: &quot;text&quot;,
								&quot;value&quot;: &quot;{{user_agent}}&quot;
							}
						],
						&quot;url&quot;: {
							&quot;raw&quot;: &quot;{{url}}/marketplace/listings/{listing_id}?release_id={release_id}&amp;condition={condition}&amp;sleeve_condition={sleeve_condition}&amp;price={price}&amp;comments={comments}&amp;allow_offers={allow_offers}&amp;status={status}&amp;external_id={external_id}&amp;location={location}&amp;weight={weight}&amp;format_quantity={format_quantity}&quot;,
							&quot;host&quot;: [
								&quot;{{url}}&quot;
							],
							&quot;path&quot;: [
								&quot;marketplace&quot;,
								&quot;listings&quot;,
								&quot;{listing_id}&quot;
							],
							&quot;query&quot;: [
								{
									&quot;key&quot;: &quot;release_id&quot;,
									&quot;value&quot;: &quot;{release_id}&quot;,
									&quot;description&quot;: &quot;The ID of the listing you are fetching\n&quot;
								},
								{
									&quot;key&quot;: &quot;condition&quot;,
									&quot;value&quot;: &quot;{condition}&quot;,
									&quot;description&quot;: &quot;The condition of the release you are posting. Must be one of the following: \n• Mint (M)\n• Near Mint (NM or M-)\n• Very Good Plus (VG+)\n• Very Good (VG)\n• Good Plus (G+)\n• Good (G)\n• Fair (F)\n• Poor (P)&quot;
								},
								{
									&quot;key&quot;: &quot;sleeve_condition&quot;,
									&quot;value&quot;: &quot;{sleeve_condition}&quot;,
									&quot;description&quot;: &quot;The condition of the sleeve of the item you are posting. Must be one of the following: \n• Mint (M)\n• Near Mint (NM or M-)\n• Very Good Plus (VG+)\n• Very Good (VG)\n• Good Plus (G+)\n• Good (G)\n• Fair (F)\n• Poor (P)\n• Generic Not Graded No Cover&quot;
								},
								{
									&quot;key&quot;: &quot;price&quot;,
									&quot;value&quot;: &quot;{price}&quot;,
									&quot;description&quot;: &quot;The price of the item (in the seller’s currency).&quot;
								},
								{
									&quot;key&quot;: &quot;comments&quot;,
									&quot;value&quot;: &quot;{comments}&quot;,
									&quot;description&quot;: &quot;Any remarks about the item that will be displayed to buyers.&quot;
								},
								{
									&quot;key&quot;: &quot;allow_offers&quot;,
									&quot;value&quot;: &quot;{allow_offers}&quot;,
									&quot;description&quot;: &quot;Whether or not to allow buyers to make offers on the item. Defaults to false.&quot;
								},
								{
									&quot;key&quot;: &quot;status&quot;,
									&quot;value&quot;: &quot;{status}&quot;,
									&quot;description&quot;: &quot;The status of the listing. Defaults to For Sale. Options are For Sale (the listing is ready to be shown on the Marketplace) and Draft (the listing is not ready for public display).&quot;
								},
								{
									&quot;key&quot;: &quot;external_id&quot;,
									&quot;value&quot;: &quot;{external_id}&quot;,
									&quot;description&quot;: &quot;A freeform field that can be used for the seller’s own reference. Information stored here will not be displayed to anyone other than the seller. This field is called “Private Comments” on the Discogs website.&quot;
								},
								{
									&quot;key&quot;: &quot;location&quot;,
									&quot;value&quot;: &quot;{location}&quot;,
									&quot;description&quot;: &quot;A freeform field that is intended to help identify an item’s physical storage location. Information stored here will not be displayed to anyone other than the seller. This field will be visible on the inventory management page and will be available in inventory exports via the website.&quot;
								},
								{
									&quot;key&quot;: &quot;weight&quot;,
									&quot;value&quot;: &quot;{weight}&quot;,
									&quot;description&quot;: &quot;The weight, in grams, of this listing, for the purpose of calculating shipping. Set this field to auto to have the weight automatically estimated for you.&quot;
								},
								{
									&quot;key&quot;: &quot;format_quantity&quot;,
									&quot;value&quot;: &quot;{format_quantity}&quot;,
									&quot;description&quot;: &quot;The number of items this listing counts as, for the purpose of calculating shipping. This field is called “Counts As” on the Discogs website. Set this field to auto to have the quantity automatically estimated for you.&quot;
								}
							]
						},
						&quot;description&quot;: &quot;Edit the data associated with a listing.\n\nIf the listing’s status is not For Sale, Draft, or Expired, it cannot be modified – only deleted. To re-list a Sold listing, a new listing must be created.\n\nAuthentication as the listing owner is required.\n\n[https://www.discogs.com/developers/#page:marketplace,header:marketplace-listing](https://www.discogs.com/developers/#page:marketplace,header:marketplace-listing)&quot;
					},
					&quot;response&quot;: []
				},
				{
					&quot;name&quot;: &quot;Listing&quot;,
					&quot;request&quot;: {
						&quot;method&quot;: &quot;DELETE&quot;,
						&quot;header&quot;: [
							{
								&quot;key&quot;: &quot;Content-Type&quot;,
								&quot;name&quot;: &quot;Content-Type&quot;,
								&quot;type&quot;: &quot;text&quot;,
								&quot;value&quot;: &quot;application/x-www-form-urlencoded&quot;
							},
							{
								&quot;key&quot;: &quot;User-Agent&quot;,
								&quot;type&quot;: &quot;text&quot;,
								&quot;value&quot;: &quot;{{user_agent}}&quot;
							}
						],
						&quot;url&quot;: {
							&quot;raw&quot;: &quot;{{url}}/marketplace/listings/{listing_id}?curr_abbr={curr_abbr}&quot;,
							&quot;host&quot;: [
								&quot;{{url}}&quot;
							],
							&quot;path&quot;: [
								&quot;marketplace&quot;,
								&quot;listings&quot;,
								&quot;{listing_id}&quot;
							],
							&quot;query&quot;: [
								{
									&quot;key&quot;: &quot;curr_abbr&quot;,
									&quot;value&quot;: &quot;{curr_abbr}&quot;
								}
							]
						},
						&quot;description&quot;: &quot;Permanently remove a listing from the Marketplace. Authentication as the listing owner is required.\n\n[https://www.discogs.com/developers/#page:marketplace,header:marketplace-listing](https://www.discogs.com/developers/#page:marketplace,header:marketplace-listing)&quot;
					},
					&quot;response&quot;: []
				},
				{
					&quot;name&quot;: &quot;New listing&quot;,
					&quot;request&quot;: {
						&quot;method&quot;: &quot;POST&quot;,
						&quot;header&quot;: [
							{
								&quot;key&quot;: &quot;Content-Type&quot;,
								&quot;name&quot;: &quot;Content-Type&quot;,
								&quot;type&quot;: &quot;text&quot;,
								&quot;value&quot;: &quot;application/x-www-form-urlencoded&quot;
							},
							{
								&quot;key&quot;: &quot;User-Agent&quot;,
								&quot;type&quot;: &quot;text&quot;,
								&quot;value&quot;: &quot;{{user_agent}}&quot;
							}
						],
						&quot;url&quot;: {
							&quot;raw&quot;: &quot;{{url}}/marketplace/listings?release_id={release_id}&amp;condition={condition}&amp;sleeve_condition={sleeve_condition}&amp;price={price}&amp;comments={comments}&amp;allow_offers={allow_offers}&amp;status={status}&amp;external_id={external_id}&amp;location={location}&amp;weight={weight}&amp;format_quantity={format_quantity}&quot;,
							&quot;host&quot;: [
								&quot;{{url}}&quot;
							],
							&quot;path&quot;: [
								&quot;marketplace&quot;,
								&quot;listings&quot;
							],
							&quot;query&quot;: [
								{
									&quot;key&quot;: &quot;release_id&quot;,
									&quot;value&quot;: &quot;{release_id}&quot;,
									&quot;description&quot;: &quot;The ID of the listing you are fetching\n&quot;
								},
								{
									&quot;key&quot;: &quot;condition&quot;,
									&quot;value&quot;: &quot;{condition}&quot;,
									&quot;description&quot;: &quot;The condition of the release you are posting. Must be one of the following: \n• Mint (M)\n• Near Mint (NM or M-)\n• Very Good Plus (VG+)\n• Very Good (VG)\n• Good Plus (G+)\n• Good (G)\n• Fair (F)\n• Poor (P)&quot;
								},
								{
									&quot;key&quot;: &quot;sleeve_condition&quot;,
									&quot;value&quot;: &quot;{sleeve_condition}&quot;,
									&quot;description&quot;: &quot;The condition of the sleeve of the item you are posting. Must be one of the following: \n• Mint (M)\n• Near Mint (NM or M-)\n• Very Good Plus (VG+)\n• Very Good (VG)\n• Good Plus (G+)\n• Good (G)\n• Fair (F)\n• Poor (P)\n• Generic Not Graded No Cover&quot;
								},
								{
									&quot;key&quot;: &quot;price&quot;,
									&quot;value&quot;: &quot;{price}&quot;,
									&quot;description&quot;: &quot;The price of the item (in the seller’s currency).&quot;
								},
								{
									&quot;key&quot;: &quot;comments&quot;,
									&quot;value&quot;: &quot;{comments}&quot;,
									&quot;description&quot;: &quot;Any remarks about the item that will be displayed to buyers.&quot;
								},
								{
									&quot;key&quot;: &quot;allow_offers&quot;,
									&quot;value&quot;: &quot;{allow_offers}&quot;,
									&quot;description&quot;: &quot;Whether or not to allow buyers to make offers on the item. Defaults to false.&quot;
								},
								{
									&quot;key&quot;: &quot;status&quot;,
									&quot;value&quot;: &quot;{status}&quot;,
									&quot;description&quot;: &quot;The status of the listing. Defaults to For Sale. Options are For Sale (the listing is ready to be shown on the Marketplace) and Draft (the listing is not ready for public display).&quot;
								},
								{
									&quot;key&quot;: &quot;external_id&quot;,
									&quot;value&quot;: &quot;{external_id}&quot;,
									&quot;description&quot;: &quot;A freeform field that can be used for the seller’s own reference. Information stored here will not be displayed to anyone other than the seller. This field is called “Private Comments” on the Discogs website.&quot;
								},
								{
									&quot;key&quot;: &quot;location&quot;,
									&quot;value&quot;: &quot;{location}&quot;,
									&quot;description&quot;: &quot;A freeform field that is intended to help identify an item’s physical storage location. Information stored here will not be displayed to anyone other than the seller. This field will be visible on the inventory management page and will be available in inventory exports via the website.&quot;
								},
								{
									&quot;key&quot;: &quot;weight&quot;,
									&quot;value&quot;: &quot;{weight}&quot;,
									&quot;description&quot;: &quot;The weight, in grams, of this listing, for the purpose of calculating shipping. Set this field to auto to have the weight automatically estimated for you.&quot;
								},
								{
									&quot;key&quot;: &quot;format_quantity&quot;,
									&quot;value&quot;: &quot;{format_quantity}&quot;,
									&quot;description&quot;: &quot;The number of items this listing counts as, for the purpose of calculating shipping. This field is called “Counts As” on the Discogs website. Set this field to auto to have the quantity automatically estimated for you.&quot;
								}
							]
						},
						&quot;description&quot;: &quot;Create a Marketplace listing. Authentication is required; the listing will be added to the authenticated user’s Inventory.\n\n[https://www.discogs.com/developers/#page:marketplace,header:marketplace-new-listing](https://www.discogs.com/developers/#page:marketplace,header:marketplace-new-listing)&quot;
					},
					&quot;response&quot;: []
				},
				{
					&quot;name&quot;: &quot;Order&quot;,
					&quot;request&quot;: {
						&quot;method&quot;: &quot;GET&quot;,
						&quot;header&quot;: [
							{
								&quot;key&quot;: &quot;Content-Type&quot;,
								&quot;name&quot;: &quot;Content-Type&quot;,
								&quot;type&quot;: &quot;text&quot;,
								&quot;value&quot;: &quot;application/x-www-form-urlencoded&quot;
							},
							{
								&quot;key&quot;: &quot;User-Agent&quot;,
								&quot;type&quot;: &quot;text&quot;,
								&quot;value&quot;: &quot;{{user_agent}}&quot;
							}
						],
						&quot;url&quot;: {
							&quot;raw&quot;: &quot;{{url}}/marketplace/orders/{order_id}&quot;,
							&quot;host&quot;: [
								&quot;{{url}}&quot;
							],
							&quot;path&quot;: [
								&quot;marketplace&quot;,
								&quot;orders&quot;,
								&quot;{order_id}&quot;
							]
						},
						&quot;description&quot;: &quot;View the data associated with a listing.\nIf the authorized user is the listing owner the listing will include the weight, format_quantity, external_id, and location keys. If the user is authorized, the listing will contain a in_cart boolean field indicating whether or not this listing is in their cart.\n\n[https://www.discogs.com/developers/#page:marketplace,header:marketplace-listing](https://www.discogs.com/developers/#page:marketplace,header:marketplace-listing)&quot;
					},
					&quot;response&quot;: []
				},
				{
					&quot;name&quot;: &quot;Order&quot;,
					&quot;request&quot;: {
						&quot;method&quot;: &quot;POST&quot;,
						&quot;header&quot;: [
							{
								&quot;key&quot;: &quot;Content-Type&quot;,
								&quot;name&quot;: &quot;Content-Type&quot;,
								&quot;type&quot;: &quot;text&quot;,
								&quot;value&quot;: &quot;application/x-www-form-urlencoded&quot;
							},
							{
								&quot;key&quot;: &quot;User-Agent&quot;,
								&quot;type&quot;: &quot;text&quot;,
								&quot;value&quot;: &quot;{{user_agent}}&quot;
							}
						],
						&quot;url&quot;: {
							&quot;raw&quot;: &quot;{{url}}/marketplace/orders/{order_id}?status={status}&amp;shipping={shipping}&quot;,
							&quot;host&quot;: [
								&quot;{{url}}&quot;
							],
							&quot;path&quot;: [
								&quot;marketplace&quot;,
								&quot;orders&quot;,
								&quot;{order_id}&quot;
							],
							&quot;query&quot;: [
								{
									&quot;key&quot;: &quot;status&quot;,
									&quot;value&quot;: &quot;{status}&quot;,
									&quot;description&quot;: &quot;The status of the Order you are updating. Must be one of the following: \n• New Order\n• Buyer Contacted\n• Invoice Sent\n• Payment Pending\n• Payment Received\n• Shipped\n• Refund Sent\n• Cancelled (Non-Paying Buyer)\n• Cancelled (Item Unavailable)\n• Cancelled (Per Buyer&apos;s Request)\nthe order’s current status\n\nFurthermore, the new status must be present in the order’s next_status list. For more information about order statuses, see Edit an order.&quot;
								},
								{
									&quot;key&quot;: &quot;shipping&quot;,
									&quot;value&quot;: &quot;{shipping}&quot;,
									&quot;description&quot;: &quot;The order shipping amount. As a side-effect of setting this value, the buyer is invoiced and the order status is set to Invoice Sent.&quot;
								}
							]
						},
						&quot;description&quot;: &quot;dit the data associated with an order.\nAuthentication as the seller is required.\nThe response contains a next_status key – an array of valid next statuses for this order, which you can display to the user in (for example) a dropdown control. This also renders your application more resilient to any future changes in the order status logic.\nChanging the order status using this resource will always message the buyer with:\n\nSeller changed status from Old Status to New Status\n\nand does not provide a facility for including a custom message along with the change. For more fine-grained control, use the Add a new message resource, which allows you to simultaneously add a message and change the order status.\nIf the order status is neither cancelled, Payment Received, nor Shipped, you can change the shipping. Doing so will send an invoice to the buyer and set the order status to Invoice Sent. (For that reason, you cannot set the shipping and the order status in the same request.)\n\n[https://www.discogs.com/developers/#page:marketplace,header:marketplace-listing](https://www.discogs.com/developers/#page:marketplace,header:marketplace-listing)&quot;
					},
					&quot;response&quot;: []
				},
				{
					&quot;name&quot;: &quot;List orders&quot;,
					&quot;request&quot;: {
						&quot;method&quot;: &quot;GET&quot;,
						&quot;header&quot;: [
							{
								&quot;key&quot;: &quot;Content-Type&quot;,
								&quot;name&quot;: &quot;Content-Type&quot;,
								&quot;type&quot;: &quot;text&quot;,
								&quot;value&quot;: &quot;application/x-www-form-urlencoded&quot;
							},
							{
								&quot;key&quot;: &quot;User-Agent&quot;,
								&quot;type&quot;: &quot;text&quot;,
								&quot;value&quot;: &quot;{{user_agent}}&quot;
							}
						],
						&quot;url&quot;: {
							&quot;raw&quot;: &quot;{{url}}/marketplace/orders?status={status}&amp;sort={sort}&amp;sort_order={sort_order}&quot;,
							&quot;host&quot;: [
								&quot;{{url}}&quot;
							],
							&quot;path&quot;: [
								&quot;marketplace&quot;,
								&quot;orders&quot;
							],
							&quot;query&quot;: [
								{
									&quot;key&quot;: &quot;status&quot;,
									&quot;value&quot;: &quot;{status}&quot;,
									&quot;description&quot;: &quot;Only show orders with this status. Valid status keys are: \n• All\n• New Order\n• Buyer Contacted\n• Invoice Sent\n• Payment Pending\n• Payment Received\n• Shipped\n• Merged\n• Order Changed\n• Refund Sent\n• Cancelled\n• Cancelled (Non-Paying Buyer)\n• Cancelled (Item Unavailable)\n• Cancelled (Per Buyer&apos;s Request) Cancelled (Refund Received)\n\n&quot;
								},
								{
									&quot;key&quot;: &quot;sort&quot;,
									&quot;value&quot;: &quot;{sort}&quot;,
									&quot;description&quot;: &quot;Sort items by this field (see below). Valid sort keys are: \n• id\n• buyer\n• created\n• status\n• last_activity&quot;
								},
								{
									&quot;key&quot;: &quot;sort_order&quot;,
									&quot;value&quot;: &quot;{sort_order}&quot;,
									&quot;description&quot;: &quot;Sort items in a particular order (one of asc, desc)&quot;
								}
							]
						},
						&quot;description&quot;: &quot;Returns a list of the authenticated user’s orders. Accepts Pagination parameters.\n\n[https://www.discogs.com/developers/#page:marketplace,header:marketplace-list-orders](https://www.discogs.com/developers/#page:marketplace,header:marketplace-list-orders)&quot;
					},
					&quot;response&quot;: []
				},
				{
					&quot;name&quot;: &quot;List order messages&quot;,
					&quot;request&quot;: {
						&quot;method&quot;: &quot;GET&quot;,
						&quot;header&quot;: [
							{
								&quot;key&quot;: &quot;Content-Type&quot;,
								&quot;name&quot;: &quot;Content-Type&quot;,
								&quot;type&quot;: &quot;text&quot;,
								&quot;value&quot;: &quot;application/x-www-form-urlencoded&quot;
							},
							{
								&quot;key&quot;: &quot;User-Agent&quot;,
								&quot;type&quot;: &quot;text&quot;,
								&quot;value&quot;: &quot;{{user_agent}}&quot;
							}
						],
						&quot;url&quot;: {
							&quot;raw&quot;: &quot;{{url}}/marketplace/orders/{order_id}/messages&quot;,
							&quot;host&quot;: [
								&quot;{{url}}&quot;
							],
							&quot;path&quot;: [
								&quot;marketplace&quot;,
								&quot;orders&quot;,
								&quot;{order_id}&quot;,
								&quot;messages&quot;
							]
						},
						&quot;description&quot;: &quot;Returns a list of the order’s messages with the most recent first. Accepts Pagination parameters.\nAuthentication as the seller is required.\n\n[https://www.discogs.com/developers/#page:marketplace,header:marketplace-list-order-messages](https://www.discogs.com/developers/#page:marketplace,header:marketplace-list-order-messages)&quot;
					},
					&quot;response&quot;: []
				},
				{
					&quot;name&quot;: &quot;List order messages&quot;,
					&quot;request&quot;: {
						&quot;method&quot;: &quot;POST&quot;,
						&quot;header&quot;: [
							{
								&quot;key&quot;: &quot;Content-Type&quot;,
								&quot;name&quot;: &quot;Content-Type&quot;,
								&quot;type&quot;: &quot;text&quot;,
								&quot;value&quot;: &quot;application/x-www-form-urlencoded&quot;
							},
							{
								&quot;key&quot;: &quot;User-Agent&quot;,
								&quot;type&quot;: &quot;text&quot;,
								&quot;value&quot;: &quot;{{user_agent}}&quot;
							}
						],
						&quot;url&quot;: {
							&quot;raw&quot;: &quot;{{url}}/marketplace/orders/{order_id}/messages?message={message}&amp;status={status}&quot;,
							&quot;host&quot;: [
								&quot;{{url}}&quot;
							],
							&quot;path&quot;: [
								&quot;marketplace&quot;,
								&quot;orders&quot;,
								&quot;{order_id}&quot;,
								&quot;messages&quot;
							],
							&quot;query&quot;: [
								{
									&quot;key&quot;: &quot;message&quot;,
									&quot;value&quot;: &quot;{message}&quot;
								},
								{
									&quot;key&quot;: &quot;status&quot;,
									&quot;value&quot;: &quot;{status}&quot;
								}
							]
						},
						&quot;description&quot;: &quot;Adds a new message to the order’s message log.\nWhen posting a new message, you can simultaneously change the order status. If you do, the message will automatically be prepended with:\n\nSeller changed status from Old Status to New Status\nWhile message and status are each optional, one or both must be present.\n\n[https://www.discogs.com/developers/#page:marketplace,header:marketplace-list-order-messages](https://www.discogs.com/developers/#page:marketplace,header:marketplace-list-order-messages)&quot;
					},
					&quot;response&quot;: []
				},
				{
					&quot;name&quot;: &quot;Fee&quot;,
					&quot;request&quot;: {
						&quot;method&quot;: &quot;GET&quot;,
						&quot;header&quot;: [
							{
								&quot;key&quot;: &quot;Content-Type&quot;,
								&quot;name&quot;: &quot;Content-Type&quot;,
								&quot;type&quot;: &quot;text&quot;,
								&quot;value&quot;: &quot;application/x-www-form-urlencoded&quot;
							},
							{
								&quot;key&quot;: &quot;User-Agent&quot;,
								&quot;type&quot;: &quot;text&quot;,
								&quot;value&quot;: &quot;{{user_agent}}&quot;
							}
						],
						&quot;url&quot;: {
							&quot;raw&quot;: &quot;{{url}}/marketplace/fee/{price}&quot;,
							&quot;host&quot;: [
								&quot;{{url}}&quot;
							],
							&quot;path&quot;: [
								&quot;marketplace&quot;,
								&quot;fee&quot;,
								&quot;{price}&quot;
							]
						},
						&quot;description&quot;: &quot;The Fee resource allows you to quickly calculate the fee for selling an item on the Marketplace.\n\n[https://www.discogs.com/developers/#page:marketplace,header:marketplace-fee](https://www.discogs.com/developers/#page:marketplace,header:marketplace-fee\n)&quot;
					},
					&quot;response&quot;: []
				},
				{
					&quot;name&quot;: &quot;Fee with currency&quot;,
					&quot;request&quot;: {
						&quot;method&quot;: &quot;GET&quot;,
						&quot;header&quot;: [
							{
								&quot;key&quot;: &quot;Content-Type&quot;,
								&quot;name&quot;: &quot;Content-Type&quot;,
								&quot;type&quot;: &quot;text&quot;,
								&quot;value&quot;: &quot;application/x-www-form-urlencoded&quot;
							},
							{
								&quot;key&quot;: &quot;User-Agent&quot;,
								&quot;type&quot;: &quot;text&quot;,
								&quot;value&quot;: &quot;{{user_agent}}&quot;
							}
						],
						&quot;url&quot;: {
							&quot;raw&quot;: &quot;{{url}}/marketplace/fee/{price}/{currency}&quot;,
							&quot;host&quot;: [
								&quot;{{url}}&quot;
							],
							&quot;path&quot;: [
								&quot;marketplace&quot;,
								&quot;fee&quot;,
								&quot;{price}&quot;,
								&quot;{currency}&quot;
							]
						},
						&quot;description&quot;: &quot;The Fee resource allows you to quickly calculate the fee for selling an item on the Marketplace given a particular currency.\n\n[https://www.discogs.com/developers/#page:marketplace,header:marketplace-fee-with-currency](https://www.discogs.com/developers/#page:marketplace,header:marketplace-fee-with-currency)&quot;
					},
					&quot;response&quot;: []
				},
				{
					&quot;name&quot;: &quot;Price suggestions&quot;,
					&quot;request&quot;: {
						&quot;method&quot;: &quot;GET&quot;,
						&quot;header&quot;: [
							{
								&quot;key&quot;: &quot;Content-Type&quot;,
								&quot;name&quot;: &quot;Content-Type&quot;,
								&quot;type&quot;: &quot;text&quot;,
								&quot;value&quot;: &quot;application/x-www-form-urlencoded&quot;
							},
							{
								&quot;key&quot;: &quot;User-Agent&quot;,
								&quot;type&quot;: &quot;text&quot;,
								&quot;value&quot;: &quot;{{user_agent}}&quot;
							}
						],
						&quot;url&quot;: {
							&quot;raw&quot;: &quot;{{url}}/marketplace/price_suggestions/{release_id}&quot;,
							&quot;host&quot;: [
								&quot;{{url}}&quot;
							],
							&quot;path&quot;: [
								&quot;marketplace&quot;,
								&quot;price_suggestions&quot;,
								&quot;{release_id}&quot;
							]
						},
						&quot;description&quot;: &quot;Retrieve price suggestions for the provided Release ID. If no suggestions are available, an empty object will be returned.\nAuthentication is required, and the user needs to have filled out their seller settings. Suggested prices will be denominated in the user’s selling currency.\n\n[https://www.discogs.com/developers/#page:marketplace,header:marketplace-price-suggestions](https://www.discogs.com/developers/#page:marketplace,header:marketplace-price-suggestions)&quot;
					},
					&quot;response&quot;: []
				}
			],
			&quot;description&quot;: &quot;Visit [https://www.discogs.com/developers/#page:marketplace](https://www.discogs.com/developers/#page:marketplace) for full documentation.&quot;,
			&quot;event&quot;: [
				{
					&quot;listen&quot;: &quot;prerequest&quot;,
					&quot;script&quot;: {
						&quot;id&quot;: &quot;702ada7b-7dcf-44a0-8c1f-a05621508e9d&quot;,
						&quot;type&quot;: &quot;text/javascript&quot;,
						&quot;exec&quot;: [
							&quot;&quot;
						]
					}
				},
				{
					&quot;listen&quot;: &quot;test&quot;,
					&quot;script&quot;: {
						&quot;id&quot;: &quot;d0e6ba63-fefa-46f7-8aec-8cb780e45c55&quot;,
						&quot;type&quot;: &quot;text/javascript&quot;,
						&quot;exec&quot;: [
							&quot;&quot;
						]
					}
				}
			],
			&quot;protocolProfileBehavior&quot;: {}
		},
		{
			&quot;name&quot;: &quot;Inventory Export&quot;,
			&quot;item&quot;: [
				{
					&quot;name&quot;: &quot;Export your inventory&quot;,
					&quot;event&quot;: [
						{
							&quot;listen&quot;: &quot;test&quot;,
							&quot;script&quot;: {
								&quot;id&quot;: &quot;5e6c9eeb-a6e7-4edc-9e15-ef801f3c5cbf&quot;,
								&quot;exec&quot;: [
									&quot;&quot;
								],
								&quot;type&quot;: &quot;text/javascript&quot;
							}
						}
					],
					&quot;request&quot;: {
						&quot;method&quot;: &quot;POST&quot;,
						&quot;header&quot;: [
							{
								&quot;key&quot;: &quot;Content-Type&quot;,
								&quot;type&quot;: &quot;text&quot;,
								&quot;value&quot;: &quot;application/x-www-form-urlencoded&quot;
							},
							{
								&quot;key&quot;: &quot;User-Agent&quot;,
								&quot;type&quot;: &quot;text&quot;,
								&quot;value&quot;: &quot;{{user_agent}}&quot;
							}
						],
						&quot;body&quot;: {
							&quot;mode&quot;: &quot;raw&quot;,
							&quot;raw&quot;: &quot;&quot;
						},
						&quot;url&quot;: {
							&quot;raw&quot;: &quot;{{url}}/inventory/export&quot;,
							&quot;host&quot;: [
								&quot;{{url}}&quot;
							],
							&quot;path&quot;: [
								&quot;inventory&quot;,
								&quot;export&quot;
							]
						},
						&quot;description&quot;: &quot;Request an export of your inventory as a CSV.\n\n[https://www.discogs.com/developers/#page:inventory-export,header:inventory-export-export-your-inventory](https://www.discogs.com/developers/#page:inventory-export,header:inventory-export-export-your-inventory)&quot;
					},
					&quot;response&quot;: []
				},
				{
					&quot;name&quot;: &quot;Recent exports&quot;,
					&quot;event&quot;: [
						{
							&quot;listen&quot;: &quot;test&quot;,
							&quot;script&quot;: {
								&quot;id&quot;: &quot;5e6c9eeb-a6e7-4edc-9e15-ef801f3c5cbf&quot;,
								&quot;exec&quot;: [
									&quot;&quot;
								],
								&quot;type&quot;: &quot;text/javascript&quot;
							}
						}
					],
					&quot;request&quot;: {
						&quot;method&quot;: &quot;GET&quot;,
						&quot;header&quot;: [
							{
								&quot;key&quot;: &quot;Content-Type&quot;,
								&quot;type&quot;: &quot;text&quot;,
								&quot;value&quot;: &quot;application/x-www-form-urlencoded&quot;
							},
							{
								&quot;key&quot;: &quot;User-Agent&quot;,
								&quot;type&quot;: &quot;text&quot;,
								&quot;value&quot;: &quot;{{user_agent}}&quot;
							}
						],
						&quot;url&quot;: {
							&quot;raw&quot;: &quot;{{url}}/inventory/export&quot;,
							&quot;host&quot;: [
								&quot;{{url}}&quot;
							],
							&quot;path&quot;: [
								&quot;inventory&quot;,
								&quot;export&quot;
							]
						},
						&quot;description&quot;: &quot;Get a list of all recent exports of your inventory. Accepts Pagination parameters.\n\n[https://www.discogs.com/developers/#page:inventory-export,header:inventory-export-get-recent-exports](https://www.discogs.com/developers/#page:inventory-export,header:inventory-export-get-recent-exports)&quot;
					},
					&quot;response&quot;: []
				},
				{
					&quot;name&quot;: &quot;Get an export&quot;,
					&quot;event&quot;: [
						{
							&quot;listen&quot;: &quot;test&quot;,
							&quot;script&quot;: {
								&quot;id&quot;: &quot;5e6c9eeb-a6e7-4edc-9e15-ef801f3c5cbf&quot;,
								&quot;exec&quot;: [
									&quot;&quot;
								],
								&quot;type&quot;: &quot;text/javascript&quot;
							}
						}
					],
					&quot;request&quot;: {
						&quot;method&quot;: &quot;GET&quot;,
						&quot;header&quot;: [
							{
								&quot;key&quot;: &quot;Content-Type&quot;,
								&quot;type&quot;: &quot;text&quot;,
								&quot;value&quot;: &quot;application/x-www-form-urlencoded&quot;
							},
							{
								&quot;key&quot;: &quot;User-Agent&quot;,
								&quot;type&quot;: &quot;text&quot;,
								&quot;value&quot;: &quot;{{user_agent}}&quot;
							}
						],
						&quot;url&quot;: {
							&quot;raw&quot;: &quot;{{url}}/inventory/export/{id}&quot;,
							&quot;host&quot;: [
								&quot;{{url}}&quot;
							],
							&quot;path&quot;: [
								&quot;inventory&quot;,
								&quot;export&quot;,
								&quot;{id}&quot;
							]
						},
						&quot;description&quot;: &quot;Get details about the status of an inventory export.\n\n[https://www.discogs.com/developers/#page:inventory-export,header:inventory-export-get-an-export](https://www.discogs.com/developers/#page:inventory-export,header:inventory-export-get-an-export)&quot;
					},
					&quot;response&quot;: []
				},
				{
					&quot;name&quot;: &quot;Download an export&quot;,
					&quot;event&quot;: [
						{
							&quot;listen&quot;: &quot;test&quot;,
							&quot;script&quot;: {
								&quot;id&quot;: &quot;5e6c9eeb-a6e7-4edc-9e15-ef801f3c5cbf&quot;,
								&quot;exec&quot;: [
									&quot;&quot;
								],
								&quot;type&quot;: &quot;text/javascript&quot;
							}
						}
					],
					&quot;request&quot;: {
						&quot;method&quot;: &quot;GET&quot;,
						&quot;header&quot;: [
							{
								&quot;key&quot;: &quot;Content-Type&quot;,
								&quot;type&quot;: &quot;text&quot;,
								&quot;value&quot;: &quot;application/x-www-form-urlencoded&quot;
							},
							{
								&quot;key&quot;: &quot;User-Agent&quot;,
								&quot;type&quot;: &quot;text&quot;,
								&quot;value&quot;: &quot;{{user_agent}}&quot;
							}
						],
						&quot;url&quot;: {
							&quot;raw&quot;: &quot;{{url}}/inventory/export/{id}/download&quot;,
							&quot;host&quot;: [
								&quot;{{url}}&quot;
							],
							&quot;path&quot;: [
								&quot;inventory&quot;,
								&quot;export&quot;,
								&quot;{id}&quot;,
								&quot;download&quot;
							]
						},
						&quot;description&quot;: &quot;Download the results of an inventory export.\n\n[https://www.discogs.com/developers/#page:inventory-export,header:inventory-export-download-an-export](https://www.discogs.com/developers/#page:inventory-export,header:inventory-export-download-an-export)&quot;
					},
					&quot;response&quot;: []
				}
			],
			&quot;description&quot;: &quot;Visit [https://www.discogs.com/developers/#page:inventory-export](https://www.discogs.com/developers/#page:inventory-export) for full documentation.&quot;,
			&quot;event&quot;: [
				{
					&quot;listen&quot;: &quot;prerequest&quot;,
					&quot;script&quot;: {
						&quot;id&quot;: &quot;5f6b6b23-c5c5-4b3e-869c-2003a0026ee3&quot;,
						&quot;type&quot;: &quot;text/javascript&quot;,
						&quot;exec&quot;: [
							&quot;&quot;
						]
					}
				},
				{
					&quot;listen&quot;: &quot;test&quot;,
					&quot;script&quot;: {
						&quot;id&quot;: &quot;4389dd1d-5d38-4bb3-91e4-635430ce24f4&quot;,
						&quot;type&quot;: &quot;text/javascript&quot;,
						&quot;exec&quot;: [
							&quot;&quot;
						]
					}
				}
			],
			&quot;protocolProfileBehavior&quot;: {}
		},
		{
			&quot;name&quot;: &quot;Inventory Upload&quot;,
			&quot;item&quot;: [
				{
					&quot;name&quot;: &quot;Add inventory&quot;,
					&quot;event&quot;: [
						{
							&quot;listen&quot;: &quot;test&quot;,
							&quot;script&quot;: {
								&quot;id&quot;: &quot;5e6c9eeb-a6e7-4edc-9e15-ef801f3c5cbf&quot;,
								&quot;exec&quot;: [
									&quot;&quot;
								],
								&quot;type&quot;: &quot;text/javascript&quot;
							}
						}
					],
					&quot;request&quot;: {
						&quot;method&quot;: &quot;POST&quot;,
						&quot;header&quot;: [
							{
								&quot;key&quot;: &quot;Content-Type&quot;,
								&quot;type&quot;: &quot;text&quot;,
								&quot;value&quot;: &quot;application/x-www-form-urlencoded&quot;
							},
							{
								&quot;key&quot;: &quot;User-Agent&quot;,
								&quot;type&quot;: &quot;text&quot;,
								&quot;value&quot;: &quot;{{user_agent}}&quot;
							}
						],
						&quot;body&quot;: {
							&quot;mode&quot;: &quot;raw&quot;,
							&quot;raw&quot;: &quot;&quot;
						},
						&quot;url&quot;: {
							&quot;raw&quot;: &quot;{{url}}/inventory/upload/add&quot;,
							&quot;host&quot;: [
								&quot;{{url}}&quot;
							],
							&quot;path&quot;: [
								&quot;inventory&quot;,
								&quot;upload&quot;,
								&quot;add&quot;
							]
						},
						&quot;description&quot;: &quot;Upload a CSV of listings to add to your inventory.\n\n[https://www.discogs.com/developers/#page:inventory-upload,header:inventory-upload-add-inventory](https://www.discogs.com/developers/#page:inventory-upload,header:inventory-upload-add-inventory)&quot;
					},
					&quot;response&quot;: []
				},
				{
					&quot;name&quot;: &quot;Change inventory&quot;,
					&quot;event&quot;: [
						{
							&quot;listen&quot;: &quot;test&quot;,
							&quot;script&quot;: {
								&quot;id&quot;: &quot;5e6c9eeb-a6e7-4edc-9e15-ef801f3c5cbf&quot;,
								&quot;exec&quot;: [
									&quot;&quot;
								],
								&quot;type&quot;: &quot;text/javascript&quot;
							}
						}
					],
					&quot;request&quot;: {
						&quot;method&quot;: &quot;POST&quot;,
						&quot;header&quot;: [
							{
								&quot;key&quot;: &quot;Content-Type&quot;,
								&quot;type&quot;: &quot;text&quot;,
								&quot;value&quot;: &quot;application/x-www-form-urlencoded&quot;
							},
							{
								&quot;key&quot;: &quot;User-Agent&quot;,
								&quot;type&quot;: &quot;text&quot;,
								&quot;value&quot;: &quot;{{user_agent}}&quot;
							}
						],
						&quot;body&quot;: {
							&quot;mode&quot;: &quot;raw&quot;,
							&quot;raw&quot;: &quot;&quot;
						},
						&quot;url&quot;: {
							&quot;raw&quot;: &quot;{{url}}/inventory/upload/change&quot;,
							&quot;host&quot;: [
								&quot;{{url}}&quot;
							],
							&quot;path&quot;: [
								&quot;inventory&quot;,
								&quot;upload&quot;,
								&quot;change&quot;
							]
						},
						&quot;description&quot;: &quot;Upload a CSV of listings to change in your inventory.\n\n[https://www.discogs.com/developers/#page:inventory-upload,header:inventory-upload-change-inventory](https://www.discogs.com/developers/#page:inventory-upload,header:inventory-upload-change-inventory)&quot;
					},
					&quot;response&quot;: []
				},
				{
					&quot;name&quot;: &quot;Delete inventory&quot;,
					&quot;event&quot;: [
						{
							&quot;listen&quot;: &quot;test&quot;,
							&quot;script&quot;: {
								&quot;id&quot;: &quot;5e6c9eeb-a6e7-4edc-9e15-ef801f3c5cbf&quot;,
								&quot;exec&quot;: [
									&quot;&quot;
								],
								&quot;type&quot;: &quot;text/javascript&quot;
							}
						}
					],
					&quot;request&quot;: {
						&quot;method&quot;: &quot;POST&quot;,
						&quot;header&quot;: [
							{
								&quot;key&quot;: &quot;Content-Type&quot;,
								&quot;type&quot;: &quot;text&quot;,
								&quot;value&quot;: &quot;application/x-www-form-urlencoded&quot;
							},
							{
								&quot;key&quot;: &quot;User-Agent&quot;,
								&quot;type&quot;: &quot;text&quot;,
								&quot;value&quot;: &quot;{{user_agent}}&quot;
							}
						],
						&quot;body&quot;: {
							&quot;mode&quot;: &quot;raw&quot;,
							&quot;raw&quot;: &quot;&quot;
						},
						&quot;url&quot;: {
							&quot;raw&quot;: &quot;{{url}}/inventory/upload/change&quot;,
							&quot;host&quot;: [
								&quot;{{url}}&quot;
							],
							&quot;path&quot;: [
								&quot;inventory&quot;,
								&quot;upload&quot;,
								&quot;change&quot;
							]
						},
						&quot;description&quot;: &quot;Upload a CSV of listings to delete from your inventory.\n\n[https://www.discogs.com/developers/#page:inventory-upload,header:inventory-upload-delete-inventory](https://www.discogs.com/developers/#page:inventory-upload,header:inventory-upload-delete-inventory)&quot;
					},
					&quot;response&quot;: []
				},
				{
					&quot;name&quot;: &quot;Recent uploads&quot;,
					&quot;event&quot;: [
						{
							&quot;listen&quot;: &quot;test&quot;,
							&quot;script&quot;: {
								&quot;id&quot;: &quot;5e6c9eeb-a6e7-4edc-9e15-ef801f3c5cbf&quot;,
								&quot;exec&quot;: [
									&quot;&quot;
								],
								&quot;type&quot;: &quot;text/javascript&quot;
							}
						}
					],
					&quot;request&quot;: {
						&quot;method&quot;: &quot;GET&quot;,
						&quot;header&quot;: [
							{
								&quot;key&quot;: &quot;Content-Type&quot;,
								&quot;type&quot;: &quot;text&quot;,
								&quot;value&quot;: &quot;application/x-www-form-urlencoded&quot;
							},
							{
								&quot;key&quot;: &quot;User-Agent&quot;,
								&quot;type&quot;: &quot;text&quot;,
								&quot;value&quot;: &quot;{{user_agent}}&quot;
							}
						],
						&quot;url&quot;: {
							&quot;raw&quot;: &quot;{{url}}/inventory/upload&quot;,
							&quot;host&quot;: [
								&quot;{{url}}&quot;
							],
							&quot;path&quot;: [
								&quot;inventory&quot;,
								&quot;upload&quot;
							]
						},
						&quot;description&quot;: &quot;Get a list of all recent inventory uploads. Accepts Pagination parameters.\n\n[https://www.discogs.com/developers/#page:inventory-upload,header:inventory-upload-get-recent-uploads](https://www.discogs.com/developers/#page:inventory-upload,header:inventory-upload-get-recent-uploads)&quot;
					},
					&quot;response&quot;: []
				},
				{
					&quot;name&quot;: &quot;Recent upload by ID&quot;,
					&quot;event&quot;: [
						{
							&quot;listen&quot;: &quot;test&quot;,
							&quot;script&quot;: {
								&quot;id&quot;: &quot;5e6c9eeb-a6e7-4edc-9e15-ef801f3c5cbf&quot;,
								&quot;exec&quot;: [
									&quot;&quot;
								],
								&quot;type&quot;: &quot;text/javascript&quot;
							}
						}
					],
					&quot;request&quot;: {
						&quot;method&quot;: &quot;GET&quot;,
						&quot;header&quot;: [
							{
								&quot;key&quot;: &quot;Content-Type&quot;,
								&quot;type&quot;: &quot;text&quot;,
								&quot;value&quot;: &quot;application/x-www-form-urlencoded&quot;
							},
							{
								&quot;key&quot;: &quot;User-Agent&quot;,
								&quot;type&quot;: &quot;text&quot;,
								&quot;value&quot;: &quot;{{user_agent}}&quot;
							}
						],
						&quot;url&quot;: {
							&quot;raw&quot;: &quot;{{url}}/inventory/upload/{id}&quot;,
							&quot;host&quot;: [
								&quot;{{url}}&quot;
							],
							&quot;path&quot;: [
								&quot;inventory&quot;,
								&quot;upload&quot;,
								&quot;{id}&quot;
							]
						},
						&quot;description&quot;: &quot;Get details about the status of an inventory upload.\n\n[https://www.discogs.com/developers/#page:inventory-upload,header:inventory-upload-get-an-upload](https://www.discogs.com/developers/#page:inventory-upload,header:inventory-upload-get-an-upload)&quot;
					},
					&quot;response&quot;: []
				}
			],
			&quot;description&quot;: &quot;Visit [https://www.discogs.com/developers/#page:inventory-upload](https://www.discogs.com/developers/#page:inventory-upload) for full documentation.&quot;,
			&quot;event&quot;: [
				{
					&quot;listen&quot;: &quot;prerequest&quot;,
					&quot;script&quot;: {
						&quot;id&quot;: &quot;d0f290d3-f3c1-49b5-ba5e-967af2ef5d07&quot;,
						&quot;type&quot;: &quot;text/javascript&quot;,
						&quot;exec&quot;: [
							&quot;&quot;
						]
					}
				},
				{
					&quot;listen&quot;: &quot;test&quot;,
					&quot;script&quot;: {
						&quot;id&quot;: &quot;46a688cb-a72a-4e9b-a9eb-1f23f59c86ba&quot;,
						&quot;type&quot;: &quot;text/javascript&quot;,
						&quot;exec&quot;: [
							&quot;&quot;
						]
					}
				}
			],
			&quot;protocolProfileBehavior&quot;: {}
		},
		{
			&quot;name&quot;: &quot;User identity&quot;,
			&quot;item&quot;: [
				{
					&quot;name&quot;: &quot;Identity&quot;,
					&quot;event&quot;: [
						{
							&quot;listen&quot;: &quot;test&quot;,
							&quot;script&quot;: {
								&quot;id&quot;: &quot;5e6c9eeb-a6e7-4edc-9e15-ef801f3c5cbf&quot;,
								&quot;exec&quot;: [
									&quot;&quot;
								],
								&quot;type&quot;: &quot;text/javascript&quot;
							}
						}
					],
					&quot;request&quot;: {
						&quot;method&quot;: &quot;GET&quot;,
						&quot;header&quot;: [
							{
								&quot;key&quot;: &quot;Content-Type&quot;,
								&quot;type&quot;: &quot;text&quot;,
								&quot;value&quot;: &quot;application/x-www-form-urlencoded&quot;
							},
							{
								&quot;key&quot;: &quot;User-Agent&quot;,
								&quot;type&quot;: &quot;text&quot;,
								&quot;value&quot;: &quot;{{user_agent}}&quot;
							}
						],
						&quot;url&quot;: {
							&quot;raw&quot;: &quot;{{url}}/oauth/identity&quot;,
							&quot;host&quot;: [
								&quot;{{url}}&quot;
							],
							&quot;path&quot;: [
								&quot;oauth&quot;,
								&quot;identity&quot;
							]
						},
						&quot;description&quot;: &quot;Retrieve basic information about the authenticated user.\nYou can use this resource to find out who you’re authenticated as, and it also doubles as a good sanity check to ensure that you’re using OAuth correctly.\nFor more detailed information, make another request for the user’s Profile.\n\n[https://www.discogs.com/developers/#page:user-identity,header:user-identity-identity](https://www.discogs.com/developers/#page:user-identity,header:user-identity-identity)&quot;
					},
					&quot;response&quot;: []
				},
				{
					&quot;name&quot;: &quot;Profile&quot;,
					&quot;event&quot;: [
						{
							&quot;listen&quot;: &quot;test&quot;,
							&quot;script&quot;: {
								&quot;id&quot;: &quot;5e6c9eeb-a6e7-4edc-9e15-ef801f3c5cbf&quot;,
								&quot;exec&quot;: [
									&quot;&quot;
								],
								&quot;type&quot;: &quot;text/javascript&quot;
							}
						}
					],
					&quot;request&quot;: {
						&quot;method&quot;: &quot;GET&quot;,
						&quot;header&quot;: [
							{
								&quot;key&quot;: &quot;Content-Type&quot;,
								&quot;type&quot;: &quot;text&quot;,
								&quot;value&quot;: &quot;application/x-www-form-urlencoded&quot;
							},
							{
								&quot;key&quot;: &quot;User-Agent&quot;,
								&quot;type&quot;: &quot;text&quot;,
								&quot;value&quot;: &quot;{{user_agent}}&quot;
							}
						],
						&quot;url&quot;: {
							&quot;raw&quot;: &quot;{{url}}/users/{{username}}&quot;,
							&quot;host&quot;: [
								&quot;{{url}}&quot;
							],
							&quot;path&quot;: [
								&quot;users&quot;,
								&quot;{{username}}&quot;
							]
						},
						&quot;description&quot;: &quot;Retrieve a user by username.\n\nIf authenticated as the requested user, the email key will be visible, and the num_list count will include the user’s private lists.\n\nIf authenticated as the requested user or the user’s collection/wantlist is public, the num_collection / num_wantlist keys will be visible.\n\n[https://www.discogs.com/developers/#page:user-identity,header:user-identity-profile](https://www.discogs.com/developers/#page:user-identity,header:user-identity-profile)&quot;
					},
					&quot;response&quot;: []
				},
				{
					&quot;name&quot;: &quot;Profile&quot;,
					&quot;event&quot;: [
						{
							&quot;listen&quot;: &quot;test&quot;,
							&quot;script&quot;: {
								&quot;id&quot;: &quot;5e6c9eeb-a6e7-4edc-9e15-ef801f3c5cbf&quot;,
								&quot;exec&quot;: [
									&quot;&quot;
								],
								&quot;type&quot;: &quot;text/javascript&quot;
							}
						}
					],
					&quot;request&quot;: {
						&quot;method&quot;: &quot;POST&quot;,
						&quot;header&quot;: [
							{
								&quot;key&quot;: &quot;Content-Type&quot;,
								&quot;name&quot;: &quot;Content-Type&quot;,
								&quot;value&quot;: &quot;application/json&quot;,
								&quot;type&quot;: &quot;text&quot;
							},
							{
								&quot;key&quot;: &quot;User-Agent&quot;,
								&quot;type&quot;: &quot;text&quot;,
								&quot;value&quot;: &quot;{{user_agent}}&quot;
							}
						],
						&quot;body&quot;: {
							&quot;mode&quot;: &quot;raw&quot;,
							&quot;raw&quot;: &quot;&quot;
						},
						&quot;url&quot;: {
							&quot;raw&quot;: &quot;{{url}}/users/{{username}}&quot;,
							&quot;host&quot;: [
								&quot;{{url}}&quot;
							],
							&quot;path&quot;: [
								&quot;users&quot;,
								&quot;{{username}}&quot;
							]
						},
						&quot;description&quot;: &quot;Edit a user’s profile data. Authentication as the user is required. Parameters must be filled in a json object inside the body. \n\n[https://www.discogs.com/developers/#page:user-identity,header:user-identity-profile](https://www.discogs.com/developers/#page:user-identity,header:user-identity-profile)&quot;
					},
					&quot;response&quot;: []
				},
				{
					&quot;name&quot;: &quot;User submissions&quot;,
					&quot;event&quot;: [
						{
							&quot;listen&quot;: &quot;test&quot;,
							&quot;script&quot;: {
								&quot;id&quot;: &quot;5e6c9eeb-a6e7-4edc-9e15-ef801f3c5cbf&quot;,
								&quot;exec&quot;: [
									&quot;&quot;
								],
								&quot;type&quot;: &quot;text/javascript&quot;
							}
						}
					],
					&quot;request&quot;: {
						&quot;method&quot;: &quot;GET&quot;,
						&quot;header&quot;: [
							{
								&quot;key&quot;: &quot;Content-Type&quot;,
								&quot;type&quot;: &quot;text&quot;,
								&quot;value&quot;: &quot;application/x-www-form-urlencoded&quot;
							},
							{
								&quot;key&quot;: &quot;User-Agent&quot;,
								&quot;type&quot;: &quot;text&quot;,
								&quot;value&quot;: &quot;{{user_agent}}&quot;
							}
						],
						&quot;url&quot;: {
							&quot;raw&quot;: &quot;{{url}}/users/{{username}}/submissions&quot;,
							&quot;host&quot;: [
								&quot;{{url}}&quot;
							],
							&quot;path&quot;: [
								&quot;users&quot;,
								&quot;{{username}}&quot;,
								&quot;submissions&quot;
							]
						},
						&quot;description&quot;: &quot;Retrieve a user’s submissions by username. Accepts Pagination parameters.\n\n[https://www.discogs.com/developers/#page:user-identity,header:user-identity-user-submissions](https://www.discogs.com/developers/#page:user-identity,header:user-identity-user-submissions)&quot;
					},
					&quot;response&quot;: []
				},
				{
					&quot;name&quot;: &quot;User contributions&quot;,
					&quot;event&quot;: [
						{
							&quot;listen&quot;: &quot;test&quot;,
							&quot;script&quot;: {
								&quot;id&quot;: &quot;5e6c9eeb-a6e7-4edc-9e15-ef801f3c5cbf&quot;,
								&quot;exec&quot;: [
									&quot;&quot;
								],
								&quot;type&quot;: &quot;text/javascript&quot;
							}
						}
					],
					&quot;request&quot;: {
						&quot;method&quot;: &quot;GET&quot;,
						&quot;header&quot;: [
							{
								&quot;key&quot;: &quot;Content-Type&quot;,
								&quot;type&quot;: &quot;text&quot;,
								&quot;value&quot;: &quot;application/x-www-form-urlencoded&quot;
							},
							{
								&quot;key&quot;: &quot;User-Agent&quot;,
								&quot;type&quot;: &quot;text&quot;,
								&quot;value&quot;: &quot;{{user_agent}}&quot;
							}
						],
						&quot;url&quot;: {
							&quot;raw&quot;: &quot;{{url}}/users/{{username}}/contributions&quot;,
							&quot;host&quot;: [
								&quot;{{url}}&quot;
							],
							&quot;path&quot;: [
								&quot;users&quot;,
								&quot;{{username}}&quot;,
								&quot;contributions&quot;
							]
						},
						&quot;description&quot;: &quot;Retrieve a user’s contributions by username. Accepts Pagination parameters. The Contributions resource represents releases, labels, and artists submitted by a user. \n\n[https://www.discogs.com/developers/#page:user-identity,header:user-identity-user-contributions](https://www.discogs.com/developers/#page:user-identity,header:user-identity-user-contributions)&quot;
					},
					&quot;response&quot;: []
				}
			],
			&quot;description&quot;: &quot;Visit [https://www.discogs.com/developers/#page:user-identity](https://www.discogs.com/developers/#page:user-identity) for full documentation.&quot;,
			&quot;event&quot;: [
				{
					&quot;listen&quot;: &quot;prerequest&quot;,
					&quot;script&quot;: {
						&quot;id&quot;: &quot;12e817a3-5bc8-45f8-9708-eac6a7d48aea&quot;,
						&quot;type&quot;: &quot;text/javascript&quot;,
						&quot;exec&quot;: [
							&quot;&quot;
						]
					}
				},
				{
					&quot;listen&quot;: &quot;test&quot;,
					&quot;script&quot;: {
						&quot;id&quot;: &quot;54c3bbed-460d-47c2-a733-72e4962676a8&quot;,
						&quot;type&quot;: &quot;text/javascript&quot;,
						&quot;exec&quot;: [
							&quot;&quot;
						]
					}
				}
			],
			&quot;protocolProfileBehavior&quot;: {}
		},
		{
			&quot;name&quot;: &quot;User Collection&quot;,
			&quot;item&quot;: [
				{
					&quot;name&quot;: &quot;Collection&quot;,
					&quot;event&quot;: [
						{
							&quot;listen&quot;: &quot;test&quot;,
							&quot;script&quot;: {
								&quot;id&quot;: &quot;5e6c9eeb-a6e7-4edc-9e15-ef801f3c5cbf&quot;,
								&quot;exec&quot;: [
									&quot;&quot;
								],
								&quot;type&quot;: &quot;text/javascript&quot;
							}
						}
					],
					&quot;request&quot;: {
						&quot;method&quot;: &quot;GET&quot;,
						&quot;header&quot;: [
							{
								&quot;key&quot;: &quot;Content-Type&quot;,
								&quot;type&quot;: &quot;text&quot;,
								&quot;value&quot;: &quot;application/x-www-form-urlencoded&quot;
							},
							{
								&quot;key&quot;: &quot;User-Agent&quot;,
								&quot;type&quot;: &quot;text&quot;,
								&quot;value&quot;: &quot;{{user_agent}}&quot;
							}
						],
						&quot;url&quot;: {
							&quot;raw&quot;: &quot;{{url}}/users/{{username}}/collection/folders&quot;,
							&quot;host&quot;: [
								&quot;{{url}}&quot;
							],
							&quot;path&quot;: [
								&quot;users&quot;,
								&quot;{{username}}&quot;,
								&quot;collection&quot;,
								&quot;folders&quot;
							]
						},
						&quot;description&quot;: &quot;Retrieve a list of folders in a user’s collection. If the collection has been made private by its owner, authentication as the collection owner is required. If you are not authenticated as the collection owner, only folder ID 0 (the “All” folder) will be visible (if the requested user’s collection is public).\n\n[https://www.discogs.com/developers/#page:user-collection,header:user-collection-collection](https://www.discogs.com/developers/#page:user-collection,header:user-collection-collection)&quot;
					},
					&quot;response&quot;: []
				},
				{
					&quot;name&quot;: &quot;Collection&quot;,
					&quot;event&quot;: [
						{
							&quot;listen&quot;: &quot;test&quot;,
							&quot;script&quot;: {
								&quot;id&quot;: &quot;5e6c9eeb-a6e7-4edc-9e15-ef801f3c5cbf&quot;,
								&quot;exec&quot;: [
									&quot;&quot;
								],
								&quot;type&quot;: &quot;text/javascript&quot;
							}
						}
					],
					&quot;request&quot;: {
						&quot;method&quot;: &quot;POST&quot;,
						&quot;header&quot;: [
							{
								&quot;key&quot;: &quot;Content-Type&quot;,
								&quot;name&quot;: &quot;Content-Type&quot;,
								&quot;value&quot;: &quot;application/json&quot;,
								&quot;type&quot;: &quot;text&quot;
							},
							{
								&quot;key&quot;: &quot;User-Agent&quot;,
								&quot;type&quot;: &quot;text&quot;,
								&quot;value&quot;: &quot;{{user_agent}}&quot;
							}
						],
						&quot;body&quot;: {
							&quot;mode&quot;: &quot;raw&quot;,
							&quot;raw&quot;: &quot;&quot;
						},
						&quot;url&quot;: {
							&quot;raw&quot;: &quot;{{url}}/users/{{username}}/collection/folders&quot;,
							&quot;host&quot;: [
								&quot;{{url}}&quot;
							],
							&quot;path&quot;: [
								&quot;users&quot;,
								&quot;{{username}}&quot;,
								&quot;collection&quot;,
								&quot;folders&quot;
							]
						},
						&quot;description&quot;: &quot;Retrieve a list of folders in a user’s collection. If the collection has been made private by its owner, authentication as the collection owner is required. If you are not authenticated as the collection owner, only folder ID 0 (the “All” folder) will be visible (if the requested user’s collection is public).\n\n[https://www.discogs.com/developers/#page:user-collection,header:user-collection-collection](https://www.discogs.com/developers/#page:user-collection,header:user-collection-collection)&quot;
					},
					&quot;response&quot;: []
				},
				{
					&quot;name&quot;: &quot;Collection folder&quot;,
					&quot;event&quot;: [
						{
							&quot;listen&quot;: &quot;test&quot;,
							&quot;script&quot;: {
								&quot;id&quot;: &quot;5e6c9eeb-a6e7-4edc-9e15-ef801f3c5cbf&quot;,
								&quot;exec&quot;: [
									&quot;&quot;
								],
								&quot;type&quot;: &quot;text/javascript&quot;
							}
						}
					],
					&quot;request&quot;: {
						&quot;method&quot;: &quot;GET&quot;,
						&quot;header&quot;: [
							{
								&quot;key&quot;: &quot;Content-Type&quot;,
								&quot;type&quot;: &quot;text&quot;,
								&quot;value&quot;: &quot;application/x-www-form-urlencoded&quot;
							},
							{
								&quot;key&quot;: &quot;User-Agent&quot;,
								&quot;type&quot;: &quot;text&quot;,
								&quot;value&quot;: &quot;{{user_agent}}&quot;
							}
						],
						&quot;url&quot;: {
							&quot;raw&quot;: &quot;{{url}}/users/{{username}}/collection/folders/{folder_id}&quot;,
							&quot;host&quot;: [
								&quot;{{url}}&quot;
							],
							&quot;path&quot;: [
								&quot;users&quot;,
								&quot;{{username}}&quot;,
								&quot;collection&quot;,
								&quot;folders&quot;,
								&quot;{folder_id}&quot;
							]
						},
						&quot;description&quot;: &quot;Retrieve metadata about a folder in a user’s collection. If folder_id is not 0, authentication as the collection owner is required.\n\n[https://www.discogs.com/developers/#page:user-collection,header:user-collection-collection-folder](https://www.discogs.com/developers/#page:user-collection,header:user-collection-collection-folder)&quot;
					},
					&quot;response&quot;: []
				},
				{
					&quot;name&quot;: &quot;Collection folder&quot;,
					&quot;event&quot;: [
						{
							&quot;listen&quot;: &quot;test&quot;,
							&quot;script&quot;: {
								&quot;id&quot;: &quot;5e6c9eeb-a6e7-4edc-9e15-ef801f3c5cbf&quot;,
								&quot;exec&quot;: [
									&quot;&quot;
								],
								&quot;type&quot;: &quot;text/javascript&quot;
							}
						}
					],
					&quot;request&quot;: {
						&quot;method&quot;: &quot;POST&quot;,
						&quot;header&quot;: [
							{
								&quot;key&quot;: &quot;Content-Type&quot;,
								&quot;type&quot;: &quot;text&quot;,
								&quot;value&quot;: &quot;application/x-www-form-urlencoded&quot;
							},
							{
								&quot;key&quot;: &quot;User-Agent&quot;,
								&quot;type&quot;: &quot;text&quot;,
								&quot;value&quot;: &quot;{{user_agent}}&quot;
							}
						],
						&quot;body&quot;: {
							&quot;mode&quot;: &quot;raw&quot;,
							&quot;raw&quot;: &quot;&quot;
						},
						&quot;url&quot;: {
							&quot;raw&quot;: &quot;{{url}}/users/{{username}}/collection/folders/{folder_id}&quot;,
							&quot;host&quot;: [
								&quot;{{url}}&quot;
							],
							&quot;path&quot;: [
								&quot;users&quot;,
								&quot;{{username}}&quot;,
								&quot;collection&quot;,
								&quot;folders&quot;,
								&quot;{folder_id}&quot;
							]
						},
						&quot;description&quot;: &quot;Edit a folder’s metadata. Folders 0 and 1 cannot be renamed. Authentication as the collection owner is required.\n\n[https://www.discogs.com/developers/#page:user-collection,header:user-collection-collection-folder](https://www.discogs.com/developers/#page:user-collection,header:user-collection-collection-folder)&quot;
					},
					&quot;response&quot;: []
				},
				{
					&quot;name&quot;: &quot;Collection folder&quot;,
					&quot;event&quot;: [
						{
							&quot;listen&quot;: &quot;test&quot;,
							&quot;script&quot;: {
								&quot;id&quot;: &quot;5e6c9eeb-a6e7-4edc-9e15-ef801f3c5cbf&quot;,
								&quot;exec&quot;: [
									&quot;&quot;
								],
								&quot;type&quot;: &quot;text/javascript&quot;
							}
						}
					],
					&quot;request&quot;: {
						&quot;method&quot;: &quot;DELETE&quot;,
						&quot;header&quot;: [
							{
								&quot;key&quot;: &quot;Content-Type&quot;,
								&quot;type&quot;: &quot;text&quot;,
								&quot;value&quot;: &quot;application/x-www-form-urlencoded&quot;
							},
							{
								&quot;key&quot;: &quot;User-Agent&quot;,
								&quot;type&quot;: &quot;text&quot;,
								&quot;value&quot;: &quot;{{user_agent}}&quot;
							}
						],
						&quot;body&quot;: {
							&quot;mode&quot;: &quot;raw&quot;,
							&quot;raw&quot;: &quot;&quot;
						},
						&quot;url&quot;: {
							&quot;raw&quot;: &quot;{{url}}/users/{{username}}/collection/folders/{folder_id}&quot;,
							&quot;host&quot;: [
								&quot;{{url}}&quot;
							],
							&quot;path&quot;: [
								&quot;users&quot;,
								&quot;{{username}}&quot;,
								&quot;collection&quot;,
								&quot;folders&quot;,
								&quot;{folder_id}&quot;
							]
						},
						&quot;description&quot;: &quot;Delete a folder from a user’s collection. A folder must be empty before it can be deleted. Authentication as the collection owner is required.\n\n[https://www.discogs.com/developers/#page:user-collection,header:user-collection-collection-folder](https://www.discogs.com/developers/#page:user-collection,header:user-collection-collection-folder)&quot;
					},
					&quot;response&quot;: []
				},
				{
					&quot;name&quot;: &quot;Collection items by release&quot;,
					&quot;event&quot;: [
						{
							&quot;listen&quot;: &quot;test&quot;,
							&quot;script&quot;: {
								&quot;id&quot;: &quot;5e6c9eeb-a6e7-4edc-9e15-ef801f3c5cbf&quot;,
								&quot;exec&quot;: [
									&quot;&quot;
								],
								&quot;type&quot;: &quot;text/javascript&quot;
							}
						}
					],
					&quot;request&quot;: {
						&quot;method&quot;: &quot;GET&quot;,
						&quot;header&quot;: [
							{
								&quot;key&quot;: &quot;Content-Type&quot;,
								&quot;type&quot;: &quot;text&quot;,
								&quot;value&quot;: &quot;application/x-www-form-urlencoded&quot;
							},
							{
								&quot;key&quot;: &quot;User-Agent&quot;,
								&quot;type&quot;: &quot;text&quot;,
								&quot;value&quot;: &quot;{{user_agent}}&quot;
							}
						],
						&quot;url&quot;: {
							&quot;raw&quot;: &quot;{{url}}/users/{{username}}/collection/releases/{release_id}&quot;,
							&quot;host&quot;: [
								&quot;{{url}}&quot;
							],
							&quot;path&quot;: [
								&quot;users&quot;,
								&quot;{{username}}&quot;,
								&quot;collection&quot;,
								&quot;releases&quot;,
								&quot;{release_id}&quot;
							]
						},
						&quot;description&quot;: &quot;View the user’s collection folders which contain a specified release. This will also show information about each release instance. The release_id must be non-zero.\n\nAuthentication as the collection owner is required if the owner’s collection is private.\n\n[https://www.discogs.com/developers/#page:user-collection,header:user-collection-collection-items-by-release](https://www.discogs.com/developers/#page:user-collection,header:user-collection-collection-items-by-release)&quot;
					},
					&quot;response&quot;: []
				},
				{
					&quot;name&quot;: &quot;Collection items by folder&quot;,
					&quot;event&quot;: [
						{
							&quot;listen&quot;: &quot;test&quot;,
							&quot;script&quot;: {
								&quot;id&quot;: &quot;5e6c9eeb-a6e7-4edc-9e15-ef801f3c5cbf&quot;,
								&quot;exec&quot;: [
									&quot;&quot;
								],
								&quot;type&quot;: &quot;text/javascript&quot;
							}
						}
					],
					&quot;request&quot;: {
						&quot;method&quot;: &quot;GET&quot;,
						&quot;header&quot;: [
							{
								&quot;key&quot;: &quot;Content-Type&quot;,
								&quot;type&quot;: &quot;text&quot;,
								&quot;value&quot;: &quot;application/x-www-form-urlencoded&quot;
							},
							{
								&quot;key&quot;: &quot;User-Agent&quot;,
								&quot;type&quot;: &quot;text&quot;,
								&quot;value&quot;: &quot;{{user_agent}}&quot;
							}
						],
						&quot;url&quot;: {
							&quot;raw&quot;: &quot;{{url}}/users/{{username}}/collection/folders/{folder_id}/releases?sort={sort}&amp;sort_order={sort_order}&quot;,
							&quot;host&quot;: [
								&quot;{{url}}&quot;
							],
							&quot;path&quot;: [
								&quot;users&quot;,
								&quot;{{username}}&quot;,
								&quot;collection&quot;,
								&quot;folders&quot;,
								&quot;{folder_id}&quot;,
								&quot;releases&quot;
							],
							&quot;query&quot;: [
								{
									&quot;key&quot;: &quot;sort&quot;,
									&quot;value&quot;: &quot;{sort}&quot;,
									&quot;description&quot;: &quot;Sort items by one of these fields: \n• label\n• artist\n• title\n• catno\n• format\n• rating\n• added\n• year&quot;
								},
								{
									&quot;key&quot;: &quot;sort_order&quot;,
									&quot;value&quot;: &quot;{sort_order}&quot;,
									&quot;description&quot;: &quot;Sort items in a particular order (asc or desc)&quot;
								}
							]
						},
						&quot;description&quot;: &quot;Returns the list of item in a folder in a user’s collection. Accepts Pagination parameters.\n\nBasic information about each release is provided, suitable for display in a list. For detailed information, make another API call to fetch the corresponding release.\n\nIf folder_id is not 0, or the collection has been made private by its owner, authentication as the collection owner is required.\n\nIf you are not authenticated as the collection owner, only public notes fields will be visible.\n\n[https://www.discogs.com/developers/#page:user-collection,header:user-collection-collection-items-by-folder](https://www.discogs.com/developers/#page:user-collection,header:user-collection-collection-items-by-folder)&quot;
					},
					&quot;response&quot;: []
				},
				{
					&quot;name&quot;: &quot;Add to collection folder&quot;,
					&quot;event&quot;: [
						{
							&quot;listen&quot;: &quot;test&quot;,
							&quot;script&quot;: {
								&quot;id&quot;: &quot;5e6c9eeb-a6e7-4edc-9e15-ef801f3c5cbf&quot;,
								&quot;exec&quot;: [
									&quot;&quot;
								],
								&quot;type&quot;: &quot;text/javascript&quot;
							}
						}
					],
					&quot;request&quot;: {
						&quot;method&quot;: &quot;POST&quot;,
						&quot;header&quot;: [
							{
								&quot;key&quot;: &quot;Content-Type&quot;,
								&quot;type&quot;: &quot;text&quot;,
								&quot;value&quot;: &quot;application/x-www-form-urlencoded&quot;
							},
							{
								&quot;key&quot;: &quot;User-Agent&quot;,
								&quot;type&quot;: &quot;text&quot;,
								&quot;value&quot;: &quot;{{user_agent}}&quot;
							}
						],
						&quot;body&quot;: {
							&quot;mode&quot;: &quot;raw&quot;,
							&quot;raw&quot;: &quot;&quot;
						},
						&quot;url&quot;: {
							&quot;raw&quot;: &quot;{{url}}/users/{{username}}/collection/folders/{folder_id}/releases/{release_id}&quot;,
							&quot;host&quot;: [
								&quot;{{url}}&quot;
							],
							&quot;path&quot;: [
								&quot;users&quot;,
								&quot;{{username}}&quot;,
								&quot;collection&quot;,
								&quot;folders&quot;,
								&quot;{folder_id}&quot;,
								&quot;releases&quot;,
								&quot;{release_id}&quot;
							]
						},
						&quot;description&quot;: &quot;Add a release to a folder in a user’s collection.\n\nThe folder_id must be non-zero – you can use 1 for “Uncategorized”.\n\nAuthentication as the collection owner is required.\n\n[https://www.discogs.com/developers/#page:user-collection,header:user-collection-add-to-collection-folder](https://www.discogs.com/developers/#page:user-collection,header:user-collection-add-to-collection-folder)&quot;
					},
					&quot;response&quot;: []
				},
				{
					&quot;name&quot;: &quot;Change rating of release&quot;,
					&quot;event&quot;: [
						{
							&quot;listen&quot;: &quot;test&quot;,
							&quot;script&quot;: {
								&quot;id&quot;: &quot;5e6c9eeb-a6e7-4edc-9e15-ef801f3c5cbf&quot;,
								&quot;exec&quot;: [
									&quot;&quot;
								],
								&quot;type&quot;: &quot;text/javascript&quot;
							}
						}
					],
					&quot;request&quot;: {
						&quot;method&quot;: &quot;POST&quot;,
						&quot;header&quot;: [
							{
								&quot;key&quot;: &quot;Content-Type&quot;,
								&quot;type&quot;: &quot;text&quot;,
								&quot;value&quot;: &quot;application/x-www-form-urlencoded&quot;
							},
							{
								&quot;key&quot;: &quot;User-Agent&quot;,
								&quot;type&quot;: &quot;text&quot;,
								&quot;value&quot;: &quot;{{user_agent}}&quot;
							}
						],
						&quot;body&quot;: {
							&quot;mode&quot;: &quot;raw&quot;,
							&quot;raw&quot;: &quot;&quot;
						},
						&quot;url&quot;: {
							&quot;raw&quot;: &quot;{{url}}/users/{{username}}/collection/folders/{folder_id}/releases/{release_id}/instances/{instance_id}&quot;,
							&quot;host&quot;: [
								&quot;{{url}}&quot;
							],
							&quot;path&quot;: [
								&quot;users&quot;,
								&quot;{{username}}&quot;,
								&quot;collection&quot;,
								&quot;folders&quot;,
								&quot;{folder_id}&quot;,
								&quot;releases&quot;,
								&quot;{release_id}&quot;,
								&quot;instances&quot;,
								&quot;{instance_id}&quot;
							]
						},
						&quot;description&quot;: &quot;Change the rating on a release and/or move the instance to another folder.\n\nThis endpoint potentially takes 2 folder_id parameters: one in the URL (which is the folder you are requesting, and is required), and one in the request body (representing the folder you want to move the instance to, which is optional)\n\nAuthentication as the collection owner is required.\n\n[https://www.discogs.com/developers/#page:user-collection,header:user-collection-change-rating-of-release](https://www.discogs.com/developers/#page:user-collection,header:user-collection-change-rating-of-release)&quot;
					},
					&quot;response&quot;: []
				},
				{
					&quot;name&quot;: &quot;Delete instance from folder&quot;,
					&quot;event&quot;: [
						{
							&quot;listen&quot;: &quot;test&quot;,
							&quot;script&quot;: {
								&quot;id&quot;: &quot;5e6c9eeb-a6e7-4edc-9e15-ef801f3c5cbf&quot;,
								&quot;exec&quot;: [
									&quot;&quot;
								],
								&quot;type&quot;: &quot;text/javascript&quot;
							}
						}
					],
					&quot;request&quot;: {
						&quot;method&quot;: &quot;DELETE&quot;,
						&quot;header&quot;: [
							{
								&quot;key&quot;: &quot;Content-Type&quot;,
								&quot;type&quot;: &quot;text&quot;,
								&quot;value&quot;: &quot;application/x-www-form-urlencoded&quot;
							},
							{
								&quot;key&quot;: &quot;User-Agent&quot;,
								&quot;type&quot;: &quot;text&quot;,
								&quot;value&quot;: &quot;{{user_agent}}&quot;
							}
						],
						&quot;body&quot;: {
							&quot;mode&quot;: &quot;raw&quot;,
							&quot;raw&quot;: &quot;&quot;
						},
						&quot;url&quot;: {
							&quot;raw&quot;: &quot;{{url}}/users/{{username}}/collection/folders/{folder_id}/releases/{release_id}/instances/{instance_id}&quot;,
							&quot;host&quot;: [
								&quot;{{url}}&quot;
							],
							&quot;path&quot;: [
								&quot;users&quot;,
								&quot;{{username}}&quot;,
								&quot;collection&quot;,
								&quot;folders&quot;,
								&quot;{folder_id}&quot;,
								&quot;releases&quot;,
								&quot;{release_id}&quot;,
								&quot;instances&quot;,
								&quot;{instance_id}&quot;
							]
						},
						&quot;description&quot;: &quot;Remove an instance of a release from a user’s collection folder.\n\nTo move the release to the “Uncategorized” folder instead, use the POST method.\n\nAuthentication as the collection owner is required.\n\n[https://www.discogs.com/developers/#page:user-collection,header:user-collection-delete-instance-from-folder](https://www.discogs.com/developers/#page:user-collection,header:user-collection-delete-instance-from-folder)&quot;
					},
					&quot;response&quot;: []
				},
				{
					&quot;name&quot;: &quot;List custom fields&quot;,
					&quot;event&quot;: [
						{
							&quot;listen&quot;: &quot;test&quot;,
							&quot;script&quot;: {
								&quot;id&quot;: &quot;5e6c9eeb-a6e7-4edc-9e15-ef801f3c5cbf&quot;,
								&quot;exec&quot;: [
									&quot;&quot;
								],
								&quot;type&quot;: &quot;text/javascript&quot;
							}
						}
					],
					&quot;request&quot;: {
						&quot;method&quot;: &quot;GET&quot;,
						&quot;header&quot;: [
							{
								&quot;key&quot;: &quot;Content-Type&quot;,
								&quot;type&quot;: &quot;text&quot;,
								&quot;value&quot;: &quot;application/x-www-form-urlencoded&quot;
							},
							{
								&quot;key&quot;: &quot;User-Agent&quot;,
								&quot;type&quot;: &quot;text&quot;,
								&quot;value&quot;: &quot;{{user_agent}}&quot;
							}
						],
						&quot;url&quot;: {
							&quot;raw&quot;: &quot;{{url}}/users/{{username}}/collection/folders/{folder_id}&quot;,
							&quot;host&quot;: [
								&quot;{{url}}&quot;
							],
							&quot;path&quot;: [
								&quot;users&quot;,
								&quot;{{username}}&quot;,
								&quot;collection&quot;,
								&quot;folders&quot;,
								&quot;{folder_id}&quot;
							]
						},
						&quot;description&quot;: &quot;Retrieve a list of user-defined collection notes fields. These fields are available on every release in the collection.\n\nIf the collection has been made private by its owner, authentication as the collection owner is required.\n\nIf you are not authenticated as the collection owner, only fields with public set to true will be visible.\n\n[https://www.discogs.com/developers/#page:user-collection,header:user-collection-list-custom-fields](https://www.discogs.com/developers/#page:user-collection,header:user-collection-list-custom-fields)&quot;
					},
					&quot;response&quot;: []
				},
				{
					&quot;name&quot;: &quot;Edit fields instance&quot;,
					&quot;event&quot;: [
						{
							&quot;listen&quot;: &quot;test&quot;,
							&quot;script&quot;: {
								&quot;id&quot;: &quot;5e6c9eeb-a6e7-4edc-9e15-ef801f3c5cbf&quot;,
								&quot;exec&quot;: [
									&quot;&quot;
								],
								&quot;type&quot;: &quot;text/javascript&quot;
							}
						}
					],
					&quot;request&quot;: {
						&quot;method&quot;: &quot;POST&quot;,
						&quot;header&quot;: [
							{
								&quot;key&quot;: &quot;Content-Type&quot;,
								&quot;type&quot;: &quot;text&quot;,
								&quot;value&quot;: &quot;application/x-www-form-urlencoded&quot;
							},
							{
								&quot;key&quot;: &quot;User-Agent&quot;,
								&quot;type&quot;: &quot;text&quot;,
								&quot;value&quot;: &quot;{{user_agent}}&quot;
							}
						],
						&quot;body&quot;: {
							&quot;mode&quot;: &quot;raw&quot;,
							&quot;raw&quot;: &quot;&quot;
						},
						&quot;url&quot;: {
							&quot;raw&quot;: &quot;{{url}}/users/{{username}}/collection/folders/{folder_id}/releases/{release_id}/instances/{instance_id}/fields/{field_id}{?value}&quot;,
							&quot;host&quot;: [
								&quot;{{url}}&quot;
							],
							&quot;path&quot;: [
								&quot;users&quot;,
								&quot;{{username}}&quot;,
								&quot;collection&quot;,
								&quot;folders&quot;,
								&quot;{folder_id}&quot;,
								&quot;releases&quot;,
								&quot;{release_id}&quot;,
								&quot;instances&quot;,
								&quot;{instance_id}&quot;,
								&quot;fields&quot;,
								&quot;{field_id}{&quot;
							],
							&quot;query&quot;: [
								{
									&quot;key&quot;: &quot;value}&quot;,
									&quot;value&quot;: null
								}
							]
						},
						&quot;description&quot;: &quot;Change the value of a notes field on a particular instance.\n\n[https://www.discogs.com/developers/#page:user-collection,header:user-collection-edit-fields-instance](https://www.discogs.com/developers/#page:user-collection,header:user-collection-edit-fields-instance)&quot;
					},
					&quot;response&quot;: []
				},
				{
					&quot;name&quot;: &quot;Collection value&quot;,
					&quot;event&quot;: [
						{
							&quot;listen&quot;: &quot;test&quot;,
							&quot;script&quot;: {
								&quot;id&quot;: &quot;5e6c9eeb-a6e7-4edc-9e15-ef801f3c5cbf&quot;,
								&quot;exec&quot;: [
									&quot;&quot;
								],
								&quot;type&quot;: &quot;text/javascript&quot;
							}
						}
					],
					&quot;request&quot;: {
						&quot;method&quot;: &quot;GET&quot;,
						&quot;header&quot;: [
							{
								&quot;key&quot;: &quot;Content-Type&quot;,
								&quot;type&quot;: &quot;text&quot;,
								&quot;value&quot;: &quot;application/x-www-form-urlencoded&quot;
							},
							{
								&quot;key&quot;: &quot;User-Agent&quot;,
								&quot;type&quot;: &quot;text&quot;,
								&quot;value&quot;: &quot;{{user_agent}}&quot;
							}
						],
						&quot;url&quot;: {
							&quot;raw&quot;: &quot;{{url}}/users/{{username}}/collection/value&quot;,
							&quot;host&quot;: [
								&quot;{{url}}&quot;
							],
							&quot;path&quot;: [
								&quot;users&quot;,
								&quot;{{username}}&quot;,
								&quot;collection&quot;,
								&quot;value&quot;
							]
						},
						&quot;description&quot;: &quot;Returns the minimum, median, and maximum value of a user’s collection.\n\nAuthentication as the collection owner is required.\n\n[https://www.discogs.com/developers/#page:user-collection,header:user-collection-collection-value](https://www.discogs.com/developers/#page:user-collection,header:user-collection-collection-value)&quot;
					},
					&quot;response&quot;: []
				}
			],
			&quot;description&quot;: &quot;Visit [https://www.discogs.com/developers/#page:user-collection](https://www.discogs.com/developers/#page:user-collection) for full documentation.&quot;,
			&quot;event&quot;: [
				{
					&quot;listen&quot;: &quot;prerequest&quot;,
					&quot;script&quot;: {
						&quot;id&quot;: &quot;8f318760-6386-44db-8aec-a9ee1559f23e&quot;,
						&quot;type&quot;: &quot;text/javascript&quot;,
						&quot;exec&quot;: [
							&quot;&quot;
						]
					}
				},
				{
					&quot;listen&quot;: &quot;test&quot;,
					&quot;script&quot;: {
						&quot;id&quot;: &quot;6677de9a-c742-4000-a9ae-af3d7a8c3cc9&quot;,
						&quot;type&quot;: &quot;text/javascript&quot;,
						&quot;exec&quot;: [
							&quot;&quot;
						]
					}
				}
			],
			&quot;protocolProfileBehavior&quot;: {}
		},
		{
			&quot;name&quot;: &quot;User Wantlist&quot;,
			&quot;item&quot;: [
				{
					&quot;name&quot;: &quot;Wantlist&quot;,
					&quot;event&quot;: [
						{
							&quot;listen&quot;: &quot;test&quot;,
							&quot;script&quot;: {
								&quot;id&quot;: &quot;5e6c9eeb-a6e7-4edc-9e15-ef801f3c5cbf&quot;,
								&quot;exec&quot;: [
									&quot;&quot;
								],
								&quot;type&quot;: &quot;text/javascript&quot;
							}
						}
					],
					&quot;request&quot;: {
						&quot;method&quot;: &quot;GET&quot;,
						&quot;header&quot;: [
							{
								&quot;key&quot;: &quot;Content-Type&quot;,
								&quot;type&quot;: &quot;text&quot;,
								&quot;value&quot;: &quot;application/x-www-form-urlencoded&quot;
							},
							{
								&quot;key&quot;: &quot;User-Agent&quot;,
								&quot;type&quot;: &quot;text&quot;,
								&quot;value&quot;: &quot;{{user_agent}}&quot;
							}
						],
						&quot;url&quot;: {
							&quot;raw&quot;: &quot;{{url}}/users/{{username}}/wants&quot;,
							&quot;host&quot;: [
								&quot;{{url}}&quot;
							],
							&quot;path&quot;: [
								&quot;users&quot;,
								&quot;{{username}}&quot;,
								&quot;wants&quot;
							]
						},
						&quot;description&quot;: &quot;Returns the list of releases in a user’s wantlist. Accepts Pagination parameters.\n\nBasic information about each release is provided, suitable for display in a list. For detailed information, make another API call to fetch the corresponding release.\n\nIf the wantlist has been made private by its owner, you must be authenticated as the owner to view it.\n\nThe notes field will be visible if you are authenticated as the wantlist owner.\n\n[https://www.discogs.com/developers/#page:user-wantlist,header:user-wantlist-wantlist](https://www.discogs.com/developers/#page:user-wantlist,header:user-wantlist-wantlist)&quot;
					},
					&quot;response&quot;: []
				},
				{
					&quot;name&quot;: &quot;Add to wantlist&quot;,
					&quot;event&quot;: [
						{
							&quot;listen&quot;: &quot;test&quot;,
							&quot;script&quot;: {
								&quot;id&quot;: &quot;5e6c9eeb-a6e7-4edc-9e15-ef801f3c5cbf&quot;,
								&quot;exec&quot;: [
									&quot;&quot;
								],
								&quot;type&quot;: &quot;text/javascript&quot;
							}
						}
					],
					&quot;request&quot;: {
						&quot;method&quot;: &quot;POST&quot;,
						&quot;header&quot;: [
							{
								&quot;key&quot;: &quot;Content-Type&quot;,
								&quot;name&quot;: &quot;Content-Type&quot;,
								&quot;value&quot;: &quot;application/json&quot;,
								&quot;type&quot;: &quot;text&quot;
							},
							{
								&quot;key&quot;: &quot;User-Agent&quot;,
								&quot;type&quot;: &quot;text&quot;,
								&quot;value&quot;: &quot;{{user_agent}}&quot;
							}
						],
						&quot;body&quot;: {
							&quot;mode&quot;: &quot;raw&quot;,
							&quot;raw&quot;: &quot;&quot;
						},
						&quot;url&quot;: {
							&quot;raw&quot;: &quot;{{url}}/users/{{username}}/wants/{release_id}&quot;,
							&quot;host&quot;: [
								&quot;{{url}}&quot;
							],
							&quot;path&quot;: [
								&quot;users&quot;,
								&quot;{{username}}&quot;,
								&quot;wants&quot;,
								&quot;{release_id}&quot;
							]
						},
						&quot;description&quot;: &quot;Add a release to a user’s wantlist. Additional parameters must be send as JSON object inside the request body.\n\nAuthentication as the wantlist owner is required.\n\n[https://www.discogs.com/developers/#page:user-wantlist,header:user-wantlist-add-to-wantlist](https://www.discogs.com/developers/#page:user-wantlist,header:user-wantlist-add-to-wantlist)&quot;
					},
					&quot;response&quot;: []
				},
				{
					&quot;name&quot;: &quot;Delete release from wantlist&quot;,
					&quot;event&quot;: [
						{
							&quot;listen&quot;: &quot;test&quot;,
							&quot;script&quot;: {
								&quot;id&quot;: &quot;5e6c9eeb-a6e7-4edc-9e15-ef801f3c5cbf&quot;,
								&quot;exec&quot;: [
									&quot;&quot;
								],
								&quot;type&quot;: &quot;text/javascript&quot;
							}
						}
					],
					&quot;request&quot;: {
						&quot;method&quot;: &quot;DELETE&quot;,
						&quot;header&quot;: [
							{
								&quot;key&quot;: &quot;Content-Type&quot;,
								&quot;name&quot;: &quot;Content-Type&quot;,
								&quot;type&quot;: &quot;text&quot;,
								&quot;value&quot;: &quot;application/json&quot;
							},
							{
								&quot;key&quot;: &quot;User-Agent&quot;,
								&quot;type&quot;: &quot;text&quot;,
								&quot;value&quot;: &quot;{{user_agent}}&quot;
							}
						],
						&quot;body&quot;: {
							&quot;mode&quot;: &quot;raw&quot;,
							&quot;raw&quot;: &quot;&quot;
						},
						&quot;url&quot;: {
							&quot;raw&quot;: &quot;{{url}}/users/{{username}}/wants/{release_id}&quot;,
							&quot;host&quot;: [
								&quot;{{url}}&quot;
							],
							&quot;path&quot;: [
								&quot;users&quot;,
								&quot;{{username}}&quot;,
								&quot;wants&quot;,
								&quot;{release_id}&quot;
							]
						},
						&quot;description&quot;: &quot;Delete a release from a user’s wantlist.\n\nAuthentication as the wantlist owner is required.\n\n[https://www.discogs.com/developers/#page:user-wantlist,header:user-wantlist-add-to-wantlist](https://www.discogs.com/developers/#page:user-wantlist,header:user-wantlist-add-to-wantlist)&quot;
					},
					&quot;response&quot;: []
				}
			],
			&quot;description&quot;: &quot;Visit [https://www.discogs.com/developers/#page:user-wantlist](https://www.discogs.com/developers/#page:user-wantlist) for full documentation.&quot;,
			&quot;event&quot;: [
				{
					&quot;listen&quot;: &quot;prerequest&quot;,
					&quot;script&quot;: {
						&quot;id&quot;: &quot;0f194711-ec15-47fe-b647-58673517ba2f&quot;,
						&quot;type&quot;: &quot;text/javascript&quot;,
						&quot;exec&quot;: [
							&quot;&quot;
						]
					}
				},
				{
					&quot;listen&quot;: &quot;test&quot;,
					&quot;script&quot;: {
						&quot;id&quot;: &quot;109e7ea0-29fc-4bfc-9c89-eaf4f9346a71&quot;,
						&quot;type&quot;: &quot;text/javascript&quot;,
						&quot;exec&quot;: [
							&quot;&quot;
						]
					}
				}
			],
			&quot;protocolProfileBehavior&quot;: {}
		},
		{
			&quot;name&quot;: &quot;User Lists&quot;,
			&quot;item&quot;: [
				{
					&quot;name&quot;: &quot;User Lists&quot;,
					&quot;event&quot;: [
						{
							&quot;listen&quot;: &quot;test&quot;,
							&quot;script&quot;: {
								&quot;id&quot;: &quot;5e6c9eeb-a6e7-4edc-9e15-ef801f3c5cbf&quot;,
								&quot;exec&quot;: [
									&quot;&quot;
								],
								&quot;type&quot;: &quot;text/javascript&quot;
							}
						}
					],
					&quot;request&quot;: {
						&quot;method&quot;: &quot;GET&quot;,
						&quot;header&quot;: [
							{
								&quot;key&quot;: &quot;Content-Type&quot;,
								&quot;type&quot;: &quot;text&quot;,
								&quot;value&quot;: &quot;application/x-www-form-urlencoded&quot;
							},
							{
								&quot;key&quot;: &quot;User-Agent&quot;,
								&quot;type&quot;: &quot;text&quot;,
								&quot;value&quot;: &quot;{{user_agent}}&quot;
							}
						],
						&quot;url&quot;: {
							&quot;raw&quot;: &quot;{{url}}/users/{{username}}/lists&quot;,
							&quot;host&quot;: [
								&quot;{{url}}&quot;
							],
							&quot;path&quot;: [
								&quot;users&quot;,
								&quot;{{username}}&quot;,
								&quot;lists&quot;
							]
						},
						&quot;description&quot;: &quot;Returns a User’s Lists. Private Lists will only display when authenticated as the owner. Accepts Pagination parameters.\n\n[https://www.discogs.com/developers/#page:user-lists,header:user-lists-user-lists](https://www.discogs.com/developers/#page:user-lists,header:user-lists-user-lists)&quot;
					},
					&quot;response&quot;: []
				},
				{
					&quot;name&quot;: &quot;List&quot;,
					&quot;event&quot;: [
						{
							&quot;listen&quot;: &quot;test&quot;,
							&quot;script&quot;: {
								&quot;id&quot;: &quot;5e6c9eeb-a6e7-4edc-9e15-ef801f3c5cbf&quot;,
								&quot;exec&quot;: [
									&quot;&quot;
								],
								&quot;type&quot;: &quot;text/javascript&quot;
							}
						}
					],
					&quot;request&quot;: {
						&quot;method&quot;: &quot;GET&quot;,
						&quot;header&quot;: [
							{
								&quot;key&quot;: &quot;Content-Type&quot;,
								&quot;type&quot;: &quot;text&quot;,
								&quot;value&quot;: &quot;application/x-www-form-urlencoded&quot;
							},
							{
								&quot;key&quot;: &quot;User-Agent&quot;,
								&quot;type&quot;: &quot;text&quot;,
								&quot;value&quot;: &quot;{{user_agent}}&quot;
							}
						],
						&quot;url&quot;: {
							&quot;raw&quot;: &quot;{{url}}/lists/{list_id}&quot;,
							&quot;host&quot;: [
								&quot;{{url}}&quot;
							],
							&quot;path&quot;: [
								&quot;lists&quot;,
								&quot;{list_id}&quot;
							]
						},
						&quot;description&quot;: &quot;Returns items from a specified List. Private Lists will only display when authenticated as the owner.\n\n[https://www.discogs.com/developers/#page:user-lists,header:user-lists-list](https://www.discogs.com/developers/#page:user-lists,header:user-lists-list)&quot;
					},
					&quot;response&quot;: []
				}
			],
			&quot;description&quot;: &quot;Visit [https://www.discogs.com/developers/#page:user-lists](https://www.discogs.com/developers/#page:user-lists) for full documentation.&quot;,
			&quot;event&quot;: [
				{
					&quot;listen&quot;: &quot;prerequest&quot;,
					&quot;script&quot;: {
						&quot;id&quot;: &quot;dd86cb37-83bd-4b83-a467-71d02f8c2634&quot;,
						&quot;type&quot;: &quot;text/javascript&quot;,
						&quot;exec&quot;: [
							&quot;&quot;
						]
					}
				},
				{
					&quot;listen&quot;: &quot;test&quot;,
					&quot;script&quot;: {
						&quot;id&quot;: &quot;eb7fb672-1450-4fb1-a339-b1f3a2998308&quot;,
						&quot;type&quot;: &quot;text/javascript&quot;,
						&quot;exec&quot;: [
							&quot;&quot;
						]
					}
				}
			],
			&quot;protocolProfileBehavior&quot;: {}
		}
	],
	&quot;auth&quot;: {
		&quot;type&quot;: &quot;oauth1&quot;,
		&quot;oauth1&quot;: [
			{
				&quot;key&quot;: &quot;consumerSecret&quot;,
				&quot;value&quot;: &quot;{{consumer_secret}}&quot;,
				&quot;type&quot;: &quot;string&quot;
			},
			{
				&quot;key&quot;: &quot;consumerKey&quot;,
				&quot;value&quot;: &quot;{{consumer_key}}&quot;,
				&quot;type&quot;: &quot;string&quot;
			},
			{
				&quot;key&quot;: &quot;nonce&quot;,
				&quot;value&quot;: &quot;{{$guid}}&quot;,
				&quot;type&quot;: &quot;string&quot;
			},
			{
				&quot;key&quot;: &quot;timestamp&quot;,
				&quot;value&quot;: &quot;{{$timestamp}}&quot;,
				&quot;type&quot;: &quot;string&quot;
			},
			{
				&quot;key&quot;: &quot;addParamsToHeader&quot;,
				&quot;value&quot;: true,
				&quot;type&quot;: &quot;boolean&quot;
			},
			{
				&quot;key&quot;: &quot;signatureMethod&quot;,
				&quot;value&quot;: &quot;PLAINTEXT&quot;,
				&quot;type&quot;: &quot;string&quot;
			},
			{
				&quot;key&quot;: &quot;tokenSecret&quot;,
				&quot;value&quot;: &quot;{{oauth_token_secret}}&quot;,
				&quot;type&quot;: &quot;string&quot;
			},
			{
				&quot;key&quot;: &quot;token&quot;,
				&quot;value&quot;: &quot;{{oauth_token}}&quot;,
				&quot;type&quot;: &quot;string&quot;
			},
			{
				&quot;key&quot;: &quot;version&quot;,
				&quot;value&quot;: &quot;1.0&quot;,
				&quot;type&quot;: &quot;string&quot;
			},
			{
				&quot;key&quot;: &quot;addEmptyParamsToSign&quot;,
				&quot;value&quot;: false,
				&quot;type&quot;: &quot;boolean&quot;
			}
		]
	},
	&quot;event&quot;: [
		{
			&quot;listen&quot;: &quot;prerequest&quot;,
			&quot;script&quot;: {
				&quot;id&quot;: &quot;dddb7f7d-1885-4b0c-89a3-bed704dfd753&quot;,
				&quot;type&quot;: &quot;text/javascript&quot;,
				&quot;exec&quot;: [
					&quot;&quot;
				]
			}
		},
		{
			&quot;listen&quot;: &quot;test&quot;,
			&quot;script&quot;: {
				&quot;id&quot;: &quot;0bbbaf35-766b-4c94-99ea-7cc979cc16dd&quot;,
				&quot;type&quot;: &quot;text/javascript&quot;,
				&quot;exec&quot;: [
					&quot;&quot;
				]
			}
		}
	],
	&quot;protocolProfileBehavior&quot;: {}
}</file><file path="docker-compose-prod.yml">services:
  nginx:
    image: martinjuul/baander-nginx:latest
    container_name: baander-nginx
    build:
      context: ./docker/
      args:
        BUILD_ARGUMENT_ENV: prod
      dockerfile: ./nginx/Dockerfile
    restart: unless-stopped
    ports:
      - &quot;${WEB_PORT_HTTP}:80&quot;
    networks:
      - baander-backtier
    volumes:
      - ./:/var/www/html:ro,cached
    depends_on:
      - app
  app: &amp;app-template
    image: martinjuul/baander-app:latest
    container_name: baander-app
    restart: unless-stopped
    build:
      context: .
      args:
        BUILD_ARGUMENT_ENV: prod
        HOST_UID: ${HOST_UID}
        HOST_GID: ${HOST_GID}
      dockerfile: ./Dockerfile
    networks:
      - baander-backtier
  supervisord:
    &lt;&lt;: *app-template
    container_name: baander-scheduler
    expose: []
    command: [&quot;/usr/bin/supervisord&quot;]
networks:
  baander-backtier:
    name: baander-backtier</file><file path="docker/dev/ca.crt">-----BEGIN CERTIFICATE-----
MIIDSjCCAjKgAwIBAgIVAPyCrItydf1MYF3gZyxauncll7KHMA0GCSqGSIb3DQEB
CwUAMDQxMjAwBgNVBAMTKUVsYXN0aWMgQ2VydGlmaWNhdGUgVG9vbCBBdXRvZ2Vu
ZXJhdGVkIENBMB4XDTI1MDYwODE1MzQxM1oXDTI4MDYwNzE1MzQxM1owNDEyMDAG
A1UEAxMpRWxhc3RpYyBDZXJ0aWZpY2F0ZSBUb29sIEF1dG9nZW5lcmF0ZWQgQ0Ew
ggEiMA0GCSqGSIb3DQEBAQUAA4IBDwAwggEKAoIBAQDKrjlfBlGYXNb9Mu0H7Vrp
kj2w/iT+PmXG6ZRD/FmIcajBVSQqVWUMEcZlT8Jn4uZQ4E5L3Yi3H4Bu1Cj8kEfR
VnFIFFyQBngU6XmZeLeytyGbzpf1mtk6ZdX0IWPYOPJD3CsYqAhOVznkbEaBSuel
jPioG/pnb25Gue51crG61IMt65U02145Exvk0aZrprpBWqFxhhPY4WHeNuOXlIjg
dNtfusRGIGq9JUEFfBL8OatPLW7m9dlxv0db/SSDKpcarq0q9fdxOKbb18vg3mbt
htVGP5EEg2e4crNQ274xeISPPDJvxQV04o0cPYWq2/AL9OTZNeFOqX3mXUFGlOtN
AgMBAAGjUzBRMB0GA1UdDgQWBBRpoH4jVZzk1pQgk0otH5A0uAlI/jAfBgNVHSME
GDAWgBRpoH4jVZzk1pQgk0otH5A0uAlI/jAPBgNVHRMBAf8EBTADAQH/MA0GCSqG
SIb3DQEBCwUAA4IBAQABhNxJsmqRGcJgGL8Mv+RQkwj0wPMD0ST8h7odxM6JHoVK
praRo3JClxPOeGnYwiJj6bT6VwZ8jAmTQh2r2pime2HRgK03f4qLqKDJGBLj+fEw
NXtbOWd/r4BC/pEuLan4JUWcVpc67yHoJHZn5MPcWEHAfjrM3Lx3/8kzbEN2SOiE
ZvcGgXYIT7Go9SxE+C+ez7wNjc5rd/+s9FdCK0N2Eb5RM+LBxRi8WHPAptwEYsDb
qwIIj9FAH8LBO0FFrmybGtWXR1RHXHBiHpbJnzhreIAGJhCp8ZPd4aCVPHVUWeVe
ym7EII0xw8GT6TppRXDcGam7qkwuZAntAjyf+PLo
-----END CERTIFICATE-----</file><file path="docker/dev/www.conf">[www]
user = www-data
group = www-data
listen = *:9000
pm = ondemand
pm.max_children = 150
pm.start_servers = 10
pm.min_spare_servers = 10
pm.max_spare_servers = 20
pm.process_idle_timeout = 1200s
pm.max_requests = 100
request_terminate_timeout = 1200s
request_slowlog_timeout = 800s
slowlog = /proc/self/fd/2</file><file path="docker/dev/xdebug-main.ini">[PHP]
zend_extension=xdebug

xdebug.client_port = 10000
xdebug.file_link_format = phpstorm://open?%f:%l
xdebug.discover_client_host = 1
xdebug.max_nesting_level = 10000
xdebug.mode = profile
xdebug.start_with_request = trigger
xdebug.trigger_value=triggerprofile
xdebug.client_host=host.docker.internal</file><file path="docker/dev/xdebug-osx.ini">[PHP]
zend_extension=xdebug

xdebug.mode = coverage,debug
xdebug.client_port = 10000
#xdebug.client_host = host.docker.internal
xdebug.idekey = PHPSTORM
#xdebug.show_error_trace = 1
xdebug.start_with_request = no
xdebug.file_link_format = phpstorm://open?%f:%l
xdebug.discover_client_host= 0
xdebug.max_nesting_level = 10000
xdebug.log_level = 0
xdebug.extended_info = On</file><file path="docker/ffmpeg/Dockerfile">FROM debian:bookworm AS builder

RUN set -xe \
    &amp;&amp; DEBIAN_FRONTEND=noninteractive apt-get update -qq \
    &amp;&amp; DEBIAN_FRONTEND=noninteractive apt-get upgrade -yqq \
    &amp;&amp; DEBIAN_FRONTEND=noninteractive apt-get install -yqq -o=Dpkg::Use-Pty=0 \
      build-essential \
      ca-certificates \
      curl \
      python3 \
      python-is-python3 \
      ninja-build \
      meson \
      git

WORKDIR /usr/src

RUN set -xe \
    &amp;&amp; update-ca-certificates \
    &amp;&amp; git clone --depth 1 https://github.com/markus-perl/ffmpeg-build-script.git \
    &amp;&amp; cd ffmpeg-build-script \
    &amp;&amp; ./build-ffmpeg --enable-gpl-and-non-free --build --full-static

#COPY --from=builder /usr/src/ffmpeg-build-script/bin/ffmpeg /ffmpeg
#COPY --from=builder /usr/src/ffmpeg-build-script/bin/ffprobe /ffprobe
#COPY --from=builder /usr/src/ffmpeg-build-script/bin/ffplay /ffplay
#
#CMD         [&quot;--help&quot;]
#ENTRYPOINT  [&quot;/ffmpeg&quot;]</file><file path="docker/general/do_we_need_xdebug.sh">#!/bin/bash -x
if [ &quot;$ENV&quot; == &quot;dev&quot; ] || [ &quot;$ENV&quot; == &quot;test&quot; ]; then
    pecl install xdebug-$XDEBUG_VERSION
    mv /tmp/xdebug.ini /usr/local/etc/php/conf.d/
else
    rm /tmp/xdebug.ini
fi</file><file path="docs/assets/baander-logo.svg">&lt;?xml version=&quot;1.0&quot; encoding=&quot;iso-8859-1&quot;?&gt;
&lt;!-- Uploaded to: SVG Repo, www.svgrepo.com, Generator: SVG Repo Mixer Tools --&gt;
&lt;svg height=&quot;800px&quot; width=&quot;800px&quot; version=&quot;1.1&quot; id=&quot;Layer_1&quot; xmlns=&quot;http://www.w3.org/2000/svg&quot; xmlns:xlink=&quot;http://www.w3.org/1999/xlink&quot; 
	 viewBox=&quot;0 0 512 512&quot; xml:space=&quot;preserve&quot;&gt;
&lt;path style=&quot;fill:#F9D84E;&quot; d=&quot;M503.172,406.069H8.828c-4.875,0-8.828-3.953-8.828-8.828V233.122l11.034-60.98h489.931L512,230.498
	v166.743C512,402.116,508.047,406.069,503.172,406.069z&quot;/&gt;
&lt;path id=&quot;SVGCleanerId_0&quot; style=&quot;fill:#4E5058;&quot; d=&quot;M512,238.345h-17.655l-35.31-61.793H52.966l-35.31,61.793H0V114.759
	c0-4.875,3.953-8.828,8.828-8.828h494.345c4.875,0,8.828,3.953,8.828,8.828V238.345z&quot;/&gt;
&lt;path style=&quot;fill:#FFC20D;&quot; d=&quot;M22.069,388.414c-2.438,0-4.414-1.976-4.414-4.414V105.931H8.828c-4.875,0-8.828,3.953-8.828,8.828
	v282.483c0,4.875,3.953,8.828,8.828,8.828h494.345c4.875,0,8.828-3.953,8.828-8.828v-8.828H22.069z&quot;/&gt;
&lt;g&gt;
	&lt;path id=&quot;SVGCleanerId_0_1_&quot; style=&quot;fill:#4E5058;&quot; d=&quot;M512,238.345h-17.655l-35.31-61.793H52.966l-35.31,61.793H0V114.759
		c0-4.875,3.953-8.828,8.828-8.828h494.345c4.875,0,8.828,3.953,8.828,8.828V238.345z&quot;/&gt;
&lt;/g&gt;
&lt;path style=&quot;fill:#383A43;&quot; d=&quot;M26.483,105.931H8.828c-4.875,0-8.828,3.953-8.828,8.828v123.586h17.655V114.759
	C17.655,109.884,21.608,105.931,26.483,105.931z&quot;/&gt;
&lt;path style=&quot;fill:#F9D84E;&quot; d=&quot;M300.138,353.103h-88.276c-9.751,0-17.655-7.904-17.655-17.655v-88.276
	c0-9.751,7.904-17.655,17.655-17.655h88.276c9.751,0,17.655,7.904,17.655,17.655v88.276
	C317.793,345.199,309.889,353.103,300.138,353.103z&quot;/&gt;
&lt;path id=&quot;SVGCleanerId_1&quot; style=&quot;fill:#45CAE0;&quot; d=&quot;M317.793,247.172c0-9.751-7.904-17.655-17.655-17.655h-88.276
	c-9.751,0-17.655,7.904-17.655,17.655v18.391h123.586V247.172z&quot;/&gt;
&lt;path style=&quot;fill:#E9E9EA;&quot; d=&quot;M300.138,353.103h-88.276c-9.751,0-17.655-7.904-17.655-17.655v-88.276
	c0-9.751,7.904-17.655,17.655-17.655h88.276c9.751,0,17.655,7.904,17.655,17.655v88.276
	C317.793,345.199,309.889,353.103,300.138,353.103z&quot;/&gt;
&lt;g&gt;
	&lt;path id=&quot;SVGCleanerId_1_1_&quot; style=&quot;fill:#45CAE0;&quot; d=&quot;M317.793,247.172c0-9.751-7.904-17.655-17.655-17.655h-88.276
		c-9.751,0-17.655,7.904-17.655,17.655v18.391h123.586V247.172z&quot;/&gt;
&lt;/g&gt;
&lt;g&gt;
	&lt;path style=&quot;fill:#BDBDC0;&quot; d=&quot;M282.483,300.138h-52.966c-4.875,0-8.828-3.953-8.828-8.828s3.953-8.828,8.828-8.828h52.966
		c4.875,0,8.828,3.953,8.828,8.828S287.358,300.138,282.483,300.138z&quot;/&gt;
	&lt;path style=&quot;fill:#BDBDC0;&quot; d=&quot;M282.483,326.621h-52.966c-4.875,0-8.828-3.953-8.828-8.828s3.953-8.828,8.828-8.828h52.966
		c4.875,0,8.828,3.953,8.828,8.828S287.358,326.621,282.483,326.621z&quot;/&gt;
&lt;/g&gt;
&lt;g&gt;
	&lt;path style=&quot;fill:#E9E9EA;&quot; d=&quot;M97.103,370.759h70.621c4.875,0,8.828-3.953,8.828-8.828V220.69c0-4.875-3.953-8.828-8.828-8.828
		H97.103c-24.376,0-44.138,19.762-44.138,44.138v70.621C52.966,350.997,72.727,370.759,97.103,370.759z&quot;/&gt;
	&lt;path style=&quot;fill:#E9E9EA;&quot; d=&quot;M414.897,370.759h-70.621c-4.875,0-8.828-3.953-8.828-8.828V220.69c0-4.875,3.953-8.828,8.828-8.828
		h70.621c24.376,0,44.138,19.762,44.138,44.138v70.621C459.034,350.997,439.273,370.759,414.897,370.759z&quot;/&gt;
&lt;/g&gt;
&lt;path style=&quot;fill:#BDBDC0;&quot; d=&quot;M406.253,291.31c0-39.002-31.801-70.621-70.805-70.621v141.241
	C374.451,361.931,406.253,330.313,406.253,291.31z&quot;/&gt;
&lt;path style=&quot;fill:#64666D;&quot; d=&quot;M335.448,353.103c34.127,0,61.977-27.666,61.977-61.793s-27.85-61.793-61.977-61.793
	c-0.062,0,0,0.004,0,0.004v26.483c0,0-0.062-0.004,0-0.004c19.501,0,33.288,15.809,33.288,35.31c0,19.501-13.786,35.31-33.288,35.31
	c-0.062,0,0-0.004,0-0.004v26.483C335.448,353.099,335.386,353.103,335.448,353.103z&quot;/&gt;
&lt;path style=&quot;fill:#A7A7AB;&quot; d=&quot;M335.448,273.655c9.751,0,17.839,7.904,17.839,17.655c0,9.751-8.088,17.655-17.839,17.655
	c-0.062,0,0.062-0.009,0-0.009v17.66c0.062,0-0.062,0.004,0,0.004c19.501,0,35.495-15.809,35.495-35.31
	c0-19.501-15.993-35.31-35.495-35.31c-0.062,0,0.062,0.004,0,0.004v17.66C335.51,273.664,335.386,273.655,335.448,273.655z&quot;/&gt;
&lt;path style=&quot;fill:#BDBDC0;&quot; d=&quot;M105.931,291.31c0,39.003,31.801,70.621,70.805,70.621V220.69
	C137.732,220.69,105.931,252.308,105.931,291.31z&quot;/&gt;
&lt;path style=&quot;fill:#64666D;&quot; d=&quot;M176.552,229.517c-34.207,0-62.023,27.666-62.023,61.793s27.816,61.793,62.023,61.793v-0.004v-26.483
	v0.004c-19.862,0-33.333-15.809-33.333-35.31c0-19.501,13.471-35.31,33.333-35.31v0.004v-26.483V229.517z&quot;/&gt;
&lt;path style=&quot;fill:#A7A7AB;&quot; d=&quot;M176.736,308.966c-9.751,0-17.839-7.904-17.839-17.655c0-9.751,8.088-17.655,17.839-17.655
	c0.062,0-0.062,0.009,0,0.009v-17.66c-0.062,0,0.062-0.004,0-0.004c-19.501,0-35.495,15.809-35.495,35.31
	c0,19.501,15.993,35.31,35.495,35.31c0.062,0-0.062-0.004,0-0.004v-17.66C176.674,308.957,176.798,308.966,176.736,308.966z&quot;/&gt;
&lt;/svg&gt;</file><file path="docs/dev_docker_services.md"># Dev docker services

## Docker networks

Currently only `baander-backtier` is defined. This network is used for connecting all containers.

You must __not__ define/create this network. It will be created automatically.

## Redis

__Host__:

Memory store for caching and queue services

Bound to host 127.0.0.1:6379

Docker network baander-backtier as hostname redis

No password

Recommendation: Use [Redis insight](https://redis.io/insight/)

## Postgres

Database for storing everything important e.g. Libraries and Users.

__Host__:

Bound to host 127.0.0.1:5432 (not available outside localhost)

Docker network baander-backtier as hostname postgres

__Username:__ baander

__Password:__ baander

__Database:__ baander

Recommendation: Use [Beekeeper Studio](https://www.beekeeperstudio.io/) the free tier is more than enough.

If you can get a license for Navicat, then that&apos;s also a solid choice.

## Mailpit

Only used for testing emails in development

Bound to host:

__127.0.0.1:8025__ The smtp server. Probably not something you will use, but its available.

__127.0.0.1:1025__ The web interface for viewing emails.</file><file path="docs/dev_setup_host.md"># Dev setup host

## Install nvm, nodejs + yarn

If you have not install nvm (Node version manager), then you must install it now. The windows version is __NOT__ suitable,
if you&apos;re working on Windows, you must as said before be inside a WSL linux shell.

Follow the instructions here [nvm - installing and updating](https://github.com/nvm-sh/nvm?tab=readme-ov-file#installing-and-updating)

Then install nodejs 20+ (22 is also okay)

```shell
nvm install 22.7.0 --with-latest-npm
```

Exit the shell and open it again, so we&apos;ll have node/nvm in our environment (you can also follow the on screen instructions).

Install yarn 1

```shell
npm i -g yarn
```

## Hosts file

Map `baander.test` to `127.0.0.1` in your hosts file</file><file path="docs/dev_users.md"># Dev users

## Admin

__email/username:__ admin@baander.test

__password:__ password

## User

__email/username:__ user@baander.test

__password:__ password</file><file path="docs/discogs-client.md"># Discogs API Client

The Discogs API Client provides a simple interface to interact with the Discogs API. It supports searching for artists, releases, masters, and labels, as well as looking up specific entities by their IDs. The client also supports pagination for all endpoints that return multiple results.

## Installation

The Discogs API Client is already integrated into the Baander application. No additional installation is required.

## Configuration

To use the Discogs API Client, you need to set your Discogs API key in the `.env` file:

```
DISCOGS_API_KEY=your_api_key_here
```

## Basic Usage

### Initialization

```php
use App\Http\Integrations\Discogs\DiscogsClient;

// Using dependency injection (recommended)
public function __construct(DiscogsClient $discogsClient)
{
    $this-&gt;discogsClient = $discogsClient;
}

// Or manually
$discogsClient = app(DiscogsClient::class);
```

### Searching

The client supports searching for artists, releases, masters, and labels. Each search method accepts a filter object that specifies the search criteria and pagination parameters.

#### Artists

```php
use App\Http\Integrations\Discogs\Filters\ArtistFilter;

$filter = new ArtistFilter(
    q: &apos;Radiohead&apos;,
    page: 1,
    per_page: 10
);

$artists = $discogsClient-&gt;search-&gt;artist($filter);
```

#### Releases

```php
use App\Http\Integrations\Discogs\Filters\ReleaseFilter;

$filter = new ReleaseFilter(
    artist: &apos;Radiohead&apos;,
    title: &apos;OK Computer&apos;,
    page: 1,
    per_page: 10
);

$releases = $discogsClient-&gt;search-&gt;release($filter);
```

#### Masters

```php
use App\Http\Integrations\Discogs\Filters\MasterFilter;

$filter = new MasterFilter(
    artist: &apos;Radiohead&apos;,
    title: &apos;OK Computer&apos;,
    page: 1,
    per_page: 10
);

$masters = $discogsClient-&gt;search-&gt;master($filter);
```

#### Labels

```php
use App\Http\Integrations\Discogs\Filters\LabelFilter;

$filter = new LabelFilter(
    q: &apos;XL Recordings&apos;,
    page: 1,
    per_page: 10
);

$labels = $discogsClient-&gt;search-&gt;label($filter);
```

### Pagination

All search methods support pagination. You can specify the page number and the number of items per page in the filter object. You can also retrieve pagination information from the last search:

```php
$pagination = $discogsClient-&gt;search-&gt;getPagination();
// Returns: [&apos;page&apos; =&gt; 1, &apos;pages&apos; =&gt; 10, &apos;items&apos; =&gt; 100, &apos;per_page&apos; =&gt; 10]
```

### Looking Up Entities

The client supports looking up specific entities by their IDs.

#### Artists

```php
$artist = $discogsClient-&gt;lookup-&gt;artist(3840); // Radiohead
```

#### Artist Releases

```php
$releases = $discogsClient-&gt;lookup-&gt;artistReleases(3840, 1, 10); // Radiohead&apos;s releases, page 1, 10 per page
```

#### Releases

```php
$release = $discogsClient-&gt;lookup-&gt;release(1475088); // OK Computer
```

#### Masters

```php
$master = $discogsClient-&gt;lookup-&gt;master(45524); // OK Computer (master)
```

#### Master Versions

```php
$versions = $discogsClient-&gt;lookup-&gt;masterVersions(45524, 1, 10); // OK Computer versions, page 1, 10 per page
```

#### Labels

```php
$label = $discogsClient-&gt;lookup-&gt;label(1814); // XL Recordings
```

#### Label Releases

```php
$releases = $discogsClient-&gt;lookup-&gt;labelReleases(1814, 1, 10); // XL Recordings releases, page 1, 10 per page
```

## Models

The Discogs API Client uses model classes to represent the data returned from the API. These models provide a structured way to access the data and ensure type safety.

### Available Models

- `Artist`: Represents an artist entity
- `Release`: Represents a release entity
- `Master`: Represents a master release entity
- `Label`: Represents a label entity

### Using Models

All lookup and search methods return model instances or collections of model instances. For example:

```php
// Looking up an artist returns an Artist model
$artist = $discogsClient-&gt;lookup-&gt;artist(3840);
echo $artist-&gt;name; // &quot;Radiohead&quot;
echo $artist-&gt;profile; // Artist&apos;s profile text

// Searching for releases returns an array of Release models
$releases = $discogsClient-&gt;search-&gt;release($filter);
foreach ($releases as $release) {
    echo $release-&gt;title;
    echo $release-&gt;year;
}
```

### Model Properties

Each model has properties that correspond to the fields in the API response. Some common properties include:

- `id`: The unique identifier for the entity
- `name` or `title`: The name or title of the entity
- `uri`: The URI for the entity on Discogs
- `resource_url`: The API URL for the entity
- `thumbnail` and `cover_image`: URLs for the entity&apos;s images

Refer to the model classes for a complete list of properties for each entity type.

## Examples

See the `examples/discogs_client_example.php` file for more examples of how to use the Discogs API Client.

## Testing

The client includes a comprehensive test suite. You can run the tests with:

```bash
php artisan test --filter=DiscogsClientTest
```</file><file path="docs/phpstorm.md"># IDE JetBrains PhpStorm
This document describing how you can configure your IDE [PhpStorm](https://www.jetbrains.com/phpstorm/).

## Configuring PhpStorm
### General
* Go to `Settings -&gt; Plugins` and install next plugins:
    - .env files support
    - .ignore
    - Makefile Language
    - Php Inspections (EA Extended)
    - Laravel Idea
    - Rainbow brackets
    - String Manipulation
* Go to `Settings -&gt; Php -&gt; Frameworks -&gt; Laravel Idea` and check settings for `Laravel Idea` plugin.
* If you want control quality of your PHP project - pay your attention to the tools, described [here](development.md).

### CLI Interpreter
You need to set correct CLI interpreter for your PhpStorm.
In order to do it please open `Settings -&gt; PHP` section and follow recommendations [configuring remote PHP interpreters](https://www.jetbrains.com/help/phpstorm/configuring-remote-interpreters.html).

![Path mappings](images/phpstorm_00.png)
![Path mappings](images/phpstorm_01.png)

### Composer
Go to `Settings -&gt; Php -&gt; Composer` and set path to composer.json, check other settings:

![Path mappings](images/phpstorm_02.png)

### Server
In order to configure PHP servers please open `Settings -&gt; PHP -&gt; Servers`.
You need to configure how your local files will be mapped inside docker container:

![Path mappings](images/phpstorm_03.png)

### Test Frameworks
If you want to run tests directly from your IDE you need to do following configuration in `Settings -&gt; PHP -&gt; Test Frameworks`:

![Path mappings](images/phpstorm_04.png)

Next you need to add Run/Debug configuration for PHP Remote Debug. It needs to be the same as image below:

![Path mappings](images/phpstorm_05.png)

### Debugging
In order to use Xdebug as debugging tool please follow [Using Xdebug](xdebug.md) documentation.

### Code Style
This environment has committed `.idea/` catalog, so most IDE configs should be available out of the box. But if you want to have own configs, you can put `./idea` in gitignore and delete folder from the git repository.
Anyway you can always import our recommended code style if you don&apos;t have committed `./idea` folder inside your repository:
* Go to `Settings -&gt; Editor -&gt; Code Style -&gt; PHP` and import scheme `Project` (CodeStyle.xml) from [docs/phpstorm](phpstorm):

![Path mappings](images/phpstorm_code_style.png)

### PHP Inspections and code quality tools
* Go to `Settings -&gt; PHP -&gt; Quality tools` and configure next:

![Path mappings](images/phpstorm_06.png)
![Path mappings](images/phpstorm_php_code_sniffer_1.png)
![Path mappings](images/phpstorm_php_code_sniffer_2.png)
![Path mappings](images/phpstorm_php_cs_fixer_1.png)

Note: make sure that you have proper local path for the PHP CS Fixer ruleset `.php-cs-fixer.dist.php`.

![Path mappings](images/phpstorm_php_cs_fixer_2.png)
![Path mappings](images/phpstorm_laravel_pint_1.png)
![Path mappings](images/phpstorm_laravel_pint_2.png)
![Path mappings](images/phpstorm_phpstan_1.png)
![Path mappings](images/phpstorm_phpstan_2.png)
![Path mappings](images/phpstorm_phpmd_1.png)

Note: make sure that you have proper local path for the MessDetector ruleset `phpmd_ruleset.xml`.

![Path mappings](images/phpstorm_phpmd_2.png)

* If you don&apos;t have committed folder `.idea/`, go to `Settings -&gt; Editor -&gt; Inspections` and import profile `Project Default` (Inspections.xml) from [docs/phpstorm](phpstorm):

![Path mappings](images/phpstorm_inspections.png)

* Go to `Settings -&gt; Tools -&gt; External tools` and create ecs tool:

![Path mappings](images/phpstorm_12.png)

Note: Arguments value should be `exec-bash cmd=&quot;./vendor/bin/ecs --clear-cache check $FilePathRelativeToProjectRoot$&quot;`.

Note: In order to use it - right click on the necessary file/folder in PhpStorm and select context menu `External Tools -&gt; ecs`.

* Go to `Settings -&gt; Tools -&gt; External tools` and create phpcs tool:

![Path mappings](images/phpstorm_13.png)

Note: Arguments value should be `exec-bash cmd=&quot;./vendor/bin/phpcs --version &amp;&amp; ./vendor/bin/phpcs --standard=PSR12 --colors -p $FilePathRelativeToProjectRoot$&quot;`.

Note: In order to use it - right click on the necessary file/folder in PhpStorm and select context menu `External Tools -&gt; phpcs`.


For inspecting your code you can use main menu item `Code -&gt; Inspect Code`. Code will be processed by code quality tools like PHP CS Fixer, PHP Mess Detector, PHP CodeSniffer, PHPStan.

## External documentations
* [Configuring Remote PHP Interpreters](https://www.jetbrains.com/help/phpstorm/configuring-remote-interpreters.html)
* [Test Frameworks](https://www.jetbrains.com/help/phpstorm/php-test-frameworks.html)
* [Laravel Development using PhpStorm](https://blog.jetbrains.com/phpstorm/2015/01/laravel-development-using-phpstorm/)
* [Laravel Plugin plugin for PhpStorm](https://plugins.jetbrains.com/plugin/7532-laravel)
* [Php Inspections (EA Extended) plugin for PhpStorm](https://plugins.jetbrains.com/idea/plugin/7622-php-inspections-ea-extended-)
* [Qodana code quality tool](https://blog.jetbrains.com/qodana/2023/09/code-quality-under-pressure-supporting-developers-with-qodana-integration-in-intellij-based-ides/)</file><file path="docs/xdebug.md"># Xdebug
This document describing how you can use [Xdebug](https://xdebug.org/) and [PhpStorm](https://www.jetbrains.com/phpstorm/) within DEV environment.

## Configuration and usage
Please follow [PhpStorm](phpstorm.md) documentation before actions described bellow.

### PhpStorm basic configuration
1.Check /docker/dev/xdebug-main.ini or /docker/dev/xdebug-osx.ini (optional)

- In case you need debug only requests with IDE KEY: PHPSTORM from frontend in your browser:
```bash
xdebug.start_with_request = no
```
Install locally in Firefox extension &quot;Xdebug helper&quot; and set in settings IDE KEY: PHPSTORM

- In case you need debug any request to an api (by default):
```bash
xdebug.start_with_request = yes
```

2.Go to `Settings -&gt; Php -&gt; Debug` and set Xdebug port `10000`

3.Check your `Run/Debug Configurations` as on image bellow

4.Install needed browser extensions (optional, see step 1). For example for Firefox install extension &quot;Xdebug helper&quot; and set in extension settings IDE KEY: PHPSTORM

![Basic configuration](images/xdebug_01.png)

![Basic configuration](images/phpstorm_05.png)

### Using Xdebug
After actions above you can start to listen incoming PHP debug connections:

1. Add breakpoint to your code
2. Enable Xdebug in your browser (optional, required only when xdebug.start_with_request = no)
3. Click `Debug` button in PhpStorm
4. Reload browser page

If everything configured properly you will get something like next:

![Using Xdebug](images/xdebug_02.png)

## Debug Postman requests
If you&apos;re using [Postman](https://www.getpostman.com/) to test/debug your application when `xdebug.start_with_request = no` you need to add `?XDEBUG_SESSION_START=PHPSTORM` to each URL
that you use with Postman. If you have default configuration (`xdebug.start_with_request = yes`) - nothing to do and your Xdebug should work out of the box.

## Debug Console commands
If you want to debug console commands you just need to uncomment/edit (nothing to do in case MacOS and `XDEBUG_CONFIG=osx`) option `xdebug.client_host` in config `docker/dev/xdebug-main.ini`:
```bash
xdebug.client_host=172.17.0.1
```
Just find out the proper host ip in your docker bridge configuration and set above option (in general it is `172.17.0.1`).
Don&apos;t forget to rebuild docker containers according to [general](../readme.md) documentation.

## External documentations
* [Debugging PHP (web and cli) with Xdebug using Docker and PHPStorm](https://thecodingmachine.io/configuring-xdebug-phpstorm-docker)
* [Debug your PHP in Docker with Intellij/PHPStorm and Xdebug](https://gist.github.com/jehaby/61a89b15571b4bceee2417106e80240d)
* [Debugging with Postman and PHPStorm (Xdebug)](https://www.thinkbean.com/drupal-development-blog/debugging-postman-and-phpstorm-xdebug)</file><file path="lang/en/acl.php">&lt;?php
return [
    &apos;permissions&apos; =&gt; [
        &apos;albums.delete&apos;           =&gt; &apos;Delete an album&apos;,
        &apos;albums.edit-metadata&apos;    =&gt; &apos;Edit metadata&apos;,
        &apos;albums.forceDelete&apos;      =&gt; &apos;Remove album entirely including from filesystem&apos;,
        &apos;albums.store&apos;            =&gt; &apos;Manually create a new album&apos;,
        &apos;albums.update&apos;           =&gt; &apos;Update an album&apos;,
        &apos;albums.viewAny&apos;          =&gt; &apos;View all albums&apos;,
        &apos;artists.edit-metadata&apos;   =&gt; &apos;Edit metadata&apos;,
        &apos;genre.edit-metadata&apos;     =&gt; &apos;Edit metadata&apos;,
        &apos;libraries.delete&apos;        =&gt; &apos;Delete a library&apos;,
        &apos;libraries.edit-metadata&apos; =&gt; &apos;Edit metadata&apos;,
        &apos;libraries.forceDelete&apos;   =&gt; &apos;Remove library&apos;,
        &apos;libraries.store&apos;         =&gt; &apos;Create a new library&apos;,
        &apos;libraries.update&apos;        =&gt; &apos;Update a library&apos;,
        &apos;libraries.viewAny&apos;       =&gt; &apos;View all libraries&apos;,
        &apos;songs.edit-metadata&apos;     =&gt; &apos;Edit metadata&apos;,
        &apos;users.delete&apos;            =&gt; &apos;Delete a user&apos;,
        &apos;users.forceDelete&apos;       =&gt; &apos;Permanently delete a user&apos;,
        &apos;users.update&apos;            =&gt; &apos;Edit a user&apos;,
        &apos;users.viewAny&apos;           =&gt; &apos;View all users&apos;,
        &apos;user.viewLimited&apos;        =&gt; &apos;View basic profile data&apos;,
    ],
];</file><file path="lang/en/date.php">&lt;?php
return [
    &apos;time&apos; =&gt; [
        &apos;minute&apos; =&gt; [
            &apos;char&apos; =&gt; &apos;m&apos;,
            &apos;name&apos; =&gt; &apos;minute&apos;,
        ],
        &apos;hour&apos;   =&gt; [
            &apos;char&apos; =&gt; &apos;h&apos;,
            &apos;name&apos; =&gt; &apos;hour&apos;,
        ],
        &apos;day&apos;    =&gt; [
            &apos;char&apos; =&gt; &apos;d&apos;,
            &apos;name&apos; =&gt; &apos;day&apos;,
        ]
    ],
];</file><file path="lang/en/error.php">&lt;?php
return [
    &apos;file_does_not_exist&apos;    =&gt; &apos;File does not exist&apos;,
    &apos;unable_to_locate_image&apos; =&gt; &apos;The requested image could not be located.&apos;,
];</file><file path="lang/en/library.php">&lt;?php
return [
    &apos;album&apos; =&gt; [
        &apos;fallback&apos; =&gt; &apos;Various artists&apos;,
    ],
];</file><file path="lang/en/pagination.php">&lt;?php
return [
    /*
    |--------------------------------------------------------------------------
    | Pagination Language Lines
    |--------------------------------------------------------------------------
    |
    | The following language lines are used by the paginator library to build
    | the simple pagination links. You are free to change them to anything
    | you want to customize your views to better match your application.
    |
    */
    &apos;previous&apos; =&gt; &apos;&amp;laquo; Previous&apos;,
    &apos;next&apos; =&gt; &apos;Next &amp;raquo;&apos;,
];</file><file path="lang/en/passwords.php">&lt;?php
return [
    /*
    |--------------------------------------------------------------------------
    | Password Reset Language Lines
    |--------------------------------------------------------------------------
    |
    | The following language lines are the default lines which match reasons
    | that are given by the password broker for a password update attempt
    | outcome such as failure due to an invalid password / reset token.
    |
    */
    &apos;reset&apos; =&gt; &apos;Your password has been reset.&apos;,
    &apos;sent&apos; =&gt; &apos;We have emailed your password reset link.&apos;,
    &apos;throttled&apos; =&gt; &apos;Please wait before retrying.&apos;,
    &apos;token&apos; =&gt; &apos;This password reset token is invalid.&apos;,
    &apos;user&apos; =&gt; &quot;We can&apos;t find a user with that email address.&quot;,
];</file><file path="lang/en/validation.php">&lt;?php
return [
    /*
    |--------------------------------------------------------------------------
    | Validation Language Lines
    |--------------------------------------------------------------------------
    |
    | The following language lines contain the default error messages used by
    | the validator class. Some of these rules have multiple versions such
    | as the size rules. Feel free to tweak each of these messages here.
    |
    */
    &apos;accepted&apos; =&gt; &apos;The :attribute field must be accepted.&apos;,
    &apos;accepted_if&apos; =&gt; &apos;The :attribute field must be accepted when :other is :value.&apos;,
    &apos;active_url&apos; =&gt; &apos;The :attribute field must be a valid URL.&apos;,
    &apos;after&apos; =&gt; &apos;The :attribute field must be a date after :date.&apos;,
    &apos;after_or_equal&apos; =&gt; &apos;The :attribute field must be a date after or equal to :date.&apos;,
    &apos;alpha&apos; =&gt; &apos;The :attribute field must only contain letters.&apos;,
    &apos;alpha_dash&apos; =&gt; &apos;The :attribute field must only contain letters, numbers, dashes, and underscores.&apos;,
    &apos;alpha_num&apos; =&gt; &apos;The :attribute field must only contain letters and numbers.&apos;,
    &apos;array&apos; =&gt; &apos;The :attribute field must be an array.&apos;,
    &apos;ascii&apos; =&gt; &apos;The :attribute field must only contain single-byte alphanumeric characters and symbols.&apos;,
    &apos;before&apos; =&gt; &apos;The :attribute field must be a date before :date.&apos;,
    &apos;before_or_equal&apos; =&gt; &apos;The :attribute field must be a date before or equal to :date.&apos;,
    &apos;between&apos; =&gt; [
        &apos;array&apos; =&gt; &apos;The :attribute field must have between :min and :max items.&apos;,
        &apos;file&apos; =&gt; &apos;The :attribute field must be between :min and :max kilobytes.&apos;,
        &apos;numeric&apos; =&gt; &apos;The :attribute field must be between :min and :max.&apos;,
        &apos;string&apos; =&gt; &apos;The :attribute field must be between :min and :max characters.&apos;,
    ],
    &apos;boolean&apos; =&gt; &apos;The :attribute field must be true or false.&apos;,
    &apos;can&apos; =&gt; &apos;The :attribute field contains an unauthorized value.&apos;,
    &apos;confirmed&apos; =&gt; &apos;The :attribute field confirmation does not match.&apos;,
    &apos;contains&apos; =&gt; &apos;The :attribute field is missing a required value.&apos;,
    &apos;current_password&apos; =&gt; &apos;The password is incorrect.&apos;,
    &apos;date&apos; =&gt; &apos;The :attribute field must be a valid date.&apos;,
    &apos;date_equals&apos; =&gt; &apos;The :attribute field must be a date equal to :date.&apos;,
    &apos;date_format&apos; =&gt; &apos;The :attribute field must match the format :format.&apos;,
    &apos;decimal&apos; =&gt; &apos;The :attribute field must have :decimal decimal places.&apos;,
    &apos;declined&apos; =&gt; &apos;The :attribute field must be declined.&apos;,
    &apos;declined_if&apos; =&gt; &apos;The :attribute field must be declined when :other is :value.&apos;,
    &apos;different&apos; =&gt; &apos;The :attribute field and :other must be different.&apos;,
    &apos;digits&apos; =&gt; &apos;The :attribute field must be :digits digits.&apos;,
    &apos;digits_between&apos; =&gt; &apos;The :attribute field must be between :min and :max digits.&apos;,
    &apos;dimensions&apos; =&gt; &apos;The :attribute field has invalid image dimensions.&apos;,
    &apos;distinct&apos; =&gt; &apos;The :attribute field has a duplicate value.&apos;,
    &apos;doesnt_end_with&apos; =&gt; &apos;The :attribute field must not end with one of the following: :values.&apos;,
    &apos;doesnt_start_with&apos; =&gt; &apos;The :attribute field must not start with one of the following: :values.&apos;,
    &apos;email&apos; =&gt; &apos;The :attribute field must be a valid email address.&apos;,
    &apos;ends_with&apos; =&gt; &apos;The :attribute field must end with one of the following: :values.&apos;,
    &apos;enum&apos; =&gt; &apos;The selected :attribute is invalid.&apos;,
    &apos;exists&apos; =&gt; &apos;The selected :attribute is invalid.&apos;,
    &apos;extensions&apos; =&gt; &apos;The :attribute field must have one of the following extensions: :values.&apos;,
    &apos;file&apos; =&gt; &apos;The :attribute field must be a file.&apos;,
    &apos;filled&apos; =&gt; &apos;The :attribute field must have a value.&apos;,
    &apos;gt&apos; =&gt; [
        &apos;array&apos; =&gt; &apos;The :attribute field must have more than :value items.&apos;,
        &apos;file&apos; =&gt; &apos;The :attribute field must be greater than :value kilobytes.&apos;,
        &apos;numeric&apos; =&gt; &apos;The :attribute field must be greater than :value.&apos;,
        &apos;string&apos; =&gt; &apos;The :attribute field must be greater than :value characters.&apos;,
    ],
    &apos;gte&apos; =&gt; [
        &apos;array&apos; =&gt; &apos;The :attribute field must have :value items or more.&apos;,
        &apos;file&apos; =&gt; &apos;The :attribute field must be greater than or equal to :value kilobytes.&apos;,
        &apos;numeric&apos; =&gt; &apos;The :attribute field must be greater than or equal to :value.&apos;,
        &apos;string&apos; =&gt; &apos;The :attribute field must be greater than or equal to :value characters.&apos;,
    ],
    &apos;hex_color&apos; =&gt; &apos;The :attribute field must be a valid hexadecimal color.&apos;,
    &apos;image&apos; =&gt; &apos;The :attribute field must be an image.&apos;,
    &apos;in&apos; =&gt; &apos;The selected :attribute is invalid.&apos;,
    &apos;in_array&apos; =&gt; &apos;The :attribute field must exist in :other.&apos;,
    &apos;integer&apos; =&gt; &apos;The :attribute field must be an integer.&apos;,
    &apos;ip&apos; =&gt; &apos;The :attribute field must be a valid IP address.&apos;,
    &apos;ipv4&apos; =&gt; &apos;The :attribute field must be a valid IPv4 address.&apos;,
    &apos;ipv6&apos; =&gt; &apos;The :attribute field must be a valid IPv6 address.&apos;,
    &apos;json&apos; =&gt; &apos;The :attribute field must be a valid JSON string.&apos;,
    &apos;list&apos; =&gt; &apos;The :attribute field must be a list.&apos;,
    &apos;lowercase&apos; =&gt; &apos;The :attribute field must be lowercase.&apos;,
    &apos;lt&apos; =&gt; [
        &apos;array&apos; =&gt; &apos;The :attribute field must have less than :value items.&apos;,
        &apos;file&apos; =&gt; &apos;The :attribute field must be less than :value kilobytes.&apos;,
        &apos;numeric&apos; =&gt; &apos;The :attribute field must be less than :value.&apos;,
        &apos;string&apos; =&gt; &apos;The :attribute field must be less than :value characters.&apos;,
    ],
    &apos;lte&apos; =&gt; [
        &apos;array&apos; =&gt; &apos;The :attribute field must not have more than :value items.&apos;,
        &apos;file&apos; =&gt; &apos;The :attribute field must be less than or equal to :value kilobytes.&apos;,
        &apos;numeric&apos; =&gt; &apos;The :attribute field must be less than or equal to :value.&apos;,
        &apos;string&apos; =&gt; &apos;The :attribute field must be less than or equal to :value characters.&apos;,
    ],
    &apos;mac_address&apos; =&gt; &apos;The :attribute field must be a valid MAC address.&apos;,
    &apos;max&apos; =&gt; [
        &apos;array&apos; =&gt; &apos;The :attribute field must not have more than :max items.&apos;,
        &apos;file&apos; =&gt; &apos;The :attribute field must not be greater than :max kilobytes.&apos;,
        &apos;numeric&apos; =&gt; &apos;The :attribute field must not be greater than :max.&apos;,
        &apos;string&apos; =&gt; &apos;The :attribute field must not be greater than :max characters.&apos;,
    ],
    &apos;max_digits&apos; =&gt; &apos;The :attribute field must not have more than :max digits.&apos;,
    &apos;mimes&apos; =&gt; &apos;The :attribute field must be a file of type: :values.&apos;,
    &apos;mimetypes&apos; =&gt; &apos;The :attribute field must be a file of type: :values.&apos;,
    &apos;min&apos; =&gt; [
        &apos;array&apos; =&gt; &apos;The :attribute field must have at least :min items.&apos;,
        &apos;file&apos; =&gt; &apos;The :attribute field must be at least :min kilobytes.&apos;,
        &apos;numeric&apos; =&gt; &apos;The :attribute field must be at least :min.&apos;,
        &apos;string&apos; =&gt; &apos;The :attribute field must be at least :min characters.&apos;,
    ],
    &apos;min_digits&apos; =&gt; &apos;The :attribute field must have at least :min digits.&apos;,
    &apos;missing&apos; =&gt; &apos;The :attribute field must be missing.&apos;,
    &apos;missing_if&apos; =&gt; &apos;The :attribute field must be missing when :other is :value.&apos;,
    &apos;missing_unless&apos; =&gt; &apos;The :attribute field must be missing unless :other is :value.&apos;,
    &apos;missing_with&apos; =&gt; &apos;The :attribute field must be missing when :values is present.&apos;,
    &apos;missing_with_all&apos; =&gt; &apos;The :attribute field must be missing when :values are present.&apos;,
    &apos;multiple_of&apos; =&gt; &apos;The :attribute field must be a multiple of :value.&apos;,
    &apos;not_in&apos; =&gt; &apos;The selected :attribute is invalid.&apos;,
    &apos;not_regex&apos; =&gt; &apos;The :attribute field format is invalid.&apos;,
    &apos;numeric&apos; =&gt; &apos;The :attribute field must be a number.&apos;,
    &apos;password&apos; =&gt; [
        &apos;letters&apos; =&gt; &apos;The :attribute field must contain at least one letter.&apos;,
        &apos;mixed&apos; =&gt; &apos;The :attribute field must contain at least one uppercase and one lowercase letter.&apos;,
        &apos;numbers&apos; =&gt; &apos;The :attribute field must contain at least one number.&apos;,
        &apos;symbols&apos; =&gt; &apos;The :attribute field must contain at least one symbol.&apos;,
        &apos;uncompromised&apos; =&gt; &apos;The given :attribute has appeared in a data leak. Please choose a different :attribute.&apos;,
    ],
    &apos;present&apos; =&gt; &apos;The :attribute field must be present.&apos;,
    &apos;present_if&apos; =&gt; &apos;The :attribute field must be present when :other is :value.&apos;,
    &apos;present_unless&apos; =&gt; &apos;The :attribute field must be present unless :other is :value.&apos;,
    &apos;present_with&apos; =&gt; &apos;The :attribute field must be present when :values is present.&apos;,
    &apos;present_with_all&apos; =&gt; &apos;The :attribute field must be present when :values are present.&apos;,
    &apos;prohibited&apos; =&gt; &apos;The :attribute field is prohibited.&apos;,
    &apos;prohibited_if&apos; =&gt; &apos;The :attribute field is prohibited when :other is :value.&apos;,
    &apos;prohibited_unless&apos; =&gt; &apos;The :attribute field is prohibited unless :other is in :values.&apos;,
    &apos;prohibits&apos; =&gt; &apos;The :attribute field prohibits :other from being present.&apos;,
    &apos;regex&apos; =&gt; &apos;The :attribute field format is invalid.&apos;,
    &apos;required&apos; =&gt; &apos;The :attribute field is required.&apos;,
    &apos;required_array_keys&apos; =&gt; &apos;The :attribute field must contain entries for: :values.&apos;,
    &apos;required_if&apos; =&gt; &apos;The :attribute field is required when :other is :value.&apos;,
    &apos;required_if_accepted&apos; =&gt; &apos;The :attribute field is required when :other is accepted.&apos;,
    &apos;required_if_declined&apos; =&gt; &apos;The :attribute field is required when :other is declined.&apos;,
    &apos;required_unless&apos; =&gt; &apos;The :attribute field is required unless :other is in :values.&apos;,
    &apos;required_with&apos; =&gt; &apos;The :attribute field is required when :values is present.&apos;,
    &apos;required_with_all&apos; =&gt; &apos;The :attribute field is required when :values are present.&apos;,
    &apos;required_without&apos; =&gt; &apos;The :attribute field is required when :values is not present.&apos;,
    &apos;required_without_all&apos; =&gt; &apos;The :attribute field is required when none of :values are present.&apos;,
    &apos;same&apos; =&gt; &apos;The :attribute field must match :other.&apos;,
    &apos;size&apos; =&gt; [
        &apos;array&apos; =&gt; &apos;The :attribute field must contain :size items.&apos;,
        &apos;file&apos; =&gt; &apos;The :attribute field must be :size kilobytes.&apos;,
        &apos;numeric&apos; =&gt; &apos;The :attribute field must be :size.&apos;,
        &apos;string&apos; =&gt; &apos;The :attribute field must be :size characters.&apos;,
    ],
    &apos;starts_with&apos; =&gt; &apos;The :attribute field must start with one of the following: :values.&apos;,
    &apos;string&apos; =&gt; &apos;The :attribute field must be a string.&apos;,
    &apos;timezone&apos; =&gt; &apos;The :attribute field must be a valid timezone.&apos;,
    &apos;unique&apos; =&gt; &apos;The :attribute has already been taken.&apos;,
    &apos;uploaded&apos; =&gt; &apos;The :attribute failed to upload.&apos;,
    &apos;uppercase&apos; =&gt; &apos;The :attribute field must be uppercase.&apos;,
    &apos;url&apos; =&gt; &apos;The :attribute field must be a valid URL.&apos;,
    &apos;ulid&apos; =&gt; &apos;The :attribute field must be a valid ULID.&apos;,
    &apos;uuid&apos; =&gt; &apos;The :attribute field must be a valid UUID.&apos;,
    /*
    |--------------------------------------------------------------------------
    | Custom Validation Language Lines
    |--------------------------------------------------------------------------
    |
    | Here you may specify custom validation messages for attributes using the
    | convention &quot;attribute.rule&quot; to name the lines. This makes it quick to
    | specify a specific custom language line for a given attribute rule.
    |
    */
    &apos;custom&apos; =&gt; [
        &apos;attribute-name&apos; =&gt; [
            &apos;rule-name&apos; =&gt; &apos;custom-message&apos;,
        ],
    ],
    /*
    |--------------------------------------------------------------------------
    | Custom Validation Attributes
    |--------------------------------------------------------------------------
    |
    | The following language lines are used to swap our attribute placeholder
    | with something more reader friendly such as &quot;E-Mail Address&quot; instead
    | of &quot;email&quot;. This simply helps us make our message more expressive.
    |
    */
    &apos;attributes&apos; =&gt; [],
];</file><file path="LICENSE">Apache License
                           Version 2.0, January 2004
                        http://www.apache.org/licenses/

   TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION

   1. Definitions.

      &quot;License&quot; shall mean the terms and conditions for use, reproduction,
      and distribution as defined by Sections 1 through 9 of this document.

      &quot;Licensor&quot; shall mean the copyright owner or entity authorized by
      the copyright owner that is granting the License.

      &quot;Legal Entity&quot; shall mean the union of the acting entity and all
      other entities that control, are controlled by, or are under common
      control with that entity. For the purposes of this definition,
      &quot;control&quot; means (i) the power, direct or indirect, to cause the
      direction or management of such entity, whether by contract or
      otherwise, or (ii) ownership of fifty percent (50%) or more of the
      outstanding shares, or (iii) beneficial ownership of such entity.

      &quot;You&quot; (or &quot;Your&quot;) shall mean an individual or Legal Entity
      exercising permissions granted by this License.

      &quot;Source&quot; form shall mean the preferred form for making modifications,
      including but not limited to software source code, documentation
      source, and configuration files.

      &quot;Object&quot; form shall mean any form resulting from mechanical
      transformation or translation of a Source form, including but
      not limited to compiled object code, generated documentation,
      and conversions to other media types.

      &quot;Work&quot; shall mean the work of authorship, whether in Source or
      Object form, made available under the License, as indicated by a
      copyright notice that is included in or attached to the work
      (an example is provided in the Appendix below).

      &quot;Derivative Works&quot; shall mean any work, whether in Source or Object
      form, that is based on (or derived from) the Work and for which the
      editorial revisions, annotations, elaborations, or other modifications
      represent, as a whole, an original work of authorship. For the purposes
      of this License, Derivative Works shall not include works that remain
      separable from, or merely link (or bind by name) to the interfaces of,
      the Work and Derivative Works thereof.

      &quot;Contribution&quot; shall mean any work of authorship, including
      the original version of the Work and any modifications or additions
      to that Work or Derivative Works thereof, that is intentionally
      submitted to Licensor for inclusion in the Work by the copyright owner
      or by an individual or Legal Entity authorized to submit on behalf of
      the copyright owner. For the purposes of this definition, &quot;submitted&quot;
      means any form of electronic, verbal, or written communication sent
      to the Licensor or its representatives, including but not limited to
      communication on electronic mailing lists, source code control systems,
      and issue tracking systems that are managed by, or on behalf of, the
      Licensor for the purpose of discussing and improving the Work, but
      excluding communication that is conspicuously marked or otherwise
      designated in writing by the copyright owner as &quot;Not a Contribution.&quot;

      &quot;Contributor&quot; shall mean Licensor and any individual or Legal Entity
      on behalf of whom a Contribution has been received by Licensor and
      subsequently incorporated within the Work.

   2. Grant of Copyright License. Subject to the terms and conditions of
      this License, each Contributor hereby grants to You a perpetual,
      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
      copyright license to reproduce, prepare Derivative Works of,
      publicly display, publicly perform, sublicense, and distribute the
      Work and such Derivative Works in Source or Object form.

   3. Grant of Patent License. Subject to the terms and conditions of
      this License, each Contributor hereby grants to You a perpetual,
      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
      (except as stated in this section) patent license to make, have made,
      use, offer to sell, sell, import, and otherwise transfer the Work,
      where such license applies only to those patent claims licensable
      by such Contributor that are necessarily infringed by their
      Contribution(s) alone or by combination of their Contribution(s)
      with the Work to which such Contribution(s) was submitted. If You
      institute patent litigation against any entity (including a
      cross-claim or counterclaim in a lawsuit) alleging that the Work
      or a Contribution incorporated within the Work constitutes direct
      or contributory patent infringement, then any patent licenses
      granted to You under this License for that Work shall terminate
      as of the date such litigation is filed.

   4. Redistribution. You may reproduce and distribute copies of the
      Work or Derivative Works thereof in any medium, with or without
      modifications, and in Source or Object form, provided that You
      meet the following conditions:

      (a) You must give any other recipients of the Work or
          Derivative Works a copy of this License; and

      (b) You must cause any modified files to carry prominent notices
          stating that You changed the files; and

      (c) You must retain, in the Source form of any Derivative Works
          that You distribute, all copyright, patent, trademark, and
          attribution notices from the Source form of the Work,
          excluding those notices that do not pertain to any part of
          the Derivative Works; and

      (d) If the Work includes a &quot;NOTICE&quot; text file as part of its
          distribution, then any Derivative Works that You distribute must
          include a readable copy of the attribution notices contained
          within such NOTICE file, excluding those notices that do not
          pertain to any part of the Derivative Works, in at least one
          of the following places: within a NOTICE text file distributed
          as part of the Derivative Works; within the Source form or
          documentation, if provided along with the Derivative Works; or,
          within a display generated by the Derivative Works, if and
          wherever such third-party notices normally appear. The contents
          of the NOTICE file are for informational purposes only and
          do not modify the License. You may add Your own attribution
          notices within Derivative Works that You distribute, alongside
          or as an addendum to the NOTICE text from the Work, provided
          that such additional attribution notices cannot be construed
          as modifying the License.

      You may add Your own copyright statement to Your modifications and
      may provide additional or different license terms and conditions
      for use, reproduction, or distribution of Your modifications, or
      for any such Derivative Works as a whole, provided Your use,
      reproduction, and distribution of the Work otherwise complies with
      the conditions stated in this License.

   5. Submission of Contributions. Unless You explicitly state otherwise,
      any Contribution intentionally submitted for inclusion in the Work
      by You to the Licensor shall be under the terms and conditions of
      this License, without any additional terms or conditions.
      Notwithstanding the above, nothing herein shall supersede or modify
      the terms of any separate license agreement you may have executed
      with Licensor regarding such Contributions.

   6. Trademarks. This License does not grant permission to use the trade
      names, trademarks, service marks, or product names of the Licensor,
      except as required for reasonable and customary use in describing the
      origin of the Work and reproducing the content of the NOTICE file.

   7. Disclaimer of Warranty. Unless required by applicable law or
      agreed to in writing, Licensor provides the Work (and each
      Contributor provides its Contributions) on an &quot;AS IS&quot; BASIS,
      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
      implied, including, without limitation, any warranties or conditions
      of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A
      PARTICULAR PURPOSE. You are solely responsible for determining the
      appropriateness of using or redistributing the Work and assume any
      risks associated with Your exercise of permissions under this License.

   8. Limitation of Liability. In no event and under no legal theory,
      whether in tort (including negligence), contract, or otherwise,
      unless required by applicable law (such as deliberate and grossly
      negligent acts) or agreed to in writing, shall any Contributor be
      liable to You for damages, including any direct, indirect, special,
      incidental, or consequential damages of any character arising as a
      result of this License or out of the use or inability to use the
      Work (including but not limited to damages for loss of goodwill,
      work stoppage, computer failure or malfunction, or any and all
      other commercial damages or losses), even if such Contributor
      has been advised of the possibility of such damages.

   9. Accepting Warranty or Additional Liability. While redistributing
      the Work or Derivative Works thereof, You may choose to offer,
      and charge a fee for, acceptance of support, warranty, indemnity,
      or other liability obligations and/or rights consistent with this
      License. However, in accepting such obligations, You may act only
      on Your own behalf and on Your sole responsibility, not on behalf
      of any other Contributor, and only if You agree to indemnify,
      defend, and hold each Contributor harmless for any liability
      incurred by, or claims asserted against, such Contributor by reason
      of your accepting any such warranty or additional liability.

   END OF TERMS AND CONDITIONS

   APPENDIX: How to apply the Apache License to your work.

      To apply the Apache License to your work, attach the following
      boilerplate notice, with the fields enclosed by brackets &quot;[]&quot;
      replaced with your own identifying information. (Don&apos;t include
      the brackets!)  The text should be enclosed in the appropriate
      comment syntax for the file format. We also recommend that a
      file or class name and description of purpose be included on the
      same &quot;printed page&quot; as the copyright notice for easier
      identification within third-party archives.

   Copyright 2024 Martin Christiansen

   Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.</file><file path="openapi-gen-client.ts">import { createClient } from &apos;@hey-api/openapi-ts&apos;;
import * as parser from &apos;php-parser&apos;;
import fs from &apos;fs&apos;;
import path from &apos;path&apos;;
// Create an instance of the PHP parser
const php = new parser.Engine({
  parser: {
    extractDoc: false,
    version: 803,
    suppressErrors: true,
  },
  ast: {
    withPositions: true,
  },
});
/**
 * Recursively scans a directory and retrieves PHP class names.
 * @param {string} dirPath - The directory path to scan.
 * @returns {string[]} - An array of class names.
 */
function scanClasses(dirPath: string): string[] {
  const classNames: string[] = [];
  function recursiveScan(currentPath: string) {
    const files = fs.readdirSync(currentPath);
    files.forEach(file =&gt; {
      const filePath = path.join(currentPath, file);
      const stat = fs.statSync(filePath);
      if (stat.isDirectory()) {
        recursiveScan(filePath);
      } else if (file.endsWith(&apos;.php&apos;)) {
        const content = fs.readFileSync(filePath, &apos;utf8&apos;);
        try {
          const ast = php.parseCode(content, path.basename(filePath));
          extractClassNames(ast, classNames);
        } catch (err) {
          console.error(`Error parsing ${filePath}:`, err);
        }
      }
    });
  }
  recursiveScan(dirPath);
  return classNames;
}
/**
 * Traverses the AST to extract class names.
 * @param {any} node - The AST node.
 * @param {string[]} classNames - The array to store class names.
 */
function extractClassNames(node: any, classNames: string[]) {
  if (node.kind === &apos;class&apos;) {
    classNames.push(node.name.name);
  }
  for (const key in node) {
    if (node[key] &amp;&amp; typeof node[key] === &apos;object&apos;) {
      extractClassNames(node[key], classNames);
    }
  }
}
// Scan directories for classes
const requestsDir = path.join(__dirname, &apos;app&apos;, &apos;Http&apos;, &apos;Requests&apos;);
const resourcesDir = path.join(__dirname, &apos;app&apos;, &apos;Http&apos;, &apos;Resources&apos;);
// Define exceptions and scan classes
const exceptions = [
  &apos;ModelNotFoundException&apos;,
  &apos;AuthenticationException&apos;,
  &apos;ValidationException&apos;,
  &apos;AuthorizationException&apos;,
];
const scannedRequestsClasses = scanClasses(requestsDir);
const scannedResourcesClasses = scanClasses(resourcesDir);
const classesArray = [
  ...scannedRequestsClasses,
  ...scannedResourcesClasses,
  ...exceptions,
];
const classesPattern = classesArray.join(&apos;|&apos;).replace(/\./g, &apos;\\.&apos;).replace(/\//g, &apos;\\/&apos;);
const outDir = `${__dirname}/resources/app/api-client/gen`;
if (fs.existsSync(outDir)) {
  fs.rmdirSync(outDir, { recursive: true});
}
createClient({
  client: &apos;@hey-api/client-axios&apos;,
  input: {
    path: `${__dirname}/api.json`,
    include: `^(#\/paths\/api(\/.*)?|#\/paths\/webauthn(\/.*)?|#\/components\/schemas\/(${classesPattern}|LibraryType))$`, // Explicitly include LibraryType
  },
  output: outDir,
  experimentalParser: true,
  plugins: [
    &apos;@hey-api/schemas&apos;,
    &apos;@hey-api/sdk&apos;,
    {
      enums: &apos;javascript&apos;,
      name: &apos;@hey-api/typescript&apos;,
    },
    &apos;@tanstack/react-query&apos;,
    &apos;zod&apos;,
  ],
});</file><file path="phpcs.xml">&lt;?xml version=&quot;1.0&quot;?&gt;
&lt;ruleset name=&quot;Baander Codesniffer Rules&quot;&gt;
    &lt;description&gt;PSR-12 and Laravel conventions&lt;/description&gt;
    &lt;!-- Include PSR-12 standard --&gt;
    &lt;rule ref=&quot;PSR12&quot;/&gt;
    &lt;!-- Exclude deprecated or unnecessary checks --&gt;
    &lt;exclude name=&quot;Generic.Files.LineEndings.InvalidEOLChar&quot;/&gt;
    &lt;exclude name=&quot;PSR12.Operators.OperatorSpacing.NoSpaceBefore&quot;/&gt;
    &lt;exclude name=&quot;PSR12.Operators.OperatorSpacing.NoSpaceAfter&quot;/&gt;
    &lt;!-- Adding specific rules for Laravel --&gt;
    &lt;rule ref=&quot;Generic.Classes.DuplicateClassName&quot;&gt;
        &lt;exclude name=&quot;Generic.CodeAnalysis.EmptyStatement.DetectedIf&quot;/&gt;
    &lt;/rule&gt;
    &lt;rule ref=&quot;Generic.CodeAnalysis.EmptyStatement&quot;/&gt;
    &lt;rule ref=&quot;Generic.CodeAnalysis.ForLoopShouldBeWhileLoop&quot;/&gt;
    &lt;rule ref=&quot;Generic.CodeAnalysis.ForLoopWithTestFunctionCall&quot;/&gt;
    &lt;rule ref=&quot;Generic.CodeAnalysis.JumbledIncrementer&quot;/&gt;
    &lt;rule ref=&quot;Generic.CodeAnalysis.UnconditionalIfStatement&quot;/&gt;
    &lt;rule ref=&quot;Generic.CodeAnalysis.UnnecessaryFinalModifier&quot;/&gt;
    &lt;rule ref=&quot;Generic.CodeAnalysis.UnusedFunctionParameter&quot;&gt;
        &lt;exclude-pattern&gt;/app/Http/Resources/*\.php&lt;/exclude-pattern&gt;
    &lt;/rule&gt;
    &lt;rule ref=&quot;Generic.CodeAnalysis.UselessOverridingMethod&quot;/&gt;
    &lt;rule ref=&quot;Generic.Commenting.DocComment&quot;&gt;
        &lt;exclude name=&quot;Generic.Commenting.DocComment.TagValueIndent&quot;/&gt;
        &lt;exclude name=&quot;Generic.Commenting.DocComment.NonParamGroup&quot;/&gt;
    &lt;/rule&gt;
    &lt;rule ref=&quot;Generic.ControlStructures.InlineControlStructure&quot;/&gt;
    &lt;rule ref=&quot;Generic.Files.ByteOrderMark&quot;/&gt;
    &lt;rule ref=&quot;Generic.Formatting.DisallowMultipleStatements&quot;/&gt;
    &lt;rule ref=&quot;Generic.Formatting.SpaceAfterCast&quot;/&gt;
    &lt;rule ref=&quot;Generic.Functions.CallTimePassByReference&quot;/&gt;
    &lt;rule ref=&quot;Generic.Functions.FunctionCallArgumentSpacing&quot;/&gt;
    &lt;rule ref=&quot;Generic.Functions.OpeningFunctionBraceBsdAllman&quot;/&gt;
    &lt;rule ref=&quot;Generic.Metrics.CyclomaticComplexity&quot;&gt;
        &lt;properties&gt;
            &lt;property name=&quot;complexity&quot; value=&quot;20&quot;/&gt;
            &lt;property name=&quot;absoluteComplexity&quot; value=&quot;50&quot;/&gt;
        &lt;/properties&gt;
    &lt;/rule&gt;
    &lt;rule ref=&quot;Generic.Metrics.NestingLevel&quot;&gt;
        &lt;properties&gt;
            &lt;property name=&quot;nestingLevel&quot; value=&quot;5&quot;/&gt;
            &lt;property name=&quot;absoluteNestingLevel&quot; value=&quot;15&quot;/&gt;
        &lt;/properties&gt;
    &lt;/rule&gt;
    &lt;rule ref=&quot;Generic.PHP.LowerCaseConstant&quot;/&gt;
    &lt;rule ref=&quot;Generic.PHP.DeprecatedFunctions&quot;/&gt;
    &lt;rule ref=&quot;Generic.PHP.DisallowShortOpenTag&quot;/&gt;
    &lt;rule ref=&quot;Generic.PHP.ForbiddenFunctions&quot;/&gt;
    &lt;rule ref=&quot;Generic.PHP.NoSilencedErrors&quot;/&gt;
    &lt;rule ref=&quot;Generic.WhiteSpace.DisallowTabIndent&quot;/&gt;
    &lt;rule ref=&quot;Generic.WhiteSpace.ScopeIndent&quot;&gt;
        &lt;properties&gt;
            &lt;property name=&quot;indent&quot; value=&quot;4&quot;/&gt;
            &lt;property name=&quot;tabIndent&quot; value=&quot;true&quot;/&gt;
        &lt;/properties&gt;
    &lt;/rule&gt;
    &lt;rule ref=&quot;MySource.PHP.EvalObjectFactory&quot;/&gt;
    &lt;rule ref=&quot;PSR1.Classes.ClassDeclaration&quot;/&gt;
    &lt;rule ref=&quot;PSR1.Files.SideEffects&quot;/&gt;
    &lt;rule ref=&quot;Squiz.PHP.GlobalKeyword&quot;/&gt;
    &lt;rule ref=&quot;Squiz.PHP.LowercasePHPFunctions&quot;/&gt;
    &lt;rule ref=&quot;Squiz.WhiteSpace.ObjectOperatorSpacing&quot;&gt;
        &lt;properties&gt;
            &lt;property name=&quot;ignoreNewlines&quot; value=&quot;true&quot;/&gt;
        &lt;/properties&gt;
    &lt;/rule&gt;
    &lt;rule ref=&quot;Squiz.WhiteSpace.OperatorSpacing&quot;&gt;
        &lt;properties&gt;
            &lt;property name=&quot;ignoreNewlines&quot; value=&quot;true&quot;/&gt;
        &lt;/properties&gt;
    &lt;/rule&gt;
    &lt;rule ref=&quot;Zend.Files.ClosingTag&quot;/&gt;
    &lt;!-- Directories to include --&gt;
    &lt;file&gt;app&lt;/file&gt;
    &lt;file&gt;config&lt;/file&gt;
    &lt;file&gt;public&lt;/file&gt;
    &lt;file&gt;routes&lt;/file&gt;
    &lt;file&gt;tests&lt;/file&gt;
    &lt;!-- Exclude specific files and patterns --&gt;
    &lt;exclude-pattern&gt;*/.phpstorm.meta.php&lt;/exclude-pattern&gt;
    &lt;exclude-pattern&gt;*/_ide_helper.php&lt;/exclude-pattern&gt;
    &lt;exclude-pattern&gt;*/autoload.php&lt;/exclude-pattern&gt;
    &lt;exclude-pattern&gt;*/composer/*&lt;/exclude-pattern&gt;
    &lt;exclude-pattern&gt;*/node_modules/*&lt;/exclude-pattern&gt;
    &lt;exclude-pattern&gt;*/vendor/*&lt;/exclude-pattern&gt;
    &lt;exclude-pattern&gt;*/storage/*&lt;/exclude-pattern&gt;
    &lt;exclude-pattern&gt;*/docs/*&lt;/exclude-pattern&gt;
    &lt;exclude-pattern&gt;*/resources/views/*&lt;/exclude-pattern&gt;
    &lt;exclude-pattern&gt;*/public/index.php&lt;/exclude-pattern&gt;
    &lt;!-- Show progress of the run --&gt;
    &lt;arg value=&quot;p&quot;/&gt;
    &lt;!-- Show sniff codes in all reports --&gt;
    &lt;arg value=&quot;s&quot;/&gt;
    &lt;ini name=&quot;memory_limit&quot; value=&quot;256M&quot;/&gt;
&lt;/ruleset&gt;</file><file path="queue_listen.sh">#!/usr/bin/env bash
export $(grep -v &apos;^#&apos; .env | xargs -0) &amp;&amp; php artisan queue:listen</file><file path="resources/app/api-client-ext/interceptors/index.ts">import { refreshAccessTokenInterceptor } from &apos;@/api-client-ext/interceptors/refresh-access-token.interceptor.ts&apos;;
import { profilerParamInterceptor } from &apos;@/api-client-ext/interceptors/profiler-param.interceptor.ts&apos;;
import { apmTransactionInterceptor } from &apos;@/api-client-ext/interceptors/apm-transaction.interceptor.ts&apos;;
export function applyInterceptors() {
  refreshAccessTokenInterceptor();
  profilerParamInterceptor();
  apmTransactionInterceptor();
}</file><file path="resources/app/api-client-ext/interceptors/profiler-param.interceptor.ts">import { OpenAPI } from &apos;@/api-client/requests&apos;;
export function profilerParamInterceptor() {
  OpenAPI.interceptors.request.use(
    async (request) =&gt; {
      const searchParams = new URLSearchParams(location.search);
      const trigger = searchParams.get(&apos;XDEBUG_TRIGGER&apos;);
      if (trigger) {
        if (!request.params) {
          request.params = {};
        }
        request.params[&apos;XDEBUG_TRIGGER&apos;] = trigger;
      }
      return request;
    },
  );
}</file><file path="resources/app/api-client/requests/core/ApiError.ts">import type { ApiRequestOptions } from &apos;./ApiRequestOptions&apos;;
import type { ApiResult } from &apos;./ApiResult&apos;;
export class ApiError extends Error {
	public readonly url: string;
	public readonly status: number;
	public readonly statusText: string;
	public readonly body: unknown;
	public readonly request: ApiRequestOptions;
	constructor(request: ApiRequestOptions, response: ApiResult, message: string) {
		super(message);
		this.name = &apos;ApiError&apos;;
		this.url = response.url;
		this.status = response.status;
		this.statusText = response.statusText;
		this.body = response.body;
		this.request = request;
	}
}</file><file path="resources/app/api-client/requests/core/ApiResult.ts">export type ApiResult&lt;TData = any&gt; = {
	readonly body: TData;
	readonly ok: boolean;
	readonly status: number;
	readonly statusText: string;
	readonly url: string;
};</file><file path="resources/app/api-client/requests/core/CancelablePromise.ts">export class CancelError extends Error {
	constructor(message: string) {
		super(message);
		this.name = &apos;CancelError&apos;;
	}
	public get isCancelled(): boolean {
		return true;
	}
}
export interface OnCancel {
	readonly isResolved: boolean;
	readonly isRejected: boolean;
	readonly isCancelled: boolean;
	(cancelHandler: () =&gt; void): void;
}
export class CancelablePromise&lt;T&gt; implements Promise&lt;T&gt; {
	private _isResolved: boolean;
	private _isRejected: boolean;
	private _isCancelled: boolean;
	readonly cancelHandlers: (() =&gt; void)[];
	readonly promise: Promise&lt;T&gt;;
	private _resolve?: (value: T | PromiseLike&lt;T&gt;) =&gt; void;
	private _reject?: (reason?: unknown) =&gt; void;
	constructor(
		executor: (
			resolve: (value: T | PromiseLike&lt;T&gt;) =&gt; void,
			reject: (reason?: unknown) =&gt; void,
			onCancel: OnCancel
		) =&gt; void
	) {
		this._isResolved = false;
		this._isRejected = false;
		this._isCancelled = false;
		this.cancelHandlers = [];
		this.promise = new Promise&lt;T&gt;((resolve, reject) =&gt; {
			this._resolve = resolve;
			this._reject = reject;
			const onResolve = (value: T | PromiseLike&lt;T&gt;): void =&gt; {
				if (this._isResolved || this._isRejected || this._isCancelled) {
					return;
				}
				this._isResolved = true;
				if (this._resolve) this._resolve(value);
			};
			const onReject = (reason?: unknown): void =&gt; {
				if (this._isResolved || this._isRejected || this._isCancelled) {
					return;
				}
				this._isRejected = true;
				if (this._reject) this._reject(reason);
			};
			const onCancel = (cancelHandler: () =&gt; void): void =&gt; {
				if (this._isResolved || this._isRejected || this._isCancelled) {
					return;
				}
				this.cancelHandlers.push(cancelHandler);
			};
			Object.defineProperty(onCancel, &apos;isResolved&apos;, {
				get: (): boolean =&gt; this._isResolved,
			});
			Object.defineProperty(onCancel, &apos;isRejected&apos;, {
				get: (): boolean =&gt; this._isRejected,
			});
			Object.defineProperty(onCancel, &apos;isCancelled&apos;, {
				get: (): boolean =&gt; this._isCancelled,
			});
			return executor(onResolve, onReject, onCancel as OnCancel);
		});
	}
	get [Symbol.toStringTag]() {
		return &quot;Cancellable Promise&quot;;
	}
	public then&lt;TResult1 = T, TResult2 = never&gt;(
		onFulfilled?: ((value: T) =&gt; TResult1 | PromiseLike&lt;TResult1&gt;) | null,
		onRejected?: ((reason: unknown) =&gt; TResult2 | PromiseLike&lt;TResult2&gt;) | null
	): Promise&lt;TResult1 | TResult2&gt; {
		return this.promise.then(onFulfilled, onRejected);
	}
	public catch&lt;TResult = never&gt;(
		onRejected?: ((reason: unknown) =&gt; TResult | PromiseLike&lt;TResult&gt;) | null
	): Promise&lt;T | TResult&gt; {
		return this.promise.catch(onRejected);
	}
	public finally(onFinally?: (() =&gt; void) | null): Promise&lt;T&gt; {
		return this.promise.finally(onFinally);
	}
	public cancel(): void {
		if (this._isResolved || this._isRejected || this._isCancelled) {
			return;
		}
		this._isCancelled = true;
		if (this.cancelHandlers.length) {
			try {
				for (const cancelHandler of this.cancelHandlers) {
					cancelHandler();
				}
			} catch (error) {
				console.warn(&apos;Cancellation threw an error&apos;, error);
				return;
			}
		}
		this.cancelHandlers.length = 0;
		if (this._reject) this._reject(new CancelError(&apos;Request aborted&apos;));
	}
	public get isCancelled(): boolean {
		return this._isCancelled;
	}
}</file><file path="resources/app/api-client/requests/index.ts">// This file is auto-generated by @hey-api/openapi-ts
export { ApiError } from &apos;./core/ApiError&apos;;
export { CancelablePromise, CancelError } from &apos;./core/CancelablePromise&apos;;
export { OpenAPI, type OpenAPIConfig } from &apos;./core/OpenAPI&apos;;
export * from &apos;./schemas.gen&apos;;
export * from &apos;./services.gen&apos;;
export * from &apos;./types.gen&apos;;</file><file path="resources/app/assets/svg/baander-logo.svg">&lt;?xml version=&quot;1.0&quot; encoding=&quot;iso-8859-1&quot;?&gt;
&lt;!-- Uploaded to: SVG Repo, www.svgrepo.com, Generator: SVG Repo Mixer Tools --&gt;
&lt;svg height=&quot;800px&quot; width=&quot;800px&quot; version=&quot;1.1&quot; id=&quot;Layer_1&quot; xmlns=&quot;http://www.w3.org/2000/svg&quot; xmlns:xlink=&quot;http://www.w3.org/1999/xlink&quot; 
	 viewBox=&quot;0 0 512 512&quot; xml:space=&quot;preserve&quot;&gt;
&lt;path style=&quot;fill:#F9D84E;&quot; d=&quot;M503.172,406.069H8.828c-4.875,0-8.828-3.953-8.828-8.828V233.122l11.034-60.98h489.931L512,230.498
	v166.743C512,402.116,508.047,406.069,503.172,406.069z&quot;/&gt;
&lt;path id=&quot;SVGCleanerId_0&quot; style=&quot;fill:#4E5058;&quot; d=&quot;M512,238.345h-17.655l-35.31-61.793H52.966l-35.31,61.793H0V114.759
	c0-4.875,3.953-8.828,8.828-8.828h494.345c4.875,0,8.828,3.953,8.828,8.828V238.345z&quot;/&gt;
&lt;path style=&quot;fill:#FFC20D;&quot; d=&quot;M22.069,388.414c-2.438,0-4.414-1.976-4.414-4.414V105.931H8.828c-4.875,0-8.828,3.953-8.828,8.828
	v282.483c0,4.875,3.953,8.828,8.828,8.828h494.345c4.875,0,8.828-3.953,8.828-8.828v-8.828H22.069z&quot;/&gt;
&lt;g&gt;
	&lt;path id=&quot;SVGCleanerId_0_1_&quot; style=&quot;fill:#4E5058;&quot; d=&quot;M512,238.345h-17.655l-35.31-61.793H52.966l-35.31,61.793H0V114.759
		c0-4.875,3.953-8.828,8.828-8.828h494.345c4.875,0,8.828,3.953,8.828,8.828V238.345z&quot;/&gt;
&lt;/g&gt;
&lt;path style=&quot;fill:#383A43;&quot; d=&quot;M26.483,105.931H8.828c-4.875,0-8.828,3.953-8.828,8.828v123.586h17.655V114.759
	C17.655,109.884,21.608,105.931,26.483,105.931z&quot;/&gt;
&lt;path style=&quot;fill:#F9D84E;&quot; d=&quot;M300.138,353.103h-88.276c-9.751,0-17.655-7.904-17.655-17.655v-88.276
	c0-9.751,7.904-17.655,17.655-17.655h88.276c9.751,0,17.655,7.904,17.655,17.655v88.276
	C317.793,345.199,309.889,353.103,300.138,353.103z&quot;/&gt;
&lt;path id=&quot;SVGCleanerId_1&quot; style=&quot;fill:#45CAE0;&quot; d=&quot;M317.793,247.172c0-9.751-7.904-17.655-17.655-17.655h-88.276
	c-9.751,0-17.655,7.904-17.655,17.655v18.391h123.586V247.172z&quot;/&gt;
&lt;path style=&quot;fill:#E9E9EA;&quot; d=&quot;M300.138,353.103h-88.276c-9.751,0-17.655-7.904-17.655-17.655v-88.276
	c0-9.751,7.904-17.655,17.655-17.655h88.276c9.751,0,17.655,7.904,17.655,17.655v88.276
	C317.793,345.199,309.889,353.103,300.138,353.103z&quot;/&gt;
&lt;g&gt;
	&lt;path id=&quot;SVGCleanerId_1_1_&quot; style=&quot;fill:#45CAE0;&quot; d=&quot;M317.793,247.172c0-9.751-7.904-17.655-17.655-17.655h-88.276
		c-9.751,0-17.655,7.904-17.655,17.655v18.391h123.586V247.172z&quot;/&gt;
&lt;/g&gt;
&lt;g&gt;
	&lt;path style=&quot;fill:#BDBDC0;&quot; d=&quot;M282.483,300.138h-52.966c-4.875,0-8.828-3.953-8.828-8.828s3.953-8.828,8.828-8.828h52.966
		c4.875,0,8.828,3.953,8.828,8.828S287.358,300.138,282.483,300.138z&quot;/&gt;
	&lt;path style=&quot;fill:#BDBDC0;&quot; d=&quot;M282.483,326.621h-52.966c-4.875,0-8.828-3.953-8.828-8.828s3.953-8.828,8.828-8.828h52.966
		c4.875,0,8.828,3.953,8.828,8.828S287.358,326.621,282.483,326.621z&quot;/&gt;
&lt;/g&gt;
&lt;g&gt;
	&lt;path style=&quot;fill:#E9E9EA;&quot; d=&quot;M97.103,370.759h70.621c4.875,0,8.828-3.953,8.828-8.828V220.69c0-4.875-3.953-8.828-8.828-8.828
		H97.103c-24.376,0-44.138,19.762-44.138,44.138v70.621C52.966,350.997,72.727,370.759,97.103,370.759z&quot;/&gt;
	&lt;path style=&quot;fill:#E9E9EA;&quot; d=&quot;M414.897,370.759h-70.621c-4.875,0-8.828-3.953-8.828-8.828V220.69c0-4.875,3.953-8.828,8.828-8.828
		h70.621c24.376,0,44.138,19.762,44.138,44.138v70.621C459.034,350.997,439.273,370.759,414.897,370.759z&quot;/&gt;
&lt;/g&gt;
&lt;path style=&quot;fill:#BDBDC0;&quot; d=&quot;M406.253,291.31c0-39.002-31.801-70.621-70.805-70.621v141.241
	C374.451,361.931,406.253,330.313,406.253,291.31z&quot;/&gt;
&lt;path style=&quot;fill:#64666D;&quot; d=&quot;M335.448,353.103c34.127,0,61.977-27.666,61.977-61.793s-27.85-61.793-61.977-61.793
	c-0.062,0,0,0.004,0,0.004v26.483c0,0-0.062-0.004,0-0.004c19.501,0,33.288,15.809,33.288,35.31c0,19.501-13.786,35.31-33.288,35.31
	c-0.062,0,0-0.004,0-0.004v26.483C335.448,353.099,335.386,353.103,335.448,353.103z&quot;/&gt;
&lt;path style=&quot;fill:#A7A7AB;&quot; d=&quot;M335.448,273.655c9.751,0,17.839,7.904,17.839,17.655c0,9.751-8.088,17.655-17.839,17.655
	c-0.062,0,0.062-0.009,0-0.009v17.66c0.062,0-0.062,0.004,0,0.004c19.501,0,35.495-15.809,35.495-35.31
	c0-19.501-15.993-35.31-35.495-35.31c-0.062,0,0.062,0.004,0,0.004v17.66C335.51,273.664,335.386,273.655,335.448,273.655z&quot;/&gt;
&lt;path style=&quot;fill:#BDBDC0;&quot; d=&quot;M105.931,291.31c0,39.003,31.801,70.621,70.805,70.621V220.69
	C137.732,220.69,105.931,252.308,105.931,291.31z&quot;/&gt;
&lt;path style=&quot;fill:#64666D;&quot; d=&quot;M176.552,229.517c-34.207,0-62.023,27.666-62.023,61.793s27.816,61.793,62.023,61.793v-0.004v-26.483
	v0.004c-19.862,0-33.333-15.809-33.333-35.31c0-19.501,13.471-35.31,33.333-35.31v0.004v-26.483V229.517z&quot;/&gt;
&lt;path style=&quot;fill:#A7A7AB;&quot; d=&quot;M176.736,308.966c-9.751,0-17.839-7.904-17.839-17.655c0-9.751,8.088-17.655,17.839-17.655
	c0.062,0-0.062,0.009,0,0.009v-17.66c-0.062,0,0.062-0.004,0-0.004c-19.501,0-35.495,15.809-35.495,35.31
	c0,19.501,15.993,35.31,35.495,35.31c0.062,0-0.062-0.004,0-0.004v-17.66C176.674,308.957,176.798,308.966,176.736,308.966z&quot;/&gt;
&lt;/svg&gt;</file><file path="resources/app/common/i18n.ts">import i18n from &apos;i18next&apos;;
import { initReactI18next } from &apos;react-i18next&apos;;
import LanguageDetector from &apos;i18next-browser-languagedetector&apos;;
i18n
  .use(LanguageDetector)
  .use(initReactI18next)
  .init({
    fallbackLng: &apos;en&apos;,
    interpolation: {
      escapeValue: false, // not needed for react as it escapes by default
    },
    resources: LARAVEL_TRANSLATIONS
  });
export default i18n;</file><file path="resources/app/components/apm/apm-error-boundary.tsx">import { Component, ErrorInfo, ReactNode } from &apos;react&apos;;
import { reactApm } from &apos;@/services/apm&apos;;
interface Props {
  children: ReactNode;
  fallback?: ReactNode;
  onError?: (error: Error, errorInfo: ErrorInfo) =&gt; void;
}
interface State {
  hasError: boolean;
  error?: Error;
}
export class ApmErrorBoundary extends Component&lt;Props, State&gt; {
  constructor(props: Props) {
    super(props);
    this.state = { hasError: false };
  }
  static getDerivedStateFromError(error: Error): State {
    return { hasError: true, error };
  }
  componentDidCatch(error: Error, errorInfo: ErrorInfo) {
    // Track the error in APM
    reactApm.captureReactError(error, &apos;ErrorBoundary&apos;, {
      componentStack: errorInfo.componentStack,
      errorBoundary: true,
    });
    // Call custom error handler if provided
    this.props.onError?.(error, errorInfo);
    console.error(&apos;React Error Boundary caught an error:&apos;, error, errorInfo);
  }
  render() {
    if (this.state.hasError) {
      return this.props.fallback || (
        &lt;div style={{ padding: &apos;20px&apos;, textAlign: &apos;center&apos; }}&gt;
          &lt;h2&gt;Something went wrong&lt;/h2&gt;
          &lt;p&gt;An error occurred while rendering this component.&lt;/p&gt;
          &lt;button onClick={() =&gt; this.setState({ hasError: false, error: undefined })}&gt;
            Try again
          &lt;/button&gt;
        &lt;/div&gt;
      );
    }
    return this.props.children;
  }
}</file><file path="resources/app/components/apm/with-apm-instrumentation.tsx">// components/apm/with-apm-instrumentation.tsx
import React, { ComponentType, useEffect, useRef, useState } from &apos;react&apos;;
import { reactApm } from &apos;@/services/apm&apos;;
interface ApmInstrumentationOptions {
  trackRenders?: boolean;
  trackMounts?: boolean;
  trackPropChanges?: boolean;
  trackErrors?: boolean;
}
export function withApmInstrumentation&lt;P extends object&gt;(
  WrappedComponent: ComponentType&lt;P&gt;,
  componentName?: string,
  options: ApmInstrumentationOptions = {
    trackRenders: true,
    trackMounts: true,
    trackPropChanges: true,
    trackErrors: true,
  }
) {
  const displayName = componentName || WrappedComponent.displayName || WrappedComponent.name || &apos;Component&apos;;
  const InstrumentedComponent: React.FC&lt;P&gt; = (props) =&gt; {
    const renderSpanRef = useRef&lt;any&gt;(null);
    const mountSpanRef = useRef&lt;any&gt;(null);
    const prevPropsRef = useRef&lt;P&gt;(props);
    const [hasError, setHasError] = useState(false);
    // Track component mount
    useEffect(() =&gt; {
      if (options.trackMounts) {
        mountSpanRef.current = reactApm.trackComponentMount(displayName);
      }
      return () =&gt; {
        // Track component unmount
        if (options.trackMounts &amp;&amp; mountSpanRef.current) {
          mountSpanRef.current.end();
          reactApm.trackComponentUnmount(displayName);
        }
      };
    }, []);
    // Track prop changes
    useEffect(() =&gt; {
      if (options.trackPropChanges &amp;&amp; prevPropsRef.current) {
        const changedProps = Object.keys(props).filter(
          key =&gt; (props as any)[key] !== (prevPropsRef.current as any)[key]
        );
        if (changedProps.length &gt; 0) {
          const span = reactApm.trackPropChanges(displayName, changedProps);
          span?.end();
        }
      }
      prevPropsRef.current = props;
    });
    // Track renders
    useEffect(() =&gt; {
      if (options.trackRenders) {
        renderSpanRef.current = reactApm.startComponentRender(displayName);
        // End render span after a microtask to capture the full render
        Promise.resolve().then(() =&gt; {
          if (renderSpanRef.current) {
            renderSpanRef.current.end();
          }
        });
      }
    });
    if (hasError) {
      return &lt;div&gt;Something went wrong in {displayName}&lt;/div&gt;;
    }
    try {
      return &lt;WrappedComponent {...props} /&gt;;
    } catch (error) {
      if (options.trackErrors) {
        reactApm.captureReactError(
          error as Error,
          displayName,
          { props }
        );
      }
      setHasError(true);
      throw error;
    }
  };
  InstrumentedComponent.displayName = `withApmInstrumentation(${displayName})`;
  return InstrumentedComponent;
}</file><file path="resources/app/components/song-table/song-table.module.scss">.scrollList {
  border-right: 1px solid #e0dddd;
  overflow-x: auto;
  max-width: 100%;
  table {
    border-spacing: unset;
    table-layout: fixed;
    border-collapse: collapse;
  }
  th {
    background-color: var(--red-1);
    position: sticky;
    top: 0;
    z-index: 10;
    padding: 6px;
    text-align: left;
    font-weight: var(--font-weight-bold);
    font-size: 0.875rem;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
  }
  td {
    padding: 6px;
    text-align: left;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
  }
  tbody tr:hover {
    background-color: var(--accent-2);
  }
}
.header {
  padding: 8px;
}
.title {
  margin: 0;
  font-size: 1.5rem;
}
.description {
  margin: 4px 0 0;
  font-size: 0.875rem;
}
.listItem {
  cursor: pointer;
}
.titleCell {
  display: flex;
  align-items: center;
}
.titleCellNowPlayingIcon {
  color: var(--accent-8);
  margin-right: 8px;
}
.titleCellTitle {
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
}
.scrollbar {
  --sb-track-color: &apos;transparent&apos;;
  --sb-thumb-color: #828282;
  --sb-size: 6px;
}
.scrollbar::-webkit-scrollbar {
  width: var(--sb-size)
}
.scrollbar::-webkit-scrollbar-track {
  background: var(--sb-track-color);
  border-radius: 3px;
}
.scrollbar::-webkit-scrollbar-thumb {
  background: var(--sb-thumb-color);
  border-radius: 3px;
}
@supports not selector(::-webkit-scrollbar) {
  .scrollbar {
    scrollbar-color: var(--sb-thumb-color)
    var(--sb-track-color);
  }
}</file><file path="resources/app/components/video-player/advanced-video-player.tsx">import React, { useState, useRef } from &apos;react&apos;;
import {
  Box,
  Flex,
  Text,
  IconButton,
  Dialog,
  Select,
  Slider,
  Badge,
  Card,
  Tooltip,
  Separator
} from &apos;@radix-ui/themes&apos;;
import {
  PlayIcon,
  PauseIcon,
  SpeakerLoudIcon,
  GearIcon,
  Cross2Icon,
  VideoIcon
} from &apos;@radix-ui/react-icons&apos;;
import VideoPlayer from &apos;./video-player&apos;;
interface VideoSource {
  url: string;
  type: &apos;hls&apos; | &apos;dash&apos; | &apos;mp4&apos;;
  label: string;
  quality?: string;
}
interface AdvancedVideoPlayerProps {
  sources: VideoSource[];
  poster?: string;
  autoPlay?: boolean;
  className?: string;
  onSourceChange?: (source: VideoSource) =&gt; void;
}
export const AdvancedVideoPlayer: React.FC&lt;AdvancedVideoPlayerProps&gt; = ({
                                                                          sources,
                                                                          poster,
                                                                          autoPlay = false,
                                                                          className = &apos;&apos;,
                                                                          onSourceChange,
                                                                        }) =&gt; {
  const [selectedSource, setSelectedSource] = useState&lt;VideoSource | null&gt;(sources[0] || null);
  const [currentTime, setCurrentTime] = useState(0);
  const [duration, setDuration] = useState(0);
  const [isPlaying, setIsPlaying] = useState(false);
  const [showSettings, setShowSettings] = useState(false);
  const [playbackRate, setPlaybackRate] = useState(1);
  const videoPlayerRef = useRef&lt;any&gt;(null);
  const handleSourceChange = (sourceUrl: string) =&gt; {
    const source = sources.find(s =&gt; s.url === sourceUrl);
    if (source) {
      setSelectedSource(source);
      onSourceChange?.(source);
    }
  };
  const handlePlaybackRateChange = (rate: string) =&gt; {
    const rateValue = parseFloat(rate);
    setPlaybackRate(rateValue);
    if (videoPlayerRef.current?.videoRef?.current) {
      videoPlayerRef.current.videoRef.current.playbackRate = rateValue;
    }
  };
  const formatTime = (time: number) =&gt; {
    const hours = Math.floor(time / 3600);
    const minutes = Math.floor((time % 3600) / 60);
    const seconds = Math.floor(time % 60);
    if (hours &gt; 0) {
      return `${hours}:${minutes.toString().padStart(2, &apos;0&apos;)}:${seconds.toString().padStart(2, &apos;0&apos;)}`;
    }
    return `${minutes}:${seconds.toString().padStart(2, &apos;0&apos;)}`;
  };
  const playbackRates = [
    { value: &apos;0.25&apos;, label: &apos;0.25x&apos; },
    { value: &apos;0.5&apos;, label: &apos;0.5x&apos; },
    { value: &apos;0.75&apos;, label: &apos;0.75x&apos; },
    { value: &apos;1&apos;, label: &apos;Normal&apos; },
    { value: &apos;1.25&apos;, label: &apos;1.25x&apos; },
    { value: &apos;1.5&apos;, label: &apos;1.5x&apos; },
    { value: &apos;2&apos;, label: &apos;2x&apos; },
  ];
  if (!selectedSource) {
    return (
      &lt;Card className={className}&gt;
        &lt;Flex direction=&quot;column&quot; align=&quot;center&quot; justify=&quot;center&quot; style={{ minHeight: &apos;200px&apos; }}&gt;
          &lt;VideoIcon width=&quot;32&quot; height=&quot;32&quot; /&gt;
          &lt;Text size=&quot;4&quot; weight=&quot;bold&quot; mt=&quot;3&quot; mb=&quot;2&quot;&gt;
            No video sources available
          &lt;/Text&gt;
          &lt;Text size=&quot;2&quot; color=&quot;gray&quot;&gt;
            Please provide at least one video source
          &lt;/Text&gt;
        &lt;/Flex&gt;
      &lt;/Card&gt;
    );
  }
  return (
    &lt;Box className={className} style={{ position: &apos;relative&apos;, width: &apos;100%&apos; }}&gt;
      {/* Main Video Player */}
      &lt;VideoPlayer
        ref={videoPlayerRef}
        src={selectedSource.url}
        type={selectedSource.type}
        poster={poster}
        autoPlay={autoPlay}
        controls={false} // We&apos;ll use custom controls
        onTimeUpdate={setCurrentTime}
        onLoadedData={() =&gt; {
          if (videoPlayerRef.current?.videoRef?.current) {
            setDuration(videoPlayerRef.current.videoRef.current.duration || 0);
          }
        }}
        onPlay={() =&gt; setIsPlaying(true)}
        onPause={() =&gt; setIsPlaying(false)}
      /&gt;
      {/* Custom Controls Overlay */}
      &lt;Box
        position=&quot;absolute&quot;
        bottom=&quot;0&quot;
        left=&quot;0&quot;
        right=&quot;0&quot;
        p=&quot;4&quot;
        style={{
          background: &apos;linear-gradient(transparent, rgba(0, 0, 0, 0.9))&apos;,
          borderBottomLeftRadius: &apos;var(--radius-3)&apos;,
          borderBottomRightRadius: &apos;var(--radius-3)&apos;,
        }}
      &gt;
        {/* Progress Bar */}
        &lt;Box mb=&quot;3&quot;&gt;
          &lt;Slider
            value={[currentTime]}
            max={duration || 100}
            step={0.1}
            onValueChange={(value) =&gt; {
              if (videoPlayerRef.current?.videoRef?.current) {
                videoPlayerRef.current.videoRef.current.currentTime = value[0];
              }
            }}
            style={{ width: &apos;100%&apos; }}
          /&gt;
        &lt;/Box&gt;
        {/* Control Buttons */}
        &lt;Flex align=&quot;center&quot; justify=&quot;between&quot;&gt;
          &lt;Flex align=&quot;center&quot; gap=&quot;3&quot;&gt;
            {/* Play/Pause */}
            &lt;Tooltip content={isPlaying ? &apos;Pause (Space)&apos; : &apos;Play (Space)&apos;}&gt;
              &lt;IconButton
                variant=&quot;ghost&quot;
                size=&quot;3&quot;
                onClick={() =&gt; {
                  if (isPlaying) {
                    videoPlayerRef.current?.videoRef?.current?.pause();
                  } else {
                    videoPlayerRef.current?.videoRef?.current?.play();
                  }
                }}
                style={{ color: &apos;white&apos; }}
              &gt;
                {isPlaying ? &lt;PauseIcon width=&quot;20&quot; height=&quot;20&quot; /&gt; : &lt;PlayIcon width=&quot;20&quot; height=&quot;20&quot; /&gt;}
              &lt;/IconButton&gt;
            &lt;/Tooltip&gt;
            {/* Volume Control */}
            &lt;Flex align=&quot;center&quot; gap=&quot;2&quot;&gt;
              &lt;IconButton
                variant=&quot;ghost&quot;
                size=&quot;2&quot;
                onClick={() =&gt; {
                  if (videoPlayerRef.current?.videoRef?.current) {
                    const video = videoPlayerRef.current.videoRef.current;
                    video.muted = !video.muted;
                  }
                }}
                style={{ color: &apos;white&apos; }}
              &gt;
                &lt;SpeakerLoudIcon /&gt;
              &lt;/IconButton&gt;
              &lt;Box style={{ width: &apos;80px&apos; }}&gt;
                &lt;Slider
                  defaultValue={[1]}
                  max={1}
                  step={0.1}
                  onValueChange={(value) =&gt; {
                    if (videoPlayerRef.current?.videoRef?.current) {
                      videoPlayerRef.current.videoRef.current.volume = value[0];
                    }
                  }}
                  size=&quot;1&quot;
                /&gt;
              &lt;/Box&gt;
            &lt;/Flex&gt;
            {/* Time Display */}
            &lt;Text size=&quot;2&quot; style={{ color: &apos;white&apos;, fontFamily: &apos;var(--font-mono)&apos; }}&gt;
              {formatTime(currentTime)} / {formatTime(duration)}
            &lt;/Text&gt;
            {/* Current Source Badge */}
            &lt;Badge variant=&quot;soft&quot; size=&quot;1&quot;&gt;
              {selectedSource.label}
              {selectedSource.quality &amp;&amp; ` - ${selectedSource.quality}`}
            &lt;/Badge&gt;
          &lt;/Flex&gt;
          {/* Settings Button */}
          &lt;Dialog.Root open={showSettings} onOpenChange={setShowSettings}&gt;
            &lt;Dialog.Trigger&gt;
              &lt;Tooltip content=&quot;Settings&quot;&gt;
                &lt;IconButton
                  variant=&quot;ghost&quot;
                  size=&quot;2&quot;
                  style={{ color: &apos;white&apos; }}
                &gt;
                  &lt;GearIcon /&gt;
                &lt;/IconButton&gt;
              &lt;/Tooltip&gt;
            &lt;/Dialog.Trigger&gt;
            &lt;Dialog.Content maxWidth=&quot;400px&quot;&gt;
              &lt;Dialog.Title&gt;Video Settings&lt;/Dialog.Title&gt;
              &lt;Flex direction=&quot;column&quot; gap=&quot;4&quot; mt=&quot;4&quot;&gt;
                {/* Quality Selection */}
                {sources.length &gt; 1 &amp;&amp; (
                  &lt;Box&gt;
                    &lt;Text size=&quot;2&quot; weight=&quot;bold&quot; mb=&quot;2&quot;&gt;Quality&lt;/Text&gt;
                    &lt;Select.Root value={selectedSource.url} onValueChange={handleSourceChange}&gt;
                      &lt;Select.Trigger style={{ width: &apos;100%&apos; }}&gt;
                        &lt;Select.Label /&gt;
                      &lt;/Select.Trigger&gt;
                      &lt;Select.Content&gt;
                        {sources.map((source, index) =&gt; (
                          &lt;Select.Item key={index} value={source.url}&gt;
                            &lt;Flex align=&quot;center&quot; justify=&quot;between&quot; style={{ width: &apos;100%&apos; }}&gt;
                              &lt;Text&gt;{source.label}&lt;/Text&gt;
                              {source.quality &amp;&amp; (
                                &lt;Badge variant=&quot;soft&quot; size=&quot;1&quot; ml=&quot;2&quot;&gt;
                                  {source.quality}
                                &lt;/Badge&gt;
                              )}
                            &lt;/Flex&gt;
                          &lt;/Select.Item&gt;
                        ))}
                      &lt;/Select.Content&gt;
                    &lt;/Select.Root&gt;
                  &lt;/Box&gt;
                )}
                &lt;Separator /&gt;
                {/* Playback Speed */}
                &lt;Box&gt;
                  &lt;Text size=&quot;2&quot; weight=&quot;bold&quot; mb=&quot;2&quot;&gt;Playback Speed&lt;/Text&gt;
                  &lt;Select.Root value={playbackRate.toString()} onValueChange={handlePlaybackRateChange}&gt;
                    &lt;Select.Trigger style={{ width: &apos;100%&apos; }}&gt;
                      &lt;Select.Label /&gt;
                    &lt;/Select.Trigger&gt;
                    &lt;Select.Content&gt;
                      {playbackRates.map((rate) =&gt; (
                        &lt;Select.Item key={rate.value} value={rate.value}&gt;
                          {rate.label}
                        &lt;/Select.Item&gt;
                      ))}
                    &lt;/Select.Content&gt;
                  &lt;/Select.Root&gt;
                &lt;/Box&gt;
              &lt;/Flex&gt;
              &lt;Dialog.Close&gt;
                &lt;IconButton
                  style={{ position: &apos;absolute&apos;, top: &apos;10px&apos;, right: &apos;10px&apos; }}
                  variant=&quot;ghost&quot;
                  size=&quot;1&quot;
                &gt;
                  &lt;Cross2Icon /&gt;
                &lt;/IconButton&gt;
              &lt;/Dialog.Close&gt;
            &lt;/Dialog.Content&gt;
          &lt;/Dialog.Root&gt;
        &lt;/Flex&gt;
      &lt;/Box&gt;
    &lt;/Box&gt;
  );
};
export default AdvancedVideoPlayer;</file><file path="resources/app/components/video-player/video-player.tsx">import React, { useRef, useEffect, useState, useCallback } from &apos;react&apos;;
import {
  Box,
  Flex,
  Text,
  Card,
  Spinner,
  IconButton,
  Slider,
  Tooltip,
  Dialog,
  Button,
  ScrollArea,
  Badge,
  Separator,
  Select,
} from &apos;@radix-ui/themes&apos;;
import {
  PlayIcon,
  PauseIcon,
  SpeakerLoudIcon,
  SpeakerOffIcon,
  FileTextIcon,
  Cross2Icon,
  DownloadIcon,
  TrashIcon,
  ChatBubbleIcon,
} from &apos;@radix-ui/react-icons&apos;;
import Hls from &apos;hls.js&apos;;
import * as dashjs from &apos;dashjs&apos;;
interface LogEntry {
  timestamp: number;
  source: &apos;video&apos; | &apos;hls&apos; | &apos;dash&apos; | &apos;player&apos; | &apos;subtitles&apos;;
  level: &apos;info&apos; | &apos;warn&apos; | &apos;error&apos; | &apos;debug&apos;;
  event: string;
  data?: any;
  message?: string;
}
interface SubtitleTrack {
  id: string;
  label: string;
  language: string;
  src?: string;
  kind?: &apos;subtitles&apos; | &apos;captions&apos; | &apos;descriptions&apos; | &apos;chapters&apos; | &apos;metadata&apos;;
  default?: boolean;
  srcLang?: string;
}
export interface VideoPlayerProps extends React.RefAttributes&lt;HTMLVideoElement&gt; {
  src: string;
  type?: &apos;hls&apos; | &apos;dash&apos; | &apos;mp4&apos;;
  autoPlay?: boolean;
  controls?: boolean;
  muted?: boolean;
  loop?: boolean;
  poster?: string;
  className?: string;
  debug?: boolean;
  subtitles?: SubtitleTrack[];
  onLoadStart?: () =&gt; void;
  onLoadedData?: () =&gt; void;
  onPlay?: () =&gt; void;
  onPause?: () =&gt; void;
  onEnded?: () =&gt; void;
  onError?: (error: any) =&gt; void;
  onTimeUpdate?: (currentTime: number) =&gt; void;
  onLogEntry?: (entry: LogEntry) =&gt; void;
  onSubtitleChange?: (track: SubtitleTrack | null) =&gt; void;
}
export const VideoPlayer: React.FC&lt;VideoPlayerProps&gt; = ({
                                                          src,
                                                          type,
                                                          autoPlay = false,
                                                          controls = true,
                                                          muted = false,
                                                          loop = false,
                                                          poster,
                                                          className = &apos;&apos;,
                                                          debug = false,
                                                          subtitles = [],
                                                          onLoadStart,
                                                          onLoadedData,
                                                          onPlay,
                                                          onPause,
                                                          onEnded,
                                                          onError,
                                                          onTimeUpdate,
                                                          onLogEntry,
                                                          onSubtitleChange,
                                                        }) =&gt; {
  const videoRef = useRef&lt;HTMLVideoElement&gt;(null);
  const hlsRef = useRef&lt;Hls | null&gt;(null);
  const dashPlayerRef = useRef&lt;dashjs.MediaPlayerClass | null&gt;(null);
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState&lt;string | null&gt;(null);
  const [currentTime, setCurrentTime] = useState(0);
  const [duration, setDuration] = useState(0);
  const [isPlaying, setIsPlaying] = useState(false);
  const [isMuted, setIsMuted] = useState(muted);
  const [volume, setVolume] = useState(1);
  const [showControls, setShowControls] = useState(true);
  // Debug state
  const [logs, setLogs] = useState&lt;LogEntry[]&gt;([]);
  const [showDebugger, setShowDebugger] = useState(false);
  const [autoScroll, setAutoScroll] = useState(true);
  const scrollAreaRef = useRef&lt;HTMLDivElement&gt;(null);
  // Subtitle state
  const [availableSubtitles, setAvailableSubtitles] = useState&lt;SubtitleTrack[]&gt;([]);
  const [selectedSubtitle, setSelectedSubtitle] = useState&lt;string | null&gt;(null);
  const [showSubtitleSelector, setShowSubtitleSelector] = useState(false);
  // Logger function
  const addLog = useCallback((entry: Omit&lt;LogEntry, &apos;timestamp&apos;&gt;) =&gt; {
    const logEntry: LogEntry = {
      ...entry,
      timestamp: Date.now(),
    };
    setLogs(prev =&gt; [...prev, logEntry]);
    onLogEntry?.(logEntry);
    // Also log to console in debug mode
    if (debug) {
      const logLevel = entry.level === &apos;info&apos; ? &apos;log&apos; : entry.level;
      console[logLevel](`[${entry.source.toUpperCase()}] ${entry.event}:`, entry.data || entry.message);
    }
  }, [debug, onLogEntry]);
  // Clear logs
  const clearLogs = useCallback(() =&gt; {
    setLogs([]);
  }, []);
  // Export logs
  const exportLogs = useCallback(() =&gt; {
    const logsJson = JSON.stringify(logs, null, 2);
    const blob = new Blob([logsJson], { type: &apos;application/json&apos; });
    const url = URL.createObjectURL(blob);
    const a = document.createElement(&apos;a&apos;);
    a.href = url;
    a.download = `video-player-logs-${new Date().toISOString()}.json`;
    a.click();
    URL.revokeObjectURL(url);
  }, [logs]);
  // Auto scroll to bottom when new logs are added
  useEffect(() =&gt; {
    if (autoScroll &amp;&amp; scrollAreaRef.current) {
      scrollAreaRef.current.scrollTop = scrollAreaRef.current.scrollHeight;
    }
  }, [logs, autoScroll]);
  // Initialize subtitles
  const initializeSubtitles = useCallback(() =&gt; {
    const video = videoRef.current;
    if (!video) return;
    // Clear existing tracks
    const existingTracks = Array.from(video.textTracks);
    existingTracks.forEach(track =&gt; {
      track.mode = &apos;disabled&apos;;
    });
    // Combine external subtitles with provided subtitles
    const allSubtitles = [...subtitles];
    // Add subtitles from HLS/DASH if available
    if (hlsRef.current) {
      const hlsSubtitles = hlsRef.current.subtitleTracks;
      hlsSubtitles.forEach((track, index) =&gt; {
        allSubtitles.push({
          id: `hls-${index}`,
          label: track.name || `Track ${index + 1}`,
          language: track.lang || &apos;unknown&apos;,
          kind: &apos;subtitles&apos;
        });
      });
    }
    if (dashPlayerRef.current) {
      const dashSubtitles = dashPlayerRef.current.getTracksFor(&apos;text&apos;);
      dashSubtitles.forEach((track, index) =&gt; {
        allSubtitles.push({
          id: `dash-${index}`,
          label: track.lang || `Track ${index + 1}`,
          language: track.lang || &apos;unknown&apos;,
          kind: &apos;subtitles&apos;
        });
      });
    }
    // Add HTML text tracks
    existingTracks.forEach((track, index) =&gt; {
      allSubtitles.push({
        id: `html-${index}`,
        label: track.label || `Track ${index + 1}`,
        language: track.language || &apos;unknown&apos;,
        kind: track.kind as any,
        srcLang: track.language
      });
    });
    setAvailableSubtitles(allSubtitles);
    addLog({
      source: &apos;subtitles&apos;,
      level: &apos;info&apos;,
      event: &apos;initialized&apos;,
      data: {
        total: allSubtitles.length,
        tracks: allSubtitles.map(t =&gt; ({ id: t.id, label: t.label, language: t.language }))
      }
    });
    // Set default subtitle if specified
    const defaultTrack = allSubtitles.find(track =&gt; track.default);
    if (defaultTrack) {
      setSelectedSubtitle(defaultTrack.id);
      handleSubtitleSelection(defaultTrack.id);
    }
  }, [subtitles, addLog]);
  // Handle subtitle selection
  const handleSubtitleSelection = useCallback((trackId: string | null) =&gt; {
    const video = videoRef.current;
    if (!video) return;
    addLog({
      source: &apos;subtitles&apos;,
      level: &apos;info&apos;,
      event: &apos;track_selected&apos;,
      data: { trackId }
    });
    // Disable all tracks first
    Array.from(video.textTracks).forEach(track =&gt; {
      track.mode = &apos;disabled&apos;;
    });
    if (!trackId || trackId === &apos;off&apos;) {
      setSelectedSubtitle(null);
      onSubtitleChange?.(null);
      // Disable HLS/DASH subtitles
      if (hlsRef.current) {
        hlsRef.current.subtitleTrack = -1;
      }
      if (dashPlayerRef.current) {
        dashPlayerRef.current.setTextTrack(-1);
      }
      return;
    }
    const track = availableSubtitles.find(t =&gt; t.id === trackId);
    if (!track) return;
    setSelectedSubtitle(trackId);
    onSubtitleChange?.(track);
    // Handle different track types
    if (trackId.startsWith(&apos;hls-&apos;) &amp;&amp; hlsRef.current) {
      const hlsTrackIndex = parseInt(trackId.replace(&apos;hls-&apos;, &apos;&apos;));
      hlsRef.current.subtitleTrack = hlsTrackIndex;
    } else if (trackId.startsWith(&apos;dash-&apos;) &amp;&amp; dashPlayerRef.current) {
      const dashTrackIndex = parseInt(trackId.replace(&apos;dash-&apos;, &apos;&apos;));
      dashPlayerRef.current.setTextTrack(dashTrackIndex);
    } else if (trackId.startsWith(&apos;html-&apos;)) {
      const htmlTrackIndex = parseInt(trackId.replace(&apos;html-&apos;, &apos;&apos;));
      const htmlTrack = video.textTracks[htmlTrackIndex];
      if (htmlTrack) {
        htmlTrack.mode = &apos;showing&apos;;
      }
    } else {
      // External subtitle track
      if (track.src) {
        // Add external subtitle track
        const trackElement = document.createElement(&apos;track&apos;);
        trackElement.kind = track.kind || &apos;subtitles&apos;;
        trackElement.src = track.src;
        trackElement.srclang = track.language;
        trackElement.label = track.label;
        trackElement.default = false;
        video.appendChild(trackElement);
        trackElement.addEventListener(&apos;load&apos;, () =&gt; {
          const textTrack = trackElement.track;
          textTrack.mode = &apos;showing&apos;;
          addLog({
            source: &apos;subtitles&apos;,
            level: &apos;info&apos;,
            event: &apos;external_track_loaded&apos;,
            data: { trackId, src: track.src }
          });
        });
        trackElement.addEventListener(&apos;error&apos;, () =&gt; {
          addLog({
            source: &apos;subtitles&apos;,
            level: &apos;error&apos;,
            event: &apos;external_track_error&apos;,
            data: { trackId, src: track.src }
          });
        });
      }
    }
  }, [availableSubtitles, addLog, onSubtitleChange]);
  // Determine video type from URL if not explicitly provided
  const getVideoType = useCallback((url: string): &apos;hls&apos; | &apos;dash&apos; | &apos;mp4&apos; =&gt; {
    if (type) return type;
    if (url.includes(&apos;.m3u8&apos;) || url.includes(&apos;hls&apos;)) return &apos;hls&apos;;
    if (url.includes(&apos;.mpd&apos;) || url.includes(&apos;dash&apos;)) return &apos;dash&apos;;
    return &apos;mp4&apos;;
  }, [type]);
  // Cleanup function
  const cleanup = useCallback(() =&gt; {
    addLog({
      source: &apos;player&apos;,
      level: &apos;info&apos;,
      event: &apos;cleanup&apos;,
      message: &apos;Cleaning up player instances&apos;
    });
    if (hlsRef.current) {
      hlsRef.current.destroy();
      hlsRef.current = null;
    }
    if (dashPlayerRef.current) {
      dashPlayerRef.current.reset();
      dashPlayerRef.current = null;
    }
  }, [addLog]);
  // Initialize HLS player
  const initializeHLS = useCallback(() =&gt; {
    if (!videoRef.current || !Hls.isSupported()) {
      addLog({
        source: &apos;hls&apos;,
        level: &apos;error&apos;,
        event: &apos;not_supported&apos;,
        message: &apos;HLS not supported&apos;
      });
      return false;
    }
    cleanup();
    addLog({
      source: &apos;hls&apos;,
      level: &apos;info&apos;,
      event: &apos;initialize&apos;,
      data: { src }
    });
    const hls = new Hls({
      enableWorker: true,
      lowLatencyMode: true,
      backBufferLength: 90,
      debug: debug,
    });
    // HLS Event Logging
    Object.values(Hls.Events).forEach(event =&gt; {
      hls.on(event, (eventType, data) =&gt; {
        const level = event.includes(&apos;ERROR&apos;) ? &apos;error&apos; :
                      event.includes(&apos;WARN&apos;) ? &apos;warn&apos; : &apos;info&apos;;
        addLog({
          source: &apos;hls&apos;,
          level,
          event: eventType,
          data: data
        });
      });
    });
    hls.loadSource(src);
    hls.attachMedia(videoRef.current);
    hls.on(Hls.Events.MANIFEST_PARSED, () =&gt; {
      setIsLoading(false);
      onLoadedData?.();
      // Initialize subtitles after manifest is parsed
      setTimeout(initializeSubtitles, 100);
    });
    hls.on(Hls.Events.ERROR, (_event, data) =&gt; {
      console.error(&apos;HLS Error:&apos;, data);
      if (data.fatal) {
        setError(`HLS Error: ${data.details}`);
        onError?.(data);
      }
    });
    hlsRef.current = hls;
    return true;
  }, [src, cleanup, onLoadedData, onError, addLog, debug, initializeSubtitles]);
  // Initialize Dash player
  const initializeDash = useCallback(() =&gt; {
    if (!videoRef.current) {
      addLog({
        source: &apos;dash&apos;,
        level: &apos;error&apos;,
        event: &apos;no_video_element&apos;,
        message: &apos;No video element available&apos;
      });
      return false;
    }
    cleanup();
    addLog({
      source: &apos;dash&apos;,
      level: &apos;info&apos;,
      event: &apos;initialize&apos;,
      data: { src }
    });
    const dashPlayer = dashjs.MediaPlayer().create();
    // Dash Event Logging
    Object.values(dashjs.MediaPlayer.events).forEach(event =&gt; {
      dashPlayer.on(event, (data: any) =&gt; {
        const level = event.includes(&apos;ERROR&apos;) ? &apos;error&apos; :
                      event.includes(&apos;WARN&apos;) ? &apos;warn&apos; : &apos;info&apos;;
        addLog({
          source: &apos;dash&apos;,
          level,
          event: event,
          data: data
        });
      });
    });
    dashPlayer.initialize(videoRef.current, src, autoPlay);
    dashPlayer.on(dashjs.MediaPlayer.events.STREAM_INITIALIZED, () =&gt; {
      setIsLoading(false);
      onLoadedData?.();
      // Initialize subtitles after stream is initialized
      setTimeout(initializeSubtitles, 100);
    });
    dashPlayer.on(dashjs.MediaPlayer.events.ERROR, (e: Error) =&gt; {
      console.error(&apos;Dash Error:&apos;, e);
      setError(`Dash Error: ${e.message || e.toString() || &apos;Unknown error&apos;}`);
      onError?.(e);
    });
    dashPlayerRef.current = dashPlayer;
    return true;
  }, [src, autoPlay, cleanup, onLoadedData, onError, addLog, initializeSubtitles]);
  // Initialize native video
  const initializeNative = useCallback(() =&gt; {
    if (!videoRef.current) {
      addLog({
        source: &apos;video&apos;,
        level: &apos;error&apos;,
        event: &apos;no_video_element&apos;,
        message: &apos;No video element available&apos;
      });
      return false;
    }
    cleanup();
    addLog({
      source: &apos;video&apos;,
      level: &apos;info&apos;,
      event: &apos;initialize_native&apos;,
      data: { src }
    });
    videoRef.current.src = src;
    return true;
  }, [src, cleanup, addLog]);
  // Add external subtitles as track elements
  useEffect(() =&gt; {
    const video = videoRef.current;
    if (!video || subtitles.length === 0) return;
    // Remove existing external tracks
    const existingTracks = video.querySelectorAll(&apos;track[data-external=&quot;true&quot;]&apos;);
    existingTracks.forEach(track =&gt; track.remove());
    // Add external subtitle tracks
    subtitles.forEach((subtitle, index) =&gt; {
      if (subtitle.src) {
        const trackElement = document.createElement(&apos;track&apos;);
        trackElement.kind = subtitle.kind || &apos;subtitles&apos;;
        trackElement.src = subtitle.src;
        trackElement.srclang = subtitle.language;
        trackElement.label = subtitle.label;
        trackElement.default = subtitle.default || false;
        trackElement.setAttribute(&apos;data-external&apos;, &apos;true&apos;);
        trackElement.setAttribute(&apos;data-track-id&apos;, subtitle.id);
        video.appendChild(trackElement);
      }
    });
    // Initialize subtitles after adding tracks
    setTimeout(initializeSubtitles, 100);
  }, [subtitles, initializeSubtitles]);
  // Initialize player based on video type
  useEffect(() =&gt; {
    if (!src || !videoRef.current) return;
    setIsLoading(true);
    setError(null);
    onLoadStart?.();
    const videoType = getVideoType(src);
    let initialized = false;
    addLog({
      source: &apos;player&apos;,
      level: &apos;info&apos;,
      event: &apos;initialize&apos;,
      data: { src, type: videoType }
    });
    switch (videoType) {
      case &apos;hls&apos;:
        if (Hls.isSupported()) {
          initialized = initializeHLS();
        } else if (videoRef.current.canPlayType(&apos;application/vnd.apple.mpegurl&apos;)) {
          initialized = initializeNative();
        }
        break;
      case &apos;dash&apos;:
        initialized = initializeDash();
        break;
      default:
        initialized = initializeNative();
        break;
    }
    if (!initialized) {
      const errorMsg = &apos;Unsupported video format or browser&apos;;
      setError(errorMsg);
      setIsLoading(false);
      addLog({
        source: &apos;player&apos;,
        level: &apos;error&apos;,
        event: &apos;initialization_failed&apos;,
        message: errorMsg
      });
    }
    return cleanup;
  }, [src, getVideoType, initializeHLS, initializeDash, initializeNative, cleanup, onLoadStart, addLog]);
  // Video event handlers with logging
  useEffect(() =&gt; {
    const video = videoRef.current;
    if (!video) return;
    const videoEvents = [
      &apos;loadstart&apos;, &apos;progress&apos;, &apos;suspend&apos;, &apos;abort&apos;, &apos;error&apos;, &apos;emptied&apos;, &apos;stalled&apos;,
      &apos;loadedmetadata&apos;, &apos;loadeddata&apos;, &apos;canplay&apos;, &apos;canplaythrough&apos;, &apos;playing&apos;,
      &apos;waiting&apos;, &apos;seeking&apos;, &apos;seeked&apos;, &apos;ended&apos;, &apos;durationchange&apos;, &apos;timeupdate&apos;,
      &apos;play&apos;, &apos;pause&apos;, &apos;ratechange&apos;, &apos;resize&apos;, &apos;volumechange&apos;
    ];
    const eventHandlers: { [key: string]: (e: Event) =&gt; void } = {};
    videoEvents.forEach(eventName =&gt; {
      const handler = (e: Event) =&gt; {
        addLog({
          source: &apos;video&apos;,
          level: eventName === &apos;error&apos; ? &apos;error&apos; : &apos;debug&apos;,
          event: eventName,
          data: {
            currentTime: video.currentTime,
            duration: video.duration,
            readyState: video.readyState,
            networkState: video.networkState,
            buffered: video.buffered.length &gt; 0 ? {
              start: video.buffered.start(0),
              end: video.buffered.end(video.buffered.length - 1)
            } : null
          }
        });
      };
      eventHandlers[eventName] = handler;
      video.addEventListener(eventName, handler);
    });
    const handleTimeUpdate = () =&gt; {
      const time = video.currentTime;
      setCurrentTime(time);
      onTimeUpdate?.(time);
    };
    const handleLoadedMetadata = () =&gt; {
      setDuration(video.duration);
      setVolume(video.volume);
      setIsMuted(video.muted);
      // Initialize subtitles when metadata is loaded for native videos
      if (!hlsRef.current &amp;&amp; !dashPlayerRef.current) {
        setTimeout(initializeSubtitles, 100);
      }
    };
    const handlePlay = () =&gt; {
      setIsPlaying(true);
      onPlay?.();
    };
    const handlePause = () =&gt; {
      setIsPlaying(false);
      onPause?.();
    };
    const handleEnded = () =&gt; {
      setIsPlaying(false);
      onEnded?.();
    };
    const handleError = () =&gt; {
      const error = video.error;
      if (error) {
        setError(`Video Error: ${error.message}`);
        onError?.(error);
      }
    };
    const handleVolumeChange = () =&gt; {
      setVolume(video.volume);
      setIsMuted(video.muted);
    };
    video.addEventListener(&apos;timeupdate&apos;, handleTimeUpdate);
    video.addEventListener(&apos;loadedmetadata&apos;, handleLoadedMetadata);
    video.addEventListener(&apos;play&apos;, handlePlay);
    video.addEventListener(&apos;pause&apos;, handlePause);
    video.addEventListener(&apos;ended&apos;, handleEnded);
    video.addEventListener(&apos;error&apos;, handleError);
    video.addEventListener(&apos;volumechange&apos;, handleVolumeChange);
    return () =&gt; {
      videoEvents.forEach(eventName =&gt; {
        video.removeEventListener(eventName, eventHandlers[eventName]);
      });
      video.removeEventListener(&apos;timeupdate&apos;, handleTimeUpdate);
      video.removeEventListener(&apos;loadedmetadata&apos;, handleLoadedMetadata);
      video.removeEventListener(&apos;play&apos;, handlePlay);
      video.removeEventListener(&apos;pause&apos;, handlePause);
      video.removeEventListener(&apos;ended&apos;, handleEnded);
      video.removeEventListener(&apos;error&apos;, handleError);
      video.removeEventListener(&apos;volumechange&apos;, handleVolumeChange);
    };
  }, [onTimeUpdate, onPlay, onPause, onEnded, onError, addLog, initializeSubtitles]);
  // Control functions
  const togglePlay = () =&gt; {
    if (videoRef.current) {
      if (isPlaying) {
        videoRef.current.pause();
      } else {
        videoRef.current.play();
      }
    }
  };
  const toggleMute = () =&gt; {
    if (videoRef.current) {
      videoRef.current.muted = !isMuted;
    }
  };
  const handleSeek = (value: number[]) =&gt; {
    if (videoRef.current) {
      addLog({
        source: &apos;player&apos;,
        level: &apos;info&apos;,
        event: &apos;seek&apos;,
        data: { from: currentTime, to: value[0] }
      });
      videoRef.current.currentTime = value[0];
    }
  };
  const handleVolumeChange = (value: number[]) =&gt; {
    if (videoRef.current) {
      addLog({
        source: &apos;player&apos;,
        level: &apos;info&apos;,
        event: &apos;volume_change&apos;,
        data: { from: volume, to: value[0] }
      });
      videoRef.current.volume = value[0];
    }
  };
  const formatTime = (time: number) =&gt; {
    const minutes = Math.floor(time / 60);
    const seconds = Math.floor(time % 60);
    return `${minutes}:${seconds.toString().padStart(2, &apos;0&apos;)}`;
  };
  const formatTimestamp = (timestamp: number) =&gt; {
    return new Date(timestamp).toLocaleTimeString();
  };
  const getLevelColor = (level: LogEntry[&apos;level&apos;]) =&gt; {
    switch (level) {
      case &apos;error&apos;: return &apos;red&apos;;
      case &apos;warn&apos;: return &apos;yellow&apos;;
      case &apos;info&apos;: return &apos;blue&apos;;
      case &apos;debug&apos;: return &apos;gray&apos;;
      default: return &apos;gray&apos;;
    }
  };
  if (error) {
    return (
      &lt;Card className={className}&gt;
        &lt;Flex direction=&quot;column&quot; align=&quot;center&quot; justify=&quot;center&quot; style={{ minHeight: &apos;200px&apos; }}&gt;
          &lt;Text size=&quot;4&quot; weight=&quot;bold&quot; color=&quot;red&quot; mb=&quot;2&quot;&gt;
            Video playback error
          &lt;/Text&gt;
          &lt;Text size=&quot;2&quot; color=&quot;gray&quot;&gt;
            {error}
          &lt;/Text&gt;
        &lt;/Flex&gt;
      &lt;/Card&gt;
    );
  }
  return (
    &lt;&gt;
      &lt;Box
        className={className}
        style={{
          position: &apos;relative&apos;,
          width: &apos;100%&apos;,
          height: &apos;100%&apos;,
          backgroundColor: &apos;var(--color-panel-solid)&apos;,
          borderRadius: &apos;var(--radius-3)&apos;
        }}
        onMouseEnter={() =&gt; setShowControls(true)}
        onMouseLeave={() =&gt; setShowControls(false)}
      &gt;
        {isLoading &amp;&amp; (
          &lt;Flex
            position=&quot;absolute&quot;
            inset=&quot;0&quot;
            align=&quot;center&quot;
            justify=&quot;center&quot;
            style={{
              backgroundColor: &apos;rgba(0, 0, 0, 0.8)&apos;,
              zIndex: 10,
              borderRadius: &apos;var(--radius-3)&apos;
            }}
          &gt;
            &lt;Flex direction=&quot;column&quot; align=&quot;center&quot; gap=&quot;3&quot;&gt;
              &lt;Spinner size=&quot;3&quot; /&gt;
              &lt;Text size=&quot;2&quot; style={{ color: &apos;white&apos; }}&gt;Loading video...&lt;/Text&gt;
            &lt;/Flex&gt;
          &lt;/Flex&gt;
        )}
        &lt;video
          ref={videoRef}
          autoPlay={autoPlay}
          muted={muted}
          loop={loop}
          poster={poster}
          crossOrigin=&quot;anonymous&quot;
          style={{
            width: &apos;100%&apos;,
            height: &apos;100%&apos;,
            borderRadius: &apos;var(--radius-3)&apos;
          }}
          playsInline
          onClick={togglePlay}
        &gt;
          {subtitles.map((subtitle) =&gt; (
            subtitle.src &amp;&amp; (
              &lt;track
                key={subtitle.id}
                kind={subtitle.kind || &apos;subtitles&apos;}
                src={subtitle.src}
                srcLang={subtitle.language}
                label={subtitle.label}
                default={subtitle.default}
              /&gt;
            )
          ))}
        &lt;/video&gt;
        {controls &amp;&amp; showControls &amp;&amp; (
          &lt;Box
            position=&quot;absolute&quot;
            bottom=&quot;0&quot;
            left=&quot;0&quot;
            right=&quot;0&quot;
            p=&quot;3&quot;
            style={{
              background: &apos;linear-gradient(transparent, rgba(0, 0, 0, 0.8))&apos;,
              borderBottomLeftRadius: &apos;var(--radius-3)&apos;,
              borderBottomRightRadius: &apos;var(--radius-3)&apos;,
            }}
          &gt;
            {/* Progress bar */}
            &lt;Box mb=&quot;3&quot;&gt;
              &lt;Slider
                value={[currentTime]}
                max={duration || 100}
                step={0.1}
                onValueChange={handleSeek}
                style={{ width: &apos;100%&apos; }}
              /&gt;
            &lt;/Box&gt;
            {/* Controls */}
            &lt;Flex align=&quot;center&quot; justify=&quot;between&quot;&gt;
              &lt;Flex align=&quot;center&quot; gap=&quot;3&quot;&gt;
                &lt;Tooltip content={isPlaying ? &apos;Pause&apos; : &apos;Play&apos;}&gt;
                  &lt;IconButton
                    variant=&quot;ghost&quot;
                    size=&quot;2&quot;
                    onClick={togglePlay}
                    style={{ color: &apos;white&apos; }}
                  &gt;
                    {isPlaying ? &lt;PauseIcon /&gt; : &lt;PlayIcon /&gt;}
                  &lt;/IconButton&gt;
                &lt;/Tooltip&gt;
                &lt;Flex align=&quot;center&quot; gap=&quot;2&quot;&gt;
                  &lt;Tooltip content={isMuted ? &apos;Unmute&apos; : &apos;Mute&apos;}&gt;
                    &lt;IconButton
                      variant=&quot;ghost&quot;
                      size=&quot;1&quot;
                      onClick={toggleMute}
                      style={{ color: &apos;white&apos; }}
                    &gt;
                      {isMuted ? &lt;SpeakerOffIcon /&gt; : &lt;SpeakerLoudIcon /&gt;}
                    &lt;/IconButton&gt;
                  &lt;/Tooltip&gt;
                  &lt;Box style={{ width: &apos;80px&apos; }}&gt;
                    &lt;Slider
                      value={[isMuted ? 0 : volume]}
                      max={1}
                      step={0.1}
                      onValueChange={handleVolumeChange}
                      size=&quot;1&quot;
                    /&gt;
                  &lt;/Box&gt;
                &lt;/Flex&gt;
                &lt;Text size=&quot;1&quot; style={{ color: &apos;white&apos;, fontFamily: &apos;var(--font-mono)&apos; }}&gt;
                  {formatTime(currentTime)} / {formatTime(duration)}
                &lt;/Text&gt;
              &lt;/Flex&gt;
              &lt;Flex align=&quot;center&quot; gap=&quot;2&quot;&gt;
                {/* Subtitle Selector */}
                {availableSubtitles.length &gt; 0 &amp;&amp; (
                  &lt;Dialog.Root open={showSubtitleSelector} onOpenChange={setShowSubtitleSelector}&gt;
                    &lt;Dialog.Trigger&gt;
                      &lt;Tooltip content=&quot;Subtitles&quot;&gt;
                        &lt;IconButton
                          variant=&quot;ghost&quot;
                          size=&quot;2&quot;
                          style={{
                            color: selectedSubtitle ? &apos;var(--accent-9)&apos; : &apos;white&apos;
                          }}
                        &gt;
                          &lt;ChatBubbleIcon /&gt;
                          {selectedSubtitle &amp;&amp; (
                            &lt;Badge
                              variant=&quot;solid&quot;
                              size=&quot;1&quot;
                              style={{
                                position: &apos;absolute&apos;,
                                top: &apos;-4px&apos;,
                                right: &apos;-4px&apos;,
                                width: &apos;8px&apos;,
                                height: &apos;8px&apos;,
                                minWidth: &apos;unset&apos;,
                                padding: &apos;0&apos;
                              }}
                            /&gt;
                          )}
                        &lt;/IconButton&gt;
                      &lt;/Tooltip&gt;
                    &lt;/Dialog.Trigger&gt;
                    &lt;Dialog.Content style={{ maxWidth: &apos;350px&apos; }}&gt;
                      &lt;Dialog.Title&gt;Subtitle Tracks&lt;/Dialog.Title&gt;
                      &lt;Flex direction=&quot;column&quot; gap=&quot;3&quot; mt=&quot;4&quot;&gt;
                        &lt;Select.Root
                          value={selectedSubtitle || &apos;off&apos;}
                          onValueChange={handleSubtitleSelection}
                        &gt;
                          &lt;Select.Trigger style={{ width: &apos;100%&apos; }}&gt;
                            &lt;Text&gt;Select subtitle track&lt;/Text&gt;
                          &lt;/Select.Trigger&gt;
                          &lt;Select.Content&gt;
                            &lt;Select.Item value=&quot;off&quot;&gt;
                              &lt;Flex align=&quot;center&quot; gap=&quot;2&quot;&gt;
                                &lt;Text&gt;Off&lt;/Text&gt;
                              &lt;/Flex&gt;
                            &lt;/Select.Item&gt;
                            {availableSubtitles.map((track) =&gt; (
                              &lt;Select.Item key={track.id} value={track.id}&gt;
                                &lt;Flex align=&quot;center&quot; justify=&quot;between&quot; style={{ width: &apos;100%&apos; }}&gt;
                                  &lt;Flex direction=&quot;column&quot; align=&quot;start&quot;&gt;
                                    &lt;Text&gt;{track.label}&lt;/Text&gt;
                                    &lt;Text size=&quot;1&quot; color=&quot;gray&quot;&gt;
                                      {track.language} • {track.kind || &apos;subtitles&apos;}
                                    &lt;/Text&gt;
                                  &lt;/Flex&gt;
                                  {track.default &amp;&amp; (
                                    &lt;Badge variant=&quot;soft&quot; size=&quot;1&quot;&gt;
                                      Default
                                    &lt;/Badge&gt;
                                  )}
                                &lt;/Flex&gt;
                              &lt;/Select.Item&gt;
                            ))}
                          &lt;/Select.Content&gt;
                        &lt;/Select.Root&gt;
                        {selectedSubtitle &amp;&amp; (
                          &lt;Box p=&quot;2&quot; style={{ backgroundColor: &apos;var(--color-panel-solid)&apos;, borderRadius: &apos;var(--radius-2)&apos; }}&gt;
                            &lt;Text size=&quot;2&quot; weight=&quot;bold&quot; mb=&quot;1&quot;&gt;Active Track:&lt;/Text&gt;
                            {(() =&gt; {
                              const track = availableSubtitles.find(t =&gt; t.id === selectedSubtitle);
                              return track ? (
                                &lt;Flex direction=&quot;column&quot; gap=&quot;1&quot;&gt;
                                  &lt;Text size=&quot;1&quot;&gt;{track.label}&lt;/Text&gt;
                                  &lt;Text size=&quot;1&quot; color=&quot;gray&quot;&gt;
                                    Language: {track.language} • Type: {track.kind || &apos;subtitles&apos;}
                                  &lt;/Text&gt;
                                &lt;/Flex&gt;
                              ) : null;
                            })()}
                          &lt;/Box&gt;
                        )}
                      &lt;/Flex&gt;
                      &lt;Dialog.Close&gt;
                        &lt;IconButton
                          style={{ position: &apos;absolute&apos;, top: &apos;10px&apos;, right: &apos;10px&apos; }}
                          variant=&quot;ghost&quot;
                          size=&quot;1&quot;
                        &gt;
                          &lt;Cross2Icon /&gt;
                        &lt;/IconButton&gt;
                      &lt;/Dialog.Close&gt;
                    &lt;/Dialog.Content&gt;
                  &lt;/Dialog.Root&gt;
                )}
                {/* Debug Button */}
                {debug &amp;&amp; (
                  &lt;Tooltip content=&quot;Debug Logger&quot;&gt;
                    &lt;IconButton
                      variant=&quot;ghost&quot;
                      size=&quot;2&quot;
                      onClick={() =&gt; setShowDebugger(true)}
                      style={{ color: &apos;white&apos; }}
                    &gt;
                      &lt;FileTextIcon /&gt;
                      {logs.length &gt; 0 &amp;&amp; (
                        &lt;Badge
                          variant=&quot;solid&quot;
                          size=&quot;1&quot;
                          style={{
                            position: &apos;absolute&apos;,
                            top: &apos;-8px&apos;,
                            right: &apos;-8px&apos;,
                            minWidth: &apos;16px&apos;,
                            height: &apos;16px&apos;,
                            fontSize: &apos;10px&apos;
                          }}
                        &gt;
                          {logs.length}
                        &lt;/Badge&gt;
                      )}
                    &lt;/IconButton&gt;
                  &lt;/Tooltip&gt;
                )}
              &lt;/Flex&gt;
            &lt;/Flex&gt;
          &lt;/Box&gt;
        )}
      &lt;/Box&gt;
      {/* Debug Logger Dialog */}
      &lt;Dialog.Root open={showDebugger} onOpenChange={setShowDebugger}&gt;
        &lt;Dialog.Content style={{ maxWidth: &apos;800px&apos;, maxHeight: &apos;600px&apos; }}&gt;
          &lt;Dialog.Title&gt;Video Player Debug Logger&lt;/Dialog.Title&gt;
          &lt;Flex direction=&quot;column&quot; gap=&quot;3&quot; mt=&quot;4&quot; style={{ height: &apos;500px&apos; }}&gt;
            {/* Controls */}
            &lt;Flex align=&quot;center&quot; justify=&quot;between&quot;&gt;
              &lt;Flex align=&quot;center&quot; gap=&quot;2&quot;&gt;
                &lt;Text size=&quot;2&quot; weight=&quot;bold&quot;&gt;Logs: {logs.length}&lt;/Text&gt;
                &lt;Badge variant=&quot;soft&quot; size=&quot;1&quot;&gt;
                  Auto-scroll: {autoScroll ? &apos;ON&apos; : &apos;OFF&apos;}
                &lt;/Badge&gt;
              &lt;/Flex&gt;
              &lt;Flex gap=&quot;2&quot;&gt;
                &lt;Button
                  variant=&quot;outline&quot;
                  size=&quot;1&quot;
                  onClick={() =&gt; setAutoScroll(!autoScroll)}
                &gt;
                  Toggle Auto-scroll
                &lt;/Button&gt;
                &lt;Button
                  variant=&quot;outline&quot;
                  size=&quot;1&quot;
                  onClick={exportLogs}
                  disabled={logs.length === 0}
                &gt;
                  &lt;DownloadIcon width=&quot;12&quot; height=&quot;12&quot; /&gt;
                  Export
                &lt;/Button&gt;
                &lt;Button
                  variant=&quot;outline&quot;
                  size=&quot;1&quot;
                  color=&quot;red&quot;
                  onClick={clearLogs}
                  disabled={logs.length === 0}
                &gt;
                  &lt;TrashIcon width=&quot;12&quot; height=&quot;12&quot; /&gt;
                  Clear
                &lt;/Button&gt;
              &lt;/Flex&gt;
            &lt;/Flex&gt;
            &lt;Separator /&gt;
            {/* Logs */}
            &lt;ScrollArea style={{ height: &apos;100%&apos; }} ref={scrollAreaRef}&gt;
              &lt;Flex direction=&quot;column&quot; gap=&quot;1&quot;&gt;
                {logs.map((log, index) =&gt; (
                  &lt;Card key={index} variant=&quot;surface&quot;&gt;
                    &lt;Flex direction=&quot;column&quot; gap=&quot;1&quot;&gt;
                      &lt;Flex align=&quot;center&quot; justify=&quot;between&quot;&gt;
                        &lt;Flex align=&quot;center&quot; gap=&quot;2&quot;&gt;
                          &lt;Badge color={getLevelColor(log.level)} variant=&quot;soft&quot; size=&quot;1&quot;&gt;
                            {log.level.toUpperCase()}
                          &lt;/Badge&gt;
                          &lt;Badge variant=&quot;outline&quot; size=&quot;1&quot;&gt;
                            {log.source.toUpperCase()}
                          &lt;/Badge&gt;
                          &lt;Text size=&quot;1&quot; weight=&quot;bold&quot;&gt;
                            {log.event}
                          &lt;/Text&gt;
                        &lt;/Flex&gt;
                        &lt;Text size=&quot;1&quot; color=&quot;gray&quot;&gt;
                          {formatTimestamp(log.timestamp)}
                        &lt;/Text&gt;
                      &lt;/Flex&gt;
                      {log.message &amp;&amp; (
                        &lt;Text size=&quot;1&quot; color=&quot;gray&quot;&gt;
                          {log.message}
                        &lt;/Text&gt;
                      )}
                      {log.data &amp;&amp; (
                        &lt;Box
                          p=&quot;2&quot;
                          style={{
                            backgroundColor: &apos;var(--color-panel-solid)&apos;,
                            borderRadius: &apos;var(--radius-2)&apos;,
                            fontFamily: &apos;var(--font-mono)&apos;,
                            fontSize: &apos;11px&apos;,
                            overflow: &apos;auto&apos;
                          }}
                        &gt;
                          &lt;pre&gt;{JSON.stringify(log.data, null, 2)}&lt;/pre&gt;
                        &lt;/Box&gt;
                      )}
                    &lt;/Flex&gt;
                  &lt;/Card&gt;
                ))}
                {logs.length === 0 &amp;&amp; (
                  &lt;Flex align=&quot;center&quot; justify=&quot;center&quot; style={{ height: &apos;200px&apos; }}&gt;
                    &lt;Text color=&quot;gray&quot;&gt;No logs yet. Start playing video to see events.&lt;/Text&gt;
                  &lt;/Flex&gt;
                )}
              &lt;/Flex&gt;
            &lt;/ScrollArea&gt;
          &lt;/Flex&gt;
          &lt;Dialog.Close&gt;
            &lt;IconButton
              style={{ position: &apos;absolute&apos;, top: &apos;10px&apos;, right: &apos;10px&apos; }}
              variant=&quot;ghost&quot;
              size=&quot;1&quot;
            &gt;
              &lt;Cross2Icon /&gt;
            &lt;/IconButton&gt;
          &lt;/Dialog.Close&gt;
        &lt;/Dialog.Content&gt;
      &lt;/Dialog.Root&gt;
    &lt;/&gt;
  );
};
export default VideoPlayer;</file><file path="resources/app/global.d.ts">import { AxiosInstance } from &apos;axios&apos;;
import { route as routeFn } from &apos;ziggy-js&apos;;
import { Ziggy } from &apos;@/ziggy&apos;;
declare global {
  interface Window {
    axios: AxiosInstance;
    Ziggy: typeof Ziggy;
  }
  var route: typeof routeFn;
}</file><file path="resources/app/hooks/use-apm-component-tracking.ts">// hooks/use-apm-component-tracking.ts
import { useEffect, useRef } from &apos;react&apos;;
import { reactApm } from &apos;@/services/apm&apos;;
export function useApmComponentTracking(componentName: string) {
  const renderSpanRef = useRef&lt;any&gt;(null);
  useEffect(() =&gt; {
    // Track component mount
    const mountSpan = reactApm.trackComponentMount(componentName);
    return () =&gt; {
      // Track component unmount
      mountSpan?.end();
      reactApm.trackComponentUnmount(componentName);
    };
  }, [componentName]);
  const startRenderTracking = () =&gt; {
    renderSpanRef.current = reactApm.startComponentRender(componentName);
  };
  const endRenderTracking = () =&gt; {
    if (renderSpanRef.current) {
      renderSpanRef.current.end();
      renderSpanRef.current = null;
    }
  };
  const trackCustomSpan = (spanName: string, type: string = &apos;custom&apos;) =&gt; {
    return reactApm.trackComponentLifecycle(componentName, spanName, { type });
  };
  return {
    startRenderTracking,
    endRenderTracking,
    trackCustomSpan,
  };
}</file><file path="resources/app/hooks/use-apm-route-tracking.ts">import { useEffect, useRef, useMemo } from &apos;react&apos;;
import { useLocation, useNavigationType, useParams, useMatch, matchPath } from &apos;react-router-dom&apos;;
import { apm } from &apos;@/services/apm.ts&apos;;
import { publicRoutes } from &apos;@/routes/public&apos;;
import { protectedRoutes } from &apos;@/routes/protected&apos;;
import { useAppSelector } from &apos;@/store/hooks.ts&apos;;
import { selectIsAuthenticated } from &apos;@/store/users/auth-slice.ts&apos;;
export function useApmRouteTracking() {
  const location = useLocation();
  const navigationType = useNavigationType(); // &apos;POP&apos;, &apos;PUSH&apos;, or &apos;REPLACE&apos;
  const params = useParams(); // Get route params
  const prevPathRef = useRef&lt;string | null&gt;(null);
  const isAuthenticated = useAppSelector(selectIsAuthenticated);
  // Get the appropriate routes based on authentication status
  const routes = isAuthenticated ? protectedRoutes : publicRoutes;
  // Function to find the matching route and extract its name
  const findMatchingRoute = useMemo(() =&gt; {
    // Get all routes from the router
    const getAllRoutes = () =&gt; {
      // Flatten the route configuration to make it easier to search
      const flattenRoutes = (routeArray: any[], parentPath = &apos;&apos;, parentName = &apos;&apos;) =&gt; {
        let result: { path: string; name: string }[] = [];
        routeArray.forEach(route =&gt; {
          const fullPath = parentPath ? 
            (route.path?.startsWith(&apos;/&apos;) ? route.path : `${parentPath}/${route.path || &apos;&apos;}`) : 
            route.path || &apos;&apos;;
          // Skip catch-all routes
          if (fullPath === &apos;*&apos; || fullPath.endsWith(&apos;/*&apos;)) {
            return;
          }
          // Add this route
          if (fullPath) {
            // Extract a name from the path
            const pathSegments = fullPath.split(&apos;/&apos;).filter(Boolean);
            const lastSegment = pathSegments[pathSegments.length - 1] || &apos;home&apos;;
            const routeName = lastSegment.replace(/:/g, &apos;&apos;); // Remove parameter markers
            // Use component displayName or name if available
            // Try to get the name from the element&apos;s type (for React elements)
            let elementName = route.element?.type?.displayName || route.element?.type?.name;
            // If that doesn&apos;t work, try to get it from the element itself (for function/class components)
            if (!elementName &amp;&amp; typeof route.element === &apos;function&apos;) {
              elementName = route.element.displayName || route.element.name;
            }
            // If the element is a React component with a name property, use that
            if (!elementName &amp;&amp; route.element?.props?.name) {
              elementName = route.element.props.name;
            }
            // Create a more descriptive name by combining parent name with current name
            let descriptiveName = elementName || routeName;
            if (parentName &amp;&amp; descriptiveName !== &apos;home&apos;) {
              descriptiveName = `${parentName}.${descriptiveName}`;
            }
            result.push({ 
              path: fullPath, 
              name: descriptiveName 
            });
            // Add child routes
            if (route.children) {
              // Pass the current route&apos;s name as the parent name for child routes
              const currentRouteName = elementName || routeName;
              result = [...result, ...flattenRoutes(route.children, fullPath, currentRouteName)];
            }
          }
        });
        return result;
      };
      return flattenRoutes(routes);
    };
    const allRoutes = getAllRoutes();
    // Find the most specific matching route
    let bestMatch = null;
    let bestMatchScore = -1;
    allRoutes.forEach(route =&gt; {
      const match = matchPath(route.path, location.pathname);
      if (match) {
        // Score the match based on specificity (number of segments that match)
        const score = match.pathname.split(&apos;/&apos;).filter(Boolean).length;
        if (score &gt; bestMatchScore) {
          bestMatch = { ...route, params: match.params };
          bestMatchScore = score;
        }
      }
    });
    return bestMatch;
  }, [routes, location.pathname]);
  // Match against common route patterns
  const dashboardMatch = useMatch(&apos;/dashboard/*&apos;);
  const libraryMatch = useMatch(&apos;/library/:library/*&apos;);
  const playlistMatch = useMatch(&apos;/playlists/music/*&apos;);
  const userSettingsMatch = useMatch(&apos;/user/settings/*&apos;);
  const authMatch = useMatch(&apos;/auth/*&apos;);
  // Determine the route type based on matches
  const routeType = useMemo(() =&gt; {
    if (dashboardMatch) return &apos;dashboard&apos;;
    if (libraryMatch) return &apos;library&apos;;
    if (playlistMatch) return &apos;playlist&apos;;
    if (userSettingsMatch) return &apos;user-settings&apos;;
    if (authMatch) return &apos;auth&apos;;
    if (location.pathname === &apos;/&apos;) return &apos;home&apos;;
    return &apos;other&apos;;
  }, [dashboardMatch, libraryMatch, playlistMatch, userSettingsMatch, authMatch, location.pathname]);
  // Extract query parameters
  const queryParams = useMemo(() =&gt; {
    const searchParams = new URLSearchParams(location.search);
    const params: Record&lt;string, string&gt; = {};
    searchParams.forEach((value, key) =&gt; {
      params[key] = value;
    });
    return params;
  }, [location.search]);
  useEffect(() =&gt; {
    // Get the previous path for transition tracking
    const prevPath = prevPathRef.current;
    // Get the route name from the matching route
    const routeName = findMatchingRoute?.[&apos;name&apos;] || routeType;
    // Start a new transaction for the route
    const transaction = apm.getCurrentTransaction() ?? apm.startTransaction(&apos;Route: &apos; + routeName, &apos;route.change&apos;);
    const span = transaction?.startSpan(`Route: ${routeName}:${location.pathname}`, &apos;route.change&apos;);
    // Add detailed metadata about the route
    span?.addLabels({
      route: location.pathname,
      routeType,
      routeName,
      search: location.search,
      hash: location.hash,
      navigationType,
      prevPath: prevPath || &apos;initial&apos;,
      timestamp: new Date().toISOString(),
    });
    // Set custom context with more detailed information
    span?.addContext({
      page: {
        url: location.pathname + location.search + location.hash,
        route: location.pathname,
        routeType,
        routeName,
        title: document.title,
        referrer: document.referrer,
        queryParams: Object.keys(queryParams).length &gt; 0 ? queryParams : undefined,
        routeParams: Object.keys(params).length &gt; 0 ? params : undefined,
        matchedPath: findMatchingRoute,
      },
      navigation: {
        type: navigationType,
        from: prevPath || &apos;initial&apos;,
        to: location.pathname,
      },
      routeMatches: {
        dashboard: !!dashboardMatch,
        library: !!libraryMatch,
        playlist: !!playlistMatch,
        userSettings: !!userSettingsMatch,
        auth: !!authMatch,
      }
    });
    // Update the previous path ref for the next navigation
    prevPathRef.current = location.pathname;
    // For Elastic APM RUM, use captureError for logging (if needed)
    // or just rely on the transaction data
    // Create a span for page load metrics if this is the initial load
    if (!prevPath) {
      const pageLoadSpan = transaction?.startSpan(&apos;page-load-metrics&apos;, &apos;page.metrics&apos;);
      if (pageLoadSpan) {
        // Use modern Performance Timeline API to get page load metrics
        if (window.performance &amp;&amp; &apos;getEntriesByType&apos; in window.performance) {
          const navEntries = window.performance.getEntriesByType(&apos;navigation&apos;);
          if (navEntries.length &gt; 0) {
            const navTiming = navEntries[0] as PerformanceNavigationTiming;
            pageLoadSpan.addLabels({
              pageLoadTime: navTiming.loadEventEnd - navTiming.startTime,
              domLoadTime: navTiming.domComplete - navTiming.domContentLoadedEventStart,
              redirectTime: navTiming.redirectEnd - navTiming.redirectStart,
              dnsLookupTime: navTiming.domainLookupEnd - navTiming.domainLookupStart,
              tcpConnectTime: navTiming.connectEnd - navTiming.connectStart,
              serverResponseTime: navTiming.responseEnd - navTiming.requestStart,
              domParseTime: navTiming.domInteractive - navTiming.responseEnd,
            });
          }
        }
        pageLoadSpan.end();
      }
    }
    return () =&gt; {
      transaction?.end();
    };
  }, [
    location.pathname, 
    location.search, 
    location.hash, 
    navigationType, 
    routeType, 
    params, 
    queryParams, 
    dashboardMatch, 
    libraryMatch, 
    playlistMatch, 
    userSettingsMatch, 
    authMatch,
    findMatchingRoute
  ]);
}</file><file path="resources/app/hooks/use-app-config.ts">interface ApplicationConfig {
  environment: string;
  debug: boolean;
  otlEndpoint: string;
  otlServiceName: string;
}
const config: ApplicationConfig = {
  environment: import.meta.env.VITE_APP_ENV,
  debug: Boolean(import.meta.env.VITE_APP_DEBUG),
  otlEndpoint: import.meta.env.VITE_OTL_ENDPOINT,
  otlServiceName: import.meta.env.VITE_OTL_SERVICE_NAME,
};
export function useAppConfig() {
  return config;
}</file><file path="resources/app/hooks/use-app-dashboards.ts">export function useAppDashboards() {
  const openNewTab = (path: string) =&gt; {
    window.open(`${import.meta.env.VITE_APP_URL}/${path}`, &apos;blank&apos;);
  };
  const openPulse = () =&gt; openNewTab(&apos;-/pulse&apos;);
  return {
    openPulse,
  };
}</file><file path="resources/app/hooks/use-block-body-scroll.ts">import { useLayoutEffect } from &apos;react&apos;;
export function useBlockBodyScroll() {
  useLayoutEffect(() =&gt; {
    const style = window.getComputedStyle(document.body).overflow;
    document.body.style.overflow = &apos;hidden&apos;;
    return () =&gt; {
      document.body.style.overflow = style;
    };
  });
}</file><file path="resources/app/hooks/use-disclosure.ts">import { useCallback, useState, useEffect, useRef } from &apos;react&apos;;
type DisclosureCallbacks = {
  onOpen?: () =&gt; void;
  onClose?: () =&gt; void;
};
export function useDisclosure(
  initialState = false,
  callbacks?: DisclosureCallbacks
): readonly [
  boolean,
  {
    open: () =&gt; void;
    close: () =&gt; void;
    toggle: () =&gt; void;
  }
] {
  const callbacksRef = useRef(callbacks);
  useEffect(() =&gt; {
    callbacksRef.current = callbacks;
  });
  const [isOpen, setIsOpen] = useState(initialState);
  useEffect(() =&gt; {
    setIsOpen(initialState);
  }, [initialState]);
  const open = useCallback(() =&gt; {
    setIsOpen((prev) =&gt; {
      if (!prev) {
        callbacksRef.current?.onOpen?.();
        return true;
      }
      return prev;
    });
  }, []);
  const close = useCallback(() =&gt; {
    setIsOpen((prev) =&gt; {
      if (prev) {
        callbacksRef.current?.onClose?.();
        return false;
      }
      return prev;
    });
  }, []);
  const toggle = useCallback(() =&gt; {
    setIsOpen((prev) =&gt; {
      const newState = !prev;
      if (newState) {
        callbacksRef.current?.onOpen?.();
      } else {
        callbacksRef.current?.onClose?.();
      }
      return newState;
    });
  }, []);
  return [isOpen, { open, close, toggle }] as const;
}</file><file path="resources/app/hooks/use-event-listener.ts">import { useEffect } from &apos;react&apos;;
// This hook is used for listening event including CustomEvents
export function useEventListener&lt;K extends keyof WindowEventMap&gt;(eventName: K, handler: (event: WindowEventMap[K]) =&gt; void) {
  useEffect(() =&gt; {
    const listener = (event: WindowEventMap[K]) =&gt; handler(event);
    window.addEventListener(eventName, listener);
    return () =&gt; window.removeEventListener(eventName, listener);
  }, [eventName, handler]);
}</file><file path="resources/app/hooks/use-is-online.ts">import { useEffect, useState } from &apos;react&apos;;
export function useIsOnline() {
  const [isOnline, setIsOnline] = useState&lt;boolean&gt;(false);
  const _isOnline = () =&gt; {
    setIsOnline(true);
  };
  const _isOffline = () =&gt; {
    setIsOnline(false);
  };
  useEffect(() =&gt; {
    window.addEventListener(&apos;online&apos;, _isOnline);
    window.addEventListener(&apos;offline&apos;, _isOffline);
    return () =&gt; {
      window.removeEventListener(&apos;online&apos;, _isOnline);
      window.removeEventListener(&apos;offline&apos;, _isOffline);
    };
  });
  return isOnline;
}</file><file path="resources/app/hooks/use-outside-click.ts">import { useEffect, useLayoutEffect, useRef } from &apos;react&apos;;
export function useOutsideClick&lt;T extends Element&gt;(callback: (event: Event) =&gt; void) {
  const ref = useRef&lt;T&gt;(null);
  const referenceCallback = useRef(callback);
  useLayoutEffect(() =&gt; {
    referenceCallback.current = callback;
  });
  useEffect(() =&gt; {
    const handler = (event: Event) =&gt; {
      const element = ref.current;
      if (element) {
        console.log(&apos;element&apos;, element);
      }
      if (element &amp;&amp; !element.contains(event.target as Node)) {
        console.log(&apos;clicked outside&apos;);
        referenceCallback.current(event);
      }
    };
    document.addEventListener(&apos;click&apos;, handler);
    document.addEventListener(&apos;touchstart&apos;, handler);
    return () =&gt; {
      document.removeEventListener(&apos;click&apos;, handler);
      document.removeEventListener(&apos;touchstart&apos;, handler);
    }
  }, []);
  return ref;
}</file><file path="resources/app/hooks/use-path-param.ts">import { useParams } from &apos;react-router-dom&apos;;
import { assertIsDefined } from &apos;@/utils/assert/is-defined.ts&apos;;
export function usePathParam&lt;T&gt;() : T {
  const params = useParams() as Partial&lt;T&gt;;
  // Validate that each key in T exists in params
  Object.keys(params).forEach((key) =&gt; {
    const typedKey = key as keyof T;
    assertIsDefined(params[typedKey], key);
  });
  return params as T;
}</file><file path="resources/app/hooks/use-queue.ts">import { useState, useCallback } from &apos;react&apos;;
import { useAppDispatch, useAppSelector } from &apos;@/store/hooks&apos;;
import { setQueue, setCurrentSongIndex } from &apos;@/store/music/music-player-slice&apos;;
import { SongResource } from &apos;@/api-client/requests&apos;;
export function useQueue() {
  const dispatch = useAppDispatch();
  const queue = useAppSelector((state) =&gt; state.musicPlayer.queue);
  const [activeIndex, setActiveIndex] = useState(0);
  const overwriteQueue = useCallback((newQueue: SongResource[]) =&gt; {
    dispatch(setQueue(newQueue));
    setActiveIndex(0);
  }, [dispatch]);
  const playSongAtIndex = useCallback((index: number) =&gt; {
    setActiveIndex(index);
    dispatch(setCurrentSongIndex(index));
  }, [dispatch]);
  return {
    queue,
    activeIndex,
    overwriteQueue,
    playSongAtIndex,
  };
}</file><file path="resources/app/hooks/use-webauthn.ts">import { browserSupportsWebAuthn, startRegistration, startAuthentication } from &apos;@simplewebauthn/browser&apos;;
export function useWebauthn() {
  return {
    browserSupportsWebAuthn,
    startAuthentication,
    startRegistration,
  }
}</file><file path="resources/app/layouts/dashboard-layout/dashboard-layout.module.scss">.shell {
    display: grid;
    grid-template-rows: 1fr; /* Only Main, no Footer */
    grid-template-columns: 250px 1fr; /* Sidebar | Content */
    height: 100vh;
    overflow: hidden;
}
.sidebar {
    grid-row: 1; /* Spans only the Main row */
    grid-column: 1; /* Occupies the first column */
    display: flex;
    flex-direction: column;
    width: 100%;
    overflow: hidden;
}
.main {
    grid-row: 1; /* Occupies the first row */
    grid-column: 2; /* Starts next to the Sidebar */
    display: flex;
    flex-direction: column;
    flex: 1;
    min-height: 0;
    overflow: hidden;
}
.content {
    flex-grow: 1;
    overflow-y: auto;
}
.content &gt; .page {
    display: flex;
    flex-direction: column;
    height: 100%;
    width: 100%;
    max-width: 100%;
    overflow-x: hidden;
    overflow-y: auto;
    box-sizing: border-box;
}</file><file path="resources/app/libs/blurhash/decode.ts">import { linearTosRGB, sRGBToLinear } from &apos;@/libs/blurhash/srgb.ts&apos;;
export const decode83 = (str: String) =&gt; {
  let value = 0;
  for (let i = 0; i &lt; str.length; i++) {
    value =
      value * 83 +
      [
        &apos;0&apos;,
        &apos;1&apos;,
        &apos;2&apos;,
        &apos;3&apos;,
        &apos;4&apos;,
        &apos;5&apos;,
        &apos;6&apos;,
        &apos;7&apos;,
        &apos;8&apos;,
        &apos;9&apos;,
        &apos;A&apos;,
        &apos;B&apos;,
        &apos;C&apos;,
        &apos;D&apos;,
        &apos;E&apos;,
        &apos;F&apos;,
        &apos;G&apos;,
        &apos;H&apos;,
        &apos;I&apos;,
        &apos;J&apos;,
        &apos;K&apos;,
        &apos;L&apos;,
        &apos;M&apos;,
        &apos;N&apos;,
        &apos;O&apos;,
        &apos;P&apos;,
        &apos;Q&apos;,
        &apos;R&apos;,
        &apos;S&apos;,
        &apos;T&apos;,
        &apos;U&apos;,
        &apos;V&apos;,
        &apos;W&apos;,
        &apos;X&apos;,
        &apos;Y&apos;,
        &apos;Z&apos;,
        &apos;a&apos;,
        &apos;b&apos;,
        &apos;c&apos;,
        &apos;d&apos;,
        &apos;e&apos;,
        &apos;f&apos;,
        &apos;g&apos;,
        &apos;h&apos;,
        &apos;i&apos;,
        &apos;j&apos;,
        &apos;k&apos;,
        &apos;l&apos;,
        &apos;m&apos;,
        &apos;n&apos;,
        &apos;o&apos;,
        &apos;p&apos;,
        &apos;q&apos;,
        &apos;r&apos;,
        &apos;s&apos;,
        &apos;t&apos;,
        &apos;u&apos;,
        &apos;v&apos;,
        &apos;w&apos;,
        &apos;x&apos;,
        &apos;y&apos;,
        &apos;z&apos;,
        &apos;#&apos;,
        &apos;$&apos;,
        &apos;%&apos;,
        &apos;*&apos;,
        &apos;+&apos;,
        &apos;,&apos;,
        &apos;-&apos;,
        &apos;.&apos;,
        &apos;:&apos;,
        &apos;;&apos;,
        &apos;=&apos;,
        &apos;?&apos;,
        &apos;@&apos;,
        &apos;[&apos;,
        &apos;]&apos;,
        &apos;^&apos;,
        &apos;_&apos;,
        &apos;{&apos;,
        &apos;|&apos;,
        &apos;}&apos;,
        &apos;~&apos;,
      ].indexOf(str[i]);
  }
  return value;
};
export const decodeDC = (value: number) =&gt; {
  const intR = value &gt;&gt; 16;
  const intG = (value &gt;&gt; 8) &amp; 255;
  const intB = value &amp; 255;
  return [sRGBToLinear(intR), sRGBToLinear(intG), sRGBToLinear(intB)];
};
export const decodeAC = (value: number, maximumValue: number) =&gt; {
  const divisor = 19 * 19;
  const quantR = Math.floor(value / divisor);
  const quantG = Math.floor(value / 19) % 19;
  const quantB = value % 19;
  // Inline and simplify the sign and power operation to avoid extra function calls.
  const adjustValue = (quant: number) =&gt; {
    const sign = quant - 9 &lt; 0 ? -1 : 1; // Directly compute the sign.
    const normalized = (quant - 9) / 9;
    return sign * normalized * normalized * maximumValue; // Use squaring instead of Math.pow for exp=2.
  };
  return [adjustValue(quantR), adjustValue(quantG), adjustValue(quantB)];
};
export const decodeBlurhash = (
  blurhash: string,
  width: number,
  height: number,
  punch: number = 1,
) =&gt; {
  const sizeFlag = decode83(blurhash[0]);
  const numY = Math.floor(sizeFlag / 9) + 1;
  const numX = (sizeFlag % 9) + 1;
  const quantisedMaximumValue = decode83(blurhash[1]);
  const maximumValue = ((quantisedMaximumValue + 1) / 166) * punch;
  const colors = Array.from({ length: numX * numY }, (_, i) =&gt;
    i === 0
    ? decodeDC(decode83(blurhash.substring(2, 6)))
    : decodeAC(
      decode83(blurhash.substring(4 + i * 2, 6 + i * 2)),
      maximumValue,
    ),
  );
  const bytesPerRow = width * 4;
  const pixels = new Uint8ClampedArray(bytesPerRow * height);
  const cosX = Array.from({ length: width }, (_, x) =&gt;
    Array.from({ length: numX }, (__, i) =&gt; Math.cos((Math.PI * x * i) / width)),
  );
  const cosY = Array.from({ length: height }, (_, y) =&gt;
    Array.from({ length: numY }, (__, j) =&gt;
      Math.cos((Math.PI * y * j) / height),
    ),
  );
  for (let y = 0; y &lt; height; y++) {
    for (let x = 0; x &lt; width; x++) {
      let r = 0,
        g = 0,
        b = 0;
      for (let j = 0; j &lt; numY; j++) {
        for (let i = 0; i &lt; numX; i++) {
          const basis = cosX[x][i] * cosY[y][j];
          const color = colors[i + j * numX];
          r += color[0] * basis;
          g += color[1] * basis;
          b += color[2] * basis;
        }
      }
      const offset = y * bytesPerRow + x * 4;
      pixels[offset] = linearTosRGB(r);
      pixels[offset + 1] = linearTosRGB(g);
      pixels[offset + 2] = linearTosRGB(b);
      pixels[offset + 3] = 255; // alpha
    }
  }
  return pixels;
};</file><file path="resources/app/libs/blurhash/generate-bg-image.ts">import { decodeBlurhash } from &apos;@/libs/blurhash/decode.ts&apos;;
import { getIsLightFromPixels } from &apos;@/libs/blurhash/luminance.ts&apos;;
/**
 * Util function to convert Uint8ClampedArray to base64 image string
 *
 * @param bytes
 * @param width
 * @param height
 */
const uint8ClampedArrayToBase64 = (bytes: Uint8ClampedArray, width: number, height: number): string =&gt; {
  const canvas = document.createElement(&apos;canvas&apos;);
  canvas.width = width;
  canvas.height = height;
  const ctx = canvas.getContext(&apos;2d&apos;);
  if (!ctx) {
    throw new Error(&apos;Could not get canvas context&apos;);
  }
  const imageData = new ImageData(bytes, width, height);
  ctx.putImageData(imageData, 0, 0);
  return canvas.toDataURL();
};
/**
 * Generate a CSS background image string using a BlurHash and the actual image URL.
 */
export const generateBlurhashBackgroundImage = (
  blurHash: string,
  width: number,
  height: number,
) =&gt; {
  // Process blurhash to pixels
  const pixels = decodeBlurhash(blurHash, width, height);
  const isLight = getIsLightFromPixels(pixels);
  // Convert pixels to base64 image string
  const value = uint8ClampedArrayToBase64(pixels, width, height);
  return {
    backgroundUrl: `url(${value})`,
    isLight,
  };
};</file><file path="resources/app/libs/blurhash/luminance.ts">import { decodeBlurhash } from &apos;@/libs/blurhash/decode.ts&apos;;
export const calculateLuminance = (r: number, g: number, b: number): number =&gt; {
  // Convert sRGB to linear RGB
  const [R, G, B] = [r, g, b].map(v =&gt; {
    v /= 255;
    return v &lt;= 0.03928 ? v / 12.92 : Math.pow((v + 0.055) / 1.055, 2.4);
  });
  // Calculate luminance
  return 0.2126 * R + 0.7152 * G + 0.0722 * B;
};
export const getAverageColorFromBlurhash = (pixels: Uint8ClampedArray): { r: number, g: number, b: number } =&gt; {
  let r = 0, g = 0, b = 0;
  for (let i = 0; i &lt; pixels.length; i += 4) {
    r += pixels[i];
    g += pixels[i + 1];
    b += pixels[i + 2];
  }
  const pixelCount = pixels.length / 4;
  r = Math.floor(r / pixelCount);
  g = Math.floor(g / pixelCount);
  b = Math.floor(b / pixelCount);
  return { r, g, b };
};
function getIsLight(r: number, g: number, b: number) {
  const luminance = calculateLuminance(r, g, b);
  // Assuming 0.5 as the threshold for light/dark background
  return luminance &gt; 0.5;
}
export const getIsLightFromBlurhash = (blurhash: string, width: number, height: number): boolean =&gt; {
  const { r, g, b } = getAverageColorFromBlurhash(decodeBlurhash(blurhash, width, height));
  return getIsLight(r, g, b);
};
export const getIsLightFromPixels = (pixels: Uint8ClampedArray): boolean =&gt; {
  const { r, g, b } = getAverageColorFromBlurhash(pixels);
  return getIsLight(r, g, b);
};</file><file path="resources/app/libs/blurhash/srgb.ts">export const sRGBToLinear = (value: number) =&gt; {
  const v = value / 255;
  return v &lt;= 0.04045 ? v / 12.92 : ((v + 0.055) / 1.055) ** 2.4;
};
export const linearTosRGB = (value: number) =&gt; {
  const v = Math.max(0, Math.min(1, value));
  const a = 1.055,
    b = 0.055,
    gamma = 1 / 2.4;
  return Math.trunc(
    (v &lt;= 0.0031308 ? v * 12.92 : a * Math.pow(v, gamma) - b) * 255 + 0.5,
  );
};</file><file path="resources/app/libs/lyrics/line-parser.ts">/**
 * Regular expression to match sequences of tags enclosed in square brackets.
 * This regex will capture one or more tags that start with an opening square
 * bracket &apos;[&apos; and end with a closing square bracket &apos;]&apos;, with any characters
 * inside the brackets.
 *
 * Matches:
 * - [tag1]
 * - [tag1][tag2]
 * - [tag1][tag2][tag3]
 *
 * Does not match:
 * - [tag1
 * - tag1]
 * - tag1
 *
 * @type {RegExp}
 */
export const TAGS_REGEXP: RegExp = /^(\[.+])+/;
/**
 * Regular expression to capture and parse information from strings.
 *
 * This pattern matches and captures two groups from the input string:
 * - The first group captures one or more word characters (alphanumeric and underscores).
 * - The second group captures any characters after a colon (&apos;:&apos;) and optional surrounding whitespace.
 * - The pattern expects the string to start with optional whitespace, followed by the word characters, a colon, and then any remaining characters.
 *
 * This can be useful for parsing labels and their corresponding values from formatted strings.
 */
export const INFO_REGEXP = /^\s*(\w+)\s*:(.*)$/;
/**
 * Regular expression for matching time strings.
 *
 * This regular expression can match and extract components of a time string in the following format:
 * - One or more digits for the hour component.
 * - A colon (:) followed by one or more digits for the minute component.
 * - An optional period (.) or colon (:) followed by one or more digits for fractional minutes.
 * - Optional surrounding whitespace.
 *
 * Captured groups:
 * - Group 1: Hours component (one or more digits).
 * - Group 2: Entire minute and fractional minute component.
 * - Group 3: Fractional minute component, if any, including the separating character.
 */
export const TIME_REGEXP = /^\s*(\d+)\s*:\s*(\d+(\s*[.:]\s*\d+)?)\s*$/;
// Enumeration for line types
export enum LineType {
  INVALID = &apos;INVALID&apos;,
  INFO = &apos;INFO&apos;,
  TIME = &apos;TIME&apos;,
}
// Interfaces to define the structure of different line types
export interface InvalidLine {
  type: LineType.INVALID;
}
export interface TimeLine {
  type: LineType.TIME;
  timestamps: number[];
  content: string;
}
export interface InfoLine {
  type: LineType.INFO;
  key: string;
  value: string;
}
/**
 * Parses a line to extract tags and remaining content.
 *
 * @param {string} line - The input string to parse for tags.
 * @return {null | [string[], string]} An array containing the list of tags and the remaining content or null if no tags are found.
 */
export function parseTags(line: string): null | [string[], string] {
  line = line.trim();
  const matches = TAGS_REGEXP.exec(line);
  if (matches === null) {
    return null;
  }
  const tag = matches[0];
  const content = line.slice(tag.length);
  return [tag.slice(1, -1).split(/\]\s*\[/), content];
}
/**
 * Parses the time tags and content to generate a TimeLine object.
 * Subtracts animation time to ensure lyrics shows up at the correct time.
 *
 * @param {string[]} tags - An array of time tags to be parsed.
 * @param {string} content - The content associated with the time tags.
 * @return {TimeLine} - The parsed TimeLine object containing type, timestamps, and content.
 */
export function parseTime(tags: string[], content: string): TimeLine {
  interface ExtendedTimestamp {
    start: number;
    end: number;
  }
  const timestamps: ExtendedTimestamp[] = [];
  tags.forEach((tag) =&gt; {
    const matches = TIME_REGEXP.exec(tag);
    if (!matches) {
      throw new Error(`Invalid time format in tag: ${tag}`);
    }
    const animationTime = 0.080;
    const minutes = parseFloat(matches[1]);
    let seconds = parseFloat(matches[2].replace(/\s+/g, &apos;&apos;).replace(&apos;:&apos;, &apos;.&apos;));
    let start = minutes * 60 + seconds;
    let end = start;
    // Subtract animationTime from the start
    start -= animationTime;
    // Add animationTime to the end
    end += animationTime;
    // Ensure the adjusted timestamps are not negative
    if (start &lt; 0) {
      start = 0;
    }
    timestamps.push({ start, end });
  });
  // Flatten the timestamps structure if needed: e.g., [1.985, 2.015, ...]
  const flatTimestamps: number[] = timestamps.reduce(
    (acc: number[], curr) =&gt; acc.concat([curr.start, curr.end]),
    []
  );
  return {
    type: LineType.TIME,
    timestamps: flatTimestamps,
    content: content.trim(),
  };
}
/**
 * Parses the given info tag and extracts key and value components.
 *
 * @param {string} tag - The info tag to be parsed.
 * @returns {InfoLine} An object containing the type, key, and value extracted from the tag.
 * @throws {Error} If the tag format is invalid.
 */
export function parseInfo(tag: string): InfoLine {
  const matches = INFO_REGEXP.exec(tag);
  if (!matches) {
    throw new Error(`Invalid info format in tag: ${tag}`);
  }
  return {
    type: LineType.INFO,
    key: matches[1].trim(),
    value: matches[2].trim(),
  };
}
/**
 * Parses a line of text and returns an object representing either information,
 * time data, or an invalid line.
 *
 * @param {string} line - The line of text to be parsed.
 * @return {InfoLine | TimeLine | InvalidLine} An object representing the parsed line.
 */
export function parseLine(line: string): InfoLine | TimeLine | InvalidLine {
  const parsedTags = parseTags(line);
  try {
    if (parsedTags) {
      const [tags, content] = parsedTags;
      if (TIME_REGEXP.test(tags[0])) {
        return parseTime(tags, content);
      } else {
        return parseInfo(tags[0]);
      }
    }
    return { type: LineType.INVALID };
  } catch (error) {
    console.error(&apos;Error parsing line:&apos;, error);
    return { type: LineType.INVALID };
  }
}</file><file path="resources/app/libs/lyrics/lrc.ts">import { parseLine, LineType } from &apos;./line-parser&apos;;
export interface Lyric {
  timestamp: number;
  content: string;
}
export interface CombineLyric {
  timestamps: number[];
  content: string;
}
export type Info = Record&lt;string, string&gt;;
/**
 * Pads a number with leading zeros to meet the specified width.
 * @param num - The number to pad.
 * @param size - The desired width of the string.
 * @returns A zero-padded string representation of the number.
 */
export function padZero(num: number | string, size: number = 2): string {
  let str = num.toString();
  while (str.split(&apos;.&apos;)[0].length &lt; size) str = &apos;0&apos; + str;
  return str;
}
/**
 * Converts a timestamp to a string in the format of MM:SS.ss.
 * @example
 * Lrc.timestampToString(143.54)
 * // return &apos;02:23.54&apos;:
 * @param timestamp - The timestamp in seconds.
 * @returns A string representation of the timestamp.
 */
export function timestampToString(timestamp: number): string {
  return `${padZero(Math.floor(timestamp / 60))}:${padZero(
    (timestamp % 60).toFixed(2),
  )}`;
}
export type LineFormat = &apos;\r\n&apos; | &apos;\r&apos; | &apos;\n&apos;;
export interface ToStringOptions {
  combine: boolean;
  sort: boolean;
  lineFormat: LineFormat;
}
export class Lrc {
  info: Info = {};
  lyrics: Lyric[] = [];
  /**
   * Parses LRC formatted text and creates an Lrc object.
   * @param text - The LRC text to parse.
   * @returns An instance of the Lrc class.
   */
  static parse(text: string): Lrc {
    const lyrics: Lyric[] = [];
    const info: Info = {};
    text.split(/\r\n|[\n\r]/g).forEach((line) =&gt; {
      const parsedLine = parseLine(line);
      switch (parsedLine.type) {
        case LineType.INFO:
          info[parsedLine.key] = parsedLine.value;
          break;
        case LineType.TIME:
          parsedLine.timestamps.forEach((timestamp) =&gt; {
            lyrics.push({ timestamp, content: parsedLine.content });
          });
          break;
        default:
          // Ignore invalid lines
          break;
      }
    });
    const lrc = new Lrc();
    lrc.lyrics = lyrics;
    lrc.info = info;
    return lrc;
  }
  /**
   * Adjusts the timestamps of the lyrics by a specified offset.
   * @param offsetTime - The time in seconds to offset.
   */
  offset(offsetTime: number): void {
    this.lyrics.forEach((lyric) =&gt; {
      lyric.timestamp += offsetTime;
      if (lyric.timestamp &lt; 0) {
        lyric.timestamp = 0;
      }
    });
  }
  /**
   * Clones the Lrc object, creating a deep copy of it.
   * @returns A new instance of the Lrc class.
   */
  clone(): Lrc {
    const lrcClone = new Lrc();
    lrcClone.info = { ...this.info };
    lrcClone.lyrics = this.lyrics.map((lyric) =&gt; ({ ...lyric }));
    return lrcClone;
  }
  /**
   * Converts the Lrc object to a formatted LRC string.
   * @param opts - Options to format the output string.
   * @returns A formatted string representing the LRC.
   */
  toString(opts: Partial&lt;ToStringOptions&gt; = {}): string {
    opts.combine = opts.combine ?? true;
    opts.lineFormat = opts.lineFormat ?? &apos;\r\n&apos;;
    opts.sort = opts.sort ?? true;
    const lines: string[] = [];
    const lyricsMap: Record&lt;string, number[]&gt; = {};
    const lyricsList: CombineLyric[] = [];
    // Add info lines
    for (const key in this.info) {
      lines.push(`[${key}:${this.info[key]}]`);
    }
    if (opts.combine) {
      // Combine lyrics with the same content
      this.lyrics.forEach((lyric) =&gt; {
        if (lyricsMap[lyric.content]) {
          lyricsMap[lyric.content].push(lyric.timestamp);
        } else {
          lyricsMap[lyric.content] = [lyric.timestamp];
        }
      });
      // Sort and prepare combined lyrics list
      for (const content in lyricsMap) {
        if (opts.sort) {
          lyricsMap[content].sort((a, b) =&gt; a - b);
        }
        lyricsList.push({ timestamps: lyricsMap[content], content });
      }
      if (opts.sort) {
        lyricsList.sort((a, b) =&gt; a.timestamps[0] - b.timestamps[0]);
      }
      // Generate combined lyrics lines
      lyricsList.forEach((lyric) =&gt; {
        lines.push(
          `[${lyric.timestamps
                   .map(timestampToString)
                   .join(&apos;][&apos;)}]${lyric.content || &apos;&apos;}`
        );
      });
    } else {
      // Generate individual lyrics lines
      this.lyrics.forEach((lyric) =&gt; {
        lines.push(`[${timestampToString(lyric.timestamp)}]${lyric.content}`);
      });
    }
    return lines.join(opts.lineFormat);
  }
}</file><file path="resources/app/models/library-type.ts">export enum LibraryType {
  Music = &apos;music&apos;,
  Movie = &apos;movie&apos;,
  Tv = &apos;tv_show&apos;,
}
export type LibraryMusic = LibraryType.Music;
export type LibraryMovie = LibraryType.Movie;
export type LibraryTv = LibraryType.Tv;
export function isMusicLibrary(v: unknown): v is LibraryMusic {
  return Boolean(v) &amp;&amp; typeof v === &apos;string&apos; &amp;&amp; v === LibraryType.Music;
}
export function isMovieLibrary(v: unknown): v is LibraryMovie {
  return Boolean(v) &amp;&amp; typeof v === &apos;string&apos; &amp;&amp; v === LibraryType.Movie;
}
export function isTvLibrary(v: unknown): v is LibraryTv {
  return Boolean(v) &amp;&amp; typeof v === &apos;string&apos; &amp;&amp; v === LibraryType.Tv;
}</file><file path="resources/app/models/library.ts">import { LibraryResource, LibraryType } from &apos;@/api-client/requests&apos;;
export class Library implements Partial&lt;LibraryResource&gt; {
  name!: string;
  slug!: string;
  path!: string;
  type!: LibraryType;
  order!: number;
  lastScan!: string | null;
  createdAt!: string | null;
  updatedAt!: string | null;
  constructor(props: Partial&lt;LibraryResource&gt;) {
    Object.assign(this, props);
  }
}</file><file path="resources/app/modules/auth/create-account/create-account-form.module.scss">.formContent {
}
.form {
  display: flex;
  flex-direction: column;
  padding: 40px;
  background-color: #ffffff;
  border-radius: 10px;
  box-shadow: 0 4px 20px rgba(0, 0, 0, 0.1);
  position: relative;
}
.field {
}</file><file path="resources/app/modules/auth/create-account/create-account-form.tsx">import { useForm, SubmitHandler } from &apos;react-hook-form&apos;;
import { DevTool } from &apos;@hookform/devtools&apos;;
import { TextField, Button, Box, Flex, Text } from &apos;@radix-ui/themes&apos;;
import { Label } from &apos;radix-ui&apos;;
import styles from &apos;./create-account-form.module.scss&apos;;
import { useAppDispatch } from &apos;@/store/hooks&apos;;
import { createUser } from &apos;@/store/users/auth-slice.ts&apos;;
interface AccountForm {
  name: string;
  email: string;
  password: string;
  password_confirmation: string;
}
export function CreateAccountForm() {
  const {
    register,
    handleSubmit,
    formState: { errors },
    control,
    setError,
  } = useForm&lt;AccountForm&gt;();
  const dispatch = useAppDispatch();
  const onSubmit: SubmitHandler&lt;AccountForm&gt; = (data) =&gt; {
    if (data.password !== data.password_confirmation) {
      setError(&apos;password_confirmation&apos;, {
        type: &apos;manual&apos;,
        message: &apos;Passwords do not match&apos;,
      });
      return;
    }
    dispatch(createUser(data));
  };
  return (
    &lt;&gt;
      &lt;form className={styles.form} onSubmit={handleSubmit(onSubmit)}&gt;
        &lt;Flex direction=&quot;column&quot; gap=&quot;3&quot; px=&quot;4&quot; className={styles.formContent}&gt;
          &lt;Box className={styles.field}&gt;
            &lt;Label.Root htmlFor=&quot;name&quot;&gt;Name&lt;/Label.Root&gt;
            &lt;TextField.Root
              id=&quot;name&quot;
              size=&quot;3&quot;
              {...register(&apos;name&apos;, { required: &apos;Name is required&apos; })}
            /&gt;
            {errors.name &amp;&amp; &lt;Text color=&quot;red&quot;&gt;{errors.name.message}&lt;/Text&gt;}
          &lt;/Box&gt;
          &lt;Box className={styles.field}&gt;
            &lt;Label.Root htmlFor=&quot;email&quot;&gt;Email&lt;/Label.Root&gt;
            &lt;TextField.Root
              id=&quot;email&quot;
              type=&quot;email&quot;
              size=&quot;3&quot;
              {...register(&apos;email&apos;, {
                required: &apos;Email is required&apos;,
                pattern: {
                  value: /\S+@\S+\.\S+/,
                  message: &apos;Entered value does not match email format&apos;,
                },
              })}
            /&gt;
            {errors.email &amp;&amp; &lt;Text color=&quot;red&quot;&gt;{errors.email.message}&lt;/Text&gt;}
          &lt;/Box&gt;
          &lt;Box className={styles.field}&gt;
            &lt;Label.Root htmlFor=&quot;password&quot;&gt;Password&lt;/Label.Root&gt;
            &lt;TextField.Root
              id=&quot;password&quot;
              type=&quot;password&quot;
              size=&quot;3&quot;
              {...register(&apos;password&apos;, { required: &apos;Password is required&apos; })}
            /&gt;
            {errors.password &amp;&amp; &lt;Text color=&quot;red&quot;&gt;{errors.password.message}&lt;/Text&gt;}
          &lt;/Box&gt;
          &lt;Box className={styles.field}&gt;
            &lt;Label.Root htmlFor=&quot;password_confirmation&quot;&gt;Confirm Password&lt;/Label.Root&gt;
            &lt;TextField.Root
              id=&quot;password_confirmation&quot;
              type=&quot;password&quot;
              size=&quot;3&quot;
              {...register(&apos;password_confirmation&apos;, {
                required: &apos;Password confirmation is required&apos;,
              })}
            /&gt;
            {errors.password_confirmation &amp;&amp; (
              &lt;Text color=&quot;red&quot;&gt;{errors.password_confirmation.message}&lt;/Text&gt;
            )}
          &lt;/Box&gt;
          &lt;Button mt=&quot;4&quot; size=&quot;3&quot; type=&quot;submit&quot;&gt;Create Account&lt;/Button&gt;
        &lt;/Flex&gt;
      &lt;/form&gt;
      &lt;DevTool control={control} /&gt;
    &lt;/&gt;
  );
}</file><file path="resources/app/modules/auth/routes/_routes.tsx">import { Navigate, Route, Routes } from &apos;react-router-dom&apos;;
import { CreateAccount } from &apos;@/modules/auth/routes/create-account.tsx&apos;;
import { ForgotPassword } from &apos;@/modules/auth/routes/forgot-password.tsx&apos;;
export const AuthRoutes = () =&gt; {
  return (
    &lt;Routes&gt;
      &lt;Route path=&quot;/create-account&quot; element={&lt;CreateAccount /&gt;} /&gt;
      &lt;Route path=&quot;/forgot-password&quot; element={&lt;ForgotPassword /&gt;} /&gt;
      &lt;Route path=&quot;*&quot; element={&lt;Navigate to=&quot;/create-account&quot; /&gt;} /&gt;
    &lt;/Routes&gt;
  )
}</file><file path="resources/app/modules/auth/routes/create-account.module.scss">@use &quot;shared&quot; as *;</file><file path="resources/app/modules/auth/routes/create-account.tsx">import { Flex, Text } from &apos;@radix-ui/themes&apos;;
import styles from &apos;./create-account.module.scss&apos;;
import { CreateAccountForm } from &apos;@/modules/auth/create-account/create-account-form.tsx&apos;;
import { Link } from &apos;react-router-dom&apos;;
export function CreateAccount() {
  return (
    &lt;Flex direction=&quot;column&quot; className={styles.container}&gt;
      &lt;Flex direction=&quot;column&quot; gap=&quot;3&quot; className={styles.formContent}&gt;
        &lt;Text size=&quot;7&quot; weight=&quot;bold&quot; align=&quot;center&quot; className={styles.heading}&gt;
          Create an account
        &lt;/Text&gt;
        &lt;CreateAccountForm /&gt;
        &lt;Flex direction=&quot;row&quot; justify=&quot;between&quot; className={styles.links}&gt;
          &lt;Link to=&quot;/auth/forgot-password&quot;&gt;
            &lt;Text size=&quot;3&quot;&gt;
              Forgot Password?
            &lt;/Text&gt;
          &lt;/Link&gt;
          &lt;Link to=&quot;/&quot;&gt;
            &lt;Text size=&quot;3&quot;&gt;
              Login
            &lt;/Text&gt;
          &lt;/Link&gt;
        &lt;/Flex&gt;
      &lt;/Flex&gt;
    &lt;/Flex&gt;
  )
}</file><file path="resources/app/modules/auth/routes/forgot-password.module.scss">@use &quot;shared&quot; as *;</file><file path="resources/app/modules/auth/routes/forgot-password.tsx">import { Flex, Text } from &apos;@radix-ui/themes&apos;;
import { Link } from &apos;react-router-dom&apos;;
import { ForgotPasswordForm } from &apos;@/modules/auth/forgot-password-form/forgot-password-form.tsx&apos;;
import styles from &apos;./forgot-password.module.scss&apos;;
export function ForgotPassword() {
  return (
    &lt;Flex direction=&quot;column&quot; className={styles.container}&gt;
      &lt;Flex direction=&quot;column&quot; gap=&quot;3&quot; className={styles.formContent}&gt;
        &lt;Text size=&quot;7&quot; weight=&quot;bold&quot; align=&quot;center&quot; className={styles.heading}&gt;
          Forgot Password?
        &lt;/Text&gt;
        &lt;ForgotPasswordForm /&gt;
        &lt;Flex direction=&quot;row&quot; justify=&quot;between&quot; className={styles.links}&gt;
          &lt;Link to=&quot;/auth/create-account&quot;&gt;
            &lt;Text size=&quot;3&quot;&gt;
              Create account
            &lt;/Text&gt;
          &lt;/Link&gt;
          &lt;Link to=&quot;/&quot;&gt;
            &lt;Text size=&quot;3&quot;&gt;
              Login
            &lt;/Text&gt;
          &lt;/Link&gt;
        &lt;/Flex&gt;
      &lt;/Flex&gt;
    &lt;/Flex&gt;
  )
}</file><file path="resources/app/modules/auth/routes/shared.scss">.container {
  display: flex;
  flex-direction: row;
  justify-content: space-between;
  align-items: center;
  gap: 30px;
  min-height: 80vh;
  padding: 20px;
  max-width: 1200px;
  margin: 0 auto;
}
.heading {
  margin-bottom: 10px;
}</file><file path="resources/app/modules/authorize/routes.tsx">import { Route, Routes } from &apos;react-router-dom&apos;;
import { ConfirmPassword } from &apos;@/modules/authorize/confirm-password.tsx&apos;;
export const AuthorizeRoutes = () =&gt; {
  return (
    &lt;Routes&gt;
      &lt;Route path=&quot;confirm-password&quot; element={&lt;ConfirmPassword /&gt;} /&gt;
    &lt;/Routes&gt;
  )
}</file><file path="resources/app/modules/dashboard/components/iframe.module.scss">.iframeContainer {
  background: transparent;
  position: relative;
  overflow: hidden;
  width: 100%;
  padding-top: 56.25%; /* 16:9 Aspect Ratio (divide 9 by 16 = 0.5625) */
}
.iframe {
  background: transparent;
  position: absolute;
  top: 0;
  left: 0;
  bottom: 0;
  right: 0;
  width: 100%;
  height: 100%;
}</file><file path="resources/app/modules/dashboard/components/iframe.tsx">import styles from &apos;./iframe.module.scss&apos;;
export interface IframeProps {
  routeName: string;
}
export function Iframe({routeName}: IframeProps) {
  return (
    &lt;div className={styles.iframeContainer}&gt;
      &lt;iframe
        className={styles.iframe}
        src={route(routeName)}
      &gt;&lt;/iframe&gt;
    &lt;/div&gt;
  );
}</file><file path="resources/app/modules/dashboard/dashboard-home/dashboard-home.tsx">import { Container, Flex, Heading, Text } from &apos;@radix-ui/themes&apos;;
import { Env } from &apos;@/common/env.ts&apos;;
export function DashboardHome() {
  return (
    &lt;Container&gt;
      &lt;Heading mt=&quot;3&quot;&gt;Bånder&lt;/Heading&gt;
      &lt;Flex direction=&quot;column&quot; mt=&quot;3&quot;&gt;
        &lt;Text&gt;&lt;Text weight=&quot;bold&quot;&gt;Application name&lt;/Text&gt; {Env.appName()}&lt;/Text&gt;
        &lt;Text&gt;&lt;Text weight=&quot;bold&quot;&gt;Environment&lt;/Text&gt; {Env.env()}&lt;/Text&gt;
        &lt;Text&gt;&lt;Text weight=&quot;bold&quot;&gt;Url&lt;/Text&gt; {Env.url()}&lt;/Text&gt;
        &lt;Text&gt;&lt;Text weight=&quot;bold&quot;&gt;Version&lt;/Text&gt; {Env.version()}&lt;/Text&gt;
      &lt;/Flex&gt;
    &lt;/Container&gt;
  );
}</file><file path="resources/app/modules/dashboard/libraries/components/create-library.module.css">.Root {
    width: 260px;
}
.Field {
    display: grid;
    margin-bottom: 10px;
}
.innerField {
    display: flex;
    align-items: baseline;
    justify-content: space-between;
}
.Label {
    font-size: 15px;
    font-weight: 500;
    line-height: 35px;
}
.Message {
    font-size: 13px;
    opacity: 0.8;
}
.Input,
.Textarea {
    all: unset;
    box-sizing: border-box;
    width: 100%;
    display: inline-flex;
    align-items: center;
    justify-content: center;
    border-radius: 4px;
    font-size: 15px;
    background-color: var(--black-a2);
    box-shadow: 0 0 0 1px var(--black-a6);
    &amp;:hover {
        box-shadow: 0 0 0 1px black;
    }
    &amp;:focus {
        box-shadow: 0 0 0 2px black;
    }
    &amp;::selection {
        background-color: var(--black-a6);
        color: white;
    }
}
.Input {
    padding: 0 10px;
    height: 35px;
    line-height: 1;
}
.Textarea {
    resize: none;
    padding: 10px;
}</file><file path="resources/app/modules/dashboard/music/MusicTasks.tsx">import { Button, Container, Flex, Heading } from &apos;@radix-ui/themes&apos;;
export function MusicTasks() {
  return (
    &lt;Container mt=&quot;3&quot;&gt;
      &lt;Heading&gt;Tasks&lt;/Heading&gt;
      &lt;Flex mt=&quot;3&quot;&gt;
        &lt;Button&gt;Sync smart playlists&lt;/Button&gt;
      &lt;/Flex&gt;
    &lt;/Container&gt;
  )
}</file><file path="resources/app/modules/dashboard/queue-monitor/components/job-details.module.scss">.exceptionText {
  font-size: 0.8rem;
  text-wrap: pretty;
}</file><file path="resources/app/modules/dashboard/queue-monitor/components/jobs-list.module.scss">.scrollList {
  border-bottom: 1px solid #e0dddd;
  .title {
    margin-left: 3px;
  }
  table {
    border-spacing: unset;
  }
  thead {
    background-color: #fff;
  }
}
.bold {
  font-weight: 600;
}
.scrollbar {
  --sb-track-color: &apos;transparent&apos;;
  --sb-thumb-color: #828282;
  --sb-size: 6px;
}
.scrollbar::-webkit-scrollbar {
  width: var(--sb-size)
}
.scrollbar::-webkit-scrollbar-track {
  background: var(--sb-track-color);
  border-radius: 3px;
}
.scrollbar::-webkit-scrollbar-thumb {
  background: var(--sb-thumb-color);
  border-radius: 3px;
}
@supports not selector(::-webkit-scrollbar) {
  .scrollbar {
    scrollbar-color: var(--sb-thumb-color)
    var(--sb-track-color);
  }
}</file><file path="resources/app/modules/dashboard/routes/log-viewer.tsx">import { Iframe } from &apos;@/modules/dashboard/components/iframe.tsx&apos;;
export function LogViewer() {
  return (
    &lt;Iframe routeName=&quot;log-viewer.index&quot; /&gt;
  );
}</file><file path="resources/app/modules/dashboard/system-info/php.module.scss">.configKey {
  font-weight: 600;
}</file><file path="resources/app/modules/equalizer/components/description.module.scss">.descriptionContainer {
  display: flex;
  align-items: end;
  justify-content: center;
  color: orange;
  padding: 0 1em;
}
.horizontalLine {
  width: 100%;
  height: 1px;
  background-color: orange;
  margin: 0.5em 0;
}
.label {
  font-size: 0.75rem;
  font-weight: bold;
  text-transform: uppercase;
  margin: 0 1em;
}</file><file path="resources/app/modules/equalizer/components/description.tsx">import styles from &apos;./description.module.scss&apos;;
export interface DescriptionProps {
  [key: string]: any;
  label: string;
}
export function Description(props: DescriptionProps) {
  const { label, ...rest } = props;
  return (
    &lt;div className={styles.descriptionContainer} {...rest}&gt;
      &lt;div className={styles.horizontalLine} /&gt;
      &lt;span className={styles.label}&gt;{label}&lt;/span&gt;
      &lt;div className={styles.horizontalLine} /&gt;
    &lt;/div&gt;
  );
}</file><file path="resources/app/modules/equalizer/components/eq-button.module.scss">.eqButtonContainer {
  display: flex;
  flex-direction: column;
  align-items: center;
  margin: auto 0;
}
.eqPowerButton {
  background-color: #19181e;
  color: orange;
  border: none;
  border-radius: 0.5em;
  padding: 0.5em 1em;
  cursor: pointer;
  width: 3em;
  height: 2em;
  transition: background-color 0.2s ease-in-out;
}
.eqPowerLabel {
  color: orange;
  font-size: 0.75em;
  text-transform: uppercase;
  text-align: center;
  font-weight: bold;
  margin-bottom: 0.25em;
}</file><file path="resources/app/modules/equalizer/components/eq-button.tsx">import styles from &apos;./eq-button.module.scss&apos;;
export interface EqButtonProps {
  [key: string]: any;
  handleOnClick: () =&gt; void;
  label: string;
}
export function EqButton(props: EqButtonProps) {
  const { handleOnClick, label, ...rest } = props;
  return (
    &lt;div className={styles.eqButtonContainer} {...rest}&gt;
      &lt;p className={styles.eqPowerLabel}&gt;{label}&lt;/p&gt;
      &lt;button className={styles.eqPowerButton} onClick={() =&gt; handleOnClick()} /&gt;
    &lt;/div&gt;
  );
}</file><file path="resources/app/modules/equalizer/components/knob.module.scss">.eqKnob {
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  text-align: center;
  position: relative;
  cursor: w-resize;
}
.eqKnobName {
  color: orange;
  font-size: 0.75em;
  font-weight: bold;
  text-transform: uppercase;
  margin-bottom: 5px;
  text-align: center;
}
.eqKnobLabels {
  display: flex;
  justify-content: space-between;
  width: 100%;
}
.eqKnobLabel {
  color: orange;
  font-size: 0.75em;
  font-weight: bold;
  text-transform: uppercase;
}
.eqKnobControl {
  width: 80px;
  aspect-ratio: 1 / 1;
  border-radius: 50%;
  background-color: #19181e;
  box-shadow: 0 0 10px #19181e;
  margin: 0.5em 0;
  position: relative;
}
.eqKnobRevolveControlContainer {
  width: 100%;
  aspect-ratio: 1 / 1;
  display: flex;
  justify-content: center;
  align-items: center;
  transform: rotate(-135deg);
}
.eqKnobRevolveControl {
  width: 80%;
  height: 80%;
  border-radius: 50%;
  background-color: #272a35;
  z-index: 1;
  cursor: ns-resize;
  &amp;.rotating {
    transform: rotate(var(--rotate, 0));
  }
}
.eqKnobRevolvePointer {
  width: 0.25em;
  height: 1em;
  background-color: #19181e;
  margin: 0 auto;
  border-radius: 0.25em;
  position: relative;
  top: -1px;
  &amp;.active {
    background-color: #ce4206;
    box-shadow: 0 0 10px #ce4206;
  }
}
.eqDot {
  width: 0.5em;
  height: 0.5em;
  border-radius: 50%;
  background-color: #19181e;
  box-shadow: 0 0 10px #19181e;
  position: absolute;
  &amp;.active {
    background-color: #9c341a;
    box-shadow: 0 0 10px #9c341a;
  }
}
.egDotContainer {
  width: 85.5%;
  aspect-ratio: 1 / 1;
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%) rotate(var(--rotate, 0));
}</file><file path="resources/app/modules/equalizer/components/knob.tsx">import React, { useState, useEffect } from &apos;react&apos;;
import styles from &apos;./knob.module.scss&apos;;
export interface KnobProps {
  [key: string]: any;
  name: string;
  leftLabel: string;
  rightLabel: string;
  isEnabled?: boolean;
  isSmall?: boolean;
  value?: number;
  isInfinite?: boolean;
  isIndicatorsVisible?: boolean;
  onChange?: (value: number) =&gt; void;
}
export function Knob(props: KnobProps) {
  const {
    isEnabled,
    name,
    leftLabel,
    rightLabel,
    value,
    isIndicatorsVisible,
    onChange,
    ...rest
  } = props;
  const [deg, setDeg] = useState(0);
  const handleOnWheelChange = (e: React.WheelEvent&lt;HTMLDivElement&gt;) =&gt; {
    const { deltaY } = e;
    const newRotate = deg + deltaY;
    if (newRotate &gt;= 0 &amp;&amp; newRotate &lt;= 270) {
      setDeg(newRotate);
    }
    const value = Math.round((newRotate / 270) * 100);
    const valueWithLimitedRange = value &gt; 100 ? 100 : value &lt;= 0 ? 0 : value;
    if (isEnabled) {
      onChange?.(valueWithLimitedRange);
    }
  };
  useEffect(() =&gt; {
    const newRotate = Math.round(((value ?? 0) / 100) * 270);
    setDeg(newRotate);
  }, [value]);
  return (
    &lt;div className={styles.eqKnob} {...rest}&gt;
      &lt;p className={styles.eqKnobName}&gt;{name}&lt;/p&gt;
      &lt;div className={styles.eqKnobControl}&gt;
        &lt;div className={styles.eqKnobRevolveControlContainer}&gt;
          &lt;div
            className={`${styles.eqKnobRevolveControl} ${styles.rotating}`}
            style={{ &apos;--rotate&apos;: `${deg}deg` } as React.CSSProperties}
            title=&quot;Use mouse wheel to control&quot;
            onWheel={(e) =&gt; handleOnWheelChange(e)}
          &gt;
            {!isIndicatorsVisible &amp;&amp; (
              &lt;div
                className={`${styles.eqKnobRevolvePointer} ${
                  isEnabled ? styles.active : &apos;&apos;
                }`}
              /&gt;
            )}
          &lt;/div&gt;
          {isIndicatorsVisible &amp;&amp;
            Array.from({ length: 10 }, (_, index) =&gt; (
              &lt;div
                className={styles.egDotContainer}
                key={index}
                style={{ &apos;--rotate&apos;: `${index * 30 + 45}deg` } as React.CSSProperties}
              &gt;
                &lt;div
                  className={`${styles.eqDot} ${
                    isEnabled &amp;&amp; index * 30 &lt;= deg ? styles.active : &apos;&apos;
                  }`}
                /&gt;
              &lt;/div&gt;
            ))}
        &lt;/div&gt;
      &lt;/div&gt;
      &lt;div className={styles.eqKnobLabels}&gt;
        &lt;p className={styles.eqKnobLabel}&gt;{leftLabel}&lt;/p&gt;
        &lt;p className={styles.eqKnobLabel}&gt;{rightLabel}&lt;/p&gt;
      &lt;/div&gt;
    &lt;/div&gt;
  );
}</file><file path="resources/app/modules/equalizer/components/vfd-channel-analyzer.module.scss">vfdSpectrum {
  display: flex;
  gap: 0.5em;
}
.vfdChannels {
}
.spectrumColumn {
  display: flex;
  flex-direction: column;
  gap: 0.25em;
  width: 2.5em;
}
.spectrumBar {
  width: 100%;
  height: 0.25em;
  background-color: #062626;
  box-shadow: none;
  &amp;.active {
    background-color: #1caeae;
    box-shadow: 0 0 10px #1caeae;
  }
}
.spectrumBarRed {
  width: 100%;
  height: 0.25em;
  background-color: #250c06;
  box-shadow: none;
  &amp;.active {
    background-color: #9c341a;
    box-shadow: 0 0 10px #9c341a;
  }
}
.barFrequencyDescription {
  color: #062626;
  font-size: 0.75em;
  font-weight: bold;
  text-shadow: none;
  margin: 0.25em 0;
  text-align: center;
  &amp;.active {
    color: #1caeae;
    text-shadow: 0 0 10px #1caeae;
  }
  &amp;.dB {
    margin-top: 0;
  }
}
.decibelText {
  color: #062626;
  font-size: 0.5em;
  font-weight: bold;
  text-shadow: none;
  text-align: center;
  margin-bottom: 0.5em;
  &amp;:nth-of-type(7) {
    margin-bottom: 0;
  }
  &amp;.active {
    color: #1caeae;
    text-shadow: 0 0 10px #1caeae;
  }
}
.decibelColumn {
  display: flex;
  flex-direction: column;
  justify-content: end;
  align-items: center;
  width: 1.5em;
}</file><file path="resources/app/modules/equalizer/components/vfd-channel-analyzer.tsx">import styles from &apos;./vfd-channel-analyzer.module.scss&apos;;
import { BarsMode } from &apos;@/modules/equalizer/types.ts&apos;;
export interface VfdChannelAnalyzerProps {
  isEnabled: boolean;
  left: number;
  right: number;
  barsMode: BarsMode;
}
export const VfdChannelAnalyzer = (props: VfdChannelAnalyzerProps) =&gt; {
  const { isEnabled, left, right, barsMode } = props;
  const isBarActive = (value: number, index: number) =&gt; {
    switch (barsMode) {
      case &apos;bars&apos;:
        return value - 50 &gt;= 100 - index * 10;
      case &apos;pointer&apos;:
        return (value - 50 &gt;= 100 - index * 10) &amp;&amp; !(value - 50 &gt;= 100 - (index - 1) * 10);
      case &apos;off&apos;:
        return false;
      default:
        return false;
    }
  };
  return (
    &lt;div className={styles.vfdChannels}&gt;
      &lt;div className={styles.vfdSpectrum}&gt;
        &lt;div className={styles.spectrumColumn}&gt;
          {Array.from({ length: 12 }, (_, index) =&gt;
            index &lt; 3 ? (
              &lt;div
                key={index}
                className={`${styles.spectrumBarRed} ${isEnabled &amp;&amp; isBarActive(left, index) ? styles.active : &apos;&apos;}`}
              /&gt;
            ) : (
              &lt;div
                key={index}
                className={`${styles.spectrumBar} ${isEnabled &amp;&amp; isBarActive(left, index) ? styles.active : &apos;&apos;}`}
              /&gt;
            ),
          )}
          &lt;div className={`${styles.spectrumBar} ${isEnabled &amp;&amp; barsMode === &apos;bars&apos; ? styles.active : &apos;&apos;}`} /&gt;
          &lt;p className={`${styles.barFrequencyDescription} ${isEnabled ? styles.active : &apos;&apos;}`}&gt;
            LEFT
          &lt;/p&gt;
        &lt;/div&gt;
        &lt;div className={styles.decibelColumn}&gt;
          &lt;p className={`${styles.decibelText} ${isEnabled ? styles.active : &apos;&apos;}`}&gt;+3&lt;/p&gt;
          &lt;p className={`${styles.decibelText} ${isEnabled ? styles.active : &apos;&apos;}`}&gt;0&lt;/p&gt;
          &lt;p className={`${styles.decibelText} ${isEnabled ? styles.active : &apos;&apos;}`}&gt;-3&lt;/p&gt;
          &lt;p className={`${styles.decibelText} ${isEnabled ? styles.active : &apos;&apos;}`}&gt;-5&lt;/p&gt;
          &lt;p className={`${styles.decibelText} ${isEnabled ? styles.active : &apos;&apos;}`}&gt;-10&lt;/p&gt;
          &lt;p className={`${styles.decibelText} ${isEnabled ? styles.active : &apos;&apos;}`}&gt;-20&lt;/p&gt;
          &lt;p className={`${styles.decibelText} ${isEnabled ? styles.active : &apos;&apos;}`}&gt;-∞&lt;/p&gt;
          &lt;p className={`${styles.barFrequencyDescription} ${styles.dB} ${isEnabled ? styles.active : &apos;&apos;}`}&gt;
            dB
          &lt;/p&gt;
        &lt;/div&gt;
        &lt;div className={styles.spectrumColumn}&gt;
          {Array.from({ length: 12 }, (_, index) =&gt;
            index &lt; 3 ? (
              &lt;div
                key={index}
                className={`${styles.spectrumBarRed} ${isEnabled &amp;&amp; isBarActive(right, index) ? styles.active : &apos;&apos;}`}
              /&gt;
            ) : (
              &lt;div
                key={index}
                className={`${styles.spectrumBar} ${isEnabled &amp;&amp; isBarActive(right, index) ? styles.active : &apos;&apos;}`}
              /&gt;
            ),
          )}
          &lt;div className={`${styles.spectrumBar} ${isEnabled &amp;&amp; barsMode === &apos;bars&apos; ? styles.active : &apos;&apos;}`} /&gt;
          &lt;p className={`${styles.barFrequencyDescription} ${isEnabled ? styles.active : &apos;&apos;}`}&gt;
            RIGHT
          &lt;/p&gt;
        &lt;/div&gt;
      &lt;/div&gt;
    &lt;/div&gt;
  );
};</file><file path="resources/app/modules/equalizer/components/vfd-display.module.scss">.vfdDisplayContainer {
  background-color: #0b0b0e;
  border-radius: 0.5em;
  display: flex;
  flex-direction: column;
  padding: 0.5em 0;
  position: relative;
  &amp;::before {
    content: &apos; &apos;;
    display: block;
    position: absolute;
    top: 0;
    left: 0;
    height: 100%;
    width: 100%;
    border-radius: 0.5em;
    background: linear-gradient(
                    rgba(18, 16, 16, 0) 50%,
                    rgba(0, 0, 0, 0.25) 50%
    ),
    linear-gradient(
                    90deg,
                    rgba(255, 0, 0, 0.06),
                    rgba(0, 255, 0, 0.02),
                    rgba(0, 0, 255, 0.06)
    );
    z-index: 2;
    background-size: 100% 2px, 3px 100%;
  }
}
.vfdAnalyzersRow {
  padding: 0 1.25em;
  display: flex;
  flex: 1;
  gap: 2em;
  align-items: center;
}
.vfdControls {
  display: flex;
  gap: 1em;
  padding: 0.25em 1.25em;
}
.vfdControl {
  color: #062626;
  font-size: 1em;
  font-weight: bold;
  text-shadow: none;
  &amp;.active {
    color: #1caeae;
    text-shadow: 0 0 10px #1caeae;
  }
}
.vfdControlRed {
  font-size: 1em;
  font-weight: bold;
  text-transform: uppercase;
  color: #250c06;
  text-shadow: none;
  &amp;.active {
    color: #9c341a;
    text-shadow: 0 0 10px #9c341a;
  }
}</file><file path="resources/app/modules/equalizer/components/vfd-display.tsx">import { BarsMode } from &apos;@/modules/equalizer/types.ts&apos;;
import styles from &apos;./vfd-display.module.scss&apos;;
import { VfdSpectrumAnalyzer } from &apos;@/modules/equalizer/components/vfd-spectrum.tsx&apos;;
import { VfdChannelAnalyzer } from &apos;@/modules/equalizer/components/vfd-channel-analyzer.tsx&apos;;
import { PlaybackSource } from &apos;@/modules/equalizer/models/playback-source.ts&apos;;
export interface VfdDisplayProps {
  [key: string]: any;
  isEnabled: boolean;
  audioSource: PlaybackSource;
  isMuted: boolean;
  isRepeatEnabled: boolean;
  isShuffleEnabled: boolean;
  isMicrophoneEnabled: boolean;
  leftChannel: number;
  rightChannel: number;
  isStereoEnabled: boolean;
  isKaraokeEnabled: boolean;
  frequencies: number[];
  barsMode: BarsMode;
  frequencyBars: {
    label: string;
    frequencyId: number;
  }[];
}
export function VfdDisplay(props: VfdDisplayProps) {
  const {
    isEnabled,
    audioSource,
    isMuted,
    isRepeatEnabled,
    isShuffleEnabled,
    isMicrophoneEnabled,
    leftChannel,
    rightChannel,
    isStereoEnabled,
    isKaraokeEnabled,
    frequencies,
    frequencyBars,
    barsMode,
    ...rest
  } = props;
  return (
    &lt;div className={styles.vfdDisplayContainer} {...rest}&gt;
      &lt;div className={styles.vfdControls}&gt;
        &lt;p className={`${styles.vfdControl} ${isEnabled &amp;&amp; audioSource === PlaybackSource.LIBRARY ? styles.active : &apos;&apos;}`}&gt;
          TAPE
        &lt;/p&gt;
        &lt;p className={`${styles.vfdControl} ${isEnabled &amp;&amp; audioSource === PlaybackSource.INTERNET_RADIO ? styles.active : &apos;&apos;}`}&gt;
          TUNER
        &lt;/p&gt;
        &lt;p className={`${styles.vfdControl} ${isEnabled &amp;&amp; audioSource === PlaybackSource.STREAMING ? styles.active : &apos;&apos;}`}&gt;
          AUX
        &lt;/p&gt;
        &lt;p className={`${styles.vfdControlRed} ${isEnabled &amp;&amp; isMicrophoneEnabled ? styles.active : &apos;&apos;}`}&gt;
          MIC
        &lt;/p&gt;
      &lt;/div&gt;
      &lt;div className={styles.vfdAnalyzersRow}&gt;
        &lt;VfdSpectrumAnalyzer
          frequencies={frequencies}
          isEnabled={isEnabled &amp;&amp; barsMode !== &apos;off&apos;}
          frequencyBars={frequencyBars}
          barsMode={barsMode}
        /&gt;
        &lt;VfdChannelAnalyzer
          left={leftChannel}
          right={rightChannel}
          isEnabled={isEnabled &amp;&amp; barsMode !== &apos;off&apos;}
          barsMode={barsMode}
        /&gt;
      &lt;/div&gt;
      &lt;div className={styles.vfdControls}&gt;
        &lt;p className={`${styles.vfdControl} ${isEnabled ? styles.active : &apos;&apos;}`}&gt;
          Hi-Fi
        &lt;/p&gt;
        &lt;p className={`${styles.vfdControl} ${isEnabled &amp;&amp; isStereoEnabled ? styles.active : &apos;&apos;}`}&gt;
          STEREO
        &lt;/p&gt;
        &lt;p className={`${styles.vfdControl} ${isEnabled &amp;&amp; isRepeatEnabled ? styles.active : &apos;&apos;}`}&gt;
          REPEAT
        &lt;/p&gt;
        &lt;p className={`${styles.vfdControl} ${isEnabled &amp;&amp; isShuffleEnabled ? styles.active : &apos;&apos;}`}&gt;
          SHUFFLE
        &lt;/p&gt;
        &lt;p className={`${styles.vfdControl} ${isEnabled &amp;&amp; isMuted ? styles.active : &apos;&apos;}`}&gt;
          MUTING
        &lt;/p&gt;
        &lt;p className={`${styles.vfdControl} ${isEnabled &amp;&amp; isKaraokeEnabled &amp;&amp; isMicrophoneEnabled ? styles.active : &apos;&apos;}`}&gt;
          KARAOKE
        &lt;/p&gt;
      &lt;/div&gt;
    &lt;/div&gt;
  );
}</file><file path="resources/app/modules/equalizer/components/vfd-spectrum.module.scss">.spectrumColumn {
  display: flex;
  flex-direction: column;
  gap: 0.25em;
  width: 1.5em;
  &amp;.channel-column {
    width: 2.5em;
  }
}
.spectrumBar {
  width: 100%;
  height: 0.25em;
  background-color: #062626;
  box-shadow: none;
  &amp;.active {
    background-color: #1caeae;
    box-shadow: 0 0 10px #1caeae;
  }
}
.spectrumBarRed {
  width: 100%;
  height: 0.25em;
  background-color: #250c06;
  box-shadow: none;
  &amp;.active {
    background-color: #9c341a;
    box-shadow: 0 0 10px #9c341a;
  }
}
.barFrequencyDescription {
  color: #062626;
  font-size: 0.75em;
  font-weight: bold;
  text-shadow: none;
  margin: 0.25em 0;
  text-align: center;
  &amp;.active {
    color: #1caeae;
    text-shadow: 0 0 10px #1caeae;
  }
}
.vfdSpectrum {
  display: flex;
  gap: 0.5em;
}</file><file path="resources/app/modules/equalizer/components/vfd-spectrum.tsx">import { BarsMode } from &apos;@/modules/equalizer/types.ts&apos;;
import styles from &apos;./vfd-spectrum.module.scss&apos;;
export interface VfdSpectrumAnalyzerProps {
  isEnabled: boolean;
  frequencies: number[];
  frequencyBars: {
    label: string;
    frequencyId: number;
  }[];
  barsMode: BarsMode;
}
export const VfdSpectrumAnalyzer = (props: VfdSpectrumAnalyzerProps) =&gt; {
  const { isEnabled, frequencyBars, frequencies, barsMode } = props;
  const isBarActive = (value: number, index: number) =&gt; {
    switch (barsMode) {
      case &apos;bars&apos;:
        return value - 100 - (55 - index * 5) &gt;= 100 - index * 10;
      case &apos;pointer&apos;:
        return value - 100 - (55 - index * 5) &gt;= 100 - index * 10 &amp;&amp;
          !(value - 100 - (55 - (index - 1) * 5) &gt;= 100 - (index - 1) * 10);
      case &apos;off&apos;:
        return false;
      default:
        return false;
    }
  };
  return (
    &lt;div className={styles.vfdSpectrum}&gt;
      {frequencyBars.map((bar) =&gt; (
        &lt;div key={bar.frequencyId} className={styles.spectrumColumn}&gt;
          {Array.from({ length: 12 }, (_, index) =&gt;
            index &lt; 3 ? (
              &lt;div
                key={index}
                className={`${styles.spectrumBarRed} ${isEnabled &amp;&amp; isBarActive(frequencies[bar.frequencyId], index) ? styles.active : &apos;&apos;}`}
              /&gt;
            ) : (
              &lt;div
                key={index}
                className={`${styles.spectrumBar} ${isEnabled &amp;&amp; isBarActive(frequencies[bar.frequencyId], index) ? styles.active : &apos;&apos;}`}
              /&gt;
            ),
          )}
          &lt;div className={`${styles.spectrumBar} ${isEnabled &amp;&amp; barsMode === &apos;bars&apos; ? styles.active : &apos;&apos;}`}/&gt;
          &lt;p className={`${styles.barFrequencyDescription} ${isEnabled ? styles.active : &apos;&apos;}`}&gt;
            {bar.label}
          &lt;/p&gt;
        &lt;/div&gt;
      ))}
    &lt;/div&gt;
  );
};</file><file path="resources/app/modules/equalizer/equalizer.module.scss">.buttonsContainer {
  display: flex;
  align-items: center;
  justify-content: space-evenly;
}
.eqContainer {
  position: relative;
}
.gridCol {
  position: relative;
}
.knobCol {
  position: relative;
  display: flex;
  justify-content: space-between;
}</file><file path="resources/app/modules/equalizer/models/playback-source.ts">export enum PlaybackSource {
  NONE = &apos;none&apos;,
  INTERNET_RADIO = &apos;internet-radio&apos;,
  LIBRARY = &apos;library&apos;,
  STREAMING = &apos;streaming&apos;,
}</file><file path="resources/app/modules/equalizer/models/three-band-eq.ts">export class ThreeBandEq {
  constructor(
    public bass: number,
    public middle: number,
    public treble: number,
  ) {
  }
}</file><file path="resources/app/modules/equalizer/types.ts">export type BarsMode = &apos;bars&apos; | &apos;pointer&apos; | &apos;off&apos;;</file><file path="resources/app/modules/equalizer/vfd-frequency-bars.ts">export const vfdFrequencyBars = [
  {
    label: &apos;32&apos;,
    frequencyId: 5,
  },
  {
    label: &apos;64&apos;,
    frequencyId: 15,
  },
  {
    label: &apos;128&apos;,
    frequencyId: 35,
  },
  {
    label: &apos;256&apos;,
    frequencyId: 70,
  },
  {
    label: &apos;512&apos;,
    frequencyId: 135,
  },
  {
    label: &apos;1k&apos;,
    frequencyId: 165,
  },
  {
    label: &apos;2k&apos;,
    frequencyId: 195,
  },
  {
    label: &apos;4k&apos;,
    frequencyId: 230,
  },
  {
    label: &apos;6k&apos;,
    frequencyId: 275,
  },
  {
    label: &apos;8k&apos;,
    frequencyId: 300,
  },
  {
    label: &apos;10k&apos;,
    frequencyId: 340,
  },
  {
    label: &apos;12k&apos;,
    frequencyId: 370,
  },
  {
    label: &apos;16k&apos;,
    frequencyId: 400,
  },
];</file><file path="resources/app/modules/library-movies/mock.ts">import { MovieResource } from &apos;@/modules/library-movies/modes.ts&apos;;
export const movieResources: MovieResource[] = [
  {
    title: &quot;The Shawshank Redemption&quot;,
    ratingScores: [{ provider: &quot;IMDb&quot;, score: &quot;9.3&quot; }, { provider: &quot;Rotten Tomatoes&quot;, score: &quot;91%&quot; }],
    status: &quot;OK&quot;,
    runtime: &quot;142 minutes&quot;,
    language: &quot;English&quot;,
    year: 1994,
    summary: &quot;Two imprisoned men bond over a number of years, finding solace and eventual redemption through acts of common decency.&quot;,
    genres: [&quot;Drama&quot;],
    actors: [{ name: &quot;Tim Robbins&quot; }, { name: &quot;Morgan Freeman&quot; }]
  },
  {
    title: &quot;The Godfather&quot;,
    ratingScores: [{ provider: &quot;IMDb&quot;, score: &quot;9.2&quot; }, { provider: &quot;Rotten Tomatoes&quot;, score: &quot;97%&quot; }],
    status: &quot;OK&quot;,
    runtime: &quot;175 minutes&quot;,
    language: &quot;English&quot;,
    year: 1972,
    summary: &quot;The aging patriarch of an organized crime dynasty transfers control of his clandestine empire to his reluctant son.&quot;,
    genres: [&quot;Crime&quot;, &quot;Drama&quot;],
    actors: [{ name: &quot;Marlon Brando&quot; }, { name: &quot;Al Pacino&quot; }]
  },
  {
    title: &quot;The Dark Knight&quot;,
    ratingScores: [{ provider: &quot;IMDb&quot;, score: &quot;9.0&quot; }, { provider: &quot;Rotten Tomatoes&quot;, score: &quot;94%&quot; }],
    status: &quot;OK&quot;,
    runtime: &quot;152 minutes&quot;,
    language: &quot;English&quot;,
    year: 2008,
    summary: &quot;When the menace known as The Joker emerges from his mysterious past, he wreaks havoc and chaos on the people of Gotham.&quot;,
    genres: [&quot;Action&quot;, &quot;Crime&quot;, &quot;Drama&quot;],
    actors: [{ name: &quot;Christian Bale&quot; }, { name: &quot;Heath Ledger&quot; }]
  },
  {
    title: &quot;Pulp Fiction&quot;,
    ratingScores: [{ provider: &quot;IMDb&quot;, score: &quot;8.9&quot; }, { provider: &quot;Rotten Tomatoes&quot;, score: &quot;92%&quot; }],
    status: &quot;OK&quot;,
    runtime: &quot;154 minutes&quot;,
    language: &quot;English&quot;,
    year: 1994,
    summary: &quot;The lives of two mob hitmen, a boxer, a gangster and his wife, and a pair of diner bandits intertwine in four tales of violence and redemption.&quot;,
    genres: [&quot;Crime&quot;, &quot;Drama&quot;],
    actors: [{ name: &quot;John Travolta&quot; }, { name: &quot;Uma Thurman&quot; }]
  },
  {
    title: &quot;Inception&quot;,
    ratingScores: [{ provider: &quot;IMDb&quot;, score: &quot;8.8&quot; }, { provider: &quot;Rotten Tomatoes&quot;, score: &quot;87%&quot; }],
    status: &quot;OK&quot;,
    runtime: &quot;148 minutes&quot;,
    language: &quot;English&quot;,
    year: 2010,
    summary: &quot;A thief who steals corporate secrets through the use of dream-sharing technology is given the inverse task of planting an idea into the mind of a C.E.O.&quot;,
    genres: [&quot;Action&quot;, &quot;Adventure&quot;, &quot;Sci-Fi&quot;],
    actors: [{ name: &quot;Leonardo DiCaprio&quot; }, { name: &quot;Joseph Gordon-Levitt&quot; }]
  },
  {
    title: &quot;Fight Club&quot;,
    ratingScores: [{ provider: &quot;IMDb&quot;, score: &quot;8.8&quot; }, { provider: &quot;Rotten Tomatoes&quot;, score: &quot;79%&quot; }],
    status: &quot;OK&quot;,
    runtime: &quot;139 minutes&quot;,
    language: &quot;English&quot;,
    year: 1999,
    summary: &quot;An insomniac office worker and a devil-may-care soap maker form an underground fight club that evolves into something much, much more.&quot;,
    genres: [&quot;Drama&quot;],
    actors: [{ name: &quot;Brad Pitt&quot; }, { name: &quot;Edward Norton&quot; }]
  },
  {
    title: &quot;Forrest Gump&quot;,
    ratingScores: [{ provider: &quot;IMDb&quot;, score: &quot;8.8&quot; }, { provider: &quot;Rotten Tomatoes&quot;, score: &quot;71%&quot; }],
    status: &quot;OK&quot;,
    runtime: &quot;142 minutes&quot;,
    language: &quot;English&quot;,
    year: 1994,
    summary: &quot;The presidencies of Kennedy and Johnson, the Vietnam War, the Watergate scandal and other historical events unfold from the perspective of an Alabama man with an IQ of 75.&quot;,
    genres: [&quot;Drama&quot;, &quot;Romance&quot;],
    actors: [{ name: &quot;Tom Hanks&quot; }, { name: &quot;Robin Wright&quot; }]
  },
  {
    title: &quot;The Matrix&quot;,
    ratingScores: [{ provider: &quot;IMDb&quot;, score: &quot;8.7&quot; }, { provider: &quot;Rotten Tomatoes&quot;, score: &quot;88%&quot; }],
    status: &quot;OK&quot;,
    runtime: &quot;136 minutes&quot;,
    language: &quot;English&quot;,
    year: 1999,
    summary: &quot;A computer hacker learns from mysterious rebels about the true nature of his reality and his role in the war against its controllers.&quot;,
    genres: [&quot;Action&quot;, &quot;Sci-Fi&quot;],
    actors: [{ name: &quot;Keanu Reeves&quot; }, { name: &quot;Laurence Fishburne&quot; }]
  },
  {
    title: &quot;The Lord of the Rings: The Fellowship of the Ring&quot;,
    ratingScores: [{ provider: &quot;IMDb&quot;, score: &quot;8.8&quot; }, { provider: &quot;Rotten Tomatoes&quot;, score: &quot;91%&quot; }],
    status: &quot;OK&quot;,
    runtime: &quot;178 minutes&quot;,
    language: &quot;English&quot;,
    year: 2001,
    summary: &quot;A meek Hobbit from the Shire and eight companions set out on a journey to destroy the powerful One Ring and save Middle-earth from the Dark Lord Sauron.&quot;,
    genres: [&quot;Action&quot;, &quot;Adventure&quot;, &quot;Drama&quot;],
    actors: [{ name: &quot;Elijah Wood&quot; }, { name: &quot;Ian McKellen&quot; }]
  },
  {
    title: &quot;Star Wars: Episode V - The Empire Strikes Back&quot;,
    ratingScores: [{ provider: &quot;IMDb&quot;, score: &quot;8.7&quot; }, { provider: &quot;Rotten Tomatoes&quot;, score: &quot;94%&quot; }],
    status: &quot;OK&quot;,
    runtime: &quot;124 minutes&quot;,
    language: &quot;English&quot;,
    year: 1980,
    summary: &quot;After the Rebels are brutally overpowered by the Empire on the ice planet Hoth, Luke Skywalker begins Jedi training with Yoda, while his friends are pursued across the galaxy by Darth Vader and bounty hunter Boba Fett.&quot;,
    genres: [&quot;Action&quot;, &quot;Adventure&quot;, &quot;Fantasy&quot;],
    actors: [{ name: &quot;Mark Hamill&quot; }, { name: &quot;Harrison Ford&quot; }]
  },
  {
    title: &quot;Interstellar&quot;,
    ratingScores: [{ provider: &quot;IMDb&quot;, score: &quot;8.6&quot; }, { provider: &quot;Rotten Tomatoes&quot;, score: &quot;72%&quot; }],
    status: &quot;OK&quot;,
    runtime: &quot;169 minutes&quot;,
    language: &quot;English&quot;,
    year: 2014,
    summary: &quot;A team of explorers travel through a wormhole in space in an attempt to ensure humanity&apos;s survival.&quot;,
    genres: [&quot;Adventure&quot;, &quot;Drama&quot;, &quot;Sci-Fi&quot;],
    actors: [{ name: &quot;Matthew McConaughey&quot; }, { name: &quot;Anne Hathaway&quot; }]
  },
  {
    title: &quot;The Silence of the Lambs&quot;,
    ratingScores: [{ provider: &quot;IMDb&quot;, score: &quot;8.6&quot; }, { provider: &quot;Rotten Tomatoes&quot;, score: &quot;96%&quot; }],
    status: &quot;OK&quot;,
    runtime: &quot;118 minutes&quot;,
    language: &quot;English&quot;,
    year: 1991,
    summary: &quot;A young F.B.I. cadet must receive the help of an incarcerated and manipulative cannibal killer to help catch another serial killer, a madman who skins his victims.&quot;,
    genres: [&quot;Crime&quot;, &quot;Drama&quot;, &quot;Thriller&quot;],
    actors: [{ name: &quot;Jodie Foster&quot; }, { name: &quot;Anthony Hopkins&quot; }]
  },
  {
    title: &quot;Saving Private Ryan&quot;,
    ratingScores: [{ provider: &quot;IMDb&quot;, score: &quot;8.6&quot; }, { provider: &quot;Rotten Tomatoes&quot;, score: &quot;93%&quot; }],
    status: &quot;OK&quot;,
    runtime: &quot;169 minutes&quot;,
    language: &quot;English&quot;,
    year: 1998,
    summary: &quot;Following the Normandy Landings, a group of U.S. soldiers go behind enemy lines to retrieve a paratrooper whose brothers have been killed in action.&quot;,
    genres: [&quot;Drama&quot;, &quot;War&quot;],
    actors: [{ name: &quot;Tom Hanks&quot; }, { name: &quot;Matt Damon&quot; }]
  },
  {
    title: &quot;The Green Mile&quot;,
    ratingScores: [{ provider: &quot;IMDb&quot;, score: &quot;8.6&quot; }, { provider: &quot;Rotten Tomatoes&quot;, score: &quot;79%&quot; }],
    status: &quot;OK&quot;,
    runtime: &quot;189 minutes&quot;,
    language: &quot;English&quot;,
    year: 1999,
    summary: &quot;The lives of guards on Death Row are affected by one of their charges: a black man accused of child murder and rape, yet who has a mysterious gift.&quot;,
    genres: [&quot;Crime&quot;, &quot;Drama&quot;, &quot;Fantasy&quot;],
    actors: [{ name: &quot;Tom Hanks&quot; }, { name: &quot;Michael Clarke Duncan&quot; }]
  },
  {
    title: &quot;Parasite&quot;,
    ratingScores: [{ provider: &quot;IMDb&quot;, score: &quot;8.6&quot; }, { provider: &quot;Rotten Tomatoes&quot;, score: &quot;98%&quot; }],
    status: &quot;OK&quot;,
    runtime: &quot;132 minutes&quot;,
    language: &quot;Korean&quot;,
    year: 2019,
    summary: &quot;Greed and class discrimination threaten the newly formed symbiotic relationship between the wealthy Park family and the destitute Kim clan.&quot;,
    genres: [&quot;Comedy&quot;, &quot;Drama&quot;, &quot;Thriller&quot;],
    actors: [{ name: &quot;Kang-ho Song&quot; }, { name: &quot;Sun-kyun Lee&quot; }]
  },
  {
    title: &quot;Spirited Away&quot;,
    ratingScores: [{ provider: &quot;IMDb&quot;, score: &quot;8.6&quot; }, { provider: &quot;Rotten Tomatoes&quot;, score: &quot;97%&quot; }],
    status: &quot;OK&quot;,
    runtime: &quot;125 minutes&quot;,
    language: &quot;Japanese&quot;,
    year: 2001,
    summary: &quot;During her family&apos;s move to the suburbs, a sullen 10-year-old girl wanders into a world ruled by gods, witches, and spirits, where humans are changed into beasts.&quot;,
    genres: [&quot;Animation&quot;, &quot;Adventure&quot;, &quot;Family&quot;],
    actors: [{ name: &quot;Daveigh Chase&quot; }, { name: &quot;Suzanne Pleshette&quot; }]
  },
  {
    title: &quot;The Lion King&quot;,
    ratingScores: [{ provider: &quot;IMDb&quot;, score: &quot;8.5&quot; }, { provider: &quot;Rotten Tomatoes&quot;, score: &quot;93%&quot; }],
    status: &quot;OK&quot;,
    runtime: &quot;88 minutes&quot;,
    language: &quot;English&quot;,
    year: 1994,
    summary: &quot;Lion prince Simba and his father are targeted by his bitter uncle, who wants to ascend the throne himself.&quot;,
    genres: [&quot;Animation&quot;, &quot;Adventure&quot;, &quot;Drama&quot;],
    actors: [{ name: &quot;Matthew Broderick&quot; }, { name: &quot;Jeremy Irons&quot; }]
  },
  {
    title: &quot;The Pianist&quot;,
    ratingScores: [{ provider: &quot;IMDb&quot;, score: &quot;8.5&quot; }, { provider: &quot;Rotten Tomatoes&quot;, score: &quot;95%&quot; }],
    status: &quot;OK&quot;,
    runtime: &quot;150 minutes&quot;,
    language: &quot;English&quot;,
    year: 2002,
    summary: &quot;A Polish Jewish musician struggles to survive the destruction of the Warsaw ghetto of World War II.&quot;,
    genres: [&quot;Biography&quot;, &quot;Drama&quot;, &quot;Music&quot;],
    actors: [{ name: &quot;Adrien Brody&quot; }, { name: &quot;Thomas Kretschmann&quot; }]
  },
  {
    title: &quot;The Usual Suspects&quot;,
    ratingScores: [{ provider: &quot;IMDb&quot;, score: &quot;8.5&quot; }, { provider: &quot;Rotten Tomatoes&quot;, score: &quot;89%&quot; }],
    status: &quot;OK&quot;,
    runtime: &quot;106 minutes&quot;,
    language: &quot;English&quot;,
    year: 1995,
    summary: &quot;A sole survivor tells of the twisty events leading up to a horrific gun battle on a boat, which begin when five criminals meet at a seemingly random police lineup.&quot;,
    genres: [&quot;Crime&quot;, &quot;Drama&quot;, &quot;Mystery&quot;],
    actors: [{ name: &quot;Kevin Spacey&quot; }, { name: &quot;Gabriel Byrne&quot; }]
  },
  {
    title: &quot;Terminator 2: Judgment Day&quot;,
    ratingScores: [{ provider: &quot;IMDb&quot;, score: &quot;8.5&quot; }, { provider: &quot;Rotten Tomatoes&quot;, score: &quot;93%&quot; }],
    status: &quot;OK&quot;,
    runtime: &quot;137 minutes&quot;,
    language: &quot;English&quot;,
    year: 1991,
    summary: &quot;A cyborg, identical to the one who failed to kill Sarah Connor, must now protect her teenage son, John Connor, from a more advanced and powerful cyborg.&quot;,
    genres: [&quot;Action&quot;, &quot;Sci-Fi&quot;],
    actors: [{ name: &quot;Arnold Schwarzenegger&quot; }, { name: &quot;Linda Hamilton&quot; }]
  },
  {
    title: &quot;Back to the Future&quot;,
    ratingScores: [{ provider: &quot;IMDb&quot;, score: &quot;8.5&quot; }, { provider: &quot;Rotten Tomatoes&quot;, score: &quot;96%&quot; }],
    status: &quot;OK&quot;,
    runtime: &quot;116 minutes&quot;,
    language: &quot;English&quot;,
    year: 1985,
    summary: &quot;Marty McFly, a 17-year-old high school student, is accidentally sent thirty years into the past in a time-traveling DeLorean invented by his close friend, eccentric scientist Doc Brown.&quot;,
    genres: [&quot;Adventure&quot;, &quot;Comedy&quot;, &quot;Sci-Fi&quot;],
    actors: [{ name: &quot;Michael J. Fox&quot; }, { name: &quot;Christopher Lloyd&quot; }]
  },
  {
    title: &quot;Gladiator&quot;,
    ratingScores: [{ provider: &quot;IMDb&quot;, score: &quot;8.5&quot; }, { provider: &quot;Rotten Tomatoes&quot;, score: &quot;77%&quot; }],
    status: &quot;OK&quot;,
    runtime: &quot;155 minutes&quot;,
    language: &quot;English&quot;,
    year: 2000,
    summary: &quot;A former Roman General sets out to exact vengeance against the corrupt emperor who murdered his family and sent him into slavery.&quot;,
    genres: [&quot;Action&quot;, &quot;Adventure&quot;, &quot;Drama&quot;],
    actors: [{ name: &quot;Russell Crowe&quot; }, { name: &quot;Joaquin Phoenix&quot; }]
  },
  {
    title: &quot;Green Book&quot;,
    ratingScores: [{ provider: &quot;IMDb&quot;, score: &quot;8.2&quot; }, { provider: &quot;Rotten Tomatoes&quot;, score: &quot;77%&quot; }],
    status: &quot;OK&quot;,
    runtime: &quot;130 minutes&quot;,
    language: &quot;English&quot;,
    year: 2018,
    summary: &quot;A working-class Italian-American bouncer becomes the driver of an African-American classical pianist on a tour of venues through the 1960s American South.&quot;,
    genres: [&quot;Biography&quot;, &quot;Comedy&quot;, &quot;Drama&quot;],
    actors: [{ name: &quot;Viggo Mortensen&quot; }, { name: &quot;Mahershala Ali&quot; }]
  },
  {
    title: &quot;Hamilton&quot;,
    ratingScores: [{ provider: &quot;IMDb&quot;, score: &quot;8.5&quot; }, { provider: &quot;Rotten Tomatoes&quot;, score: &quot;98%&quot; }],
    status: &quot;OK&quot;,
    runtime: &quot;160 minutes&quot;,
    language: &quot;English&quot;,
    year: 2020,
    summary: &quot;The real life of one of America&apos;s foremost founding fathers and first Secretary of the Treasury, Alexander Hamilton. Captured live on Broadway from the Richard Rodgers Theater with the original Broadway cast.&quot;,
    genres: [&quot;Biography&quot;, &quot;Drama&quot;, &quot;History&quot;],
    actors: [{ name: &quot;Lin-Manuel Miranda&quot; }, { name: &quot;Phillipa Soo&quot; }]
  },
  {
    title: &quot;Blade Runner 2049&quot;,
    ratingScores: [{ provider: &quot;IMDb&quot;, score: &quot;8.0&quot; }, { provider: &quot;Rotten Tomatoes&quot;, score: &quot;88%&quot; }],
    status: &quot;OK&quot;,
    runtime: &quot;164 minutes&quot;,
    language: &quot;English&quot;,
    year: 2017,
    summary: &quot;Young Blade Runner K&apos;s discovery of a long-buried secret leads him to track down former Blade Runner Rick Deckard, who&apos;s been missing for thirty years.&quot;,
    genres: [&quot;Action&quot;, &quot;Drama&quot;, &quot;Sci-Fi&quot;],
    actors: [{ name: &quot;Harrison Ford&quot; }, { name: &quot;Ryan Gosling&quot; }]
  },
  {
    title: &quot;A Beautiful Mind&quot;,
    ratingScores: [{ provider: &quot;IMDb&quot;, score: &quot;8.2&quot; }, { provider: &quot;Rotten Tomatoes&quot;, score: &quot;74%&quot; }],
    status: &quot;OK&quot;,
    runtime: &quot;135 minutes&quot;,
    language: &quot;English&quot;,
    year: 2001,
    summary: &quot;After John Nash, a brilliant but asocial mathematician, accepts secret work in cryptography, his life takes a turn for the nightmarish.&quot;,
    genres: [&quot;Biography&quot;, &quot;Drama&quot;],
    actors: [{ name: &quot;Russell Crowe&quot; }, { name: &quot;Ed Harris&quot; }]
  },
  {
    title: &quot;Room&quot;,
    ratingScores: [{ provider: &quot;IMDb&quot;, score: &quot;8.1&quot; }, { provider: &quot;Rotten Tomatoes&quot;, score: &quot;93%&quot; }],
    status: &quot;OK&quot;,
    runtime: &quot;118 minutes&quot;,
    language: &quot;English&quot;,
    year: 2015,
    summary: &quot;A young boy is raised within the confines of a small shed.&quot;,
    genres: [&quot;Drama&quot;, &quot;Thriller&quot;],
    actors: [{ name: &quot;Brie Larson&quot; }, { name: &quot;Jacob Tremblay&quot; }]
  },
  {
    title: &quot;The Shape of Water&quot;,
    ratingScores: [{ provider: &quot;IMDb&quot;, score: &quot;7.3&quot; }, { provider: &quot;Rotten Tomatoes&quot;, score: &quot;92%&quot; }],
    status: &quot;OK&quot;,
    runtime: &quot;123 minutes&quot;,
    language: &quot;English&quot;,
    year: 2017,
    summary: &quot;At a top-secret research facility in the 1960s, a lonely janitor forms a unique relationship with an amphibious creature that is being held in captivity.&quot;,
    genres: [&quot;Drama&quot;, &quot;Fantasy&quot;, &quot;Romance&quot;],
    actors: [{ name: &quot;Sally Hawkins&quot; }, { name: &quot;Octavia Spencer&quot; }]
  },
  {
    title: &quot;The Prestige&quot;,
    ratingScores: [{ provider: &quot;IMDb&quot;, score: &quot;8.5&quot; }, { provider: &quot;Rotten Tomatoes&quot;, score: &quot;76%&quot; }],
    status: &quot;OK&quot;,
    runtime: &quot;130 minutes&quot;,
    language: &quot;English&quot;,
    year: 2006,
    summary: &quot;After a tragic accident, two stage magicians engage in a battle to create the ultimate illusion while sacrificing everything they have to outwit each other.&quot;,
    genres: [&quot;Drama&quot;, &quot;Mystery&quot;, &quot;Sci-Fi&quot;],
    actors: [{ name: &quot;Christian Bale&quot; }, { name: &quot;Hugh Jackman&quot; }]
  },
  {
    title: &quot;Whiplash&quot;,
    ratingScores: [{ provider: &quot;IMDb&quot;, score: &quot;8.5&quot; }, { provider: &quot;Rotten Tomatoes&quot;, score: &quot;94%&quot; }],
    status: &quot;OK&quot;,
    runtime: &quot;106 minutes&quot;,
    language: &quot;English&quot;,
    year: 2014,
    summary: &quot;A promising young drummer enrolls at a cut-throat music conservatory where his dreams of greatness are mentored by an instructor who will stop at nothing to realize a student&apos;s potential.&quot;,
    genres: [&quot;Drama&quot;, &quot;Music&quot;],
    actors: [{ name: &quot;Miles Teller&quot; }, { name: &quot;J.K. Simmons&quot; }]
  },
  {
    title: &quot;The Intouchables&quot;,
    ratingScores: [{ provider: &quot;IMDb&quot;, score: &quot;8.5&quot; }, { provider: &quot;Rotten Tomatoes&quot;, score: &quot;75%&quot; }],
    status: &quot;OK&quot;,
    runtime: &quot;112 minutes&quot;,
    language: &quot;French&quot;,
    year: 2011,
    summary: &quot;After he becomes a quadriplegic from a paragliding accident, an aristocrat hires a young man from the projects to be his caregiver.&quot;,
    genres: [&quot;Biography&quot;, &quot;Comedy&quot;, &quot;Drama&quot;],
    actors: [{ name: &quot;François Cluzet&quot; }, { name: &quot;Omar Sy&quot; }]
  },
  {
    title: &quot;The Great Dictator&quot;,
    ratingScores: [{ provider: &quot;IMDb&quot;, score: &quot;8.5&quot; }, { provider: &quot;Rotten Tomatoes&quot;, score: &quot;93%&quot; }],
    status: &quot;OK&quot;,
    runtime: &quot;125 minutes&quot;,
    language: &quot;English&quot;,
    year: 1940,
    summary: &quot;Dictator Adenoid Hynkel tries to expand his empire while a poor Jewish barber tries to avoid persecution from Hynkel&apos;s regime.&quot;,
    genres: [&quot;Comedy&quot;, &quot;Drama&quot;, &quot;War&quot;],
    actors: [{ name: &quot;Charlie Chaplin&quot; }, { name: &quot;Paulette Goddard&quot; }]
  },
  {
    title: &quot;The Pianist&quot;,
    ratingScores: [{ provider: &quot;IMDb&quot;, score: &quot;8.5&quot; }, { provider: &quot;Rotten Tomatoes&quot;, score: &quot;95%&quot; }],
    status: &quot;OK&quot;,
    runtime: &quot;150 minutes&quot;,
    language: &quot;English&quot;,
    year: 2002,
    summary: &quot;A Polish Jewish musician struggles to survive the destruction of the Warsaw ghetto of World War II.&quot;,
    genres: [&quot;Biography&quot;, &quot;Drama&quot;, &quot;Music&quot;],
    actors: [{ name: &quot;Adrien Brody&quot; }, { name: &quot;Thomas Kretschmann&quot; }]
  },
  {
    title: &quot;The Usual Suspects&quot;,
    ratingScores: [{ provider: &quot;IMDb&quot;, score: &quot;8.5&quot; }, { provider: &quot;Rotten Tomatoes&quot;, score: &quot;89%&quot; }],
    status: &quot;OK&quot;,
    runtime: &quot;106 minutes&quot;,
    language: &quot;English&quot;,
    year: 1995,
    summary: &quot;A sole survivor tells of the twisty events leading up to a horrific gun battle on a boat, which begin when five criminals meet at a seemingly random police lineup.&quot;,
    genres: [&quot;Crime&quot;, &quot;Drama&quot;, &quot;Mystery&quot;],
    actors: [{ name: &quot;Kevin Spacey&quot; }, { name: &quot;Gabriel Byrne&quot; }]
  },
  {
    title: &quot;Terminator 2: Judgment Day&quot;,
    ratingScores: [{ provider: &quot;IMDb&quot;, score: &quot;8.5&quot; }, { provider: &quot;Rotten Tomatoes&quot;, score: &quot;93%&quot; }],
    status: &quot;OK&quot;,
    runtime: &quot;137 minutes&quot;,
    language: &quot;English&quot;,
    year: 1991,
    summary: &quot;A cyborg, identical to the one who failed to kill Sarah Connor, must now protect her teenage son, John Connor, from a more advanced and powerful cyborg.&quot;,
    genres: [&quot;Action&quot;, &quot;Sci-Fi&quot;],
    actors: [{ name: &quot;Arnold Schwarzenegger&quot; }, { name: &quot;Linda Hamilton&quot; }]
  },
  {
    title: &quot;Back to the Future&quot;,
    ratingScores: [{ provider: &quot;IMDb&quot;, score: &quot;8.5&quot; }, { provider: &quot;Rotten Tomatoes&quot;, score: &quot;96%&quot; }],
    status: &quot;OK&quot;,
    runtime: &quot;116 minutes&quot;,
    language: &quot;English&quot;,
    year: 1985,
    summary: &quot;Marty McFly, a 17-year-old high school student, is accidentally sent thirty years into the past in a time-traveling DeLorean invented by his close friend, eccentric scientist Doc Brown.&quot;,
    genres: [&quot;Adventure&quot;, &quot;Comedy&quot;, &quot;Sci-Fi&quot;],
    actors: [{ name: &quot;Michael J. Fox&quot; }, { name: &quot;Christopher Lloyd&quot; }]
  },
  {
    title: &quot;Gladiator&quot;,
    ratingScores: [{ provider: &quot;IMDb&quot;, score: &quot;8.5&quot; }, { provider: &quot;Rotten Tomatoes&quot;, score: &quot;77%&quot; }],
    status: &quot;OK&quot;,
    runtime: &quot;155 minutes&quot;,
    language: &quot;English&quot;,
    year: 2000,
    summary: &quot;A former Roman General sets out to exact vengeance against the corrupt emperor who murdered his family and sent him into slavery.&quot;,
    genres: [&quot;Action&quot;, &quot;Adventure&quot;, &quot;Drama&quot;],
    actors: [{ name: &quot;Russell Crowe&quot; }, { name: &quot;Joaquin Phoenix&quot; }]
  },
  {
    title: &quot;Memento&quot;,
    ratingScores: [{ provider: &quot;IMDb&quot;, score: &quot;8.4&quot; }, { provider: &quot;Rotten Tomatoes&quot;, score: &quot;93%&quot; }],
    status: &quot;OK&quot;,
    runtime: &quot;113 minutes&quot;,
    language: &quot;English&quot;,
    year: 2000,
    summary: &quot;A man with short-term memory loss attempts to track down his wife&apos;s murderer.&quot;,
    genres: [&quot;Mystery&quot;, &quot;Thriller&quot;],
    actors: [{ name: &quot;Guy Pearce&quot; }, { name: &quot;Carrie-Anne Moss&quot; }]
  },
  {
    title: &quot;The Departed&quot;,
    ratingScores: [{ provider: &quot;IMDb&quot;, score: &quot;8.5&quot; }, { provider: &quot;Rotten Tomatoes&quot;, score: &quot;90%&quot; }],
    status: &quot;OK&quot;,
    runtime: &quot;151 minutes&quot;,
    language: &quot;English&quot;,
    year: 2006,
    summary: &quot;An undercover cop and a mole in the police attempt to identify each other while infiltrating an Irish gang in South Boston.&quot;,
    genres: [&quot;Crime&quot;, &quot;Drama&quot;, &quot;Thriller&quot;],
    actors: [{ name: &quot;Leonardo DiCaprio&quot; }, { name: &quot;Matt Damon&quot; }]
  },
  {
    title: &quot;American History X&quot;,
    ratingScores: [{ provider: &quot;IMDb&quot;, score: &quot;8.5&quot; }, { provider: &quot;Rotten Tomatoes&quot;, score: &quot;83%&quot; }],
    status: &quot;OK&quot;,
    runtime: &quot;119 minutes&quot;,
    language: &quot;English&quot;,
    year: 1998,
    summary: &quot;A former neo-nazi skinhead tries to prevent his younger brother from going down the same wrong path that he did.&quot;,
    genres: [&quot;Drama&quot;],
    actors: [{ name: &quot;Edward Norton&quot; }, { name: &quot;Edward Furlong&quot; }]
  },
  {
    title: &quot;Psycho&quot;,
    ratingScores: [{ provider: &quot;IMDb&quot;, score: &quot;8.5&quot; }, { provider: &quot;Rotten Tomatoes&quot;, score: &quot;96%&quot; }],
    status: &quot;OK&quot;,
    runtime: &quot;109 minutes&quot;,
    language: &quot;English&quot;,
    year: 1960,
    summary: &quot;A Phoenix secretary embezzles $40,000 from her employer&apos;s client, goes on the run, and checks into a remote motel run by a young man under the domination of his mother.&quot;,
    genres: [&quot;Horror&quot;, &quot;Mystery&quot;, &quot;Thriller&quot;],
    actors: [{ name: &quot;Anthony Perkins&quot; }, { name: &quot;Janet Leigh&quot; }]
  },
  {
    title: &quot;The Incredibles&quot;,
    ratingScores: [{ provider: &quot;IMDb&quot;, score: &quot;8.0&quot; }, { provider: &quot;Rotten Tomatoes&quot;, score: &quot;97%&quot; }],
    status: &quot;OK&quot;,
    runtime: &quot;115 minutes&quot;,
    language: &quot;English&quot;,
    year: 2004,
    summary: &quot;A family of undercover superheroes, while trying to live the quiet suburban life, are forced into action to save the world.&quot;,
    genres: [&quot;Animation&quot;, &quot;Action&quot;, &quot;Adventure&quot;],
    actors: [{ name: &quot;Craig T. Nelson&quot; }, { name: &quot;Holly Hunter&quot; }]
  },
  {
    title: &quot;Up&quot;,
    ratingScores: [{ provider: &quot;IMDb&quot;, score: &quot;8.2&quot; }, { provider: &quot;Rotten Tomatoes&quot;, score: &quot;98%&quot; }],
    status: &quot;OK&quot;,
    runtime: &quot;96 minutes&quot;,
    language: &quot;English&quot;,
    year: 2009,
    summary: &quot;78-year-old Carl Fredricksen travels to Paradise Falls in his house equipped with balloons, inadvertently taking a young stowaway.&quot;,
    genres: [&quot;Animation&quot;, &quot;Adventure&quot;, &quot;Drama&quot;],
    actors: [{ name: &quot;Edward Asner&quot; }, { name: &quot;Jordan Nagai&quot; }]
  },
  {
    title: &quot;Coco&quot;,
    ratingScores: [{ provider: &quot;IMDb&quot;, score: &quot;8.4&quot; }, { provider: &quot;Rotten Tomatoes&quot;, score: &quot;97%&quot; }],
    status: &quot;OK&quot;,
    runtime: &quot;105 minutes&quot;,
    language: &quot;English&quot;,
    year: 2017,
    summary: &quot;Aspiring musician Miguel, confronted with his family&apos;s ancestral ban on music, enters the Land of the Dead to find his great-great-grandfather, a legendary singer.&quot;,
    genres: [&quot;Animation&quot;, &quot;Adventure&quot;, &quot;Family&quot;],
    actors: [{ name: &quot;Anthony Gonzalez&quot; }, { name: &quot;Gael García Bernal&quot; }]
  },
  {
    title: &quot;La La Land&quot;,
    ratingScores: [{ provider: &quot;IMDb&quot;, score: &quot;8.0&quot; }, { provider: &quot;Rotten Tomatoes&quot;, score: &quot;91%&quot; }],
    status: &quot;OK&quot;,
    runtime: &quot;128 minutes&quot;,
    language: &quot;English&quot;,
    year: 2016,
    summary: &quot;While navigating their careers in Los Angeles, a pianist and an actress fall in love while attempting to reconcile their aspirations for the future.&quot;,
    genres: [&quot;Comedy&quot;, &quot;Drama&quot;, &quot;Music&quot;],
    actors: [{ name: &quot;Ryan Gosling&quot; }, { name: &quot;Emma Stone&quot; }]
  },
  {
    title: &quot;Inside Out&quot;,
    ratingScores: [{ provider: &quot;IMDb&quot;, score: &quot;8.1&quot; }, { provider: &quot;Rotten Tomatoes&quot;, score: &quot;98%&quot; }],
    status: &quot;OK&quot;,
    runtime: &quot;95 minutes&quot;,
    language: &quot;English&quot;,
    year: 2015,
    summary: &quot;After young Riley is uprooted from her Midwest life and moved to San Francisco, her emotions - Joy, Fear, Anger, Disgust, and Sadness - conflict on how best to navigate a new city, house, and school.&quot;,
    genres: [&quot;Animation&quot;, &quot;Adventure&quot;, &quot;Comedy&quot;],
    actors: [{ name: &quot;Amy Poehler&quot; }, { name: &quot;Bill Hader&quot; }]
  },
  {
    title: &quot;Toy Story&quot;,
    ratingScores: [{ provider: &quot;IMDb&quot;, score: &quot;8.3&quot; }, { provider: &quot;Rotten Tomatoes&quot;, score: &quot;100%&quot; }],
    status: &quot;OK&quot;,
    runtime: &quot;81 minutes&quot;,
    language: &quot;English&quot;,
    year: 1995,
    summary: &quot;A cowboy doll is profoundly threatened and jealous when a new spaceman action figure supplants him as top toy in a boy&apos;s bedroom.&quot;,
    genres: [&quot;Animation&quot;, &quot;Adventure&quot;, &quot;Comedy&quot;],
    actors: [{ name: &quot;Tom Hanks&quot; }, { name: &quot;Tim Allen&quot; }]
  },
  {
    title: &quot;Shrek&quot;,
    ratingScores: [{ provider: &quot;IMDb&quot;, score: &quot;7.9&quot; }, { provider: &quot;Rotten Tomatoes&quot;, score: &quot;88%&quot; }],
    status: &quot;OK&quot;,
    runtime: &quot;90 minutes&quot;,
    language: &quot;English&quot;,
    year: 2001,
    summary: &quot;A mean lord exiles fairytale creatures to the swamp of a grumpy ogre, who must go on a quest and rescue a princess for the lord in order to get his land back.&quot;,
    genres: [&quot;Animation&quot;, &quot;Adventure&quot;, &quot;Comedy&quot;],
    actors: [{ name: &quot;Mike Myers&quot; }, { name: &quot;Eddie Murphy&quot; }]
  },
  {
    title: &quot;The Bourne Identity&quot;,
    ratingScores: [{ provider: &quot;IMDb&quot;, score: &quot;7.9&quot; }, { provider: &quot;Rotten Tomatoes&quot;, score: &quot;83%&quot; }],
    status: &quot;OK&quot;,
    runtime: &quot;119 minutes&quot;,
    language: &quot;English&quot;,
    year: 2002,
    summary: &quot;A man is picked up by a fishing boat, bullet-riddled and suffering from amnesia, before racing to elude assassins and regain his memory.&quot;,
    genres: [&quot;Action&quot;, &quot;Mystery&quot;, &quot;Thriller&quot;],
    actors: [{ name: &quot;Matt Damon&quot; }, { name: &quot;Franka Potente&quot; }]
  },
  {
    title: &quot;Gone Girl&quot;,
    ratingScores: [{ provider: &quot;IMDb&quot;, score: &quot;8.1&quot; }, { provider: &quot;Rotten Tomatoes&quot;, score: &quot;87%&quot; }],
    status: &quot;OK&quot;,
    runtime: &quot;149 minutes&quot;,
    language: &quot;English&quot;,
    year: 2014,
    summary: &quot;With his wife&apos;s disappearance having become the focus of an intense media circus, a man sees the spotlight turned on him when it&apos;s suspected that he may not be innocent.&quot;,
    genres: [&quot;Drama&quot;, &quot;Mystery&quot;, &quot;Thriller&quot;],
    actors: [{ name: &quot;Ben Affleck&quot; }, { name: &quot;Rosamund Pike&quot; }]
  },
  {
    title: &quot;The Social Network&quot;,
    ratingScores: [{ provider: &quot;IMDb&quot;, score: &quot;7.7&quot; }, { provider: &quot;Rotten Tomatoes&quot;, score: &quot;96%&quot; }],
    status: &quot;OK&quot;,
    runtime: &quot;120 minutes&quot;,
    language: &quot;English&quot;,
    year: 2010,
    summary: &quot;As Harvard student Mark Zuckerberg creates the social networking site that would become known as Facebook, he is sued by the twins who claimed he stole their idea, and by the co-founder who was later squeezed out of the business.&quot;,
    genres: [&quot;Biography&quot;, &quot;Drama&quot;],
    actors: [{ name: &quot;Jesse Eisenberg&quot; }, { name: &quot;Andrew Garfield&quot; }]
  },
  {
    title: &quot;The Grand Budapest Hotel&quot;,
    ratingScores: [{ provider: &quot;IMDb&quot;, score: &quot;8.1&quot; }, { provider: &quot;Rotten Tomatoes&quot;, score: &quot;91%&quot; }],
    status: &quot;OK&quot;,
    runtime: &quot;99 minutes&quot;,
    language: &quot;English&quot;,
    year: 2014,
    summary: &quot;A writer encounters the owner of an aging high-class hotel, who tells him of his early years serving as a lobby boy in the hotel&apos;s glorious years under an exceptional concierge.&quot;,
    genres: [&quot;Adventure&quot;, &quot;Comedy&quot;, &quot;Crime&quot;],
    actors: [{ name: &quot;Ralph Fiennes&quot; }, { name: &quot;F. Murray Abraham&quot; }]
  },
  {
    title: &quot;Mad Max: Fury Road&quot;,
    ratingScores: [{ provider: &quot;IMDb&quot;, score: &quot;8.1&quot; }, { provider: &quot;Rotten Tomatoes&quot;, score: &quot;97%&quot; }],
    status: &quot;OK&quot;,
    runtime: &quot;120 minutes&quot;,
    language: &quot;English&quot;,
    year: 2015,
    summary: &quot;In a post-apocalyptic wasteland, Max helps a rebellious woman and a group of female prisoners escape from an oppressive warlord and his army in an armored tanker truck.&quot;,
    genres: [&quot;Action&quot;, &quot;Adventure&quot;, &quot;Sci-Fi&quot;],
    actors: [{ name: &quot;Tom Hardy&quot; }, { name: &quot;Charlize Theron&quot; }]
  },
  {
    title: &quot;The Wolf of Wall Street&quot;,
    ratingScores: [{ provider: &quot;IMDb&quot;, score: &quot;8.2&quot; }, { provider: &quot;Rotten Tomatoes&quot;, score: &quot;79%&quot; }],
    status: &quot;OK&quot;,
    runtime: &quot;180 minutes&quot;,
    language: &quot;English&quot;,
    year: 2013,
    summary: &quot;Based on the true story of Jordan Belfort, from his rise to a wealthy stock-broker living the high life to his fall involving crime, corruption, and the federal government.&quot;,
    genres: [&quot;Biography&quot;, &quot;Crime&quot;, &quot;Drama&quot;],
    actors: [{ name: &quot;Leonardo DiCaprio&quot; }, { name: &quot;Jonah Hill&quot; }]
  },
  {
    title: &quot;The Hateful Eight&quot;,
    ratingScores: [{ provider: &quot;IMDb&quot;, score: &quot;7.8&quot; }, { provider: &quot;Rotten Tomatoes&quot;, score: &quot;75%&quot; }],
    status: &quot;OK&quot;,
    runtime: &quot;168 minutes&quot;,
    language: &quot;English&quot;,
    year: 2015,
    summary: &quot;In the dead of a Wyoming winter, a bounty hunter and his prisoner find shelter in a cabin currently inhabited by a collection of nefarious characters.&quot;,
    genres: [&quot;Crime&quot;, &quot;Drama&quot;, &quot;Mystery&quot;],
    actors: [{ name: &quot;Samuel L. Jackson&quot; }, { name: &quot;Kurt Russell&quot; }]
  },
  {
    title: &quot;Birdman&quot;,
    ratingScores: [{ provider: &quot;IMDb&quot;, score: &quot;7.7&quot; }, { provider: &quot;Rotten Tomatoes&quot;, score: &quot;91%&quot; }],
    status: &quot;OK&quot;,
    runtime: &quot;119 minutes&quot;,
    language: &quot;English&quot;,
    year: 2014,
    summary: &quot;A washed-up superhero actor attempts to revive his fading career by writing, directing, and starring in a Broadway production.&quot;,
    genres: [&quot;Comedy&quot;, &quot;Drama&quot;],
    actors: [{ name: &quot;Michael Keaton&quot; }, { name: &quot;Zach Galifianakis&quot; }]
  },
  {
    title: &quot;12 Years a Slave&quot;,
    ratingScores: [{ provider: &quot;IMDb&quot;, score: &quot;8.1&quot; }, { provider: &quot;Rotten Tomatoes&quot;, score: &quot;95%&quot; }],
    status: &quot;OK&quot;,
    runtime: &quot;134 minutes&quot;,
    language: &quot;English&quot;,
    year: 2013,
    summary: &quot;In the antebellum United States, Solomon Northup, a free black man from upstate New York, is abducted and sold into slavery.&quot;,
    genres: [&quot;Biography&quot;, &quot;Drama&quot;, &quot;History&quot;],
    actors: [{ name: &quot;Chiwetel Ejiofor&quot; }, { name: &quot;Michael Kenneth Williams&quot; }]
  },
  {
    title: &quot;Django Unchained&quot;,
    ratingScores: [{ provider: &quot;IMDb&quot;, score: &quot;8.4&quot; }, { provider: &quot;Rotten Tomatoes&quot;, score: &quot;87%&quot; }],
    status: &quot;OK&quot;,
    runtime: &quot;165 minutes&quot;,
    language: &quot;English&quot;,
    year: 2012,
    summary: &quot;With the help of a German bounty-hunter, a freed slave sets out to rescue his wife from a brutal plantation-owner in Mississippi.&quot;,
    genres: [&quot;Drama&quot;, &quot;Western&quot;],
    actors: [{ name: &quot;Jamie Foxx&quot; }, { name: &quot;Christoph Waltz&quot; }]
  },
  {
    title: &quot;Moonlight&quot;,
    ratingScores: [{ provider: &quot;IMDb&quot;, score: &quot;7.4&quot; }, { provider: &quot;Rotten Tomatoes&quot;, score: &quot;98%&quot; }],
    status: &quot;OK&quot;,
    runtime: &quot;111 minutes&quot;,
    language: &quot;English&quot;,
    year: 2016,
    summary: &quot;A young African-American man grapples with his identity and sexuality while experiencing the everyday struggles of childhood, adolescence, and burgeoning adulthood.&quot;,
    genres: [&quot;Drama&quot;],
    actors: [{ name: &quot;Mahershala Ali&quot; }, { name: &quot;Naomie Harris&quot; }]
  },
  {
    title: &quot;Spotlight&quot;,
    ratingScores: [{ provider: &quot;IMDb&quot;, score: &quot;8.1&quot; }, { provider: &quot;Rotten Tomatoes&quot;, score: &quot;97%&quot; }],
    status: &quot;OK&quot;,
    runtime: &quot;129 minutes&quot;,
    language: &quot;English&quot;,
    year: 2015,
    summary: &quot;The true story of how the Boston Globe uncovered the massive scandal of child molestation and cover-up within the local Catholic Archdiocese, shaking the entire Catholic Church to its core.&quot;,
    genres: [&quot;Biography&quot;, &quot;Crime&quot;, &quot;Drama&quot;],
    actors: [{ name: &quot;Mark Ruffalo&quot; }, { name: &quot;Michael Keaton&quot; }]
  },
  {
    title: &quot;Argo&quot;,
    ratingScores: [{ provider: &quot;IMDb&quot;, score: &quot;7.7&quot; }, { provider: &quot;Rotten Tomatoes&quot;, score: &quot;96%&quot; }],
    status: &quot;OK&quot;,
    runtime: &quot;120 minutes&quot;,
    language: &quot;English&quot;,
    year: 2012,
    summary: &quot;Acting under the cover of a Hollywood producer scouting a location for a science fiction film, a CIA agent launches a dangerous operation to rescue six Americans in Tehran during the U.S. hostage crisis in Iran in 1979.&quot;,
    genres: [&quot;Biography&quot;, &quot;Drama&quot;, &quot;Thriller&quot;],
    actors: [{ name: &quot;Ben Affleck&quot; }, { name: &quot;Bryan Cranston&quot; }]
  },
  {
    title: &quot;The Revenant&quot;,
    ratingScores: [{ provider: &quot;IMDb&quot;, score: &quot;8.0&quot; }, { provider: &quot;Rotten Tomatoes&quot;, score: &quot;78%&quot; }],
    status: &quot;OK&quot;,
    runtime: &quot;156 minutes&quot;,
    language: &quot;English&quot;,
    year: 2015,
    summary: &quot;A frontiersman on a fur trading expedition in the 1820s fights for survival after being mauled by a bear and left for dead by members of his own hunting team.&quot;,
    genres: [&quot;Action&quot;, &quot;Adventure&quot;, &quot;Drama&quot;],
    actors: [{ name: &quot;Leonardo DiCaprio&quot; }, { name: &quot;Tom Hardy&quot; }]
  },
  {
    title: &quot;Slumdog Millionaire&quot;,
    ratingScores: [{ provider: &quot;IMDb&quot;, score: &quot;8.0&quot; }, { provider: &quot;Rotten Tomatoes&quot;, score: &quot;91%&quot; }],
    status: &quot;OK&quot;,
    runtime: &quot;120 minutes&quot;,
    language: &quot;English&quot;,
    year: 2008,
    summary: &quot;A Mumbai teenager reflects on his life after being accused of cheating on the Indian version of &apos;Who Wants to Be a Millionaire?&apos;.&quot;,
    genres: [&quot;Drama&quot;, &quot;Romance&quot;],
    actors: [{ name: &quot;Dev Patel&quot; }, { name: &quot;Freida Pinto&quot; }]
  },
  {
    title: &quot;The Artist&quot;,
    ratingScores: [{ provider: &quot;IMDb&quot;, score: &quot;7.9&quot; }, { provider: &quot;Rotten Tomatoes&quot;, score: &quot;95%&quot; }],
    status: &quot;OK&quot;,
    runtime: &quot;100 minutes&quot;,
    language: &quot;English&quot;,
    year: 2011,
    summary: &quot;An egomaniacal film star develops a relationship with a young dancer against the backdrop of Hollywood&apos;s silent era.&quot;,
    genres: [&quot;Comedy&quot;, &quot;Drama&quot;, &quot;Romance&quot;],
    actors: [{ name: &quot;Jean Dujardin&quot; }, { name: &quot;Bérénice Bejo&quot; }]
  },
  {
    title: &quot;Hacksaw Ridge&quot;,
    ratingScores: [{ provider: &quot;IMDb&quot;, score: &quot;8.1&quot; }, { provider: &quot;Rotten Tomatoes&quot;, score: &quot;85%&quot; }],
    status: &quot;OK&quot;,
    runtime: &quot;139 minutes&quot;,
    language: &quot;English&quot;,
    year: 2016,
    summary: &quot;World War II American Army Medic Desmond T. Doss, who served during the Battle of Okinawa, refuses to kill people, and becomes the first man in American history to receive the Medal of Honor without firing a shot.&quot;,
    genres: [&quot;Biography&quot;, &quot;Drama&quot;, &quot;History&quot;],
    actors: [{ name: &quot;Andrew Garfield&quot; }, { name: &quot;Sam Worthington&quot; }]
  },
  {
    title: &quot;Her&quot;,
    ratingScores: [{ provider: &quot;IMDb&quot;, score: &quot;8.0&quot; }, { provider: &quot;Rotten Tomatoes&quot;, score: &quot;94%&quot; }],
    status: &quot;OK&quot;,
    runtime: &quot;126 minutes&quot;,
    language: &quot;English&quot;,
    year: 2013,
    summary: &quot;In a near future, a lonely writer develops an unlikely relationship with an operating system designed to meet his every need.&quot;,
    genres: [&quot;Drama&quot;, &quot;Romance&quot;, &quot;Sci-Fi&quot;],
    actors: [{ name: &quot;Joaquin Phoenix&quot; }, { name: &quot;Amy Adams&quot; }]
  },
];</file><file path="resources/app/modules/library-movies/modes.ts">export interface MovieResource {
  title: string;
  ratingScores: RatingScore[];
  status: &apos;OK&apos; | &apos;SCANNING&apos; | &apos;PATH_NOT_FOUND&apos;;
  runtime?: string;
  language?: string;
  poster?: string;
  year?: number;
  summary?: string;
  genres?: string[];
  actors?: Person[];
}
export interface RatingScore {
  provider: string;
  score: string;
}
export interface Person {
  name: string;
  image?: string;
}</file><file path="resources/app/modules/library-music-player/components/player-buttons/player-buttons.tsx">import React from &apos;react&apos;;
import { Icon } from &apos;@iconify/react&apos;;
import styles from &apos;./player-controls.module.scss&apos;;
import { MUSIC_CONTROL_ICON_SIZE } from &apos;@/modules/library-music-player/constants.ts&apos;;
interface BaseControlProps extends React.HTMLAttributes&lt;HTMLButtonElement&gt; {
  iconName: string;
  iconSize?: number;
}
function BaseControl({ iconName, iconSize = MUSIC_CONTROL_ICON_SIZE, ...props }: BaseControlProps) {
  return (
    &lt;button className={styles.playerControl} {...props}&gt;
      &lt;Icon icon={iconName} fontSize={iconSize} className={styles.icon}  /&gt;
    &lt;/button&gt;
  );
}
export interface PlayerControlProps extends Omit&lt;BaseControlProps, &apos;iconName&apos;&gt; {
  onClick: () =&gt; void;
  iconSize?: number;
}
export function NextButton({ onClick }: PlayerControlProps) {
  return &lt;BaseControl iconName=&quot;entypo:controller-next&quot; onClick={onClick}/&gt;;
}
export function PreviousButton({ onClick }: PlayerControlProps) {
  return &lt;BaseControl iconName=&quot;entypo:controller-jump-to-start&quot; onClick={onClick}/&gt;;
}
export interface PlayPauseButtonProps extends PlayerControlProps {
  isPlaying: boolean;
}
export function PlayPauseButton({ onClick, isPlaying, ...props }: PlayPauseButtonProps) {
  return &lt;BaseControl
    iconName={isPlaying ? &apos;entypo:controller-paus&apos; : &apos;entypo:controller-play&apos;}
    iconSize={MUSIC_CONTROL_ICON_SIZE}
    onClick={onClick}
    {...props}
  /&gt;;
}
interface VisualizerButtonProps extends PlayerControlProps {
  isActive?: boolean;
}
export function VisualizerButton({ onClick, isActive, ...props }: VisualizerButtonProps) {
  return &lt;BaseControl
    title={`${isActive ? &apos;Hide&apos; : &apos;Show&apos;} visualizer`}
    iconName={isActive ? &apos;ph:waveform&apos; : &apos;ph:waveform-slash&apos;}
    onClick={onClick}
    {...props}
  /&gt;;
}
interface LyricsButtonProps extends PlayerControlProps {
  isActive?: boolean;
}
export function LyricsButton({ onClick, isActive, ...props }: LyricsButtonProps) {
  return &lt;BaseControl
    title={`${isActive ? &apos;Hide&apos; : &apos;Show&apos;} lyrics`}
    iconName=&quot;maki:karaoke&quot;
    iconSize={MUSIC_CONTROL_ICON_SIZE}
    onClick={onClick}
    {...props}
  /&gt;;
}</file><file path="resources/app/modules/library-music-player/components/player-controls/player-controls.tsx">import {
  NextButton,
  PlayPauseButton,
  PreviousButton,
} from &apos;@/modules/library-music-player/components/player-buttons/player-buttons.tsx&apos;;
import { useAppDispatch } from &apos;@/store/hooks.ts&apos;;
import { playNextSong, playPreviousSong } from &apos;@/store/music/music-player-slice.ts&apos;;
import styles from &apos;./player-controls.module.scss&apos;;
export interface PlayerControlsProps {
  isPlaying: boolean;
  togglePlayPause: () =&gt; void;
}
export function PlayerControls({ isPlaying, togglePlayPause }: PlayerControlsProps) {
  const dispatch = useAppDispatch();
  const onPlayNextSong = () =&gt; {
    dispatch(playNextSong());
  }
  const onPlayPreviousSong = () =&gt; {
    dispatch(playPreviousSong());
  }
  return (
    &lt;div className={styles.playerControls}&gt;
      &lt;PreviousButton onClick={() =&gt; onPlayPreviousSong()}/&gt;
      &lt;PlayPauseButton
        isPlaying={isPlaying}
        onClick={() =&gt; togglePlayPause()}
      /&gt;
      &lt;NextButton onClick={() =&gt; onPlayNextSong()}/&gt;
    &lt;/div&gt;
  )
}</file><file path="resources/app/modules/library-music-player/components/progress-bar/progress-bar.module.css">.Root {
    position: relative;
    display: flex;
    align-items: center;
    user-select: none;
    touch-action: none;
    width: inherit;
    height: 20px;
}
.Track {
    background-color: var(--gray-4);
    position: relative;
    flex-grow: 1;
    border-radius: 9999px;
    height: 3px;
}
.RangeBuffer {
    position: absolute;
    background-color: var(--red-track-secondary);
    border-radius: 9999px;
    height: 100%;
}
.RangeProgress {
    background-color: var(--red-track);
    position: absolute;
    border-radius: 9999px;
    height: 100%;
}
.Thumb {
    cursor: pointer;
    display: block;
    width: 12px;
    height: 12px;
    background-color: var(--gray-2);
    box-shadow: 0 2px 8px var(--black-a6);
    border-radius: 7px;
    touch-action: cross-slide-x;
    &amp;:hover {
        background-color: var(--violet-3);
    }
    &amp;:focus {
        outline: none;
        box-shadow: 0 0 0 5px var(--black-a8);
    }
}</file><file path="resources/app/modules/library-music-player/constants.ts">export const MUSIC_CONTROL_ICON_SIZE = 26;</file><file path="resources/app/modules/library-music-playlists/_routes.tsx">import { Route, Routes } from &apos;react-router-dom&apos;;
import { PlayList } from &apos;@/modules/library-music-playlists/playlist/playlist.tsx&apos;;
export const LibraryMusicPlaylistsRoutes = () =&gt; {
  return (
    &lt;Routes&gt;
      &lt;Route path=&quot;/:playlistId&quot; element={&lt;PlayList /&gt;} /&gt;
    &lt;/Routes&gt;
  )
}
export interface MusicPlaylistParams {
  playlistId: string;
}</file><file path="resources/app/modules/library-music-playlists/components/context-menu/playlist-layout-context-menu/playlist-layout-context-menu.tsx">import { ContextMenu } from &apos;@radix-ui/themes&apos;;
import { usePlaylistServiceDeleteApiPlaylistsByPlaylist } from &apos;@/api-client/queries&apos;;
export interface PlaylistLayoutContextMenuProps {
  id: string;
}
export function PlaylistLayoutContextMenu({id}: PlaylistLayoutContextMenuProps) {
  const deleteMutation = usePlaylistServiceDeleteApiPlaylistsByPlaylist({
  });
  const handleDelete = () =&gt; {
    deleteMutation.mutate({
      playlist: id,
    })
  }
  return (
    &lt;ContextMenu.Content&gt;
      &lt;ContextMenu.Item&gt;Play&lt;/ContextMenu.Item&gt;
      &lt;ContextMenu.Item&gt;Shuffle&lt;/ContextMenu.Item&gt;
      &lt;ContextMenu.Item&gt;Play Next&lt;/ContextMenu.Item&gt;
      &lt;ContextMenu.Item&gt;Play Later&lt;/ContextMenu.Item&gt;
      &lt;ContextMenu.Separator /&gt;
      &lt;ContextMenu.Item&gt;Duplicate&lt;/ContextMenu.Item&gt;
      &lt;ContextMenu.Separator /&gt;
      &lt;ContextMenu.Item onClick={() =&gt; handleDelete()}&gt;Delete&lt;/ContextMenu.Item&gt;
    &lt;/ContextMenu.Content&gt;
  )
}</file><file path="resources/app/modules/library-music-playlists/components/create-playlist/create-playlist.module.scss">.container {
  max-width: 800px;
  margin: 0 auto;
  padding: 20px;
}
.title {
  margin-bottom: 20px;
}
.formGroup {
  margin-bottom: 20px;
}
.label {
  display: block;
  margin-bottom: 5px;
  font-weight: bold;
}
.input {
  width: 100%;
  padding: 8px;
  border: 1px solid #ccc;
  border-radius: 4px;
}
.error {
  color: red;
  font-size: 0.8rem;
  margin-top: 5px;
}
.submitButton {
  margin-top: 20px;
}</file><file path="resources/app/modules/library-music-playlists/components/create-playlist/create-playlist.tsx">import { Button, Flex, Switch, Text, TextField } from &apos;@radix-ui/themes&apos;;
import { useForm, Controller } from &apos;react-hook-form&apos;;
import { useState } from &apos;react&apos;;
import styles from &apos;./create-playlist.module.scss&apos;;
interface PlaylistForm {
  name: string;
  description: string;
  is_public: boolean;
}
export function CreatePlaylist() {
  const {
    register,
    handleSubmit,
    control,
    formState: { errors, isSubmitting },
  } = useForm&lt;PlaylistForm&gt;({
    defaultValues: {
      name: &apos;&apos;,
      description: &apos;&apos;,
      is_public: false,
    },
  });
  const [error, setError] = useState&lt;string | null&gt;(null);
  const onSubmit = async (data: PlaylistForm) =&gt; {
    try {
      setError(null);
      const response = await fetch(&apos;/api/playlists&apos;, {
        method: &apos;POST&apos;,
        headers: {
          &apos;Content-Type&apos;: &apos;application/json&apos;,
        },
        body: JSON.stringify(data),
      });
      if (!response.ok) {
        const errorData = await response.json();
        throw new Error(errorData.message || &apos;Failed to create playlist&apos;);
      }
      // Handle success - redirect or show success message
      window.location.href = &apos;/library/playlists&apos;;
    } catch (err) {
      setError(err instanceof Error ? err.message : &apos;An unknown error occurred&apos;);
    }
  };
  return (
    &lt;div className={styles.container}&gt;
      &lt;form onSubmit={handleSubmit(onSubmit)}&gt;
        &lt;Flex direction=&quot;column&quot; gap=&quot;4&quot;&gt;
          {error &amp;&amp; (
            &lt;Text color=&quot;red&quot; size=&quot;2&quot; className={styles.error}&gt;
              {error}
            &lt;/Text&gt;
          )}
          &lt;Flex direction=&quot;column&quot; gap=&quot;3&quot;&gt;
            &lt;div className={styles.formGroup}&gt;
              &lt;label className={styles.label}&gt;
                &lt;Text as=&quot;div&quot; size=&quot;2&quot; mb=&quot;1&quot; weight=&quot;bold&quot; className={styles.title}&gt;
                  Name
                &lt;/Text&gt;
                &lt;TextField.Root
                  data-1p-ignore
                  placeholder=&quot;Playlist name&quot;
                  className={styles.input}
                  {...register(&apos;name&apos;, { required: &apos;Name is required&apos; })}
                /&gt;
                {errors.name &amp;&amp; (
                  &lt;Text color=&quot;red&quot; size=&quot;1&quot; className={styles.error}&gt;
                    {errors.name.message}
                  &lt;/Text&gt;
                )}
              &lt;/label&gt;
            &lt;/div&gt;
            &lt;div className={styles.formGroup}&gt;
              &lt;label className={styles.label}&gt;
                &lt;Text as=&quot;div&quot; size=&quot;2&quot; mb=&quot;1&quot; weight=&quot;bold&quot; className={styles.title}&gt;
                  Description
                &lt;/Text&gt;
                &lt;TextField.Root
                  data-1p-ignore
                  placeholder=&quot;Optional description&quot;
                  className={styles.input}
                  {...register(&apos;description&apos;)}
                /&gt;
              &lt;/label&gt;
            &lt;/div&gt;
            &lt;div className={styles.formGroup}&gt;
              &lt;label className={styles.label}&gt;
                &lt;Flex align=&quot;center&quot; gap=&quot;2&quot;&gt;
                  &lt;Text as=&quot;div&quot; size=&quot;2&quot; weight=&quot;bold&quot; className={styles.title}&gt;
                    Public
                  &lt;/Text&gt;
                  &lt;Controller
                    name=&quot;is_public&quot;
                    control={control}
                    render={({ field }) =&gt; (
                      &lt;Switch
                        checked={field.value}
                        onCheckedChange={field.onChange}
                      /&gt;
                    )}
                  /&gt;
                &lt;/Flex&gt;
              &lt;/label&gt;
            &lt;/div&gt;
          &lt;/Flex&gt;
          &lt;Flex justify=&quot;end&quot; mt=&quot;4&quot; className={styles.submitButton}&gt;
            &lt;Button type=&quot;submit&quot; disabled={isSubmitting}&gt;
              {isSubmitting ? &apos;Creating...&apos; : &apos;Create Playlist&apos;}
            &lt;/Button&gt;
          &lt;/Flex&gt;
        &lt;/Flex&gt;
      &lt;/form&gt;
    &lt;/div&gt;
  );
}</file><file path="resources/app/modules/library-music-playlists/components/create-smart-playlist/create-smart-playlist.module.scss">.container {
  max-width: 800px;
  margin: 0 auto;
  padding: 1.5rem;
}
.formGroup {
  margin-bottom: 1rem;
}
.label {
  display: block;
  width: 100%;
}
.title {
  display: block;
  margin-bottom: 0.5rem;
}
.input {
  width: 100%;
}
.error {
  margin-top: 0.25rem;
}
.submitButton {
  margin-top: 1rem;
}</file><file path="resources/app/modules/library-music-playlists/components/create-smart-playlist/create-smart-playlist.tsx">import { Button, Flex, Switch, Text, TextField } from &apos;@radix-ui/themes&apos;;
import { useForm, Controller } from &apos;react-hook-form&apos;;
import { useState } from &apos;react&apos;;
import { PlaylistService } from &apos;../../../../api-client/requests/services.gen&apos;;
import { SmartPlaylistRuleEditor } from &apos;../smart-playlist-rule-editor/smart-playlist-rule-editor&apos;;
import styles from &apos;./create-smart-playlist.module.scss&apos;;
interface SmartPlaylistForm {
  name: string;
  description: string;
  is_public: boolean;
  ruleGroups: Array&lt;Array&lt;{
    field: string;
    operator: string;
    value: string;
    maxValue?: string;
  }&gt;&gt;;
}
export function CreateSmartPlaylist() {
  const {
    register,
    handleSubmit,
    control,
    formState: { errors, isSubmitting },
    watch,
  } = useForm&lt;SmartPlaylistForm&gt;({
    defaultValues: {
      name: &apos;&apos;,
      description: &apos;&apos;,
      is_public: false,
      ruleGroups: [[{ field: &apos;genre&apos;, operator: &apos;is&apos;, value: &apos;&apos;, maxValue: &apos;&apos; }]],
    },
  });
  // Watch the ruleGroups field to validate it has at least one rule
  const ruleGroups = watch(&apos;ruleGroups.0&apos;);
  const [error, setError] = useState&lt;string | null&gt;(null);
  const onSubmit = async (data: SmartPlaylistForm) =&gt; {
    try {
      setError(null);
      // Validate that at least one rule is defined
      if (data.ruleGroups.length === 0 || data.ruleGroups[0].length === 0) {
        setError(&apos;At least one rule is required&apos;);
        return;
      }
      // Transform the data to match the API&apos;s expected format
      // Since we only have one group now, we&apos;ll just use that
      const apiData = {
        ...data,
        rules: [data.ruleGroups[0]] // The API expects &apos;rules&apos; as an array with a single group
      };
      await PlaylistService.postApiPlaylistsSmart({
        requestBody: apiData,
      });
      // Handle success - redirect or show success message
      window.location.href = &apos;/library/playlists&apos;;
    } catch (err: any) {
      if (err.status === 422 &amp;&amp; err.body?.errors) {
        // Handle validation errors
        const validationErrors = err.body.errors;
        const errorMessages = Object.values(validationErrors).flat();
        setError(errorMessages.join(&apos;, &apos;));
      } else {
        setError(err.body?.message || &apos;Failed to create smart playlist&apos;);
      }
    }
  };
  return (
    &lt;div className={styles.container}&gt;
      &lt;form onSubmit={handleSubmit(onSubmit)}&gt;
        &lt;Flex direction=&quot;column&quot; gap=&quot;4&quot;&gt;
          {error &amp;&amp; (
            &lt;Text color=&quot;red&quot; size=&quot;2&quot; className={styles.error}&gt;
              {error}
            &lt;/Text&gt;
          )}
          &lt;Flex direction=&quot;column&quot; gap=&quot;3&quot;&gt;
            &lt;div className={styles.formGroup}&gt;
              &lt;label className={styles.label}&gt;
                &lt;Text as=&quot;div&quot; size=&quot;2&quot; mb=&quot;1&quot; weight=&quot;bold&quot; className={styles.title}&gt;
                  Name
                &lt;/Text&gt;
                &lt;TextField.Root
                  data-1p-ignore
                  placeholder=&quot;Playlist name&quot;
                  className={styles.input}
                  {...register(&apos;name&apos;, { 
                    required: &apos;Name is required&apos;,
                    maxLength: { value: 255, message: &apos;Name must be at most 255 characters&apos; }
                  })}
                /&gt;
                {errors.name &amp;&amp; (
                  &lt;Text color=&quot;red&quot; size=&quot;1&quot; className={styles.error}&gt;
                    {errors.name.message}
                  &lt;/Text&gt;
                )}
              &lt;/label&gt;
            &lt;/div&gt;
            &lt;div className={styles.formGroup}&gt;
              &lt;label className={styles.label}&gt;
                &lt;Text as=&quot;div&quot; size=&quot;2&quot; mb=&quot;1&quot; weight=&quot;bold&quot; className={styles.title}&gt;
                  Description
                &lt;/Text&gt;
                &lt;TextField.Root
                  data-1p-ignore
                  placeholder=&quot;Optional description&quot;
                  className={styles.input}
                  {...register(&apos;description&apos;)}
                /&gt;
              &lt;/label&gt;
            &lt;/div&gt;
            &lt;div className={styles.formGroup}&gt;
              &lt;label className={styles.label}&gt;
                &lt;Flex align=&quot;center&quot; gap=&quot;2&quot;&gt;
                  &lt;Text as=&quot;div&quot; size=&quot;2&quot; weight=&quot;bold&quot; className={styles.title}&gt;
                    Public
                  &lt;/Text&gt;
                  &lt;Controller
                    name=&quot;is_public&quot;
                    control={control}
                    render={({ field }) =&gt; (
                      &lt;Switch
                        checked={field.value}
                        onCheckedChange={field.onChange}
                      /&gt;
                    )}
                  /&gt;
                &lt;/Flex&gt;
              &lt;/label&gt;
            &lt;/div&gt;
            &lt;div className={styles.formGroup}&gt;
              &lt;Text as=&quot;div&quot; size=&quot;2&quot; mb=&quot;1&quot; weight=&quot;bold&quot; className={styles.title}&gt;
                Rules
              &lt;/Text&gt;
              &lt;SmartPlaylistRuleEditor 
                control={control} 
                name=&quot;ruleGroups&quot; 
                errors={errors.ruleGroups}
              /&gt;
              {errors.ruleGroups &amp;&amp; (
                &lt;Text color=&quot;red&quot; size=&quot;1&quot; className={styles.error}&gt;
                  {errors.ruleGroups.message}
                &lt;/Text&gt;
              )}
              {(!ruleGroups || ruleGroups.length === 0) &amp;&amp; (
                &lt;Text color=&quot;red&quot; size=&quot;1&quot; className={styles.error}&gt;
                  At least one rule is required
                &lt;/Text&gt;
              )}
            &lt;/div&gt;
          &lt;/Flex&gt;
          &lt;Flex justify=&quot;end&quot; mt=&quot;4&quot; className={styles.submitButton}&gt;
            &lt;Button type=&quot;submit&quot; disabled={isSubmitting}&gt;
              {isSubmitting ? &apos;Creating...&apos; : &apos;Create Smart Playlist&apos;}
            &lt;/Button&gt;
          &lt;/Flex&gt;
        &lt;/Flex&gt;
      &lt;/form&gt;
    &lt;/div&gt;
  );
}</file><file path="resources/app/modules/library-music-playlists/components/smart-playlist-rule-editor/smart-playlist-rule-editor.module.scss">.container {
  margin-top: 1rem;
  margin-bottom: 1rem;
}
.ruleGroup {
  background-color: var(--gray-3);
  border-radius: 8px;
  padding: 1rem;
  margin-bottom: 1rem;
}
.ruleGroupTitle {
  margin: 0;
  font-size: 14px;
  font-weight: 500;
}
.ruleList {
  margin-top: 0.5rem;
}
.rule {
  background-color: var(--gray-2);
  border-radius: 6px;
  padding: 0.5rem;
}
.valueInput {
  flex: 1;
  /* Styling for the between operator inputs */
  &amp; &gt; div {
    flex: 1;
  }
}
.emptyState {
  text-align: center;
  color: var(--gray-9);
  padding: 2rem;
  background-color: var(--gray-2);
  border-radius: 8px;
}
.error {
  color: var(--red-9);
  font-size: 12px;
  margin-top: 0.25rem;
}
.valueInput {
  flex: 1;
}
.autocompleteDropdown {
  position: absolute;
  top: 100%;
  left: 0;
  width: 100%;
  background-color: var(--color-panel-solid);
  border-radius: 6px;
  box-shadow: 0 2px 10px rgba(0, 0, 0, 0.3);
  z-index: 10;
  max-height: 200px;
  overflow: auto;
}
.suggestionItem {
  padding: 8px;
  cursor: pointer;
  color: var(--white);
  &amp;:hover {
    background-color: var(--gray-10);
    color: white;
  }
}
.dropDownTrigger {
  cursor: pointer;
}</file><file path="resources/app/modules/library-music-playlists/components/smart-playlist-rule-editor/smart-playlist-rule-editor.tsx">import { Button, Flex, Select, TextField, Box } from &apos;@radix-ui/themes&apos;;
import { useFieldArray, useWatch, Control, Controller, FieldErrors } from &apos;react-hook-form&apos;;
import { PlusIcon, TrashIcon } from &apos;@radix-ui/react-icons&apos;;
import styles from &apos;./smart-playlist-rule-editor.module.scss&apos;;
import { useState, useEffect } from &apos;react&apos;;
import { useGenreServiceGetApiGenres } from &apos;@/api-client/queries&apos;;
import { useArtistServiceGetApiLibrariesByLibraryArtists } from &apos;@/api-client/queries&apos;;
const RULE_FIELDS = [
  { value: &apos;genre&apos;, label: &apos;Genre&apos; },
  { value: &apos;artist&apos;, label: &apos;Artist&apos; },
  { value: &apos;year&apos;, label: &apos;Year&apos; },
  { value: &apos;duration&apos;, label: &apos;Duration&apos; },
];
// Define a type for the valid field values
type FieldType = &apos;genre&apos; | &apos;artist&apos; | &apos;year&apos; | &apos;duration&apos;;
const FIELD_OPERATORS: Record&lt;FieldType, Array&lt;{ value: string; label: string }&gt;&gt; = {
  genre: [
    { value: &apos;is&apos;, label: &apos;Is&apos; },
    { value: &apos;isNot&apos;, label: &apos;Is Not&apos; },
  ],
  artist: [
    { value: &apos;is&apos;, label: &apos;Is&apos; },
    { value: &apos;isNot&apos;, label: &apos;Is Not&apos; },
  ],
  year: [
    { value: &apos;is&apos;, label: &apos;Is&apos; },
    { value: &apos;isNot&apos;, label: &apos;Is Not&apos; },
    { value: &apos;greaterThan&apos;, label: &apos;Greater Than&apos; },
    { value: &apos;lessThan&apos;, label: &apos;Less Than&apos; },
    { value: &apos;between&apos;, label: &apos;Between&apos; },
  ],
  duration: [
    { value: &apos;is&apos;, label: &apos;Is&apos; },
    { value: &apos;isNot&apos;, label: &apos;Is Not&apos; },
    { value: &apos;greaterThan&apos;, label: &apos;Greater Than&apos; },
    { value: &apos;lessThan&apos;, label: &apos;Less Than&apos; },
    { value: &apos;between&apos;, label: &apos;Between&apos; },
  ],
};
export type SmartPlaylistRule = {
  field: FieldType;
  operator: string;
  value: string;
  maxValue?: string; // Optional maxValue for &apos;between&apos; operator
};
// Custom Autocomplete component for genre and artist fields
type AutocompleteFieldProps = {
  placeholder: string;
  value: string;
  onChange: (value: string) =&gt; void;
  suggestions: { slug: string; name: string }[];
  loading: boolean;
};
function AutocompleteField({ placeholder, value, onChange, suggestions, loading }: AutocompleteFieldProps) {
  const [isOpen, setIsOpen] = useState(false);
  const [inputValue, setInputValue] = useState(value);
  const [filteredSuggestions, setFilteredSuggestions] = useState(suggestions);
  useEffect(() =&gt; {
    setInputValue(value);
  }, [value]);
  useEffect(() =&gt; {
    if (inputValue) {
      const filtered = suggestions.filter(item =&gt; 
        item.name.toLowerCase().includes(inputValue.toLowerCase())
      );
      setFilteredSuggestions(filtered);
    } else {
      setFilteredSuggestions(suggestions);
    }
  }, [inputValue, suggestions]);
  const handleInputChange = (e: React.ChangeEvent&lt;HTMLInputElement&gt;) =&gt; {
    const newValue = e.target.value;
    setInputValue(newValue);
    setIsOpen(true);
  };
  const handleSelectSuggestion = (suggestion: { slug: string; name: string }) =&gt; {
    setInputValue(suggestion.name);
    onChange(suggestion.name);
    setIsOpen(false);
  };
  return (
    &lt;Box position=&quot;relative&quot; width=&quot;100%&quot;&gt;
      &lt;TextField.Root
        placeholder={placeholder}
        value={inputValue}
        onChange={handleInputChange}
        onFocus={() =&gt; setIsOpen(true)}
        onBlur={() =&gt; setTimeout(() =&gt; setIsOpen(false), 200)}
      /&gt;
      {isOpen &amp;&amp; filteredSuggestions.length &gt; 0 &amp;&amp; (
        &lt;div className={styles.autocompleteDropdown}&gt;
          {loading ? (
            &lt;Box p=&quot;2&quot; style={{ color: &apos;var(--gray-1)&apos; }}&gt;Loading...&lt;/Box&gt;
          ) : (
            filteredSuggestions.map(suggestion =&gt; (
              &lt;div 
                key={suggestion.slug}
                className={styles.suggestionItem}
                onMouseDown={() =&gt; handleSelectSuggestion(suggestion)}
              &gt;
                {suggestion.name}
              &lt;/div&gt;
            ))
          )}
        &lt;/div&gt;
      )}
    &lt;/Box&gt;
  );
}
export type SmartPlaylistFormData = {
  ruleGroups: SmartPlaylistRule[][];
};
type SmartPlaylistRuleEditorProps = {
  control: Control&lt;SmartPlaylistFormData&gt;;
  name: &apos;ruleGroups&apos; | `ruleGroups.${number}`;
  errors?: FieldErrors&lt;SmartPlaylistFormData&gt;;
};
export function SmartPlaylistRuleEditor({ control, name, errors }: SmartPlaylistRuleEditorProps) {
  // We&apos;ll only use the first group (index 0) since we&apos;re removing the groups concept
  const groupName = name === &apos;ruleGroups&apos; ? `${name}.0` : name;
  // Initialize the first group if it doesn&apos;t exist
  const { fields: ruleGroups, append: appendRuleGroup } = useFieldArray({
    control,
    name: &apos;ruleGroups&apos;,
  });
  if (ruleGroups.length === 0) {
    // Add the first (and only) rule group with an initial rule
    appendRuleGroup([{ field: &apos;genre&apos;, operator: &apos;is&apos;, value: &apos;&apos;, maxValue: &apos;&apos; }]);
  }
  return (
    &lt;div className={styles.container}&gt;
      &lt;div className={styles.ruleGroup}&gt;
        &lt;h4 className={styles.ruleGroupTitle}&gt;Match the following rules:&lt;/h4&gt;
        &lt;RuleEditor 
          control={control}
          name={groupName} 
          errors={errors?.ruleGroups?.[0]} 
        /&gt;
      &lt;/div&gt;
    &lt;/div&gt;
  );
}
type RuleEditorProps = {
  control: Control&lt;SmartPlaylistFormData&gt;;
  name: `ruleGroups.${number}`;
  errors?: any; // Using any temporarily to fix type issues
};
function RuleEditor({ control, name, errors }: RuleEditorProps) {
  const { fields: rules, append, remove } = useFieldArray({
    control,
    name,
  });
  const watchedFields = useWatch({
    control,
    name,
  }) as SmartPlaylistRule[];
  // Get the current library
  const library = {
    slug: &apos;music&apos;
  };
  // Fetch genres
  const { data: genresData, isLoading: genresLoading } = useGenreServiceGetApiGenres({
    librarySlug: library?.slug || &apos;&apos;,
    limit: 100,
  });
  // Fetch artists
  const { data: artistsData, isLoading: artistsLoading } = useArtistServiceGetApiLibrariesByLibraryArtists({
    library: library?.slug || &apos;&apos;,
    limit: 100,
  });
  // Format the data for the autocomplete component
  const genreSuggestions = genresData?.data?.map(genre =&gt; ({
    slug: genre.slug,
    name: genre.name,
  })) || [];
  const artistSuggestions = artistsData?.data?.map(artist =&gt; ({
    slug: artist.slug,
    name: artist.name,
  })) || [];
  // Function to add a new rule
  const addRule = () =&gt; {
    append({ field: &apos;genre&apos;, operator: &apos;is&apos;, value: &apos;&apos;, maxValue: &apos;&apos; });
  };
  return (
    &lt;div className={styles.ruleList}&gt;
      {rules.map((rule, ruleIndex) =&gt; (
        &lt;Flex key={rule.id} gap=&quot;2&quot; align=&quot;center&quot; mb=&quot;2&quot; className={styles.rule}&gt;
          &lt;Controller
            name={`${name}.${ruleIndex}.field`}
            control={control}
            rules={{ required: &apos;Field is required&apos; }}
            render={({ field }) =&gt; (
              &lt;Select.Root 
                value={field.value || &apos;genre&apos;}
                onValueChange={(value) =&gt; {
                  field.onChange(value);
                }}
              &gt;
                &lt;Select.Trigger className={styles.dropDownTrigger} /&gt;
                &lt;Select.Content&gt;
                  {RULE_FIELDS.map((fieldOption) =&gt; (
                    &lt;Select.Item key={fieldOption.value} value={fieldOption.value}&gt;
                      {fieldOption.label}
                    &lt;/Select.Item&gt;
                  ))}
                &lt;/Select.Content&gt;
              &lt;/Select.Root&gt;
            )}
          /&gt;
          &lt;Controller
            name={`${name}.${ruleIndex}.operator`}
            control={control}
            rules={{ required: &apos;Operator is required&apos; }}
            render={({ field }) =&gt; (
              &lt;Select.Root
                value={field.value || &apos;is&apos;}
                onValueChange={(value) =&gt; {
                  field.onChange(value);
                }}
              &gt;
                &lt;Select.Trigger className={styles.dropDownTrigger} /&gt;
                &lt;Select.Content&gt;
                  {FIELD_OPERATORS[(watchedFields?.[ruleIndex]?.field || &apos;genre&apos;) as FieldType].map((op) =&gt; (
                    &lt;Select.Item key={op.value} value={op.value}&gt;
                      {op.label}
                    &lt;/Select.Item&gt;
                  ))}
                &lt;/Select.Content&gt;
              &lt;/Select.Root&gt;
            )}
          /&gt;
          {watchedFields?.[ruleIndex]?.operator === &apos;between&apos; ? (
            &lt;Flex gap=&quot;2&quot; className={styles.valueInput}&gt;
              {watchedFields?.[ruleIndex]?.field === &apos;genre&apos; ? (
                &lt;&gt;
                  &lt;Controller
                    name={`${name}.${ruleIndex}.value`}
                    control={control}
                    rules={{ required: &apos;Min value is required&apos; }}
                    render={({ field }) =&gt; (
                      &lt;AutocompleteField
                        placeholder=&quot;Min Genre&quot;
                        value={field.value}
                        onChange={field.onChange}
                        suggestions={genreSuggestions}
                        loading={genresLoading}
                      /&gt;
                    )}
                  /&gt;
                  &lt;Controller
                    name={`${name}.${ruleIndex}.maxValue`}
                    control={control}
                    rules={{ required: &apos;Max value is required&apos; }}
                    render={({ field }) =&gt; (
                      &lt;AutocompleteField
                        placeholder=&quot;Max Genre&quot;
                        value={field.value as string}
                        onChange={field.onChange}
                        suggestions={genreSuggestions}
                        loading={genresLoading}
                      /&gt;
                    )}
                  /&gt;
                &lt;/&gt;
              ) : watchedFields?.[ruleIndex]?.field === &apos;artist&apos; ? (
                &lt;&gt;
                  &lt;Controller
                    name={`${name}.${ruleIndex}.value`}
                    control={control}
                    rules={{ required: &apos;Min value is required&apos; }}
                    render={({ field }) =&gt; (
                      &lt;AutocompleteField
                        placeholder=&quot;Min Artist&quot;
                        value={field.value}
                        onChange={field.onChange}
                        suggestions={artistSuggestions}
                        loading={artistsLoading}
                      /&gt;
                    )}
                  /&gt;
                  &lt;Controller
                    name={`${name}.${ruleIndex}.maxValue`}
                    control={control}
                    rules={{ required: &apos;Max value is required&apos; }}
                    render={({ field }) =&gt; (
                      &lt;AutocompleteField
                        placeholder=&quot;Max Artist&quot;
                        value={field.value as string}
                        onChange={field.onChange}
                        suggestions={artistSuggestions}
                        loading={artistsLoading}
                      /&gt;
                    )}
                  /&gt;
                &lt;/&gt;
              ) : (
                &lt;&gt;
                  &lt;TextField.Root 
                    placeholder=&quot;Min&quot;
                    type={(watchedFields?.[ruleIndex]?.field === &apos;year&apos; || watchedFields?.[ruleIndex]?.field === &apos;duration&apos;) ? &quot;number&quot; : &quot;text&quot;}
                    {...control.register(`${name}.${ruleIndex}.value`, { 
                      required: &apos;Min value is required&apos;
                    })}
                  /&gt;
                  &lt;TextField.Root 
                    placeholder=&quot;Max&quot;
                    type={(watchedFields?.[ruleIndex]?.field === &apos;year&apos; || watchedFields?.[ruleIndex]?.field === &apos;duration&apos;) ? &quot;number&quot; : &quot;text&quot;}
                    {...control.register(`${name}.${ruleIndex}.maxValue`, { 
                      required: &apos;Max value is required&apos;
                    })}
                  /&gt;
                &lt;/&gt;
              )}
            &lt;/Flex&gt;
          ) : (
            watchedFields?.[ruleIndex]?.field === &apos;genre&apos; ? (
              &lt;Controller
                name={`${name}.${ruleIndex}.value`}
                control={control}
                rules={{ required: &apos;Value is required&apos; }}
                render={({ field }) =&gt; (
                  &lt;AutocompleteField
                    placeholder=&quot;Genre&quot;
                    value={field.value}
                    onChange={field.onChange}
                    suggestions={genreSuggestions}
                    loading={genresLoading}
                  /&gt;
                )}
              /&gt;
            ) : watchedFields?.[ruleIndex]?.field === &apos;artist&apos; ? (
              &lt;Controller
                name={`${name}.${ruleIndex}.value`}
                control={control}
                rules={{ required: &apos;Value is required&apos; }}
                render={({ field }) =&gt; (
                  &lt;AutocompleteField
                    placeholder=&quot;Artist&quot;
                    value={field.value}
                    onChange={field.onChange}
                    suggestions={artistSuggestions}
                    loading={artistsLoading}
                  /&gt;
                )}
              /&gt;
            ) : (
              &lt;TextField.Root 
                placeholder=&quot;Value&quot;
                type={(watchedFields?.[ruleIndex]?.field === &apos;year&apos; || watchedFields?.[ruleIndex]?.field === &apos;duration&apos;) &amp;&amp; 
                     (watchedFields?.[ruleIndex]?.operator === &apos;greaterThan&apos; || watchedFields?.[ruleIndex]?.operator === &apos;lessThan&apos;) 
                     ? &quot;number&quot; : &quot;text&quot;}
                className={styles.valueInput}
                {...control.register(`${name}.${ruleIndex}.value`, { 
                  required: &apos;Value is required&apos;
                })}
              /&gt;
            )
          )}
          &lt;Button 
            color=&quot;red&quot; 
            variant=&quot;soft&quot; 
            size=&quot;1&quot;
            onClick={() =&gt; remove(ruleIndex)}
          &gt;
            &lt;TrashIcon /&gt;
          &lt;/Button&gt;
        &lt;/Flex&gt;
      ))}
      {errors &amp;&amp; (
        &lt;div className={styles.error}&gt;
          {typeof errors === &apos;string&apos; ? errors : (errors as any).message}
        &lt;/div&gt;
      )}
      {rules.map((_rule, index) =&gt; (
        errors &amp;&amp; errors[index] &amp;&amp; (
          &lt;div key={`error-${index}`} className={styles.error}&gt;
            {(errors[index] as any)?.field?.message || (errors[index] as any)?.operator?.message || (errors[index] as any)?.value?.message || (errors[index] as any)?.maxValue?.message}
          &lt;/div&gt;
        )
      ))}
      &lt;Flex justify=&quot;center&quot; mt=&quot;2&quot;&gt;
        &lt;Button variant=&quot;soft&quot; onClick={addRule}&gt;
          &lt;PlusIcon /&gt; Add Rule
        &lt;/Button&gt;
      &lt;/Flex&gt;
    &lt;/div&gt;
  );
}</file><file path="resources/app/modules/library-music-playlists/playlist/playlist.module.scss">.playlistTable {
  height: calc(100vh - 90px);
}
.scrollList {
  border-right: 1px solid #e0dddd;
  overflow-x: auto;
  max-width: 100%;
  height: calc(100vh - 90px);
  padding: 6px;
  .title {
    margin-left: 3px;
  }
  table {
    border-spacing: unset;
    table-layout: fixed;
    border-collapse: collapse;
  }
  th {
    background-color: var(--red-1);
    position: sticky;
    top: 0;
    z-index: 10;
    padding: 6px;
    text-align: left;
    font-weight: var(--font-weight-bold);
    font-size: 0.875rem;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
  }
  td {
    padding: 6px;
    text-align: left;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
  }
  tbody tr:hover {
    background-color: var(--accent-2);
  }
}
.listItem {
  cursor: pointer;
}
.titleCell {
  display: flex;
  align-items: center;
}
.titleCellNowPlayingIcon {
  color: var(--accent-8);
  margin-right: 8px;
}
.scrollbar {
  --sb-track-color: &apos;transparent&apos;;
  --sb-thumb-color: #828282;
  --sb-size: 6px;
}
.scrollbar::-webkit-scrollbar {
  width: var(--sb-size)
}
.scrollbar::-webkit-scrollbar-track {
  background: var(--sb-track-color);
  border-radius: 3px;
}
.scrollbar::-webkit-scrollbar-thumb {
  background: var(--sb-thumb-color);
  border-radius: 3px;
}
@supports not selector(::-webkit-scrollbar) {
  .scrollbar {
    scrollbar-color: var(--sb-thumb-color)
    var(--sb-track-color);
  }
}</file><file path="resources/app/modules/library-music/components/album-detail/index.ts">export * from &apos;./album-detail&apos;;</file><file path="resources/app/modules/library-music/components/album/index.ts">export * from &apos;./album&apos;;</file><file path="resources/app/modules/library-music/components/artwork/artist-big-circle/artist-big-circle.module.scss">.artistBigCircle {
    cursor: pointer;
    text-align: center;
    .imageContainer {
        .image {
            border-radius: 50%;
            &amp;:hover {
                box-shadow: 0 0 10px 0 rgba(0, 0, 0, 0.3);
            }
        }
    }
}</file><file path="resources/app/modules/library-music/components/artwork/cover/index.ts">export * from &apos;./cover.tsx&apos;;</file><file path="resources/app/modules/library-music/components/cover-grid/cover-grid.module.scss">.coverGrid {
    height: inherit;
    display: flex;
    flex-wrap: wrap;
    gap: 8px;
}</file><file path="resources/app/modules/library-music/components/cover-grid/cover-grid.tsx">import React from &apos;react&apos;;
import styles from &apos;./cover-grid.module.scss&apos;;
interface CoverGridProps {
  children: React.ReactNode;
  style?: React.CSSProperties;
}
export function CoverGrid({ children, style }: CoverGridProps) {
  return (
    &lt;div className={styles.coverGrid} style={style}&gt;
      {children}
    &lt;/div&gt;
  )
}</file><file path="resources/app/modules/library-music/components/cover-grid/index.ts">export * from &apos;./cover-grid.tsx&apos;;</file><file path="resources/app/modules/library-music/components/scroll-list/index.ts">export * from &apos;./scroll-list&apos;;</file><file path="resources/app/modules/library-music/routes/artists.module.scss">.artistsLayout {
    padding: var(--layout-default-body-padding);
}</file><file path="resources/app/modules/library-music/routes/songs.module.scss">.songListContainer {
  margin: 12px -12px -12px;
}</file><file path="resources/app/modules/notifications/notification-facade.ts">import { CreateNotification, Notification } from &apos;@/modules/notifications/models.ts&apos;;
import { store } from &apos;@/store&apos;;
import { createNotification } from &apos;@/store/notifications/notifications-slice.ts&apos;;
export class NotificationFacade {
  static create(options: CreateNotification) {
    const notification: Notification = {
      id: self.crypto.randomUUID(),
      ...options,
      read: false,
      createdAt: new Date(),
    }
    store.dispatch(createNotification(notification))
  }
}</file><file path="resources/app/modules/user-settings/pages/equalizer-settings.tsx">import { SettingsPageLayout } from &apos;@/modules/user-settings/layouts/settings-page-layout.tsx&apos;;
import { Equalizer } from &apos;@/modules/equalizer/equalizer.tsx&apos;;
import { useBlockBodyScroll } from &apos;@/hooks/use-block-body-scroll.ts&apos;;
export function EqualizerSettings() {
  useBlockBodyScroll();
  return (
    &lt;SettingsPageLayout title=&quot;Equalizer&quot;&gt;
      &lt;Equalizer /&gt;
    &lt;/SettingsPageLayout&gt;
  )
}</file><file path="resources/app/modules/user-settings/routes.tsx">import { Route, Routes } from &apos;react-router-dom&apos;;
import { EqualizerSettings } from &apos;@/modules/user-settings/pages/equalizer-settings.tsx&apos;;
import { SettingsOverview } from &apos;@/modules/user-settings/pages/settings-overview.tsx&apos;;
import { Sessions } from &apos;@/modules/user-settings/pages/sessions.tsx&apos;;
import { Passkeys } from &apos;@/modules/user-settings/pages/passkeys.tsx&apos;;
export const UserSettingsRoutes = () =&gt; {
  return (
    &lt;Routes&gt;
      &lt;Route path=&quot;/&quot; element={&lt;SettingsOverview /&gt;} /&gt;
      &lt;Route path=&quot;/equalizer&quot; element={&lt;EqualizerSettings/&gt;}/&gt;
      &lt;Route path=&quot;/sessions&quot; element={&lt;Sessions /&gt;} /&gt;
      &lt;Route path=&quot;/passkeys&quot; element={&lt;Passkeys /&gt;} /&gt;
    &lt;/Routes&gt;
  );
};</file><file path="resources/app/providers/radix-provider.tsx">import { Theme } from &apos;@radix-ui/themes&apos;;
import { Toast, Tooltip } from &apos;radix-ui&apos;;
import { ReactNode } from &apos;react&apos;;
export const RadixProvider = ({ children }: { children: ReactNode }) =&gt; {
  return (
    &lt;Theme accentColor=&quot;red&quot; radius=&quot;large&quot;&gt;
      &lt;Toast.Provider swipeDirection=&quot;right&quot;&gt;
        &lt;Tooltip.Provider&gt;
          {children}
        &lt;/Tooltip.Provider&gt;
      &lt;/Toast.Provider&gt;
    &lt;/Theme&gt;
  );
};</file><file path="resources/app/providers/test-mode-provider.tsx">import React, { createContext, useContext, useState, useEffect } from &apos;react&apos;;
import { generateMockDataFromType } from &apos;@/utils/testing/generateMockDataFromType.ts&apos;;
interface TestModeContextType {
  isTestMode: boolean;
  toggleTestMode: () =&gt; void;
  debugInfo: Record&lt;string, any&gt;;
  addDebugInfo: (key: string, value: any) =&gt; void;
}
const TestModeContext = createContext&lt;TestModeContextType | undefined&gt;(undefined);
export const TestModeProvider: React.FC&lt;{ children: React.ReactNode }&gt; = ({ children }) =&gt; {
  const [isTestMode, setIsTestMode] = useState(false);
  const [debugInfo, setDebugInfo] = useState&lt;Record&lt;string, any&gt;&gt;({});
  const toggleTestMode = () =&gt; {
    setIsTestMode((prev) =&gt; !prev);
  };
  const addDebugInfo = (key: string, value: any) =&gt; {
    setDebugInfo((prev) =&gt; ({ ...prev, [key]: value }));
  };
  useEffect(() =&gt; {
    if (isTestMode) {
      console.log(&apos;Debug Info:&apos;, debugInfo);
    }
  }, [debugInfo, isTestMode]);
  return (
    &lt;TestModeContext.Provider value={{ isTestMode, toggleTestMode, debugInfo, addDebugInfo }}&gt;
      {children}
    &lt;/TestModeContext.Provider&gt;
  );
};
export const useTestMode = () =&gt; {
  const context = useContext(TestModeContext);
  if (!context) {
    throw new Error(&apos;useTestMode must be used within a TestModeProvider&apos;);
  }
  return context;
};
export function withTestMode&lt;T extends { viewModel?: any }&gt;(
  Component: React.ComponentType&lt;T&gt;,
  viewModelType: T[&apos;viewModel&apos;],
) {
  return function TestModeWrapper(props: T) {
    const { isTestMode } = useTestMode();
    if (isTestMode) {
      // Generate mock data for the viewModel using the explicitly passed type
      const mockViewModel = generateMockDataFromType(viewModelType);
      // Override the viewModel with mock data
      const testProps = {
        ...props,
        viewModel: mockViewModel,
      };
      return &lt;Component {...testProps} /&gt;;
    }
    return &lt;Component {...props} /&gt;;
  };
}</file><file path="resources/app/reset.css">/* Box sizing rules */
*,
*::before,
*::after {
    box-sizing: border-box;
}
/* Prevent font size inflation */
html {
    -moz-text-size-adjust: none;
    -webkit-text-size-adjust: none;
    text-size-adjust: none;
}
/* Remove default margin in favour of better control in authored CSS */
body, h1, h2, h3, h4, p,
figure, blockquote, dl, dd {
    margin-block-end: 0;
}
/* Remove list styles on ul, ol elements with a list role, which suggests default styling will be removed */
ul[role=&apos;list&apos;],
ol[role=&apos;list&apos;] {
    list-style: none;
}
/* Set core body defaults */
body {
    min-height: 100vh;
    line-height: 1.5;
}
/* Set shorter line heights on headings and interactive elements */
h1, h2, h3, h4,
button, input, label {
    line-height: 1.1;
}
/* Balance text wrapping on headings */
h1, h2,
h3, h4 {
    text-wrap: balance;
}
/* A elements that don&apos;t have a class get default styles */
a:not([class]) {
    text-decoration-skip-ink: auto;
    color: currentColor;
}
/* Make images easier to work with */
img,
picture {
    max-width: 100%;
    display: block;
}
/* Inherit fonts for inputs and buttons */
input, button,
textarea, select {
    font-family: inherit;
    font-size: inherit;
}
/* Make sure textareas without a rows attribute are not tiny */
textarea:not([rows]) {
    min-height: 10em;
}
/* Anything that has been anchored to should have extra scroll margin */
:target {
    scroll-margin-block: 5ex;
}</file><file path="resources/app/services/apm.ts">import { init as initApm } from &apos;@elastic/apm-rum&apos;
const apm = initApm({
  serviceName: &apos;baander-frontend&apos;,
  serverUrl: &apos;https://192.168.50.151:8200&apos;,
  serviceVersion: &apos;1.0.0&apos;,
  environment: &apos;development&apos;,
})
// Custom React instrumentation utilities
export const reactApm = {
  // Track component render performance
  startComponentRender: (componentName: string) =&gt; {
    return apm.startSpan(`React Component: ${componentName}`, &apos;react.render&apos;);
  },
  // Track component lifecycle events
  trackComponentLifecycle: (componentName: string, lifecycle: string, metadata?: Record&lt;string, any&gt;) =&gt; {
    const span = apm.startSpan(`${componentName}.${lifecycle}`, &apos;react.lifecycle&apos;);
    if (metadata) {
      span?.addLabels(metadata);
    }
    return span;
  },
  // Track React errors
  captureReactError: (error: Error, componentName: string, errorInfo?: any) =&gt; {
    apm.captureError(error, {
      labels: {
        component: componentName,
        errorInfo: errorInfo?.componentStack || &apos;No component stack&apos;,
        props: errorInfo?.props || {},
        type: &apos;react-error&apos;,
      }
    });
  },
  // Track component mount/unmount
  trackComponentMount: (componentName: string) =&gt; {
    return apm.startSpan(`${componentName}.mount`, &apos;react.mount&apos;);
  },
  trackComponentUnmount: (componentName: string) =&gt; {
    return apm.startSpan(`${componentName}.unmount`, &apos;react.unmount&apos;);
  },
  // Track prop changes
  trackPropChanges: (componentName: string, changedProps: string[]) =&gt; {
    const span = apm.startSpan(`${componentName}.propsChanged`, &apos;react.update&apos;);
    span?.addLabels({
      changedProps: changedProps.join(&apos;, &apos;),
      propCount: changedProps.length,
    });
    return span;
  },
};
export { apm }</file><file path="resources/app/services/auth/stream-token.ts">import { NewAccessTokenResource } from &apos;@/api-client/requests&apos;;
import { isTokenExpired, Token } from &apos;@/services/auth/token.ts&apos;;
export function refreshStreamToken() {
  return new Promise&lt;NewAccessTokenResource&gt;((resolve, reject) =&gt; {
    const refreshToken = Token.get()?.refreshToken;
    if (!refreshToken || isTokenExpired(refreshToken.expiresAt)) {
      reject(new Error(&apos;Refresh token expired&apos;));
    }
    fetch(route(&apos;auth.streamToken&apos;), {
      method: &apos;POST&apos;,
      headers: {
        Authorization: `Bearer ${refreshToken!.token}`,
      },
    }).then(res =&gt; res.json())
      .then((res: { streamToken: NewAccessTokenResource }) =&gt; {
        resolve(res.streamToken);
      }).catch((e) =&gt; {
      reject(e);
    });
  });
}</file><file path="resources/app/services/libraries/player-state.ts">export interface PlayerStateInput {
  isPlaying: boolean;
  volumePercent: number;
  progressMs?: number;
  deviceName?: string;
  deviceType?: string;
}</file><file path="resources/app/store/create-app-slice.ts">import { asyncThunkCreator, buildCreateSlice } from &quot;@reduxjs/toolkit&quot;
// `buildCreateSlice` allows us to create a slice with async thunks.
export const createAppSlice = buildCreateSlice({
  creators: { asyncThunk: asyncThunkCreator },
})</file><file path="resources/app/store/users/auth-slice.utils.ts">import { AuthSliceState } from &apos;@/store/users/auth-slice.ts&apos;;
import { OpenAPI, PostApiAuthLoginResponse } from &apos;@/api-client/requests&apos;;
import { Token } from &apos;@/services/auth/token.ts&apos;;
export const clearAuthState = (state: AuthSliceState) =&gt; {
  state.loading = false;
  state.authenticated = false;
  state.accessToken = null;
  state.refreshToken = null;
  Token.clear();
  OpenAPI.TOKEN = undefined;
}
export const setAuthState = (state: AuthSliceState, payload: PostApiAuthLoginResponse) =&gt; {
  state.loading = false;
  state.authenticated = true;
  state.accessToken = payload.accessToken;
  state.refreshToken = payload.refreshToken;
  Token.set({
    accessToken: payload.accessToken,
    refreshToken: payload.refreshToken,
  });
  OpenAPI.TOKEN = payload.accessToken.token;
  return state;
}</file><file path="resources/app/store/users/ui-slice.ts">import { createAppSlice } from &apos;@/store/create-app-slice.ts&apos;;
import { PayloadAction } from &apos;@reduxjs/toolkit&apos;;
export type Theme = &apos;light&apos; | &apos;dark&apos;;
export interface UiSliceState {
  theme: Theme;
}
const initialState: UiSliceState = {
  theme: &apos;light&apos;,
};
export const uiSlice = createAppSlice({
  name: &apos;ui&apos;,
  initialState,
  reducers: {
    setTheme: (state, action: PayloadAction&lt;Theme&gt;) =&gt; {
      state.theme = action.payload;
    },
  },
});
export const {
  setTheme,
} = uiSlice.actions;</file><file path="resources/app/ui/alerts/alert.tsx">import React, { useState, ReactNode } from &apos;react&apos;;
interface AlertProps {
  color?: string;
  children?: ReactNode;
  showDismissButton?: boolean;
}
interface AlertTitleProps {
  children: ReactNode;
}
interface AlertDescriptionProps {
  children: ReactNode;
}
interface AlertActionProps {
  children: ReactNode;
  onClick: () =&gt; void;
}
const Alert = ({ children, showDismissButton = true }: AlertProps) =&gt; {
  const [isVisible, setIsVisible] = useState(true);
  // Check if any `Alert.Action` components are provided
  const hasActions = React.Children.toArray(children).some(
    (child) =&gt; React.isValidElement(child) &amp;&amp; child.type === Alert.Action
  );
  if (!isVisible) return null;
  return (
    &lt;div className=&quot;p-4 border rounded-lg bg-gray-50 shadow-sm&quot;&gt;
      {children}
      {/* Add a default dismiss button if no actions are provided */}
      {!hasActions || showDismissButton &amp;&amp; (
        &lt;div className=&quot;mt-4 flex justify-end&quot;&gt;
          &lt;button
            onClick={() =&gt; setIsVisible(false)}
            className=&quot;px-4 py-2 text-sm font-medium text-gray-700 bg-gray-200 rounded-md hover:bg-gray-300&quot;
          &gt;
            Dismiss
          &lt;/button&gt;
        &lt;/div&gt;
      )}
    &lt;/div&gt;
  );
};
const AlertTitle = ({ children }: AlertTitleProps) =&gt; {
  return &lt;h3 className=&quot;text-lg font-semibold text-gray-900&quot;&gt;{children}&lt;/h3&gt;;
};
const AlertDescription = ({ children }: AlertDescriptionProps) =&gt; {
  return &lt;p className=&quot;mt-2 text-sm text-gray-600&quot;&gt;{children}&lt;/p&gt;;
};
const AlertAction = ({ children, onClick }: AlertActionProps) =&gt; {
  return (
    &lt;button
      onClick={onClick}
      className=&quot;px-4 py-2 text-sm font-medium text-white bg-blue-600 rounded-md hover:bg-blue-700&quot;
    &gt;
      {children}
    &lt;/button&gt;
  );
};
// Attach subcomponents to the main Alert component
Alert.Title = AlertTitle;
Alert.Description = AlertDescription;
Alert.Action = AlertAction;
export default Alert;</file><file path="resources/app/ui/animations/vinyl-spin-animation/vinyl-spin-animation.json">{&quot;v&quot;:&quot;5.5.7&quot;,&quot;fr&quot;:30,&quot;ip&quot;:0,&quot;op&quot;:361,&quot;w&quot;:640,&quot;h&quot;:640,&quot;nm&quot;:&quot;Vinyl_lottie&quot;,&quot;ddd&quot;:0,&quot;assets&quot;:[{&quot;id&quot;:&quot;comp_0&quot;,&quot;layers&quot;:[{&quot;ddd&quot;:0,&quot;ind&quot;:1,&quot;ty&quot;:4,&quot;nm&quot;:&quot;shine 2&quot;,&quot;sr&quot;:1,&quot;ks&quot;:{&quot;o&quot;:{&quot;a&quot;:0,&quot;k&quot;:100,&quot;ix&quot;:11},&quot;r&quot;:{&quot;a&quot;:0,&quot;k&quot;:180,&quot;ix&quot;:10},&quot;p&quot;:{&quot;a&quot;:0,&quot;k&quot;:[400,300,0],&quot;ix&quot;:2},&quot;a&quot;:{&quot;a&quot;:0,&quot;k&quot;:[0.5,1.25,0],&quot;ix&quot;:1},&quot;s&quot;:{&quot;a&quot;:0,&quot;k&quot;:[100,100,100],&quot;ix&quot;:6}},&quot;ao&quot;:0,&quot;shapes&quot;:[{&quot;ty&quot;:&quot;gr&quot;,&quot;it&quot;:[{&quot;d&quot;:1,&quot;ty&quot;:&quot;el&quot;,&quot;s&quot;:{&quot;a&quot;:0,&quot;k&quot;:[96.5,96.5],&quot;ix&quot;:2},&quot;p&quot;:{&quot;a&quot;:0,&quot;k&quot;:[0,0],&quot;ix&quot;:3},&quot;nm&quot;:&quot;Ellipse Path 1&quot;,&quot;mn&quot;:&quot;ADBE Vector Shape - Ellipse&quot;,&quot;hd&quot;:false},{&quot;ty&quot;:&quot;st&quot;,&quot;c&quot;:{&quot;a&quot;:0,&quot;k&quot;:[0.18431372549,0.298039215686,0.450980392157,1],&quot;ix&quot;:3},&quot;o&quot;:{&quot;a&quot;:0,&quot;k&quot;:100,&quot;ix&quot;:4},&quot;w&quot;:{&quot;a&quot;:0,&quot;k&quot;:34,&quot;ix&quot;:5},&quot;lc&quot;:1,&quot;lj&quot;:1,&quot;ml&quot;:4,&quot;bm&quot;:0,&quot;nm&quot;:&quot;Stroke 1&quot;,&quot;mn&quot;:&quot;ADBE Vector Graphic - Stroke&quot;,&quot;hd&quot;:false},{&quot;ty&quot;:&quot;tr&quot;,&quot;p&quot;:{&quot;a&quot;:0,&quot;k&quot;:[0.5,1.25],&quot;ix&quot;:2},&quot;a&quot;:{&quot;a&quot;:0,&quot;k&quot;:[0,0],&quot;ix&quot;:1},&quot;s&quot;:{&quot;a&quot;:0,&quot;k&quot;:[100,100],&quot;ix&quot;:3},&quot;r&quot;:{&quot;a&quot;:0,&quot;k&quot;:0,&quot;ix&quot;:6},&quot;o&quot;:{&quot;a&quot;:0,&quot;k&quot;:100,&quot;ix&quot;:7},&quot;sk&quot;:{&quot;a&quot;:0,&quot;k&quot;:0,&quot;ix&quot;:4},&quot;sa&quot;:{&quot;a&quot;:0,&quot;k&quot;:0,&quot;ix&quot;:5},&quot;nm&quot;:&quot;Transform&quot;}],&quot;nm&quot;:&quot;Ellipse 1&quot;,&quot;np&quot;:3,&quot;cix&quot;:2,&quot;bm&quot;:0,&quot;ix&quot;:1,&quot;mn&quot;:&quot;ADBE Vector Group&quot;,&quot;hd&quot;:false},{&quot;ty&quot;:&quot;tm&quot;,&quot;s&quot;:{&quot;a&quot;:1,&quot;k&quot;:[{&quot;i&quot;:{&quot;x&quot;:[0.757],&quot;y&quot;:[1]},&quot;o&quot;:{&quot;x&quot;:[0.243],&quot;y&quot;:[0]},&quot;t&quot;:0,&quot;s&quot;:[4]},{&quot;i&quot;:{&quot;x&quot;:[0.757],&quot;y&quot;:[1]},&quot;o&quot;:{&quot;x&quot;:[0.243],&quot;y&quot;:[0]},&quot;t&quot;:15,&quot;s&quot;:[3]},{&quot;t&quot;:30,&quot;s&quot;:[4]}],&quot;ix&quot;:1,&quot;x&quot;:&quot;var $bm_rt;\n$bm_rt = loopOut(&apos;cycle&apos;);&quot;},&quot;e&quot;:{&quot;a&quot;:1,&quot;k&quot;:[{&quot;i&quot;:{&quot;x&quot;:[0.762],&quot;y&quot;:[1]},&quot;o&quot;:{&quot;x&quot;:[0.167],&quot;y&quot;:[0]},&quot;t&quot;:0,&quot;s&quot;:[17]},{&quot;i&quot;:{&quot;x&quot;:[0.762],&quot;y&quot;:[1]},&quot;o&quot;:{&quot;x&quot;:[0.238],&quot;y&quot;:[0]},&quot;t&quot;:15,&quot;s&quot;:[18]},{&quot;t&quot;:30,&quot;s&quot;:[17]}],&quot;ix&quot;:2,&quot;x&quot;:&quot;var $bm_rt;\n$bm_rt = loopOut(&apos;cycle&apos;);&quot;},&quot;o&quot;:{&quot;a&quot;:1,&quot;k&quot;:[{&quot;i&quot;:{&quot;x&quot;:[0.757],&quot;y&quot;:[1]},&quot;o&quot;:{&quot;x&quot;:[0.243],&quot;y&quot;:[0]},&quot;t&quot;:0,&quot;s&quot;:[3]},{&quot;i&quot;:{&quot;x&quot;:[0.757],&quot;y&quot;:[1]},&quot;o&quot;:{&quot;x&quot;:[0.167],&quot;y&quot;:[0]},&quot;t&quot;:32,&quot;s&quot;:[-3]},{&quot;t&quot;:90,&quot;s&quot;:[3]}],&quot;ix&quot;:3,&quot;x&quot;:&quot;var $bm_rt;\n$bm_rt = loopOut(&apos;cycle&apos;);&quot;},&quot;m&quot;:1,&quot;ix&quot;:2,&quot;nm&quot;:&quot;Trim Paths 1&quot;,&quot;mn&quot;:&quot;ADBE Vector Filter - Trim&quot;,&quot;hd&quot;:false}],&quot;ip&quot;:0,&quot;op&quot;:361,&quot;st&quot;:0,&quot;bm&quot;:0},{&quot;ddd&quot;:0,&quot;ind&quot;:2,&quot;ty&quot;:4,&quot;nm&quot;:&quot;shine&quot;,&quot;sr&quot;:1,&quot;ks&quot;:{&quot;o&quot;:{&quot;a&quot;:0,&quot;k&quot;:100,&quot;ix&quot;:11,&quot;x&quot;:&quot;var $bm_rt;\n$bm_rt = thisComp.layer(&apos;shine 2&apos;).transform.opacity;&quot;},&quot;r&quot;:{&quot;a&quot;:0,&quot;k&quot;:0,&quot;ix&quot;:10},&quot;p&quot;:{&quot;a&quot;:0,&quot;k&quot;:[400,300,0],&quot;ix&quot;:2},&quot;a&quot;:{&quot;a&quot;:0,&quot;k&quot;:[0.5,1.25,0],&quot;ix&quot;:1},&quot;s&quot;:{&quot;a&quot;:0,&quot;k&quot;:[100,100,100],&quot;ix&quot;:6}},&quot;ao&quot;:0,&quot;shapes&quot;:[{&quot;ty&quot;:&quot;gr&quot;,&quot;it&quot;:[{&quot;d&quot;:1,&quot;ty&quot;:&quot;el&quot;,&quot;s&quot;:{&quot;a&quot;:0,&quot;k&quot;:[94.5,94.5],&quot;ix&quot;:2,&quot;x&quot;:&quot;var $bm_rt;\n$bm_rt = thisComp.layer(&apos;shine 2&apos;).content(&apos;Ellipse 1&apos;).content(&apos;Ellipse Path 1&apos;).size;&quot;},&quot;p&quot;:{&quot;a&quot;:0,&quot;k&quot;:[0,0],&quot;ix&quot;:3},&quot;nm&quot;:&quot;Ellipse Path 1&quot;,&quot;mn&quot;:&quot;ADBE Vector Shape - Ellipse&quot;,&quot;hd&quot;:false},{&quot;ty&quot;:&quot;st&quot;,&quot;c&quot;:{&quot;a&quot;:0,&quot;k&quot;:[1,1,1,1],&quot;ix&quot;:3,&quot;x&quot;:&quot;var $bm_rt;\n$bm_rt = thisComp.layer(&apos;shine 2&apos;).content(&apos;Ellipse 1&apos;).content(&apos;Stroke 1&apos;).color;&quot;},&quot;o&quot;:{&quot;a&quot;:0,&quot;k&quot;:100,&quot;ix&quot;:4},&quot;w&quot;:{&quot;a&quot;:0,&quot;k&quot;:35,&quot;ix&quot;:5,&quot;x&quot;:&quot;var $bm_rt;\n$bm_rt = thisComp.layer(&apos;shine 2&apos;).content(&apos;Ellipse 1&apos;).content(&apos;Stroke 1&apos;).strokeWidth;&quot;},&quot;lc&quot;:1,&quot;lj&quot;:1,&quot;ml&quot;:4,&quot;bm&quot;:0,&quot;nm&quot;:&quot;Stroke 1&quot;,&quot;mn&quot;:&quot;ADBE Vector Graphic - Stroke&quot;,&quot;hd&quot;:false},{&quot;ty&quot;:&quot;tr&quot;,&quot;p&quot;:{&quot;a&quot;:0,&quot;k&quot;:[0.5,1.25],&quot;ix&quot;:2},&quot;a&quot;:{&quot;a&quot;:0,&quot;k&quot;:[0,0],&quot;ix&quot;:1},&quot;s&quot;:{&quot;a&quot;:0,&quot;k&quot;:[100,100],&quot;ix&quot;:3},&quot;r&quot;:{&quot;a&quot;:0,&quot;k&quot;:0,&quot;ix&quot;:6},&quot;o&quot;:{&quot;a&quot;:0,&quot;k&quot;:100,&quot;ix&quot;:7},&quot;sk&quot;:{&quot;a&quot;:0,&quot;k&quot;:0,&quot;ix&quot;:4},&quot;sa&quot;:{&quot;a&quot;:0,&quot;k&quot;:0,&quot;ix&quot;:5},&quot;nm&quot;:&quot;Transform&quot;}],&quot;nm&quot;:&quot;Ellipse 1&quot;,&quot;np&quot;:3,&quot;cix&quot;:2,&quot;bm&quot;:0,&quot;ix&quot;:1,&quot;mn&quot;:&quot;ADBE Vector Group&quot;,&quot;hd&quot;:false},{&quot;ty&quot;:&quot;tm&quot;,&quot;s&quot;:{&quot;a&quot;:0,&quot;k&quot;:0,&quot;ix&quot;:1,&quot;x&quot;:&quot;var $bm_rt;\n$bm_rt = thisComp.layer(&apos;shine 2&apos;).content(&apos;Trim Paths 1&apos;).start;&quot;},&quot;e&quot;:{&quot;a&quot;:0,&quot;k&quot;:13,&quot;ix&quot;:2,&quot;x&quot;:&quot;var $bm_rt;\n$bm_rt = thisComp.layer(&apos;shine 2&apos;).content(&apos;Trim Paths 1&apos;).end;&quot;},&quot;o&quot;:{&quot;a&quot;:0,&quot;k&quot;:0,&quot;ix&quot;:3,&quot;x&quot;:&quot;var $bm_rt;\n$bm_rt = thisComp.layer(&apos;shine 2&apos;).content(&apos;Trim Paths 1&apos;).offset;&quot;},&quot;m&quot;:1,&quot;ix&quot;:2,&quot;nm&quot;:&quot;Trim Paths 1&quot;,&quot;mn&quot;:&quot;ADBE Vector Filter - Trim&quot;,&quot;hd&quot;:false}],&quot;ip&quot;:0,&quot;op&quot;:361,&quot;st&quot;:0,&quot;bm&quot;:0},{&quot;ddd&quot;:0,&quot;ind&quot;:3,&quot;ty&quot;:4,&quot;nm&quot;:&quot;Layer 1 - Group 5&quot;,&quot;sr&quot;:1,&quot;ks&quot;:{&quot;o&quot;:{&quot;a&quot;:0,&quot;k&quot;:100,&quot;ix&quot;:11},&quot;r&quot;:{&quot;a&quot;:0,&quot;k&quot;:0,&quot;ix&quot;:10},&quot;p&quot;:{&quot;a&quot;:0,&quot;k&quot;:[400,300,0],&quot;ix&quot;:2},&quot;a&quot;:{&quot;a&quot;:0,&quot;k&quot;:[400,300,0],&quot;ix&quot;:1},&quot;s&quot;:{&quot;a&quot;:0,&quot;k&quot;:[100,100,100],&quot;ix&quot;:6}},&quot;ao&quot;:0,&quot;shapes&quot;:[{&quot;ty&quot;:&quot;gr&quot;,&quot;it&quot;:[{&quot;ind&quot;:0,&quot;ty&quot;:&quot;sh&quot;,&quot;ix&quot;:1,&quot;ks&quot;:{&quot;a&quot;:0,&quot;k&quot;:{&quot;i&quot;:[[0,-0.828],[0.828,0],[0,0.828],[-0.828,0]],&quot;o&quot;:[[0,0.828],[-0.828,0],[0,-0.828],[0.828,0]],&quot;v&quot;:[[1.5,0],[0,1.5],[-1.5,0],[0,-1.5]],&quot;c&quot;:true},&quot;ix&quot;:2},&quot;nm&quot;:&quot;Path 1&quot;,&quot;mn&quot;:&quot;ADBE Vector Shape - Group&quot;,&quot;hd&quot;:false},{&quot;ty&quot;:&quot;fl&quot;,&quot;c&quot;:{&quot;a&quot;:0,&quot;k&quot;:[0.105882360421,0.231372563979,0.400000029919,1],&quot;ix&quot;:4},&quot;o&quot;:{&quot;a&quot;:0,&quot;k&quot;:100,&quot;ix&quot;:5},&quot;r&quot;:1,&quot;bm&quot;:0,&quot;nm&quot;:&quot;Fill 1&quot;,&quot;mn&quot;:&quot;ADBE Vector Graphic - Fill&quot;,&quot;hd&quot;:false},{&quot;ty&quot;:&quot;tr&quot;,&quot;p&quot;:{&quot;a&quot;:0,&quot;k&quot;:[400,300],&quot;ix&quot;:2},&quot;a&quot;:{&quot;a&quot;:0,&quot;k&quot;:[0,0],&quot;ix&quot;:1},&quot;s&quot;:{&quot;a&quot;:0,&quot;k&quot;:[100,100],&quot;ix&quot;:3},&quot;r&quot;:{&quot;a&quot;:0,&quot;k&quot;:0,&quot;ix&quot;:6},&quot;o&quot;:{&quot;a&quot;:0,&quot;k&quot;:100,&quot;ix&quot;:7},&quot;sk&quot;:{&quot;a&quot;:0,&quot;k&quot;:0,&quot;ix&quot;:4},&quot;sa&quot;:{&quot;a&quot;:0,&quot;k&quot;:0,&quot;ix&quot;:5},&quot;nm&quot;:&quot;Transform&quot;}],&quot;nm&quot;:&quot;Group 1&quot;,&quot;np&quot;:2,&quot;cix&quot;:2,&quot;bm&quot;:0,&quot;ix&quot;:1,&quot;mn&quot;:&quot;ADBE Vector Group&quot;,&quot;hd&quot;:false}],&quot;ip&quot;:0,&quot;op&quot;:361,&quot;st&quot;:0,&quot;bm&quot;:0},{&quot;ddd&quot;:0,&quot;ind&quot;:4,&quot;ty&quot;:4,&quot;nm&quot;:&quot;Layer 1 - Group 1&quot;,&quot;sr&quot;:1,&quot;ks&quot;:{&quot;o&quot;:{&quot;a&quot;:0,&quot;k&quot;:100,&quot;ix&quot;:11},&quot;r&quot;:{&quot;a&quot;:0,&quot;k&quot;:0,&quot;ix&quot;:10},&quot;p&quot;:{&quot;a&quot;:0,&quot;k&quot;:[400,300,0],&quot;ix&quot;:2},&quot;a&quot;:{&quot;a&quot;:0,&quot;k&quot;:[400,300,0],&quot;ix&quot;:1},&quot;s&quot;:{&quot;a&quot;:0,&quot;k&quot;:[100,100,100],&quot;ix&quot;:6}},&quot;ao&quot;:0,&quot;shapes&quot;:[{&quot;ty&quot;:&quot;gr&quot;,&quot;it&quot;:[{&quot;ind&quot;:0,&quot;ty&quot;:&quot;sh&quot;,&quot;ix&quot;:1,&quot;ks&quot;:{&quot;a&quot;:0,&quot;k&quot;:{&quot;i&quot;:[[0,-4.461],[4.461,0],[0,4.461],[-4.461,0]],&quot;o&quot;:[[0,4.461],[-4.461,0],[0,-4.461],[4.461,0]],&quot;v&quot;:[[8.077,0],[0,8.077],[-8.077,0],[0,-8.077]],&quot;c&quot;:true},&quot;ix&quot;:2},&quot;nm&quot;:&quot;Path 1&quot;,&quot;mn&quot;:&quot;ADBE Vector Shape - Group&quot;,&quot;hd&quot;:false},{&quot;ty&quot;:&quot;fl&quot;,&quot;c&quot;:{&quot;a&quot;:0,&quot;k&quot;:[0.980392156863,0.658823529412,0.247058823529,1],&quot;ix&quot;:4},&quot;o&quot;:{&quot;a&quot;:0,&quot;k&quot;:100,&quot;ix&quot;:5},&quot;r&quot;:1,&quot;bm&quot;:0,&quot;nm&quot;:&quot;Fill 1&quot;,&quot;mn&quot;:&quot;ADBE Vector Graphic - Fill&quot;,&quot;hd&quot;:false},{&quot;ty&quot;:&quot;tr&quot;,&quot;p&quot;:{&quot;a&quot;:0,&quot;k&quot;:[400,300],&quot;ix&quot;:2},&quot;a&quot;:{&quot;a&quot;:0,&quot;k&quot;:[0,0],&quot;ix&quot;:1},&quot;s&quot;:{&quot;a&quot;:0,&quot;k&quot;:[100,100],&quot;ix&quot;:3},&quot;r&quot;:{&quot;a&quot;:0,&quot;k&quot;:0,&quot;ix&quot;:6},&quot;o&quot;:{&quot;a&quot;:0,&quot;k&quot;:100,&quot;ix&quot;:7},&quot;sk&quot;:{&quot;a&quot;:0,&quot;k&quot;:0,&quot;ix&quot;:4},&quot;sa&quot;:{&quot;a&quot;:0,&quot;k&quot;:0,&quot;ix&quot;:5},&quot;nm&quot;:&quot;Transform&quot;}],&quot;nm&quot;:&quot;Group 1&quot;,&quot;np&quot;:2,&quot;cix&quot;:2,&quot;bm&quot;:0,&quot;ix&quot;:1,&quot;mn&quot;:&quot;ADBE Vector Group&quot;,&quot;hd&quot;:false}],&quot;ip&quot;:0,&quot;op&quot;:361,&quot;st&quot;:0,&quot;bm&quot;:0},{&quot;ddd&quot;:0,&quot;ind&quot;:5,&quot;ty&quot;:4,&quot;nm&quot;:&quot;writing&quot;,&quot;sr&quot;:1,&quot;ks&quot;:{&quot;o&quot;:{&quot;a&quot;:0,&quot;k&quot;:100,&quot;ix&quot;:11},&quot;r&quot;:{&quot;a&quot;:1,&quot;k&quot;:[{&quot;i&quot;:{&quot;x&quot;:[0.833],&quot;y&quot;:[0.833]},&quot;o&quot;:{&quot;x&quot;:[0.167],&quot;y&quot;:[0.167]},&quot;t&quot;:0,&quot;s&quot;:[0]},{&quot;t&quot;:30,&quot;s&quot;:[360]}],&quot;ix&quot;:10,&quot;x&quot;:&quot;var $bm_rt;\n$bm_rt = loopOut(&apos;cycle&apos;);&quot;},&quot;p&quot;:{&quot;a&quot;:0,&quot;k&quot;:[400,300,0],&quot;ix&quot;:2},&quot;a&quot;:{&quot;a&quot;:0,&quot;k&quot;:[400,300,0],&quot;ix&quot;:1},&quot;s&quot;:{&quot;a&quot;:0,&quot;k&quot;:[100,100,100],&quot;ix&quot;:6}},&quot;ao&quot;:0,&quot;shapes&quot;:[{&quot;ty&quot;:&quot;gr&quot;,&quot;it&quot;:[{&quot;ind&quot;:0,&quot;ty&quot;:&quot;sh&quot;,&quot;ix&quot;:1,&quot;ks&quot;:{&quot;a&quot;:0,&quot;k&quot;:{&quot;i&quot;:[[0,-9.389],[9.389,0],[0,9.389],[-9.389,0]],&quot;o&quot;:[[0,9.389],[-9.389,0],[0,-9.389],[9.389,0]],&quot;v&quot;:[[17,0],[0,17],[-17,0],[0,-17]],&quot;c&quot;:true},&quot;ix&quot;:2},&quot;nm&quot;:&quot;Path 1&quot;,&quot;mn&quot;:&quot;ADBE Vector Shape - Group&quot;,&quot;hd&quot;:false},{&quot;ty&quot;:&quot;tr&quot;,&quot;p&quot;:{&quot;a&quot;:0,&quot;k&quot;:[400,300],&quot;ix&quot;:2},&quot;a&quot;:{&quot;a&quot;:0,&quot;k&quot;:[0,0],&quot;ix&quot;:1},&quot;s&quot;:{&quot;a&quot;:0,&quot;k&quot;:[100,100],&quot;ix&quot;:3},&quot;r&quot;:{&quot;a&quot;:0,&quot;k&quot;:0,&quot;ix&quot;:6},&quot;o&quot;:{&quot;a&quot;:0,&quot;k&quot;:100,&quot;ix&quot;:7},&quot;sk&quot;:{&quot;a&quot;:0,&quot;k&quot;:0,&quot;ix&quot;:4},&quot;sa&quot;:{&quot;a&quot;:0,&quot;k&quot;:0,&quot;ix&quot;:5},&quot;nm&quot;:&quot;Transform&quot;}],&quot;nm&quot;:&quot;Group 2&quot;,&quot;np&quot;:2,&quot;cix&quot;:2,&quot;bm&quot;:0,&quot;ix&quot;:1,&quot;mn&quot;:&quot;ADBE Vector Group&quot;,&quot;hd&quot;:false},{&quot;ty&quot;:&quot;st&quot;,&quot;c&quot;:{&quot;a&quot;:0,&quot;k&quot;:[1,0.909803986549,0.862745165825,1],&quot;ix&quot;:3},&quot;o&quot;:{&quot;a&quot;:0,&quot;k&quot;:100,&quot;ix&quot;:4},&quot;w&quot;:{&quot;a&quot;:0,&quot;k&quot;:2,&quot;ix&quot;:5},&quot;lc&quot;:2,&quot;lj&quot;:2,&quot;bm&quot;:0,&quot;d&quot;:[{&quot;n&quot;:&quot;d&quot;,&quot;nm&quot;:&quot;dash&quot;,&quot;v&quot;:{&quot;a&quot;:0,&quot;k&quot;:21,&quot;ix&quot;:1}},{&quot;n&quot;:&quot;g&quot;,&quot;nm&quot;:&quot;gap&quot;,&quot;v&quot;:{&quot;a&quot;:0,&quot;k&quot;:29,&quot;ix&quot;:2}},{&quot;n&quot;:&quot;o&quot;,&quot;nm&quot;:&quot;offset&quot;,&quot;v&quot;:{&quot;a&quot;:0,&quot;k&quot;:52,&quot;ix&quot;:7}}],&quot;nm&quot;:&quot;Stroke 1&quot;,&quot;mn&quot;:&quot;ADBE Vector Graphic - Stroke&quot;,&quot;hd&quot;:false}],&quot;ip&quot;:0,&quot;op&quot;:361,&quot;st&quot;:0,&quot;bm&quot;:0},{&quot;ddd&quot;:0,&quot;ind&quot;:6,&quot;ty&quot;:4,&quot;nm&quot;:&quot;Layer 1 - Group 2&quot;,&quot;sr&quot;:1,&quot;ks&quot;:{&quot;o&quot;:{&quot;a&quot;:0,&quot;k&quot;:100,&quot;ix&quot;:11},&quot;r&quot;:{&quot;a&quot;:0,&quot;k&quot;:0,&quot;ix&quot;:10},&quot;p&quot;:{&quot;a&quot;:0,&quot;k&quot;:[400,300,0],&quot;ix&quot;:2},&quot;a&quot;:{&quot;a&quot;:0,&quot;k&quot;:[400,300,0],&quot;ix&quot;:1},&quot;s&quot;:{&quot;a&quot;:0,&quot;k&quot;:[100,100,100],&quot;ix&quot;:6}},&quot;ao&quot;:0,&quot;shapes&quot;:[{&quot;ty&quot;:&quot;gr&quot;,&quot;it&quot;:[{&quot;ind&quot;:0,&quot;ty&quot;:&quot;sh&quot;,&quot;ix&quot;:1,&quot;ks&quot;:{&quot;a&quot;:0,&quot;k&quot;:{&quot;i&quot;:[[0,-14.869],[14.869,0],[0,14.869],[-14.869,0]],&quot;o&quot;:[[0,14.869],[-14.869,0],[0,-14.869],[14.869,0]],&quot;v&quot;:[[26.923,0],[0,26.923],[-26.923,0],[0,-26.923]],&quot;c&quot;:true},&quot;ix&quot;:2},&quot;nm&quot;:&quot;Path 1&quot;,&quot;mn&quot;:&quot;ADBE Vector Shape - Group&quot;,&quot;hd&quot;:false},{&quot;ty&quot;:&quot;fl&quot;,&quot;c&quot;:{&quot;a&quot;:0,&quot;k&quot;:[0.082352941176,0.549019607843,0.870588235294,1],&quot;ix&quot;:4},&quot;o&quot;:{&quot;a&quot;:0,&quot;k&quot;:100,&quot;ix&quot;:5},&quot;r&quot;:1,&quot;bm&quot;:0,&quot;nm&quot;:&quot;Fill 1&quot;,&quot;mn&quot;:&quot;ADBE Vector Graphic - Fill&quot;,&quot;hd&quot;:false},{&quot;ty&quot;:&quot;tr&quot;,&quot;p&quot;:{&quot;a&quot;:0,&quot;k&quot;:[400,300],&quot;ix&quot;:2},&quot;a&quot;:{&quot;a&quot;:0,&quot;k&quot;:[0,0],&quot;ix&quot;:1},&quot;s&quot;:{&quot;a&quot;:0,&quot;k&quot;:[100,100],&quot;ix&quot;:3},&quot;r&quot;:{&quot;a&quot;:0,&quot;k&quot;:0,&quot;ix&quot;:6},&quot;o&quot;:{&quot;a&quot;:0,&quot;k&quot;:100,&quot;ix&quot;:7},&quot;sk&quot;:{&quot;a&quot;:0,&quot;k&quot;:0,&quot;ix&quot;:4},&quot;sa&quot;:{&quot;a&quot;:0,&quot;k&quot;:0,&quot;ix&quot;:5},&quot;nm&quot;:&quot;Transform&quot;}],&quot;nm&quot;:&quot;Group 2&quot;,&quot;np&quot;:2,&quot;cix&quot;:2,&quot;bm&quot;:0,&quot;ix&quot;:1,&quot;mn&quot;:&quot;ADBE Vector Group&quot;,&quot;hd&quot;:false}],&quot;ip&quot;:0,&quot;op&quot;:361,&quot;st&quot;:0,&quot;bm&quot;:0},{&quot;ddd&quot;:0,&quot;ind&quot;:8,&quot;ty&quot;:4,&quot;nm&quot;:&quot;Layer 1 - Group 4&quot;,&quot;sr&quot;:1,&quot;ks&quot;:{&quot;o&quot;:{&quot;a&quot;:0,&quot;k&quot;:100,&quot;ix&quot;:11},&quot;r&quot;:{&quot;a&quot;:0,&quot;k&quot;:0,&quot;ix&quot;:10},&quot;p&quot;:{&quot;a&quot;:0,&quot;k&quot;:[400,300,0],&quot;ix&quot;:2},&quot;a&quot;:{&quot;a&quot;:0,&quot;k&quot;:[400,300,0],&quot;ix&quot;:1},&quot;s&quot;:{&quot;a&quot;:0,&quot;k&quot;:[100,100,100],&quot;ix&quot;:6}},&quot;ao&quot;:0,&quot;shapes&quot;:[{&quot;ty&quot;:&quot;gr&quot;,&quot;it&quot;:[{&quot;ind&quot;:0,&quot;ty&quot;:&quot;sh&quot;,&quot;ix&quot;:1,&quot;ks&quot;:{&quot;a&quot;:0,&quot;k&quot;:{&quot;i&quot;:[[0,-38.66],[38.66,0],[0,38.66],[-38.66,0]],&quot;o&quot;:[[0,38.66],[-38.66,0],[0,-38.66],[38.66,0]],&quot;v&quot;:[[70,0],[0,70],[-70,0],[0,-70]],&quot;c&quot;:true},&quot;ix&quot;:2},&quot;nm&quot;:&quot;Path 1&quot;,&quot;mn&quot;:&quot;ADBE Vector Shape - Group&quot;,&quot;hd&quot;:false},{&quot;ty&quot;:&quot;fl&quot;,&quot;c&quot;:{&quot;a&quot;:0,&quot;k&quot;:[0.105882360421,0.231372563979,0.400000029919,1],&quot;ix&quot;:4},&quot;o&quot;:{&quot;a&quot;:0,&quot;k&quot;:100,&quot;ix&quot;:5},&quot;r&quot;:1,&quot;bm&quot;:0,&quot;nm&quot;:&quot;Fill 1&quot;,&quot;mn&quot;:&quot;ADBE Vector Graphic - Fill&quot;,&quot;hd&quot;:false},{&quot;ty&quot;:&quot;tr&quot;,&quot;p&quot;:{&quot;a&quot;:0,&quot;k&quot;:[400,300],&quot;ix&quot;:2},&quot;a&quot;:{&quot;a&quot;:0,&quot;k&quot;:[0,0],&quot;ix&quot;:1},&quot;s&quot;:{&quot;a&quot;:0,&quot;k&quot;:[100,100],&quot;ix&quot;:3},&quot;r&quot;:{&quot;a&quot;:0,&quot;k&quot;:0,&quot;ix&quot;:6},&quot;o&quot;:{&quot;a&quot;:0,&quot;k&quot;:100,&quot;ix&quot;:7},&quot;sk&quot;:{&quot;a&quot;:0,&quot;k&quot;:0,&quot;ix&quot;:4},&quot;sa&quot;:{&quot;a&quot;:0,&quot;k&quot;:0,&quot;ix&quot;:5},&quot;nm&quot;:&quot;Transform&quot;}],&quot;nm&quot;:&quot;Group 4&quot;,&quot;np&quot;:2,&quot;cix&quot;:2,&quot;bm&quot;:0,&quot;ix&quot;:1,&quot;mn&quot;:&quot;ADBE Vector Group&quot;,&quot;hd&quot;:false}],&quot;ip&quot;:0,&quot;op&quot;:361,&quot;st&quot;:0,&quot;bm&quot;:0}]}],&quot;layers&quot;:[{&quot;ddd&quot;:0,&quot;ind&quot;:1,&quot;ty&quot;:0,&quot;nm&quot;:&quot;Vinyl&quot;,&quot;refId&quot;:&quot;comp_0&quot;,&quot;sr&quot;:1,&quot;ks&quot;:{&quot;o&quot;:{&quot;a&quot;:0,&quot;k&quot;:100,&quot;ix&quot;:11},&quot;r&quot;:{&quot;a&quot;:0,&quot;k&quot;:0,&quot;ix&quot;:10},&quot;p&quot;:{&quot;a&quot;:0,&quot;k&quot;:[320,320,0],&quot;ix&quot;:2},&quot;a&quot;:{&quot;a&quot;:0,&quot;k&quot;:[400,300,0],&quot;ix&quot;:1},&quot;s&quot;:{&quot;a&quot;:0,&quot;k&quot;:[401,401,100],&quot;ix&quot;:6}},&quot;ao&quot;:0,&quot;w&quot;:800,&quot;h&quot;:600,&quot;ip&quot;:0,&quot;op&quot;:361,&quot;st&quot;:0,&quot;bm&quot;:0}],&quot;markers&quot;:[]}</file><file path="resources/app/ui/animations/vinyl-spin-animation/vinyl-spin-animation.tsx">import React, { useLayoutEffect, createRef } from &apos;react&apos;;
import lazyLottie from &apos;@/utils/lazy-lottie.ts&apos;;
interface VinylSpinAnimationProps extends React.HTMLProps&lt;HTMLElement&gt; {}
export function VinylSpinAnimation({ ...rest }: VinylSpinAnimationProps) {
  const ref = createRef&lt;HTMLElement&gt;();
  useLayoutEffect(() =&gt; {
    if (ref.current) {
      const animation = lazyLottie.loadAnimation({
        container: ref.current,
        path: new URL(&apos;./vinyl-spin-animation.json&apos;, import.meta.url).href,
      });
      return () =&gt; {
        animation.destroy();
      };
    }
  }, []);
  return (
    &lt;div
      // @ts-ignore
      ref={ref}
      {...rest}
    /&gt;
  );
}</file><file path="resources/app/ui/audio-stats/audio-stats.tsx">import React, { useEffect, useState, RefObject, useRef } from &apos;react&apos;;
import * as Accordion from &apos;@radix-ui/react-accordion&apos;;
import * as Separator from &apos;@radix-ui/react-separator&apos;;
let context: AudioContext | null = null;
let source: MediaElementAudioSourceNode | null = null;
export function getAudioContext() {
  if (!context) context = new AudioContext();
  return context;
}
export function getOrCreateSource(audio: HTMLMediaElement) {
  if (!source) {
    source = getAudioContext().createMediaElementSource(audio);
  }
  return source;
}
interface AudioStatsViewerProps {
  audioRef: RefObject&lt;HTMLAudioElement&gt;;
}
export const AudioStats: React.FC&lt;AudioStatsViewerProps&gt; = ({ audioRef }) =&gt; {
  const [stats, setStats] = useState&lt;any&gt;({});
  const [analyserData, setAnalyserData] = useState&lt;number[]&gt;([]);
  const audioContext = getAudioContext();
  const sourceNode = getOrCreateSource(audioRef.current);
  const analyserRef = useRef&lt;AnalyserNode | null&gt;(null);
  useEffect(() =&gt; {
    const audio = audioRef.current;
    if (!audio) return;
    const updateStats = () =&gt; {
      setStats({
        currentTime: audio.currentTime,
        duration: audio.duration,
        paused: audio.paused,
        volume: audio.volume,
        playbackRate: audio.playbackRate,
        buffered: audio.buffered.length ? audio.buffered.end(0) : 0,
        loop: audio.loop,
        muted: audio.muted,
        ended: audio.ended,
        readyState: audio.readyState,
        networkState: audio.networkState,
      });
    };
    audio.addEventListener(&apos;timeupdate&apos;, updateStats);
    audio.addEventListener(&apos;play&apos;, updateStats);
    audio.addEventListener(&apos;pause&apos;, updateStats);
    audio.addEventListener(&apos;volumechange&apos;, updateStats);
    audio.addEventListener(&apos;ended&apos;, updateStats);
    updateStats();
    if (!analyserRef.current) {
      analyserRef.current = audioContext.createAnalyser();
      analyserRef.current.fftSize = 64;
      sourceNode.connect(analyserRef.current);
      analyserRef.current.connect(audioContext.destination);
    }
    const dataArray = new Uint8Array(analyserRef.current.frequencyBinCount);
    const updateAnalyser = () =&gt; {
      if (analyserRef.current) {
        analyserRef.current.getByteFrequencyData(dataArray);
        setAnalyserData([...dataArray]);
      }
      requestAnimationFrame(updateAnalyser);
    };
    updateAnalyser();
    return () =&gt; {
      audio.removeEventListener(&apos;timeupdate&apos;, updateStats);
      audio.removeEventListener(&apos;play&apos;, updateStats);
      audio.removeEventListener(&apos;pause&apos;, updateStats);
      audio.removeEventListener(&apos;volumechange&apos;, updateStats);
      audio.removeEventListener(&apos;ended&apos;, updateStats);
    };
  }, [audioRef]);
  return (
    &lt;div style={{ padding: 16, borderRadius: 8, backgroundColor: &apos;var(--color-background)&apos; }}&gt;
      &lt;h2 style={{ fontSize: 20, fontWeight: &apos;bold&apos;, marginBottom: 16 }}&gt;Audio Stats Viewer&lt;/h2&gt;
      &lt;Accordion.Root type=&quot;multiple&quot; style={{ width: &apos;100%&apos; }}&gt;
        &lt;Accordion.Item value=&quot;audio-stats&quot;&gt;
          &lt;Accordion.Header&gt;
            &lt;Accordion.Trigger style={{ textAlign: &apos;left&apos;, fontWeight: 600, padding: 8, cursor: &apos;pointer&apos; }}&gt;
              Audio Element Stats
            &lt;/Accordion.Trigger&gt;
          &lt;/Accordion.Header&gt;
          &lt;Accordion.Content&gt;
            &lt;pre&gt;
              {JSON.stringify(stats, null, 2)}
            &lt;/pre&gt;
          &lt;/Accordion.Content&gt;
        &lt;/Accordion.Item&gt;
        &lt;Separator.Root style={{ backgroundColor: &apos;#ddd&apos;, height: 1, margin: &apos;12px 0&apos; }} /&gt;
        &lt;Accordion.Item value=&quot;frequency-data&quot;&gt;
          &lt;Accordion.Header&gt;
            &lt;Accordion.Trigger style={{ textAlign: &apos;left&apos;, fontWeight: 600, padding: 8, cursor: &apos;pointer&apos; }}&gt;
              Frequency Data (Analyser)
            &lt;/Accordion.Trigger&gt;
          &lt;/Accordion.Header&gt;
          &lt;Accordion.Content&gt;
            &lt;div style={{ marginTop: 24 }}&gt;
              &lt;h3 style={{ fontSize: 16, fontWeight: 600, marginBottom: 8 }}&gt;Live Frequency Line Graph&lt;/h3&gt;
              &lt;div
                style={{
                  position: &apos;relative&apos;,
                  width: &apos;100%&apos;,
                  height: 100,
                  border: &apos;1px solid #ddd&apos;,
                  background: &apos;#fafafa&apos;,
                }}
              &gt;
                {analyserData.map((value, i) =&gt; {
                  const x = (i / analyserData.length) * 100; // % from left
                  const y = 100 - (value / 255) * 100; // invert for top
                  return (
                    &lt;div
                      key={i}
                      style={{
                        position: &apos;absolute&apos;,
                        left: `${x}%`,
                        bottom: 0,
                        width: 2,
                        height: 100 - y + 1,
                        backgroundColor: &apos;var(--accent-10)&apos;,
                      }}
                    /&gt;
                  );
                })}
              &lt;/div&gt;
            &lt;/div&gt;
          &lt;/Accordion.Content&gt;
        &lt;/Accordion.Item&gt;
      &lt;/Accordion.Root&gt;
    &lt;/div&gt;
  );
};</file><file path="resources/app/ui/blur-hash/blur-hash.tsx">import { CSSProperties, HTMLAttributes, useEffect } from &apos;react&apos;;
import { BlurHashCanvas } from &apos;@/ui/blur-hash/blur-hash-canvas.tsx&apos;;
const canvasStyle: CSSProperties = {
  position: &apos;absolute&apos;,
  top: 0,
  bottom: 0,
  left: 0,
  right: 0,
}
export interface BlurHashProps extends HTMLAttributes&lt;HTMLDivElement&gt; {
  hash: string;
  resolutionY: number;
  resolutionX: number;
  height?: number;
  width?: number;
  punch?: number;
  style?: CSSProperties;
}
export function BlurHash({hash, height, width, punch, resolutionX, resolutionY, style, ...rest}: BlurHashProps) {
  useEffect(() =&gt; {
    if (resolutionX &amp;&amp; resolutionX &lt;= 0) {
      throw new Error(&apos;resolutionX must be greater than 0&apos;);
    }
    if (resolutionY &amp;&amp; resolutionY &lt;= 0) {
      throw new Error(&apos;resolutionY must be greater than 0&apos;);
    }
  }, [resolutionX, resolutionY]);
  return (
    &lt;div
      {...rest}
      style={{ display: &apos;inline-block&apos;, height, width, ...style, position: &apos;relative&apos; }}
    &gt;
      &lt;BlurHashCanvas
        hash={hash}
        height={resolutionY}
        width={resolutionX}
        punch={punch}
        style={canvasStyle}
        /&gt;
    &lt;/div&gt;
  )
}</file><file path="resources/app/ui/brand/Brand.tsx">import { ComponentPropsWithoutRef } from &apos;react&apos;;
import { Flex, Text } from &apos;@radix-ui/themes&apos;;
import { lazyImport } from &apos;@/utils/lazy-import.ts&apos;;
const { BaanderLogo } = lazyImport(() =&gt; import(&apos;@/ui/branding/baander-logo/baander-logo.tsx&apos;), &apos;BaanderLogo&apos;);
export interface BrandProps extends ComponentPropsWithoutRef&lt;&apos;div&apos;&gt; {
}
export function Brand({...rest}) {
  return (
    &lt;Flex {...rest}&gt;
      &lt;Flex align=&quot;center&quot; gap=&quot;2&quot;&gt;
        &lt;BaanderLogo /&gt;
        &lt;Text weight=&quot;medium&quot; size=&quot;3&quot;&gt;{import.meta.env.VITE_APP_NAME}&lt;/Text&gt;
      &lt;/Flex&gt;
    &lt;/Flex&gt;
  )
}</file><file path="resources/app/ui/branding/baander-logo/baander-logo.module.scss">.baanderLogo {
  width: 50px;
}</file><file path="resources/app/ui/branding/baander-logo/baander-logo.tsx">import LogoComponent from &apos;../../../assets/svg/baander-logo.svg?component&apos;;
import styles from &apos;./baander-logo.module.scss&apos;;
export function BaanderLogo() {
  return (
    &lt;&gt;
      &lt;LogoComponent className={styles.baanderLogo} height=&quot;50px&quot; /&gt;
    &lt;/&gt;
  )
}</file><file path="resources/app/ui/buttons/close-button.tsx">import { Button } from &apos;@radix-ui/themes&apos;;
import { Iconify } from &apos;@/ui/icons/iconify.tsx&apos;;
export interface CloseButtonProps {
  onClick?: () =&gt; void;
}
export function CloseButton({onClick}: CloseButtonProps) {
  return (
    &lt;Button onClick={onClick}&gt;
      &lt;Iconify icon=&quot;ion:close&quot; width=&quot;20&quot; height=&quot;20&quot; /&gt;
    &lt;/Button&gt;
  )
}</file><file path="resources/app/ui/carousel/carousel.scss">.embla {
  width: 100%;
  margin: auto;
  --slide-height: 19rem;
  --slide-spacing: 1rem;
  --slide-size: 10lh;
  --brand-primary: var(--accent-10);
  --brand-secondary: var(--accent-8);
  --brand-alternative: rgb(19, 120, 134);
  --background-site: rgb(249, 249, 249);
  --background-code: rgb(244, 244, 244);
  --text-body: #ccc;
  --text-comment: rgb(99, 94, 105);
  --text-high-contrast: rgb(49, 49, 49);
  --text-medium-contrast: rgb(99, 94, 105);
  --text-low-contrast: rgb(116, 109, 118);
  --detail-high-contrast: rgb(192, 192, 192);
  --detail-medium-contrast: rgb(234, 234, 234);
  --detail-low-contrast: rgb(240, 240, 242);
  --admonition-note: rgb(46, 109, 188);
  --admonition-warning: rgb(255, 196, 9);
  --admonition-danger: rgb(220, 38, 38);
  --brand-primary-rgb-value: 47, 112, 193;
  --brand-secondary-rgb-value: 116, 97, 195;
  --brand-alternative-rgb-value: 19, 120, 134;
  --background-site-rgb-value: 249, 249, 249;
  --background-code-rgb-value: 244, 244, 244;
  --text-body-rgb-value: 54, 49, 61;
  --text-comment-rgb-value: 99, 94, 105;
  --text-high-contrast-rgb-value: 49, 49, 49;
  --text-medium-contrast-rgb-value: 99, 94, 105;
  --text-low-contrast-rgb-value: 116, 109, 118;
  --detail-high-contrast-rgb-value: 192, 192, 192;
  --detail-medium-contrast-rgb-value: 234, 234, 234;
  --detail-low-contrast-rgb-value: 240, 240, 242;
  --admonition-note-rgb-value: 46, 109, 188;
  --admonition-warning-rgb-value: 255, 196, 9;
  --admonition-danger-rgb-value: 220, 38, 38;
}
.embla__viewport {
  overflow: hidden;
}
.embla__container {
  display: flex;
  touch-action: pan-y pinch-zoom;
  margin-left: calc(var(--slide-spacing) * -1);
}
.embla__slide {
  transform: translate3d(0, 0, 0);
  flex: 0 0 var(--slide-size);
  min-width: 0;
  padding-left: var(--slide-spacing);
}
.embla__slide__number {
  box-shadow: inset 0 0 0 0.2rem var(--detail-medium-contrast);
  border-radius: 1.8rem;
  font-size: 4rem;
  font-weight: 600;
  display: flex;
  align-items: center;
  justify-content: center;
  height: var(--slide-height);
  user-select: none;
}
.embla__controls {
  display: grid;
  grid-template-columns: auto 1fr;
  justify-content: space-between;
  gap: 1.2rem;
}
.embla__buttons {
  display: grid;
  grid-template-columns: repeat(2, 1fr);
  gap: 0.6rem;
  align-items: center;
}
.embla__button {
  -webkit-tap-highlight-color: rgba(49, 49, 49, 0.5);
  -webkit-appearance: none;
  appearance: none;
  background-color: transparent;
  touch-action: manipulation;
  display: inline-flex;
  text-decoration: none;
  cursor: pointer;
  border: 0;
  padding: 0;
  margin: 0;
  width: 3rem;
  height: 3rem;
  z-index: 1;
  border-radius: 50%;
  color: var(--accent-10);
  display: flex;
  align-items: center;
  justify-content: center;
}
.embla__button:disabled {
  color: var(--detail-high-contrast);
}
.embla__button__svg {
  width: 35%;
  height: 35%;
}
.embla__dots {
  display: flex;
  flex-wrap: wrap;
  justify-content: flex-end;
  align-items: center;
  margin-right: calc((2.6rem - 1.4rem) / 2 * -1);
}
.embla__dot {
  -webkit-tap-highlight-color: rgba(var(--text-high-contrast-rgb-value), 0.5);
  -webkit-appearance: none;
  appearance: none;
  background-color: transparent;
  touch-action: manipulation;
  display: inline-flex;
  text-decoration: none;
  cursor: pointer;
  border: 0;
  padding: 0;
  margin: 0;
  width: 1.2rem;
  height: 1.2rem;
  display: flex;
  align-items: center;
  justify-content: center;
  border-radius: 50%;
}
.embla__dot:after {
  box-shadow: inset 0 0 0 0.05rem var(--detail-medium-contrast);
  width: 1rem;
  height: 1rem;
  border-radius: 50%;
  display: flex;
  align-items: center;
  content: &apos;&apos;;
}
.embla__dot--selected:after {
  box-shadow: inset 0 0 0 0.05rem var(--text-body);
}</file><file path="resources/app/ui/carousel/components/arrow-buttons.tsx">import React, {
  ComponentPropsWithRef,
  useCallback,
  useEffect,
  useState
} from &apos;react&apos;
import { EmblaCarouselType } from &apos;embla-carousel&apos;
type UsePrevNextButtonsType = {
  prevBtnDisabled: boolean
  nextBtnDisabled: boolean
  onPrevButtonClick: () =&gt; void
  onNextButtonClick: () =&gt; void
}
export const usePrevNextButtons = (
  emblaApi: EmblaCarouselType | undefined
): UsePrevNextButtonsType =&gt; {
  const [prevBtnDisabled, setPrevBtnDisabled] = useState(true)
  const [nextBtnDisabled, setNextBtnDisabled] = useState(true)
  const onPrevButtonClick = useCallback(() =&gt; {
    if (!emblaApi) return
    emblaApi.scrollPrev()
  }, [emblaApi])
  const onNextButtonClick = useCallback(() =&gt; {
    if (!emblaApi) return
    emblaApi.scrollNext()
  }, [emblaApi])
  const onSelect = useCallback((emblaApi: EmblaCarouselType) =&gt; {
    setPrevBtnDisabled(!emblaApi.canScrollPrev())
    setNextBtnDisabled(!emblaApi.canScrollNext())
  }, [])
  useEffect(() =&gt; {
    if (!emblaApi) return
    onSelect(emblaApi)
    emblaApi.on(&apos;reInit&apos;, onSelect).on(&apos;select&apos;, onSelect)
  }, [emblaApi, onSelect])
  return {
    prevBtnDisabled,
    nextBtnDisabled,
    onPrevButtonClick,
    onNextButtonClick
  }
}
type PropType = ComponentPropsWithRef&lt;&apos;button&apos;&gt;
export const PrevButton: React.FC&lt;PropType&gt; = (props) =&gt; {
  const { children, ...restProps } = props
  return (
    &lt;button
      className=&quot;embla__button embla__button--prev&quot;
      type=&quot;button&quot;
      {...restProps}
    &gt;
      &lt;svg className=&quot;embla__button__svg&quot; viewBox=&quot;0 0 532 532&quot;&gt;
        &lt;path
          fill=&quot;currentColor&quot;
          d=&quot;M355.66 11.354c13.793-13.805 36.208-13.805 50.001 0 13.785 13.804 13.785 36.238 0 50.034L201.22 266l204.442 204.61c13.785 13.805 13.785 36.239 0 50.044-13.793 13.796-36.208 13.796-50.002 0a5994246.277 5994246.277 0 0 0-229.332-229.454 35.065 35.065 0 0 1-10.326-25.126c0-9.2 3.393-18.26 10.326-25.2C172.192 194.973 332.731 34.31 355.66 11.354Z&quot;
        /&gt;
      &lt;/svg&gt;
      {children}
    &lt;/button&gt;
  )
}
export const NextButton: React.FC&lt;PropType&gt; = (props) =&gt; {
  const { children, ...restProps } = props
  return (
    &lt;button
      className=&quot;embla__button embla__button--next&quot;
      type=&quot;button&quot;
      {...restProps}
    &gt;
      &lt;svg className=&quot;embla__button__svg&quot; viewBox=&quot;0 0 532 532&quot;&gt;
        &lt;path
          fill=&quot;currentColor&quot;
          d=&quot;M176.34 520.646c-13.793 13.805-36.208 13.805-50.001 0-13.785-13.804-13.785-36.238 0-50.034L330.78 266 126.34 61.391c-13.785-13.805-13.785-36.239 0-50.044 13.793-13.796 36.208-13.796 50.002 0 22.928 22.947 206.395 206.507 229.332 229.454a35.065 35.065 0 0 1 10.326 25.126c0 9.2-3.393 18.26-10.326 25.2-45.865 45.901-206.404 206.564-229.332 229.52Z&quot;
        /&gt;
      &lt;/svg&gt;
      {children}
    &lt;/button&gt;
  )
}</file><file path="resources/app/ui/carousel/components/dot-button.tsx">import React, {
  ComponentPropsWithRef,
  useCallback,
  useEffect,
  useState
} from &apos;react&apos;
import { EmblaCarouselType } from &apos;embla-carousel&apos;
type UseDotButtonType = {
  selectedIndex: number
  scrollSnaps: number[]
  onDotButtonClick: (index: number) =&gt; void
}
export const useDotButton = (
  emblaApi: EmblaCarouselType | undefined
): UseDotButtonType =&gt; {
  const [selectedIndex, setSelectedIndex] = useState(0)
  const [scrollSnaps, setScrollSnaps] = useState&lt;number[]&gt;([])
  const onDotButtonClick = useCallback(
    (index: number) =&gt; {
      if (!emblaApi) return
      emblaApi.scrollTo(index)
    },
    [emblaApi]
  )
  const onInit = useCallback((emblaApi: EmblaCarouselType) =&gt; {
    setScrollSnaps(emblaApi.scrollSnapList())
  }, [])
  const onSelect = useCallback((emblaApi: EmblaCarouselType) =&gt; {
    setSelectedIndex(emblaApi.selectedScrollSnap())
  }, [])
  useEffect(() =&gt; {
    if (!emblaApi) return
    onInit(emblaApi)
    onSelect(emblaApi)
    emblaApi.on(&apos;reInit&apos;, onInit).on(&apos;reInit&apos;, onSelect).on(&apos;select&apos;, onSelect)
  }, [emblaApi, onInit, onSelect])
  return {
    selectedIndex,
    scrollSnaps,
    onDotButtonClick
  }
}
type PropType = ComponentPropsWithRef&lt;&apos;button&apos;&gt;
export const DotButton: React.FC&lt;PropType&gt; = (props) =&gt; {
  const { children, ...restProps } = props
  return (
    &lt;button type=&quot;button&quot; {...restProps}&gt;
      {children}
    &lt;/button&gt;
  )
}</file><file path="resources/app/ui/icons/iconify.tsx">import { Icon, IconProps } from &apos;@iconify/react&apos;;
export interface IconifyProps extends IconProps {
}
export function Iconify({...props}: IconifyProps) {
  // @ts-ignore
  return &lt;Icon {...props} /&gt;
}</file><file path="resources/app/ui/icons/libary.tsx">import { Iconify } from &apos;@/ui/icons/iconify.tsx&apos;;
export function LyricsIcon() {
  return &lt;Iconify icon=&quot;arcticons:quicklyric&quot; /&gt;
}</file><file path="resources/app/ui/icons/player.tsx">import { Iconify, IconifyProps } from &apos;@/ui/icons/iconify.tsx&apos;;
export interface PlayerIconProps extends Omit&lt;IconifyProps, &apos;icon&apos;&gt; {
}
export function PlayerPlayIcon({...props}: PlayerIconProps) {
  return &lt;Iconify icon=&quot;entypo:controller-play&quot; {...props} /&gt;
}
export function PlayerPauseIcon({...props}: PlayerIconProps) {
  return &lt;Iconify icon=&quot;entypo:controller-paus&quot; {...props} /&gt;
}
export function PlayerNextIcon({...props}: PlayerIconProps) {
  return &lt;Iconify icon=&quot;entypo:controller-next&quot; {...props} /&gt;
}
export function PlayerPreviousIcon({...props}: PlayerIconProps) {
  return &lt;Iconify icon=&quot;entypo:controller-jump-to-start&quot; {...props} /&gt;
}
export function PlayerKaraokeIcon({...props}: PlayerIconProps) {
  return &lt;Iconify icon=&quot;maki:karaoke&quot; {...props} /&gt;
}
export function PlayerWaveFormIcon({...props}: PlayerIconProps) {
  return &lt;Iconify icon=&quot;ph:waveform&quot; {...props} /&gt;
}
export function PlayerWaveFormSlashIcon({...props}: PlayerIconProps) {
  return &lt;Iconify icon=&quot;ph:waveform-slash&quot; {...props} /&gt;
}
export function PlayerVolumeMutedIcon({...props}: PlayerIconProps) {
  return &lt;Iconify icon=&quot;raphael:volume0&quot; {...props} /&gt;
}
export function PlayerVolumeMediumIcon({...props}: PlayerIconProps) {
  return &lt;Iconify icon=&quot;raphael:volume1&quot; {...props} /&gt;
}
export function PlayerVolumeLevelHighIcon({...props}: PlayerIconProps) {
  return &lt;Iconify icon=&quot;raphael:volume2&quot; {...props} /&gt;
}
export function PlayerVolumeLevelFullIcon({...props}: PlayerIconProps) {
  return &lt;Iconify icon=&quot;raphael:volume3&quot; {...props} /&gt;
}</file><file path="resources/app/ui/lyrics-viewer/components/lyrics-animation/lyrics-animation.module.scss">.lyricLine {
  width: 97%;
  text-align: center;
  position: absolute;
  padding: 12px;
  margin-left: 8px;
  margin-right: 8px;
  background-color: rgba(0, 0, 0, .25);
  border-radius: 12px;
  color: #e3e3e3;
  font-weight: var(--font-weight-bold);
}
.currentLyric {
  top: 40%; /* Center the current lyric */
  left: 0;
  transform: translateY(-50%);
  font-size: var(--font-size-6);
}
.nextLyric {
  top: 60%; /* Place next lyric below current lyric */
  left: 0;
  transform: translateY(-50%);
  color: #e3e3e3;
  font-size: var(--font-size-3);
}</file><file path="resources/app/ui/lyrics-viewer/components/lyrics-animation/lyrics-animation.tsx">import React, { useEffect, useState } from &apos;react&apos;;
import { AnimatePresence, motion } from &apos;motion/react&apos;;
import { useLyrics } from &apos;@/ui/lyrics-viewer/providers/lyrics-provider.tsx&apos;;
import { Box } from &apos;@radix-ui/themes&apos;;
import styles from &apos;./lyrics-animation.module.scss&apos;;
interface LyricsAnimationProps {
  currentTime: number;
}
export const LyricsAnimation: React.FC&lt;LyricsAnimationProps&gt; = ({ currentTime }) =&gt; {
  const { synchronizer } = useLyrics();
  const [currentLyric, setCurrentLyric] = useState&lt;string&gt;(&apos;&apos;);
  const [nextLyric, setNextLyric] = useState&lt;string&gt;(&apos;&apos;);
  useEffect(() =&gt; {
    if (currentTime &amp;&amp; synchronizer) {
      const current = synchronizer.current();
      setCurrentLyric(current?.content ?? &apos;&apos;);
      const next = synchronizer.next();
      setNextLyric(next?.content ?? &apos;&apos;);
    }
  }, [currentTime, synchronizer]);
  return (
    &lt;Box width=&quot;inherit&quot; className={styles.lyricContainer}&gt;
      &lt;AnimatePresence mode=&quot;sync&quot;&gt;
        {currentLyric &amp;&amp; (
          &lt;motion.p
            className={`${styles.lyricLine} ${styles.currentLyric}`}
            initial={{ opacity: 0, y: 20 }}
            animate={{ opacity: 1, y: 0 }}
            exit={{ opacity: 0, y: -20 }}
            transition={{ duration: 0.5 }}
            key={currentLyric}
          &gt;
            {currentLyric}
          &lt;/motion.p&gt;
        )}
      &lt;/AnimatePresence&gt;
      {nextLyric &amp;&amp; (
        &lt;motion.p
          className={`${styles.lyricLine} ${styles.nextLyric}`}
          initial={{ opacity: 0, y: 40 }}
          animate={{ opacity: 0.5, y: 20 }}
          transition={{ duration: 0.5 }}
          key={nextLyric}
        &gt;
          {nextLyric}
        &lt;/motion.p&gt;
      )}
    &lt;/Box&gt;
  );
};</file><file path="resources/app/ui/lyrics-viewer/components/lyrics-settings/lyrics-settings.module.scss">.form {
  display: flex;
  flex-direction: column;
  margin-top: 1ch;
}
.field {
  display: flex;
  flex-direction: column;
  margin-bottom: 1ch;
}</file><file path="resources/app/ui/lyrics-viewer/components/lyrics-settings/lyrics-settings.tsx">import { Box, Button, Text } from &apos;@radix-ui/themes&apos;;
import { SubmitHandler, useForm } from &apos;react-hook-form&apos;;
import { useAppDispatch, useAppSelector } from &apos;@/store/hooks.ts&apos;;
import { setLyricsOffset } from &apos;@/store/music/music-player-slice.ts&apos;;
import styles from &apos;./lyrics-settings.module.scss&apos;;
interface LyricsSettingsForm {
  offset: number;
}
export function LyricsSettings() {
  const { lyrics } = useAppSelector(state =&gt; state.musicPlayer);
  const dispatch = useAppDispatch();
  const {
    register,
    handleSubmit,
    formState: { errors },
  } = useForm&lt;LyricsSettingsForm&gt;({
    defaultValues: {
      offset: lyrics.offsetMs,
    },
  });
  const onSubmit: SubmitHandler&lt;LyricsSettingsForm&gt; = (data) =&gt; {
    dispatch(setLyricsOffset({ ms: data.offset }));
  };
  return (
    &lt;Box&gt;
      &lt;Text weight=&quot;bold&quot;&gt;Lyrics settings&lt;/Text&gt;
      &lt;form
        className={styles.form}
        onSubmit={handleSubmit(onSubmit)}
      &gt;
        &lt;div className={styles.field}&gt;
          &lt;label&gt;Offset (ms)&lt;/label&gt;
          &lt;input
            type=&quot;number&quot;
            {...register(&apos;offset&apos;, { valueAsNumber: true })}
          /&gt;
          {errors.offset &amp;&amp; &lt;span&gt;Offset must be a number&lt;/span&gt;}
        &lt;/div&gt;
        &lt;Button type=&quot;submit&quot;&gt;
          Save
        &lt;/Button&gt;
      &lt;/form&gt;
    &lt;/Box&gt;
  );
}</file><file path="resources/app/ui/schema/rng-visualizer/constants.ts">export const attributeDefinitions: { [key: string]: string } = {
  id: &apos;The unique identifier for this entity.&apos;,
  name: &apos;The name of the entity.&apos;,
  sortName: &apos;The name by which the artist is sorted.&apos;,
  gender: &quot;The gender of the artist. Possible values are &apos;male&apos;, &apos;female&apos;, or &apos;other&apos;.&quot;,
  country: &apos;The country associated with the artist.&apos;,
  disambiguation: &apos;Additional information to disambiguate the artist from others with similar names.&apos;,
  title: &apos;The title of the release.&apos;,
  releaseDate: &apos;The release date of the album in ISO 8601 format.&apos;,
  artist: &apos;The artist or group who recorded the album.&apos;,
  barcode: &apos;The barcode of the release.&apos;,
  status: &apos;The status of the release (e.g., official, promotion, bootleg).&apos;,
  packaging: &apos;The type of packaging used for the release.&apos;,
  language: &apos;The language in which the release is primarily recorded.&apos;,
  trackID: &apos;The unique identifier for the track.&apos;,
  trackNumber: &apos;The track number on the release.&apos;,
  trackTitle: &apos;The title of the track.&apos;,
  trackLength: &apos;The duration of the track in milliseconds.&apos;,
  labelID: &apos;The unique identifier for the label.&apos;,
  labelName: &apos;The name of the label.&apos;,
  labelCode: &apos;The label code (a unique identifier assigned to a record label).&apos;,
  recordingID: &apos;The unique identifier for the recording.&apos;,
  recordingTitle: &apos;The title of the recording.&apos;,
  recordingLength: &apos;The duration of the recording in milliseconds.&apos;,
  workID: &apos;The unique identifier for the work.&apos;,
  workTitle: &apos;The title of the work.&apos;,
  workType: &apos;The type of work (e.g., song, symphony).&apos;,
  workLanguage: &apos;The language of the work.&apos;,
  url: &apos;The URL related to the entity.&apos;,
  urlType: &apos;The type of relationship the URL has to the entity (e.g., official homepage, discography).&apos;,
  eventID: &apos;The unique identifier for the event.&apos;,
  eventDate: &apos;The date of the event in ISO 8601 format.&apos;,
  eventName: &apos;The name of the event.&apos;,
  eventType: &apos;The type of event (e.g., concert, festival).&apos;,
  eventLocation: &apos;The location of the event.&apos;,
  areaID: &apos;The unique identifier for the area.&apos;,
  areaName: &apos;The name of the area (e.g., a country, city).&apos;,
  areaType: &apos;The type of area (e.g., country, city, subdivision).&apos;,
  genreID: &apos;The unique identifier for the genre.&apos;,
  genreName: &apos;The name of the genre.&apos;,
  comment: &apos;A comment or annotation for the entity.&apos;,
  alias: &apos;An alternative name or spelling for the entity.&apos;,
  beginDate: &apos;The date when the entity began.&apos;,
  endDate: &apos;The date when the entity ended.&apos;,
  lifespan: &apos;The lifespan of the entity (begin and end dates).&apos;,
};</file><file path="resources/app/ui/schema/rng-visualizer/rng-visualizer.scss">.links line {
  stroke: #999;
  stroke-opacity: 0.6;
  stroke-width: 1.5px;
}
.nodes rect {
  rx: 6px;
  ry: 6px;
  cursor: pointer;
}</file><file path="resources/app/ui/side-nav/side-nav.tsx">import { PropsWithChildren } from &apos;react&apos;;
import { Box, ScrollArea } from &apos;@radix-ui/themes&apos;;
import { RemoveScroll } from &apos;react-remove-scroll&apos;;
export function SideNav({ children }: PropsWithChildren) {
  return (
    &lt;Box
      display={{ initial: &apos;none&apos;, md: &apos;block&apos; }}
      style={{ width: 250, flexShrink: 0 }}
      className={RemoveScroll.classNames.zeroRight}
    &gt;
      &lt;ScrollArea&gt;{children}&lt;/ScrollArea&gt;
    &lt;/Box&gt;
  );
}</file><file path="resources/app/ui/toast/_imperative.tsx">import { useState, forwardRef, useImperativeHandle } from &apos;react&apos;;
import { Toast as AppToast, ToastProps } from &apos;./toast.tsx&apos;;
interface ToastImperativeHandle {
  publish: () =&gt; void;
}
export const Toast = forwardRef&lt;ToastImperativeHandle, ToastProps&gt;((props, forwardedRef) =&gt; {
  const { children, ...toastProps } = props;
  const [count, setCount] = useState(0);
  useImperativeHandle(forwardedRef, () =&gt; ({
    publish: () =&gt; setCount((count) =&gt; count + 1),
  }));
  return (
    &lt;&gt;
      {Array.from({ length: count }).map((_, index) =&gt; (
        &lt;AppToast key={index} {...toastProps}&gt;
          {children}
        &lt;/AppToast&gt;
      ))}
    &lt;/&gt;
  );
});</file><file path="resources/app/ui/toast/toast.tsx">import { ReactNode } from &apos;react&apos;;
import { Toast as ToastPrimitive } from &apos;radix-ui&apos;;
import { ToastProps as ToastPrimitiveProps } from &apos;@radix-ui/react-toast&apos;;
export interface ToastPropsBase extends ToastPrimitiveProps {
  actionAltText?: string;
  children?: ReactNode;
}
export interface ToastPropsWithAction extends ToastPrimitiveProps {
  actionAltText: string;
  children: ReactNode;
}
export type ToastProps = ToastPropsBase | ToastPropsWithAction;
export function Toast({ title, content, children, actionAltText, ...rest }: ToastProps) {
  if (children &amp;&amp; !actionAltText) {
    console.error(&apos;Toast: `actionAltText` is required when `children` is provided. We will make a false value so the ui doesnt break.&apos;);
    actionAltText = `${title} action button`
  }
  return (
    &lt;ToastPrimitive.Root {...rest}&gt;
      {title &amp;&amp; &lt;ToastPrimitive.Title&gt;{title}&lt;/ToastPrimitive.Title&gt;}
      &lt;ToastPrimitive.Description&gt;{content}&lt;/ToastPrimitive.Description&gt;
      {children &amp;&amp; actionAltText &amp;&amp; (
        &lt;ToastPrimitive.Action altText={actionAltText} asChild&gt;{children}&lt;/ToastPrimitive.Action&gt;
      )}
      &lt;ToastPrimitive.Close aria-label=&quot;Close&quot;&gt;
        &lt;span aria-hidden&gt;×&lt;/span&gt;
      &lt;/ToastPrimitive.Close&gt;
    &lt;/ToastPrimitive.Root&gt;
  );
}</file><file path="resources/app/utils/assert/is-defined.ts">export function assertIsDefined&lt;T&gt;(val: T, paramName: string): asserts val is NonNullable&lt;T&gt; {
  if (val === undefined || val === null) {
    throw new Error(`Parameter &quot;${paramName}&quot; is required but not found`);
  }
}</file><file path="resources/app/utils/is-promise.ts">export function isPromise(v: unknown): v is Promise&lt;unknown&gt; {
  // @ts-ignore
  return v !== null &amp;&amp; Boolean(v &amp;&amp; typeof v.then === &apos;function&apos;);
}</file><file path="resources/app/utils/lazy-import.ts">import * as React from &apos;react&apos;;
// named imports for React.lazy: https://github.com/facebook/react/issues/14603#issuecomment-726551598
export function lazyImport&lt;
  T extends React.ComponentType&lt;any&gt;,
  I extends { [K2 in K]: T },
  K extends keyof I
&gt;(factory: () =&gt; Promise&lt;I&gt;, name: K): I {
  return Object.create({
    [name]: React.lazy(() =&gt; factory().then((module) =&gt; ({ default: module[name] }))),
  });
}
// Usage
// const { Home } = lazyImport(() =&gt; import(&quot;./Home&quot;), &quot;Home&quot;);</file><file path="resources/app/utils/noop.ts">export const noop = () =&gt; void 0;</file><file path="resources/app/utils/testing/generateMockDataFromType.ts">type MockDataGenerator&lt;T&gt; = {
  [K in keyof T]: T[K] extends string
                  ? string
                  : T[K] extends number
                    ? number
                    : T[K] extends boolean
                      ? boolean
                      : T[K] extends Array&lt;infer U&gt;
                        ? U extends object
                          ? MockDataGenerator&lt;U&gt;[] // Handle arrays of objects
                          : U[] // Handle arrays of primitives (e.g., string[], number[], etc.)
                        : T[K] extends object
                          ? MockDataGenerator&lt;T[K]&gt;
                          : any; // Fallback for other types
};
export function generateMockDataFromType&lt;T&gt;(type: T): MockDataGenerator&lt;T&gt; {
  const mockData: any = {};
  for (const key in type) {
    if (typeof type[key] === &apos;string&apos;) {
      mockData[key] = `Test ${key}`;
    } else if (typeof type[key] === &apos;number&apos;) {
      mockData[key] = 0;
    } else if (typeof type[key] === &apos;boolean&apos;) {
      mockData[key] = false;
    } else if (Array.isArray(type[key])) {
      // Handle arrays of primitives (e.g., string[], number[], etc.)
      const arrayType = (type[key] as any)[0]; // Get the type of the array elements
      if (typeof arrayType === &apos;string&apos;) {
        mockData[key] = [`Test ${key}`]; // Generate a single test string for string arrays
      } else if (typeof arrayType === &apos;number&apos;) {
        mockData[key] = [0]; // Generate a single test number for number arrays
      } else if (typeof arrayType === &apos;boolean&apos;) {
        mockData[key] = [false]; // Generate a single test boolean for boolean arrays
      } else if (typeof arrayType === &apos;object&apos;) {
        mockData[key] = [generateMockDataFromType(arrayType)]; // Handle arrays of objects
      } else {
        mockData[key] = []; // Fallback for unknown types
      }
    } else if (typeof type[key] === &apos;object&apos;) {
      mockData[key] = generateMockDataFromType(type[key]);
    } else {
      mockData[key] = null; // Fallback for other types
    }
  }
  return mockData;
}</file><file path="resources/app/utils/time/format-duration.ts">export function formatDuration(duration: number | string) {
  if (typeof duration === &apos;string&apos;) {
    duration = Number(duration);
  }
  const min = Math.floor(duration / 60);
  const sec = Math.floor(duration - min * 60);
  // format - mm:ss
  return [min, sec].map((n) =&gt; (n &lt; 10 ? &apos;0&apos; + n : n)).join(&apos;:&apos;);
}</file><file path="resources/app/ziggy.d.ts">/* This file is generated by Ziggy. */
declare module &apos;ziggy-js&apos; {
  interface RouteList {
    &quot;waterline.stats.index&quot;: [],
    &quot;waterline.completed&quot;: [],
    &quot;waterline.failed&quot;: [],
    &quot;waterline.running&quot;: [],
    &quot;waterline.show&quot;: [
        {
            &quot;name&quot;: &quot;id&quot;,
            &quot;required&quot;: true
        }
    ],
    &quot;waterline.index&quot;: [
        {
            &quot;name&quot;: &quot;view&quot;,
            &quot;required&quot;: false
        }
    ],
    &quot;horizon.stats.index&quot;: [],
    &quot;horizon.workload.index&quot;: [],
    &quot;horizon.masters.index&quot;: [],
    &quot;horizon.monitoring.index&quot;: [],
    &quot;horizon.monitoring.store&quot;: [],
    &quot;horizon.monitoring-tag.paginate&quot;: [
        {
            &quot;name&quot;: &quot;tag&quot;,
            &quot;required&quot;: true
        }
    ],
    &quot;horizon.monitoring-tag.destroy&quot;: [
        {
            &quot;name&quot;: &quot;tag&quot;,
            &quot;required&quot;: true
        }
    ],
    &quot;horizon.jobs-metrics.index&quot;: [],
    &quot;horizon.jobs-metrics.show&quot;: [
        {
            &quot;name&quot;: &quot;id&quot;,
            &quot;required&quot;: true
        }
    ],
    &quot;horizon.queues-metrics.index&quot;: [],
    &quot;horizon.queues-metrics.show&quot;: [
        {
            &quot;name&quot;: &quot;id&quot;,
            &quot;required&quot;: true
        }
    ],
    &quot;horizon.jobs-batches.index&quot;: [],
    &quot;horizon.jobs-batches.show&quot;: [
        {
            &quot;name&quot;: &quot;id&quot;,
            &quot;required&quot;: true
        }
    ],
    &quot;horizon.jobs-batches.retry&quot;: [
        {
            &quot;name&quot;: &quot;id&quot;,
            &quot;required&quot;: true
        }
    ],
    &quot;horizon.pending-jobs.index&quot;: [],
    &quot;horizon.completed-jobs.index&quot;: [],
    &quot;horizon.silenced-jobs.index&quot;: [],
    &quot;horizon.failed-jobs.index&quot;: [],
    &quot;horizon.failed-jobs.show&quot;: [
        {
            &quot;name&quot;: &quot;id&quot;,
            &quot;required&quot;: true
        }
    ],
    &quot;horizon.retry-jobs.show&quot;: [
        {
            &quot;name&quot;: &quot;id&quot;,
            &quot;required&quot;: true
        }
    ],
    &quot;horizon.jobs.show&quot;: [
        {
            &quot;name&quot;: &quot;id&quot;,
            &quot;required&quot;: true
        }
    ],
    &quot;horizon.index&quot;: [
        {
            &quot;name&quot;: &quot;view&quot;,
            &quot;required&quot;: false
        }
    ],
    &quot;pulse&quot;: [],
    &quot;sanctum.csrf-cookie&quot;: [],
    &quot;livewire.update&quot;: [],
    &quot;livewire.upload-file&quot;: [],
    &quot;livewire.preview-file&quot;: [
        {
            &quot;name&quot;: &quot;filename&quot;,
            &quot;required&quot;: true
        }
    ],
    &quot;ignition.healthCheck&quot;: [],
    &quot;ignition.executeSolution&quot;: [],
    &quot;ignition.updateConfig&quot;: [],
    &quot;mailbook.dashboard&quot;: [],
    &quot;mailbook.content&quot;: [],
    &quot;mailbook.send&quot;: [],
    &quot;telescope&quot;: [
        {
            &quot;name&quot;: &quot;view&quot;,
            &quot;required&quot;: false
        }
    ],
    &quot;api.album.artwork.cover&quot;: [
        {
            &quot;name&quot;: &quot;album&quot;,
            &quot;required&quot;: true
        }
    ],
    &quot;api.artist.artwork.portrait&quot;: [
        {
            &quot;name&quot;: &quot;artist&quot;,
            &quot;required&quot;: true,
            &quot;binding&quot;: &quot;id&quot;
        }
    ],
    &quot;api.image.serve&quot;: [
        {
            &quot;name&quot;: &quot;image&quot;,
            &quot;required&quot;: true,
            &quot;binding&quot;: &quot;id&quot;
        }
    ],
    &quot;api.song.stream.direct&quot;: [
        {
            &quot;name&quot;: &quot;song&quot;,
            &quot;required&quot;: true,
            &quot;binding&quot;: &quot;id&quot;
        }
    ],
    &quot;restify.api.search&quot;: [],
    &quot;restify.api.profile&quot;: [],
    &quot;restify.api.profile.updatePut&quot;: [],
    &quot;restify.api.profile.updatePost&quot;: [],
    &quot;restify.api.restifyjs.setup&quot;: [],
    &quot;restify.api.filters.index&quot;: [
        {
            &quot;name&quot;: &quot;repository&quot;,
            &quot;required&quot;: true
        }
    ],
    &quot;restify.api.filters.apply&quot;: [
        {
            &quot;name&quot;: &quot;repository&quot;,
            &quot;required&quot;: true
        }
    ],
    &quot;restify.api.actions.index&quot;: [
        {
            &quot;name&quot;: &quot;repository&quot;,
            &quot;required&quot;: true
        }
    ],
    &quot;restify.api.actions.repository.index&quot;: [
        {
            &quot;name&quot;: &quot;repository&quot;,
            &quot;required&quot;: true
        },
        {
            &quot;name&quot;: &quot;repositoryId&quot;,
            &quot;required&quot;: true
        }
    ],
    &quot;restify.api.actions.perform&quot;: [
        {
            &quot;name&quot;: &quot;repository&quot;,
            &quot;required&quot;: true
        }
    ],
    &quot;restify.api.actions.performs&quot;: [
        {
            &quot;name&quot;: &quot;repository&quot;,
            &quot;required&quot;: true
        }
    ],
    &quot;restify.api.actions.repository.perform&quot;: [
        {
            &quot;name&quot;: &quot;repository&quot;,
            &quot;required&quot;: true
        },
        {
            &quot;name&quot;: &quot;repositoryId&quot;,
            &quot;required&quot;: true
        }
    ],
    &quot;restify.api.actions.repository.performs&quot;: [
        {
            &quot;name&quot;: &quot;repository&quot;,
            &quot;required&quot;: true
        },
        {
            &quot;name&quot;: &quot;repositoryId&quot;,
            &quot;required&quot;: true
        }
    ],
    &quot;restify.api.getters.index&quot;: [
        {
            &quot;name&quot;: &quot;repository&quot;,
            &quot;required&quot;: true
        }
    ],
    &quot;restify.api.getters.repository.index&quot;: [
        {
            &quot;name&quot;: &quot;repository&quot;,
            &quot;required&quot;: true
        },
        {
            &quot;name&quot;: &quot;repositoryId&quot;,
            &quot;required&quot;: true
        }
    ],
    &quot;restify.api.getters.perform&quot;: [
        {
            &quot;name&quot;: &quot;repository&quot;,
            &quot;required&quot;: true
        },
        {
            &quot;name&quot;: &quot;getter&quot;,
            &quot;required&quot;: true
        }
    ],
    &quot;restify.api.getters.repository.perform&quot;: [
        {
            &quot;name&quot;: &quot;repository&quot;,
            &quot;required&quot;: true
        },
        {
            &quot;name&quot;: &quot;repositoryId&quot;,
            &quot;required&quot;: true
        },
        {
            &quot;name&quot;: &quot;getter&quot;,
            &quot;required&quot;: true
        }
    ],
    &quot;restify.api.index&quot;: [
        {
            &quot;name&quot;: &quot;repository&quot;,
            &quot;required&quot;: true
        }
    ],
    &quot;restify.api.store&quot;: [
        {
            &quot;name&quot;: &quot;repository&quot;,
            &quot;required&quot;: true
        }
    ],
    &quot;restify.api.store.bulk&quot;: [
        {
            &quot;name&quot;: &quot;repository&quot;,
            &quot;required&quot;: true
        }
    ],
    &quot;restify.api.update.bulk&quot;: [
        {
            &quot;name&quot;: &quot;repository&quot;,
            &quot;required&quot;: true
        }
    ],
    &quot;restify.api.destroy.bulk&quot;: [
        {
            &quot;name&quot;: &quot;repository&quot;,
            &quot;required&quot;: true
        }
    ],
    &quot;restify.api.show&quot;: [
        {
            &quot;name&quot;: &quot;repository&quot;,
            &quot;required&quot;: true
        },
        {
            &quot;name&quot;: &quot;repositoryId&quot;,
            &quot;required&quot;: true
        }
    ],
    &quot;restify.api.patch&quot;: [
        {
            &quot;name&quot;: &quot;repository&quot;,
            &quot;required&quot;: true
        },
        {
            &quot;name&quot;: &quot;repositoryId&quot;,
            &quot;required&quot;: true
        }
    ],
    &quot;restify.api.put&quot;: [
        {
            &quot;name&quot;: &quot;repository&quot;,
            &quot;required&quot;: true
        },
        {
            &quot;name&quot;: &quot;repositoryId&quot;,
            &quot;required&quot;: true
        }
    ],
    &quot;restify.api.update&quot;: [
        {
            &quot;name&quot;: &quot;repository&quot;,
            &quot;required&quot;: true
        },
        {
            &quot;name&quot;: &quot;repositoryId&quot;,
            &quot;required&quot;: true
        }
    ],
    &quot;restify.api.destroy&quot;: [
        {
            &quot;name&quot;: &quot;repository&quot;,
            &quot;required&quot;: true
        },
        {
            &quot;name&quot;: &quot;repositoryId&quot;,
            &quot;required&quot;: true
        }
    ],
    &quot;restify.api.field.destroy&quot;: [
        {
            &quot;name&quot;: &quot;repository&quot;,
            &quot;required&quot;: true
        },
        {
            &quot;name&quot;: &quot;repositoryId&quot;,
            &quot;required&quot;: true
        },
        {
            &quot;name&quot;: &quot;field&quot;,
            &quot;required&quot;: true
        }
    ],
    &quot;restify.api.attach&quot;: [
        {
            &quot;name&quot;: &quot;repository&quot;,
            &quot;required&quot;: true
        },
        {
            &quot;name&quot;: &quot;repositoryId&quot;,
            &quot;required&quot;: true
        },
        {
            &quot;name&quot;: &quot;relatedRepository&quot;,
            &quot;required&quot;: true
        }
    ],
    &quot;restify.api.detach&quot;: [
        {
            &quot;name&quot;: &quot;repository&quot;,
            &quot;required&quot;: true
        },
        {
            &quot;name&quot;: &quot;repositoryId&quot;,
            &quot;required&quot;: true
        },
        {
            &quot;name&quot;: &quot;relatedRepository&quot;,
            &quot;required&quot;: true
        }
    ],
    &quot;restify.api.sync&quot;: [
        {
            &quot;name&quot;: &quot;repository&quot;,
            &quot;required&quot;: true
        },
        {
            &quot;name&quot;: &quot;repositoryId&quot;,
            &quot;required&quot;: true
        },
        {
            &quot;name&quot;: &quot;relatedRepository&quot;,
            &quot;required&quot;: true
        }
    ],
    &quot;restify.api.relatable.index&quot;: [
        {
            &quot;name&quot;: &quot;parentRepository&quot;,
            &quot;required&quot;: true
        },
        {
            &quot;name&quot;: &quot;parentRepositoryId&quot;,
            &quot;required&quot;: true
        },
        {
            &quot;name&quot;: &quot;repository&quot;,
            &quot;required&quot;: true
        }
    ],
    &quot;restify.api.relatable.store&quot;: [
        {
            &quot;name&quot;: &quot;parentRepository&quot;,
            &quot;required&quot;: true
        },
        {
            &quot;name&quot;: &quot;parentRepositoryId&quot;,
            &quot;required&quot;: true
        },
        {
            &quot;name&quot;: &quot;repository&quot;,
            &quot;required&quot;: true
        }
    ],
    &quot;restify.api.relatable.show&quot;: [
        {
            &quot;name&quot;: &quot;parentRepository&quot;,
            &quot;required&quot;: true
        },
        {
            &quot;name&quot;: &quot;parentRepositoryId&quot;,
            &quot;required&quot;: true
        },
        {
            &quot;name&quot;: &quot;repository&quot;,
            &quot;required&quot;: true
        },
        {
            &quot;name&quot;: &quot;repositoryId&quot;,
            &quot;required&quot;: true
        }
    ],
    &quot;restify.api.relatable.update&quot;: [
        {
            &quot;name&quot;: &quot;parentRepository&quot;,
            &quot;required&quot;: true
        },
        {
            &quot;name&quot;: &quot;parentRepositoryId&quot;,
            &quot;required&quot;: true
        },
        {
            &quot;name&quot;: &quot;repository&quot;,
            &quot;required&quot;: true
        },
        {
            &quot;name&quot;: &quot;repositoryId&quot;,
            &quot;required&quot;: true
        }
    ],
    &quot;restify.api.relatable.updatePut&quot;: [
        {
            &quot;name&quot;: &quot;parentRepository&quot;,
            &quot;required&quot;: true
        },
        {
            &quot;name&quot;: &quot;parentRepositoryId&quot;,
            &quot;required&quot;: true
        },
        {
            &quot;name&quot;: &quot;repository&quot;,
            &quot;required&quot;: true
        },
        {
            &quot;name&quot;: &quot;repositoryId&quot;,
            &quot;required&quot;: true
        }
    ],
    &quot;restify.api.relatable.destroy&quot;: [
        {
            &quot;name&quot;: &quot;parentRepository&quot;,
            &quot;required&quot;: true
        },
        {
            &quot;name&quot;: &quot;parentRepositoryId&quot;,
            &quot;required&quot;: true
        },
        {
            &quot;name&quot;: &quot;repository&quot;,
            &quot;required&quot;: true
        },
        {
            &quot;name&quot;: &quot;repositoryId&quot;,
            &quot;required&quot;: true
        }
    ],
    &quot;api.job.library-scan&quot;: [
        {
            &quot;name&quot;: &quot;id&quot;,
            &quot;required&quot;: true
        }
    ],
    &quot;login&quot;: [],
    &quot;register&quot;: [],
    &quot;forgotPassword&quot;: [],
    &quot;resetPassword&quot;: [],
    &quot;verify&quot;: [
        {
            &quot;name&quot;: &quot;id&quot;,
            &quot;required&quot;: true
        },
        {
            &quot;name&quot;: &quot;hash&quot;,
            &quot;required&quot;: true
        }
    ],
    &quot;web.asset.image&quot;: [
        {
            &quot;name&quot;: &quot;image&quot;,
            &quot;required&quot;: true,
            &quot;binding&quot;: &quot;id&quot;
        }
    ],
    &quot;webui&quot;: [
        {
            &quot;name&quot;: &quot;any&quot;,
            &quot;required&quot;: true
        }
    ]
}
}
export {};</file><file path="resources/views/mail/mailbook.blade.php">@component(&apos;mail::message&apos;)
# Installation successful!
You have successfully installed Mailbook. You can start by registering your mailables and notifications in `routes/mailbook.php`.
If you enjoy mailbook don&apos;t forget to [give it a ⭐️](https://github.com/Xammie/mailbook)
@component(&apos;mail::button&apos;, [&apos;url&apos; =&gt; &apos;https://github.com/Xammie/mailbook?tab=readme-ov-file#usage&apos;])
Documentation
@endcomponent
If you have any issues or questions feel free to open a [issue](https://github.com/Xammie/mailbook/issues) or [discussion](https://github.com/Xammie/mailbook/discussions).
Cheers,&lt;br&gt;
Mailbook
@endcomponent</file><file path="routes/api.php">&lt;?php</file><file path="routes/console.php">&lt;?php</file><file path="routes/mailbook.php">&lt;?php
use App\Mail\MailbookMail;
use Xammie\Mailbook\Facades\Mailbook;
Mailbook::add(MailbookMail::class);</file><file path="start_reverb.sh">php artisan reverb:start --debug --host=&quot;0.0.0.0&quot; --port=8080 --hostname=&quot;baander.test&quot;</file><file path="storage/app/images/covers/.gitignore">*
!.gitignore</file><file path="storage/logs/.gitignore">*
!.gitignore</file><file path="tests/CreatesApplication.php">&lt;?php
namespace Tests;
use Illuminate\Contracts\Console\Kernel;
use Illuminate\Foundation\Application;
trait CreatesApplication
{
    /**
     * Creates the application.
     */
    public function createApplication(): Application
    {
        $app = require __DIR__.&apos;/../bootstrap/app.php&apos;;
        $app-&gt;make(Kernel::class)-&gt;bootstrap();
        return $app;
    }
}</file><file path="tests/Feature/DiscogsClientTest.php">&lt;?php
namespace Tests\Feature;
use Tests\TestCase;
use App\Http\Integrations\Discogs\DiscogsClient;
use App\Http\Integrations\Discogs\Filters\ArtistFilter;
use App\Http\Integrations\Discogs\Filters\ReleaseFilter;
use App\Http\Integrations\Discogs\Models\Artist;
use App\Http\Integrations\Discogs\Models\Release;
class DiscogsClientTest extends TestCase
{
    protected DiscogsClient $discogsClient;
    protected function setUp(): void
    {
        parent::setUp();
        $this-&gt;discogsClient = app(DiscogsClient::class);
    }
    public function testSearchArtists()
    {
        $filter = new ArtistFilter(
            q: &apos;Radiohead&apos;,
            page: 1,
            per_page: 10
        );
        $results = $this-&gt;discogsClient-&gt;search-&gt;artist($filter);
        $this-&gt;assertNotNull($results);
        $this-&gt;assertIsArray($results);
        // Check that the results are Artist models
        if (count($results) &gt; 0) {
            $this-&gt;assertInstanceOf(Artist::class, $results[0]);
            $this-&gt;assertNotNull($results[0]-&gt;id);
            $this-&gt;assertNotNull($results[0]-&gt;title);
        }
        // Get pagination info
        $pagination = $this-&gt;discogsClient-&gt;search-&gt;getPagination();
        $this-&gt;assertNotNull($pagination);
        $this-&gt;assertArrayHasKey(&apos;page&apos;, $pagination);
        $this-&gt;assertArrayHasKey(&apos;pages&apos;, $pagination);
        $this-&gt;assertArrayHasKey(&apos;items&apos;, $pagination);
        $this-&gt;assertArrayHasKey(&apos;per_page&apos;, $pagination);
    }
    public function testLookupArtist()
    {
        // Radiohead&apos;s Discogs ID
        $artistId = 3840;
        $artist = $this-&gt;discogsClient-&gt;lookup-&gt;artist($artistId);
        $this-&gt;assertNotNull($artist);
        $this-&gt;assertInstanceOf(Artist::class, $artist);
        $this-&gt;assertEquals(&apos;Radiohead&apos;, $artist-&gt;name);
        $this-&gt;assertEquals($artistId, $artist-&gt;id);
    }
    public function testArtistReleases()
    {
        // Radiohead&apos;s Discogs ID
        $artistId = 3840;
        $releases = $this-&gt;discogsClient-&gt;lookup-&gt;artistReleases($artistId, 1, 5);
        $this-&gt;assertNotNull($releases);
        $this-&gt;assertIsArray($releases);
        $this-&gt;assertArrayHasKey(&apos;releases&apos;, $releases);
        $this-&gt;assertLessThanOrEqual(5, count($releases[&apos;releases&apos;]));
        // Test pagination
        $this-&gt;assertArrayHasKey(&apos;pagination&apos;, $releases);
        $this-&gt;assertEquals(1, $releases[&apos;pagination&apos;][&apos;page&apos;]);
        $this-&gt;assertEquals(5, $releases[&apos;pagination&apos;][&apos;per_page&apos;]);
    }
    public function testSearchReleases()
    {
        $filter = new ReleaseFilter(
            artist: &apos;Radiohead&apos;,
            title: &apos;OK Computer&apos;,
            page: 1,
            per_page: 5
        );
        $results = $this-&gt;discogsClient-&gt;search-&gt;release($filter);
        $this-&gt;assertNotNull($results);
        $this-&gt;assertIsArray($results);
        // Check that the results are Release models
        if (count($results) &gt; 0) {
            $this-&gt;assertInstanceOf(Release::class, $results[0]);
            $this-&gt;assertNotNull($results[0]-&gt;id);
            $this-&gt;assertNotNull($results[0]-&gt;title);
        }
    }
}</file><file path="tests/Feature/ExampleTest.php">&lt;?php
namespace Tests\Feature;
// use Illuminate\Foundation\Testing\RefreshDatabase;
use Tests\TestCase;
class ExampleTest extends TestCase
{
    /**
     * A basic test example.
     */
    public function test_the_application_returns_a_successful_response(): void
    {
        $response = $this-&gt;get(&apos;/&apos;);
        $response-&gt;assertStatus(200);
    }
}</file><file path="tests/TestCase.php">&lt;?php
namespace Tests;
use Illuminate\Foundation\Testing\TestCase as BaseTestCase;
abstract class TestCase extends BaseTestCase
{
    use CreatesApplication;
}</file><file path="tests/Unit/ExampleTest.php">&lt;?php
namespace Tests\Unit;
use PHPUnit\Framework\TestCase;
class ExampleTest extends TestCase
{
    /**
     * A basic test example.
     */
    public function test_that_true_is_true(): void
    {
        $this-&gt;assertTrue(true);
    }
}</file><file path="TODO.md">Add icons for clients https://github.com/Simbiat/DeviceDetectorIcons</file><file path="tsconfig.paths.json">{
    &quot;compilerOptions&quot;: {
        &quot;baseUrl&quot;: &quot;.&quot;,
        &quot;paths&quot;: {
            &quot;@/*&quot;: [&quot;./src/*&quot;]
        }
    }
}</file><file path=".dockerignore">.git
storage/muzak
/storage/movies
node_modules
vendor</file><file path="app/Actions/Fortify/CreateNewUser.php">&lt;?php
namespace App\Actions\Fortify;
use App\Models\User;
use Illuminate\Support\Facades\Hash;
use Illuminate\Support\Facades\Validator;
use Illuminate\Validation\Rule;
use Laravel\Fortify\Contracts\CreatesNewUsers;
class CreateNewUser implements CreatesNewUsers
{
    use PasswordValidationRules;
    /**
     * Validate and create a newly registered user.
     *
     * @param array&lt;string, string&gt; $input
     */
    public function create(array $input): User
    {
        Validator::make($input, [
            &apos;name&apos;     =&gt; [&apos;required&apos;, &apos;string&apos;, &apos;max:255&apos;],
            &apos;email&apos;    =&gt; [
                &apos;required&apos;,
                &apos;string&apos;,
                &apos;email&apos;,
                &apos;max:255&apos;,
                Rule::unique(User::class),
            ],
            &apos;password&apos; =&gt; $this-&gt;passwordRules(),
        ])-&gt;validate();
        return User::create([
            &apos;name&apos;     =&gt; $input[&apos;name&apos;],
            &apos;email&apos;    =&gt; $input[&apos;email&apos;],
            &apos;password&apos; =&gt; Hash::make($input[&apos;password&apos;]),
        ]);
    }
}</file><file path="app/Actions/Fortify/ResetUserPassword.php">&lt;?php
namespace App\Actions\Fortify;
use App\Models\User;
use Illuminate\Support\Facades\Hash;
use Illuminate\Support\Facades\Validator;
use Laravel\Fortify\Contracts\ResetsUserPasswords;
class ResetUserPassword implements ResetsUserPasswords
{
    use PasswordValidationRules;
    /**
     * Validate and reset the user&apos;s forgotten password.
     *
     * @param array&lt;string, string&gt; $input
     */
    public function reset(User $user, array $input): void
    {
        Validator::make($input, [
            &apos;password&apos; =&gt; $this-&gt;passwordRules(),
        ])-&gt;validate();
        $user-&gt;forceFill([
            &apos;password&apos; =&gt; Hash::make($input[&apos;password&apos;]),
        ])-&gt;save();
    }
}</file><file path="app/Actions/Fortify/UpdateUserPassword.php">&lt;?php
namespace App\Actions\Fortify;
use App\Models\User;
use Illuminate\Support\Facades\Hash;
use Illuminate\Support\Facades\Validator;
use Laravel\Fortify\Contracts\UpdatesUserPasswords;
class UpdateUserPassword implements UpdatesUserPasswords
{
    use PasswordValidationRules;
    /**
     * Validate and update the user&apos;s password.
     *
     * @param array&lt;string, string&gt; $input
     */
    public function update(User $user, array $input): void
    {
        Validator::make($input, [
            &apos;current_password&apos; =&gt; [&apos;required&apos;, &apos;string&apos;, &apos;current_password:web&apos;],
            &apos;password&apos;         =&gt; $this-&gt;passwordRules(),
        ], [
            &apos;current_password.current_password&apos; =&gt; __(&apos;The provided password does not match your current password.&apos;),
        ])-&gt;validateWithBag(&apos;updatePassword&apos;);
        $user-&gt;forceFill([
            &apos;password&apos; =&gt; Hash::make($input[&apos;password&apos;]),
        ])-&gt;save();
    }
}</file><file path="app/Actions/Fortify/UpdateUserProfileInformation.php">&lt;?php
namespace App\Actions\Fortify;
use App\Models\User;
use Illuminate\Contracts\Auth\MustVerifyEmail;
use Illuminate\Support\Facades\Validator;
use Illuminate\Validation\Rule;
use Laravel\Fortify\Contracts\UpdatesUserProfileInformation;
class UpdateUserProfileInformation implements UpdatesUserProfileInformation
{
    /**
     * Validate and update the given user&apos;s profile information.
     *
     * @param array&lt;string, string&gt; $input
     */
    public function update(User $user, array $input): void
    {
        Validator::make($input, [
            &apos;name&apos; =&gt; [&apos;required&apos;, &apos;string&apos;, &apos;max:255&apos;],
            &apos;email&apos; =&gt; [
                &apos;required&apos;,
                &apos;string&apos;,
                &apos;email&apos;,
                &apos;max:255&apos;,
                Rule::unique(&apos;users&apos;)-&gt;ignore($user-&gt;id),
            ],
        ])-&gt;validateWithBag(&apos;updateProfileInformation&apos;);
        if ($input[&apos;email&apos;] !== $user-&gt;email &amp;&amp;
            $user instanceof MustVerifyEmail) {
            $this-&gt;updateVerifiedUser($user, $input);
        } else {
            $user-&gt;forceFill([
                &apos;name&apos;  =&gt; $input[&apos;name&apos;],
                &apos;email&apos; =&gt; $input[&apos;email&apos;],
            ])-&gt;save();
        }
    }
    /**
     * Update the given verified user&apos;s profile information.
     *
     * @param array&lt;string, string&gt; $input
     */
    protected function updateVerifiedUser(User $user, array $input): void
    {
        $user-&gt;forceFill([
            &apos;name&apos;              =&gt; $input[&apos;name&apos;],
            &apos;email&apos;             =&gt; $input[&apos;email&apos;],
            &apos;email_verified_at&apos; =&gt; null,
        ])-&gt;save();
        $user-&gt;sendEmailVerificationNotification();
    }
}</file><file path="app/Auth/Role.php">&lt;?php
namespace App\Auth;
use App\Extensions\EnumExt;
enum Role: string
{
    use EnumExt;
    case Admin = &apos;admin&apos;;
    case User = &apos;user&apos;;
}</file><file path="app/Auth/TokenName.php">&lt;?php
namespace App\Auth;
use App\Extensions\EnumExt;
enum TokenName: string
{
    use EnumExt;
    case Access = &apos;access_token&apos;;
    case Refresh = &apos;refresh_token&apos;;
    case Stream  = &apos;stream_token&apos;;
    public function camelCaseValue(): string
    {
        return self::toCamelCase($this-&gt;value);
    }
}</file><file path="app/Console/Commands/Auth/PruneExpiredTokensCommand.php">&lt;?php
namespace App\Console\Commands\Auth;
use App\Actions\Tokens\PruneExpiredTokens;
use App\Services\AuthTokenService;
use Illuminate\Console\Command;
use Illuminate\Support\Arr;
class PruneExpiredTokensCommand extends Command
{
    /**
     * The name and signature of the console command.
     *
     * @var string
     */
    protected $signature = &apos;auth:prune-expired-tokens&apos;;
    /**
     * The console command description.
     *
     * @var string
     */
    protected $description = &apos;Prune expired tokens&apos;;
    /**
     * Execute the console command.
     */
    public function handle()
    {
        $authTokenManager = app(AuthTokenService::class);
        $result = (new PruneExpiredTokens($authTokenManager))-&gt;run();
        $count = Arr::get($result, &apos;removed&apos;, 0);
        $this-&gt;warn(&quot;Pruned {$count} expired tokens.&quot;);
        if (app()-&gt;isLocal()) {
            dump($result[&apos;context&apos;]);
        }
    }
}</file><file path="app/Console/Commands/Octane/ProdStartSwooleCommand.php">&lt;?php
namespace App\Console\Commands\Octane;
use Laravel\Octane\Commands\StartSwooleCommand;
use Laravel\Octane\Swoole\ServerProcessInspector;
use Laravel\Octane\Swoole\ServerStateFile;
use Laravel\Octane\Swoole\SwooleExtension;
class ProdStartSwooleCommand extends StartSwooleCommand
{
    public $signature = &apos;octane:dump-server-state
                    {--host=0.0.0.0 : The IP address the server should bind to}
                    {--port=8000 : The port the server should be available on}
                    {--workers=5 : The number of workers that should be available to handle requests}
                    {--task-workers=2 : The number of task workers that should be available to handle tasks}
                    {--max-requests=500 : The number of requests to process before reloading the server}&apos;;
    public $description = &apos;Dump octane server state file. The start-swoole-server script must always be running.&apos;;
    public function handle(
        ServerProcessInspector $inspector,
        ServerStateFile        $serverStateFile,
        SwooleExtension        $extension,
    ): int
    {
        if (!$extension-&gt;isInstalled()) {
            $this-&gt;error(&apos;The Swoole extension is missing.&apos;);
            return self::FAILURE;
        }
        if ($inspector-&gt;serverIsRunning()) {
            $this-&gt;error(&apos;Server is already running.&apos;);
            return self::FAILURE;
        }
        if (config(&apos;octane.swoole.ssl&apos;, false) === true &amp;&amp; !defined(&apos;SWOOLE_SSL&apos;)) {
            $this-&gt;error(&apos;You must configure Swoole with `--enable-openssl` to support ssl.&apos;);
            return self::FAILURE;
        }
        $this-&gt;writeServerStateFile($serverStateFile, $extension);
        $savedFilePath = $serverStateFile-&gt;path();
        $this-&gt;info(&quot;Server state file saved at: {$savedFilePath}&quot;);
        return self::SUCCESS;
    }
}</file><file path="app/Console/Commands/QueueMonitor/MarkJobsAsStaleCommand.php">&lt;?php
namespace App\Console\Commands\QueueMonitor;
use App\Console\Commands\QueueMonitor\Concerns\HandlesDateInputs;
use App\Models\QueueMonitor;
use App\Modules\QueueMonitor\MonitorStatus;
use Illuminate\Console\Command;
use Illuminate\Support\Collection;
use Illuminate\Support\Facades\DB;
class MarkJobsAsStaleCommand extends Command
{
    use HandlesDateInputs;
    /**
     * The name and signature of the console command.
     *
     * @var string
     */
    protected $signature = &apos;queue-monitor:stale {--before=} {--beforeDays=} {--beforeInterval=} {--dry}&apos;;
    /**
     * The console command description.
     *
     * @var string
     */
    protected $description = &apos;Mark jobs as stale within a given period&apos;;
    /**
     * Execute the console command.
     */
    public function handle()
    {
        $beforeDate = self::parseBeforeDate($this);
        if (null === $beforeDate) {
            $this-&gt;error(&apos;Needs at least --before or --beforeDays arguments&apos;);
            return 1;
        }
        $query = QueueMonitor::getModel()
            -&gt;newQuery()
            -&gt;where(&apos;status&apos;, MonitorStatus::Running)
            -&gt;where(&apos;started_at&apos;, &apos;&lt;&apos;, $beforeDate);
        $this-&gt;info(
            sprintf(&apos;Marking %d jobs after %s as stale&apos;, $count = $query-&gt;count(), $beforeDate-&gt;format(&apos;Y-m-d H:i:s&apos;)),
        );
        $query-&gt;chunk(500, function (Collection $models, int $page) use ($count) {
            $this-&gt;info(
                sprintf(&apos;Deleted chunk %d / %d&apos;, $page, abs($count / 200)),
            );
            if ($this-&gt;option(&apos;dry&apos;)) {
                return;
            }
            DB::table(QueueMonitor::getModel()-&gt;getTable())
                -&gt;whereIn(&apos;id&apos;, $models-&gt;pluck(&apos;id&apos;))
                -&gt;update([
                    &apos;status&apos; =&gt; MonitorStatus::Stale,
                ]);
        });
        return 0;
    }
}</file><file path="app/Console/Commands/QueueMonitor/PurgeOldMonitorsCommand.php">&lt;?php
namespace App\Console\Commands\QueueMonitor;
use App\Console\Commands\QueueMonitor\Concerns\HandlesDateInputs;
use App\Models\QueueMonitor;
use App\Modules\QueueMonitor\MonitorStatus;
use Illuminate\Console\Command;
use Illuminate\Support\Collection;
use Illuminate\Support\Facades\DB;
class PurgeOldMonitorsCommand extends Command
{
    use HandlesDateInputs;
    /**
     * The name and signature of the console command.
     *
     * @var string
     */
    protected $signature = &apos;queue-monitor:purge {--before=} {--beforeDays=} {--beforeInterval=} {--only-succeeded} {--queue=} {--dry}&apos;;
    /**
     * The console command description.
     *
     * @var string
     */
    protected $description = &apos;Purge monitor records&apos;;
    /**
     * Execute the console command.
     */
    public function handle()
    {
        $beforeDate = self::parseBeforeDate($this);
        if (null === $beforeDate) {
            $this-&gt;error(&apos;Needs at least --before or --beforeDays arguments&apos;);
            return 1;
        }
        $query = QueueMonitor::getModel()
            -&gt;newQuery()
            -&gt;where(&apos;started_at&apos;, &apos;&lt;&apos;, $beforeDate);
        $queues = array_filter(explode(&apos;,&apos;, $this-&gt;option(&apos;queue&apos;) ?? &apos;&apos;));
        if (count($queues) &gt; 0) {
            $query-&gt;whereIn(&apos;queue&apos;, array_map(&apos;trim&apos;, $queues));
        }
        if ($this-&gt;option(&apos;only-succeeded&apos;)) {
            $query-&gt;where(&apos;status&apos;, &apos;=&apos;, MonitorStatus::Succeeded);
        }
        $count = $query-&gt;count();
        $this-&gt;info(
            sprintf(&apos;Purging %d jobs before %s.&apos;, $count, $beforeDate-&gt;format(&apos;Y-m-d H:i:s&apos;)),
        );
        $query-&gt;chunk(200, function (Collection $models, int $page) use ($count) {
            $this-&gt;info(
                sprintf(&apos;Deleted chunk %d / %d&apos;, $page, abs($count / 200)),
            );
            if ($this-&gt;option(&apos;dry&apos;)) {
                return;
            }
            DB::table(QueueMonitor::getModel()-&gt;getTable())
                -&gt;whereIn(&apos;id&apos;, $models-&gt;pluck(&apos;id&apos;))
                -&gt;delete();
        });
        return 1;
    }
}</file><file path="app/Console/Commands/ScanLibraryCommand.php">&lt;?php
namespace App\Console\Commands;
use App\Jobs\Library\Music\ScanMusicLibraryJob;
use App\Models\Library;
use Illuminate\Console\Command;
class ScanLibraryCommand extends Command
{
    /**
     * The name and signature of the console command.
     *
     * @var string
     */
    protected $signature = &apos;scan:library&apos;;
    /**
     * The console command description.
     *
     * @var string
     */
    protected $description = &apos;Scan media library&apos;;
    /**
     * Execute the console command.
     */
    public function handle()
    {
        $library = Library::first();
        dispatch(new ScanMusicLibraryJob(library: $library));
    }
}</file><file path="app/Events/Auth/PasskeyUsedToAuthenticateEvent.php">&lt;?php
namespace App\Events\Auth;
use App\Models\Passkey;
class PasskeyUsedToAuthenticateEvent
{
    /**
     * Create a new event instance.
     */
    public function __construct(
        public Passkey $passkey,
    )
    {
        //
    }
}</file><file path="app/Events/LibraryScanCompleted.php">&lt;?php
namespace App\Events;
use App\Models\Library;
use Illuminate\Broadcasting\Channel;
use Illuminate\Broadcasting\InteractsWithSockets;
use Illuminate\Broadcasting\PresenceChannel;
use Illuminate\Broadcasting\PrivateChannel;
use Illuminate\Contracts\Broadcasting\ShouldBroadcast;
use Illuminate\Contracts\Queue\ShouldQueue;
use Illuminate\Foundation\Events\Dispatchable;
use Illuminate\Queue\SerializesModels;
class LibraryScanCompleted implements ShouldQueue
{
    use Dispatchable, InteractsWithSockets, SerializesModels;
    /**
     * Create a new event instance.
     */
    public function __construct(
        public Library $library,
    )
    {
        //
    }
    /**
     * Get the channels the event should broadcast on.
     *
     * @return array&lt;int, \Illuminate\Broadcasting\Channel&gt;
     */
    public function broadcastOn(): array
    {
        return [
            new PrivateChannel(&apos;notifications&apos;),
        ];
    }
    public function broadcastWith(): array
    {
        $name = $this-&gt;library-&gt;name;
        return [
            &apos;notification&apos; =&gt; [
                &apos;title&apos; =&gt; &apos;Library scan completed&apos;,
                &apos;body&apos;  =&gt; &quot;$name was successfully scanned&quot;,
            ],
        ];
    }
}</file><file path="app/Exceptions/Handler.php">&lt;?php
namespace App\Exceptions;
use App\Modules\Apm\Apm;
use Illuminate\Foundation\Exceptions\Handler as ExceptionHandler;
use Throwable;
class Handler extends ExceptionHandler
{
    /**
     * The list of the inputs that are never flashed to the session on validation exceptions.
     *
     * @var array&lt;int, string&gt;
     */
    protected $dontFlash = [
        &apos;current_password&apos;,
        &apos;password&apos;,
        &apos;password_confirmation&apos;,
    ];
    /**
     * Register the exception handling callbacks for the application.
     */
    public function register(): void
    {
        $this-&gt;reportable(function (Throwable $e) {
        });
    }
    public function report(Throwable $e)
    {
        parent::report($e);
        Apm::recordException($e);
    }
}</file><file path="app/Exceptions/Jobs/Manager/CouldNotFindJobException.php">&lt;?php
namespace App\Exceptions\Jobs\Manager;
use Exception;
use Illuminate\Http\Request;
use Illuminate\Http\Response;
use Throwable;
class CouldNotFindJobException extends Exception
{
    public static int $FROM_CONTROLLER = 110;
    public static string $PUBLIC_MESSAGE = &apos;Could not launch job&apos;;
    private ?string $jobClass = null;
    public function __construct(string $message = &quot;&quot;, int $code = 0, ?Throwable $previous = null)
    {
        parent::__construct($message, $code, $previous);
    }
    /**
     * @throws CouldNotFindJobException
     */
    public static function throwFromController(\Throwable $e)
    {
        $wrap = new self(&apos;Unable to start new job&apos;, CouldNotFindJobException::$FROM_CONTROLLER, $e);
        $wrap-&gt;jobClass = get_class($e);
        throw $wrap;
    }
    /**
     * Render the exception as an HTTP response.
     */
    public function render(Request $request): Response
    {
        $message = sprintf(&quot;%s %s&quot;, static::$PUBLIC_MESSAGE, $this-&gt;jobClass !== null ? $this-&gt;jobClass : &apos;&apos;);
        return \response([
            &apos;code&apos;    =&gt; self::$FROM_CONTROLLER,
            &apos;message&apos; =&gt; $message,
        ], 500);
    }
    public function report(): void
    {
        \Log::error($this-&gt;getPrevious());
    }
}</file><file path="app/Extensions/EnumExt.php">&lt;?php
namespace App\Extensions;
trait EnumExt
{
    public static function names(): array
    {
        return array_column(self::cases(), &apos;name&apos;);
    }
    public static function values(): array
    {
        return array_column(self::cases(), &apos;value&apos;);
    }
    public static function array(): array
    {
        return array_combine(self::values(), self::names());
    }
    public static function toCamelCase(string $value): string
    {
        return lcfirst(str_replace(&apos; &apos;, &apos;&apos;, ucwords(str_replace(&apos;_&apos;, &apos; &apos;, $value))));
    }
}</file><file path="app/Extensions/StrExt.php">&lt;?php
namespace App\Extensions;
class StrExt
{
    public static function between($str, $starting_word, $ending_word): ?string
    {
        if (!$str) {
            return null;
        }
        try {
            $subtring_start = strpos($str, $starting_word);
            if ($subtring_start === false || $subtring_start &lt;= 0) {
                return null;
            }
            // Adding the starting index of the starting word to
            // its length would give its ending index
            $subtring_start += strlen($starting_word);
            // Length of our required sub string
            $size = strpos($str, $ending_word, $subtring_start) - $subtring_start;
            if ($size === false || $size &lt;= 0) {
                return null;
            }
            // Return the substring from the index substring_start of length size
            return substr($str, $subtring_start, $size);
        } catch (\Exception) {
            return null;
        }
    }
    public static function safe($str)
    {
        if (!$str) {
            return null;
        }
        return strip_tags(str_replace(&apos;\x00&apos;, &apos;&apos;, $str));
    }
    public static function convertToUtf8($str): string|null
    {
        if (!$str) {
            return null;
        }
        $encoding = mb_detect_encoding($str);
        return mb_convert_encoding($str, &apos;UTF-8&apos;, $encoding);
    }
}</file><file path="app/Http/Controllers/Api/ImageController.php">&lt;?php
namespace App\Http\Controllers\Api;
use App\Http\Controllers\Controller;
use App\Models\Image;
use Illuminate\Http\Request;
use Spatie\RouteAttributes\Attributes\Get;
use Spatie\RouteAttributes\Attributes\Prefix;
#[Prefix(&apos;images&apos;)]
class ImageController extends Controller
{
    /**
     * Get an image asset
     *
     * @unauthenticated
     */
    #[Get(&apos;{image}&apos;, &apos;api.image.serve&apos;)]
    public function serve(Image $image)
    {
        return response()-&gt;file($image-&gt;getPath());
    }
}</file><file path="app/Http/Controllers/Api/StreamController.php">&lt;?php
namespace App\Http\Controllers\Api;
use App\Models\{Song, TokenAbility};
use Spatie\RouteAttributes\Attributes\{Get, Prefix};
use Symfony\Component\HttpFoundation\BinaryFileResponse;
#[Prefix(&apos;/stream&apos;)]
class StreamController
{
    /**
     * Direct stream the song.
     * Requires token with &quot;access-stream&quot;
     *
     * @param Song $song
     * @return BinaryFileResponse
     */
    #[Get(&apos;/song/{song}/direct&apos;, &apos;api.stream.song-direct&apos;, [
        &apos;auth:sanctum&apos;,
        &apos;ability:&apos; . TokenAbility::ACCESS_STREAM-&gt;value,
    ])]
    public function songDirect(Song $song)
    {
        return response()-&gt;file($song-&gt;getPath());
    }
}</file><file path="app/Http/Controllers/Controller.php">&lt;?php
namespace App\Http\Controllers;
use Illuminate\Foundation\Auth\Access\AuthorizesRequests;
use Illuminate\Foundation\Validation\ValidatesRequests;
use Illuminate\Routing\Controller as BaseController;
use Illuminate\Support\Facades\Gate;
class Controller extends BaseController
{
    use AuthorizesRequests, ValidatesRequests;
    protected function denyWithStatus(string $message, int $status)
    {
        return response()-&gt;json([
            &apos;message&apos; =&gt; $message,
        ])-&gt;setStatusCode($status);
    }
    protected function noContent()
    {
        return response(null, 204);
    }
    protected function gateCheckViewDashboard()
    {
        if (!Gate::allows(&apos;viewDashboard&apos;)) {
            abort(403);
        }
    }
    protected function gateCheckExecuteJob()
    {
        if (!Gate::allows(&apos;executeJob&apos;)) {
            abort(403);
        }
    }
}</file><file path="app/Http/Integrations/CoverArtArchive/CoverArtArchiveClient.php">&lt;?php
namespace App\Http\Integrations\CoverArtArchive;
use GuzzleHttp\Client;
use App\Http\Integrations\CoverArtArchive\Models\CoverArtResponse;
class CoverArtArchiveClient
{
    public const string BASE_URL = &apos;https://coverartarchive.org/release/&apos;;
    public function __construct(private readonly Client $client)
    {
    }
    public function getCoverArtUrl(string $musicBrainzId): ?string
    {
        $response = $this-&gt;client-&gt;getAsync(self::BASE_URL . $musicBrainzId)-&gt;wait();
        if ($response-&gt;getStatusCode() !== 200) {
            throw new \RuntimeException(&apos;API request failed: &apos; . $response-&gt;getReasonPhrase());
        }
        $data = json_decode($response-&gt;getBody()-&gt;getContents(), true);
        $coverArtResponse = CoverArtResponse::fromApiData($data);
        foreach ($coverArtResponse-&gt;images as $image) {
            if ($image-&gt;front) {
                return $image-&gt;image;
            }
        }
        return null;
    }
}</file><file path="app/Http/Integrations/MusicBrainz/Filters/ArtistFilter.php">&lt;?php
namespace App\Http\Integrations\MusicBrainz\Filters;
class ArtistFilter extends BaseFilter
{
    public function __construct(
        public ?string $name = null,
        public ?string $country = null,
        public ?string $type = null,
        int $limit = 25,
        int $offset = 0
    ) {
        parent::__construct($limit, $offset);
    }
    public function setName(?string $name): ArtistFilter
    {
        $this-&gt;name = $name;
        return $this;
    }
    public function setCountry(?string $country): ArtistFilter
    {
        $this-&gt;country = $country;
        return $this;
    }
    public function setType(?string $type): ArtistFilter
    {
        $this-&gt;type = $type;
        return $this;
    }
    protected function buildQuery(): array
    {
        $query = [];
        if ($this-&gt;name) {
            $query[] = &apos;artist:&apos; . $this-&gt;name;
        }
        if ($this-&gt;country) {
            $query[] = &apos;country:&apos; . $this-&gt;country;
        }
        if ($this-&gt;type) {
            $query[] = &apos;type:&apos; . $this-&gt;type;
        }
        return $query;
    }
}</file><file path="app/Http/Integrations/MusicBrainz/Filters/RecordingFilter.php">&lt;?php
namespace App\Http\Integrations\MusicBrainz\Filters;
class RecordingFilter extends BaseFilter
{
    public function __construct(
        public ?string $title = null,
        public ?string $artistName = null,
        int $limit = 25,
        int $offset = 0
    ) {
        parent::__construct($limit, $offset);
    }
    public function setTitle(?string $title): RecordingFilter
    {
        $this-&gt;title = $title;
        return $this;
    }
    public function setArtistName(?string $artistName): RecordingFilter
    {
        $this-&gt;artistName = $artistName;
        return $this;
    }
    protected function buildQuery(): array
    {
        $query = [];
        if ($this-&gt;title) {
            $query[] = &apos;recording:&apos; . $this-&gt;title;
        }
        if ($this-&gt;artistName) {
            $query[] = &apos;artist:&apos; . $this-&gt;artistName;
        }
        return $query;
    }
}</file><file path="app/Http/Integrations/MusicBrainz/Filters/ReleaseFilter.php">&lt;?php
namespace App\Http\Integrations\MusicBrainz\Filters;
class ReleaseFilter extends BaseFilter
{
    public function __construct(
        public ?string $title = null,
        public ?string $artistName = null,
        int $limit = 25,
        int $offset = 0
    ) {
        parent::__construct($limit, $offset);
    }
    public function setTitle(?string $title): ReleaseFilter
    {
        $this-&gt;title = $title;
        return $this;
    }
    public function setArtistName(?string $artistName): ReleaseFilter
    {
        $this-&gt;artistName = $artistName;
        return $this;
    }
    protected function buildQuery(): array
    {
        $query = [];
        if ($this-&gt;title) {
            $query[] = &apos;release:&apos; . $this-&gt;title;
        }
        if ($this-&gt;artistName) {
            $query[] = &apos;artist:&apos; . $this-&gt;artistName;
        }
        return $query;
    }
}</file><file path="app/Http/Integrations/MusicBrainz/Handlers/LookupHandler.php">&lt;?php
namespace App\Http\Integrations\MusicBrainz\Handlers;
use App\Http\Integrations\MusicBrainz\Handler;
use App\Http\Integrations\MusicBrainz\Models\{Area,
    Artist,
    Event,
    Genre,
    Instrument,
    Label,
    Place,
    Recording,
    Release,
    Series,
    Url,
    Work};
use App\Http\Integrations\MusicBrainz\Subqueries\ArtistAliasHandler;
class LookupHandler extends Handler
{
    public function artist(string $mbid): ?Artist
    {
        $response = $this-&gt;fetchEndpoint(&apos;artist/&apos; . $mbid);
        return $response ? Artist::fromApiData($response) : null;
    }
    public function release(string $mbid): ?Release
    {
        $response = $this-&gt;fetchEndpoint(&apos;release/&apos; . $mbid);
        return $response ? Release::fromApiData($response) : null;
    }
    public function recording(string $mbid): ?Recording
    {
        $response = $this-&gt;fetchEndpoint(&apos;recording/&apos; . $mbid);
        return $response ? Recording::fromApiData($response) : null;
    }
    public function label(string $mbid): ?Label
    {
        $response = $this-&gt;fetchEndpoint(&apos;label/&apos; . $mbid);
        return $response ? Label::fromApiData($response) : null;
    }
    public function work(string $mbid): ?Work
    {
        $response = $this-&gt;fetchEndpoint(&apos;work/&apos; . $mbid);
        return $response ? Work::fromApiData($response) : null;
    }
    public function area(string $mbid): ?Area
    {
        $response = $this-&gt;fetchEndpoint(&apos;area/&apos; . $mbid);
        return $response ? Area::fromApiData($response) : null;
    }
    public function place(string $mbid): ?Place
    {
        $response = $this-&gt;fetchEndpoint(&apos;place/&apos; . $mbid);
        return $response ? Place::fromApiData($response) : null;
    }
    public function instrument(string $mbid): ?Instrument
    {
        $response = $this-&gt;fetchEndpoint(&apos;instrument/&apos; . $mbid);
        return $response ? Instrument::fromApiData($response) : null;
    }
    public function series(string $mbid): ?Series
    {
        $response = $this-&gt;fetchEndpoint(&apos;series/&apos; . $mbid);
        return $response ? Series::fromApiData($response) : null;
    }
    public function event(string $mbid): ?Event
    {
        $response = $this-&gt;fetchEndpoint(&apos;event/&apos; . $mbid);
        return $response ? Event::fromApiData($response) : null;
    }
    public function genre(string $mbid): ?Genre
    {
        $response = $this-&gt;fetchEndpoint(&apos;genre/&apos; . $mbid);
        return $response ? Genre::fromApiData($response) : null;
    }
    public function url(string $mbid): ?Url
    {
        $response = $this-&gt;fetchEndpoint(&apos;url/&apos; . $mbid);
        return $response ? Url::fromApiData($response) : null;
    }
    public function artistAliases(): ArtistAliasHandler
    {
        return new ArtistAliasHandler($this-&gt;client, $this-&gt;baseUrl);
    }
}</file><file path="app/Http/Integrations/MusicBrainz/Handlers/SearchHandler.php">&lt;?php
namespace App\Http\Integrations\MusicBrainz\Handlers;
use App\Http\Integrations\MusicBrainz\Handler;
use App\Http\Integrations\MusicBrainz\Models\{
    Artist,
    Release,
    Recording,
    Label,
    Work,
    Area,
    Place,
    Instrument,
    Series,
    Event,
    Genre,
    Url
};
use App\Http\Integrations\MusicBrainz\Filters\{
    ArtistFilter,
    ReleaseFilter,
    RecordingFilter,
    LabelFilter,
    WorkFilter,
    AreaFilter,
    PlaceFilter,
    InstrumentFilter,
    SeriesFilter,
    EventFilter,
    GenreFilter,
    UrlFilter
};
use Illuminate\Support\Collection;
class SearchHandler extends Handler
{
    /**
     * Search for artists and return models
     *
     * @param ArtistFilter $filter Filter criteria
     * @return Collection&lt;Artist&gt; Collection of Artist models
     */
    public function artist(ArtistFilter $filter): Collection
    {
        $data = $this-&gt;fetchEndpoint(&apos;artist&apos;, $filter-&gt;toQueryParameters());
        if (!isset($data[&apos;artists&apos;])) {
            return collect();
        }
        return collect($data[&apos;artists&apos;])-&gt;map(fn($item) =&gt; Artist::fromApiData($item));
    }
    /**
     * Search for releases and return models
     *
     * @param ReleaseFilter $filter Filter criteria
     * @return Collection&lt;Release&gt; Collection of Release models
     */
    public function release(ReleaseFilter $filter): Collection
    {
        $data = $this-&gt;fetchEndpoint(&apos;release&apos;, $filter-&gt;toQueryParameters());
        if (!isset($data[&apos;releases&apos;])) {
            return collect();
        }
        return collect($data[&apos;releases&apos;])-&gt;map(fn($item) =&gt; Release::fromApiData($item));
    }
    /**
     * Search for recordings and return models
     *
     * @param RecordingFilter $filter Filter criteria
     * @return Collection&lt;Recording&gt; Collection of Recording models
     */
    public function recording(RecordingFilter $filter): Collection
    {
        $data = $this-&gt;fetchEndpoint(&apos;recording&apos;, $filter-&gt;toQueryParameters());
        if (!isset($data[&apos;recordings&apos;])) {
            return collect();
        }
        return collect($data[&apos;recordings&apos;])-&gt;map(fn($item) =&gt; Recording::fromApiData($item));
    }
    /**
     * Search for labels and return models
     *
     * @param LabelFilter $filter Filter criteria
     * @return Collection&lt;Label&gt; Collection of Label models
     */
    public function label(LabelFilter $filter): Collection
    {
        $data = $this-&gt;fetchEndpoint(&apos;label&apos;, $filter-&gt;toQueryParameters());
        if (!isset($data[&apos;labels&apos;])) {
            return collect();
        }
        return collect($data[&apos;labels&apos;])-&gt;map(fn($item) =&gt; Label::fromApiData($item));
    }
    /**
     * Search for works and return models
     *
     * @param WorkFilter $filter Filter criteria
     * @return Collection&lt;Work&gt; Collection of Work models
     */
    public function work(WorkFilter $filter): Collection
    {
        $data = $this-&gt;fetchEndpoint(&apos;work&apos;, $filter-&gt;toQueryParameters());
        if (!isset($data[&apos;works&apos;])) {
            return collect();
        }
        return collect($data[&apos;works&apos;])-&gt;map(fn($item) =&gt; Work::fromApiData($item));
    }
    /**
     * Search for areas and return models
     *
     * @param AreaFilter $filter Filter criteria
     * @return Collection&lt;Area&gt; Collection of Area models
     */
    public function area(AreaFilter $filter): Collection
    {
        $data = $this-&gt;fetchEndpoint(&apos;area&apos;, $filter-&gt;toQueryParameters());
        if (!isset($data[&apos;areas&apos;])) {
            return collect();
        }
        return collect($data[&apos;areas&apos;])-&gt;map(fn($item) =&gt; Area::fromApiData($item));
    }
    /**
     * Search for places and return models
     *
     * @param PlaceFilter $filter Filter criteria
     * @return Collection&lt;Place&gt; Collection of Place models
     */
    public function place(PlaceFilter $filter): Collection
    {
        $data = $this-&gt;fetchEndpoint(&apos;place&apos;, $filter-&gt;toQueryParameters());
        if (!isset($data[&apos;places&apos;])) {
            return collect();
        }
        return collect($data[&apos;places&apos;])-&gt;map(fn($item) =&gt; Place::fromApiData($item));
    }
    /**
     * Search for instruments and return models
     *
     * @param InstrumentFilter $filter Filter criteria
     * @return Collection&lt;Instrument&gt; Collection of Instrument models
     */
    public function instrument(InstrumentFilter $filter): Collection
    {
        $data = $this-&gt;fetchEndpoint(&apos;instrument&apos;, $filter-&gt;toQueryParameters());
        if (!isset($data[&apos;instruments&apos;])) {
            return collect();
        }
        return collect($data[&apos;instruments&apos;])-&gt;map(fn($item) =&gt; Instrument::fromApiData($item));
    }
    /**
     * Search for series and return models
     *
     * @param SeriesFilter $filter Filter criteria
     * @return Collection&lt;Series&gt; Collection of Series models
     */
    public function series(SeriesFilter $filter): Collection
    {
        $data = $this-&gt;fetchEndpoint(&apos;series&apos;, $filter-&gt;toQueryParameters());
        if (!isset($data[&apos;series&apos;])) {
            return collect();
        }
        return collect($data[&apos;series&apos;])-&gt;map(fn($item) =&gt; Series::fromApiData($item));
    }
    /**
     * Search for events and return models
     *
     * @param EventFilter $filter Filter criteria
     * @return Collection&lt;Event&gt; Collection of Event models
     */
    public function event(EventFilter $filter): Collection
    {
        $data = $this-&gt;fetchEndpoint(&apos;event&apos;, $filter-&gt;toQueryParameters());
        if (!isset($data[&apos;events&apos;])) {
            return collect();
        }
        return collect($data[&apos;events&apos;])-&gt;map(fn($item) =&gt; Event::fromApiData($item));
    }
    /**
     * Search for genres and return models
     *
     * @param GenreFilter $filter Filter criteria
     * @return Collection&lt;Genre&gt; Collection of Genre models
     */
    public function genre(GenreFilter $filter): Collection
    {
        $data = $this-&gt;fetchEndpoint(&apos;genre&apos;, $filter-&gt;toQueryParameters());
        if (!isset($data[&apos;genres&apos;])) {
            return collect();
        }
        return collect($data[&apos;genres&apos;])-&gt;map(fn($item) =&gt; Genre::fromApiData($item));
    }
    /**
     * Search for URLs and return models
     *
     * @param UrlFilter $filter Filter criteria
     * @return Collection&lt;Url&gt; Collection of Url models
     */
    public function url(UrlFilter $filter): Collection
    {
        $data = $this-&gt;fetchEndpoint(&apos;url&apos;, $filter-&gt;toQueryParameters());
        if (!isset($data[&apos;urls&apos;])) {
            return collect();
        }
        return collect($data[&apos;urls&apos;])-&gt;map(fn($item) =&gt; Url::fromApiData($item));
    }
    /**
     * Get raw API response for artists (for backward compatibility)
     *
     * @param ArtistFilter $filter Filter criteria
     * @return array Raw API response
     */
    public function artistRaw(ArtistFilter $filter): array
    {
        return $this-&gt;fetchEndpoint(&apos;artist&apos;, $filter-&gt;toQueryParameters());
    }
    /**
     * Get raw API response for releases (for backward compatibility)
     *
     * @param ReleaseFilter $filter Filter criteria
     * @return array Raw API response
     */
    public function releaseRaw(ReleaseFilter $filter): array
    {
        return $this-&gt;fetchEndpoint(&apos;release&apos;, $filter-&gt;toQueryParameters());
    }
    /**
     * Get search metadata (count, offset, etc.) from last search
     *
     * @param string $type Entity type (artist, release, etc.)
     * @param mixed $filter Filter used for the search
     * @return array Metadata array
     */
    public function getSearchMetadata(string $type, $filter): array
    {
        $data = $this-&gt;fetchEndpoint($type, $filter-&gt;toQueryParameters());
        return [
            &apos;count&apos; =&gt; $data[&apos;count&apos;] ?? 0,
            &apos;offset&apos; =&gt; $data[&apos;offset&apos;] ?? 0,
            &apos;created&apos; =&gt; $data[&apos;created&apos;] ?? null,
        ];
    }
}</file><file path="app/Http/Middleware/AddContentSecurityPolicyHeaders.php">&lt;?php
namespace App\Http\Middleware;
use Closure;
use Illuminate\Http\Request;
use Illuminate\Support\Facades\Vite;
use Illuminate\Support\Str;
use Symfony\Component\HttpFoundation\Response;
class AddContentSecurityPolicyHeaders
{
    /**
     * Handle an incoming request.
     *
     * @param \Closure(\Illuminate\Http\Request): (\Symfony\Component\HttpFoundation\Response) $next
     */
    public function handle(Request $request, Closure $next): Response
    {
        return $next($request);
        if (Str::contains($request-&gt;path(), config(&apos;app.csp.disable_paths&apos;))) {
            return $next($request);
        }
        Vite::useCspNonce();
        return $next($request)-&gt;withHeaders([
            &apos;Content-Security-Policy&apos; =&gt; &quot;script-src &apos;nonce-&quot; . Vite::cspNonce() . &quot;&apos;; base-uri &apos;none&apos;; object-src &apos;none&apos;;&quot;,
        ]);
    }
}</file><file path="app/Http/Middleware/ForceJsonResponse.php">&lt;?php
namespace App\Http\Middleware;
use Closure;
use Illuminate\Http\Request;
use Symfony\Component\HttpFoundation\Response;
class ForceJsonResponse
{
    /**
     * Handle an incoming request.
     *
     * @param \Closure(\Illuminate\Http\Request): (\Symfony\Component\HttpFoundation\Response) $next
     */
    public function handle(Request $request, Closure $next): Response
    {
        $request-&gt;headers-&gt;set(&apos;Accept&apos;, &apos;application/json&apos;);
        return $next($request);
    }
}</file><file path="app/Http/Middleware/RedirectIfAuthenticated.php">&lt;?php
namespace App\Http\Middleware;
use App\Providers\RouteServiceProvider;
use Closure;
use Illuminate\Http\Request;
use Illuminate\Support\Facades\Auth;
use Symfony\Component\HttpFoundation\Response;
class RedirectIfAuthenticated
{
    /**
     * Handle an incoming request.
     *
     * @param \Closure(\Illuminate\Http\Request): (\Symfony\Component\HttpFoundation\Response) $next
     */
    public function handle(Request $request, Closure $next, string ...$guards): Response
    {
        $guards = empty($guards) ? [null] : $guards;
        foreach ($guards as $guard) {
            if (Auth::guard($guard)-&gt;check()) {
                if ($request-&gt;expectsJson()) {
                    return response()-&gt;json([&apos;error&apos; =&gt; &apos;Already authenticated.&apos;], 200);
                }
                return redirect(RouteServiceProvider::HOME);
            }
        }
        return $next($request);
    }
}</file><file path="app/Http/Middleware/SecurityHeadersMiddleware.php">&lt;?php
namespace App\Http\Middleware;
use Closure;
use Illuminate\Http\Request;
use Illuminate\Support\Str;
use Symfony\Component\HttpFoundation\Response;
class SecurityHeadersMiddleware
{
    /**
     * Handle an incoming request.
     *
     * @param \Closure(\Illuminate\Http\Request): (\Symfony\Component\HttpFoundation\Response) $next
     */
    public function handle(Request $request, Closure $next): Response
    {
        if (Str::contains($request-&gt;path(), &apos;log-viewer&apos;)) {
            return $next($request);
        }
        $response = $next($request);
        $headers = [
            &apos;X-Content-Type-Options&apos; =&gt; &apos;nosniff&apos;,
            &apos;Referrer-Policy&apos;        =&gt; &apos;strict-origin-when-cross-origin&apos;,
        ];
        foreach ($headers as $name =&gt; $value) {
            $response-&gt;headers-&gt;set($name, $value);
        }
        return $response;
    }
}</file><file path="app/Http/Requests/Artist/ArtistIndexRequest.php">&lt;?php
namespace App\Http\Requests\Artist;
use Illuminate\Foundation\Http\FormRequest;
class ArtistIndexRequest extends FormRequest
{
    /**
     * Determine if the user is authorized to make this request.
     */
    public function authorize(): bool
    {
        return true;
    }
    /**
     * Get the validation rules that apply to the request.
     *
     * @return array&lt;string, \Illuminate\Contracts\Validation\ValidationRule|array&lt;mixed&gt;|string&gt;
     */
    public function rules(): array
    {
        return [
            /**
             * @query
             * Comma seperated string of fields you want to select. If nothing is defined `select *` is default.
             * - title
             * - slug
             */
            &apos;fields&apos;    =&gt; &apos;string&apos;,
            /**
             * @query
             * Comma seperated string of relations
             * - portrait
             * - songs
             */
            &apos;relations&apos; =&gt; &apos;string&apos;,
            /**
             * @query
             * Current page
             */
            &apos;page&apos;      =&gt; &apos;int&apos;,
            /**
             * @query
             * Items per page
             */
            &apos;limit&apos;     =&gt; &apos;int&apos;,
            /**
             * @query
             * _Extension_ Comma seperated list of genres
             */
            &apos;genres&apos;    =&gt; &apos;string&apos;,
        ];
    }
}</file><file path="app/Http/Requests/Auth/RegisterRequest.php">&lt;?php
namespace App\Http\Requests\Auth;
use Illuminate\Foundation\Http\FormRequest;
use Illuminate\Support\Facades\Config;
class RegisterRequest extends FormRequest
{
    /**
     * Determine if the user is authorized to make this request.
     */
    public function authorize(): bool
    {
        return true;
    }
    /**
     * Get the validation rules that apply to the request.
     *
     * @return array&lt;string, \Illuminate\Contracts\Validation\ValidationRule|array&lt;mixed&gt;|string&gt;
     */
    public function rules(): array
    {
        return [
            &apos;name&apos;     =&gt; [&apos;required&apos;, &apos;string&apos;, &apos;max:255&apos;],
            &apos;email&apos;    =&gt; [&apos;required&apos;, &apos;email&apos;, &apos;max:255&apos;, &apos;unique:users&apos;],
            &apos;password&apos; =&gt; [&apos;required&apos;, &apos;confirmed&apos;],
        ];
    }
}</file><file path="app/Http/Requests/Genre/GenreIndexRequest.php">&lt;?php
namespace App\Http\Requests\Genre;
use Illuminate\Foundation\Http\FormRequest;
class GenreIndexRequest extends FormRequest
{
    /**
     * Determine if the user is authorized to make this request.
     */
    public function authorize(): bool
    {
        return true;
    }
    /**
     * Get the validation rules that apply to the request.
     *
     * @return array&lt;string, \Illuminate\Contracts\Validation\ValidationRule|array&lt;mixed&gt;|string&gt;
     */
    public function rules(): array
    {
        return [
            /**
             * @query
             * Comma seperated string of fields you want to select. If nothing is defined `select *` is default.
             * - name
             * - slug
             */
            &apos;fields&apos;      =&gt; &apos;string&apos;,
            /**
             * @query
             * Comma seperated string of relations
             * - songs
             */
            &apos;relations&apos;   =&gt; &apos;string&apos;,
            /**
             * @query
             *
             * Constrain the query to only fetch genres that are contained within the given library
             */
            &apos;librarySlug&apos; =&gt; &apos;string&apos;,
            /**
             * @query
             * Current page
             */
            &apos;page&apos;        =&gt; &apos;int&apos;,
            /**
             * @query
             * Items per page
             */
            &apos;limit&apos;       =&gt; &apos;int&apos;,
        ];
    }
}</file><file path="app/Http/Requests/Library/UpdateLibraryRequest.php">&lt;?php
namespace App\Http\Requests\Library;
use App\Models\LibraryType;
use Illuminate\Foundation\Http\FormRequest;
use Illuminate\Validation\Rule;
class UpdateLibraryRequest extends FormRequest
{
    /**
     * Determine if the user is authorized to make this request.
     */
    public function authorize(): bool
    {
        return false;
    }
    /**
     * Get the validation rules that apply to the request.
     *
     * @return array&lt;string, \Illuminate\Contracts\Validation\ValidationRule|array&lt;mixed&gt;|string&gt;
     */
    public function rules(): array
    {
        return [
            &apos;name&apos;  =&gt; &apos;string:min:1|max:100&apos;,
            &apos;path&apos;  =&gt; &apos;string:min:1|max:1000&apos;,
            &apos;type&apos;  =&gt; [&apos;optional&apos;, Rule::enum(LibraryType::class)],
            &apos;order&apos; =&gt; &apos;integer&apos;,
        ];
    }
}</file><file path="app/Http/Requests/User/UserIndexRequest.php">&lt;?php
namespace App\Http\Requests\User;
use Illuminate\Foundation\Http\FormRequest;
class UserIndexRequest extends FormRequest
{
    /**
     * Determine if the user is authorized to make this request.
     */
    public function authorize(): bool
    {
        return true;
    }
    /**
     * Get the validation rules that apply to the request.
     *
     * @return array&lt;string, \Illuminate\Contracts\Validation\ValidationRule|array&lt;mixed&gt;|string&gt;
     */
    public function rules(): array
    {
        return [
            /**
             * @query
             * Current page
             */
            &apos;page&apos;         =&gt; &apos;int&apos;,
            /**
             * @query
             * Items per page
             */
            &apos;limit&apos;        =&gt; &apos;int&apos;,
            /**
             * @query
             */
            &apos;globalFilter&apos; =&gt; &apos;string&apos;,
            /**
             * @query
             *
             * JSON object
             */
            &apos;filters&apos;      =&gt; &apos;string&apos;,
            /**
             * @query
             *
             * JSON object
             */
            &apos;filterModes&apos;  =&gt; &apos;string&apos;,
            /**
             * @query
             *
             * JSON object
             */
            &apos;sorting&apos;      =&gt; &apos;string&apos;,
        ];
    }
}</file><file path="app/Http/Resources/Auth/PersonalAccessTokenResource.php">&lt;?php
namespace App\Http\Resources\Auth;
use App\Http\Resources\HasJsonCollection;
use App\Models\PersonalAccessToken;
use Illuminate\Http\Request;
use Illuminate\Http\Resources\Json\JsonResource;
/**
 * @mixin PersonalAccessToken
 */
class PersonalAccessTokenResource extends JsonResource
{
    use HasJsonCollection;
    /**
     * Transform the resource into an array.
     *
     * @return array&lt;string, mixed&gt;
     */
    public function toArray(Request $request): array
    {
        return [
            &apos;name&apos;                  =&gt; $this-&gt;name,
            &apos;abilities&apos;             =&gt; $this-&gt;abilities,
            &apos;userAgent&apos;             =&gt; $this-&gt;user_agent,
            &apos;clientName&apos;            =&gt; $this-&gt;client_name,
            &apos;clientVersion&apos;         =&gt; $this-&gt;client_version,
            &apos;clientType&apos;            =&gt; $this-&gt;client_type,
            &apos;deviceOperatingSystem&apos; =&gt; $this-&gt;device_operating_system,
            &apos;deviceName&apos;            =&gt; $this-&gt;device_name,
            &apos;expiresAt&apos;             =&gt; $this-&gt;expires_at,
            &apos;createdAt&apos;             =&gt; $this-&gt;created_at,
            &apos;updatedAt&apos;             =&gt; $this-&gt;updated_at,
        ];
    }
}</file><file path="app/Http/Resources/Library/LibraryResource.php">&lt;?php
namespace App\Http\Resources\Library;
use App\Http\Resources\HasJsonCollection;
use App\Models\Library;
use Illuminate\Http\Request;
use Illuminate\Http\Resources\Json\JsonResource;
/**
 * @mixin Library
 */
class LibraryResource extends JsonResource
{
    use HasJsonCollection;
    /**
     * Transform the resource into an array.
     *
     * @return array&lt;string, mixed&gt;
     */
    public function toArray(Request $request): array
    {
        return [
            &apos;name&apos;      =&gt; $this-&gt;name,
            &apos;slug&apos;      =&gt; $this-&gt;slug,
            &apos;path&apos;      =&gt; $this-&gt;path,
            &apos;type&apos;      =&gt; $this-&gt;type,
            &apos;order&apos;     =&gt; $this-&gt;order,
            &apos;lastScan&apos;  =&gt; $this-&gt;last_scan,
            &apos;createdAt&apos; =&gt; $this-&gt;created_at,
            &apos;updatedAt&apos; =&gt; $this-&gt;updated_at,
        ];
    }
}</file><file path="app/Http/Resources/QueueMonitor/QueueMonitorResource.php">&lt;?php
namespace App\Http\Resources\QueueMonitor;
use App\Http\Resources\HasJsonCollection;
use App\Models\QueueMonitor;
use Illuminate\Http\Request;
use Illuminate\Http\Resources\Json\JsonResource;
/**
 * @mixin QueueMonitor
 */
class QueueMonitorResource extends JsonResource
{
    use HasJsonCollection;
    /**
     * Transform the resource into an array.
     *
     * @return array&lt;string, mixed&gt;
     */
    public function toArray(Request $request): array
    {
        return [
            &apos;id&apos;                =&gt; $this-&gt;id,
            &apos;job_id&apos;            =&gt; $this-&gt;job_id,
            &apos;name&apos;              =&gt; $this-&gt;name,
            &apos;queue&apos;             =&gt; $this-&gt;queue,
            &apos;started_at&apos;        =&gt; $this-&gt;started_at,
            &apos;started_at_exact&apos;  =&gt; $this-&gt;started_at_exact,
            &apos;finished_at&apos;       =&gt; $this-&gt;finished_at,
            &apos;finished_at_exact&apos; =&gt; $this-&gt;finished_at_exact,
            &apos;attempt&apos;           =&gt; $this-&gt;attempt,
            &apos;progress&apos;          =&gt; $this-&gt;progress,
            &apos;exception&apos;         =&gt; $this-&gt;exception,
            &apos;exception_class&apos;   =&gt; $this-&gt;exception_class,
            &apos;data&apos;              =&gt; $this-&gt;data,
            &apos;status&apos;            =&gt; $this-&gt;status,
            &apos;job_uuid&apos;          =&gt; $this-&gt;job_uuid,
            &apos;retried&apos;           =&gt; $this-&gt;retried,
            &apos;queued_at&apos;         =&gt; $this-&gt;queued_at,
        ];
    }
}</file><file path="app/Http/Resources/User/UserResource.php">&lt;?php
namespace App\Http\Resources\User;
use App\Http\Resources\HasJsonCollection;
use Illuminate\Http\Request;
use Illuminate\Http\Resources\Json\JsonResource;
/**
 * @mixin \App\Models\User
 */
class UserResource extends JsonResource
{
    use HasJsonCollection;
    /**
     * Transform the resource into an array.
     *
     * @return array&lt;string, mixed&gt;
     */
    public function toArray(Request $request): array
    {
        return [
            &apos;name&apos;      =&gt; $this-&gt;name,
            &apos;email&apos;     =&gt; $this-&gt;email,
            &apos;isAdmin&apos;   =&gt; (bool)$this-&gt;isAdmin(),
            &apos;createdAt&apos; =&gt; $this-&gt;created_at,
            &apos;updatedAt&apos; =&gt; $this-&gt;updated_at,
        ];
    }
}</file><file path="app/Jobs/BaseJob.php">&lt;?php
namespace App\Jobs;
use App\Jobs\Concerns\HasJobsLogger;
use App\Modules\QueueMonitor\Concerns\IsMonitored;
use Illuminate\Bus\Queueable;
use Illuminate\Foundation\Bus\Dispatchable;
use Illuminate\Queue\InteractsWithQueue;
use Illuminate\Queue\SerializesModels;
abstract class BaseJob
{
    use Dispatchable,
        InteractsWithQueue,
        Queueable,
        SerializesModels,
        IsMonitored,
        HasJobsLogger;
}</file><file path="app/Jobs/Concerns/HasJobsLogger.php">&lt;?php
namespace App\Jobs\Concerns;
use Illuminate\Support\Facades\Log;
trait HasJobsLogger
{
    protected function logger()
    {
        return Log::channel(&apos;jobs_file&apos;);
    }
}</file><file path="app/Jobs/Library/MetaDataMusicBrainzAlbumJob.php">&lt;?php
namespace App\Jobs\Library;
use App\Jobs\BaseJob;
use App\Models\Album;
use App\Models\Artist;
use Illuminate\Bus\Queueable;
use Illuminate\Contracts\Queue\ShouldQueue;
use Illuminate\Foundation\Bus\Dispatchable;
use Illuminate\Queue\InteractsWithQueue;
use Illuminate\Queue\SerializesModels;
use Illuminate\Support\Carbon;
use Illuminate\Support\Facades\Log;
use MusicBrainz\Filter\PageFilter;
use MusicBrainz\Filter\Search\ReleaseFilter;
use MusicBrainz\MusicBrainz;
use MusicBrainz\Value\ArtistCredit;
use MusicBrainz\Value\ArtistCreditList;
class MetaDataMusicBrainzAlbumJob extends BaseJob implements ShouldQueue
{
    use Dispatchable, InteractsWithQueue, Queueable, SerializesModels;
    /**
     * Create a new job instance.
     */
    public function __construct(public Album $album)
    {
        //
    }
    /**
     * Execute the job.
     */
    public function handle(): void
    {
        $musicBrainz = app(MusicBrainz::class);
        $releaseFilter = new ReleaseFilter();
        $releaseFilter-&gt;addReleaseName($this-&gt;album-&gt;title);
        $pageFilter = new PageFilter(0, 1);
        try {
            $artistList = $musicBrainz-&gt;api()-&gt;search()-&gt;release($releaseFilter, $pageFilter);
        } catch (\Throwable $e) {
            Log::warning($e-&gt;getMessage());
            $this-&gt;delete();
            return;
        }
        if (empty($artistList)) {
            $this-&gt;delete();
            return;
        }
        $release = $artistList[0]-&gt;getRelease();
        if (!$this-&gt;album-&gt;year &amp;&amp; $release-&gt;getDate()) {
            $this-&gt;album-&gt;year = Carbon::parse($release-&gt;getDate())-&gt;year;
        }
        $artists = $this-&gt;processCredits($release-&gt;getArtistCredits());
        $this-&gt;album-&gt;artist()-&gt;sync($artists);
        $this-&gt;album-&gt;update();
    }
    /**
     * @param ArtistCredit[]|ArtistCreditList $credits
     * @return Artist[]
     */
    private function processCredits(array|ArtistCreditList $credits)
    {
        $artists = [];
        foreach ($credits as $credit) {
            /** @var ArtistCredit $credit */
            $artists[] = Artist::firstOrCreate([
                &apos;name&apos; =&gt; $credit-&gt;getName(),
            ])-&gt;id;
        }
        return $artists;
    }
}</file><file path="app/Jobs/Library/Music/ScanMusicLibraryJob.php">&lt;?php
namespace App\Jobs\Library\Music;
use App\Events\LibraryScanCompleted;
use App\Jobs\BaseJob;
use App\Models\Library;
use Illuminate\Contracts\Queue\{ShouldBeUnique, ShouldQueue};
use Illuminate\Queue\Middleware\WithoutOverlapping;
use Illuminate\Support\Facades\File;
use Illuminate\Support\LazyCollection;
class ScanMusicLibraryJob extends BaseJob implements ShouldQueue, ShouldBeUnique
{
    public function __construct(public Library $library)
    {
    }
    public function middleware(): array
    {
        return [new WithoutOverlapping($this-&gt;library-&gt;id)-&gt;dontRelease()];
    }
    public function handle(): void
    {
        $this-&gt;queueProgress(0);
        $this-&gt;library-&gt;updateLastScan();
        $path = $this-&gt;library-&gt;path;
        $directories = LazyCollection::make(File::directories($path));
        $totalDirectories = count($directories);
        $processedDirectories = 0;
        $chunkSize = config(&apos;scanner.music.directory_chunk_size&apos;);
        $directories-&gt;chunk($chunkSize)-&gt;each(function ($chunk) use (&amp;$processedDirectories, $totalDirectories, &amp;$chunkSize) {
            foreach ($chunk as $directory) {
                ScanDirectoryJob::dispatch($directory, $this-&gt;library);
                $processedDirectories++;
                $this-&gt;queueProgressChunk($totalDirectories, $chunkSize);
            }
        });
        $this-&gt;queueProgress(100);
        $this-&gt;queueData([&apos;processedDirectories&apos; =&gt; $processedDirectories]);
        LibraryScanCompleted::dispatch($this-&gt;library);
    }
}</file><file path="app/Models/Queries/Trend/TrendValue.php">&lt;?php
namespace App\Models\Queries\Trend;
class TrendValue
{
    public function __construct(
        public string $date,
        public mixed  $aggregate,
    )
    {
    }
}</file><file path="app/Models/QueueMonitor.php">&lt;?php
namespace App\Models;
use App\Modules\QueueMonitor\MonitorStatus;
use Carbon\CarbonInterval;
use Illuminate\Database\Eloquent\Builder;
use Illuminate\Support\Arr;
use Illuminate\Support\Carbon;
use Illuminate\Support\Facades\Artisan;
class QueueMonitor extends BaseModel
{
    protected $table = &apos;queue_monitor&apos;;
    public $timestamps = false;
    protected $guarded = [];
    protected $casts = [
        &apos;failed&apos;      =&gt; &apos;bool&apos;,
        &apos;retried&apos;     =&gt; &apos;bool&apos;,
        &apos;queued_at&apos;   =&gt; &apos;datetime&apos;,
        &apos;started_at&apos;  =&gt; &apos;datetime&apos;,
        &apos;finished_at&apos; =&gt; &apos;datetime&apos;,
        &apos;exception&apos;   =&gt; &apos;json&apos;,
    ];
    // Scopes
    protected function scopeWhereJob(Builder $query, $jobId): void
    {
        $query-&gt;where(&apos;job_id&apos;, $jobId);
    }
    protected function scopeOrdered(Builder $query): void
    {
        $query
            -&gt;orderBy(&apos;started_at&apos;, &apos;desc&apos;)
            -&gt;orderBy(&apos;started_at_exact&apos;, &apos;desc&apos;);
    }
    protected function scopeLastHour(Builder $query): void
    {
        $query-&gt;where(&apos;started_at&apos;, &apos;&gt;&apos;, Carbon::now()-&gt;subHours(1));
    }
    protected function scopeToday(Builder $query): void
    {
        $query-&gt;whereRaw(&apos;DATE(started_at) = ?&apos;, [Carbon::now()-&gt;subHours(1)-&gt;format(&apos;Y-m-d&apos;)]);
    }
    protected function scopeFailed(Builder $query): void
    {
        $query-&gt;where(&apos;status&apos;, MonitorStatus::Failed);
    }
    protected function scopeSucceeded(Builder $query): void
    {
        $query-&gt;where(&apos;status&apos;, MonitorStatus::Succeeded);
    }
    // Methods
    public function getStartedAtExact(): ?Carbon
    {
        if (null === $this-&gt;started_at_exact) {
            return null;
        }
        return Carbon::parse($this-&gt;started_at_exact);
    }
    public function getFinishedAtExact(): ?Carbon
    {
        if (null === $this-&gt;finished_at_exact) {
            return null;
        }
        return Carbon::parse($this-&gt;finished_at_exact);
    }
    /**
     * Get the estimated remaining seconds. This requires a job progress to be set.
     *
     * @param Carbon|null $now
     *
     * @return float
     */
    public function getRemainingSeconds(?Carbon $now = null): float
    {
        return $this-&gt;getRemainingInterval($now)-&gt;totalSeconds;
    }
    public function getRemainingInterval(?Carbon $now = null): CarbonInterval
    {
        if (null === $now) {
            $now = Carbon::now();
        }
        if (!$this-&gt;progress || null === $this-&gt;started_at || $this-&gt;isFinished()) {
            return CarbonInterval::seconds(0);
        }
        if (0 === ($timeDiff = $now-&gt;getTimestamp() - $this-&gt;started_at-&gt;getTimestamp())) {
            return CarbonInterval::seconds(0);
        }
        return CarbonInterval::seconds(
            (100 - $this-&gt;progress) / ($this-&gt;progress / $timeDiff),
        )-&gt;cascade();
    }
    /**
     * Get the currently elapsed seconds.
     *
     * @param Carbon|null $end
     *
     * @return float
     */
    public function getElapsedSeconds(?Carbon $end = null): float
    {
        return $this-&gt;getElapsedInterval($end)-&gt;seconds;
    }
    public function getElapsedInterval(?Carbon $end = null): CarbonInterval
    {
        if (null === $end) {
            $end = $this-&gt;getFinishedAtExact() ?? $this-&gt;finished_at ?? Carbon::now();
        }
        $startedAt = $this-&gt;getStartedAtExact() ?? $this-&gt;started_at;
        if (null === $startedAt) {
            return CarbonInterval::seconds(0);
        }
        return $startedAt-&gt;diffAsCarbonInterval($end);
    }
    /**
     * Get any optional data that has been added to the monitor model within the job.
     *
     * @return array&lt;string, mixed&gt;
     */
    public function getData(): array
    {
        return json_decode($this-&gt;data, true) ?? [];
    }
    /**
     * Recreate the exception.
     *
     * @param bool $rescue Wrap the exception recreation to catch exceptions
     *
     * @return \Throwable|null
     */
    public function getException(bool $rescue = true): ?\Throwable
    {
        if (null === $this-&gt;exception_class) {
            return null;
        }
        if (!$rescue) {
            return new $this-&gt;exception_class($this-&gt;exception_message);
        }
        try {
            return new $this-&gt;exception_class($this-&gt;exception_message);
        } catch (\Exception $exception) {
            return null;
        }
    }
    /**
     * Get the base class name of the job.
     *
     * @return string|null
     */
    public function getBasename(): ?string
    {
        if (null === $this-&gt;name) {
            return null;
        }
        return Arr::last(explode(&apos;\\&apos;, $this-&gt;name));
    }
    /**
     * check if the job is finished.
     *
     * @return bool
     */
    public function isFinished(): bool
    {
        if ($this-&gt;hasFailed()) {
            return true;
        }
        return null !== $this-&gt;finished_at;
    }
    /**
     * Check if the job has failed.
     *
     * @return bool
     */
    public function hasFailed(): bool
    {
        return MonitorStatus::Failed === $this-&gt;status;
    }
    /**
     * check if the job has succeeded.
     *
     * @return bool
     */
    public function hasSucceeded(): bool
    {
        if (!$this-&gt;isFinished()) {
            return false;
        }
        return !$this-&gt;hasFailed();
    }
    /**
     * @return void
     * @throws \Exception
     */
    public function retry(): void
    {
        $this-&gt;retried = true;
        $this-&gt;save();
        $response = Artisan::call(&apos;queue:retry&apos;, [&apos;id&apos; =&gt; $this-&gt;job_uuid]);
        if (0 !== $response) {
            throw new \Exception(Artisan::output());
        }
    }
    public function canBeRetried(): bool
    {
        return !$this-&gt;retried
            &amp;&amp; MonitorStatus::Failed === $this-&gt;status
            &amp;&amp; null !== $this-&gt;job_uuid;
    }
}</file><file path="app/Models/TokenAbility.php">&lt;?php
namespace App\Models;
enum TokenAbility: string
{
    case ACCESS_API = &apos;access-api&apos;;
    case ACCESS_BROADCASTING = &apos;access-broadcasting&apos;;
    case ACCESS_STREAM = &apos;access-stream&apos;;
    case ISSUE_ACCESS_TOKEN = &apos;issue-access-token&apos;;
}</file><file path="app/Models/UserMediaActivity.php">&lt;?php
namespace App\Models;
use App\Models\BaseModel;
use App\Modules\Nanoid\Concerns\HasNanoPublicId;
use Illuminate\Database\Eloquent\Factories\HasFactory;
class UserMediaActivity extends BaseModel
{
    use HasFactory, HasNanoPublicId;
    protected $table = &apos;user_media_activities&apos;;
    protected $fillable = [
        &apos;public_id&apos;,
        &apos;play_count&apos;,
        &apos;love&apos;,
        &apos;last_played_at&apos;,
        &apos;last_platform&apos;,
        &apos;last_player&apos;,
    ];
    protected $casts = [
        &apos;love&apos; =&gt; &apos;boolean&apos;,
    ];
    public function getRouteKeyName(): string
    {
        return &apos;public_id&apos;;
    }
    public function userMediaActivityable()
    {
        return $this-&gt;morphTo();
    }
    public function user()
    {
        return $this-&gt;belongsTo(User::class);
    }
}</file><file path="app/Models/Version.php">&lt;?php
namespace App\Models;
use App\Models\Concerns\IsBaseModel;
use Illuminate\Database\Eloquent\SoftDeletes;
use Overtrue\LaravelVersionable\Version as BaseVersion;
class Version extends BaseVersion
{
    use SoftDeletes, IsBaseModel;
    protected $dateFormat = &apos;Y-m-d H:i:sO&apos;;
    protected $table = &apos;versions&apos;;
    protected $guarded = [];
    /**
     * @var array
     */
    protected $casts = [
        &apos;contents&apos; =&gt; &apos;json&apos;,
    ];
    protected $with = [
        &apos;versionable&apos;,
    ];
    public function getIncrementing()
    {
        return true;
    }
    public function getKeyType()
    {
        return $this-&gt;keyType;
    }
}</file><file path="app/Modules/BlurHash/BlurHashServiceProvider.php">&lt;?php
namespace App\Modules\BlurHash;
use Illuminate\Foundation\Application;
use Illuminate\Support\ServiceProvider;
class BlurHashServiceProvider extends ServiceProvider
{
    /**
     * Register the service provider.
     */
    public function register(): void
    {
        $this-&gt;app-&gt;scoped(&apos;blurhash&apos;, function (Application $app) {
            $config = $app-&gt;get(&apos;config&apos;)-&gt;get(&apos;blurhash&apos;);
            return new BlurHash(
                $config[&apos;driver&apos;] ?? &apos;gd&apos;,
                $config[&apos;components-x&apos;],
                $config[&apos;components-y&apos;],
                $config[&apos;resized-max-size&apos;] ?? $config[&apos;resized-image-max-width&apos;],
            );
        });
    }
}</file><file path="app/Modules/DeviceDetector/Device.php">&lt;?php
namespace App\Modules\DeviceDetector;
use Illuminate\Support\Facades\Facade;
/**
 * @mixin DeviceDetector
 */
class Device extends Facade
{
    protected static function getFacadeAccessor(): string
    {
        return DeviceDetector::class;
    }
}</file><file path="app/Modules/Humanize/HumanDuration.php">&lt;?php
namespace App\Modules\Humanize;
class HumanDuration
{
    private const int SECONDS_IN_MINUTE = 60;
    private const int MINUTES_IN_HOUR = 60;
    private const int HOURS_IN_DAY = 24;
    public int $days = 0;
    public int $hours = 0;
    public int $minutes = 0;
    public float $seconds = 0.0;
    public int $hoursPerDay;
    private string $daysRegex = &apos;/([0-9.]+)\s?[dD]/&apos;;
    private string $hoursRegex = &apos;/([0-9.]+)\s?[hH]/&apos;;
    private string $minutesRegex = &apos;/(\d{1,2})\s?[mM]/&apos;;
    private string $secondsRegex = &apos;/(\d{1,2}(\.\d+)?)\s?[sS]/&apos;;
    public function __construct(string|float|int|null $duration = null, int $hoursPerDay = self::HOURS_IN_DAY)
    {
        $this-&gt;hoursPerDay = $hoursPerDay;
        if ($duration !== null) {
            $this-&gt;parse($duration);
        }
    }
    public function parse(string|float|int|null $duration): self|false
    {
        $this-&gt;reset();
        if ($duration === null) {
            return false;
        }
        if (is_numeric($duration)) {
            return $this-&gt;parseNumericDuration((float)$duration);
        }
        if (str_contains($duration, &apos;:&apos;)) {
            return $this-&gt;parseColonFormattedDuration($duration);
        }
        return $this-&gt;parseRegexFormattedDuration($duration);
    }
    public function toSeconds(string|float|int|null $duration = null, int|false $precision = false): float|int
    {
        if ($duration !== null) {
            $this-&gt;parse($duration);
        }
        $totalSeconds = $this-&gt;seconds +
            $this-&gt;minutes * self::SECONDS_IN_MINUTE +
            $this-&gt;hours * self::MINUTES_IN_HOUR * self::SECONDS_IN_MINUTE +
            $this-&gt;days * $this-&gt;hoursPerDay * self::MINUTES_IN_HOUR * self::SECONDS_IN_MINUTE;
        return $precision !== false ? round($totalSeconds, $precision) : $totalSeconds;
    }
    public function toMinutes(string|float|int|null $duration = null, int|false $precision = false): float|int
    {
        if ($duration !== null) {
            $this-&gt;parse($duration);
        }
        $totalMinutes = $this-&gt;toSeconds() / self::SECONDS_IN_MINUTE;
        return $precision !== false ? round($totalMinutes, $precision) : $totalMinutes;
    }
    public function humanize(string|float|int|null $duration = null): string
    {
        if ($duration !== null) {
            $this-&gt;parse($duration);
        }
        $output = &apos;&apos;;
        if ($this-&gt;seconds &gt; 0 || ($this-&gt;seconds === 0.0 &amp;&amp; $this-&gt;minutes === 0 &amp;&amp; $this-&gt;hours === 0 &amp;&amp; $this-&gt;days === 0)) {
            $output .= number_format($this-&gt;seconds, 0) . &apos;s &apos;;
        }
        if ($this-&gt;minutes &gt; 0) {
            $output = $this-&gt;minutes . __(&apos;date.time.minute.char&apos;) . &apos; &apos; . $output;
        }
        if ($this-&gt;hours &gt; 0) {
            $output = $this-&gt;hours . __(&apos;date.time.hour.char&apos;) . &apos; &apos; . $output;
        }
        if ($this-&gt;days &gt; 0) {
            $output = $this-&gt;days . __(&apos;date.time.day.char&apos;) . &apos; &apos; . $output;
        }
        return trim($output);
    }
    private function reset(): void
    {
        $this-&gt;seconds = 0.0;
        $this-&gt;minutes = 0;
        $this-&gt;hours = 0;
        $this-&gt;days = 0;
    }
    private function parseNumericDuration(float $duration): self
    {
        $this-&gt;seconds = $duration;
        $this-&gt;minutes = (int)floor($this-&gt;seconds / self::SECONDS_IN_MINUTE);
        $this-&gt;seconds = fmod($this-&gt;seconds, self::SECONDS_IN_MINUTE);
        $this-&gt;hours = (int)floor($this-&gt;minutes / self::MINUTES_IN_HOUR);
        $this-&gt;minutes %= self::MINUTES_IN_HOUR;
        $this-&gt;days = (int)floor($this-&gt;hours / $this-&gt;hoursPerDay);
        $this-&gt;hours %= $this-&gt;hoursPerDay;
        return $this;
    }
    private function parseColonFormattedDuration(string $duration): self
    {
        $parts = explode(&apos;:&apos;, $duration);
        $count = count($parts);
        if ($count === 2) {
            $this-&gt;minutes = (int)$parts[0];
            $this-&gt;seconds = (float)$parts[1];
        } else if ($count === 3) {
            $this-&gt;hours = (int)$parts[0];
            $this-&gt;minutes = (int)$parts[1];
            $this-&gt;seconds = (float)$parts[2];
        }
        return $this;
    }
    private function parseRegexFormattedDuration(string $duration): self
    {
        if ($matches = $this-&gt;matchRegex($this-&gt;daysRegex, $duration)) {
            [$whole, $fraction] = $this-&gt;numberBreakdown((float)$matches[1]);
            $this-&gt;days += $whole;
            $this-&gt;hours += $fraction * $this-&gt;hoursPerDay;
        }
        if ($matches = $this-&gt;matchRegex($this-&gt;hoursRegex, $duration)) {
            [$whole, $fraction] = $this-&gt;numberBreakdown((float)$matches[1]);
            $this-&gt;hours += $whole;
            $this-&gt;minutes += $fraction * self::MINUTES_IN_HOUR;
        }
        if ($matches = $this-&gt;matchRegex($this-&gt;minutesRegex, $duration)) {
            $this-&gt;minutes += (int)$matches[1];
        }
        if ($matches = $this-&gt;matchRegex($this-&gt;secondsRegex, $duration)) {
            $this-&gt;seconds += (float)$matches[1];
        }
        return $this;
    }
    private function matchRegex(string $regex, string $duration): ?array
    {
        preg_match($regex, $duration, $matches);
        return $matches ?: null;
    }
    private function numberBreakdown(float $number): array
    {
        $whole = (int)floor($number);
        $fraction = $number - $whole;
        return [$whole, $fraction];
    }
}</file><file path="app/Modules/Nanoid/NanoIdService.php">&lt;?php
namespace App\Modules\Nanoid;
use Hidehalo\Nanoid\Client;
class NanoIdService
{
    private Client $client;
    public function __construct(?Client $client = null)
    {
        $this-&gt;client = new Client();
    }
    public function generateId(int $size = 21)
    {
        return $this-&gt;client-&gt;generateId($size, Client::MODE_DYNAMIC);
    }
}</file><file path="app/Modules/QueueMonitor/Concerns/IsMonitored.php">&lt;?php
namespace App\Modules\QueueMonitor\Concerns;
use App\Models\QueueMonitor;
use App\Services\QueueMonitorService;
/**
 * @mixin \Illuminate\Queue\InteractsWithQueue
 */
trait IsMonitored
{
    /**
     * The unix timestamp explaining the last time a progress has been written to database.
     *
     * @var int|null
     */
    private $progressLastUpdated;
    /**
     * Internal variable used for tracking chunking progress.
     */
    private int $progressCurrentChunk = 0;
    /**
     * Update progress.
     *
     * @param int $progress Progress as integer 0-100
     *
     * @return void
     */
    public function queueProgress(int $progress): void
    {
        $progress = min(100, max(0, $progress));
        if ($this-&gt;isQueueProgressOnCooldown($progress)) {
            return;
        }
        if (!$monitor = $this-&gt;getQueueMonitor()) {
            return;
        }
        $monitor-&gt;update([
            &apos;progress&apos; =&gt; $progress,
        ]);
        $this-&gt;progressLastUpdated = time();
    }
    /**
     * Automatically update the current progress in each chunk iteration.
     *
     * @param int $collectionCount The total collection item amount
     * @param int $perChunk The size of each chunk
     *
     * @return void
     */
    public function queueProgressChunk(int $collectionCount, int $perChunk): void
    {
        $this-&gt;queueProgress(
            intval(++$this-&gt;progressCurrentChunk * $perChunk / $collectionCount * 100),
        );
    }
    /**
     * Set Monitor data.
     *
     * @param array $data Custom data
     * @param bool $merge Merge the data instead of overriding
     *
     * @return void
     */
    public function queueData(array $data, bool $merge = false): void
    {
        if (!$monitor = $this-&gt;getQueueMonitor()) {
            return;
        }
        if ($merge) {
            $data = array_merge($monitor-&gt;getData(), $data);
        }
        $monitor-&gt;update([
            &apos;data&apos; =&gt; json_encode($data),
        ]);
    }
    /**
     * Check if the monitor should skip writing the progress to database avoiding rapid update queries.
     * The progress values 0, 25, 50, 75 and 100 will always be written.
     */
    private function isQueueProgressOnCooldown(int $progress): bool
    {
        if (in_array($progress, [0, 25, 50, 75, 100])) {
            return false;
        }
        if (null === $this-&gt;progressLastUpdated) {
            return false;
        }
        return time() - $this-&gt;progressLastUpdated &lt; $this-&gt;progressCooldown();
    }
    /**
     * Delete Queue Monitor object.
     *
     * @return void
     */
    protected function deleteQueueMonitor(): void
    {
        if (!$monitor = $this-&gt;getQueueMonitor()) {
            return;
        }
        $monitor-&gt;delete();
    }
    /**
     * Return Queue Monitor Model.
     *
     * @return QueueMonitor|null
     */
    protected function getQueueMonitor(): ?QueueMonitor
    {
        if (!property_exists($this, &apos;job&apos;)) {
            return null;
        }
        if (!$this-&gt;job) {
            return null;
        }
        if (!$jobId = app(QueueMonitorService::class)-&gt;getJobId($this-&gt;job)) {
            return null;
        }
        return QueueMonitor::whereJob($jobId)
            -&gt;orderBy(&apos;started_at&apos;, &apos;desc&apos;)
            -&gt;first();
    }
    /**
     * Weather to keep successful monitor models. This can be used if you only want to keep
     * failed monitors for jobs that are frequently executed but worth to monitor. You are free
     * to use the Laravel built-in failed job procedures.
     *
     * @return bool
     */
    public static function keepMonitorOnSuccess(): bool
    {
        return true;
    }
    /**
     * The time in seconds to wait before a following queue progress update will be issued.
     * This is used to avoid writing many progress updates to the database. 0 = no delay.
     *
     * @return int
     */
    public function progressCooldown(): int
    {
        return 0;
    }
}</file><file path="app/Modules/QueueMonitor/MonitorStatus.php">&lt;?php
namespace App\Modules\QueueMonitor;
use App\Extensions\EnumExt;
enum MonitorStatus: string
{
    use EnumExt;
    case Running = &apos;running&apos;;
    case Succeeded = &apos;succeeded&apos;;
    case Failed = &apos;failed&apos;;
    case Stale = &apos;stale&apos;;
    case Queued = &apos;queued&apos;;
}</file><file path="app/Modules/Recommendation/Algorithms/JaccardIndex.php">&lt;?php
namespace App\Modules\Recommendation\Algorithms;
use App\Modules\Recommendation\Contracts\AlgorithmInterface;
class JaccardIndex implements AlgorithmInterface
{
    public function __construct(
        private readonly string $a,
        private readonly string $b,
        private readonly string $separator = &apos;,&apos;,
    )
    {
    }
    public function calculate()
    {
        $a = explode($this-&gt;separator, $this-&gt;a);
        $b = explode($this-&gt;separator, $this-&gt;b);
        $intersection = array_unique(array_intersect($a, $b));
        $union = array_unique(array_merge($a, $b));
        // Handle edge case to prevent division by zero
        if (empty($union)) {
            return 0.0;
        }
        return count($intersection) / count($union);
    }
    // Add an alternative constructor for array inputs
    public static function fromArrays(array $a, array $b): self
    {
        return new self(
            implode(&apos;,&apos;, $a),
            implode(&apos;,&apos;, $b)
        );
    }
}</file><file path="app/Notifications/ForgotPasswordNotification.php">&lt;?php
namespace App\Notifications;
use Illuminate\Bus\Queueable;
use Illuminate\Contracts\Queue\ShouldQueue;
use Illuminate\Notifications\Messages\MailMessage;
use Illuminate\Notifications\Notification;
class ForgotPasswordNotification extends Notification implements ShouldQueue
{
    use Queueable;
    public function __construct(
        public string $url,
    )
    {
    }
    /**
     * Get the notification&apos;s delivery channels.
     *
     * @return array&lt;int, string&gt;
     */
    public function via(object $notifiable): array
    {
        return [&apos;mail&apos;];
    }
    /**
     * Get the mail representation of the notification.
     */
    public function toMail(object $notifiable): MailMessage
    {
        return (new MailMessage)
            -&gt;line(&apos;In order to reset your password, please click the button below.&apos;)
            -&gt;action(&apos;Reset password&apos;, $this-&gt;url)
            -&gt;line(&apos;If you did not request a password reset, please ignore this email.&apos;);
    }
}</file><file path="app/Notifications/VerifyEmail.php">&lt;?php
namespace App\Notifications;
use Illuminate\Auth\Notifications\VerifyEmail as VerifyEmailLaravel;
class VerifyEmail extends VerifyEmailLaravel
{
    /**
     * Get the verification URL for the given notifiable.
     *
     * @param mixed $notifiable
     * @return string
     */
    protected function verificationUrl($notifiable)
    {
        $withToken = str_replace([&apos;{id}&apos;], $notifiable-&gt;getKey(), config(&apos;app.url&apos;) . &apos;/verify/{id}/{emailHash}&apos;);
        $withEmail = str_replace([&apos;{emailHash}&apos;], sha1($notifiable-&gt;getEmailForVerification()), $withToken);
        return url($withEmail);
    }
}</file><file path="app/Observers/ImageObserver.php">&lt;?php
namespace App\Observers;
use App\Models\Image;
use App\Modules\BlurHash\Facades\BlurHash;
class ImageObserver
{
    public function creating(Image $image)
    {
        if ($image-&gt;path) {
            $image-&gt;blurhash = BlurHash::encode($image-&gt;path);
        }
    }
    public function saving(Image $image)
    {
        if ($image-&gt;wasChanged(&apos;path&apos;)) {
            $image-&gt;blurhash = BlurHash::encode($image-&gt;path);
        }
    }
}</file><file path="app/Policies/AlbumPolicy.php">&lt;?php
namespace App\Policies;
use App\Models\Album;
use App\Models\User;
use Illuminate\Auth\Access\Response;
class AlbumPolicy
{
    /**
     * Determine whether the user can view any models.
     */
    public function viewAny(User $user): bool
    {
        return $user-&gt;can(&apos;albums.viewAny&apos;);
    }
    /**
     * Determine whether the user can view the model.
     */
    public function view(User $user, Album $album): bool
    {
        if ($user-&gt;can(&apos;album.viewAny&apos;)) {
            return true;
        }
        return $album-&gt;userHasAccessToLibrary($user-&gt;id, $album-&gt;id);
    }
    /**
     * Determine whether the user can create models.
     */
    public function create(User $user): bool
    {
        return $user-&gt;can(&apos;album.create&apos;);
    }
    /**
     * Determine whether the user can update the model.
     */
    public function update(User $user, Album $album): bool
    {
        return $user-&gt;can(&apos;album.update&apos;);
    }
    /**
     * Determine whether the user can delete the model.
     */
    public function delete(User $user, Album $album): bool
    {
        return $user-&gt;can(&apos;album.delete&apos;);
    }
    /**
     * Determine whether the user can restore the model.
     */
    public function restore(User $user, Album $album): bool
    {
        return $user-&gt;can(&apos;album.delete&apos;);
    }
    /**
     * Determine whether the user can permanently delete the model.
     */
    public function forceDelete(User $user, Album $album): bool
    {
        return $user-&gt;can(&apos;album.forceDelete&apos;);
    }
}</file><file path="app/Policies/SongPolicy.php">&lt;?php
namespace App\Policies;
use App\Models\Song;
use App\Models\User;
use Illuminate\Auth\Access\Response;
class SongPolicy
{
    /**
     * Determine whether the user can view any models.
     */
    public function viewAny(User $user): bool
    {
        return $user-&gt;can(&apos;song.viewAny&apos;);
    }
    /**
     * Determine whether the user can view the model.
     */
    public function view(User $user, Song $song): bool
    {
        if ($user-&gt;can(&apos;song.viewAny&apos;)) {
            return true;
        }
        if ($song-&gt;relationLoaded(&apos;album&apos;)) {
            return $song-&gt;userHasAccessToLibrary($user-&gt;id, $song-&gt;album-&gt;library_id);
        }
        return false;
    }
    /**
     * Determine whether the user can create models.
     */
    public function create(User $user): bool
    {
        return $user-&gt;isAdmin();
    }
    /**
     * Determine whether the user can update the model.
     */
    public function update(User $user, Song $song): bool
    {
        return $user-&gt;isAdmin();
    }
    /**
     * Determine whether the user can delete the model.
     */
    public function delete(User $user, Song $song): bool
    {
        return $user-&gt;isAdmin();
    }
    /**
     * Determine whether the user can restore the model.
     */
    public function restore(User $user, Song $song): bool
    {
        return $user-&gt;isAdmin();
    }
    /**
     * Determine whether the user can permanently delete the model.
     */
    public function forceDelete(User $user, Song $song): bool
    {
        return $user-&gt;isAdmin();
    }
}</file><file path="app/Providers/AuthorizationGateServiceProvider.php">&lt;?php
namespace App\Providers;
use App\Models\User;
use Illuminate\Support\Facades\Gate;
use Illuminate\Support\ServiceProvider;
use Opcodes\LogViewer\LogFile;
use Opcodes\LogViewer\LogFolder;
class AuthorizationGateServiceProvider extends ServiceProvider
{
    public function boot(): void
    {
        Gate::define(&apos;downloadLogFile&apos;, function (?User $user, LogFile $file) {
            return $user &amp;&amp; $user-&gt;isAdmin();
        });
        Gate::define(&apos;downloadLogFolder&apos;, function (?User $user, LogFolder $folder) {
            return $user &amp;&amp; $user-&gt;isAdmin();
        });
        Gate::define(&apos;deleteLogFile&apos;, function (?User $user, LogFile $file) {
            return $user &amp;&amp; $user-&gt;isAdmin();
        });
        Gate::define(&apos;viewApiDocs&apos;, function (User $user) {
            return (bool)$user;
        });
        Gate::define(&apos;viewLogViewer&apos;, function (User $user) {
            return $user-&gt;isAdmin();
        });
    }
}</file><file path="app/Providers/BroadcastServiceProvider.php">&lt;?php
namespace App\Providers;
use Illuminate\Support\Facades\Broadcast;
use Illuminate\Support\ServiceProvider;
class BroadcastServiceProvider extends ServiceProvider
{
    public function boot(): void
    {
        Broadcast::routes([&apos;middleware&apos; =&gt; [&apos;auth:sanctum&apos;]]);
        require base_path(&apos;routes/channels.php&apos;);
    }
}</file><file path="app/Providers/FortifyServiceProvider.php">&lt;?php
namespace App\Providers;
use App\Actions\Fortify\CreateNewUser;
use App\Actions\Fortify\ResetUserPassword;
use App\Actions\Fortify\UpdateUserPassword;
use App\Actions\Fortify\UpdateUserProfileInformation;
use Illuminate\Cache\RateLimiting\Limit;
use Illuminate\Http\Request;
use Illuminate\Support\Facades\RateLimiter;
use Illuminate\Support\ServiceProvider;
use Illuminate\Support\Str;
use Laravel\Fortify\Fortify;
class FortifyServiceProvider extends ServiceProvider
{
    public function boot(): void
    {
        Fortify::createUsersUsing(CreateNewUser::class);
        Fortify::updateUserProfileInformationUsing(UpdateUserProfileInformation::class);
        Fortify::updateUserPasswordsUsing(UpdateUserPassword::class);
        Fortify::resetUserPasswordsUsing(ResetUserPassword::class);
        RateLimiter::for(&apos;login&apos;, function (Request $request) {
            $throttleKey = Str::transliterate(Str::lower($request-&gt;input(Fortify::username())) . &apos;|&apos; . $request-&gt;ip());
            return Limit::perMinute(5)-&gt;by($throttleKey);
        });
        RateLimiter::for(&apos;two-factor&apos;, function (Request $request) {
            return Limit::perMinute(5)-&gt;by($request-&gt;session()-&gt;get(&apos;login.id&apos;));
        });
    }
}</file><file path="app/Providers/HorizonServiceProvider.php">&lt;?php
namespace App\Providers;
use App\Models\User;
use Illuminate\Support\Facades\Gate;
use Laravel\Horizon\HorizonApplicationServiceProvider;
class HorizonServiceProvider extends HorizonApplicationServiceProvider
{
    /**
     * Register the Horizon gate.
     *
     * This gate determines who can access Horizon in non-local environments.
     */
    protected function gate(): void
    {
        Gate::define(&apos;viewHorizon&apos;, function (User $user) {
            return $user-&gt;isAdmin();
        });
    }
}</file><file path="app/Providers/RouteServiceProvider.php">&lt;?php
namespace App\Providers;
use Illuminate\Cache\RateLimiting\Limit;
use Illuminate\Foundation\Support\Providers\RouteServiceProvider as ServiceProvider;
use Illuminate\Http\Request;
use Illuminate\Support\Facades\RateLimiter;
use Illuminate\Support\Facades\Route;
class RouteServiceProvider extends ServiceProvider
{
    /**
     * The path to your application&apos;s &quot;home&quot; route.
     *
     * Typically, users are redirected here after authentication.
     *
     * @var string
     */
    public const HOME = &apos;/&apos;;
    /**
     * Define your route model bindings, pattern filters, and other route configuration.
     */
    public function boot(): void
    {
        RateLimiter::for(&apos;api&apos;, function (Request $request) {
            return Limit::perMinute(250)-&gt;by($request-&gt;user()?-&gt;id ?: $request-&gt;ip());
        });
        RateLimiter::for(&apos;publicApi&apos;, function (Request $request) {
            return Limit::perMinute(250)-&gt;by($request-&gt;user()?-&gt;id ?: $request-&gt;ip());
        });
        $this-&gt;routes(function () {
            Route::middleware(&apos;api&apos;)
                -&gt;prefix(&apos;api&apos;)
                -&gt;group(base_path(&apos;routes/api.php&apos;));
            Route::middleware(&apos;web&apos;)
                -&gt;group(base_path(&apos;routes/web.php&apos;));
        });
    }
}</file><file path="app/Repositories/Cache/CacheRepositoryInterface.php">&lt;?php
namespace App\Repositories\Cache;
interface CacheRepositoryInterface
{
    public function has(string $key, array $tags = []): bool;
    public function get(string $key, array $tags = []);
    public function put(string $key, $value, int $minutes, array $tags = []): void;
    public function forget(string $key, array $tags = []): void;
}</file><file path="app/Repositories/Cache/LaravelCacheRepository.php">&lt;?php
namespace App\Repositories\Cache;
use Illuminate\Support\Facades\Cache;
class LaravelCacheRepository implements CacheRepositoryInterface
{
    public function has(string $key, array $tags = []): bool
    {
        return empty($tags) ? Cache::has($key) : Cache::tags($tags)-&gt;has($key);
    }
    public function get(string $key, array $tags = [])
    {
        return empty($tags) ? Cache::get($key) : Cache::tags($tags)-&gt;get($key);
    }
    public function put(string $key, $value, int $minutes, array $tags = []): void
    {
        empty($tags) ? Cache::put($key, $value, $minutes) : Cache::tags($tags)-&gt;put($key, $value, $minutes);
    }
    public function forget(string $key, array $tags = []): void
    {
        empty($tags) ? Cache::forget($key) : Cache::tags($tags)-&gt;forget($key);
    }
    public function hashKey(string $key)
    {
        return hash(&apos;sha256&apos;, $key);
    }
}</file><file path="app/Services/AuthTokenService.php">&lt;?php
namespace App\Services;
use App\Models\PersonalAccessToken;
class AuthTokenService
{
    public function pruneExpiredTokens()
    {
        return PersonalAccessToken::whereExpired()-&gt;delete();
    }
    public function getExpiredTokenCount()
    {
        return PersonalAccessToken::whereExpired()-&gt;count();
    }
    public function revokeToken(string $token): bool
    {
        $model = PersonalAccessToken::whereToken($token)-&gt;firstOrFail();
        return $model-&gt;update([
            &apos;expires_at&apos; =&gt; now(),
        ]);
    }
}</file><file path="app/Services/OpCacheService.php">&lt;?php
namespace App\Services;
use Symfony\Component\Finder\Finder;
class OpCacheService
{
    public function compile($force = false)
    {
        if (!ini_get(&apos;opcache.dups_fix&apos;) &amp;&amp; !$force) {
            return [&apos;message&apos; =&gt; &apos;opcache.dups_fix must be enabled, or run with --force&apos;];
        }
        $compiled = 0;
        // Get files in these paths
        $files = collect(Finder::create()-&gt;in(config(&apos;opcache.directories&apos;))
            -&gt;name(&apos;*.php&apos;)
            -&gt;ignoreUnreadableDirs()
            -&gt;notContains(&apos;#!/usr/bin/env php&apos;)
            -&gt;exclude(config(&apos;opcache.exclude&apos;))
            -&gt;files()
            -&gt;followLinks());
        // optimized files
        $files-&gt;each(function ($file) use (&amp;$compiled) {
            try {
                if (!opcache_is_script_cached($file)) {
                    opcache_compile_file($file);
                }
                $compiled++;
            } catch (\Exception $e) {
            }
        });
        return [
            &apos;total_files_count&apos; =&gt; $files-&gt;count(),
            &apos;compiled_count&apos;    =&gt; $compiled,
        ];
    }
}</file><file path="app/Services/QueueMetrics/QueueMetricsService.php">&lt;?php
namespace App\Services\QueueMetrics;
use App\Models\QueueMonitor;
use App\Modules\QueueMonitor\MonitorStatus;
use App\Services\QueueMetrics\Models\QueueMetric;
use Illuminate\Support\Carbon;
use Illuminate\Support\Facades\DB;
class QueueMetricsService
{
    /**
     * Collects and aggregates queue metrics for the last configured number of days.
     *
     * This function retrieves various queue metrics, including the total jobs executed,
     * total execution time, and average execution time over a specified period of days
     * configured in the application settings. It also retrieves the same metrics for the
     * preceding period for comparison.
     *
     * Metrics are returned as an array of QueueMetric objects.
     *
     * @return QueueMetric[]
     */
    public function collect(int $aggregateDays = 14)
    {
        // Define the raw expressions using `selectRaw`
        $expressionTotalTime = DB::raw(&apos;SUM(EXTRACT(EPOCH FROM (finished_at - started_at))) as total_time_elapsed&apos;);
        $expressionAverageTime = DB::raw(&apos;AVG(EXTRACT(EPOCH FROM (finished_at - started_at))) as average_time_elapsed&apos;);
        $aggregationColumns = [
            DB::raw(&apos;COUNT(*) as count&apos;),
            $expressionTotalTime,
            $expressionAverageTime,
        ];
        // Aggregated info for the last `$days` days
        $aggregatedInfo = QueueMonitor::query()
            -&gt;select($aggregationColumns)
            -&gt;where(&apos;status&apos;, &apos;!=&apos;, MonitorStatus::Running-&gt;value)
            -&gt;where(&apos;started_at&apos;, &apos;&gt;=&apos;, Carbon::now()-&gt;subDays($aggregateDays))
            -&gt;first();
        // Aggregated comparison info for the period between `$days * 2` and `$days` days ago
        $aggregatedComparisonInfo = QueueMonitor::query()
            -&gt;select($aggregationColumns)
            -&gt;where(&apos;status&apos;, &apos;!=&apos;, MonitorStatus::Running-&gt;value)
            -&gt;where(&apos;started_at&apos;, &apos;&gt;=&apos;, Carbon::now()-&gt;subDays($aggregateDays * 2))
            -&gt;where(&apos;started_at&apos;, &apos;&lt;=&apos;, Carbon::now()-&gt;subDays($aggregateDays))
            -&gt;first();
        if (!$aggregatedInfo || !$aggregatedComparisonInfo) {
            return [];
        }
        $res[] = new QueueMetric(
            title: __(&apos;Total jobs executed&apos;),
            value: $aggregatedInfo-&gt;count ?? 0,
            previousValue: $aggregatedComparisonInfo-&gt;count,
            format: &apos;%d&apos;,
        );
        $res[] = new QueueMetric(
            title: __(&apos;Total execution time&apos;),
            value: $aggregatedComparisonInfo-&gt;total_time_elapsed ?? 0,
            previousValue: $aggregatedComparisonInfo-&gt;total_time_elapsed,
            format: &apos;%ds&apos;,
        );
        $res[] = new QueueMetric(
            title: __(&apos;Average execution time&apos;),
            value: $aggregatedInfo-&gt;average_time_elapsed ?? 0,
            previousValue: $aggregatedComparisonInfo-&gt;average_time_elapsed,
            format: &apos;%0.2fs&apos;,
        );
        return $res;
    }
}</file><file path="app/Services/QueueMonitorService.php">&lt;?php
namespace App\Services;
use App\Models\QueueMonitor;
use App\Modules\QueueMonitor\Concerns\IsMonitored;
use App\Modules\QueueMonitor\Contracts\MonitoredJobContract;
use App\Modules\QueueMonitor\MonitorStatus;
use Illuminate\Contracts\Encryption\Encrypter;
use Illuminate\Contracts\Queue\Job as JobContract;
use Illuminate\Support\Carbon;
use Illuminate\Queue\Events\{JobExceptionOccurred, JobFailed, JobProcessed, JobProcessing, JobQueued};
use Illuminate\Queue\QueueManager;
use Illuminate\Support\Facades\{Crypt, Event, Route};
use Illuminate\Support\ServiceProvider;
use JsonException;
use Laravel\Horizon\Events\JobPushed;
use RuntimeException;
use Throwable;
class QueueMonitorService
{
    private const string TIMESTAMP_EXACT_FORMAT = &apos;Y-m-d H:i:s.u&apos;;
    public function handleJobQueued(JobQueued $event): void
    {
        self::jobQueued($event);
    }
    public function handleJobPushed(JobPushed $event): void
    {
        self::jobPushed($event);
    }
    public function handleJobProcessing(JobProcessing $event): void
    {
        self::jobStarted($event-&gt;job);
    }
    public function handleJobProcessed(JobProcessed $event): void
    {
        self::jobFinished($event-&gt;job, MonitorStatus::Succeeded);
    }
    public function handleJobFailed(JobFailed $event): void
    {
        self::jobFinished($event-&gt;job, MonitorStatus::Failed, $event-&gt;exception);
    }
    public function handleJobExceptionOccurred(JobExceptionOccurred $event): void
    {
        self::jobFinished($event-&gt;job, MonitorStatus::Failed, $event-&gt;exception);
    }
    public function getJobId(JobContract $job): string
    {
        if ($jobId = $job-&gt;getJobId()) {
            return (string)$jobId;
        }
        return sha1($job-&gt;getRawBody());
    }
    /**
     * Start Queue Monitoring for Job.
     *
     * @param JobQueued $event
     *
     * @return void
     * @throws JsonException
     */
    protected function jobQueued(JobQueued $event): void
    {
        if (!self::shouldBeMonitored($event-&gt;job)) {
            return;
        }
        // add initial data
        if (method_exists($event-&gt;job, &apos;initialMonitorData&apos;)) {
            $data = json_encode($event-&gt;job-&gt;initialMonitorData());
        }
        QueueMonitor::create([
            &apos;job_id&apos;    =&gt; $event-&gt;id,
            /** @phpstan-ignore-next-line */
            &apos;job_uuid&apos;  =&gt; isset($event-&gt;payload) ? $event-&gt;payload()[&apos;uuid&apos;] : (is_numeric($event-&gt;id) ? null : $event-&gt;id),
            &apos;name&apos;      =&gt; get_class($event-&gt;job),
            /** @phpstan-ignore-next-line */
            &apos;queue&apos;     =&gt; $event-&gt;job-&gt;queue ?: &apos;default&apos;,
            &apos;status&apos;    =&gt; MonitorStatus::Queued,
            &apos;queued_at&apos; =&gt; now(),
            &apos;data&apos;      =&gt; $data ?? null,
        ]);
    }
    /**
     * Start Queue Monitoring for Job.
     *
     * @param JobPushed $event
     *
     * @return void
     */
    protected function jobPushed($event): void
    {
        if (!self::shouldBeMonitored($event-&gt;payload-&gt;displayName())) {
            return;
        }
        $initialData = null;
        // add initial data
        if (method_exists($event-&gt;payload-&gt;displayName(), &apos;initialMonitorData&apos;)) {
            $jobInstance = self::getJobInstance($event-&gt;payload-&gt;decoded[&apos;data&apos;]);
            $initialData = $jobInstance-&gt;initialMonitorData();
        }
        QueueMonitor::create([
            &apos;job_id&apos;    =&gt; $event-&gt;payload-&gt;decoded[&apos;id&apos;] ?? $event-&gt;payload-&gt;decoded[&apos;uuid&apos;],
            &apos;job_uuid&apos;  =&gt; $event-&gt;payload-&gt;decoded[&apos;uuid&apos;] ?? null,
            &apos;name&apos;      =&gt; $event-&gt;payload-&gt;displayName(),
            &apos;queue&apos;     =&gt; $event-&gt;queue ?: &apos;default&apos;,
            &apos;status&apos;    =&gt; MonitorStatus::Queued,
            &apos;queued_at&apos; =&gt; now(),
            &apos;data&apos;      =&gt; $initialData ? json_encode($initialData) : null,
        ]);
        // mark the retried job
        if ($event-&gt;payload-&gt;isRetry()) {
            QueueMonitor::where(&apos;job_uuid&apos;, $event-&gt;payload-&gt;retryOf())-&gt;update([&apos;retried&apos; =&gt; true]);
        }
    }
    /**
     * Job Start Processing.
     *
     * @param JobContract $job
     *
     * @return void
     */
    protected function jobStarted(JobContract $job): void
    {
        if (!self::shouldBeMonitored($job)) {
            return;
        }
        $now = Carbon::now();
        $monitor = QueueMonitor::updateOrCreate([
            &apos;job_id&apos; =&gt; $jobId = self::getJobId($job),
            &apos;queue&apos;  =&gt; $job-&gt;getQueue() ?: &apos;default&apos;,
            &apos;status&apos; =&gt; MonitorStatus::Queued,
        ], [
            &apos;job_uuid&apos;         =&gt; $job-&gt;uuid(),
            &apos;name&apos;             =&gt; $job-&gt;resolveName(),
            &apos;started_at&apos;       =&gt; $now,
            &apos;started_at_exact&apos; =&gt; $now-&gt;format(self::TIMESTAMP_EXACT_FORMAT),
            &apos;attempt&apos;          =&gt; $job-&gt;attempts(),
            &apos;status&apos;           =&gt; MonitorStatus::Running,
        ]);
        // Mark jobs with same job id (different execution) as stale
        QueueMonitor::where(&apos;id&apos;, &apos;!=&apos;, $monitor-&gt;id)
            -&gt;where(&apos;job_id&apos;, $jobId)
            -&gt;where(&apos;status&apos;, &apos;!=&apos;, MonitorStatus::Failed)
            -&gt;whereNull(&apos;finished_at&apos;)
            -&gt;each(function (QueueMonitor $monitor) {
                $monitor-&gt;update([
                    &apos;finished_at&apos;       =&gt; $now = Carbon::now(),
                    &apos;finished_at_exact&apos; =&gt; $now-&gt;format(self::TIMESTAMP_EXACT_FORMAT),
                    &apos;status&apos;            =&gt; MonitorStatus::Stale,
                ]);
            });
    }
    /**
     * Finish Queue Monitoring for Job.
     *
     * @param JobContract $job
     * @param MonitorStatus $status
     * @param Throwable|null $exception
     *
     * @return void
     */
    protected function jobFinished(JobContract $job, MonitorStatus $status, ?Throwable $exception = null): void
    {
        if (!self::shouldBeMonitored($job)) {
            return;
        }
        $monitor = QueueMonitor::where(&apos;job_id&apos;, self::getJobId($job))
            -&gt;where(&apos;attempt&apos;, $job-&gt;attempts())
            -&gt;orderByDesc(&apos;started_at&apos;)
            -&gt;first();
        if (null === $monitor) {
            return;
        }
        $now = Carbon::now();
        $resolvedJob = $job-&gt;resolveName();
        if (null === $exception &amp;&amp; false === $resolvedJob::keepMonitorOnSuccess()) {
            $monitor-&gt;delete();
            return;
        }
        // if the job has an exception, but it&apos;s not failed (it did not exceed max tries and max exceptions),
        // so it will be back to the queue
        if (MonitorStatus::Failed == $status &amp;&amp; !$job-&gt;hasFailed()) {
            $status = MonitorStatus::Queued;
        }
        // if the job is processed, but it&apos;s released, so it will be back to the queue also
        if (MonitorStatus::Stale == $status &amp;&amp; $job-&gt;isReleased()) {
            $status = MonitorStatus::Queued;
        }
        $attributes = [
            &apos;finished_at&apos;       =&gt; $now,
            &apos;finished_at_exact&apos; =&gt; $now-&gt;format(self::TIMESTAMP_EXACT_FORMAT),
            &apos;status&apos;            =&gt; $status,
        ];
        if (null !== $exception) {
            $attributes += [
                &apos;exception&apos;       =&gt; $exception,
                &apos;exception_class&apos; =&gt; get_class($exception),
            ];
        }
        $monitor-&gt;update($attributes);
    }
    /**
     * Determine weather the Job should be monitored, default true.
     *
     * @param object|string|MonitoredJobContract $job
     * @return bool
     */
    public function shouldBeMonitored(object|string $job): bool
    {
        $class = $job instanceof JobContract ? $job-&gt;resolveName() : $job;
        return array_key_exists(IsMonitored::class, class_uses_recursive($class));
    }
    /**
     * @param array&lt;string, mixed&gt; $data
     *
     * @return MonitoredJobContract
     */
    private function getJobInstance(array $data)
    {
        if (str_starts_with($data[&apos;command&apos;], &apos;O:&apos;)) {
            return unserialize($data[&apos;command&apos;]);
        }
        return Crypt::decrypt($data[&apos;command&apos;]);
    }
}</file><file path="app/Services/SmartPlaylistService.php">&lt;?php
namespace App\Services;
use App\Models\Song;
use Illuminate\Database\Eloquent\Builder;
use Illuminate\Support\Arr;
class SmartPlaylistService
{
    public function getSongsForRules(array $rules)
    {
        $query = Song::query();
        foreach ($rules as $ruleGroup) {
            $query-&gt;where(function (Builder  $q) use ($ruleGroup) {
                foreach ($ruleGroup as $rule) {
                    $this-&gt;applyRule($q, $rule);
                }
            });
        }
        return $query-&gt;get();
    }
    protected function applyRule(Builder $query, array $rule)
    {
        $field = $rule[&apos;field&apos;];
        $operator = $rule[&apos;operator&apos;];
        $value = $rule[&apos;value&apos;];
        switch ($field) {
            case &apos;genre&apos;:
                return $this-&gt;applyGenreRule($query, $operator, $value);
            case &apos;artist&apos;:
                return $this-&gt;applyArtistRule($query, $operator, $value);
            case &apos;year&apos;:
                return $this-&gt;applyNumericRule($query, &apos;year&apos;, $operator, $value);
            case &apos;duration&apos;:
                return $this-&gt;applyNumericRule($query, &apos;length&apos;, $operator, $value);
        }
    }
    protected function applyGenreRule(Builder $query, $operator, $value)
    {
        dump($value, $operator, $value);
        if ($operator === &apos;is&apos;) {
            return $query-&gt;whereHas(&apos;genres&apos;, function (Builder $q) use ($value) {
                return $q-&gt;whereIn(&apos;name&apos;, Arr::wrap($value));
            });
        }
        if ($operator === &apos;isNot&apos;) {
            return $query-&gt;whereDoesntHave(&apos;genres&apos;, function ($q) use ($value) {
                $q-&gt;whereIn(&apos;name&apos;, Arr::wrap($value));
            });
        }
    }
    protected function applyArtistRule($query, $operator, $value)
    {
        if ($operator === &apos;is&apos;) {
            return $query-&gt;whereHas(&apos;artists&apos;, function ($q) use ($value) {
                $q-&gt;whereIn(&apos;name&apos;, Arr::wrap($value));
            });
        }
        if ($operator === &apos;isNot&apos;) {
            return $query-&gt;whereDoesntHave(&apos;artists&apos;, function ($q) use ($value) {
                $q-&gt;whereIn(&apos;name&apos;, Arr::wrap($value));
            });
        }
    }
    protected function applyNumericRule($query, $field, $operator, $value)
    {
        switch ($operator) {
            case &apos;is&apos;:
                return $query-&gt;where($field, $value);
            case &apos;isNot&apos;:
                return $query-&gt;where($field, &apos;!=&apos;, $value);
            case &apos;greaterThan&apos;:
                return $query-&gt;where($field, &apos;&gt;&apos;, $value);
            case &apos;lessThan&apos;:
                return $query-&gt;where($field, &apos;&lt;&apos;, $value);
            case &apos;between&apos;:
                return $query-&gt;whereBetween($field, $value);
        }
    }
}</file><file path="app/Services/SystemInfoService.php">&lt;?php
namespace App\Services;
use App\Modules\PhpInfoParser\Info;
class SystemInfoService
{
    public function getVmStatus()
    {
        return swoole_get_vm_status();
    }
    public function getPhpInfo(): array
    {
        return Info::getModules();
    }
}</file><file path="artisan">#!/usr/bin/env php
&lt;?php

define(&apos;LARAVEL_START&apos;, microtime(true));

/*
|--------------------------------------------------------------------------
| Register The Auto Loader
|--------------------------------------------------------------------------
|
| Composer provides a convenient, automatically generated class loader
| for our application. We just need to utilize it! We&apos;ll require it
| into the script here so that we do not have to worry about the
| loading of any of our classes manually. It&apos;s great to relax.
|
*/

require __DIR__.&apos;/vendor/autoload.php&apos;;

$app = require_once __DIR__.&apos;/bootstrap/app.php&apos;;

/*
|--------------------------------------------------------------------------
| Run The Artisan Application
|--------------------------------------------------------------------------
|
| When we run the console application, the current CLI command will be
| executed in this console and the response sent back to a terminal
| or another output device for the developers. Here goes nothing!
|
*/

$kernel = $app-&gt;make(Illuminate\Contracts\Console\Kernel::class);

$status = $kernel-&gt;handle(
    $input = new Symfony\Component\Console\Input\ArgvInput,
    new Symfony\Component\Console\Output\ConsoleOutput
);

/*
|--------------------------------------------------------------------------
| Shutdown The Application
|--------------------------------------------------------------------------
|
| Once Artisan has finished running, we will fire off the shutdown events
| so that any final work may be done by the application before we shut
| down the process. This is the last thing to happen to the request.
|
*/

$kernel-&gt;terminate($input, $status);

exit($status);</file><file path="config/auth.php">&lt;?php
return [
    /*
    |--------------------------------------------------------------------------
    | Authentication Defaults
    |--------------------------------------------------------------------------
    |
    | This option controls the default authentication &quot;guard&quot; and password
    | reset options for your application. You may change these defaults
    | as required, but they&apos;re a perfect start for most applications.
    |
    */
    &apos;defaults&apos; =&gt; [
        &apos;guard&apos;     =&gt; &apos;web&apos;,
        &apos;passwords&apos; =&gt; &apos;users&apos;,
    ],
    /*
    |--------------------------------------------------------------------------
    | Authentication Guards
    |--------------------------------------------------------------------------
    |
    | Next, you may define every authentication guard for your application.
    | Of course, a great default configuration has been defined for you
    | here which uses session storage and the Eloquent user provider.
    |
    | All authentication drivers have a user provider. This defines how the
    | users are actually retrieved out of your database or other storage
    | mechanisms used by this application to persist your user&apos;s data.
    |
    | Supported: &quot;session&quot;
    |
    */
    &apos;guards&apos; =&gt; [
        &apos;web&apos; =&gt; [
            &apos;driver&apos;   =&gt; &apos;session&apos;,
            &apos;provider&apos; =&gt; &apos;users&apos;,
        ],
        &apos;api&apos; =&gt; [
            &apos;driver&apos;   =&gt; &apos;sanctum&apos;,
            &apos;provider&apos; =&gt; &apos;users&apos;,
            &apos;hash&apos; =&gt; false,
        ],
    ],
    /*
    |--------------------------------------------------------------------------
    | User Providers
    |--------------------------------------------------------------------------
    |
    | All authentication drivers have a user provider. This defines how the
    | users are actually retrieved out of your database or other storage
    | mechanisms used by this application to persist your user&apos;s data.
    |
    | If you have multiple user tables or models you may configure multiple
    | sources which represent each model / table. These sources may then
    | be assigned to any extra authentication guards you have defined.
    |
    | Supported: &quot;database&quot;, &quot;eloquent&quot;
    |
    */
    &apos;providers&apos; =&gt; [
        &apos;users&apos; =&gt; [
            &apos;driver&apos; =&gt; &apos;eloquent&apos;,
            &apos;model&apos; =&gt; App\Models\User::class,
            &apos;password_fallback&apos; =&gt; true,
        ],
        // &apos;users&apos; =&gt; [
        //     &apos;driver&apos; =&gt; &apos;database&apos;,
        //     &apos;table&apos; =&gt; &apos;users&apos;,
        // ],
    ],
    /*
    |--------------------------------------------------------------------------
    | Resetting Passwords
    |--------------------------------------------------------------------------
    |
    | You may specify multiple password reset configurations if you have more
    | than one user table or model in the application and you want to have
    | separate password reset settings based on the specific user types.
    |
    | The expiry time is the number of minutes that each reset token will be
    | considered valid. This security feature keeps tokens short-lived so
    | they have less time to be guessed. You may change this as needed.
    |
    | The throttle setting is the number of seconds a user must wait before
    | generating more password reset tokens. This prevents the user from
    | quickly generating a very large amount of password reset tokens.
    |
    */
    &apos;passwords&apos; =&gt; [
        &apos;users&apos; =&gt; [
            &apos;provider&apos; =&gt; &apos;users&apos;,
            &apos;table&apos;    =&gt; &apos;password_reset_tokens&apos;,
            &apos;expire&apos;   =&gt; 60,
            &apos;throttle&apos; =&gt; 60,
        ],
    ],
    /*
    |--------------------------------------------------------------------------
    | Password Confirmation Timeout
    |--------------------------------------------------------------------------
    |
    | Here you may define the amount of seconds before a password confirmation
    | times out and the user is prompted to re-enter their password via the
    | confirmation screen. By default, the timeout lasts for three hours.
    |
    */
    &apos;password_timeout&apos;                  =&gt; 10800,
    /*
    |--------------------------------------------------------------------------
    | Use signed email verification URL
    |--------------------------------------------------------------------------
    |
    | Whether or not to sign the email verification URL
    | like the standard Laravel implementation does.
    | If set to `true`, additional `expires` and `signature` parameters
    | will be added to the URL. When verifying the email through the API
    | both those fields are required as well.
    | It defaults to `false` for backwards compatibility.
    |
    */
    &apos;use_signed_email_verification_url&apos; =&gt; true,
    /*
    |--------------------------------------------------------------------------
    | Identification
    |--------------------------------------------------------------------------
    |
    | Configure the credential fields by which the user will be identified.
    | Default: email
    */
    &apos;user_identifier_field_name&apos; =&gt; &apos;email&apos;,
    &apos;email_verification_link_expires_in_minutes&apos; =&gt; 60,
];</file><file path="config/blurhash.php">&lt;?php
return [
    /*
     * The image driver is used for encoding and decoding blurhash.
     *
     * Supported drivers include &quot;gd&quot;, &quot;imagick&quot;, and &quot;php-vips&quot;.
     */
    &apos;driver&apos; =&gt; env(&apos;BLURHASH_DRIVER&apos;, &apos;gd&apos;),
    /*
     * Components are selected from the image&apos;s x and y axis.
     *
     * Choosing more components means the placeholder will
     * retain more information, but it also makes the
     * BlurHash string longer. However, having too many
     * components doesn&apos;t always result in a better look.
     *
     * The valid range for values is from 1 to 9.
     */
    &apos;components-x&apos; =&gt; 4,
    &apos;components-y&apos; =&gt; 3,
    /*
     * When encoding the image, it will resize to a smaller
     * version to enhance performance. It&apos;s not recommended
     * to set the max width and height values larger than 256.
     */
    &apos;resized-max-size&apos; =&gt; 64,
];</file><file path="config/session.php">&lt;?php
use Illuminate\Support\Str;
return [
    /*
    |--------------------------------------------------------------------------
    | Default Session Driver
    |--------------------------------------------------------------------------
    |
    | This option controls the default session &quot;driver&quot; that will be used on
    | requests. By default, we will use the lightweight native driver but
    | you may specify any of the other wonderful drivers provided here.
    |
    | Supported: &quot;file&quot;, &quot;cookie&quot;, &quot;database&quot;, &quot;apc&quot;,
    |            &quot;memcached&quot;, &quot;redis&quot;, &quot;dynamodb&quot;, &quot;array&quot;
    |
    */
    &apos;driver&apos; =&gt; env(&apos;SESSION_DRIVER&apos;, &apos;file&apos;),
    /*
    |--------------------------------------------------------------------------
    | Session Lifetime
    |--------------------------------------------------------------------------
    |
    | Here you may specify the number of minutes that you wish the session
    | to be allowed to remain idle before it expires. If you want them
    | to immediately expire on the browser closing, set that option.
    |
    */
    &apos;lifetime&apos; =&gt; env(&apos;SESSION_LIFETIME&apos;, 120),
    &apos;expire_on_close&apos; =&gt; false,
    /*
    |--------------------------------------------------------------------------
    | Session Encryption
    |--------------------------------------------------------------------------
    |
    | This option allows you to easily specify that all of your session data
    | should be encrypted before it is stored. All encryption will be run
    | automatically by Laravel and you can use the Session like normal.
    |
    */
    &apos;encrypt&apos; =&gt; false,
    /*
    |--------------------------------------------------------------------------
    | Session File Location
    |--------------------------------------------------------------------------
    |
    | When using the native session driver, we need a location where session
    | files may be stored. A default has been set for you but a different
    | location may be specified. This is only needed for file sessions.
    |
    */
    &apos;files&apos; =&gt; storage_path(&apos;framework/sessions&apos;),
    /*
    |--------------------------------------------------------------------------
    | Session Database Connection
    |--------------------------------------------------------------------------
    |
    | When using the &quot;database&quot; or &quot;redis&quot; session drivers, you may specify a
    | connection that should be used to manage these sessions. This should
    | correspond to a connection in your database configuration options.
    |
    */
    &apos;connection&apos; =&gt; env(&apos;SESSION_CONNECTION&apos;),
    /*
    |--------------------------------------------------------------------------
    | Session Database Table
    |--------------------------------------------------------------------------
    |
    | When using the &quot;database&quot; session driver, you may specify the table we
    | should use to manage the sessions. Of course, a sensible default is
    | provided for you; however, you are free to change this as needed.
    |
    */
    &apos;table&apos; =&gt; &apos;sessions&apos;,
    /*
    |--------------------------------------------------------------------------
    | Session Cache Store
    |--------------------------------------------------------------------------
    |
    | While using one of the framework&apos;s cache driven session backends you may
    | list a cache store that should be used for these sessions. This value
    | must match with one of the application&apos;s configured cache &quot;stores&quot;.
    |
    | Affects: &quot;apc&quot;, &quot;dynamodb&quot;, &quot;memcached&quot;, &quot;redis&quot;
    |
    */
    &apos;store&apos; =&gt; env(&apos;SESSION_STORE&apos;),
    /*
    |--------------------------------------------------------------------------
    | Session Sweeping Lottery
    |--------------------------------------------------------------------------
    |
    | Some session drivers must manually sweep their storage location to get
    | rid of old sessions from storage. Here are the chances that it will
    | happen on a given request. By default, the odds are 2 out of 100.
    |
    */
    &apos;lottery&apos; =&gt; [2, 100],
    /*
    |--------------------------------------------------------------------------
    | Session Cookie Name
    |--------------------------------------------------------------------------
    |
    | Here you may change the name of the cookie used to identify a session
    | instance by ID. The name specified here will get used every time a
    | new session cookie is created by the framework for every driver.
    |
    */
    &apos;cookie&apos; =&gt; env(
        &apos;SESSION_COOKIE&apos;,
        Str::slug(env(&apos;APP_NAME&apos;, &apos;baander&apos;), &apos;_&apos;) . &apos;_session&apos;,
    ),
    /*
    |--------------------------------------------------------------------------
    | Session Cookie Path
    |--------------------------------------------------------------------------
    |
    | The session cookie path determines the path for which the cookie will
    | be regarded as available. Typically, this will be the root path of
    | your application but you are free to change this when necessary.
    |
    */
    &apos;path&apos; =&gt; &apos;/&apos;,
    /*
    |--------------------------------------------------------------------------
    | Session Cookie Domain
    |--------------------------------------------------------------------------
    |
    | Here you may change the domain of the cookie used to identify a session
    | in your application. This will determine which domains the cookie is
    | available to in your application. A sensible default has been set.
    |
    */
    &apos;domain&apos; =&gt; env(&apos;SESSION_DOMAIN&apos;),
    /*
    |--------------------------------------------------------------------------
    | HTTPS Only Cookies
    |--------------------------------------------------------------------------
    |
    | By setting this option to true, session cookies will only be sent back
    | to the server if the browser has a HTTPS connection. This will keep
    | the cookie from being sent to you when it can&apos;t be done securely.
    |
    */
    &apos;secure&apos; =&gt; env(&apos;SESSION_SECURE_COOKIE&apos;),
    /*
    |--------------------------------------------------------------------------
    | HTTP Access Only
    |--------------------------------------------------------------------------
    |
    | Setting this value to true will prevent JavaScript from accessing the
    | value of the cookie and the cookie will only be accessible through
    | the HTTP protocol. You are free to modify this option if needed.
    |
    */
    &apos;http_only&apos; =&gt; true,
    /*
    |--------------------------------------------------------------------------
    | Same-Site Cookies
    |--------------------------------------------------------------------------
    |
    | This option determines how your cookies behave when cross-site requests
    | take place, and can be used to mitigate CSRF attacks. By default, we
    | will set this value to &quot;lax&quot; since this is a secure default value.
    |
    | Supported: &quot;lax&quot;, &quot;strict&quot;, &quot;none&quot;, null
    |
    */
    &apos;same_site&apos; =&gt; &apos;lax&apos;,
    /*
    |--------------------------------------------------------------------------
    | Partitioned Cookies
    |--------------------------------------------------------------------------
    |
    | Setting this value to true will tie the cookie to the top-level site for
    | a cross-site context. Partitioned cookies are accepted by the browser
    | when flagged &quot;secure&quot; and the Same-Site attribute is set to &quot;none&quot;.
    |
    */
    &apos;partitioned&apos; =&gt; false,
];</file><file path="config/transcoder.php">&lt;?php
return [
    &apos;host&apos; =&gt; env(&apos;TRANSCODE_HOST&apos;, &apos;localhost&apos;),
    &apos;port&apos; =&gt; env(&apos;TRANSCODE_PORT&apos;, &apos;9000&apos;),
];</file><file path="config/versionable.php">&lt;?php
return [
    /*
     * Keep versions, you can redefine in target model.
     * Default: 0 - Keep all versions.
     */
    &apos;keep_versions&apos; =&gt; 0,
    /*
     * User foreign key name of versions table.
     */
    &apos;user_foreign_key&apos; =&gt; &apos;user_id&apos;,
    /*
     * The model class for store versions.
     */
    &apos;version_model&apos; =&gt; \App\Models\Version::class,
    /**
     * The model class for user.
     */
    &apos;user_model&apos; =&gt; \App\Models\User::class,
    /**
     * Use uuid for version id.
     */
    &apos;uuid&apos; =&gt; false,
];</file><file path="database/factories/UserTwoFactorAuthenticationFactory.php">&lt;?php
namespace Database\Factories;
use App\Models\UserTwoFactorAuthentication;
use App\Modules\TwoFactor\TwoFactorService;
use Illuminate\Database\Eloquent\Factories\Factory;
use Illuminate\Support\Collection;
/**
 * @extends \Illuminate\Database\Eloquent\Factories\Factory&lt;\App\Models\UserTwoFactorAuthentication&gt;
 */
class UserTwoFactorAuthenticationFactory extends Factory
{
    protected $model = UserTwoFactorAuthentication::class;
    /**
     * Define the model&apos;s default state.
     *
     * @return array&lt;string, mixed&gt;
     */
    public function definition(): array
    {
        /** @var TwoFactorService $service */
        $service = app(TwoFactorService::class);
        $config = config(&apos;two-factor&apos;);
        $data = array_merge([
            &apos;shared_secret&apos; =&gt; $service-&gt;generateSecret(),
            &apos;enabled_at&apos;    =&gt; $this-&gt;faker-&gt;dateTimeBetween(&apos;-1 years&apos;),
            &apos;label&apos;         =&gt; config(&apos;two-factor.issuer&apos;) . &apos;:&apos; . $this-&gt;faker-&gt;freeEmail,
        ], $config[&apos;totp&apos;]);
        [$enabled, $amount, $length] = array_values($config[&apos;recovery&apos;]);
        if ($enabled) {
            $data[&apos;recovery_codes&apos;] = UserTwoFactorAuthentication::generateRecoveryCodes($amount, $length);
            $data[&apos;recovery_codes_generated_at&apos;] = $this-&gt;faker-&gt;dateTimeBetween(&apos;-1 year&apos;);
        }
        return $data;
    }
    /**
     * Returns the user with recovery codes.
     *
     * @return static
     */
    public function withRecovery(): static
    {
        [
            &apos;two-factor.recovery.codes&apos; =&gt; $amount,
            &apos;two-factor.recovery.length&apos; =&gt; $length
        ] = config()-&gt;get([&apos;two-factor.recovery.codes&apos;, &apos;two-factor.recovery.length&apos;]);
        return $this-&gt;state([
            &apos;recovery_codes&apos; =&gt; UserTwoFactorAuthentication::generateRecoveryCodes($amount, $length),
            &apos;recovery_codes_generated_at&apos; =&gt; $this-&gt;faker-&gt;dateTimeBetween(&apos;-1 years&apos;),
        ]);
    }
    /**
     * Returns an authentication with a list of safe devices.
     */
    public function withSafeDevices(): static
    {
        $max = config(&apos;two-factor.safe_devices.max_devices&apos;);
        return $this-&gt;state([
            &apos;safe_devices&apos; =&gt; Collection::times($max, function ($step) use ($max) {
                $expiration_days = config(&apos;two-factor.safe_devices.expiration_days&apos;);
                $added_at = $max !== $step
                    ? now()
                    : $this-&gt;faker-&gt;dateTimeBetween(now()-&gt;subDays($expiration_days * 2),
                        now()-&gt;subDays($expiration_days));
                return [
                    &apos;2fa_remember&apos; =&gt; UserTwoFactorAuthentication::generateDefaultTwoFactorRemember(),
                    &apos;ip&apos; =&gt; $this-&gt;faker-&gt;ipv4,
                    &apos;added_at&apos; =&gt; $added_at,
                ];
            }),
        ]);
    }
    /**
     * Returns an enabled authentication.
     */
    public function enabled(): static
    {
        return $this-&gt;state([
            &apos;enabled_at&apos; =&gt; null,
        ]);
    }
}</file><file path="database/migrations/2014_10_12_000000_create_users_table.php">&lt;?php
use Illuminate\Database\Migrations\Migration;
use Tpetry\PostgresqlEnhanced\Schema\Blueprint;
use Tpetry\PostgresqlEnhanced\Support\Facades\Schema;
return new class extends Migration
{
    /**
     * Run the migrations.
     */
    public function up(): void
    {
        Schema::create(&apos;users&apos;, function (Blueprint $table) {
            $table-&gt;id();
            $table-&gt;caseInsensitiveText(&apos;name&apos;);
            $table-&gt;text(&apos;email&apos;)-&gt;unique();
            $table-&gt;timestampTz(&apos;email_verified_at&apos;)-&gt;nullable();
            $table-&gt;text(&apos;password&apos;);
            $table-&gt;text(&apos;remember_token&apos;)-&gt;nullable();
            $table-&gt;timestampsTz();
        });
    }
    /**
     * Reverse the migrations.
     */
    public function down(): void
    {
        Schema::dropIfExists(&apos;users&apos;);
    }
};</file><file path="database/migrations/2019_12_14_000001_create_personal_access_tokens_table.php">&lt;?php
use Illuminate\Database\Migrations\Migration;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\Schema;
return new class extends Migration
{
    /**
     * Run the migrations.
     */
    public function up(): void
    {
        Schema::create(&apos;personal_access_tokens&apos;, function (Blueprint $table) {
            $table-&gt;id();
            $table-&gt;morphs(&apos;tokenable&apos;);
            $table-&gt;text(&apos;name&apos;);
            $table-&gt;text(&apos;token&apos;)-&gt;unique();
            $table-&gt;text(&apos;abilities&apos;)-&gt;nullable();
            $table-&gt;timestampTz(&apos;last_used_at&apos;)-&gt;nullable();
            $table-&gt;timestampTz(&apos;expires_at&apos;)-&gt;nullable();
            $table-&gt;text(&apos;user_agent&apos;)-&gt;nullable();
            $table-&gt;text(&apos;device_operating_system&apos;)-&gt;nullable();
            $table-&gt;text(&apos;device_name&apos;)-&gt;nullable();
            $table-&gt;text(&apos;client_name&apos;)-&gt;nullable();
            $table-&gt;text(&apos;client_version&apos;)-&gt;nullable();
            $table-&gt;text(&apos;client_type&apos;)-&gt;nullable();
            $table-&gt;timestampsTz();
        });
    }
    /**
     * Reverse the migrations.
     */
    public function down(): void
    {
        Schema::dropIfExists(&apos;personal_access_tokens&apos;);
    }
};</file><file path="database/migrations/2024_04_07_120837_create_artists_table.php">&lt;?php
use Illuminate\Database\Migrations\Migration;
use Tpetry\PostgresqlEnhanced\Schema\Blueprint;
use Tpetry\PostgresqlEnhanced\Support\Facades\Schema;
return new class extends Migration
{
    /**
     * Run the migrations.
     */
    public function up(): void
    {
        Schema::create(&apos;artists&apos;, function (Blueprint $table) {
            $table-&gt;id();
            $table-&gt;caseInsensitiveText(&apos;name&apos;);
            $table-&gt;text(&apos;slug&apos;)-&gt;unique();
            $table-&gt;timestampsTz();
            $table-&gt;index(&apos;name&apos;);
        });
    }
    /**
     * Reverse the migrations.
     */
    public function down(): void
    {
        Schema::dropIfExists(&apos;artists&apos;);
    }
};</file><file path="database/migrations/2024_04_07_121120_create_songs_table.php">&lt;?php
use Illuminate\Database\Migrations\Migration;
use Tpetry\PostgresqlEnhanced\Schema\Blueprint;
use Tpetry\PostgresqlEnhanced\Support\Facades\Schema;
return new class extends Migration
{
    /**
     * Run the migrations.
     */
    public function up(): void
    {
        Schema::create(&apos;songs&apos;, function (Blueprint $table) {
            $table-&gt;id();
            $table-&gt;text(&apos;public_id&apos;)-&gt;unique();
            $table-&gt;foreignId(&apos;album_id&apos;)
                -&gt;references(&apos;id&apos;)
                -&gt;on(&apos;albums&apos;)
                -&gt;cascadeOnDelete()
                -&gt;cascadeOnUpdate();
            $table-&gt;index(&apos;album_id&apos;);
            $table-&gt;caseInsensitiveText(&apos;title&apos;);
            $table-&gt;text(&apos;path&apos;);
            $table-&gt;integer(&apos;size&apos;);
            $table-&gt;text(&apos;mime_type&apos;);
            $table-&gt;float(&apos;length&apos;)-&gt;nullable();
            $table-&gt;text(&apos;lyrics&apos;)-&gt;nullable();
            $table-&gt;integer(&apos;track&apos;)-&gt;nullable();
            $table-&gt;integer(&apos;disc&apos;)-&gt;nullable();
            $table-&gt;integer(&apos;modified_time&apos;)-&gt;nullable();
            $table-&gt;integer(&apos;year&apos;)-&gt;nullable();
            $table-&gt;text(&apos;comment&apos;)-&gt;nullable();
            $table-&gt;string(&apos;hash&apos;)-&gt;comment(&apos;sha hash of the file&apos;)-&gt;index()-&gt;nullable();
            $table-&gt;timestampsTz();
        });
    }
    /**
     * Reverse the migrations.
     */
    public function down(): void
    {
        Schema::dropIfExists(&apos;songs&apos;);
    }
};</file><file path="database/migrations/2024_04_07_121647_create_images_table.php">&lt;?php
use Illuminate\Database\Migrations\Migration;
use Tpetry\PostgresqlEnhanced\Schema\Blueprint;
use Tpetry\PostgresqlEnhanced\Support\Facades\Schema;
return new class extends Migration {
    /**
     * Run the migrations.
     */
    public function up(): void
    {
        Schema::create(&apos;images&apos;, function (Blueprint $table) {
            $table-&gt;id();
            $table-&gt;text(&apos;path&apos;);
            $table-&gt;text(&apos;extension&apos;);
            $table-&gt;text(&apos;mime_type&apos;);
            $table-&gt;text(&apos;blurhash&apos;);
            $table-&gt;text(&apos;public_id&apos;)-&gt;index();
            $table-&gt;unsignedInteger(&apos;size&apos;);
            $table-&gt;unsignedInteger(&apos;width&apos;);
            $table-&gt;unsignedInteger(&apos;height&apos;);
            $table-&gt;morphs(&apos;imageable&apos;);
            $table-&gt;timestampsTz();
        });
    }
    /**
     * Reverse the migrations.
     */
    public function down(): void
    {
        Schema::dropIfExists(&apos;images&apos;);
    }
};</file><file path="database/migrations/2024_04_13_001853_create_artist_song_table.php">&lt;?php
use Illuminate\Database\Migrations\Migration;
use Tpetry\PostgresqlEnhanced\Schema\Blueprint;
use Tpetry\PostgresqlEnhanced\Support\Facades\Schema;
return new class extends Migration {
    /**
     * Run the migrations.
     */
    public function up(): void
    {
        Schema::create(&apos;artist_song&apos;, function (Blueprint $table) {
            $table-&gt;id();
            $table-&gt;foreignId(&apos;artist_id&apos;)
                -&gt;references(&apos;id&apos;)
                -&gt;on(&apos;artists&apos;)
                -&gt;cascadeOnDelete()
                -&gt;cascadeOnUpdate();
            $table-&gt;foreignId(&apos;song_id&apos;)
                -&gt;references(&apos;id&apos;)
                -&gt;on(&apos;songs&apos;)
                -&gt;cascadeOnDelete()
                -&gt;cascadeOnUpdate();
            $table-&gt;index(&apos;artist_id&apos;);
            $table-&gt;index(&apos;song_id&apos;);
        });
    }
    /**
     * Reverse the migrations.
     */
    public function down(): void
    {
        Schema::dropIfExists(&apos;artist_album&apos;);
    }
};</file><file path="database/migrations/2024_08_05_135758_create_user_media_activities_table.php">&lt;?php
use Illuminate\Database\Migrations\Migration;
use Tpetry\PostgresqlEnhanced\Schema\Blueprint;
use Tpetry\PostgresqlEnhanced\Support\Facades\Schema;
return new class extends Migration {
    /**
     * Run the migrations.
     */
    public function up(): void
    {
        Schema::create(&apos;user_media_activities&apos;, function (Blueprint $table) {
            $table-&gt;id();
            $table-&gt;text(&apos;public_id&apos;)-&gt;unique();
            $table-&gt;foreignId(&apos;user_id&apos;)
                -&gt;references(&apos;id&apos;)
                -&gt;on(&apos;users&apos;)
                -&gt;cascadeOnDelete()
                -&gt;cascadeOnUpdate();
            $table-&gt;morphs(&apos;user_media_activityable&apos;);
            $table-&gt;unsignedBigInteger(&apos;play_count&apos;)-&gt;nullable();
            $table-&gt;boolean(&apos;love&apos;)-&gt;default(false);
            $table-&gt;timestampTz(&apos;last_played_at&apos;)-&gt;nullable();
            $table-&gt;text(&apos;last_platform&apos;)-&gt;nullable();
            $table-&gt;text(&apos;last_player&apos;)-&gt;nullable();
            $table-&gt;timestampsTz();
        });
    }
    /**
     * Reverse the migrations.
     */
    public function down(): void
    {
        Schema::dropIfExists(&apos;user_media_activities&apos;);
    }
};</file><file path="database/migrations/2024_10_05_192816_create_passkeys_table.php">&lt;?php
use Illuminate\Database\Migrations\Migration;
use Tpetry\PostgresqlEnhanced\Schema\Blueprint;
use Tpetry\PostgresqlEnhanced\Support\Facades\Schema;
return new class extends Migration
{
    /**
     * Run the migrations.
     */
    public function up(): void
    {
        Schema::create(&apos;passkeys&apos;, function (Blueprint $table) {
            $table-&gt;id();
            $table-&gt;foreignId(&apos;user_id&apos;)
                -&gt;references(&apos;id&apos;)
                -&gt;on(&apos;users&apos;)
                -&gt;cascadeOnDelete()
                -&gt;cascadeOnUpdate();
            $table-&gt;text(&apos;name&apos;);
            $table-&gt;text(&apos;credential_id&apos;);
            $table-&gt;jsonb(&apos;data&apos;);
            $table-&gt;unsignedBigInteger(&apos;counter&apos;)-&gt;default(0);
            $table-&gt;timestampTz(&apos;last_used_at&apos;)-&gt;nullable();
            $table-&gt;timestampsTz();
        });
    }
    /**
     * Reverse the migrations.
     */
    public function down(): void
    {
        Schema::dropIfExists(&apos;passkeys&apos;);
    }
};</file><file path="database/seeders/DatabaseSeeder.php">&lt;?php
namespace Database\Seeders;
// use Illuminate\Database\Console\Seeds\WithoutModelEvents;
use Illuminate\Database\Seeder;
class DatabaseSeeder extends Seeder
{
    /**
     * Seed the application&apos;s database.
     */
    public function run(): void
    {
        $this-&gt;call(AclSeed::class);
    }
}</file><file path="database/seeders/UsersSeed.php">&lt;?php
namespace Database\Seeders;
use App\Auth\Role;
use App\Models\User;
use Illuminate\Database\Console\Seeds\WithoutModelEvents;
use Illuminate\Database\Seeder;
use Illuminate\Support\Facades\Hash;
class UsersSeed extends Seeder
{
    /**
     * Run the database seeds.
     */
    public function run(): void
    {
        $adminUser = User::factory()-&gt;create([
            &apos;name&apos;              =&gt; &apos;Test admin&apos;,
            &apos;email&apos;             =&gt; &apos;admin@baander.test&apos;,
            &apos;password&apos;          =&gt; Hash::make(&apos;password&apos;),
            &apos;email_verified_at&apos; =&gt; now(),
        ]);
        $adminUser-&gt;assignRole(Role::Admin-&gt;value);
        $normalUser = User::factory()-&gt;create([
            &apos;name&apos;              =&gt; &apos;Test user&apos;,
            &apos;email&apos;             =&gt; &apos;user@baander.test&apos;,
            &apos;password&apos;          =&gt; Hash::make(&apos;password&apos;),
            &apos;email_verified_at&apos; =&gt; now(),
        ]);
        $normalUser-&gt;assignRole(Role::User-&gt;value);
    }
}</file><file path="docker/dev/nginx.conf">map $http_upgrade $connection_upgrade {
    default upgrade;
    &apos;&apos;      close;
}

upstream upstream_backend_php {
  server app:8000;
}

upstream reverb {
  server app:8080;
}

server {
    listen 80;
    server_name baander.test;

    # Redirect HTTP to HTTPS
    location / {
        return 307 https://$host$request_uri;
    }
}

server {
    listen 443 ssl;
    ssl_certificate     /etc/nginx/certificates/cert.pem;
    ssl_certificate_key /etc/nginx/certificates/key.pem;
    server_name baander.test;

    index index.php index.html index.htm;

    charset utf-8;
    server_tokens off;

    access_log /var/log/nginx/access.log;
    error_log /var/log/nginx/error.log;

    ############################
    # Reference: https://gist.github.com/Ellrion/4eb5df00173f0fb13a76
    ############################

    location ~* \.(jpg|jpeg|png|gif|svg|webp|html|txt|json|ico|css|js)$ {
        expires 1d;
        add_header Cache-Control public;
        access_log off;

        try_files $uri $uri/ @octane;
    }

    location ~ /\.(?!well-known).* {
        deny all;
    }

    location = /favicon.ico {
        log_not_found off;
        access_log off;
        try_files $uri $uri/ @octane;
    }

    # Don&apos;t log missing robots or show them in the nginx logs
    location = /robots.txt {
        allow all;
        log_not_found off;
        access_log off;
        try_files $uri $uri/ @octane;
    }

    # Deny all attempts to access hidden files such as .htaccess, .htpasswd, .DS_Store (Mac).
    # Keep logging the requests to parse later (or to pass to firewall utilities such as fail2ban)
    location ~ /\. {
        deny all;
    }

    # Deny access to any files with a .php extension in the uploads directory
    # Works in sub-directory installs and also in multisite network
    # Keep logging the requests to parse later (or to pass to firewall utilities such as fail2ban)
    location ~* /(?:uploads|files)/.*\.php$ {
        deny all;
    }

    location /index.php {
        try_files /not_exists @octane;
    }

    location / {
        if ($request_method !~ ^(GET|POST|HEAD|OPTIONS|PUT|DELETE)$) {
            return 405;
        }

        try_files $uri $uri/ @octane;
    }

    location @octane {
        set $suffix &quot;&quot;;

        if ($uri = /index.php) {
            set $suffix ?$query_string;
        }

        proxy_http_version 1.1;
        proxy_set_header Http_Host $http_host;
        proxy_set_header Host $host;
        proxy_set_header Scheme $scheme;
        proxy_set_header SERVER_PORT $server_port;
        proxy_set_header REMOTE_ADDR $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection $connection_upgrade;

        proxy_set_header X-Real-IP $remote_addr;
        proxy_pass http://upstream_backend_php$suffix;
    }

    # Laravel Reverb
    # The Websocket Client/Laravel Echo would connect and listen to this
    location ~ /app/(?&lt;reverbkey&gt;.*) { # variable reverbkey
      proxy_pass http://reverb/app/$reverbkey;
      proxy_http_version 1.1;
      proxy_set_header Host $http_host;
      proxy_set_header Scheme $scheme;
      proxy_set_header SERVER_PORT $server_port;
      proxy_set_header REMOTE_ADDR $remote_addr;
      proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
      proxy_set_header Upgrade $http_upgrade;
      proxy_set_header Connection &quot;Upgrade&quot;;
    }
    # The Laravel Backend would broadcast to this
    location ~ ^/apps/(?&lt;reverbid&gt;[^/]+)/events$ { # variable reverbid
      proxy_pass http://reverb/apps/$reverbid/events;
      proxy_set_header Host $host;
      proxy_set_header X-Real-IP $remote_addr;
      proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
      proxy_set_header X-Forwarded-Proto $scheme;
    }
}</file><file path="docker/general/cron"># Cron use www-data with sudo, because we need to redirect logs into /dev/stdout /dev/stderr for container
* * * * * cd /var/www/html &amp;&amp; sudo -u www-data /usr/local/bin/php artisan schedule:run &gt; /proc/1/fd/1 2&gt;/proc/1/fd/2</file><file path="docs/dev_workflow.md"># Dev workflow

First of all you must ensure the docker services have been built. On windows you need to be in a WSL prompt that&apos;s docker enabled,
You must also ensure this instance of WSL is connected to Docker Desktop on Windows, otherwise routing will not work properly.

Come back to this document once you&apos;ve properly setup your environment.

## Glossary

- Application container
  - Container named baander-app in [docker-compose](/docker-compose.yml)
- Scheduler container
  - Container named baander-scheduler in [docker-compose](/docker-compose.yml)
- Frontend
  - React application in [resources/app](/resources/app)

## Starting the environment

First run `make build` this will build the application container defined in [Dockerfile](/Dockerfile). Then you&apos;ll
want to run `make start` this will start all docker services.

Once you&apos;ve seen all services start up without error, you can ssh into the application container to install the composer dependencies:

`make ssh`

`composer install`

To ease the setup of the application in development mode, you can run the artisan script from within the app container:

`php artisan setup:dev`

### Start frontend

While the backend services are running, run `vite` or `yarn dev` then visit `https://baander.test`

### Start websocket

To broadcast events via the websocket, you must open a new terminal, ssh into the application container and then type

`php artisan reverb:start`

This will start the [Laravel Reverb](https://reverb.laravel.com/) websocket server.</file><file path="lang/en/auth.php">&lt;?php
return [
    /*
    |--------------------------------------------------------------------------
    | Authentication Language Lines
    |--------------------------------------------------------------------------
    |
    | The following language lines are used during authentication for various
    | messages that we need to display to the user. You are free to modify
    | these language lines according to your application&apos;s requirements.
    |
    */
    &apos;login&apos;  =&gt; &apos;Login&apos;,
    &apos;logout&apos; =&gt; &apos;Logout&apos;,
    &apos;failed&apos;   =&gt; &apos;These credentials do not match our records.&apos;,
    &apos;password&apos; =&gt; &apos;The provided password is incorrect.&apos;,
    &apos;throttle&apos; =&gt; &apos;Too many login attempts. Please try again in :seconds seconds.&apos;,
];</file><file path="phpstan.neon">includes:
  - vendor/larastan/larastan/extension.neon

parameters:
  checkOctaneCompatibility: true
  paths:
    - app/

  # Level 9 is the highest level
  level: 5



#    ignoreErrors:
#        - &apos;#PHPDoc tag @var#&apos;
#
#    excludePaths:
#        - ./*/*/FileToBeExcluded.php
#
#    checkMissingIterableValueType: false</file><file path="phpunit.xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;phpunit xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
         xsi:noNamespaceSchemaLocation=&quot;vendor/phpunit/phpunit/phpunit.xsd&quot;
         bootstrap=&quot;vendor/autoload.php&quot;
         colors=&quot;true&quot;
&gt;
    &lt;testsuites&gt;
        &lt;testsuite name=&quot;Unit&quot;&gt;
            &lt;directory&gt;tests/Unit&lt;/directory&gt;
        &lt;/testsuite&gt;
        &lt;testsuite name=&quot;Feature&quot;&gt;
            &lt;directory&gt;tests/Feature&lt;/directory&gt;
        &lt;/testsuite&gt;
    &lt;/testsuites&gt;
    &lt;source&gt;
        &lt;include&gt;
            &lt;directory&gt;app&lt;/directory&gt;
        &lt;/include&gt;
    &lt;/source&gt;
    &lt;php&gt;
        &lt;env name=&quot;APP_ENV&quot; value=&quot;testing&quot;/&gt;
        &lt;env name=&quot;BCRYPT_ROUNDS&quot; value=&quot;4&quot;/&gt;
        &lt;env name=&quot;CACHE_DRIVER&quot; value=&quot;array&quot;/&gt;
        &lt;!-- &lt;env name=&quot;DB_CONNECTION&quot; value=&quot;sqlite&quot;/&gt; --&gt;
        &lt;!-- &lt;env name=&quot;DB_DATABASE&quot; value=&quot;:memory:&quot;/&gt; --&gt;
        &lt;env name=&quot;MAIL_MAILER&quot; value=&quot;array&quot;/&gt;
        &lt;env name=&quot;QUEUE_CONNECTION&quot; value=&quot;sync&quot;/&gt;
        &lt;env name=&quot;SESSION_DRIVER&quot; value=&quot;array&quot;/&gt;
        &lt;env name=&quot;TELESCOPE_ENABLED&quot; value=&quot;false&quot;/&gt;
    &lt;/php&gt;
&lt;/phpunit&gt;</file><file path="resources/app/api-client/requests/core/ApiRequestOptions.ts">export type ApiRequestOptions&lt;T = unknown&gt; = {
	readonly body?: any;
	readonly cookies?: Record&lt;string, unknown&gt;;
	readonly errors?: Record&lt;number | string, string&gt;;
	readonly formData?: Record&lt;string, unknown&gt; | any[] | Blob | File;
	readonly headers?: Record&lt;string, unknown&gt;;
	readonly mediaType?: string;
	readonly method:
		| &apos;DELETE&apos;
		| &apos;GET&apos;
		| &apos;HEAD&apos;
		| &apos;OPTIONS&apos;
		| &apos;PATCH&apos;
		| &apos;POST&apos;
		| &apos;PUT&apos;;
	readonly path?: Record&lt;string, unknown&gt;;
	readonly query?: Record&lt;string, unknown&gt;;
	readonly responseHeader?: string;
	readonly responseTransformer?: (data: unknown) =&gt; Promise&lt;T&gt;;
	readonly url: string;
};</file><file path="resources/app/api-client/requests/core/request.ts">import axios from &apos;axios&apos;;
import type { AxiosError, AxiosRequestConfig, AxiosResponse, AxiosInstance } from &apos;axios&apos;;
import { ApiError } from &apos;./ApiError&apos;;
import type { ApiRequestOptions } from &apos;./ApiRequestOptions&apos;;
import type { ApiResult } from &apos;./ApiResult&apos;;
import { CancelablePromise } from &apos;./CancelablePromise&apos;;
import type { OnCancel } from &apos;./CancelablePromise&apos;;
import type { OpenAPIConfig } from &apos;./OpenAPI&apos;;
export const isString = (value: unknown): value is string =&gt; {
	return typeof value === &apos;string&apos;;
};
export const isStringWithValue = (value: unknown): value is string =&gt; {
	return isString(value) &amp;&amp; value !== &apos;&apos;;
};
export const isBlob = (value: any): value is Blob =&gt; {
	return value instanceof Blob;
};
export const isFormData = (value: unknown): value is FormData =&gt; {
	return value instanceof FormData;
};
export const isSuccess = (status: number): boolean =&gt; {
	return status &gt;= 200 &amp;&amp; status &lt; 300;
};
export const base64 = (str: string): string =&gt; {
	try {
		return btoa(str);
	} catch (err) {
		// @ts-ignore
		return Buffer.from(str).toString(&apos;base64&apos;);
	}
};
export const getQueryString = (params: Record&lt;string, unknown&gt;): string =&gt; {
	const qs: string[] = [];
	const append = (key: string, value: unknown) =&gt; {
		qs.push(`${encodeURIComponent(key)}=${encodeURIComponent(String(value))}`);
	};
	const encodePair = (key: string, value: unknown) =&gt; {
		if (value === undefined || value === null) {
			return;
		}
		if (value instanceof Date) {
			append(key, value.toISOString());
		} else if (Array.isArray(value)) {
			value.forEach(v =&gt; encodePair(key, v));
		} else if (typeof value === &apos;object&apos;) {
			Object.entries(value).forEach(([k, v]) =&gt; encodePair(`${key}[${k}]`, v));
		} else {
			append(key, value);
		}
	};
	Object.entries(params).forEach(([key, value]) =&gt; encodePair(key, value));
	return qs.length ? `?${qs.join(&apos;&amp;&apos;)}` : &apos;&apos;;
};
const getUrl = (config: OpenAPIConfig, options: ApiRequestOptions): string =&gt; {
	const encoder = config.ENCODE_PATH || encodeURI;
	const path = options.url
		.replace(&apos;{api-version}&apos;, config.VERSION)
		.replace(/{(.*?)}/g, (substring: string, group: string) =&gt; {
			if (options.path?.hasOwnProperty(group)) {
				return encoder(String(options.path[group]));
			}
			return substring;
		});
	const url = config.BASE + path;
	return options.query ? url + getQueryString(options.query) : url;
};
export const getFormData = (options: ApiRequestOptions): FormData | undefined =&gt; {
	if (options.formData) {
		const formData = new FormData();
		const process = (key: string, value: unknown) =&gt; {
			if (isString(value) || isBlob(value)) {
				formData.append(key, value);
			} else {
				formData.append(key, JSON.stringify(value));
			}
		};
		Object.entries(options.formData)
			.filter(([, value]) =&gt; value !== undefined &amp;&amp; value !== null)
			.forEach(([key, value]) =&gt; {
				if (Array.isArray(value)) {
					value.forEach(v =&gt; process(key, v));
				} else {
					process(key, value);
				}
			});
		return formData;
	}
	return undefined;
};
type Resolver&lt;T&gt; = (options: ApiRequestOptions&lt;T&gt;) =&gt; Promise&lt;T&gt;;
export const resolve = async &lt;T&gt;(options: ApiRequestOptions&lt;T&gt;, resolver?: T | Resolver&lt;T&gt;): Promise&lt;T | undefined&gt; =&gt; {
	if (typeof resolver === &apos;function&apos;) {
		return (resolver as Resolver&lt;T&gt;)(options);
	}
	return resolver;
};
export const getHeaders = async &lt;T&gt;(config: OpenAPIConfig, options: ApiRequestOptions&lt;T&gt;): Promise&lt;Record&lt;string, string&gt;&gt; =&gt; {
	const [token, username, password, additionalHeaders] = await Promise.all([
		// @ts-ignore
		resolve(options, config.TOKEN),
		// @ts-ignore
		resolve(options, config.USERNAME),
		// @ts-ignore
		resolve(options, config.PASSWORD),
		// @ts-ignore
		resolve(options, config.HEADERS),
	]);
	const headers = Object.entries({
		Accept: &apos;application/json&apos;,
		...additionalHeaders,
		...options.headers,
	})
	.filter(([, value]) =&gt; value !== undefined &amp;&amp; value !== null)
	.reduce((headers, [key, value]) =&gt; ({
		...headers,
		[key]: String(value),
	}), {} as Record&lt;string, string&gt;);
	if (isStringWithValue(token)) {
		headers[&apos;Authorization&apos;] = `Bearer ${token}`;
	}
	if (isStringWithValue(username) &amp;&amp; isStringWithValue(password)) {
		const credentials = base64(`${username}:${password}`);
		headers[&apos;Authorization&apos;] = `Basic ${credentials}`;
	}
	if (options.body !== undefined) {
		if (options.mediaType) {
			headers[&apos;Content-Type&apos;] = options.mediaType;
		} else if (isBlob(options.body)) {
			headers[&apos;Content-Type&apos;] = options.body.type || &apos;application/octet-stream&apos;;
		} else if (isString(options.body)) {
			headers[&apos;Content-Type&apos;] = &apos;text/plain&apos;;
		} else if (!isFormData(options.body)) {
			headers[&apos;Content-Type&apos;] = &apos;application/json&apos;;
		}
	} else if (options.formData !== undefined) {
		if (options.mediaType) {
			headers[&apos;Content-Type&apos;] = options.mediaType;
		}
	}
	return headers;
};
export const getRequestBody = (options: ApiRequestOptions): unknown =&gt; {
	if (options.body) {
		return options.body;
	}
	return undefined;
};
export const sendRequest = async &lt;T&gt;(
	config: OpenAPIConfig,
	options: ApiRequestOptions&lt;T&gt;,
	url: string,
	body: unknown,
	formData: FormData | undefined,
	headers: Record&lt;string, string&gt;,
	onCancel: OnCancel,
	axiosClient: AxiosInstance
): Promise&lt;AxiosResponse&lt;T&gt;&gt; =&gt; {
	const controller = new AbortController();
	let requestConfig: AxiosRequestConfig = {
		data: body ?? formData,
		headers,
		method: options.method,
		signal: controller.signal,
		url,
		withCredentials: config.WITH_CREDENTIALS,
	};
	onCancel(() =&gt; controller.abort());
	for (const fn of config.interceptors.request._fns) {
		requestConfig = await fn(requestConfig);
	}
	try {
		return await axiosClient.request(requestConfig);
	} catch (error) {
		const axiosError = error as AxiosError&lt;T&gt;;
		if (axiosError.response) {
			return axiosError.response;
		}
		throw error;
	}
};
export const getResponseHeader = (response: AxiosResponse&lt;unknown&gt;, responseHeader?: string): string | undefined =&gt; {
	if (responseHeader) {
		const content = response.headers[responseHeader];
		if (isString(content)) {
			return content;
		}
	}
	return undefined;
};
export const getResponseBody = (response: AxiosResponse&lt;unknown&gt;): unknown =&gt; {
	if (response.status !== 204) {
		return response.data;
	}
	return undefined;
};
export const catchErrorCodes = (options: ApiRequestOptions, result: ApiResult): void =&gt; {
	const errors: Record&lt;number, string&gt; = {
		400: &apos;Bad Request&apos;,
		401: &apos;Unauthorized&apos;,
		402: &apos;Payment Required&apos;,
		403: &apos;Forbidden&apos;,
		404: &apos;Not Found&apos;,
		405: &apos;Method Not Allowed&apos;,
		406: &apos;Not Acceptable&apos;,
		407: &apos;Proxy Authentication Required&apos;,
		408: &apos;Request Timeout&apos;,
		409: &apos;Conflict&apos;,
		410: &apos;Gone&apos;,
		411: &apos;Length Required&apos;,
		412: &apos;Precondition Failed&apos;,
		413: &apos;Payload Too Large&apos;,
		414: &apos;URI Too Long&apos;,
		415: &apos;Unsupported Media Type&apos;,
		416: &apos;Range Not Satisfiable&apos;,
		417: &apos;Expectation Failed&apos;,
		418: &apos;Im a teapot&apos;,
		421: &apos;Misdirected Request&apos;,
		422: &apos;Unprocessable Content&apos;,
		423: &apos;Locked&apos;,
		424: &apos;Failed Dependency&apos;,
		425: &apos;Too Early&apos;,
		426: &apos;Upgrade Required&apos;,
		428: &apos;Precondition Required&apos;,
		429: &apos;Too Many Requests&apos;,
		431: &apos;Request Header Fields Too Large&apos;,
		451: &apos;Unavailable For Legal Reasons&apos;,
		500: &apos;Internal Server Error&apos;,
		501: &apos;Not Implemented&apos;,
		502: &apos;Bad Gateway&apos;,
		503: &apos;Service Unavailable&apos;,
		504: &apos;Gateway Timeout&apos;,
		505: &apos;HTTP Version Not Supported&apos;,
		506: &apos;Variant Also Negotiates&apos;,
		507: &apos;Insufficient Storage&apos;,
		508: &apos;Loop Detected&apos;,
		510: &apos;Not Extended&apos;,
		511: &apos;Network Authentication Required&apos;,
		...options.errors,
	}
	const error = errors[result.status];
	if (error) {
		throw new ApiError(options, result, error);
	}
	if (!result.ok) {
		const errorStatus = result.status ?? &apos;unknown&apos;;
		const errorStatusText = result.statusText ?? &apos;unknown&apos;;
		const errorBody = (() =&gt; {
			try {
				return JSON.stringify(result.body, null, 2);
			} catch (e) {
				return undefined;
			}
		})();
		throw new ApiError(options, result,
			`Generic Error: status: ${errorStatus}; status text: ${errorStatusText}; body: ${errorBody}`
		);
	}
};
/**
 * Request method
 * @param config The OpenAPI configuration object
 * @param options The request options from the service
 * @param axiosClient The axios client instance to use
 * @returns CancelablePromise&lt;T&gt;
 * @throws ApiError
 */
export const request = &lt;T&gt;(config: OpenAPIConfig, options: ApiRequestOptions&lt;T&gt;, axiosClient: AxiosInstance = axios): CancelablePromise&lt;T&gt; =&gt; {
	return new CancelablePromise(async (resolve, reject, onCancel) =&gt; {
		try {
			const url = getUrl(config, options);
			const formData = getFormData(options);
			const body = getRequestBody(options);
			const headers = await getHeaders(config, options);
			if (!onCancel.isCancelled) {
				let response = await sendRequest&lt;T&gt;(config, options, url, body, formData, headers, onCancel, axiosClient);
				for (const fn of config.interceptors.response._fns) {
					response = await fn(response);
				}
				const responseBody = getResponseBody(response);
				const responseHeader = getResponseHeader(response, options.responseHeader);
				let transformedBody = responseBody;
				if (options.responseTransformer &amp;&amp; isSuccess(response.status)) {
					transformedBody = await options.responseTransformer(responseBody)
				}
				const result: ApiResult = {
					url,
					ok: isSuccess(response.status),
					status: response.status,
					statusText: response.statusText,
					body: responseHeader ?? transformedBody,
				};
				catchErrorCodes(options, result);
				resolve(result.body);
			}
		} catch (error) {
			reject(error);
		}
	});
};</file><file path="resources/app/common/env.ts">const fallback = &apos;UNKNOWN&apos;;
export class Env {
  static appName() {
    return window.BaanderAppInfo?.name ?? import.meta.env.VITE_APP_NAME;
  }
  static env() {
    return window.BaanderAppInfo?.environment ?? import.meta.env.VITE_APP_ENV ?? fallback;
  }
  static url() {
    return window.BaanderAppInfo?.url ?? import.meta.env.VITE_APP_URL ?? fallback;
  }
  static version() {
    return window.BaanderAppInfo?.version ?? fallback;
  }
  static isProduction() {
    return Env.env() == &apos;production&apos;;
  }
}</file><file path="resources/app/common/react-query.ts">import { DefaultError, DefaultOptions, Query, QueryCache, QueryClient } from &apos;@tanstack/react-query&apos;;
import { get, set, del } from &apos;idb-keyval&apos;;
import {
  PersistedClient,
  Persister,
} from &apos;@tanstack/react-query-persist-client&apos;;
import { Env } from &apos;@/common/env.ts&apos;;
const queryCache = new QueryCache({
  onError: (error: DefaultError, query: Query&lt;unknown, unknown, unknown&gt;) =&gt; {
    if (query.state.data !== undefined) {
      console.error(error);
    }
  },
});
const defaultOptions: DefaultOptions = {
  mutations: {
    retry: Env.isProduction(),
  },
  queries: {
    refetchOnWindowFocus: true,
    retry: Env.isProduction(),
    staleTime: 1000 * 5,
  },
};
export const queryClient = new QueryClient({
  defaultOptions,
  queryCache,
});
export function createIDBPersister(idbValidKey: IDBValidKey = &apos;reactQuery&apos;) {
  return {
    persistClient: async (client: PersistedClient) =&gt; {
      await set(idbValidKey, client);
    },
    restoreClient: async () =&gt; {
      return await get&lt;PersistedClient&gt;(idbValidKey);
    },
    removeClient: async () =&gt; {
      await del(idbValidKey);
    },
  } as Persister;
}</file><file path="resources/app/components/song-table/song-table.tsx">import React, { useCallback, useMemo, useRef, useState } from &apos;react&apos;;
import { SongResource } from &apos;@/api-client/requests&apos;;
import { Iconify } from &apos;@/ui/icons/iconify&apos;;
import { useAppDispatch, useAppSelector } from &apos;@/store/hooks&apos;;
import { setQueueAndSong } from &apos;@/store/music/music-player-slice&apos;;
import {
  ColumnDef,
  flexRender,
  getCoreRowModel,
  getSortedRowModel,
  SortingState,
  useReactTable,
} from &apos;@tanstack/react-table&apos;;
import { useVirtualizer } from &apos;@tanstack/react-virtual&apos;;
import { SpeakerLoudIcon } from &apos;@radix-ui/react-icons&apos;;
import styles from &apos;./song-table.module.scss&apos;;
export interface SongTableProps {
  songs: SongResource[];
  title?: string | null;
  description?: string | null;
  onFetchNextPage?: () =&gt; void;
  hasNextPage?: boolean;
  isFetchingNextPage?: boolean;
  className?: string;
}
export function SongTable({
  songs,
  title,
  description,
  onFetchNextPage,
  hasNextPage,
  isFetchingNextPage,
  className,
}: SongTableProps) {
  const dispatch = useAppDispatch();
  const [sorting, setSorting] = useState&lt;SortingState&gt;([]);
  const onSongClick = useCallback((publicId: string) =&gt; {
    if (songs) {
      const newQueue = [...songs];
      const index = newQueue.findIndex(x =&gt; x.public_id === publicId);
      newQueue.splice(0, 0, newQueue.splice(index, 1)[0]);
      dispatch(setQueueAndSong({
        queue: newQueue,
        playPublicId: newQueue[0].public_id,
      }));
    }
  }, [dispatch, songs]);
  const columns = useMemo&lt;Array&lt;ColumnDef&lt;SongResource&gt;&gt;&gt;(
    () =&gt; [
      {
        &apos;header&apos;: &apos;Title&apos;,
        cell: (info) =&gt; &lt;SongTitleCell song={info.row.original}/&gt;,
      },
      {
        &apos;header&apos;: &apos;Lyrics&apos;,
        &apos;accessorKey&apos;: &apos;lyricsExist&apos;,
        cell: (info) =&gt; info.getValue() ? &lt;Iconify icon=&quot;arcticons:quicklyric&quot;/&gt; : null,
        size: 10,
      },
      {
        &apos;header&apos;: &apos;Artist&apos;,
        accessorFn: (row) =&gt; row.artists?.map(x =&gt; x.name).join(&apos;, &apos;),
      },
      {
        &apos;header&apos;: &apos;Album&apos;,
        accessorFn: (row) =&gt; row.album?.title,
      },
      {
        &apos;header&apos;: &apos;Duration&apos;,
        &apos;accessorKey&apos;: &apos;durationHuman&apos;,
        size: 10,
      },
      {
        &apos;header&apos;: &apos;Track&apos;,
        &apos;accessorKey&apos;: &apos;track&apos;,
        size: 10,
      },
    ],
    [],
  );
  const parentRef = useRef&lt;HTMLDivElement&gt;(null);
  const table = useReactTable({
    data: songs,
    columns,
    state: {
      sorting,
    },
    onSortingChange: setSorting,
    getCoreRowModel: getCoreRowModel(),
    getSortedRowModel: getSortedRowModel(),
    debugAll: false,
    debugColumns: false,
  });
  const { rows } = table.getRowModel();
  const virtualizer = useVirtualizer({
    count: rows.length,
    getScrollElement: () =&gt; parentRef.current,
    estimateSize: () =&gt; 24,
  });
  // Handle infinite scrolling if needed
  React.useEffect(() =&gt; {
    if (!onFetchNextPage) return;
    const [lastItem] = [...virtualizer.getVirtualItems()].reverse();
    if (!lastItem) {
      return;
    }
    if (
      lastItem.index &gt;= songs.length - 1 &amp;&amp;
      hasNextPage &amp;&amp;
      !isFetchingNextPage
    ) {
      onFetchNextPage();
    }
  }, [
    hasNextPage,
    onFetchNextPage,
    songs.length,
    isFetchingNextPage,
    virtualizer.getVirtualItems(),
  ]);
  return (
    &lt;&gt;
      {(title || description) &amp;&amp; (
        &lt;div className={styles.header}&gt;
          {title &amp;&amp; &lt;h2 className={styles.title}&gt;{title}&lt;/h2&gt;}
          {description &amp;&amp; &lt;p className={styles.description}&gt;{description}&lt;/p&gt;}
        &lt;/div&gt;
      )}
      &lt;div ref={parentRef} className={`${styles.scrollList} ${className || &apos;&apos;}`}&gt;
        &lt;div style={{ height: `${virtualizer.getTotalSize()}px` }}&gt;
          &lt;table&gt;
            &lt;thead&gt;
            {table.getHeaderGroups().map((headerGroup) =&gt; (
              &lt;tr key={headerGroup.id}&gt;
                {headerGroup.headers.map((header) =&gt; {
                  return (
                    &lt;th
                      key={header.id}
                      colSpan={header.colSpan}
                      style={{
                        width: header.getSize(),
                        position: &apos;sticky&apos;,
                        top: 0,
                        cursor: &apos;pointer&apos;
                      }}
                    &gt;
                      {header.isPlaceholder ? null : (
                        &lt;div
                          {...{
                            className: header.column.getCanSort()
                                       ? &apos;cursor-pointer select-none&apos;
                                       : &apos;&apos;,
                            onClick: header.column.getToggleSortingHandler(),
                          }}
                        &gt;
                          {flexRender(
                            header.column.columnDef.header,
                            header.getContext(),
                          )}
                          {{
                            asc: &apos; 🔼&apos;,
                            desc: &apos; 🔽&apos;,
                          }[header.column.getIsSorted() as string] ?? null}
                        &lt;/div&gt;
                      )}
                    &lt;/th&gt;
                  );
                })}
              &lt;/tr&gt;
            ))}
            &lt;/thead&gt;
            &lt;tbody&gt;
            {virtualizer.getVirtualItems().map((virtualRow, index) =&gt; {
              const row = rows[virtualRow.index];
              return (
                &lt;tr
                  key={row.id}
                  onClick={() =&gt; onSongClick(row.original.public_id)}
                  className={styles.listItem}
                  style={{
                    height: `${virtualRow.size}px`,
                    transform: `translateY(${
                      virtualRow.start - index * virtualRow.size
                    }px)`,
                  }}
                &gt;
                  {row.getVisibleCells().map((cell) =&gt; {
                    return (
                      &lt;td key={cell.id}&gt;
                        {flexRender(
                          cell.column.columnDef.cell,
                          cell.getContext(),
                        )}
                      &lt;/td&gt;
                    );
                  })}
                &lt;/tr&gt;
              );
            })}
            &lt;/tbody&gt;
          &lt;/table&gt;
        &lt;/div&gt;
      &lt;/div&gt;
    &lt;/&gt;
  );
}
interface SongTitleCellProps {
  song: SongResource;
}
function SongTitleCell({ song }: SongTitleCellProps) {
  const { currentSongPublicId } = useAppSelector(state =&gt; state.musicPlayer);
  return (
    &lt;div className={styles.titleCell}&gt;
      {currentSongPublicId === song.public_id &amp;&amp; &lt;SpeakerLoudIcon className={styles.titleCellNowPlayingIcon}/&gt;}
      &lt;div className={styles.titleCellTitle}&gt;{song.title}&lt;/div&gt;
    &lt;/div&gt;
  );
}</file><file path="resources/app/layouts/bare-layout/bare-layout.module.scss">.bare-layout {
  align-items: center;
  flex-direction: column;
  height: 1042px;
  overflow: hidden;
  row-gap: 0;
  width: 1440px;
  display: flex;
  text-align: center;
  letter-spacing: -0.32px;
}
.main {
  align-items: center;
  display: flex;
  flex-basis: 0;
  flex-direction: column;
  flex-grow: 1;
  justify-content: center;
  padding: 10px;
  row-gap: 10px;
  align-self: stretch;
  .login {
    align-items: center;
    border-radius: 8px;
    box-shadow: 0px 4px 14px 0px #0000001a, 0px 0px 1px 0px #0000004d;
    display: flex;
    flex-direction: column;
    height: 450px;
    padding: 48px 56px;
    row-gap: 30px;
    width: 440px;
    flex-shrink: 0;
    .component66 {
      align-items: center;
      border-radius: 8px;
      display: inline-flex;
      flex-direction: column;
      row-gap: 24px;
      flex-shrink: 0;
      .logo {
        height: 72px;
        width: 72px;
        flex-shrink: 0;
      }
      .header {
        align-items: center;
        display: inline-flex;
        flex-direction: column;
        justify-content: center;
        row-gap: 6px;
        flex-shrink: 0;
        .title {
          font-size: 32px;
          font-weight: 600;
          line-height: 44px;
          min-width: 128px;
          vertical-align: middle;
          flex-shrink: 0;
        }
        &amp; &gt; .text {
          font-size: 16px;
          font-weight: 400;
          line-height: 22px;
          min-width: 163px;
          vertical-align: middle;
          flex-shrink: 0;
        }
      }
    }
    .form {
      align-items: flex-start;
      display: flex;
      flex-direction: column;
      flex-shrink: 0;
      row-gap: 28px;
      align-self: stretch;
      .inputs {
        align-items: flex-start;
        display: flex;
        flex-direction: column;
        flex-shrink: 0;
        row-gap: 24px;
        align-self: stretch;
      }
      .button {
        height: 40px;
        width: 440px;
      }
    }
  }
}</file><file path="resources/app/layouts/dashboard-layout/components/dashboard-menu.module.scss">.sidebar {
  width: 250px;
  height: 100%;
  background-color: var(--color-panel);
  border-right: 1px solid var(--gray-5);
  overflow: hidden;
  display: flex;
  flex-direction: column;
}
.menuContainer {
  padding: 1rem;
}
.homeLink {
  display: block;
  padding: 0.75rem 1rem;
  margin-bottom: 1rem;
  border-radius: 4px;
  color: var(--gray-12);
  text-decoration: none;
  transition: background-color 0.2s;
  &amp;:hover {
    background-color: var(--gray-4);
  }
}
.menuSection {
  margin-bottom: 1.5rem;
}
.sectionTitle {
  font-size: 0.875rem;
  font-weight: 600;
  color: var(--gray-11);
  margin-bottom: 0.5rem;
  padding: 0.5rem 0;
}
.linksList {
  display: flex;
  flex-direction: column;
  gap: 0.25rem;
}
.menuLink {
  display: block;
  padding: 0.5rem 1rem;
  margin-left: 0.5rem;
  border-radius: 4px;
  color: var(--gray-11);
  text-decoration: none;
  font-size: 0.875rem;
  transition: background-color 0.2s, color 0.2s;
  &amp;:hover {
    background-color: var(--gray-4);
    color: var(--gray-12);
  }
}
.activeLink {
  background-color: var(--accent-3);
  color: var(--accent-11);
  font-weight: 500;
  &amp;:hover {
    background-color: var(--accent-4);
    color: var(--accent-11);
  }
}</file><file path="resources/app/layouts/dashboard-layout/dashboard-layout.tsx">import { ReactNode } from &apos;react&apos;;
import styles from &apos;../root-layout/root-layout.module.scss&apos;;
import { lazyImport } from &apos;@/utils/lazy-import&apos;;
const { DashboardMenu } = lazyImport(() =&gt; import(&apos;@/layouts/dashboard-layout/components/dashboard-menu.tsx&apos;), &apos;DashboardMenu&apos;);
export interface DashboardLayoutProps {
  children?: ReactNode;
}
export function DashboardLayout({ children }: DashboardLayoutProps) {
  return (
    &lt;div className={styles.shell}&gt;
      &lt;aside className={styles.sidebar}&gt;
        &lt;DashboardMenu /&gt;
      &lt;/aside&gt;
      &lt;main className={styles.main}&gt;
        &lt;div className={styles.content}&gt;
          &lt;div className={styles.page}&gt;
            {children}
          &lt;/div&gt;
        &lt;/div&gt;
      &lt;/main&gt;
    &lt;/div&gt;
  );
}</file><file path="resources/app/libs/lyrics/audio-lyric-synchronizer.ts">import { Lrc } from &apos;./lrc&apos;;
export class AudioLyricSynchronizer {
  useOffset: boolean;
  defaultOffset: number;
  private _currentIndex: number;
  lrc!: Lrc;
  constructor(lrc: Lrc = new Lrc(), useOffset: boolean = true, defaultOffset: number = -150) {
    this.useOffset = useOffset;
    this.defaultOffset = defaultOffset; // Default offset in milliseconds
    this._currentIndex = -1;
    this.setLrc(lrc);
  }
  /**
   * Sets the LRC and updates the lyrics and offset.
   * @param lrc - The LRC object to set.
   */
  setLrc(lrc: Lrc): void {
    this.lrc = lrc.clone();
    this.lrcUpdate();
  }
  /**
   * Updates LRC by aligning the offset and sorting lyrics.
   */
  lrcUpdate(): void {
    if (this.useOffset) {
      this._offsetAlign();
    }
    this._sort();
  }
  /**
   * Aligns the offset if it exists in LRC info, otherwise uses the default offset.
   */
  private _offsetAlign(): void {
    let offsetMs: number;
    if (&apos;offset&apos; in this.lrc.info) {
      offsetMs = parseInt(this.lrc.info.offset);
      if (isNaN(offsetMs)) {
        offsetMs = this.defaultOffset;
      }
      delete this.lrc.info.offset;
    } else {
      offsetMs = this.defaultOffset;
    }
    // Convert milliseconds to seconds for the lrc.offset() method
    this.lrc.offset(offsetMs / 1000);
  }
  /**
   * Sets a new default offset value
   * @param offsetMs - The new default offset in milliseconds
   */
  setDefaultOffset(offsetMs: number): void {
    this.defaultOffset = offsetMs;
    if (this.useOffset) {
      this.lrcUpdate();
    }
  }
  /**
   * Sorts the lyrics by their timestamp.
   */
  private _sort(): void {
    this.lrc.lyrics.sort((a, b) =&gt; a.timestamp - b.timestamp);
  }
  /**
   * Updates the current index based on the given timestamp.
   * @param timestamp - The current timestamp of the audio.
   */
  timeUpdate(timestamp: number): void {
    if (this._currentIndex &gt;= this.lrc.lyrics.length) {
      this._currentIndex = this.lrc.lyrics.length - 1;
    } else if (this._currentIndex &lt; -1) {
      this._currentIndex = -1;
    }
    this._currentIndex = this._findIndex(timestamp, this._currentIndex);
  }
  /**
   * Finds the appropriate index for the given timestamp.
   * @param timestamp - The current timestamp of the audio.
   * @param startIndex - The starting index for the search.
   * @returns The index of the lyric that corresponds to the timestamp.
   */
  private _findIndex(timestamp: number, startIndex: number): number {
    const curFrontTimestamp =
      startIndex === -1 ? Number.NEGATIVE_INFINITY : this.lrc.lyrics[startIndex].timestamp;
    const curBackTimestamp =
      startIndex === this.lrc.lyrics.length - 1 ? Number.POSITIVE_INFINITY : this.lrc.lyrics[startIndex + 1].timestamp;
    if (timestamp &lt; curFrontTimestamp) {
      return this._findIndex(timestamp, startIndex - 1);
    } else if (timestamp === curBackTimestamp) {
      return curBackTimestamp === Number.POSITIVE_INFINITY ? startIndex : startIndex + 1;
    } else if (timestamp &gt; curBackTimestamp) {
      return this._findIndex(timestamp, startIndex + 1);
    } else {
      return startIndex;
    }
  }
  /**
   * Gets the LRC info.
   * @returns An object containing LRC info.
   */
  getInfo() {
    return this.lrc.info;
  }
  /**
   * Gets all the lyrics.
   * @returns An array containing all the lyrics.
   */
  getLyrics() {
    return this.lrc.lyrics;
  }
  /**
   * Gets the lyric at the specified index.
   * @param index - The index of the lyric to retrieve. Defaults to the current index.
   * @returns The lyric at the specified index.
   * @throws Error if the index is out of range.
   */
  getLyric(index: number = this.curIndex()) {
    if (index &gt;= 0 &amp;&amp; index &lt;= this.lrc.lyrics.length - 1) {
      return this.lrc.lyrics[index];
    }
    return null;
  }
  /**
   * Gets the current index.
   */
  curIndex(): number {
    return this._currentIndex;
  }
  /**
   * Gets the current lyric.
   */
  current() {
    return this.getLyric();
  }
  next() {
    return this.getLyric(this._currentIndex + 1);
  }
}</file><file path="resources/app/modules/auth/forgot-password-form/forgot-password-form.tsx">import { Form } from &apos;radix-ui&apos;;
import styles from &apos;./forgot-password-form.module.scss&apos;;
import {Button, Flex, TextField } from &apos;@radix-ui/themes&apos;;
import React from &apos;react&apos;;
export function ForgotPasswordForm() {
// @ts-expect-error
  const onSubmit = (event: React.SyntheticEvent&lt;HTMLFormElement&gt;) =&gt; {
  }
  return (
    &lt;Form.Root className={styles.form} onSubmit={onSubmit}&gt;
      &lt;Flex direction=&quot;column&quot; gap=&quot;3&quot;&gt;
        &lt;Form.Field className={styles.Field} name=&quot;email&quot;&gt;
          &lt;Form.Label className={styles.Label}&gt;Email&lt;/Form.Label&gt;
          &lt;Form.Control asChild&gt;
            &lt;TextField.Root type=&quot;email&quot; radius=&quot;large&quot; size=&quot;3&quot; required&gt;
              &lt;TextField.Slot&gt;&lt;/TextField.Slot&gt;
            &lt;/TextField.Root&gt;
          &lt;/Form.Control&gt;
        &lt;/Form.Field&gt;
        &lt;Form.Submit asChild&gt;
          &lt;Button variant=&quot;solid&quot; size=&quot;3&quot; className={styles.Button}&gt;
            Submit
          &lt;/Button&gt;
        &lt;/Form.Submit&gt;
      &lt;/Flex&gt;
    &lt;/Form.Root&gt;
  )
}</file><file path="resources/app/modules/authorize/confirm-password.tsx">import { Button, Card, Container, Heading, Text } from &apos;@radix-ui/themes&apos;;
export function ConfirmPassword() {
  // const form = useForm&lt;PasswordForm&gt;({
  //   initialValues: {
  //     password: &apos;&apos;,
  //   },
  //   validate: {
  //     password: (val) =&gt; (val.length &lt;= 6 ? &apos;Password should include at least 6 characters&apos; : null),
  //   }
  // });
  return (
    &lt;Container&gt;
      &lt;Card&gt;
        &lt;form&gt;
          &lt;Heading&gt;Confirm password&lt;/Heading&gt;
          &lt;Text&gt;
            This is a secure area of the application. Please confirm your password before continuing.
          &lt;/Text&gt;
          &lt;Button type=&quot;submit&quot; mt=&quot;xl&quot;&gt;
            Login
          &lt;/Button&gt;
        &lt;/form&gt;
      &lt;/Card&gt;
    &lt;/Container&gt;
  )
}</file><file path="resources/app/modules/dashboard/libraries/components/create-library.tsx">import { Form } from &apos;radix-ui&apos;;
import { Button, Select, TextField } from &apos;@radix-ui/themes&apos;;
import { getLibraryTypesForSelect } from &apos;@/services/libraries/support.ts&apos;;
import styles from &apos;./create-library.module.css&apos;;
export function CreateLibrary() {
  const libraryTypes = getLibraryTypesForSelect();
  return (
    &lt;Form.Root className={styles.Root}&gt;
      &lt;Form.Field className={styles.Field} name=&quot;name&quot;&gt;
        &lt;Form.Label className={styles.Label}&gt;Name&lt;/Form.Label&gt;
        &lt;Form.Control asChild&gt;
          &lt;TextField.Root type=&quot;text&quot; radius=&quot;large&quot; size=&quot;3&quot; required /&gt;
        &lt;/Form.Control&gt;
        &lt;Form.Message className={styles.Message} match=&quot;valueMissing&quot;&gt;
          Please enter a name
        &lt;/Form.Message&gt;
      &lt;/Form.Field&gt;
      &lt;Form.Field className={styles.Field} name=&quot;path&quot;&gt;
        &lt;Form.Label className={styles.Label}&gt;Filesystem path&lt;/Form.Label&gt;
        &lt;Form.Control asChild&gt;
          &lt;TextField.Root type=&quot;text&quot; radius=&quot;large&quot; size=&quot;3&quot; required /&gt;
        &lt;/Form.Control&gt;
        &lt;Form.Message className={styles.Message} match=&quot;valueMissing&quot;&gt;
          Please enter the path to the library
        &lt;/Form.Message&gt;
      &lt;/Form.Field&gt;
      &lt;Form.Field className={styles.Field} name=&quot;type&quot;&gt;
        &lt;Form.Label className={styles.Label}&gt;Type&lt;/Form.Label&gt;
        &lt;Form.Control asChild&gt;
          &lt;Select.Root defaultValue={libraryTypes[0]?.value}&gt;
            &lt;Select.Trigger /&gt;
            &lt;Select.Content&gt;
              &lt;Select.Group&gt;
                &lt;Select.Label&gt;Type&lt;/Select.Label&gt;
                {libraryTypes.map((type) =&gt; (
                  &lt;Select.Item key={type.value} value={type.value}&gt;
                    {type.label}
                  &lt;/Select.Item&gt;
                ))}
              &lt;/Select.Group&gt;
            &lt;/Select.Content&gt;
          &lt;/Select.Root&gt;
        &lt;/Form.Control&gt;
        &lt;Form.Message className={styles.Message} match=&quot;valueMissing&quot;&gt;
          Please choose a type
        &lt;/Form.Message&gt;
      &lt;/Form.Field&gt;
      &lt;Form.Submit asChild&gt;
        &lt;Button className={styles.Button} style={{ marginTop: 10 }}&gt;
          Create Library
        &lt;/Button&gt;
      &lt;/Form.Submit&gt;
    &lt;/Form.Root&gt;
  );
}</file><file path="resources/app/modules/dashboard/libraries/libraries-new.tsx">import { Container, Heading } from &apos;@radix-ui/themes&apos;;
import { CreateLibrary } from &apos;@/modules/dashboard/libraries/components/create-library.tsx&apos;;
export function LibrariesNew() {
  return (
    &lt;&gt;
      &lt;Container mt=&quot;3&quot;&gt;
        &lt;Heading&gt;Create library&lt;/Heading&gt;
        &lt;CreateLibrary/&gt;
      &lt;/Container&gt;
    &lt;/&gt;
  );
}</file><file path="resources/app/modules/dashboard/queue-monitor/components/job-details.tsx">import { QueueMonitorResource } from &apos;@/api-client/requests&apos;;
import { Box, Container, Flex, Separator, Text } from &apos;@radix-ui/themes&apos;;
import { Table } from &apos;@radix-ui/themes&apos;;
import { JobStatus } from &apos;@/modules/dashboard/queue-monitor/components/job-status.tsx&apos;;
import { ErrorBoundary } from &apos;react-error-boundary&apos;;
import ReactJson from &apos;@microlink/react-json-view&apos;;
interface ExceptionDetailsProps {
  job: QueueMonitorResource;
}
const ExceptionDetails = ({ job }: ExceptionDetailsProps) =&gt; {
  return (
    &lt;Box p=&quot;2&quot;&gt;
      &lt;Flex direction=&quot;column&quot; gap=&quot;2&quot;&gt;
        &lt;Text size=&quot;2&quot; weight=&quot;bold&quot;&gt;Exception:&lt;/Text&gt;
        &lt;Text size=&quot;3&quot; color=&quot;red&quot; weight=&quot;bold&quot;&gt;{job.exception_class}&lt;/Text&gt;
        {job.exception &amp;&amp; (
          &lt;Box mt=&quot;2&quot;&gt;
            &lt;ReactJson
              src={job.exception}
              indentWidth={2}
            /&gt;
          &lt;/Box&gt;
        )}
      &lt;/Flex&gt;
    &lt;/Box&gt;
  );
};
export interface JobDetailsProps {
  job: QueueMonitorResource;
}
export function JobDetails({ job }: JobDetailsProps) {
  const tableData = {
    head: [&apos;Property&apos;, &apos;Value&apos;],
    body: [
      [&apos;id&apos;, job.id],
      [&apos;job_id&apos;, job.job_id],
      [&apos;job_uuid&apos;, job.job_uuid],
      [&apos;name&apos;, job.name],
      [&apos;queue&apos;, job.queue],
      [&apos;started_at&apos;, job.started_at],
      [&apos;started_at_exact&apos;, job.started_at_exact],
      [&apos;finished_at&apos;, job.finished_at],
      [&apos;finished_at_exact&apos;, job.finished_at_exact],
      [&apos;attempt&apos;, job.attempt],
      [&apos;progress&apos;, job.progress],
      [&apos;status&apos;, &lt;JobStatus status={job.status}/&gt;],
      [&apos;retried&apos;, job.retried],
      [&apos;queued_at&apos;, job.queued_at],
    ],
  };
  return (
    &lt;Container&gt;
      &lt;Table.Root&gt;
        &lt;Table.Header&gt;
          &lt;Table.Row&gt;
            &lt;Table.ColumnHeaderCell&gt;{tableData.head[0]}&lt;/Table.ColumnHeaderCell&gt;
            &lt;Table.ColumnHeaderCell&gt;{tableData.head[1]}&lt;/Table.ColumnHeaderCell&gt;
          &lt;/Table.Row&gt;
        &lt;/Table.Header&gt;
        &lt;Table.Body&gt;
          {tableData.body.map((row, index) =&gt; (
            &lt;Table.Row key={index}&gt;
              &lt;Table.RowHeaderCell&gt;{row[0]}&lt;/Table.RowHeaderCell&gt;
              &lt;Table.Cell&gt;{row[1]}&lt;/Table.Cell&gt;
            &lt;/Table.Row&gt;
          ))}
        &lt;/Table.Body&gt;
      &lt;/Table.Root&gt;
      &lt;Separator my=&quot;4&quot; size=&quot;4&quot; /&gt;
      &lt;ErrorBoundary fallback={&lt;Box p=&quot;2&quot;&gt;&lt;Text color=&quot;red&quot;&gt;Something went wrong&lt;/Text&gt;&lt;/Box&gt;}&gt;
        {job.exception &amp;&amp; (
          &lt;ExceptionDetails job={job}/&gt;
        )}
      &lt;/ErrorBoundary&gt;
    &lt;/Container&gt;
  );
}</file><file path="resources/app/modules/dashboard/queue-monitor/components/job-status.tsx">import { Badge } from &apos;@radix-ui/themes&apos;;
import { statusToColor } from &apos;@/utils/job-status.ts&apos;;
export interface JobStatusProps {
  status: string;
}
export function JobStatus({ status }: JobStatusProps) {
  const color = statusToColor(status);
  return (
    &lt;Badge color={color}&gt;{status}&lt;/Badge&gt;
  );
}</file><file path="resources/app/modules/dashboard/queue-monitor/components/jobs-list.tsx">import React, { useState } from &apos;react&apos;;
import { useQueueServiceGetApiQueueMetricsInfinite } from &apos;@/api-client/queries/infiniteQueries.ts&apos;;
import { TableVirtuoso } from &apos;react-virtuoso&apos;;
import { Button, Dialog, Flex, Text } from &apos;@radix-ui/themes&apos;;
import { QueueMonitorResource } from &apos;@/api-client/requests&apos;;
import { JobStatus } from &apos;@/modules/dashboard/queue-monitor/components/job-status.tsx&apos;;
import dayjs from &apos;dayjs&apos;;
import styles from &apos;./jobs-list.module.scss&apos;;
import { JobDetails } from &apos;@/modules/dashboard/queue-monitor/components/job-details.tsx&apos;;
export interface JobsList extends React.ComponentPropsWithoutRef&lt;&apos;div&apos;&gt; {
}
export function JobsList({...rest}: JobsList) {
  const { data: jobsData, fetchNextPage, hasNextPage } = useQueueServiceGetApiQueueMetricsInfinite();
  const [openJob, setOpenJob] = useState&lt;QueueMonitorResource&gt;();
  const getDuration = (start: string | null, end: string | null) =&gt; {
    if (start &amp;&amp; end) {
      const startDate = dayjs(start);
      const endDate = dayjs(end);
      const diff = endDate.diff(startDate);
      const duration = dayjs.duration(diff);
      return duration.asSeconds() + &apos;s&apos;;
    }
    return &apos;&apos;;
  };
  return (
    &lt;div {...rest}&gt;
      &lt;Dialog.Root&gt;
        &lt;TableVirtuoso
          className={styles.scrollList}
          data={jobsData?.pages?.flatMap(job =&gt; job.data)}
          totalCount={jobsData?.pages[0]?.meta?.total}
          // @ts-ignore
          components={TableComponents}
          useWindowScroll={true}
          endReached={() =&gt; {
            hasNextPage &amp;&amp; fetchNextPage();
          }}
          fixedHeaderContent={() =&gt; (
            &lt;tr&gt;
              &lt;td width=&quot;5%&quot;&gt;Job&lt;/td&gt;
              &lt;td width=&quot;5%&quot;&gt;Details&lt;/td&gt;
              &lt;td width=&quot;5%&quot;&gt;Progress&lt;/td&gt;
              &lt;td width=&quot;5%&quot;&gt;Duration&lt;/td&gt;
              &lt;td width=&quot;5%&quot;&gt;Status&lt;/td&gt;
              &lt;td width=&quot;8%&quot;&gt;Actions&lt;/td&gt;
            &lt;/tr&gt;
          )}
          itemContent={(_index, data: QueueMonitorResource) =&gt; {
            return (
              &lt;React.Fragment key={data.id}&gt;
                &lt;td&gt;
                  &lt;Text&gt;{data.name}&lt;/Text&gt;
                &lt;/td&gt;
                &lt;td&gt;
                  &lt;Flex direction=&quot;column&quot; gap=&quot;sm&quot;&gt;
                    &lt;Text size=&quot;2&quot;&gt;&lt;span className={styles.bold}&gt;Queue&lt;/span&gt;: {data.queue}&lt;/Text&gt;
                    &lt;Text size=&quot;2&quot;&gt;&lt;span className={styles.bold}&gt;Attempt&lt;/span&gt;: {data.attempt}&lt;/Text&gt;
                  &lt;/Flex&gt;
                &lt;/td&gt;
                &lt;td&gt;
                  {data.progress &amp;&amp; (&lt;Text&gt;{data.progress}%&lt;/Text&gt;)}
                &lt;/td&gt;
                &lt;td&gt;
                  {getDuration(data.started_at, data.finished_at)}
                &lt;/td&gt;
                &lt;td&gt;
                  &lt;JobStatus status={data.status}/&gt;
                &lt;/td&gt;
                &lt;td&gt;
                  &lt;Flex gap=&quot;2&quot; align=&quot;center&quot;&gt;
                    &lt;Dialog.Trigger&gt;
                      &lt;Button color=&quot;gray&quot; onClick={() =&gt; setOpenJob(data)}&gt;View&lt;/Button&gt;
                    &lt;/Dialog.Trigger&gt;
                    &lt;Button color=&quot;blue&quot;&gt;Retry&lt;/Button&gt;
                    &lt;Button color=&quot;red&quot;&gt;Delete&lt;/Button&gt;
                  &lt;/Flex&gt;
                &lt;/td&gt;
              &lt;/React.Fragment&gt;
            );
          }}
        /&gt;
        &lt;Dialog.Content&gt;
          &lt;Dialog.Title&gt;{ openJob?.name ?? &apos;Job&apos; }&lt;/Dialog.Title&gt;
          &lt;Dialog.Description&gt;See the details about the job&lt;/Dialog.Description&gt;
          {openJob &amp;&amp; &lt;JobDetails job={openJob} /&gt;}
          &lt;Flex gap=&quot;3&quot; mt=&quot;4&quot; justify=&quot;end&quot;&gt;
            &lt;Dialog.Close&gt;
              &lt;Button onClick={() =&gt; setOpenJob(undefined)}&gt;Close&lt;/Button&gt;
            &lt;/Dialog.Close&gt;
          &lt;/Flex&gt;
        &lt;/Dialog.Content&gt;
      &lt;/Dialog.Root&gt;
    &lt;/div&gt;
  );
}
interface ScrollerProps {
  style: React.CSSProperties;
  [key: string]: any;
}
const Scroller = React.forwardRef&lt;HTMLDivElement, ScrollerProps&gt;(({ style, ...props }, ref) =&gt; {
  // an alternative option to assign the ref is
  // &lt;div ref={(r) =&gt; ref.current = r}&gt;
  return &lt;div className={styles.scrollbar} style={{ ...style }} ref={ref} {...props} /&gt;;
});
const TableComponents = {
  Scroller,
}</file><file path="resources/app/modules/dashboard/queue-monitor/components/metric-card.tsx">import { Card, Text } from &apos;@radix-ui/themes&apos;;
export interface MetricCardProps {
  title: string;
  formattedValue: string;
  formattedPreviousValue: string | null;
}
export function MetricCard({ title, formattedValue, formattedPreviousValue }: MetricCardProps) {
  return (
    &lt;Card&gt;
      &lt;Text mr=&quot;2&quot;&gt;{title}&lt;/Text&gt;
      &lt;Text&gt;{formattedValue}&lt;/Text&gt;
      {formattedPreviousValue &amp;&amp; (
        &lt;Text&gt;{formattedPreviousValue}&lt;/Text&gt;
      )}
    &lt;/Card&gt;
  );
}</file><file path="resources/app/modules/dashboard/queue-monitor/components/metrics.tsx">import { useQueueServiceGetApiQueueMetricsMetrics } from &apos;@/api-client/queries&apos;;
import { Flex } from &apos;@radix-ui/themes&apos;;
import { MetricCard } from &apos;@/modules/dashboard/queue-monitor/components/metric-card.tsx&apos;;
export function Metrics() {
  const { data } = useQueueServiceGetApiQueueMetricsMetrics();
  return (
    &lt;Flex gap=&quot;3&quot; mt=&quot;4&quot; justify=&quot;center&quot;&gt;
      {data?.map((metric, index) =&gt; (
        &lt;MetricCard
          key={index}
          title={metric.title}
          formattedValue={metric.formattedValue}
          formattedPreviousValue={metric.formattedPreviousValue}
        /&gt;
      ))}
    &lt;/Flex&gt;
  )
}</file><file path="resources/app/modules/dashboard/queue-monitor/queue-monitor.tsx">import { Box, Container, Heading } from &apos;@radix-ui/themes&apos;;
import { JobsList } from &apos;@/modules/dashboard/queue-monitor/components/jobs-list.tsx&apos;;
import { Metrics } from &apos;@/modules/dashboard/queue-monitor/components/metrics.tsx&apos;;
export function QueueMonitor() {
  return (
    &lt;Container&gt;
      &lt;Heading mt=&quot;3&quot;&gt;Queue monitor&lt;/Heading&gt;
      &lt;Heading align=&quot;center&quot; size=&quot;2&quot; weight=&quot;medium&quot;&gt;Metrics&lt;/Heading&gt;
      &lt;Metrics /&gt;
      &lt;Box mt=&quot;5&quot;&gt;
        &lt;JobsList/&gt;
      &lt;/Box&gt;
    &lt;/Container&gt;
  );
}</file><file path="resources/app/modules/dashboard/system-info/php.tsx">import { useSystemInfoServiceGetApiSystemInfo } from &apos;@/api-client/queries&apos;;
import { Card, Container, Grid, Text, Heading } from &apos;@radix-ui/themes&apos;;
import styles from &apos;./php.module.scss&apos;;
function Section(section: { section: string, values: { key: string, value: string|number|boolean|null }[] }) {
  return (
    &lt;Card&gt;
        &lt;Text weight=&quot;medium&quot; size=&quot;2&quot;&gt;{section.section}&lt;/Text&gt;
        &lt;Grid columns=&quot;2&quot;&gt;
          {section.values.map((item, index) =&gt; (
            &lt;Text key={index}&gt;&lt;span className={styles.configKey}&gt;{item.key}&lt;/span&gt;: {item.value}&lt;/Text&gt;
          ))}
        &lt;/Grid&gt;
    &lt;/Card&gt;
  );
}
export function Php() {
  const { data } = useSystemInfoServiceGetApiSystemInfo();
  return (
    &lt;Container&gt;
      &lt;Heading mt=&quot;3&quot;&gt;Php&lt;/Heading&gt;
      &lt;Grid columns=&quot;2&quot; mt=&quot;3&quot;&gt;
        {data?.map((section, index) =&gt; (
          &lt;Section section={section.section} values={section.values} key={index}/&gt;
        ))}
      &lt;/Grid&gt;
    &lt;/Container&gt;
  )
}</file><file path="resources/app/modules/dashboard/users/users-list.tsx">import { Box, Container, Heading } from &apos;@radix-ui/themes&apos;;
import { UserTable } from &apos;@/ui/users/user-table/user-table.tsx&apos;;
export function UsersList() {
  return (
    &lt;Container&gt;
      &lt;Heading&gt;Users&lt;/Heading&gt;
      &lt;Box mt=&quot;lg&quot;&gt;
        &lt;UserTable/&gt;
      &lt;/Box&gt;
    &lt;/Container&gt;
  );
}</file><file path="resources/app/modules/library-movies/routes/_routes.tsx">import { Route, Routes } from &apos;react-router-dom&apos;;
import { Overview } from &apos;@/modules/library-movies/routes/overview.tsx&apos;;
export const LibraryMoviesRoutes = () =&gt; {
  return (
    &lt;Routes&gt;
      &lt;Route path=&quot;/overview&quot; element={&lt;Overview/&gt;}/&gt;
    &lt;/Routes&gt;
  );
};</file><file path="resources/app/modules/library-movies/routes/overview.tsx">import { Box } from &apos;@radix-ui/themes&apos;;
import { MovieList } from &apos;@/modules/library-movies/components/movie-list/movie-list.tsx&apos;;
export function Overview() {
  return (
    &lt;Box&gt;
      &lt;MovieList/&gt;
    &lt;/Box&gt;
  )
}</file><file path="resources/app/modules/library-music-player/components/player-buttons/player-controls.module.scss">.playerControl {
    border: 0;
    background: transparent;
    .icon {
        color: #95908f;
        cursor: pointer;
        transition: all 0.15ms ease-in-out;
        &amp;:hover {
            color: #958e8b;
        }
    }
}</file><file path="resources/app/modules/library-music-player/components/player-controls/player-controls.module.scss">.playerControls {
  display: flex;
  justify-content: center;
  align-items: center;
  height: 100%;
  flex-grow: 1;
}</file><file path="resources/app/modules/library-music-player/components/volume-slider/volume-slider.tsx">import { useAudioPlayer } from &apos;@/modules/library-music-player/providers/audio-player-provider.tsx&apos;;
import { Slider, Flex, IconButton } from &apos;@radix-ui/themes&apos;;
import { Iconify } from &apos;@/ui/icons/iconify.tsx&apos;;
import { MUSIC_CONTROL_ICON_SIZE } from &apos;@/modules/library-music-player/constants.ts&apos;;
import { ChangeEvent } from &apos;react&apos;;
function getVolumeIcon(isMuted: boolean, volume: number): string {
  if (isMuted || volume === 0) {
    return &apos;raphael:volume0&apos;;
  }
  if (volume &gt; 0 &amp;&amp; volume &lt;= 39) {
    return &apos;raphael:volume1&apos;;
  }
  if (volume &gt;= 40 &amp;&amp; volume &lt;= 69) {
    return &apos;raphael:volume2&apos;;
  }
  return &apos;raphael:volume3&apos;;
}
export function VolumeSlider() {
  const {
    volume,
    setCurrentVolume,
    isMuted,
    toggleMuteUnmute,
  } = useAudioPlayer();
  const handleChange = (e: ChangeEvent&lt;HTMLInputElement&gt;) =&gt; {
    e.preventDefault();
    setCurrentVolume(Number(e.target.value));
  }
  return (
    &lt;Flex width=&quot;120px&quot; mr=&quot;xs&quot; align=&quot;center&quot; justify=&quot;center&quot;&gt;
      &lt;IconButton onClick={() =&gt; toggleMuteUnmute()} variant=&quot;ghost&quot;&gt;
        &lt;Iconify fontSize={MUSIC_CONTROL_ICON_SIZE}  icon={getVolumeIcon(isMuted, volume)}/&gt;
      &lt;/IconButton&gt;
      &lt;Slider
        min={0}
        max={100}
        // size=&quot;sm&quot;
        defaultValue={[volume]}
        onChange={handleChange}
      /&gt;
    &lt;/Flex&gt;
  );
}</file><file path="resources/app/modules/library-music-player/hooks/use-audio-processor.tsx">import { useCallback, useEffect, useRef } from &apos;react&apos;;
import { setBufferSize, setLeftChannel, setRightChannel } from &apos;@/store/music/music-player-slice.ts&apos;;
import { useAppDispatch } from &apos;@/store/hooks.ts&apos;;
import { useAudioPlayer } from &apos;@/modules/library-music-player/providers/audio-player-provider.tsx&apos;;
export function useAudioProcessor() {
  const dispatch = useAppDispatch();
  const {
    audioRef,
    song,
  } = useAudioPlayer();
  const songTimeInSeconds = useRef(0);
  // @ts-expect-error
  const interval = useRef&lt;NodeJS.Timeout&gt;();
// @ts-expect-error
  const audioContext = useRef&lt;AudioContext&gt;();
  // @ts-expect-error
  const merger = useRef&lt;ChannelMergerNode&gt;();
// @ts-expect-error
  const bassBiquadFilter = useRef&lt;BiquadFilterNode&gt;();
  // @ts-expect-error
  const middleBiquadFilter = useRef&lt;BiquadFilterNode&gt;();
  // @ts-expect-error
  const trebleBiquadFilter = useRef&lt;BiquadFilterNode&gt;();
// @ts-expect-error
  const leftChannelGainNode = useRef&lt;GainNode&gt;();
  // @ts-expect-error
  const rightChannelGainNode = useRef&lt;GainNode&gt;();
// @ts-expect-error
  const analyser = useRef&lt;AnalyserNode&gt;();
  // @ts-expect-error
  const leftChannelAnalyser = useRef&lt;AnalyserNode&gt;();
  // @ts-expect-error
  const rightChannelAnalyser = useRef&lt;AnalyserNode&gt;();
// @ts-expect-error
  const channelSplitter = useRef&lt;ChannelSplitterNode&gt;();
  const startAnalyserInterval = useCallback(() =&gt; {
    if (!analyser.current || !song) {
      return;
    }
    // create frequency buffer
    const bufferLength = analyser.current.frequencyBinCount;
    dispatch(setBufferSize(bufferLength));
    // create left and right data buffers
    const leftChannel = new Uint8Array(bufferLength);
    const rightChannel = new Uint8Array(bufferLength);
    interval.current = setInterval(() =&gt; {
      songTimeInSeconds.current = audioRef.current.duration;
      if (leftChannelAnalyser.current &amp;&amp; rightChannelAnalyser.current) {
        leftChannelAnalyser.current.getByteFrequencyData(leftChannel);
        rightChannelAnalyser.current.getByteFrequencyData(rightChannel);
        const leftChannelReducedValue = leftChannel.reduce(
          (acc, curr) =&gt; acc + curr,
          0,
        );
        const rightChannelReducedValue = rightChannel.reduce(
          (acc, curr) =&gt; acc + curr,
          0,
        );
        const leftChannelAverageValue =
          leftChannelReducedValue / leftChannel.length;
        const rightChannelAverageValue =
          rightChannelReducedValue / rightChannel.length;
        const leftChannelValue = Math.floor(leftChannelAverageValue);
        const rightChannelValue = Math.floor(rightChannelAverageValue);
        dispatch(setLeftChannel(leftChannelValue));
        dispatch(setRightChannel(rightChannelValue));
      }
    }, 20);
  }, [song]);
  const stopAnalyserInterval = useCallback(() =&gt; {
    if (interval.current) {
      clearInterval(interval.current);
    }
  }, []);
  const resetTimeCounter = useCallback(() =&gt; {
    songTimeInSeconds.current = 0;
  }, []);
  const setupAudioGainNodesAndAnalyzers = () =&gt; {
    if (!audioContext.current || !audioRef.current) {
      return;
    }
    const source = audioContext.current.createMediaElementSource(audioRef.current);
    // BASS GAIN NODE
    bassBiquadFilter.current = audioContext.current.createBiquadFilter();
    bassBiquadFilter.current.type = &apos;lowshelf&apos;;
    source.connect(bassBiquadFilter.current);
    // MIDDLE GAIN NODE
    middleBiquadFilter.current = audioContext.current.createBiquadFilter();
    middleBiquadFilter.current.type = &apos;peaking&apos;;
    bassBiquadFilter.current.connect(middleBiquadFilter.current);
    // TREBLE GAIN NODE
    trebleBiquadFilter.current = audioContext.current.createBiquadFilter();
    trebleBiquadFilter.current.type = &apos;highshelf&apos;;
    middleBiquadFilter.current.connect(trebleBiquadFilter.current);
    // CREATE ANALYSER
    analyser.current = audioContext.current.createAnalyser();
    leftChannelAnalyser.current = audioContext.current.createAnalyser();
    rightChannelAnalyser.current = audioContext.current.createAnalyser();
    // FREQUENCY ANALYSER
    trebleBiquadFilter.current.connect(analyser.current);
    analyser.current.fftSize = 1024;
    // CHANNELS SPLITTER
    channelSplitter.current = audioContext.current.createChannelSplitter(2);
    trebleBiquadFilter.current.connect(channelSplitter.current);
    // BALANCE GAIN NODES
    leftChannelGainNode.current = audioContext.current.createGain();
    rightChannelGainNode.current = audioContext.current.createGain();
    // LEFT CHANNEL GAIN NODE CONNECT TO LEFT CHANNEL
    channelSplitter.current.connect(leftChannelGainNode.current, 0);
    // RIGHT CHANNEL GAIN NODE CONNECT TO RIGHT CHANNEL
    channelSplitter.current.connect(rightChannelGainNode.current, 1);
    if (leftChannelAnalyser.current &amp;&amp; rightChannelAnalyser.current) {
      // LEFT CHANNEL ANALYSER CONNECT TO LEFT CHANNEL GAIN NODE
      leftChannelGainNode.current.connect(leftChannelAnalyser.current);
      leftChannelAnalyser.current.fftSize = 1024;
      // RIGHT CHANNEL ANALYSER CONNECT TO RIGHT CHANNEL GAIN NODE
      rightChannelGainNode.current.connect(rightChannelAnalyser.current);
      rightChannelAnalyser.current.fftSize = 1024;
    }
    // ----- MERGE TOGETHER AUDIO SPLIT SOURCES ------------
    merger.current = audioContext.current.createChannelMerger(2);
    leftChannelGainNode.current.connect(merger.current, 0, 0);
    rightChannelGainNode.current.connect(merger.current, 0, 1);
    merger.current.connect(audioContext.current.destination);
  };
  const setBalance = useCallback((balance: number) =&gt; {
    if (!leftChannelGainNode.current || !rightChannelGainNode.current) {
      return;
    }
    leftChannelGainNode.current.gain.value = 1 - balance / 100;
    rightChannelGainNode.current.gain.value = balance / 100;
  }, []);
  const setStereo = useCallback((isStereoEnabled: boolean) =&gt; {
    if (
      !merger.current ||
      !leftChannelGainNode.current ||
      !rightChannelGainNode.current ||
      !audioContext.current
    ) {
      return;
    }
    if (isStereoEnabled) {
      leftChannelGainNode.current.connect(merger.current, 0, 0);
      rightChannelGainNode.current.connect(merger.current, 0, 1);
      merger.current.connect(audioContext.current.destination);
    } else {
      leftChannelGainNode.current.connect(merger.current, 0, 0);
      rightChannelGainNode.current.connect(merger.current, 0, 0);
      merger.current.connect(audioContext.current.destination);
    }
  }, []);
  const setBass = useCallback((bass: number) =&gt; {
    if (bassBiquadFilter.current) {
      bassBiquadFilter.current.gain.value = bass;
    }
  }, []);
  const setMiddle = useCallback((middle: number) =&gt; {
    if (middleBiquadFilter.current) {
      middleBiquadFilter.current.gain.value = middle;
    }
  }, []);
  const setTreble = useCallback((treble: number) =&gt; {
    if (trebleBiquadFilter.current) {
      trebleBiquadFilter.current.gain.value = treble;
    }
  }, []);
  useEffect(() =&gt; {
    if (audioRef.current &amp;&amp; song) {
      audioContext.current = new AudioContext();
      setupAudioGainNodesAndAnalyzers();
      startAnalyserInterval();
    } else {
      stopAnalyserInterval();
      resetTimeCounter();
      stopAnalyserInterval();
    }
  }, [song]);
  return {
    setBalance,
    setStereo,
    setBass,
    setMiddle,
    setTreble,
  };
}</file><file path="resources/app/modules/library-music-player/inline-player.tsx">import { useEffect, useMemo } from &apos;react&apos;;
import { Flex } from &apos;@radix-ui/themes&apos;;
import { useMusicSource } from &apos;@/providers/music-source-provider.tsx&apos;;
import { PlayerStateInput } from &apos;@/services/libraries/player-state.ts&apos;;
import { useAudioPlayer } from &apos;@/modules/library-music-player/providers/audio-player-provider.tsx&apos;;
import { useSongServiceGetApiLibrariesByLibrarySongsByPublicId } from &apos;@/api-client/queries&apos;;
import { PlayerControls } from &apos;@/modules/library-music-player/components/player-controls/player-controls.tsx&apos;;
import PlayerFacePlate from &apos;@/modules/library-music-player/components/player-face-plate/player-face-plate.tsx&apos;;
import {
  PlayerMetaControls,
} from &apos;@/modules/library-music-player/components/player-meta-controls/player-meta-controls.tsx&apos;;
import { LyricsProvider } from &apos;@/ui/lyrics-viewer/providers/lyrics-provider.tsx&apos;;
import { selectSong } from &apos;@/store/music/music-player-slice.ts&apos;;
import { useAppSelector } from &apos;@/store/hooks.ts&apos;;
export function InlinePlayer() {
  const sourceSong = useAppSelector(selectSong);
  useEffect(() =&gt; {
    console.log(&apos;sourceSong&apos;, sourceSong);
  }, [sourceSong]);
  const {
    authenticatedSource,
  } = useMusicSource();
  const canQuery = Boolean(sourceSong?.public_id);
  const { data: song } = useSongServiceGetApiLibrariesByLibrarySongsByPublicId({
    library: &apos;music&apos;,
    publicId: sourceSong?.public_id!,
    relations: &apos;album,album.cover,artists&apos;,
  }, undefined, { enabled: canQuery });
  const { setSong } = useAudioPlayer();
  useEffect(() =&gt; {
    if (song) {
      setSong(song);
    } else {
      setSong(null);
    }
  }, [song]);
  const {
    audioRef,
    isPlaying,
    duration,
    currentProgress,
    setCurrentProgress,
    buffered,
    togglePlayPause,
  } = useAudioPlayer();
  useEffect(() =&gt; {
    let timerId = setInterval(() =&gt; {
      if (!authenticatedSource) {
        return;
      }
// @ts-expect-error
      const data: PlayerStateInput = {
        isPlaying,
        volumePercent: 100,
        progressMs: currentProgress,
      };
    }, 5000);
    return () =&gt; {
      clearInterval(timerId);
    };
  }, []);
  const setProgress = (e: number) =&gt; {
    if (!audioRef.current) return;
    audioRef.current.currentTime = e;
    setCurrentProgress(e);
  };
  const coverUrl = useMemo(() =&gt; {
    return song?.album?.cover?.url ?? &apos;&apos;;
  }, [song]);
  const artistNames = useMemo(() =&gt; {
    return song &amp;&amp; song?.artists?.map(artist =&gt; artist.name);
  }, [song]);
  const title = useMemo(() =&gt; song &amp;&amp; song.title, [song]);
  const album = useMemo(() =&gt; song &amp;&amp; song.album, [song]);
  return (
    &lt;&gt;
      &lt;LyricsProvider&gt;
        &lt;Flex justify=&quot;center&quot; flexGrow=&quot;1&quot; style={{flexGrow: 1}}&gt;
          &lt;PlayerControls
            isPlaying={isPlaying}
            togglePlayPause={() =&gt; togglePlayPause()}
          /&gt;
          &lt;PlayerFacePlate
            buffered={buffered}
            duration={duration}
            currentProgress={currentProgress}
            setProgress={progress =&gt; setProgress(progress)}
            viewModel={{
              coverUrl,
              title,
              artists: artistNames,
              album: album?.title,
            }}
          /&gt;
          &lt;PlayerMetaControls song={song}/&gt;
        &lt;/Flex&gt;
      &lt;/LyricsProvider&gt;
    &lt;/&gt;
  );
}</file><file path="resources/app/modules/library-music-playlists/playlist/playlist.tsx">import { SongTable } from &apos;@/components/song-table/song-table&apos;;
import { usePathParam } from &apos;@/hooks/use-path-param&apos;;
import { usePlaylistServiceGetApiPlaylistsByPlaylist } from &apos;@/api-client/queries&apos;;
import { MusicPlaylistParams } from &apos;@/modules/library-music-playlists/_routes.tsx&apos;;
import styles from &apos;./playlist.module.scss&apos;;
export function PlayList() {
  const { playlistId } = usePathParam&lt;MusicPlaylistParams&gt;();
  const {
    data,
  } = usePlaylistServiceGetApiPlaylistsByPlaylist({
    playlist: playlistId,
  });
  return (
    &lt;SongTable
      songs={data?.songs || []}
      title={data?.name}
      description={data?.description}
      className={styles.playlistTable}
    /&gt;
  );
}</file><file path="resources/app/modules/library-music/components/album/album.tsx">import React from &apos;react&apos;;
import { Cover } from &apos;@/modules/library-music/components/artwork/cover&apos;;
import styles from &apos;./album.module.scss&apos;;
import { Box, Flex, Text } from &apos;@radix-ui/themes&apos;;
interface AlbumProps extends Omit&lt;React.HTMLAttributes&lt;HTMLDivElement&gt;, &apos;className&apos;&gt; {
  title: string;
  primaryArtist?: string;
  imgSrc?: string;
}
export function Album({ title, primaryArtist = &quot;Unknown Artist&quot;, imgSrc, ...props }: AlbumProps) {
  return (
    &lt;Box p=&quot;3px&quot; className={styles.album} {...props}&gt;
      &lt;Cover imgSrc={imgSrc} size={160} interactive={true} /&gt;
      &lt;Flex direction=&quot;column&quot;&gt;
        &lt;Text size=&quot;1&quot; className={styles.title} title={title}&gt;
          {title}
        &lt;/Text&gt;
        &lt;Text size=&quot;1&quot; className={styles.artist} title={primaryArtist}&gt;
          {primaryArtist}
        &lt;/Text&gt;
      &lt;/Flex&gt;
    &lt;/Box&gt;
  );
}</file><file path="resources/app/modules/library-music/components/artwork/artist-big-circle/artist-big-circle.tsx">import { Text } from &apos;@radix-ui/themes&apos;;
import styles from &apos;./artist-big-circle.module.scss&apos;;
import { ArtistResource } from &apos;@/api-client/requests&apos;;
interface ArtistBigCircleProps {
  artist: ArtistResource;
}
export function ArtistBigCircle({ artist }: ArtistBigCircleProps) {
  return (
    &lt;div className={styles.artistBigCircle}&gt;
      &lt;div className={styles.imageContainer}&gt;
        &lt;img
          src={&apos;https://place-hold.it/300&apos;}
          alt={artist.name}
          className={styles.image}
        /&gt;
      &lt;/div&gt;
      &lt;Text&gt;{artist.name}&lt;/Text&gt;
    &lt;/div&gt;
  )
}</file><file path="resources/app/modules/library-music/components/scroll-list/scroll-list.module.scss">.scrollList {
    flex: 1;
    border-right: 1px solid #e0dddd;
    border-bottom: 1px solid #e0dddd;
    .title {
        margin-left: 3px;
    }
}
.listItem {
    cursor: pointer;
}
.activeItem {
    background-color: #ccc;
}
@media (prefers-color-scheme: dark) {
    .activeItem {
        background-color: #333;
    }
}
.scrollbar {
    --sb-track-color: &apos;transparent&apos;;
    --sb-thumb-color: #828282;
    --sb-size: 6px;
}
.scrollbar::-webkit-scrollbar {
    width: var(--sb-size)
}
.scrollbar::-webkit-scrollbar-track {
    background: var(--sb-track-color);
    border-radius: 3px;
}
.scrollbar::-webkit-scrollbar-thumb {
    background: var(--sb-thumb-color);
    border-radius: 3px;
}
@supports not selector(::-webkit-scrollbar) {
    .scrollbar {
        scrollbar-color: var(--sb-thumb-color)
        var(--sb-track-color);
    }
}</file><file path="resources/app/modules/library-music/routes/artists.tsx">import styles from &apos;./artists.module.scss&apos;;
import { CoverGrid } from &apos;@/modules/library-music/components/cover-grid&apos;;
import { ArtistBigCircle } from &apos;@/modules/library-music/components/artwork/artist-big-circle/artist-big-circle.tsx&apos;;
import { Container } from &apos;@radix-ui/themes&apos;;
import { usePathParam } from &apos;@/hooks/use-path-param.ts&apos;;
import { LibraryParams } from &apos;@/modules/library-music/routes/_routes.tsx&apos;;
import { useArtistServiceGetApiLibrariesByLibraryArtists } from &apos;@/api-client/queries&apos;;
export default function Artists() {
  const { library: libraryParam } = usePathParam&lt;LibraryParams&gt;();
  const {data: artistsData} = useArtistServiceGetApiLibrariesByLibraryArtists({
    library: libraryParam,
  })
  return (
    &lt;Container className={styles.artistsLayout}&gt;
      &lt;CoverGrid style={{ gap: &apos;32px&apos; }}&gt;
        {artistsData?.data.map((artist, index) =&gt; (
          &lt;div className={styles.artist} key={index}&gt;
            &lt;ArtistBigCircle artist={artist} /&gt;
          &lt;/div&gt;
        ))}
      &lt;/CoverGrid&gt;
    &lt;/Container&gt;
  );
}</file><file path="resources/app/modules/notifications/components/notification-card/notification-card.tsx">import { Notification } from &apos;@/modules/notifications/models&apos;;
import { Box, Button, Card, Flex, Text } from &apos;@radix-ui/themes&apos;;
import { Iconify } from &apos;@/ui/icons/iconify.tsx&apos;;
import { useAppDispatch } from &apos;@/store/hooks.ts&apos;;
import { removeNotification } from &apos;@/store/notifications/notifications-slice.ts&apos;;
import { DateTime } from &apos;@/ui/dates/date-time.tsx&apos;;
export interface NotificationCardProps extends React.ComponentPropsWithoutRef&lt;&apos;div&apos;&gt; {
  notification: Notification;
}
function getNotificationColor(notification: Notification) {
  switch (notification.type) {
    case &apos;success&apos;:
      return &apos;#008000&apos;;
    case &apos;warning&apos;:
      return &apos;#FFA500&apos;;
    case &apos;error&apos;:
      return &apos;#FF0000&apos;;
    default:
      return &apos;&apos;;
  }
}
export function NotificationCard({ notification, ...rest }: NotificationCardProps) {
  const dispatch = useAppDispatch();
  const color = getNotificationColor(notification);
  const handleDismiss = () =&gt; {
    dispatch(removeNotification({ id: notification.id }));
  };
  return (
    &lt;Card
      {...rest}
      style={{
        backgroundColor: color,
        marginTop: &apos;4px&apos;
      }}
    &gt;
      &lt;Flex
        gap=&quot;2&quot;
        justify=&quot;between&quot;
        align=&quot;center&quot;
      &gt;
        &lt;Box&gt;
          &lt;Text as=&quot;div&quot; size=&quot;2&quot; weight=&quot;bold&quot;&gt;{notification.message}&lt;/Text&gt;
          &lt;Text as=&quot;div&quot; size=&quot;1&quot; color=&quot;gray&quot;&gt;
            &lt;DateTime date={notification.createdAt}/&gt;
          &lt;/Text&gt;
        &lt;/Box&gt;
        &lt;Button
          variant=&quot;ghost&quot;
          onClick={() =&gt; handleDismiss()}
        &gt;
          &lt;Iconify icon=&quot;ion:close&quot;/&gt;
        &lt;/Button&gt;
      &lt;/Flex&gt;
    &lt;/Card&gt;
  );
}</file><file path="resources/app/modules/notifications/models.ts">export type NotificationType = &apos;success&apos; | &apos;error&apos; | &apos;info&apos; | &apos;warning&apos;;
export interface ToastModel {
  id: string;
  message: string;
  type: NotificationType;
  title?: string;
  duration?: number;
}
export type CreateToast = Omit&lt;ToastModel, &apos;id&apos;&gt;;
export interface ToastOptions {
  duration?: number;
}
export function isToastOptions(value: any): value is ToastOptions {
  return value &amp;&amp; typeof value.duration === &apos;number&apos;;
}
export interface Notification {
  id: string;
  type: NotificationType;
  title?: string;
  message: string;
  read: boolean;
  /**
   * Nudge the user with a toast as well
   */
  toast?: ToastOptions | boolean;
  createdAt: Date;
  updatedAt?: Date;
}
export type CreateNotification = Omit&lt;Notification, &apos;id&apos; | &apos;read&apos; | &apos;createdAt&apos; | &apos;updatedAt&apos;&gt;;</file><file path="resources/app/modules/notifications/notification-area.tsx">import { Button, Flex, Popover, ScrollArea, Text } from &apos;@radix-ui/themes&apos;;
import { useAppDispatch, useAppSelector } from &apos;@/store/hooks.ts&apos;;
import { NotificationCard } from &apos;@/modules/notifications/components/notification-card/notification-card.tsx&apos;;
import { Notification } from &apos;@/modules/notifications/models&apos;;
import { Iconify } from &apos;@/ui/icons/iconify.tsx&apos;;
import { clearNotifications } from &apos;@/store/notifications/notifications-slice.ts&apos;;
export function NotificationArea() {
  const { notifications } = useAppSelector(state =&gt; state.notifications);
  return (
    &lt;Popover.Root&gt;
      &lt;Popover.Trigger&gt;
        &lt;Button size=&quot;3&quot; variant=&quot;ghost&quot;&gt;
          &lt;Iconify icon=&quot;ion:notifications&quot;/&gt; {notifications.length &gt; 0 ? &apos;(&apos; + notifications.length + &apos;)&apos; : &apos;&apos;}
        &lt;/Button&gt;
      &lt;/Popover.Trigger&gt;
      &lt;Popover.Content&gt;
        &lt;NotificationList notifications={notifications}/&gt;
      &lt;/Popover.Content&gt;
    &lt;/Popover.Root&gt;
  );
}
interface NotificationListProps {
  notifications: Notification[];
}
function NotificationList({ notifications }: NotificationListProps) {
  const dispatch = useAppDispatch();
  const handleClear = () =&gt; {
    dispatch(clearNotifications());
  };
  return (
    &lt;Flex direction=&quot;column&quot; maxWidth=&quot;300px&quot;&gt;
      &lt;Text as=&quot;div&quot; size=&quot;2&quot; weight=&quot;bold&quot; align=&quot;center&quot;&gt;Notifications&lt;/Text&gt;
      &lt;ScrollArea style={{ height: 300 }}&gt;
        &lt;Flex direction=&quot;column&quot;&gt;
          {notifications.map(notification =&gt; (
            &lt;NotificationCard
              notification={notification}
              key={notification.id}
            /&gt;
          ))}
        &lt;/Flex&gt;
      &lt;/ScrollArea&gt;
      &lt;Button
        mt=&quot;2&quot;
        size=&quot;2&quot;
        variant=&quot;ghost&quot;
        onClick={() =&gt; handleClear()}
      &gt;Clear&lt;/Button&gt;
    &lt;/Flex&gt;
  );
}</file><file path="resources/app/modules/overview/overview.tsx">import { Flex, Heading, Section } from &apos;@radix-ui/themes&apos;;
import { useAlbumServiceGetApiLibrariesByLibraryAlbums } from &apos;@/api-client/queries&apos;;
import { Carousel } from &apos;@/ui/carousel/carousel.tsx&apos;;
import { ReactNode, useEffect, useState } from &apos;react&apos;;
import { Album } from &apos;@/modules/library-music/components/album&apos;;
export interface OverviewProps {
  title: string;
}
export function Overview({title}: OverviewProps) {
  const { data } = useAlbumServiceGetApiLibrariesByLibraryAlbums({
    library: &apos;music&apos;,
    relations: &apos;cover,artists&apos;,
  });
  const [albums, setAlbums] = useState&lt;ReactNode[]&gt;([]);
  useEffect(() =&gt; {
    if (data) {
      const nodes = data.data.map(album =&gt; &lt;Album key={album.slug} title={album.title} imgSrc={album.cover?.url} primaryArtist={album?.artists?.[0]?.name}/&gt;);
      setAlbums(nodes);
    }
  }, [data]);
  return (
    &lt;Flex direction=&quot;column&quot; px=&quot;3&quot;&gt;
      &lt;Section title=&quot;Albums&quot;&gt;
        &lt;Heading mb=&quot;2&quot;&gt;{title}&lt;/Heading&gt;
        {albums.length &gt; 0 &amp;&amp; (
          &lt;Carousel
            slides={albums}
            options={{
            slidesToScroll: 9,
          }}/&gt;
        )}
      &lt;/Section&gt;
    &lt;/Flex&gt;
  );
}</file><file path="resources/app/modules/user-settings/pages/passkeys.tsx">import { Button, Container, Dialog, Heading, Inset } from &apos;@radix-ui/themes&apos;;
import { CreatePasskey } from &apos;@/modules/user-settings/features/passkeys/create-passkey.tsx&apos;;
export function Passkeys() {
  return (
    &lt;&gt;
      &lt;Dialog.Root&gt;
        &lt;Container&gt;
          &lt;Heading&gt;Passkeys&lt;/Heading&gt;
          &lt;Dialog.Trigger&gt;
            &lt;Button&gt;Create&lt;/Button&gt;
          &lt;/Dialog.Trigger&gt;
        &lt;/Container&gt;
        &lt;Dialog.Content&gt;
          &lt;Dialog.Title&gt;Create passkey&lt;/Dialog.Title&gt;
          &lt;Inset side=&quot;x&quot; my=&quot;5&quot;&gt;
            &lt;CreatePasskey/&gt;
          &lt;/Inset&gt;
          &lt;Dialog.Close&gt;
            &lt;Button variant=&quot;soft&quot; color=&quot;gray&quot;&gt;
              Close
            &lt;/Button&gt;
          &lt;/Dialog.Close&gt;
        &lt;/Dialog.Content&gt;
      &lt;/Dialog.Root&gt;
    &lt;/&gt;
  );
}</file><file path="resources/app/modules/user-settings/pages/sessions.tsx">import { useState } from &apos;react&apos;;
import { Button, Container, Dialog, Flex, Inset, Text } from &apos;@radix-ui/themes&apos;;
import { useUserTokenServiceGetApiUsersTokensByUser } from &apos;@/api-client/queries&apos;;
import { useDateFormatter } from &apos;@/providers/dayjs-provider.tsx&apos;;
import { PersonalAccessTokenViewResource } from &apos;@/api-client/requests&apos;;
import { TokenDetail } from &apos;@/modules/user-settings/features/tokens/token-detail.tsx&apos;;
export function Sessions() {
  const { data, isLoading } = useUserTokenServiceGetApiUsersTokensByUser({ user: &apos;1&apos;, perPage: 100 });
  const { formatDate } = useDateFormatter();
  const [openSession, setOpenSession] = useState&lt;PersonalAccessTokenViewResource | undefined&gt;();
  const setViewSession = (session: PersonalAccessTokenViewResource | undefined) =&gt; {
    setOpenSession(session);
  }
  return (
    &lt;&gt;
      &lt;Dialog.Root&gt;
      &lt;Container&gt;
        &lt;Text size=&quot;1&quot;&gt;Sessions&lt;/Text&gt;
        &lt;table&gt;
          &lt;thead&gt;
            &lt;tr&gt;
              &lt;th&gt;Name&lt;/th&gt;
              &lt;th&gt;Client&lt;/th&gt;
              &lt;th&gt;Created at&lt;/th&gt;
              &lt;th&gt;Expires at&lt;/th&gt;
              &lt;th&gt;Last used at&lt;/th&gt;
              &lt;th&gt;&lt;/th&gt;
              &lt;th&gt;&lt;/th&gt;
            &lt;/tr&gt;
          &lt;/thead&gt;
          &lt;tbody&gt;
            {isLoading ? (
              &lt;tr&gt;
                &lt;td&gt;Loading...&lt;/td&gt;
              &lt;/tr&gt;
            ) : (
               data?.data.map((session) =&gt; (
                 &lt;Dialog.Trigger key={session.id}&gt;
                   &lt;tr key={session.id} onClick={() =&gt; setViewSession(session)}&gt;
                     &lt;td&gt;{session.name}&lt;/td&gt;
                     &lt;td&gt;{session.clientName} {session.clientType}&lt;/td&gt;
                     &lt;td&gt;{formatDate(session.createdAt)}&lt;/td&gt;
                     &lt;td&gt;{formatDate(session.expiresAt)}&lt;/td&gt;
                     &lt;td&gt;{formatDate(session.lastUsedAt)}&lt;/td&gt;
                     &lt;td&gt;
                       &lt;Button&gt;View&lt;/Button&gt;
                     &lt;/td&gt;
                     &lt;td&gt;
                       &lt;Button color=&quot;red&quot;&gt;Revoke&lt;/Button&gt;
                     &lt;/td&gt;
                   &lt;/tr&gt;
                 &lt;/Dialog.Trigger&gt;
               ))
             )}
          &lt;/tbody&gt;
        &lt;/table&gt;
      &lt;/Container&gt;
        &lt;Dialog.Content&gt;
          &lt;Dialog.Title&gt;Token&lt;/Dialog.Title&gt;
          &lt;Inset side=&quot;x&quot; my=&quot;5&quot;&gt;
            {openSession &amp;&amp; &lt;TokenDetail item={openSession} /&gt;}
          &lt;/Inset&gt;
          &lt;Flex gap=&quot;3&quot; justify=&quot;end&quot;&gt;
            &lt;Dialog.Close&gt;
              &lt;Button variant=&quot;soft&quot; color=&quot;gray&quot;&gt;
                Close
              &lt;/Button&gt;
            &lt;/Dialog.Close&gt;
          &lt;/Flex&gt;
        &lt;/Dialog.Content&gt;
      &lt;/Dialog.Root&gt;
    &lt;/&gt;
  );
}</file><file path="resources/app/providers/dayjs-provider.tsx">import React, { createContext, ReactNode, useCallback, useContext, useState } from &apos;react&apos;;
import dayjs from &apos;dayjs&apos;;
const localeFormatMap: Record&lt;string, string&gt; = {
  &apos;en&apos;: &apos;MM-DD-YYYY HH:mm&apos;,        // English (US)
  &apos;en-gb&apos;: &apos;DD-MM-YYYY HH:mm&apos;,     // English (UK)
  &apos;de&apos;: &apos;DD.MM.YYYY HH:mm&apos;,        // German
  &apos;fr&apos;: &apos;DD/MM/YYYY HH:mm&apos;,        // French
  &apos;es&apos;: &apos;DD/MM/YYYY HH:mm&apos;,        // Spanish
  &apos;th&apos;: &apos;DD/MM/YYYY HH:mm&apos;,        // Thai
  &apos;zh-cn&apos;: &apos;YYYY-MM-DD HH:mm&apos;,     // Chinese (Simplified)
  // Add more locales and their formats as needed
};
const getLocalizedFormat = (locale: string): string =&gt; {
  return localeFormatMap[locale] || &apos;YYYY-MM-DD HH:mm&apos;; // Default to ISO format
};
type Formattable = dayjs.Dayjs | string | number | undefined | null;
interface DateFormatterContextProps {
  locale: string;
  setLocale: (locale: string) =&gt; void;
  formatDate: (date: Formattable) =&gt; string;
  fromNow: (date: Formattable, withoutSuffix?: boolean) =&gt; string;
}
const DateFormatterContext = createContext&lt;DateFormatterContextProps | undefined&gt;(undefined);
DateFormatterContext.displayName = &apos;DateFormatterContext&apos;;
const DateFormatterProvider: React.FC&lt;{ children: ReactNode }&gt; = ({ children }) =&gt; {
  const [locale, _setLocale] = useState&lt;string&gt;(&apos;en&apos;);
  const setLocale = useCallback((value: string) =&gt; {
    if (value &amp;&amp; value !== locale &amp;&amp; Object.keys(localeFormatMap).includes(value)) {
      dayjs.locale(value);
      _setLocale(value);
    }
  }, [locale, localeFormatMap]);
  const formatDate = (date: Formattable): string =&gt; {
    if (!date) {
      return &apos;&apos;;
    }
    const formatString = getLocalizedFormat(locale);
    return dayjs(date).format(formatString);
  };
  const fromNow = (date: Formattable, withoutSuffix?: boolean): string =&gt; {
    if (!date) {
      return &apos;&apos;;
    }
    return dayjs(date).fromNow(withoutSuffix);
  }
  return (
    &lt;DateFormatterContext.Provider value={{ formatDate, fromNow, locale, setLocale }}&gt;
      {children}
    &lt;/DateFormatterContext.Provider&gt;
  );
};
const useDateFormatter = (): DateFormatterContextProps =&gt; {
  const context = useContext(DateFormatterContext);
  if (!context) {
    throw new Error(&apos;useDateFormatter must be used within a DateFormatterProvider&apos;);
  }
  return context;
};
export { DateFormatterProvider, useDateFormatter };</file><file path="resources/app/routes/index.tsx">import { publicRoutes } from &apos;@/routes/public&apos;;
import { useRoutes } from &apos;react-router-dom&apos;;
import { protectedRoutes } from &apos;@/routes/protected&apos;;
import { selectIsAuthenticated } from &apos;@/store/users/auth-slice.ts&apos;;
import { useAppSelector } from &apos;@/store/hooks.ts&apos;;
export function AppRoutes() {
  const isAuthenticated = useAppSelector(selectIsAuthenticated);
  // see https://github.com/alan2207/bulletproof-react/blob/master/src/routes/index.tsx
  const routes = isAuthenticated ? protectedRoutes : publicRoutes;
  const element = useRoutes([...routes]);
  return &lt;&gt;{element}&lt;/&gt;;
}</file><file path="resources/app/services/auth/token.ts">import { NewAccessTokenResource, PostApiAuthLoginResponse } from &apos;@/api-client/requests&apos;;
const LOCAL_STORAGE_KEY = &apos;baander_token&apos;;
const LOCAL_STORAGE_KEY_STREAM = &apos;baander_stream_token&apos;;
export const Token = {
  get() {
    const token = localStorage.getItem(LOCAL_STORAGE_KEY);
    if (!token) {
      return undefined;
    }
    return JSON.parse(token) as PostApiAuthLoginResponse;
  },
  getStreamToken() {
    const token = localStorage.getItem(LOCAL_STORAGE_KEY_STREAM);
    if (!token) {
      return undefined;
    }
    return JSON.parse(token) as NewAccessTokenResource;
  },
  set(token: PostApiAuthLoginResponse) {
    localStorage.setItem(LOCAL_STORAGE_KEY, JSON.stringify(token));
  },
  setStreamToken(token: NewAccessTokenResource) {
    localStorage.setItem(LOCAL_STORAGE_KEY_STREAM, JSON.stringify(token));
  },
  clear() {
    localStorage.removeItem(LOCAL_STORAGE_KEY);
    localStorage.removeItem(LOCAL_STORAGE_KEY_STREAM);
  },
};
export function isTokenExpired(expiresAt: string): boolean {
  // Convert expiresAt to a Date object
  const tokenExpiryDate = new Date(expiresAt);
  // Get current date
  const now = new Date();
  // If the current date is equal to or later than the expiry date,
  // it means that the token is expired or about to expire
  return now &gt;= tokenExpiryDate;
}</file><file path="resources/app/services/libraries/support.ts">export enum LibraryType {
  AudioBook = &apos;audiobook&apos;,
  Movie = &apos;movie&apos;,
  Music = &apos;music&apos;,
  PostCast = &apos;podcast&apos;,
  TvShow = &apos;tv_show&apos;,
}
let cachedLibraryTypesForSelect: {label: string, value: string}[] | null = null;
export function getLibraryTypesForSelect() {
  if (cachedLibraryTypesForSelect !== null) {
    return cachedLibraryTypesForSelect;
  }
  cachedLibraryTypesForSelect = Object.entries(LibraryType).map(([key, value]) =&gt; ({
    label: key,
    value: value
  }));
  return cachedLibraryTypesForSelect;
}</file><file path="resources/app/store/audio/equalizer.ts">import { ThreeBandEq } from &apos;@/modules/equalizer/models/three-band-eq.ts&apos;;
import { BarsMode } from &apos;@/modules/equalizer/types.ts&apos;;
import { createSlice, PayloadAction } from &apos;@reduxjs/toolkit&apos;;
export interface EqualizerState {
  isEnabled: boolean;
  isStereoEnabled: boolean;
  isMicrophoneEnabled: boolean;
  isKaraokeEnabled: boolean;
  balance: number;
  boostThreeBands: ThreeBandEq;
  microphoneBoost: number;
  barsMode: BarsMode;
}
const initialState: EqualizerState = {
  isEnabled: true,
  isStereoEnabled: true,
  isMicrophoneEnabled: false,
  isKaraokeEnabled: false,
  balance: 50,
  microphoneBoost: 0,
  barsMode: &apos;bars&apos;,
  boostThreeBands: {
    bass: 0,
    middle: 0,
    treble: 0,
  },
};
export const equalizerSlice = createSlice({
  name: &apos;equalizer&apos;,
  initialState,
  reducers: {
    setIsEnabled: (state, action: PayloadAction&lt;boolean&gt;) =&gt; {
      state.isEnabled = action.payload;
    },
    setIsStereoEnabled: (state, action: PayloadAction&lt;boolean&gt;) =&gt; {
      state.isStereoEnabled = action.payload;
    },
    setIsKaraokeEnabled: (state, action: PayloadAction&lt;boolean&gt;) =&gt; {
      state.isKaraokeEnabled = action.payload;
    },
    setBalance: (state, action: PayloadAction&lt;number&gt;) =&gt; {
      state.balance = action.payload;
    },
    setIsMicrophoneEnabled: (state, action: PayloadAction&lt;boolean&gt;) =&gt; {
      state.isMicrophoneEnabled = action.payload;
    },
    setBassBooster: (state, action: PayloadAction&lt;number&gt;) =&gt; {
      state.boostThreeBands.bass = action.payload;
    },
    setMiddleBooster: (state, action: PayloadAction&lt;number&gt;) =&gt; {
      state.boostThreeBands.middle = action.payload;
    },
    setTrebleBooster: (state, action: PayloadAction&lt;number&gt;) =&gt; {
      state.boostThreeBands.treble = action.payload;
    },
    setMicrophoneBooster: (state, action: PayloadAction&lt;number&gt;) =&gt; {
      state.microphoneBoost = action.payload;
    },
    setBarsMode: (state, action: PayloadAction&lt;BarsMode&gt;) =&gt; {
      state.barsMode = action.payload;
    },
  }
});
export const {
  setIsEnabled,
  setIsStereoEnabled,
  setIsKaraokeEnabled,
  setIsMicrophoneEnabled,
  setBassBooster,
  setMiddleBooster,
  setTrebleBooster,
  setBalance,
  setMicrophoneBooster,
  setBarsMode,
} = equalizerSlice.actions;</file><file path="resources/app/store/notifications/notifications-slice.ts">import {
  CreateNotification,
  CreateToast,
  isToastOptions,
  Notification,
  ToastModel,
} from &apos;@/modules/notifications/models.ts&apos;;
import { createSlice, PayloadAction } from &apos;@reduxjs/toolkit&apos;;
export interface NotificationsSlice {
  notifications: Notification[];
  toasts: ToastModel[];
}
const initialState: NotificationsSlice = {
  notifications: [],
  toasts: [],
};
export const notificationsSlice = createSlice({
  name: &apos;notifications&apos;,
  initialState,
  reducers: {
    createNotification: (state, action: PayloadAction&lt;CreateNotification&gt;) =&gt; {
      const notification: Notification = {
        id: self.crypto.randomUUID(),
        ...action.payload,
        read: false,
        createdAt: new Date(),
      };
      if (notification.toast) {
        const toast: ToastModel = {
          id: notification.id,
          title: notification?.title,
          message: notification.message,
          type: notification.type,
          duration: isToastOptions(notification.toast) ? notification.toast.duration : 3000,
        };
        state.toasts.push(toast);
      }
      state.notifications.unshift(notification);
    },
    removeNotification: (state, action: PayloadAction&lt;{ id: string }&gt;) =&gt; {
      state.notifications = state.notifications.filter(notification =&gt; notification.id !== action.payload.id);
    },
    clearNotifications: (state) =&gt; {
      state.notifications = [];
    },
    markNotificationAsRead: (state, action: PayloadAction&lt;{ id: string }&gt;) =&gt; {
      state.notifications = state.notifications.map(notification =&gt; {
        if (notification.id === action.payload.id) {
          return {
            ...notification,
            isRead: true,
          };
        }
        return notification;
      });
    },
    createToast: (state, action: PayloadAction&lt;CreateToast&gt;) =&gt; {
      const toast: ToastModel = {
        ...action.payload,
        id: self.crypto.randomUUID(),
      };
      state.toasts.push(toast);
    },
    removeToast: (state, action: PayloadAction&lt;{ id: string }&gt;) =&gt; {
      state.toasts = state.toasts.filter(toast =&gt; toast.id !== action.payload.id);
    },
  },
});
export const {
  createNotification,
  removeNotification,
  clearNotifications,
  markNotificationAsRead,
  createToast,
  removeToast,
} = notificationsSlice.actions;</file><file path="resources/app/ui/alerts/alert-loading-error.tsx">import { isPromise } from &apos;@/utils/is-promise.ts&apos;;
import { useCallback } from &apos;react&apos;;
import Alert from &apos;@/ui/alerts/alert.tsx&apos;;
export interface AlertLoadingErrorProps {
  message?: string;
  retry?: () =&gt; void | Promise&lt;void&gt;;
}
export function AlertLoadingError({retry, message}: AlertLoadingErrorProps) {
  const defaultMessage = &apos;Unable to load request&apos;;
  const retryRequest = useCallback(() =&gt; {
    if (!retry) {
      return;
    }
    if (isPromise(retry)) {
      retry.then()
    } else {
      retry()
    }
  }, [retry])
  return (
    &lt;Alert
      color=&quot;red&quot;
    &gt;
      &lt;Alert.Title&gt;{message ?? defaultMessage}&lt;/Alert.Title&gt;
      &lt;Alert.Action onClick={retryRequest}&gt;
        Retry
      &lt;/Alert.Action&gt;
    &lt;/Alert&gt;
  )
}</file><file path="resources/app/ui/blur-hash/blur-hash-canvas.tsx">import { CanvasHTMLAttributes, useEffect, useRef } from &apos;react&apos;;
import { decodeBlurHash } from &apos;fast-blurhash&apos;;
export interface BlurHashCanvasProps extends CanvasHTMLAttributes&lt;HTMLCanvasElement&gt; {
  hash: string;
  height: number;
  width: number;
  punch?: number;
}
export function BlurHashCanvas({ hash, height = 128, width = 128, punch, ...rest }: BlurHashCanvasProps) {
  const ref = useRef&lt;HTMLCanvasElement&gt;(null);
  const draw = () =&gt; {
    if (ref.current) {
      const pixels = decodeBlurHash(hash, width, height, punch);
      const ctx = ref.current.getContext(&apos;2d&apos;);
      if (ctx) {
        const imageData = ctx.createImageData(width, height);
        imageData.data.set(pixels);
        ctx.putImageData(imageData, 0, 0);
      }
    }
  };
  useEffect(() =&gt; {
    if (hash) {
      draw();
    }
  }, [hash, height, width, punch]);
  return (
    &lt;canvas
      {...rest}
      height={height}
      width={width}
      ref={ref}
    /&gt;
  );
}</file><file path="resources/app/ui/carousel/carousel.tsx">import React, { ReactNode } from &apos;react&apos;;
import { EmblaOptionsType } from &apos;embla-carousel&apos;;
import useEmblaCarousel from &apos;embla-carousel-react&apos;;
import { NextButton, PrevButton, usePrevNextButtons } from &apos;@/ui/carousel/components/arrow-buttons.tsx&apos;;
import &apos;./carousel.scss&apos;;
type PropType = {
  slides: ReactNode[]
  options?: EmblaOptionsType
}
export const Carousel: React.FC&lt;PropType&gt; = (props) =&gt; {
  const { slides, options } = props;
  const [emblaRef, emblaApi] = useEmblaCarousel(options);
  const {
    prevBtnDisabled,
    nextBtnDisabled,
    onPrevButtonClick,
    onNextButtonClick,
  } = usePrevNextButtons(emblaApi);
  return (
    &lt;section className=&quot;embla&quot;&gt;
      &lt;div className=&quot;embla__viewport&quot; ref={emblaRef}&gt;
        &lt;div className=&quot;embla__container&quot;&gt;
          {slides.map((node, index) =&gt; (
            &lt;div className=&quot;embla__slide&quot; key={index}&gt;
              {node}
            &lt;/div&gt;
          ))}
        &lt;/div&gt;
      &lt;/div&gt;
      &lt;div className=&quot;embla__controls&quot;&gt;
        &lt;div className=&quot;embla__buttons&quot;&gt;
          &lt;PrevButton onClick={onPrevButtonClick} disabled={prevBtnDisabled}/&gt;
          &lt;NextButton onClick={onNextButtonClick} disabled={nextBtnDisabled}/&gt;
        &lt;/div&gt;
      &lt;/div&gt;
    &lt;/section&gt;
  );
};</file><file path="resources/app/ui/dates/date-time.tsx">import dayjs from &apos;dayjs&apos;;
type FormatStyle = &apos;short&apos; | &apos;medium&apos; | &apos;long&apos;;
export interface DateTimeProps {
  date: string | Date;
  format?: FormatStyle;
  locale?: string; // Optional locale override (e.g., &apos;en-US&apos;, &apos;fr-FR&apos;)
}
const getOptionsForFormat = (format: FormatStyle): Intl.DateTimeFormatOptions =&gt; {
  switch (format) {
    case &apos;short&apos;:
      return { dateStyle: &apos;short&apos;, timeStyle: &apos;short&apos; };
    case &apos;medium&apos;:
      return { dateStyle: &apos;medium&apos;, timeStyle: &apos;short&apos; };
    case &apos;long&apos;:
      return { dateStyle: &apos;long&apos;, timeStyle: &apos;short&apos; };
    default:
      return { dateStyle: &apos;medium&apos;, timeStyle: &apos;short&apos; };
  }
};
export function DateTime({date, format = &apos;medium&apos;, locale = navigator.language}: DateTimeProps) {
  const parsedDate = dayjs(date).toDate();
  const formatter = new Intl.DateTimeFormat(locale, getOptionsForFormat(format));
  const formatted = formatter.format(parsedDate);
  return &lt;&gt;{formatted}&lt;/&gt;;
}</file><file path="resources/app/ui/link-button.tsx">import * as React from &apos;react&apos;;
import { NavLink, RelativeRoutingType, To } from &apos;react-router-dom&apos;;
import { Button, ButtonProps } from &apos;@radix-ui/themes&apos;;
interface LinkButtonProps extends ButtonProps  {
  children: React.ReactNode;
  to: To;
  reloadDocument?: boolean;
  replace?: boolean;
  state?: any;
  preventScrollReset?: boolean;
  relative?: RelativeRoutingType;
}
export function LinkButton({children, to, reloadDocument, replace, state, preventScrollReset, relative, ...rest}: LinkButtonProps) {
  return (
    &lt;NavLink
      to={to}
      reloadDocument={reloadDocument}
      replace={replace}
      state={state}
      preventScrollReset={preventScrollReset}
      relative={relative}
      // className={({isActive}) =&gt;
      //   clsx(className, {&apos;active-class&apos;: isActive})
      // }
    &gt;
    &lt;Button
      {...rest}
    &gt;
      {children}
    &lt;/Button&gt;
    &lt;/NavLink&gt;
  );
}</file><file path="resources/app/ui/lyrics-viewer/lyrics-viewer.module.scss">.lyricsContainer {
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  position: relative;
  padding: 20px;  // Add padding to prevent edge overflow
  overflow: hidden;
  text-align: center;
  pointer-events: none;
  border-radius: 6px;
  z-index: 20;
  height: 600px;
  width: 600px;
}
.background {
  position: absolute;
  width: 100%;
  height: 100%;
  z-index: -1; // Sends the background image behind the lyrics
}
.overlay {
  position: absolute;
  top: 0;
  left: 0;
  bottom: 0;
  right: 0;
  background-color: rgba(0,0,0,.2);
  pointer-events: none;
}
.footer {
  margin-top: auto;
  pointer-events: all;
}</file><file path="resources/app/ui/music/track-row/track-row.tsx">import React from &apos;react&apos;;
import { SongResource } from &apos;@/api-client/requests&apos;;
export interface TrackRowProps extends React.HTMLAttributes&lt;HTMLTableRowElement&gt; {
  song: SongResource;
}
export function TrackRow({song, ...rest}: TrackRowProps) {
  return (
    &lt;tr {...rest}&gt;
      &lt;td&gt;{song.track}&lt;/td&gt;
      &lt;td&gt;{song.title}&lt;/td&gt;
      &lt;td&gt;{song.durationHuman}&lt;/td&gt;
    &lt;/tr&gt;
  )
}</file><file path="resources/app/ui/user-button/user-button.module.scss">.user {
  display: flex;
  align-items: center;
  justify-content: center;
  vertical-align: middle;
}</file><file path="resources/app/ui/waveform/waveform.module.scss">.container {
  background-color: var(--color-background);
  padding: 0.2rem;
}
.titleBar {
  background-color: var(--accent-2);
  padding: 0.2rem;
  display: flex;
  justify-content: space-between;
}
.dnd {
  z-index: 5;
}</file><file path="resources/app/ui/waveform/waveform.tsx">import { createRef, useEffect, useState } from &apos;react&apos;;
import { Rnd } from &apos;react-rnd&apos;;
import WaveSurfer from &apos;wavesurfer.js&apos;;
// @ts-ignore
import Hover from &apos;wavesurfer.js/dist/plugins/hover.esm.js&apos;
import { useMusicSource } from &apos;@/providers/music-source-provider.tsx&apos;;
import styles from &apos;./waveform.module.scss&apos;;
import { CloseButton }   from &apos;../buttons/close-button&apos;;
import { Spinner, Text } from &apos;@radix-ui/themes&apos;;
export interface WaveformProps {
  onClose: () =&gt; void;
}
export function Waveform({ onClose }: WaveformProps) {
  const musicSource = useMusicSource();
  const [waveSurfer, setWaveSurfer] = useState&lt;WaveSurfer&gt;();
  const waveSurferRef = createRef&lt;HTMLDivElement&gt;();
  const [isLoading, setIsLoading] = useState&lt;boolean&gt;(false);
  // Window state
  const [size, updateSize] = useState({ width: 800, height: 180 });
  const [position, updatePosition] = useState({ x: -500, y: -200 });
  useEffect(() =&gt; {
    if (waveSurferRef.current) {
      const instance = WaveSurfer.create({
        container: waveSurferRef.current,
        waveColor: &apos;rgb(200, 0, 200)&apos;,
        progressColor: &apos;rgb(100, 0, 100)&apos;,
        autoplay: true,
        normalize: true,
        backend: &apos;WebAudio&apos;,
        plugins: [
          Hover.create({
            lineColor: &apos;#4981de&apos;,
            lineWidth: 2,
            labelBackground: &apos;#555&apos;,
            labelColor: &apos;#fff&apos;,
            labelSize: &apos;11px&apos;,
          }),
        ],
      });
      setWaveSurfer(instance);
    }
  }, [waveSurferRef.current]);
  useEffect(() =&gt; {
    if (waveSurfer &amp;&amp; musicSource.authenticatedSource) {
      setIsLoading(true);
      waveSurfer.empty();
      waveSurfer
        .load(musicSource.authenticatedSource)
        .then(() =&gt; {
          setIsLoading(false);
        });
    }
  }, [waveSurfer, musicSource.authenticatedSource]);
  useEffect(() =&gt; {
    return () =&gt; {
      waveSurfer?.destroy();
    };
  }, []);
  return (
    &lt;Rnd
      size={size}
      position={position}
      enableResizing
      // @ts-ignore
      onDragStop={(e, d) =&gt; {
        updatePosition({ x: d.x, y: d.y });
      }}
      // @ts-ignore
      onResizeStop={(e, direction, ref, delta, position) =&gt; {
        updateSize({
          width: Number(ref.style.width),
          height: Number(ref.style.height),
        });
        updatePosition(position);
      }}
      className={styles.dnd}
    &gt;
      &lt;div className={styles.container}&gt;
        &lt;div className={styles.titleBar}&gt;
          &lt;Text&gt;Waveform&lt;/Text&gt;
          &lt;CloseButton onClick={() =&gt; onClose()} /&gt;
        &lt;/div&gt;
        {isLoading &amp;&amp; &lt;Spinner /&gt;}
        &lt;div&gt;
          &lt;div ref={waveSurferRef}&gt;&lt;/div&gt;
        &lt;/div&gt;
      &lt;/div&gt;
    &lt;/Rnd&gt;
  );
}</file><file path="resources/app/utils/job-status.ts">export const statusToColor = (value: string) =&gt; {
  switch (value) {
    case &apos;succeeded&apos;:
      return &apos;green&apos;;
    case &apos;running&apos;:
      return &apos;blue&apos;;
    case &apos;failed&apos;:
      return &apos;red&apos;;
    case &apos;stale&apos;:
      return &apos;yellow&apos;;
    case &apos;queued&apos;:
      return &apos;indigo&apos;;
    default:
      return &apos;gray&apos;;
  }
};</file><file path="resources/app/utils/lazy-lottie.ts">import type {
  AnimationConfigWithPath,
  AnimationItem,
  LottiePlayer,
} from &apos;lottie-web&apos;;
let cachedLottie: LottiePlayer | null = null;
export type LazyAnimationItem = Pick&lt;
  AnimationItem,
  &apos;play&apos; | &apos;addEventListener&apos; | &apos;destroy&apos; | &apos;goToAndStop&apos;
&gt;;
const lazyLottie = {
  loadAnimation: (
    // Note: explicitly not using the `AnimationConfigWithData` type here because we want all animations
    // to be passed as URLs (`path: ...`), not as objects (`animationData: ...`). To pass an animation as an object,
    // you need to bundle it, which makes the bundle larger.
    //
    // If you’re a developer who wants to play a Lottie animation, please import the animation as a `.txt` file:
    //
    //   import animationURL from &quot;./animation.json.txt&quot;;
    //
    //  and pass it as the `path` prop:
    //
    //   lazyLottie.loadAnimation({ path: animationURL, ... });
    params: AnimationConfigWithPath,
  ): LazyAnimationItem =&gt; {
    if (cachedLottie) {
      return cachedLottie.loadAnimation(params);
    }
    const abortController = new AbortController();
    const queuedCommands: Array&lt;{
      commandName: &apos;play&apos; | &apos;addEventListener&apos; | &apos;goToAndStop&apos;;
      // TODO: Fix this the next time the file is edited
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      args: any[];
    }&gt; = [];
    import(&apos;lottie-web&apos;).then(({ default: lottie }) =&gt; {
      if (abortController.signal.aborted) {
        return;
      }
      cachedLottie = lottie;
      const animation = lottie.loadAnimation(params);
      for (const command of queuedCommands) {
        // @ts-expect-error – Getting “A spread argument must either have a tuple type or be passed to a rest parameter”, and it’s tricky to work around with this generalized code
        // TODO: Fix this the next time the file is edited
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        animation[command.commandName](...(command.args as any));
      }
    });
    return {
      play(...args) {
        queuedCommands.push({ commandName: &apos;play&apos;, args });
      },
      addEventListener(...args) {
        queuedCommands.push({ commandName: &apos;addEventListener&apos;, args });
        return () =&gt; {
          throw new Error(&apos;Not implemented&apos;);
        };
      },
      goToAndStop(...args) {
        queuedCommands.push({ commandName: &apos;goToAndStop&apos;, args });
      },
      destroy() {
        abortController.abort();
      },
    };
  },
};
export default lazyLottie;</file><file path="resources/views/dbg.blade.php">&lt;pre&gt;
&lt;/pre&gt;</file><file path="tsconfig.node.json">{
    &quot;compilerOptions&quot;: {
        &quot;composite&quot;: true,
        &quot;skipLibCheck&quot;: true,
        &quot;module&quot;: &quot;esnext&quot;,
        &quot;moduleResolution&quot;: &quot;bundler&quot;,
        &quot;allowSyntheticDefaultImports&quot;: true
    },
    &quot;include&quot;: [
        &quot;vite.config.ts&quot;
    ]
}</file><file path=".env.dev.example">#docker env
WEB_PORT_HTTP=80
WEB_PORT_TLS=443

# XDEBUG_CONFIG possible values: main|osx. Use main value for Linux and Windows, osx value for MacOS.
XDEBUG_CONFIG=main
# only for dev! See https://pecl.php.net/package/xdebug for versions
XDEBUG_VERSION=3.3.2

APP_NAME=Bånder
APP_ENV=local
APP_KEY=
APP_DEBUG=true
APP_URL=https://baander.test
ASSET_URL=https://baander.test
SANCTUM_STATEFUL_DOMAINS=https://baander.test
CLOCKWORK_ENABLE=false

LOG_CHANNEL=stack
LOG_DEPRECATIONS_CHANNEL=null
LOG_LEVEL=debug

DB_CONNECTION=&quot;pgsql&quot;
DB_HOST=&quot;postgres&quot;
DB_PORT=&quot;5432&quot;
DB_DATABASE=&quot;baander&quot;
DB_USERNAME=&quot;baander&quot;
DB_PASSWORD=&quot;baander&quot;

BROADCAST_CONNECTION=reverb
BROADCAST_DRIVER=reverb
CACHE_DRIVER=redis
FILESYSTEM_DISK=local
QUEUE_CONNECTION=redis
SESSION_DRIVER=redis
SESSION_CONNECTION=sessions
SESSION_LIFETIME=120

PASSPORT_PERSONAL_ACCESS_CLIENT_ID=1
PASSPORT_PERSONAL_ACCESS_CLIENT_SECRET=

REDIS_CLIENT=phpredis
REDIS_HOST=redis
REDIS_PASSWORD=null
REDIS_PORT=6379

MAIL_MAILER=smtp
MAIL_HOST=buggregator
MAIL_PORT=1025
MAIL_USERNAME=null
MAIL_PASSWORD=null
MAIL_ENCRYPTION=null
MAIL_FROM_ADDRESS=&quot;noreply@baander.test&quot;
MAIL_FROM_NAME=&quot;${APP_NAME}&quot;

INSPECTOR_URL=http://inspector@buggregator:8000
INSPECTOR_API_KEY=test
INSPECTOR_INGESTION_KEY=1test
INSPECTOR_ENABLE=true
VAR_DUMPER_FORMAT=server
VAR_DUMPER_SERVER=buggregator:9912
VAR_DUMPER_PREVIEW_MAX_DEPTH=4

VITE_APP_NAME=&quot;${APP_NAME}&quot;
VITE_APP_URL=&quot;https://baander.test&quot;

REVERB_APP_ID=199099
REVERB_APP_KEY=ws
REVERB_APP_SECRET=
REVERB_HOST=&quot;baander.test&quot;
REVERB_PORT=8080

VITE_REVERB_APP_KEY=&quot;${REVERB_APP_KEY}&quot;
VITE_REVERB_HOST=&quot;${REVERB_HOST}&quot;
VITE_REVERB_PORT=&quot;443&quot;
VITE_REVERB_SCHEME=&quot;${REVERB_SCHEME}&quot;</file><file path="app/Baander.php">&lt;?php
namespace App;
class Baander
{
    public const string VERSION = &apos;0.0.0-alpha&apos;;
    public static function getPeerName(): string
    {
        return config(&apos;app.name&apos;) . &apos;/v&apos; . Baander::VERSION;
    }
    public static function getAppInfo(): array
    {
        return [
            &apos;name&apos;        =&gt; config(&apos;app.name&apos;),
            &apos;url&apos;         =&gt; config(&apos;app.url&apos;),
            &apos;apiUrl&apos;      =&gt; config(&apos;app.url&apos;) . &apos;/api&apos;,
            &apos;environment&apos; =&gt; config(&apos;app.env&apos;),
            &apos;debug&apos;       =&gt; config(&apos;app.debug&apos;),
            &apos;locale&apos;      =&gt; config(&apos;app.locale&apos;),
            &apos;version&apos;     =&gt; Baander::VERSION,
        ];
    }
}</file><file path="app/Console/Kernel.php">&lt;?php
namespace App\Console;
use App\Jobs\Library\Metadata\ProbeQueueChecker;
use Illuminate\Console\Scheduling\Schedule;
use Illuminate\Foundation\Console\Kernel as ConsoleKernel;
class Kernel extends ConsoleKernel
{
    /**
     * Define the application&apos;s command schedule.
     */
    protected function schedule(Schedule $schedule): void
    {
        $schedule-&gt;command(&apos;horizon:snapshot&apos;)-&gt;everyFiveMinutes()-&gt;onOneServer();
        $schedule-&gt;command(&apos;sanctum:tokens clean&apos;)-&gt;daily();
        $schedule-&gt;command(&apos;sanctum:tokens cache&apos;)-&gt;weekly();
        $schedule-&gt;job(new ProbeQueueChecker())-&gt;everyMinute();
    }
    /**
     * Register the commands for the application.
     */
    protected function commands(): void
    {
        $this-&gt;load(__DIR__ . &apos;/Commands&apos;);
        require base_path(&apos;routes/console.php&apos;);
    }
}</file><file path="app/Http/Concerns/Filterable.php">&lt;?php
namespace App\Http\Concerns;
use App\Modules\Eloquent\BaseBuilder;
use Illuminate\Database\Eloquent\Builder;
use Illuminate\Http\Request;
trait Filterable
{
    /**
     * Apply global filter to the query.
     *
     * @param BaseBuilder|Builder $query
     * @param string $globalFilter
     * @param array $columns
     * @return void
     */
    protected function applyGlobalFilter(BaseBuilder|Builder $query, string $globalFilter, array $columns): void
    {
        $globalFilter = strtolower($globalFilter);
        $query-&gt;where(function ($q) use ($globalFilter, $columns) {
            foreach ($columns as $column) {
                $q-&gt;orWhereRaw(&quot;$column ILIKE ?&quot;, [&quot;%$globalFilter%&quot;]);
            }
        });
    }
    /**
     * Apply column filters to the query.
     *
     * @param BaseBuilder|Builder $query
     * @param array $filters
     * @param array $filterModes
     * @return void
     */
    protected function applyColumnFilters(BaseBuilder|Builder $query, array $filters, array $filterModes): void
    {
        foreach ($filters as $filter) {
            $columnId = $filter[&apos;id&apos;];
            $filterValue = strtolower($filter[&apos;value&apos;]);
            $filterMode = $filterModes[$columnId] ?? &apos;contains&apos;;
            $query-&gt;where(function ($q) use ($columnId, $filterValue, $filterMode) {
                if ($filterMode === &apos;contains&apos;) {
                    $q-&gt;whereRaw(&quot;$columnId ILIKE ?&quot;, [&quot;%$filterValue%&quot;]);
                } else if ($filterMode === &apos;startsWith&apos;) {
                    $q-&gt;whereRaw(&quot;$columnId ILIKE ?&quot;, [&quot;$filterValue%&quot;]);
                } else if ($filterMode === &apos;endsWith&apos;) {
                    $q-&gt;whereRaw(&quot;$columnId ILIKE ?&quot;, [&quot;%$filterValue&quot;]);
                }
            });
        }
    }
    /**
     * Apply sorting to the query.
     *
     * @param BaseBuilder|Builder $query
     * @param array $sorting
     * @return void
     */
    protected function applySorting(BaseBuilder|Builder $query, array $sorting): void
    {
        $sort = $sorting[0];
        $columnId = $sort[&apos;id&apos;];
        $direction = $sort[&apos;desc&apos;] ? &apos;desc&apos; : &apos;asc&apos;;
        $query-&gt;orderBy($columnId, $direction);
    }
    /**
     * Apply the query filters, sorting, and pagination.
     *
     * @param Request $request
     * @param \class-string $model
     * @param array $columnsForGlobalFilter
     * @return \Illuminate\Contracts\Pagination\LengthAwarePaginator
     */
    protected function applyFilters(Request $request, string $model, array $columnsForGlobalFilter = [])
    {
        $query = $model::query();
        // Handle global filter
        if ($request-&gt;filled(&apos;globalFilter&apos;)) {
            $this-&gt;applyGlobalFilter($query, $request-&gt;input(&apos;globalFilter&apos;), $columnsForGlobalFilter);
        }
        // Handle column filters
        $filters = json_decode($request-&gt;input(&apos;filters&apos;, &apos;[]&apos;), true);
        $filterModes = json_decode($request-&gt;input(&apos;filterModes&apos;, &apos;[]&apos;), true);
        if ($filters) {
            $this-&gt;applyColumnFilters($query, $filters, $filterModes);
        }
        // Handle sorting
        $sorting = json_decode($request-&gt;input(&apos;sorting&apos;, &apos;[]&apos;), true);
        if ($sorting) {
            $this-&gt;applySorting($query, $sorting);
        }
        return $query-&gt;paginate();
    }
}</file><file path="app/Http/Controllers/Api/OpCacheController.php">&lt;?php
namespace App\Http\Controllers\Api;
use App\Http\Controllers\Controller;
use App\Models\TokenAbility;
use App\Services\OpCacheService;
use Illuminate\Http\Request;
use Spatie\RouteAttributes\Attributes\{Get, Middleware, Post, Prefix};
#[Prefix(&apos;opcache&apos;)]
#[Middleware([
    &apos;auth:sanctum&apos;,
    &apos;ability:&apos; . TokenAbility::ACCESS_API-&gt;value,
    &apos;force.json&apos;,
])]
class OpCacheController extends Controller
{
    public function __construct(private readonly OpCacheService $opCacheService)
    {
    }
    /**
     * Get status
     *
     * @response array{
     *  opcache_enabled: bool,
     *  file_cache: string,
     *  file_cache_only: bool,
     *  cache_full: bool,
     *  restart_pending: bool,
     *  restart_in_progress,
     *  memory_usage: array{
     *    used_memory: int,
     *    free_memory: int,
     *    wasted_memory: int,
     *    current_wasted_percentage: float,
     *  },
     *  interned_strings_usage: array{
     *    buffer_size: int,
     *    used_memory: int,
     *    free_memory: int,
     *    number_of_strings: int,
     *  },
     *  opcache_statistics: array{
     *   num_cached_scripts: int,
     *   num_cached_keys: int,
     *   max_cached_keys: int,
     *   hits: int,
     *   start_time: int,
     *   last_restart_time: int,
     *   oom_restarts: int,
     *   hash_restarts: int,
     *   manual_restarts: int,
     *   misses: int,
     *   blacklist_misses: int,
     *   blacklist_miss_ratio: int,
     *   opcache_hit_rate: float
     *  },
     *  jit: array{
     *   enabled: bool,
     *   on: bool,
     *   kind: int,
     *   opt_level: int,
     *   opt_flags: int,
     *   buffer_size: int,
     *   buffer_free: int
     *  }
     * }
     */
    #[Get(&apos;/status&apos;)]
    public function getStatus()
    {
        $status = opcache_get_status(false);
        return response()-&gt;json($status);
    }
    /**
     * Get config
     *
     * @response array{
     *   directives: array{property: int|float|bool|string},
     *   version: array{version: string, opcache_product_name: string},
     *   blacklist: string[]
     * }
     */
    #[Get(&apos;/config&apos;, &apos;api.opcache.getConfig&apos;)]
    public function getConfig()
    {
        $config = opcache_get_configuration();
        return response()-&gt;json($config);
    }
    /**
     * Clear
     *
     * @response array{
     *  success: bool
     * }
     */
    #[Post(&apos;/clear&apos;, &apos;api.opcache.clear&apos;)]
    public function clearCache()
    {
        $result = opcache_reset();
        return response()-&gt;json([
            &apos;success&apos; =&gt; (bool)$result,
        ])-&gt;setStatusCode($result ? 200 : 500);
    }
    /**
     * Compile cache
     *
     * @response array{
     *   totalFiles: int,
     *   compiled: int
     * }
     */
    #[Post(&apos;/compile&apos;, &apos;api.opcache.compile&apos;)]
    public function compileCache(Request $request)
    {
        $result = $this-&gt;opCacheService-&gt;compile($request-&gt;query(&apos;force&apos;));
        return response()-&gt;json([
            &apos;totalFiles&apos; =&gt; $result[&apos;total_files_count&apos;],
            &apos;compiled&apos;   =&gt; $result[&apos;compiled_count&apos;],
        ]);
    }
}</file><file path="app/Http/Requests/Auth/LogoutRequest.php">&lt;?php
namespace App\Http\Requests\Auth;
use App\Auth\TokenName;
use Illuminate\Foundation\Http\FormRequest;
class LogoutRequest extends FormRequest
{
    /**
     * Determine if the user is authorized to make this request.
     */
    public function authorize(): bool
    {
        return true;
    }
    /**
     * Get the validation rules that apply to the request.
     *
     * @return array&lt;string, \Illuminate\Contracts\Validation\ValidationRule|array&lt;mixed&gt;|string&gt;
     */
    public function rules(): array
    {
        return [
            &apos;refresh_token&apos; =&gt; &apos;string&apos;,
        ];
    }
}</file><file path="app/Http/Requests/QueueMetrics/ShowQueueMetricsRequest.php">&lt;?php
namespace App\Http\Requests\QueueMetrics;
use App\Modules\QueueMonitor\MonitorStatus;
use Illuminate\Foundation\Http\FormRequest;
use Illuminate\Validation\Rule;
class ShowQueueMetricsRequest extends FormRequest
{
    /**
     * Determine if the user is authorized to make this request.
     */
    public function authorize(): bool
    {
        return true;
    }
    /**
     * Get the validation rules that apply to the request.
     *
     * @return array&lt;string, \Illuminate\Contracts\Validation\ValidationRule|array&lt;mixed&gt;|string&gt;
     */
    public function rules(): array
    {
        return [
            /**
             * @query
             * Current page
             */
            &apos;page&apos;        =&gt; &apos;int&apos;,
            /**
             * @query
             * Items per page
             */
            &apos;limit&apos;       =&gt; &apos;int&apos;,
            /**
             * @query
             * MonitorStatus
             * - 0=RUNNING
             * - 1=SUCCEEDED
             * - 2=FAILED
             * - 3=STALE
             * - 4=QUEUED
             */
            &apos;status&apos;      =&gt; [Rule::in(MonitorStatus::values())],
            /**
             * @query
             * Name of the queue
             */
            &apos;queue&apos;       =&gt; &apos;string&apos;,
            /**
             * @query
             * Name of the job
             */
            &apos;name&apos;        =&gt; &apos;string&apos;,
            /**
             * @query
             * Order queued jobs first
             *
             * @default false
             */
            &apos;queuedFirst&apos; =&gt; &apos;bool&apos;,
        ];
    }
}</file><file path="app/Http/Resources/Artist/ArtistResource.php">&lt;?php
namespace App\Http\Resources\Artist;
use App\Http\Resources\HasJsonCollection;
use App\Http\Resources\Image\ImageResource;
use App\Models\Artist;
use Illuminate\Http\Request;
use Illuminate\Http\Resources\Json\JsonResource;
/**
 * @mixin Artist
 */
class ArtistResource extends JsonResource
{
    use HasJsonCollection;
    /**
     * Transform the resource into an array.
     *
     * @return array&lt;string, mixed&gt;
     */
    public function toArray(Request $request): array
    {
        return [
            &apos;name&apos;      =&gt; $this-&gt;name,
            &apos;slug&apos;      =&gt; $this-&gt;slug,
            &apos;createdAt&apos; =&gt; $this-&gt;created_at,
            &apos;updatedAt&apos; =&gt; $this-&gt;updated_at,
            /**
             * Portrait relation
             */
            &apos;portrait&apos;  =&gt; ImageResource::make($this-&gt;whenLoaded(&apos;portrait&apos;)),
        ];
    }
}</file><file path="app/Http/Resources/Image/ImageResource.php">&lt;?php
namespace App\Http\Resources\Image;
use App\Http\Resources\HasJsonCollection;
use App\Models\Image;
use Illuminate\Http\Request;
use Illuminate\Http\Resources\Json\JsonResource;
/**
 * @mixin Image
 */
class ImageResource extends JsonResource
{
    use HasJsonCollection;
    /**
     * Transform the resource into an array.
     *
     * @return array&lt;string, mixed&gt;
     */
    public function toArray(Request $request): array
    {
        return [
            &apos;public_id&apos; =&gt; $this-&gt;public_id,
            &apos;path&apos;      =&gt; $this-&gt;path,
            &apos;extension&apos; =&gt; $this-&gt;extension,
            &apos;size&apos;      =&gt; $this-&gt;size,
            &apos;mime_type&apos; =&gt; $this-&gt;mime_type,
            &apos;width&apos;     =&gt; $this-&gt;width,
            &apos;height&apos;    =&gt; $this-&gt;height,
            &apos;blurhash&apos;  =&gt; $this-&gt;blurhash,
            &apos;url&apos;       =&gt; route(&apos;api.image.serve&apos;, [&apos;image&apos; =&gt; $this-&gt;public_id]),
        ];
    }
}</file><file path="app/Models/Artist.php">&lt;?php
namespace App\Models;
use Illuminate\Database\Eloquent\Factories\HasFactory;
use Spatie\Sluggable\{HasSlug, SlugOptions};
class Artist extends BaseModel
{
    use HasFactory, HasSlug;
    public static array $filterFields = [
        &apos;name&apos;,
        &apos;slug&apos;,
    ];
    public static array $filterRelations = [
        &apos;songs&apos;,
    ];
    protected $fillable = [
        &apos;name&apos;,
        &apos;slug&apos;,
    ];
    /**
     * Get the options for generating the slug.
     */
    public function getSlugOptions(): SlugOptions
    {
        return SlugOptions::create()
            -&gt;generateSlugsFrom(&apos;name&apos;)
            -&gt;saveSlugsTo(&apos;slug&apos;);
    }
    public function getRouteKeyName(): string
    {
        return &apos;slug&apos;;
    }
    public function albums()
    {
        return $this-&gt;belongsToMany(Album::class)
            -&gt;using(AlbumArtist::class);
    }
    public function songs()
    {
        return $this-&gt;belongsToMany(Song::class)
            -&gt;using(ArtistSong::class);
    }
    public function portrait()
    {
        return $this-&gt;morphOne(Image::class, &apos;imageable&apos;);
    }
}</file><file path="app/Models/Image.php">&lt;?php
namespace App\Models;
use App\Observers\ImageObserver;
use App\Modules\Http\Concerns\DirectStreamableFile;
use App\Modules\Nanoid\Concerns\HasNanoPublicId;
use Illuminate\Database\Eloquent\Attributes\ObservedBy;
use Illuminate\Database\Eloquent\Factories\HasFactory;
#[ObservedBy(ImageObserver::class)]
class Image extends BaseModel implements DirectStreamableFile
{
    use HasFactory, HasNanoPublicId;
    protected $fillable = [
        &apos;public_id&apos;,
        &apos;path&apos;,
        &apos;extension&apos;,
        &apos;size&apos;,
        &apos;mime_type&apos;,
        &apos;width&apos;,
        &apos;height&apos;,
    ];
    public function getRouteKeyName(): string
    {
        return &apos;public_id&apos;;
    }
    public function imageable()
    {
        return $this-&gt;morphTo();
    }
    public function getPath(): string
    {
        return $this-&gt;path;
    }
    public function getSize(): int
    {
        return $this-&gt;size;
    }
    public function getMimeType(): string
    {
        return $this-&gt;mime_type;
    }
}</file><file path="app/Models/LibraryType.php">&lt;?php
namespace App\Models;
use App\Extensions\EnumExt;
enum LibraryType: string
{
    use EnumExt;
    case Music = &apos;music&apos;;
    case Podcast = &apos;podcast&apos;;
    case Audiobook = &apos;audiobook&apos;;
    case Movie = &apos;movie&apos;;
    case TvShow = &apos;tv_show&apos;;
}</file><file path="app/Models/Playlist.php">&lt;?php
namespace App\Models;
use App\Modules\Nanoid\Concerns\HasNanoPublicId;
use App\Services\SmartPlaylistService;
use Illuminate\Database\Eloquent\Factories\HasFactory;
use Illuminate\Database\Eloquent\Relations\MorphOne;
class Playlist extends BaseModel
{
    use HasFactory, HasNanoPublicId;
    public static $filterRelations = [
        &apos;cover&apos;,
        &apos;songs&apos;,
        &apos;songs.artists&apos;,
        &apos;songs.album&apos;,
        &apos;songs.genres&apos;,
        &apos;songs.cover&apos;
    ];
    protected $fillable = [
        &apos;public_id&apos;,
        &apos;user_id&apos;,
        &apos;name&apos;,
        &apos;description&apos;,
        &apos;is_public&apos;,
        &apos;is_smart&apos;,
        &apos;is_collaborative&apos;,
        &apos;smart_rules&apos;,
    ];
    protected $casts = [
        &apos;smart_rules&apos; =&gt; &apos;array&apos;,
    ];
    public function getRouteKeyName(): string
    {
        return &apos;public_id&apos;;
    }
    protected static function booted()
    {
        static::created(function (Playlist $playlist) {
            $playlist-&gt;statistics()-&gt;exists() || $playlist-&gt;statistics()-&gt;create();
        });
    }
    public function syncSmartPlaylist()
    {
        if (!$this-&gt;is_smart) {
            return;
        }
        $service = app(SmartPlaylistService::class);
        $songs = $service-&gt;getSongsForRules($this-&gt;smart_rules);
        $this-&gt;songs()-&gt;sync(
            $songs-&gt;mapWithKeys(function ($song, $index) {
                return [$song-&gt;id =&gt; [&apos;position&apos; =&gt; $index + 1]];
            }),
        );
    }
    public function statistics()
    {
        return $this-&gt;hasOne(PlaylistStatistic::class);
    }
    public function incrementViews()
    {
        $this-&gt;statistics()-&gt;increment(&apos;views&apos;);
    }
    public function incrementPlays()
    {
        $this-&gt;statistics()-&gt;increment(&apos;plays&apos;);
    }
    public function incrementShares()
    {
        $this-&gt;statistics()-&gt;increment(&apos;shares&apos;);
    }
    public function incrementFavorites()
    {
        $this-&gt;statistics()-&gt;increment(&apos;favorites&apos;);
    }
    public function collaborators()
    {
        return $this-&gt;belongsToMany(User::class, &apos;playlist_collaborator&apos;)
            -&gt;using(PlaylistCollaborator::class)
            -&gt;withPivot(&apos;role&apos;)
            -&gt;withTimestamps();
    }
    public function isCollaborator(User $user)
    {
        return $this-&gt;collaborators()-&gt;where(&apos;user_id&apos;, $user-&gt;id)-&gt;exists();
    }
    public function canEdit(User $user)
    {
        return $this-&gt;user_id === $user-&gt;id ||
            $this-&gt;collaborators()-&gt;where(&apos;user_id&apos;, $user-&gt;id)
                -&gt;where(&apos;role&apos;, &apos;editor&apos;)
                -&gt;exists();
    }
    public function canAddSongs(User $user)
    {
        return $this-&gt;user_id === $user-&gt;id ||
            $this-&gt;is_collaborative ||
            $this-&gt;collaborators()-&gt;where(&apos;user_id&apos;, $user-&gt;id)-&gt;exists();
    }
    public function user()
    {
        return $this-&gt;belongsTo(User::class);
    }
    public function cover(): MorphOne
    {
        return $this-&gt;morphOne(Image::class, &apos;imageable&apos;);
    }
    public function songs()
    {
        return $this-&gt;belongsToMany(Song::class, &apos;playlist_song&apos;)
            -&gt;using(PlaylistSong::class)
            -&gt;withPivot(&apos;position&apos;)
            -&gt;orderBy(&apos;position&apos;);
    }
}</file><file path="app/Modules/OpenApi/JsonPaginatorExtension.php">&lt;?php
namespace App\Modules\OpenApi;
use App\Modules\Pagination\JsonPaginator;
use Dedoc\Scramble\Extensions\TypeToSchemaExtension;
use Dedoc\Scramble\Support\Generator\{Response, Schema};
use Dedoc\Scramble\Support\Generator\Types\{ArrayType, IntegerType, ObjectType as OpenApiObjectType};
use Dedoc\Scramble\Support\Type\{Generic, ObjectType, Type};
use Illuminate\Database\Eloquent\Model;
use Illuminate\Http\Resources\Json\JsonResource;
class JsonPaginatorExtension extends TypeToSchemaExtension
{
    public function shouldHandle(Type $type)
    {
        return $type instanceof Generic
            &amp;&amp; $type-&gt;name === JsonPaginator::class
            &amp;&amp; count($type-&gt;templateTypes) === 1
            &amp;&amp; $type-&gt;templateTypes[0] instanceof ObjectType;
    }
    public function toResponse(Type $type)
    {
        $collectingClassType = $type-&gt;templateTypes[0];
        if (!$collectingClassType-&gt;isInstanceOf(JsonResource::class) &amp;&amp; !$collectingClassType-&gt;isInstanceOf(Model::class)) {
            return null;
        }
        if (!($collectingType = $this-&gt;openApiTransformer-&gt;transform($collectingClassType))) {
            return null;
        }
        $type = new OpenApiObjectType;
        $type-&gt;addProperty(&apos;data&apos;, (new ArrayType)-&gt;setItems($collectingType))
            -&gt;addProperty(&apos;total&apos;, (new IntegerType)-&gt;setDescription(&apos;Total number of items being paginated.&apos;))
            -&gt;addProperty(&apos;count&apos;, (new IntegerType)-&gt;setDescription(&apos;The number of items for the current page&apos;))
            -&gt;addProperty(&apos;limit&apos;, (new IntegerType)-&gt;setDescription(&apos;The number of items per page&apos;))
            -&gt;addProperty(&apos;currentPage&apos;, (new IntegerType)-&gt;setDescription(&apos;The number of current page&apos;))
            -&gt;addProperty(&apos;nextPage&apos;, (new IntegerType)-&gt;setDescription(&apos;The number of next page&apos;))
            -&gt;addProperty(&apos;lastPage&apos;, (new IntegerType)-&gt;setDescription(&apos;The number of last page&apos;));
        $type-&gt;setRequired([
            &apos;data&apos;,
            &apos;total&apos;,
            &apos;count&apos;,
            &apos;limit&apos;,
            &apos;currentPage&apos;,
            &apos;nextPage&apos;,
            &apos;lastPage&apos;,
        ]);
        return Response::make(200)
            -&gt;description(&apos;Json paginated set of `&apos; . $this-&gt;components-&gt;uniqueSchemaName($collectingClassType-&gt;name) . &apos;`&apos;)
            -&gt;setContent(&apos;application/json&apos;, Schema::fromType($type));
    }
}</file><file path="app/Octane/EmergencyWorker.php">&lt;?php
namespace App\Octane;
use Closure;
use Illuminate\Http\Request;
use Laravel\Octane\Contracts\Client;
use Laravel\Octane\Contracts\Worker;
use Laravel\Octane\OctaneResponse;
use Laravel\Octane\RequestContext;
use Symfony\Component\HttpFoundation\Response;
use Throwable;
use Whoops\Handler\PlainTextHandler;
use Whoops\Run;
class EmergencyWorker implements Worker
{
    protected Run $whoops;
    public function __construct(
        protected Client    $client,
        protected Throwable $exception,
        protected array     $serverState,
    )
    {
        $this-&gt;whoops = new Run();
        $this-&gt;whoops-&gt;allowQuit(false);
        $this-&gt;whoops-&gt;writeToOutput(false);
        $this-&gt;whoops-&gt;pushHandler(new PlainTextHandler());
    }
    public function handle(Request $request, RequestContext $context): void
    {
        $response = new Response();
        $response-&gt;setStatusCode(500);
        $response-&gt;headers-&gt;add([&apos;Content-Type&apos; =&gt; &apos;text/plain&apos;]);
        if ($this-&gt;showError()) {
            $response-&gt;setContent($this-&gt;whoops-&gt;handleException($this-&gt;exception));
        } else {
            $response-&gt;setContent(&apos;Server error.&apos;);
        }
        $this-&gt;client-&gt;respond($context, new OctaneResponse($response));
    }
    private function showError(): bool
    {
        return $this-&gt;serverState[&apos;octaneConfig&apos;][&apos;swoole&apos;][&apos;show_fatal_error&apos;] ?? false;
    }
    public function boot(): void
    {
    }
    public function handleTask($data)
    {
    }
    public function terminate(): void
    {
    }
    public function handleTick(): void
    {
    }
    public function onRequestHandled(Closure $callback): self
    {
        return $this;
    }
}</file><file path="app/Octane/OnWorkerStart.php">&lt;?php
namespace App\Octane;
use Laravel\Octane\ApplicationFactory;
use Laravel\Octane\Contracts\Worker as WorkerContract;
use Laravel\Octane\Stream;
use Laravel\Octane\Swoole\Handlers\OnWorkerStart as OriginalOnWorkerStart;
use Laravel\Octane\Swoole\SwooleClient;
use Laravel\Octane\Swoole\WorkerState;
use Laravel\Octane\Worker;
use Swoole\Http\Server;
use Throwable;
class OnWorkerStart extends OriginalOnWorkerStart
{
    protected function bootWorker($server): WorkerContract
    {
        $this-&gt;workerState-&gt;client = new SwooleClient();
        try {
            $worker = new Worker(
                new ApplicationFactory($this-&gt;basePath),
                $this-&gt;workerState-&gt;client,
            );
            $worker-&gt;boot([
                &apos;octane.cacheTable&apos; =&gt; $this-&gt;workerState-&gt;cacheTable,
                Server::class       =&gt; $server,
                WorkerState::class  =&gt; $this-&gt;workerState,
            ]);
            return $worker;
        } catch (Throwable $e) {
            Stream::throwable($e);
            return new EmergencyWorker($this-&gt;workerState-&gt;client, $e, $this-&gt;serverState);
        }
    }
}</file><file path="config/cache.php">&lt;?php
use Illuminate\Support\Str;
return [
    /*
    |--------------------------------------------------------------------------
    | Default Cache Store
    |--------------------------------------------------------------------------
    |
    | This option controls the default cache connection that gets used while
    | using this caching library. This connection is used when another is
    | not explicitly specified when executing a given caching function.
    |
    */
    &apos;default&apos; =&gt; env(&apos;CACHE_DRIVER&apos;, &apos;file&apos;),
    /*
    |--------------------------------------------------------------------------
    | Cache Stores
    |--------------------------------------------------------------------------
    |
    | Here you may define all of the cache &quot;stores&quot; for your application as
    | well as their drivers. You may even define multiple stores for the
    | same cache driver to group types of items stored in your caches.
    |
    | Supported drivers: &quot;apc&quot;, &quot;array&quot;, &quot;database&quot;, &quot;file&quot;,
    |         &quot;memcached&quot;, &quot;redis&quot;, &quot;dynamodb&quot;, &quot;octane&quot;, &quot;null&quot;
    |
    */
    &apos;stores&apos; =&gt; [
        &apos;apc&apos; =&gt; [
            &apos;driver&apos; =&gt; &apos;apc&apos;,
        ],
        &apos;array&apos; =&gt; [
            &apos;driver&apos;    =&gt; &apos;array&apos;,
            &apos;serialize&apos; =&gt; false,
        ],
        &apos;database&apos; =&gt; [
            &apos;driver&apos;          =&gt; &apos;database&apos;,
            &apos;table&apos;           =&gt; &apos;cache&apos;,
            &apos;connection&apos;      =&gt; null,
            &apos;lock_connection&apos; =&gt; null,
        ],
        &apos;file&apos; =&gt; [
            &apos;driver&apos;    =&gt; &apos;file&apos;,
            &apos;path&apos;      =&gt; storage_path(&apos;framework/cache/data&apos;),
            &apos;lock_path&apos; =&gt; storage_path(&apos;framework/cache/data&apos;),
        ],
        &apos;redis&apos; =&gt; [
            &apos;driver&apos;          =&gt; &apos;redis&apos;,
            &apos;connection&apos;      =&gt; &apos;cache&apos;,
            &apos;lock_connection&apos; =&gt; &apos;default&apos;,
        ],
        &apos;redis-secret&apos; =&gt; [
            &apos;driver&apos;        =&gt; &apos;redis&apos;,
            &apos;connection&apos;    =&gt; &apos;secret&apos;,
            &apos;lock_connection&apos; =&gt; &apos;default&apos;,
        ],
        &apos;sanctum&apos; =&gt; [
            &apos;driver&apos; =&gt; &apos;redis&apos;,
            &apos;connection&apos; =&gt; &apos;sanctum&apos;,
            &apos;lock_connection&apos; =&gt; &apos;sanctum&apos;,
        ],
        &apos;octane&apos; =&gt; [
            &apos;driver&apos; =&gt; &apos;octane&apos;,
        ],
    ],
    /*
    |--------------------------------------------------------------------------
    | Cache Key Prefix
    |--------------------------------------------------------------------------
    |
    | When utilizing the APC, database, memcached, Redis, or DynamoDB cache
    | stores there might be other applications using the same cache. For
    | that reason, you may prefix every cache key to avoid collisions.
    |
    */
    &apos;prefix&apos; =&gt; env(&apos;CACHE_PREFIX&apos;, &apos;_b_cache_&apos;),
];</file><file path="config/cors.php">&lt;?php
$config = [
    /*
    |--------------------------------------------------------------------------
    | Cross-Origin Resource Sharing (CORS) Configuration
    |--------------------------------------------------------------------------
    |
    | Here you may configure your settings for cross-origin resource sharing
    | or &quot;CORS&quot;. This determines what cross-origin operations may execute
    | in web browsers. You are free to adjust these settings as needed.
    |
    | To learn more: https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS
    |
    */
    &apos;paths&apos; =&gt; [&apos;api/*&apos;, &apos;sanctum/csrf-cookie&apos;],
    &apos;allowed_methods&apos; =&gt; [&apos;*&apos;],
    &apos;allowed_origins&apos; =&gt; [],
    &apos;allowed_origins_patterns&apos; =&gt; [],
    &apos;allowed_headers&apos; =&gt; [&apos;*&apos;],
    &apos;exposed_headers&apos; =&gt; [],
    &apos;max_age&apos; =&gt; 0,
    &apos;supports_credentials&apos; =&gt; false,
];
if (env(&apos;APP_ENV&apos;) === &apos;local&apos; || env(&apos;APP_ENV&apos;) === &apos;testing&apos;) {
    $config[&apos;allowed_origins&apos;][] = &apos;*&apos;;
} else {
    $config[&apos;allowed_origins&apos;][] = env(&apos;APP_URL&apos;);
}
return $config;</file><file path="config/sanctum.php">&lt;?php
use Laravel\Sanctum\Sanctum;
return [
    /*
    |--------------------------------------------------------------------------
    | Stateful Domains
    |--------------------------------------------------------------------------
    |
    | Requests from the following domains / hosts will receive stateful API
    | authentication cookies. Typically, these should include your local
    | and production domains which access your API via a frontend SPA.
    |
    */
    &apos;stateful&apos; =&gt; explode(&apos;,&apos;, env(&apos;SANCTUM_STATEFUL_DOMAINS&apos;, sprintf(
        &apos;%s%s&apos;,
        &apos;localhost,localhost:3000,127.0.0.1,127.0.0.1:8000,::1&apos;,
        Sanctum::currentApplicationUrlWithPort()
    ))),
    /*
    |--------------------------------------------------------------------------
    | Sanctum Guards
    |--------------------------------------------------------------------------
    |
    | This array contains the authentication guards that will be checked when
    | Sanctum is trying to authenticate a request. If none of these guards
    | are able to authenticate the request, Sanctum will use the bearer
    | token that&apos;s present on an incoming request for authentication.
    |
    */
    &apos;guard&apos; =&gt; [&apos;web&apos;],
    /*
    |--------------------------------------------------------------------------
    | Expiration Minutes
    |--------------------------------------------------------------------------
    |
    | This value controls the number of minutes until an issued token will be
    | considered expired. This will override any values set in the token&apos;s
    | &quot;expires_at&quot; attribute, but first-party sessions are not affected.
    |
    */
    &apos;expiration&apos;               =&gt; null,
    &apos;access_token_expiration&apos;  =&gt; 60, // One hour
    &apos;refresh_token_expiration&apos; =&gt; 7 * 24 * 60, // 7 days
    &apos;stream_token_expiration&apos; =&gt; 24 * 60, // 1 day
    /*
    |--------------------------------------------------------------------------
    | Token Prefix
    |--------------------------------------------------------------------------
    |
    | Sanctum can prefix new tokens in order to take advantage of numerous
    | security scanning initiatives maintained by open source platforms
    | that notify developers if they commit tokens into repositories.
    |
    | See: https://docs.github.com/en/code-security/secret-scanning/about-secret-scanning
    |
    */
    &apos;token_prefix&apos; =&gt; env(&apos;SANCTUM_TOKEN_PREFIX&apos;, &apos;baander_token&apos;),
    /*
    |--------------------------------------------------------------------------
    | Sanctum Middleware
    |--------------------------------------------------------------------------
    |
    | When authenticating your first-party SPA with Sanctum you may need to
    | customize some of the middleware Sanctum uses while processing the
    | request. You may change the middleware listed below as required.
    |
    */
    &apos;middleware&apos; =&gt; [
        &apos;authenticate_session&apos; =&gt; Laravel\Sanctum\Http\Middleware\AuthenticateSession::class,
        &apos;encrypt_cookies&apos;      =&gt; Illuminate\Cookie\Middleware\EncryptCookies::class,
        &apos;validate_csrf_token&apos;  =&gt; Illuminate\Foundation\Http\Middleware\ValidateCsrfToken::class,
    ],
    /*
    |--------------------------------------------------------------------------
    | Redis Configuration
    |--------------------------------------------------------------------------
    */
    &apos;token_cache&apos; =&gt; [
        &apos;enabled&apos; =&gt; env(&apos;SANCTUM_REDIS_ENABLED&apos;, true),
        &apos;store&apos; =&gt; env(&apos;SANCTUM_CACHE_STORE&apos;, &apos;redis&apos;),
        &apos;prefix&apos; =&gt; env(&apos;SANCTUM_CACHE_PREFIX&apos;, &apos;sanctum_token:&apos;),
        &apos;ttl&apos; =&gt; (int) env(&apos;SANCTUM_CACHE_TTL&apos;, 1440), // Default 24 hours (1440 minutes)
    ],
    /*
    |--------------------------------------------------------------------------
    | Token Invalidation on Logout
    |--------------------------------------------------------------------------
    */
    &apos;invalidate_on_logout&apos; =&gt; (bool) env(&apos;SANCTUM_INVALIDATE_ON_LOGOUT&apos;, true),
];</file><file path="config/services.php">&lt;?php
return [
    &apos;ffmpeg&apos;    =&gt; [
        &apos;bin&apos; =&gt; [
            &apos;ffmpeg&apos;  =&gt; env(&apos;FFMPEG_BIN&apos;, &apos;/usr/bin/ffmpeg&apos;),
            &apos;ffprobe&apos; =&gt; env(&apos;FFPROBE_BIN&apos;, &apos;/usr/bin/ffprobe&apos;),
        ],
    ],
    &apos;tastedive&apos; =&gt; [
        &apos;api_key&apos; =&gt; env(&apos;TASTE_DIVE_API_KEY&apos;),
    ],
    &apos;discogs&apos; =&gt; [
        &apos;api_key&apos; =&gt; env(&apos;DISCOGS_API_KEY&apos;),
    ]
];</file><file path="config/webauthn.php">&lt;?php
return [
    &apos;relying_party&apos; =&gt; [
        &apos;id&apos;   =&gt; parse_url(config(&apos;app.url&apos;), PHP_URL_HOST),
        &apos;name&apos; =&gt; config(&apos;app.name&apos;),
        &apos;icon&apos; =&gt; env(&apos;WEBAUTHN_ICON&apos;),
    ],
];</file><file path="database/migrations/2018_02_05_000000_create_queue_monitor_table.php">&lt;?php
use App\Modules\QueueMonitor\MonitorStatus;
use Illuminate\Database\Migrations\Migration;
use Tpetry\PostgresqlEnhanced\Schema\Blueprint;
use Tpetry\PostgresqlEnhanced\Support\Facades\Schema;
return new class extends Migration {
    public function up()
    {
        Schema::create(&apos;queue_monitor&apos;, function (Blueprint $table) {
            $table-&gt;id(&apos;id&apos;);
            $table-&gt;uuid(&apos;job_uuid&apos;)-&gt;nullable();
            $table-&gt;text(&apos;job_id&apos;)-&gt;index();
            $table-&gt;caseInsensitiveText(&apos;name&apos;)-&gt;nullable();
            $table-&gt;text(&apos;queue&apos;)-&gt;nullable();
            $table-&gt;enum(&apos;status&apos;, MonitorStatus::values())-&gt;default(MonitorStatus::Running)-&gt;after(&apos;queue&apos;);
            $table-&gt;dateTimeTz(&apos;queued_at&apos;)-&gt;nullable();
            $table-&gt;timestampTz(&apos;started_at&apos;)-&gt;nullable()-&gt;index();
            $table-&gt;text(&apos;started_at_exact&apos;)-&gt;nullable();
            $table-&gt;timestampTz(&apos;finished_at&apos;)-&gt;nullable();
            $table-&gt;text(&apos;finished_at_exact&apos;)-&gt;nullable();
            $table-&gt;integer(&apos;attempt&apos;)-&gt;default(0);
            $table-&gt;boolean(&apos;retried&apos;)-&gt;default(false);
            $table-&gt;integer(&apos;progress&apos;)-&gt;nullable();
            $table-&gt;jsonb(&apos;exception&apos;)-&gt;nullable();
            $table-&gt;text(&apos;exception_class&apos;)-&gt;nullable();
            $table-&gt;text(&apos;data&apos;)-&gt;nullable();
        });
    }
    public function down()
    {
        Schema::drop(config(&apos;queue-monitor.table&apos;));
    }
};</file><file path="database/migrations/2024_04_07_122724_create_genres_table.php">&lt;?php
use Illuminate\Database\Migrations\Migration;
use Tpetry\PostgresqlEnhanced\Schema\Blueprint;
use Tpetry\PostgresqlEnhanced\Support\Facades\Schema;
return new class extends Migration
{
    /**
     * Run the migrations.
     */
    public function up(): void
    {
        Schema::create(&apos;genres&apos;, function (Blueprint $table) {
            $table-&gt;id();
            $table-&gt;bigInteger(&apos;parent_id&apos;)-&gt;nullable();
            $table-&gt;caseInsensitiveText(&apos;name&apos;)-&gt;index();
            $table-&gt;text(&apos;slug&apos;)-&gt;unique();
            $table-&gt;timestampsTz();
        });
    }
    /**
     * Reverse the migrations.
     */
    public function down(): void
    {
        Schema::dropIfExists(&apos;genres&apos;);
    }
};</file><file path="docker/dev/php.ini">[PHP]

;;;;;;;;;;;;;;;;;;;
; About php.ini   ;
;;;;;;;;;;;;;;;;;;;
; PHP&apos;s initialization file, generally called php.ini, is responsible for
; configuring many of the aspects of PHP&apos;s behavior.

; PHP attempts to find and load this configuration from a number of locations.
; The following is a summary of its search order:
; 1. SAPI module specific location.
; 2. The PHPRC environment variable.
; 3. A number of predefined registry keys on Windows
; 4. Current working directory (except CLI)
; 5. The web server&apos;s directory (for SAPI modules), or directory of PHP
; (otherwise in Windows)
; 6. The directory from the --with-config-file-path compile time option, or the
; Windows directory (usually C:\windows)
; See the PHP docs for more specific information.
; https://php.net/configuration.file

; The syntax of the file is extremely simple.  Whitespace and lines
; beginning with a semicolon are silently ignored (as you probably guessed).
; Section headers (e.g. [Foo]) are also silently ignored, even though
; they might mean something in the future.

; Directives following the section heading [PATH=/www/mysite] only
; apply to PHP files in the /www/mysite directory.  Directives
; following the section heading [HOST=www.example.com] only apply to
; PHP files served from www.example.com.  Directives set in these
; special sections cannot be overridden by user-defined INI files or
; at runtime. Currently, [PATH=] and [HOST=] sections only work under
; CGI/FastCGI.
; https://php.net/ini.sections

; Directives are specified using the following syntax:
; directive = value
; Directive names are *case sensitive* - foo=bar is different from FOO=bar.
; Directives are variables used to configure PHP or PHP extensions.
; There is no name validation.  If PHP can&apos;t find an expected
; directive because it is not set or is mistyped, a default value will be used.

; The value can be a string, a number, a PHP constant (e.g. E_ALL or M_PI), one
; of the INI constants (On, Off, True, False, Yes, No and None) or an expression
; (e.g. E_ALL &amp; ~E_NOTICE), a quoted string (&quot;bar&quot;), or a reference to a
; previously set variable or directive (e.g. ${foo})

; Expressions in the INI file are limited to bitwise operators and parentheses:
; |  bitwise OR
; ^  bitwise XOR
; &amp;  bitwise AND
; ~  bitwise NOT
; !  boolean NOT

; Boolean flags can be turned on using the values 1, On, True or Yes.
; They can be turned off using the values 0, Off, False or No.

; An empty string can be denoted by simply not writing anything after the equal
; sign, or by using the None keyword:

; foo =         ; sets foo to an empty string
; foo = None    ; sets foo to an empty string
; foo = &quot;None&quot;  ; sets foo to the string &apos;None&apos;

; If you use constants in your value, and these constants belong to a
; dynamically loaded extension (either a PHP extension or a Zend extension),
; you may only use these constants *after* the line that loads the extension.

;;;;;;;;;;;;;;;;;;;
; About this file ;
;;;;;;;;;;;;;;;;;;;
; PHP comes packaged with two INI files. One that is recommended to be used
; in production environments and one that is recommended to be used in
; development environments.

; php.ini-production contains settings which hold security, performance and
; best practices at its core. But please be aware, these settings may break
; compatibility with older or less security-conscious applications. We
; recommending using the production ini in production and testing environments.

; php.ini-development is very similar to its production variant, except it is
; much more verbose when it comes to errors. We recommend using the
; development version only in development environments, as errors shown to
; application users can inadvertently leak otherwise secure information.

; This is the php.ini-development INI file.

;;;;;;;;;;;;;;;;;;;
; Quick Reference ;
;;;;;;;;;;;;;;;;;;;

; The following are all the settings which are different in either the production
; or development versions of the INIs with respect to PHP&apos;s default behavior.
; Please see the actual settings later in the document for more details as to why
; we recommend these changes in PHP&apos;s behavior.

; display_errors
;   Default Value: On
;   Development Value: On
;   Production Value: Off

; display_startup_errors
;   Default Value: On
;   Development Value: On
;   Production Value: Off

; error_reporting
;   Default Value: E_ALL
;   Development Value: E_ALL
;   Production Value: E_ALL &amp; ~E_DEPRECATED &amp; ~E_STRICT

; log_errors
;   Default Value: Off
;   Development Value: On
;   Production Value: On

; max_input_time
;   Default Value: -1 (Unlimited)
;   Development Value: 60 (60 seconds)
;   Production Value: 60 (60 seconds)

; output_buffering
;   Default Value: Off
;   Development Value: 4096
;   Production Value: 4096

; register_argc_argv
;   Default Value: On
;   Development Value: Off
;   Production Value: Off

; request_order
;   Default Value: None
;   Development Value: &quot;GP&quot;
;   Production Value: &quot;GP&quot;

; session.gc_divisor
;   Default Value: 100
;   Development Value: 1000
;   Production Value: 1000

; session.sid_bits_per_character
;   Default Value: 4
;   Development Value: 5
;   Production Value: 5

; session.sid_length
;   Default Value: 32
;   Development Value: 26
;   Production Value: 26

; short_open_tag
;   Default Value: On
;   Development Value: Off
;   Production Value: Off

; variables_order
;   Default Value: &quot;EGPCS&quot;
;   Development Value: &quot;GPCS&quot;
;   Production Value: &quot;GPCS&quot;

; zend.assertions
;   Default Value: 1
;   Development Value: 1
;   Production Value: -1

; zend.exception_ignore_args
;   Default Value: Off
;   Development Value: Off
;   Production Value: On

; zend.exception_string_param_max_len
;   Default Value: 15
;   Development Value: 15
;   Production Value: 0

;;;;;;;;;;;;;;;;;;;;
; php.ini Options  ;
;;;;;;;;;;;;;;;;;;;;
; Name for user-defined php.ini (.htaccess) files. Default is &quot;.user.ini&quot;
;user_ini.filename = &quot;.user.ini&quot;

; To disable this feature set this option to an empty value
;user_ini.filename =

; TTL for user-defined php.ini files (time-to-live) in seconds. Default is 300 seconds (5 minutes)
;user_ini.cache_ttl = 300

;;;;;;;;;;;;;;;;;;;;
; Language Options ;
;;;;;;;;;;;;;;;;;;;;

; Enable the PHP scripting language engine under Apache.
; https://php.net/engine
engine = On

; This directive determines whether or not PHP will recognize code between
; &lt;? and ?&gt; tags as PHP source which should be processed as such. It is
; generally recommended that &lt;?php and ?&gt; should be used and that this feature
; should be disabled, as enabling it may result in issues when generating XML
; documents, however this remains supported for backward compatibility reasons.
; Note that this directive does not control the &lt;?= shorthand tag, which can be
; used regardless of this directive.
; Default Value: On
; Development Value: Off
; Production Value: Off
; https://php.net/short-open-tag
short_open_tag = Off

; The number of significant digits displayed in floating point numbers.
; https://php.net/precision
precision = 14

; Output buffering is a mechanism for controlling how much output data
; (excluding headers and cookies) PHP should keep internally before pushing that
; data to the client. If your application&apos;s output exceeds this setting, PHP
; will send that data in chunks of roughly the size you specify.
; Turning on this setting and managing its maximum buffer size can yield some
; interesting side-effects depending on your application and web server.
; You may be able to send headers and cookies after you&apos;ve already sent output
; through print or echo. You also may see performance benefits if your server is
; emitting less packets due to buffered output versus PHP streaming the output
; as it gets it. On production servers, 4096 bytes is a good setting for performance
; reasons.
; Note: Output buffering can also be controlled via Output Buffering Control
;   functions.
; Possible Values:
;   On = Enabled and buffer is unlimited. (Use with caution)
;   Off = Disabled
;   Integer = Enables the buffer and sets its maximum size in bytes.
; Note: This directive is hardcoded to Off for the CLI SAPI
; Default Value: Off
; Development Value: 4096
; Production Value: 4096
; https://php.net/output-buffering
output_buffering = 4096

; You can redirect all of the output of your scripts to a function.  For
; example, if you set output_handler to &quot;mb_output_handler&quot;, character
; encoding will be transparently converted to the specified encoding.
; Setting any output handler automatically turns on output buffering.
; Note: People who wrote portable scripts should not depend on this ini
;   directive. Instead, explicitly set the output handler using ob_start().
;   Using this ini directive may cause problems unless you know what script
;   is doing.
; Note: You cannot use both &quot;mb_output_handler&quot; with &quot;ob_iconv_handler&quot;
;   and you cannot use both &quot;ob_gzhandler&quot; and &quot;zlib.output_compression&quot;.
; Note: output_handler must be empty if this is set &apos;On&apos; !!!!
;   Instead you must use zlib.output_handler.
; https://php.net/output-handler
;output_handler =

; URL rewriter function rewrites URL on the fly by using
; output buffer. You can set target tags by this configuration.
; &quot;form&quot; tag is special tag. It will add hidden input tag to pass values.
; Refer to session.trans_sid_tags for usage.
; Default Value: &quot;form=&quot;
; Development Value: &quot;form=&quot;
; Production Value: &quot;form=&quot;
;url_rewriter.tags

; URL rewriter will not rewrite absolute URL nor form by default. To enable
; absolute URL rewrite, allowed hosts must be defined at RUNTIME.
; Refer to session.trans_sid_hosts for more details.
; Default Value: &quot;&quot;
; Development Value: &quot;&quot;
; Production Value: &quot;&quot;
;url_rewriter.hosts

; Transparent output compression using the zlib library
; Valid values for this option are &apos;off&apos;, &apos;on&apos;, or a specific buffer size
; to be used for compression (default is 4KB)
; Note: Resulting chunk size may vary due to nature of compression. PHP
;   outputs chunks that are few hundreds bytes each as a result of
;   compression. If you prefer a larger chunk size for better
;   performance, enable output_buffering in addition.
; Note: You need to use zlib.output_handler instead of the standard
;   output_handler, or otherwise the output will be corrupted.
; https://php.net/zlib.output-compression
zlib.output_compression = Off

; https://php.net/zlib.output-compression-level
;zlib.output_compression_level = -1

; You cannot specify additional output handlers if zlib.output_compression
; is activated here. This setting does the same as output_handler but in
; a different order.
; https://php.net/zlib.output-handler
;zlib.output_handler =

; Implicit flush tells PHP to tell the output layer to flush itself
; automatically after every output block.  This is equivalent to calling the
; PHP function flush() after each and every call to print() or echo() and each
; and every HTML block.  Turning this option on has serious performance
; implications and is generally recommended for debugging purposes only.
; https://php.net/implicit-flush
; Note: This directive is hardcoded to On for the CLI SAPI
implicit_flush = Off

; The unserialize callback function will be called (with the undefined class&apos;
; name as parameter), if the unserializer finds an undefined class
; which should be instantiated. A warning appears if the specified function is
; not defined, or if the function doesn&apos;t include/implement the missing class.
; So only set this entry, if you really want to implement such a
; callback-function.
unserialize_callback_func =

; The unserialize_max_depth specifies the default depth limit for unserialized
; structures. Setting the depth limit too high may result in stack overflows
; during unserialization. The unserialize_max_depth ini setting can be
; overridden by the max_depth option on individual unserialize() calls.
; A value of 0 disables the depth limit.
;unserialize_max_depth = 4096

; When floats &amp; doubles are serialized, store serialize_precision significant
; digits after the floating point. The default value ensures that when floats
; are decoded with unserialize, the data will remain the same.
; The value is also used for json_encode when encoding double values.
; If -1 is used, then dtoa mode 0 is used which automatically select the best
; precision.
serialize_precision = -1

; open_basedir, if set, limits all file operations to the defined directory
; and below.  This directive makes most sense if used in a per-directory
; or per-virtualhost web server configuration file.
; Note: disables the realpath cache
; https://php.net/open-basedir
;open_basedir =

; This directive allows you to disable certain functions.
; It receives a comma-delimited list of function names.
; https://php.net/disable-functions
disable_functions =

; This directive allows you to disable certain classes.
; It receives a comma-delimited list of class names.
; https://php.net/disable-classes
disable_classes =

; Colors for Syntax Highlighting mode.  Anything that&apos;s acceptable in
; &lt;span style=&quot;color: ???????&quot;&gt; would work.
; https://php.net/syntax-highlighting
;highlight.string  = #DD0000
;highlight.comment = #FF9900
;highlight.keyword = #007700
;highlight.default = #0000BB
;highlight.html    = #000000

; If enabled, the request will be allowed to complete even if the user aborts
; the request. Consider enabling it if executing long requests, which may end up
; being interrupted by the user or a browser timing out. PHP&apos;s default behavior
; is to disable this feature.
; https://php.net/ignore-user-abort
;ignore_user_abort = On

; Determines the size of the realpath cache to be used by PHP. This value should
; be increased on systems where PHP opens many files to reflect the quantity of
; the file operations performed.
; Note: if open_basedir is set, the cache is disabled
; https://php.net/realpath-cache-size
;realpath_cache_size = 4096k

; Duration of time, in seconds for which to cache realpath information for a given
; file or directory. For systems with rarely changing files, consider increasing this
; value.
; https://php.net/realpath-cache-ttl
;realpath_cache_ttl = 120

; Enables or disables the circular reference collector.
; https://php.net/zend.enable-gc
zend.enable_gc = On

; If enabled, scripts may be written in encodings that are incompatible with
; the scanner.  CP936, Big5, CP949 and Shift_JIS are the examples of such
; encodings.  To use this feature, mbstring extension must be enabled.
;zend.multibyte = Off

; Allows to set the default encoding for the scripts.  This value will be used
; unless &quot;declare(encoding=...)&quot; directive appears at the top of the script.
; Only affects if zend.multibyte is set.
;zend.script_encoding =

; Allows to include or exclude arguments from stack traces generated for exceptions.
; In production, it is recommended to turn this setting on to prohibit the output
; of sensitive information in stack traces
; Default Value: Off
; Development Value: Off
; Production Value: On
zend.exception_ignore_args = Off

; Allows setting the maximum string length in an argument of a stringified stack trace
; to a value between 0 and 1000000.
; This has no effect when zend.exception_ignore_args is enabled.
; Default Value: 15
; Development Value: 15
; Production Value: 0
zend.exception_string_param_max_len = 15

;;;;;;;;;;;;;;;;;
; Miscellaneous ;
;;;;;;;;;;;;;;;;;

; Decides whether PHP may expose the fact that it is installed on the server
; (e.g. by adding its signature to the Web server header).  It is no security
; threat in any way, but it makes it possible to determine whether you use PHP
; on your server or not.
; https://php.net/expose-php
expose_php = On

;;;;;;;;;;;;;;;;;;;
; Resource Limits ;
;;;;;;;;;;;;;;;;;;;

; Maximum execution time of each script, in seconds
; https://php.net/max-execution-time
; Note: This directive is hardcoded to 0 for the CLI SAPI
max_execution_time = 300

; Maximum amount of time each script may spend parsing request data. It&apos;s a good
; idea to limit this time on productions servers in order to eliminate unexpectedly
; long running scripts.
; Note: This directive is hardcoded to -1 for the CLI SAPI
; Default Value: -1 (Unlimited)
; Development Value: 60 (60 seconds)
; Production Value: 60 (60 seconds)
; https://php.net/max-input-time
max_input_time = 60

; Maximum input variable nesting level
; https://php.net/max-input-nesting-level
;max_input_nesting_level = 64

; How many GET/POST/COOKIE input variables may be accepted
;max_input_vars = 1000

; How many multipart body parts (combined input variable and file uploads) may
; be accepted.
; Default Value: -1 (Sum of max_input_vars and max_file_uploads)
;max_multipart_body_parts = 1500

; Maximum amount of memory a script may consume
; https://php.net/memory-limit
memory_limit = 2048M

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Error handling and logging ;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; This directive informs PHP of which errors, warnings and notices you would like
; it to take action for. The recommended way of setting values for this
; directive is through the use of the error level constants and bitwise
; operators. The error level constants are below here for convenience as well as
; some common settings and their meanings.
; By default, PHP is set to take action on all errors, notices and warnings EXCEPT
; those related to E_NOTICE and E_STRICT, which together cover best practices and
; recommended coding standards in PHP. For performance reasons, this is the
; recommend error reporting setting. Your production server shouldn&apos;t be wasting
; resources complaining about best practices and coding standards. That&apos;s what
; development servers and development settings are for.
; Note: The php.ini-development file has this setting as E_ALL. This
; means it pretty much reports everything which is exactly what you want during
; development and early testing.
;
; Error Level Constants:
; E_ALL             - All errors and warnings
; E_ERROR           - fatal run-time errors
; E_RECOVERABLE_ERROR  - almost fatal run-time errors
; E_WARNING         - run-time warnings (non-fatal errors)
; E_PARSE           - compile-time parse errors
; E_NOTICE          - run-time notices (these are warnings which often result
;                     from a bug in your code, but it&apos;s possible that it was
;                     intentional (e.g., using an uninitialized variable and
;                     relying on the fact it is automatically initialized to an
;                     empty string)
; E_STRICT          - run-time notices, enable to have PHP suggest changes
;                     to your code which will ensure the best interoperability
;                     and forward compatibility of your code
; E_CORE_ERROR      - fatal errors that occur during PHP&apos;s initial startup
; E_CORE_WARNING    - warnings (non-fatal errors) that occur during PHP&apos;s
;                     initial startup
; E_COMPILE_ERROR   - fatal compile-time errors
; E_COMPILE_WARNING - compile-time warnings (non-fatal errors)
; E_USER_ERROR      - user-generated error message
; E_USER_WARNING    - user-generated warning message
; E_USER_NOTICE     - user-generated notice message
; E_DEPRECATED      - warn about code that will not work in future versions
;                     of PHP
; E_USER_DEPRECATED - user-generated deprecation warnings
;
; Common Values:
;   E_ALL (Show all errors, warnings and notices including coding standards.)
;   E_ALL &amp; ~E_NOTICE  (Show all errors, except for notices)
;   E_ALL &amp; ~E_NOTICE &amp; ~E_STRICT  (Show all errors, except for notices and coding standards warnings.)
;   E_COMPILE_ERROR|E_RECOVERABLE_ERROR|E_ERROR|E_CORE_ERROR  (Show only errors)
; Default Value: E_ALL
; Development Value: E_ALL
; Production Value: E_ALL &amp; ~E_DEPRECATED &amp; ~E_STRICT
; https://php.net/error-reporting
error_reporting = E_ALL

; This directive controls whether or not and where PHP will output errors,
; notices and warnings too. Error output is very useful during development, but
; it could be very dangerous in production environments. Depending on the code
; which is triggering the error, sensitive information could potentially leak
; out of your application such as database usernames and passwords or worse.
; For production environments, we recommend logging errors rather than
; sending them to STDOUT.
; Possible Values:
;   Off = Do not display any errors
;   stderr = Display errors to STDERR (affects only CGI/CLI binaries!)
;   On or stdout = Display errors to STDOUT
; Default Value: On
; Development Value: On
; Production Value: Off
; https://php.net/display-errors
display_errors = On

; The display of errors which occur during PHP&apos;s startup sequence are handled
; separately from display_errors. We strongly recommend you set this to &apos;off&apos;
; for production servers to avoid leaking configuration details.
; Default Value: On
; Development Value: On
; Production Value: Off
; https://php.net/display-startup-errors
display_startup_errors = On

; Besides displaying errors, PHP can also log errors to locations such as a
; server-specific log, STDERR, or a location specified by the error_log
; directive found below. While errors should not be displayed on productions
; servers they should still be monitored and logging is a great way to do that.
; Default Value: Off
; Development Value: On
; Production Value: On
; https://php.net/log-errors
log_errors = On

; Do not log repeated messages. Repeated errors must occur in same file on same
; line unless ignore_repeated_source is set true.
; https://php.net/ignore-repeated-errors
ignore_repeated_errors = Off

; Ignore source of message when ignoring repeated messages. When this setting
; is On you will not log errors with repeated messages from different files or
; source lines.
; https://php.net/ignore-repeated-source
ignore_repeated_source = Off

; If this parameter is set to Off, then memory leaks will not be shown (on
; stdout or in the log). This is only effective in a debug compile, and if
; error reporting includes E_WARNING in the allowed list
; https://php.net/report-memleaks
report_memleaks = On

; This setting is off by default.
;report_zend_debug = 0

; Turn off normal error reporting and emit XML-RPC error XML
; https://php.net/xmlrpc-errors
;xmlrpc_errors = 0

; An XML-RPC faultCode
;xmlrpc_error_number = 0

; When PHP displays or logs an error, it has the capability of formatting the
; error message as HTML for easier reading. This directive controls whether
; the error message is formatted as HTML or not.
; Note: This directive is hardcoded to Off for the CLI SAPI
; https://php.net/html-errors
;html_errors = On

; If html_errors is set to On *and* docref_root is not empty, then PHP
; produces clickable error messages that direct to a page describing the error
; or function causing the error in detail.
; You can download a copy of the PHP manual from https://php.net/docs
; and change docref_root to the base URL of your local copy including the
; leading &apos;/&apos;. You must also specify the file extension being used including
; the dot. PHP&apos;s default behavior is to leave these settings empty, in which
; case no links to documentation are generated.
; Note: Never use this feature for production boxes.
; https://php.net/docref-root
; Examples
;docref_root = &quot;/phpmanual/&quot;

; https://php.net/docref-ext
;docref_ext = .html

; String to output before an error message. PHP&apos;s default behavior is to leave
; this setting blank.
; https://php.net/error-prepend-string
; Example:
;error_prepend_string = &quot;&lt;span style=&apos;color: #ff0000&apos;&gt;&quot;

; String to output after an error message. PHP&apos;s default behavior is to leave
; this setting blank.
; https://php.net/error-append-string
; Example:
;error_append_string = &quot;&lt;/span&gt;&quot;

; Log errors to specified file. PHP&apos;s default behavior is to leave this value
; empty.
; https://php.net/error-log
; Example:
;error_log = php_errors.log
; Log errors to syslog (Event Log on Windows).
;error_log = syslog

; The syslog ident is a string which is prepended to every message logged
; to syslog. Only used when error_log is set to syslog.
;syslog.ident = php

; The syslog facility is used to specify what type of program is logging
; the message. Only used when error_log is set to syslog.
;syslog.facility = user

; Set this to disable filtering control characters (the default).
; Some loggers only accept NVT-ASCII, others accept anything that&apos;s not
; control characters. If your logger accepts everything, then no filtering
; is needed at all.
; Allowed values are:
;   ascii (all printable ASCII characters and NL)
;   no-ctrl (all characters except control characters)
;   all (all characters)
;   raw (like &quot;all&quot;, but messages are not split at newlines)
; https://php.net/syslog.filter
;syslog.filter = ascii

;windows.show_crt_warning
; Default value: 0
; Development value: 0
; Production value: 0

;;;;;;;;;;;;;;;;;
; Data Handling ;
;;;;;;;;;;;;;;;;;

; The separator used in PHP generated URLs to separate arguments.
; PHP&apos;s default setting is &quot;&amp;&quot;.
; https://php.net/arg-separator.output
; Example:
;arg_separator.output = &quot;&amp;amp;&quot;

; List of separator(s) used by PHP to parse input URLs into variables.
; PHP&apos;s default setting is &quot;&amp;&quot;.
; NOTE: Every character in this directive is considered as separator!
; https://php.net/arg-separator.input
; Example:
;arg_separator.input = &quot;;&amp;&quot;

; This directive determines which super global arrays are registered when PHP
; starts up. G,P,C,E &amp; S are abbreviations for the following respective super
; globals: GET, POST, COOKIE, ENV and SERVER. There is a performance penalty
; paid for the registration of these arrays and because ENV is not as commonly
; used as the others, ENV is not recommended on productions servers. You
; can still get access to the environment variables through getenv() should you
; need to.
; Default Value: &quot;EGPCS&quot;
; Development Value: &quot;GPCS&quot;
; Production Value: &quot;GPCS&quot;;
; https://php.net/variables-order
variables_order = &quot;GPCS&quot;

; This directive determines which super global data (G,P &amp; C) should be
; registered into the super global array REQUEST. If so, it also determines
; the order in which that data is registered. The values for this directive
; are specified in the same manner as the variables_order directive,
; EXCEPT one. Leaving this value empty will cause PHP to use the value set
; in the variables_order directive. It does not mean it will leave the super
; globals array REQUEST empty.
; Default Value: None
; Development Value: &quot;GP&quot;
; Production Value: &quot;GP&quot;
; https://php.net/request-order
request_order = &quot;GP&quot;

; This directive determines whether PHP registers $argv &amp; $argc each time it
; runs. $argv contains an array of all the arguments passed to PHP when a script
; is invoked. $argc contains an integer representing the number of arguments
; that were passed when the script was invoked. These arrays are extremely
; useful when running scripts from the command line. When this directive is
; enabled, registering these variables consumes CPU cycles and memory each time
; a script is executed. For performance reasons, this feature should be disabled
; on production servers.
; Note: This directive is hardcoded to On for the CLI SAPI
; Default Value: On
; Development Value: Off
; Production Value: Off
; https://php.net/register-argc-argv
register_argc_argv = Off

; When enabled, the ENV, REQUEST and SERVER variables are created when they&apos;re
; first used (Just In Time) instead of when the script starts. If these
; variables are not used within a script, having this directive on will result
; in a performance gain. The PHP directive register_argc_argv must be disabled
; for this directive to have any effect.
; https://php.net/auto-globals-jit
auto_globals_jit = On

; Whether PHP will read the POST data.
; This option is enabled by default.
; Most likely, you won&apos;t want to disable this option globally. It causes $_POST
; and $_FILES to always be empty; the only way you will be able to read the
; POST data will be through the php://input stream wrapper. This can be useful
; to proxy requests or to process the POST data in a memory efficient fashion.
; https://php.net/enable-post-data-reading
;enable_post_data_reading = Off

; Maximum size of POST data that PHP will accept.
; Its value may be 0 to disable the limit. It is ignored if POST data reading
; is disabled through enable_post_data_reading.
; https://php.net/post-max-size
post_max_size = 80M

; Automatically add files before PHP document.
; https://php.net/auto-prepend-file
auto_prepend_file =

; Automatically add files after PHP document.
; https://php.net/auto-append-file
auto_append_file =

; By default, PHP will output a media type using the Content-Type header. To
; disable this, simply set it to be empty.
;
; PHP&apos;s built-in default media type is set to text/html.
; https://php.net/default-mimetype
default_mimetype = &quot;text/html&quot;

; PHP&apos;s default character set is set to UTF-8.
; https://php.net/default-charset
default_charset = &quot;UTF-8&quot;

; PHP internal character encoding is set to empty.
; If empty, default_charset is used.
; https://php.net/internal-encoding
;internal_encoding =

; PHP input character encoding is set to empty.
; If empty, default_charset is used.
; https://php.net/input-encoding
;input_encoding =

; PHP output character encoding is set to empty.
; If empty, default_charset is used.
; See also output_buffer.
; https://php.net/output-encoding
;output_encoding =

;;;;;;;;;;;;;;;;;;;;;;;;;
; Paths and Directories ;
;;;;;;;;;;;;;;;;;;;;;;;;;

; UNIX: &quot;/path1:/path2&quot;
;include_path = &quot;.:/php/includes&quot;
;
; Windows: &quot;\path1;\path2&quot;
;include_path = &quot;.;c:\php\includes&quot;
;
; PHP&apos;s default setting for include_path is &quot;.;/path/to/php/pear&quot;
; https://php.net/include-path

; The root of the PHP pages, used only if nonempty.
; if PHP was not compiled with FORCE_REDIRECT, you SHOULD set doc_root
; if you are running php as a CGI under any web server (other than IIS)
; see documentation for security issues.  The alternate is to use the
; cgi.force_redirect configuration below
; https://php.net/doc-root
doc_root =

; The directory under which PHP opens the script using /~username used only
; if nonempty.
; https://php.net/user-dir
user_dir =

; Directory in which the loadable extensions (modules) reside.
; https://php.net/extension-dir
;extension_dir = &quot;./&quot;
; On windows:
;extension_dir = &quot;ext&quot;

; Directory where the temporary files should be placed.
; Defaults to the system default (see sys_get_temp_dir)
;sys_temp_dir = &quot;/tmp&quot;

; Whether or not to enable the dl() function.  The dl() function does NOT work
; properly in multithreaded servers, such as IIS or Zeus, and is automatically
; disabled on them.
; https://php.net/enable-dl
enable_dl = Off

; cgi.force_redirect is necessary to provide security running PHP as a CGI under
; most web servers.  Left undefined, PHP turns this on by default.  You can
; turn it off here AT YOUR OWN RISK
; **You CAN safely turn this off for IIS, in fact, you MUST.**
; https://php.net/cgi.force-redirect
;cgi.force_redirect = 1

; if cgi.nph is enabled it will force cgi to always sent Status: 200 with
; every request. PHP&apos;s default behavior is to disable this feature.
;cgi.nph = 1

; if cgi.force_redirect is turned on, and you are not running under Apache or Netscape
; (iPlanet) web servers, you MAY need to set an environment variable name that PHP
; will look for to know it is OK to continue execution.  Setting this variable MAY
; cause security issues, KNOW WHAT YOU ARE DOING FIRST.
; https://php.net/cgi.redirect-status-env
;cgi.redirect_status_env =

; cgi.fix_pathinfo provides *real* PATH_INFO/PATH_TRANSLATED support for CGI.  PHP&apos;s
; previous behaviour was to set PATH_TRANSLATED to SCRIPT_FILENAME, and to not grok
; what PATH_INFO is.  For more information on PATH_INFO, see the cgi specs.  Setting
; this to 1 will cause PHP CGI to fix its paths to conform to the spec.  A setting
; of zero causes PHP to behave as before.  Default is 1.  You should fix your scripts
; to use SCRIPT_FILENAME rather than PATH_TRANSLATED.
; https://php.net/cgi.fix-pathinfo
;cgi.fix_pathinfo=1

; if cgi.discard_path is enabled, the PHP CGI binary can safely be placed outside
; of the web tree and people will not be able to circumvent .htaccess security.
;cgi.discard_path=1

; FastCGI under IIS supports the ability to impersonate
; security tokens of the calling client.  This allows IIS to define the
; security context that the request runs under.  mod_fastcgi under Apache
; does not currently support this feature (03/17/2002)
; Set to 1 if running under IIS.  Default is zero.
; https://php.net/fastcgi.impersonate
;fastcgi.impersonate = 1

; Disable logging through FastCGI connection. PHP&apos;s default behavior is to enable
; this feature.
;fastcgi.logging = 0

; cgi.rfc2616_headers configuration option tells PHP what type of headers to
; use when sending HTTP response code. If set to 0, PHP sends Status: header that
; is supported by Apache. When this option is set to 1, PHP will send
; RFC2616 compliant header.
; Default is zero.
; https://php.net/cgi.rfc2616-headers
;cgi.rfc2616_headers = 0

; cgi.check_shebang_line controls whether CGI PHP checks for line starting with #!
; (shebang) at the top of the running script. This line might be needed if the
; script support running both as stand-alone script and via PHP CGI&lt;. PHP in CGI
; mode skips this line and ignores its content if this directive is turned on.
; https://php.net/cgi.check-shebang-line
;cgi.check_shebang_line=1

;;;;;;;;;;;;;;;;
; File Uploads ;
;;;;;;;;;;;;;;;;

; Whether to allow HTTP file uploads.
; https://php.net/file-uploads
file_uploads = On

; Temporary directory for HTTP uploaded files (will use system default if not
; specified).
; https://php.net/upload-tmp-dir
;upload_tmp_dir =

; Maximum allowed size for uploaded files.
; https://php.net/upload-max-filesize
upload_max_filesize = 100M

; Maximum number of files that can be uploaded via a single request
max_file_uploads = 20

;;;;;;;;;;;;;;;;;;
; Fopen wrappers ;
;;;;;;;;;;;;;;;;;;

; Whether to allow the treatment of URLs (like http:// or ftp://) as files.
; https://php.net/allow-url-fopen
allow_url_fopen = On

; Whether to allow include/require to open URLs (like https:// or ftp://) as files.
; https://php.net/allow-url-include
allow_url_include = Off

; Define the anonymous ftp password (your email address). PHP&apos;s default setting
; for this is empty.
; https://php.net/from
;from=&quot;john@doe.com&quot;

; Define the User-Agent string. PHP&apos;s default setting for this is empty.
; https://php.net/user-agent
;user_agent=&quot;PHP&quot;

; Default timeout for socket based streams (seconds)
; https://php.net/default-socket-timeout
default_socket_timeout = 60

; If your scripts have to deal with files from Macintosh systems,
; or you are running on a Mac and need to deal with files from
; unix or win32 systems, setting this flag will cause PHP to
; automatically detect the EOL character in those files so that
; fgets() and file() will work regardless of the source of the file.
; https://php.net/auto-detect-line-endings
;auto_detect_line_endings = Off

;;;;;;;;;;;;;;;;;;;;;;
; Dynamic Extensions ;
;;;;;;;;;;;;;;;;;;;;;;

; If you wish to have an extension loaded automatically, use the following
; syntax:
;
;   extension=modulename
;
; For example:
;
;   extension=mysqli
;
; When the extension library to load is not located in the default extension
; directory, You may specify an absolute path to the library file:
;
;   extension=/path/to/extension/mysqli.so
;
; Note : The syntax used in previous PHP versions (&apos;extension=&lt;ext&gt;.so&apos; and
; &apos;extension=&apos;php_&lt;ext&gt;.dll&apos;) is supported for legacy reasons and may be
; deprecated in a future PHP major version. So, when it is possible, please
; move to the new (&apos;extension=&lt;ext&gt;) syntax.
;
; Notes for Windows environments :
;
; - Many DLL files are located in the ext/
;   extension folders as well as the separate PECL DLL download.
;   Be sure to appropriately set the extension_dir directive.
;
;extension=bz2

; The ldap extension must be before curl if OpenSSL 1.0.2 and OpenLDAP is used
; otherwise it results in segfault when unloading after using SASL.
; See https://github.com/php/php-src/issues/8620 for more info.
;extension=ldap

;extension=curl
;extension=ffi
;extension=ftp
;extension=fileinfo
;extension=gd
;extension=gettext
;extension=gmp
;extension=intl
;extension=imap
;extension=mbstring
;extension=exif      ; Must be after mbstring as it depends on it
;extension=mysqli
;extension=oci8_12c  ; Use with Oracle Database 12c Instant Client
;extension=oci8_19  ; Use with Oracle Database 19 Instant Client
;extension=odbc
;extension=openssl
;extension=pdo_firebird
;extension=pdo_mysql
;extension=pdo_oci
;extension=pdo_odbc
;extension=pdo_pgsql
;extension=pdo_sqlite
;extension=pgsql
;extension=shmop

; The MIBS data available in the PHP distribution must be installed.
; See https://www.php.net/manual/en/snmp.installation.php
;extension=snmp

;extension=soap
;extension=sockets
;extension=sodium
;extension=sqlite3
;extension=tidy
;extension=xsl
;extension=zip

;zend_extension=opcache

;;;;;;;;;;;;;;;;;;;
; Module Settings ;
;;;;;;;;;;;;;;;;;;;

[CLI Server]
; Whether the CLI web server uses ANSI color coding in its terminal output.
cli_server.color = On

[Date]
; Defines the default timezone used by the date functions
; https://php.net/date.timezone
;date.timezone =

; https://php.net/date.default-latitude
;date.default_latitude = 31.7667

; https://php.net/date.default-longitude
;date.default_longitude = 35.2333

; https://php.net/date.sunrise-zenith
;date.sunrise_zenith = 90.833333

; https://php.net/date.sunset-zenith
;date.sunset_zenith = 90.833333

[filter]
; https://php.net/filter.default
;filter.default = unsafe_raw

; https://php.net/filter.default-flags
;filter.default_flags =

[iconv]
; Use of this INI entry is deprecated, use global input_encoding instead.
; If empty, default_charset or input_encoding or iconv.input_encoding is used.
; The precedence is: default_charset &lt; input_encoding &lt; iconv.input_encoding
;iconv.input_encoding =

; Use of this INI entry is deprecated, use global internal_encoding instead.
; If empty, default_charset or internal_encoding or iconv.internal_encoding is used.
; The precedence is: default_charset &lt; internal_encoding &lt; iconv.internal_encoding
;iconv.internal_encoding =

; Use of this INI entry is deprecated, use global output_encoding instead.
; If empty, default_charset or output_encoding or iconv.output_encoding is used.
; The precedence is: default_charset &lt; output_encoding &lt; iconv.output_encoding
; To use an output encoding conversion, iconv&apos;s output handler must be set
; otherwise output encoding conversion cannot be performed.
;iconv.output_encoding =

[imap]
; rsh/ssh logins are disabled by default. Use this INI entry if you want to
; enable them. Note that the IMAP library does not filter mailbox names before
; passing them to rsh/ssh command, thus passing untrusted data to this function
; with rsh/ssh enabled is insecure.
;imap.enable_insecure_rsh=0

[intl]
;intl.default_locale =
; This directive allows you to produce PHP errors when some error
; happens within intl functions. The value is the level of the error produced.
; Default is 0, which does not produce any errors.
;intl.error_level = E_WARNING
;intl.use_exceptions = 0

[sqlite3]
; Directory pointing to SQLite3 extensions
; https://php.net/sqlite3.extension-dir
;sqlite3.extension_dir =

; SQLite defensive mode flag (only available from SQLite 3.26+)
; When the defensive flag is enabled, language features that allow ordinary
; SQL to deliberately corrupt the database file are disabled. This forbids
; writing directly to the schema, shadow tables (eg. FTS data tables), or
; the sqlite_dbpage virtual table.
; https://www.sqlite.org/c3ref/c_dbconfig_defensive.html
; (for older SQLite versions, this flag has no use)
;sqlite3.defensive = 1

[Pcre]
; PCRE library backtracking limit.
; https://php.net/pcre.backtrack-limit
;pcre.backtrack_limit=100000

; PCRE library recursion limit.
; Please note that if you set this value to a high number you may consume all
; the available process stack and eventually crash PHP (due to reaching the
; stack size limit imposed by the Operating System).
; https://php.net/pcre.recursion-limit
;pcre.recursion_limit=100000

; Enables or disables JIT compilation of patterns. This requires the PCRE
; library to be compiled with JIT support.
;pcre.jit=1

[Pdo]
; Whether to pool ODBC connections. Can be one of &quot;strict&quot;, &quot;relaxed&quot; or &quot;off&quot;
; https://php.net/pdo-odbc.connection-pooling
;pdo_odbc.connection_pooling=strict

[Pdo_mysql]
; Default socket name for local MySQL connects.  If empty, uses the built-in
; MySQL defaults.
pdo_mysql.default_socket=

[Phar]
; https://php.net/phar.readonly
;phar.readonly = On

; https://php.net/phar.require-hash
;phar.require_hash = On

;phar.cache_list =

[mail function]
; For Win32 only.
; https://php.net/smtp
SMTP = localhost
; https://php.net/smtp-port
smtp_port = 25

; For Win32 only.
; https://php.net/sendmail-from
;sendmail_from = me@example.com

; For Unix only.  You may supply arguments as well (default: &quot;sendmail -t -i&quot;).
; https://php.net/sendmail-path
;sendmail_path =

; Force the addition of the specified parameters to be passed as extra parameters
; to the sendmail binary. These parameters will always replace the value of
; the 5th parameter to mail().
;mail.force_extra_parameters =

; Add X-PHP-Originating-Script: that will include uid of the script followed by the filename
mail.add_x_header = Off

; Use mixed LF and CRLF line separators to keep compatibility with some
; RFC 2822 non conformant MTA.
mail.mixed_lf_and_crlf = Off

; The path to a log file that will log all mail() calls. Log entries include
; the full path of the script, line number, To address and headers.
;mail.log =
; Log mail to syslog (Event Log on Windows).
;mail.log = syslog

[ODBC]
; https://php.net/odbc.default-db
;odbc.default_db    =  Not yet implemented

; https://php.net/odbc.default-user
;odbc.default_user  =  Not yet implemented

; https://php.net/odbc.default-pw
;odbc.default_pw    =  Not yet implemented

; Controls the ODBC cursor model.
; Default: SQL_CURSOR_STATIC (default).
;odbc.default_cursortype

; Allow or prevent persistent links.
; https://php.net/odbc.allow-persistent
odbc.allow_persistent = On

; Check that a connection is still valid before reuse.
; https://php.net/odbc.check-persistent
odbc.check_persistent = On

; Maximum number of persistent links.  -1 means no limit.
; https://php.net/odbc.max-persistent
odbc.max_persistent = -1

; Maximum number of links (persistent + non-persistent).  -1 means no limit.
; https://php.net/odbc.max-links
odbc.max_links = -1

; Handling of LONG fields.  Returns number of bytes to variables.  0 means
; passthru.
; https://php.net/odbc.defaultlrl
odbc.defaultlrl = 4096

; Handling of binary data.  0 means passthru, 1 return as is, 2 convert to char.
; See the documentation on odbc_binmode and odbc_longreadlen for an explanation
; of odbc.defaultlrl and odbc.defaultbinmode
; https://php.net/odbc.defaultbinmode
odbc.defaultbinmode = 1

[MySQLi]

; Maximum number of persistent links.  -1 means no limit.
; https://php.net/mysqli.max-persistent
mysqli.max_persistent = -1

; Allow accessing, from PHP&apos;s perspective, local files with LOAD DATA statements
; https://php.net/mysqli.allow_local_infile
;mysqli.allow_local_infile = On

; It allows the user to specify a folder where files that can be sent via LOAD DATA
; LOCAL can exist. It is ignored if mysqli.allow_local_infile is enabled.
;mysqli.local_infile_directory =

; Allow or prevent persistent links.
; https://php.net/mysqli.allow-persistent
mysqli.allow_persistent = On

; Maximum number of links.  -1 means no limit.
; https://php.net/mysqli.max-links
mysqli.max_links = -1

; Default port number for mysqli_connect().  If unset, mysqli_connect() will use
; the $MYSQL_TCP_PORT or the mysql-tcp entry in /etc/services or the
; compile-time value defined MYSQL_PORT (in that order).  Win32 will only look
; at MYSQL_PORT.
; https://php.net/mysqli.default-port
mysqli.default_port = 3306

; Default socket name for local MySQL connects.  If empty, uses the built-in
; MySQL defaults.
; https://php.net/mysqli.default-socket
mysqli.default_socket =

; Default host for mysqli_connect() (doesn&apos;t apply in safe mode).
; https://php.net/mysqli.default-host
mysqli.default_host =

; Default user for mysqli_connect() (doesn&apos;t apply in safe mode).
; https://php.net/mysqli.default-user
mysqli.default_user =

; Default password for mysqli_connect() (doesn&apos;t apply in safe mode).
; Note that this is generally a *bad* idea to store passwords in this file.
; *Any* user with PHP access can run &apos;echo get_cfg_var(&quot;mysqli.default_pw&quot;)
; and reveal this password!  And of course, any users with read access to this
; file will be able to reveal the password as well.
; https://php.net/mysqli.default-pw
mysqli.default_pw =

; If this option is enabled, closing a persistent connection will rollback
; any pending transactions of this connection, before it is put back
; into the persistent connection pool.
;mysqli.rollback_on_cached_plink = Off

[mysqlnd]
; Enable / Disable collection of general statistics by mysqlnd which can be
; used to tune and monitor MySQL operations.
mysqlnd.collect_statistics = On

; Enable / Disable collection of memory usage statistics by mysqlnd which can be
; used to tune and monitor MySQL operations.
mysqlnd.collect_memory_statistics = On

; Records communication from all extensions using mysqlnd to the specified log
; file.
; https://php.net/mysqlnd.debug
;mysqlnd.debug =

; Defines which queries will be logged.
;mysqlnd.log_mask = 0

; Default size of the mysqlnd memory pool, which is used by result sets.
;mysqlnd.mempool_default_size = 16000

; Size of a pre-allocated buffer used when sending commands to MySQL in bytes.
;mysqlnd.net_cmd_buffer_size = 2048

; Size of a pre-allocated buffer used for reading data sent by the server in
; bytes.
;mysqlnd.net_read_buffer_size = 32768

; Timeout for network requests in seconds.
;mysqlnd.net_read_timeout = 31536000

; SHA-256 Authentication Plugin related. File with the MySQL server public RSA
; key.
;mysqlnd.sha256_server_public_key =

[OCI8]

; Connection: Enables privileged connections using external
; credentials (OCI_SYSOPER, OCI_SYSDBA)
; https://php.net/oci8.privileged-connect
;oci8.privileged_connect = Off

; Connection: The maximum number of persistent OCI8 connections per
; process. Using -1 means no limit.
; https://php.net/oci8.max-persistent
;oci8.max_persistent = -1

; Connection: The maximum number of seconds a process is allowed to
; maintain an idle persistent connection. Using -1 means idle
; persistent connections will be maintained forever.
; https://php.net/oci8.persistent-timeout
;oci8.persistent_timeout = -1

; Connection: The number of seconds that must pass before issuing a
; ping during oci_pconnect() to check the connection validity. When
; set to 0, each oci_pconnect() will cause a ping. Using -1 disables
; pings completely.
; https://php.net/oci8.ping-interval
;oci8.ping_interval = 60

; Connection: Set this to a user chosen connection class to be used
; for all pooled server requests with Oracle Database Resident
; Connection Pooling (DRCP).  To use DRCP, this value should be set to
; the same string for all web servers running the same application,
; the database pool must be configured, and the connection string must
; specify to use a pooled server.
;oci8.connection_class =

; High Availability: Using On lets PHP receive Fast Application
; Notification (FAN) events generated when a database node fails. The
; database must also be configured to post FAN events.
;oci8.events = Off

; Tuning: This option enables statement caching, and specifies how
; many statements to cache. Using 0 disables statement caching.
; https://php.net/oci8.statement-cache-size
;oci8.statement_cache_size = 20

; Tuning: Enables row prefetching and sets the default number of
; rows that will be fetched automatically after statement execution.
; https://php.net/oci8.default-prefetch
;oci8.default_prefetch = 100

; Tuning: Sets the amount of LOB data that is internally returned from
; Oracle Database when an Oracle LOB locator is initially retrieved as
; part of a query. Setting this can improve performance by reducing
; round-trips.
; https://php.net/oci8.prefetch-lob-size
; oci8.prefetch_lob_size = 0

; Compatibility. Using On means oci_close() will not close
; oci_connect() and oci_new_connect() connections.
; https://php.net/oci8.old-oci-close-semantics
;oci8.old_oci_close_semantics = Off

[PostgreSQL]
; Allow or prevent persistent links.
; https://php.net/pgsql.allow-persistent
pgsql.allow_persistent = On

; Detect broken persistent links always with pg_pconnect().
; Auto reset feature requires a little overheads.
; https://php.net/pgsql.auto-reset-persistent
pgsql.auto_reset_persistent = Off

; Maximum number of persistent links.  -1 means no limit.
; https://php.net/pgsql.max-persistent
pgsql.max_persistent = -1

; Maximum number of links (persistent+non persistent).  -1 means no limit.
; https://php.net/pgsql.max-links
pgsql.max_links = -1

; Ignore PostgreSQL backends Notice message or not.
; Notice message logging require a little overheads.
; https://php.net/pgsql.ignore-notice
pgsql.ignore_notice = 0

; Log PostgreSQL backends Notice message or not.
; Unless pgsql.ignore_notice=0, module cannot log notice message.
; https://php.net/pgsql.log-notice
pgsql.log_notice = 0

[bcmath]
; Number of decimal digits for all bcmath functions.
; https://php.net/bcmath.scale
bcmath.scale = 0

[browscap]
; https://php.net/browscap
;browscap = extra/browscap.ini

[Session]
; Handler used to store/retrieve data.
; https://php.net/session.save-handler
session.save_handler = files

; Argument passed to save_handler.  In the case of files, this is the path
; where data files are stored. Note: Windows users have to change this
; variable in order to use PHP&apos;s session functions.
;
; The path can be defined as:
;
;     session.save_path = &quot;N;/path&quot;
;
; where N is an integer.  Instead of storing all the session files in
; /path, what this will do is use subdirectories N-levels deep, and
; store the session data in those directories.  This is useful if
; your OS has problems with many files in one directory, and is
; a more efficient layout for servers that handle many sessions.
;
; NOTE 1: PHP will not create this directory structure automatically.
;         You can use the script in the ext/session dir for that purpose.
; NOTE 2: See the section on garbage collection below if you choose to
;         use subdirectories for session storage
;
; The file storage module creates files using mode 600 by default.
; You can change that by using
;
;     session.save_path = &quot;N;MODE;/path&quot;
;
; where MODE is the octal representation of the mode. Note that this
; does not overwrite the process&apos;s umask.
; https://php.net/session.save-path
;session.save_path = &quot;/tmp&quot;

; Whether to use strict session mode.
; Strict session mode does not accept an uninitialized session ID, and
; regenerates the session ID if the browser sends an uninitialized session ID.
; Strict mode protects applications from session fixation via a session adoption
; vulnerability. It is disabled by default for maximum compatibility, but
; enabling it is encouraged.
; https://wiki.php.net/rfc/strict_sessions
session.use_strict_mode = 0

; Whether to use cookies.
; https://php.net/session.use-cookies
session.use_cookies = 1

; https://php.net/session.cookie-secure
;session.cookie_secure =

; This option forces PHP to fetch and use a cookie for storing and maintaining
; the session id. We encourage this operation as it&apos;s very helpful in combating
; session hijacking when not specifying and managing your own session id. It is
; not the be-all and end-all of session hijacking defense, but it&apos;s a good start.
; https://php.net/session.use-only-cookies
session.use_only_cookies = 1

; Name of the session (used as cookie name).
; https://php.net/session.name
session.name = PHPSESSID

; Initialize session on request startup.
; https://php.net/session.auto-start
session.auto_start = 0

; Lifetime in seconds of cookie or, if 0, until browser is restarted.
; https://php.net/session.cookie-lifetime
session.cookie_lifetime = 0

; The path for which the cookie is valid.
; https://php.net/session.cookie-path
session.cookie_path = /

; The domain for which the cookie is valid.
; https://php.net/session.cookie-domain
session.cookie_domain =

; Whether or not to add the httpOnly flag to the cookie, which makes it
; inaccessible to browser scripting languages such as JavaScript.
; https://php.net/session.cookie-httponly
session.cookie_httponly =

; Add SameSite attribute to cookie to help mitigate Cross-Site Request Forgery (CSRF/XSRF)
; Current valid values are &quot;Strict&quot;, &quot;Lax&quot; or &quot;None&quot;. When using &quot;None&quot;,
; make sure to include the quotes, as `none` is interpreted like `false` in ini files.
; https://tools.ietf.org/html/draft-west-first-party-cookies-07
session.cookie_samesite =

; Handler used to serialize data. php is the standard serializer of PHP.
; https://php.net/session.serialize-handler
session.serialize_handler = php

; Defines the probability that the &apos;garbage collection&apos; process is started on every
; session initialization. The probability is calculated by using gc_probability/gc_divisor,
; e.g. 1/100 means there is a 1% chance that the GC process starts on each request.
; Default Value: 1
; Development Value: 1
; Production Value: 1
; https://php.net/session.gc-probability
session.gc_probability = 1

; Defines the probability that the &apos;garbage collection&apos; process is started on every
; session initialization. The probability is calculated by using gc_probability/gc_divisor,
; e.g. 1/100 means there is a 1% chance that the GC process starts on each request.
; For high volume production servers, using a value of 1000 is a more efficient approach.
; Default Value: 100
; Development Value: 1000
; Production Value: 1000
; https://php.net/session.gc-divisor
session.gc_divisor = 1000

; After this number of seconds, stored data will be seen as &apos;garbage&apos; and
; cleaned up by the garbage collection process.
; https://php.net/session.gc-maxlifetime
session.gc_maxlifetime = 1440

; NOTE: If you are using the subdirectory option for storing session files
;       (see session.save_path above), then garbage collection does *not*
;       happen automatically.  You will need to do your own garbage
;       collection through a shell script, cron entry, or some other method.
;       For example, the following script is the equivalent of setting
;       session.gc_maxlifetime to 1440 (1440 seconds = 24 minutes):
;          find /path/to/sessions -cmin +24 -type f | xargs rm

; Check HTTP Referer to invalidate externally stored URLs containing ids.
; HTTP_REFERER has to contain this substring for the session to be
; considered as valid.
; https://php.net/session.referer-check
session.referer_check =

; Set to {nocache,private,public,} to determine HTTP caching aspects
; or leave this empty to avoid sending anti-caching headers.
; https://php.net/session.cache-limiter
session.cache_limiter = nocache

; Document expires after n minutes.
; https://php.net/session.cache-expire
session.cache_expire = 180

; trans sid support is disabled by default.
; Use of trans sid may risk your users&apos; security.
; Use this option with caution.
; - User may send URL contains active session ID
;   to other person via. email/irc/etc.
; - URL that contains active session ID may be stored
;   in publicly accessible computer.
; - User may access your site with the same session ID
;   always using URL stored in browser&apos;s history or bookmarks.
; https://php.net/session.use-trans-sid
session.use_trans_sid = 0

; Set session ID character length. This value could be between 22 to 256.
; Shorter length than default is supported only for compatibility reason.
; Users should use 32 or more chars.
; https://php.net/session.sid-length
; Default Value: 32
; Development Value: 26
; Production Value: 26
session.sid_length = 26

; The URL rewriter will look for URLs in a defined set of HTML tags.
; &lt;form&gt; is special; if you include them here, the rewriter will
; add a hidden &lt;input&gt; field with the info which is otherwise appended
; to URLs. &lt;form&gt; tag&apos;s action attribute URL will not be modified
; unless it is specified.
; Note that all valid entries require a &quot;=&quot;, even if no value follows.
; Default Value: &quot;a=href,area=href,frame=src,form=&quot;
; Development Value: &quot;a=href,area=href,frame=src,form=&quot;
; Production Value: &quot;a=href,area=href,frame=src,form=&quot;
; https://php.net/url-rewriter.tags
session.trans_sid_tags = &quot;a=href,area=href,frame=src,form=&quot;

; URL rewriter does not rewrite absolute URLs by default.
; To enable rewrites for absolute paths, target hosts must be specified
; at RUNTIME. i.e. use ini_set()
; &lt;form&gt; tags is special. PHP will check action attribute&apos;s URL regardless
; of session.trans_sid_tags setting.
; If no host is defined, HTTP_HOST will be used for allowed host.
; Example value: php.net,www.php.net,wiki.php.net
; Use &quot;,&quot; for multiple hosts. No spaces are allowed.
; Default Value: &quot;&quot;
; Development Value: &quot;&quot;
; Production Value: &quot;&quot;
;session.trans_sid_hosts=&quot;&quot;

; Define how many bits are stored in each character when converting
; the binary hash data to something readable.
; Possible values:
;   4  (4 bits: 0-9, a-f)
;   5  (5 bits: 0-9, a-v)
;   6  (6 bits: 0-9, a-z, A-Z, &quot;-&quot;, &quot;,&quot;)
; Default Value: 4
; Development Value: 5
; Production Value: 5
; https://php.net/session.hash-bits-per-character
session.sid_bits_per_character = 5

; Enable upload progress tracking in $_SESSION
; Default Value: On
; Development Value: On
; Production Value: On
; https://php.net/session.upload-progress.enabled
;session.upload_progress.enabled = On

; Cleanup the progress information as soon as all POST data has been read
; (i.e. upload completed).
; Default Value: On
; Development Value: On
; Production Value: On
; https://php.net/session.upload-progress.cleanup
;session.upload_progress.cleanup = On

; A prefix used for the upload progress key in $_SESSION
; Default Value: &quot;upload_progress_&quot;
; Development Value: &quot;upload_progress_&quot;
; Production Value: &quot;upload_progress_&quot;
; https://php.net/session.upload-progress.prefix
;session.upload_progress.prefix = &quot;upload_progress_&quot;

; The index name (concatenated with the prefix) in $_SESSION
; containing the upload progress information
; Default Value: &quot;PHP_SESSION_UPLOAD_PROGRESS&quot;
; Development Value: &quot;PHP_SESSION_UPLOAD_PROGRESS&quot;
; Production Value: &quot;PHP_SESSION_UPLOAD_PROGRESS&quot;
; https://php.net/session.upload-progress.name
;session.upload_progress.name = &quot;PHP_SESSION_UPLOAD_PROGRESS&quot;

; How frequently the upload progress should be updated.
; Given either in percentages (per-file), or in bytes
; Default Value: &quot;1%&quot;
; Development Value: &quot;1%&quot;
; Production Value: &quot;1%&quot;
; https://php.net/session.upload-progress.freq
;session.upload_progress.freq =  &quot;1%&quot;

; The minimum delay between updates, in seconds
; Default Value: 1
; Development Value: 1
; Production Value: 1
; https://php.net/session.upload-progress.min-freq
;session.upload_progress.min_freq = &quot;1&quot;

; Only write session data when session data is changed. Enabled by default.
; https://php.net/session.lazy-write
;session.lazy_write = On

[Assertion]
; Switch whether to compile assertions at all (to have no overhead at run-time)
; -1: Do not compile at all
;  0: Jump over assertion at run-time
;  1: Execute assertions
; Changing from or to a negative value is only possible in php.ini!
; (For turning assertions on and off at run-time, toggle zend.assertions between the values 1 and 0)
; Default Value: 1
; Development Value: 1
; Production Value: -1
; https://php.net/zend.assertions
zend.assertions = 1

[COM]
; path to a file containing GUIDs, IIDs or filenames of files with TypeLibs
; https://php.net/com.typelib-file
;com.typelib_file =

; allow Distributed-COM calls
; https://php.net/com.allow-dcom
;com.allow_dcom = true

; autoregister constants of a component&apos;s typelib on com_load()
; https://php.net/com.autoregister-typelib
;com.autoregister_typelib = true

; register constants casesensitive
; https://php.net/com.autoregister-casesensitive
;com.autoregister_casesensitive = false

; show warnings on duplicate constant registrations
; https://php.net/com.autoregister-verbose
;com.autoregister_verbose = true

; The default character set code-page to use when passing strings to and from COM objects.
; Default: system ANSI code page
;com.code_page=

; The version of the .NET framework to use. The value of the setting are the first three parts
; of the framework&apos;s version number, separated by dots, and prefixed with &quot;v&quot;, e.g. &quot;v4.0.30319&quot;.
;com.dotnet_version=

[mbstring]
; language for internal character representation.
; This affects mb_send_mail() and mbstring.detect_order.
; https://php.net/mbstring.language
;mbstring.language = Japanese

; Use of this INI entry is deprecated, use global internal_encoding instead.
; internal/script encoding.
; Some encoding cannot work as internal encoding. (e.g. SJIS, BIG5, ISO-2022-*)
; If empty, default_charset or internal_encoding or iconv.internal_encoding is used.
; The precedence is: default_charset &lt; internal_encoding &lt; iconv.internal_encoding
;mbstring.internal_encoding =

; Use of this INI entry is deprecated, use global input_encoding instead.
; http input encoding.
; mbstring.encoding_translation = On is needed to use this setting.
; If empty, default_charset or input_encoding or mbstring.input is used.
; The precedence is: default_charset &lt; input_encoding &lt; mbstring.http_input
; https://php.net/mbstring.http-input
;mbstring.http_input =

; Use of this INI entry is deprecated, use global output_encoding instead.
; http output encoding.
; mb_output_handler must be registered as output buffer to function.
; If empty, default_charset or output_encoding or mbstring.http_output is used.
; The precedence is: default_charset &lt; output_encoding &lt; mbstring.http_output
; To use an output encoding conversion, mbstring&apos;s output handler must be set
; otherwise output encoding conversion cannot be performed.
; https://php.net/mbstring.http-output
;mbstring.http_output =

; enable automatic encoding translation according to
; mbstring.internal_encoding setting. Input chars are
; converted to internal encoding by setting this to On.
; Note: Do _not_ use automatic encoding translation for
;       portable libs/applications.
; https://php.net/mbstring.encoding-translation
;mbstring.encoding_translation = Off

; automatic encoding detection order.
; &quot;auto&quot; detect order is changed according to mbstring.language
; https://php.net/mbstring.detect-order
;mbstring.detect_order = auto

; substitute_character used when character cannot be converted
; one from another
; https://php.net/mbstring.substitute-character
;mbstring.substitute_character = none

; Enable strict encoding detection.
;mbstring.strict_detection = Off

; This directive specifies the regex pattern of content types for which mb_output_handler()
; is activated.
; Default: mbstring.http_output_conv_mimetypes=^(text/|application/xhtml\+xml)
;mbstring.http_output_conv_mimetypes=

; This directive specifies maximum stack depth for mbstring regular expressions. It is similar
; to the pcre.recursion_limit for PCRE.
;mbstring.regex_stack_limit=100000

; This directive specifies maximum retry count for mbstring regular expressions. It is similar
; to the pcre.backtrack_limit for PCRE.
;mbstring.regex_retry_limit=1000000

[gd]
; Tell the jpeg decode to ignore warnings and try to create
; a gd image. The warning will then be displayed as notices
; disabled by default
; https://php.net/gd.jpeg-ignore-warning
;gd.jpeg_ignore_warning = 1

[exif]
; Exif UNICODE user comments are handled as UCS-2BE/UCS-2LE and JIS as JIS.
; With mbstring support this will automatically be converted into the encoding
; given by corresponding encode setting. When empty mbstring.internal_encoding
; is used. For the decode settings you can distinguish between motorola and
; intel byte order. A decode setting cannot be empty.
; https://php.net/exif.encode-unicode
;exif.encode_unicode = ISO-8859-15

; https://php.net/exif.decode-unicode-motorola
;exif.decode_unicode_motorola = UCS-2BE

; https://php.net/exif.decode-unicode-intel
;exif.decode_unicode_intel    = UCS-2LE

; https://php.net/exif.encode-jis
;exif.encode_jis =

; https://php.net/exif.decode-jis-motorola
;exif.decode_jis_motorola = JIS

; https://php.net/exif.decode-jis-intel
;exif.decode_jis_intel    = JIS

[Tidy]
; The path to a default tidy configuration file to use when using tidy
; https://php.net/tidy.default-config
;tidy.default_config = /usr/local/lib/php/default.tcfg

; Should tidy clean and repair output automatically?
; WARNING: Do not use this option if you are generating non-html content
; such as dynamic images
; https://php.net/tidy.clean-output
tidy.clean_output = Off

[soap]
; Enables or disables WSDL caching feature.
; https://php.net/soap.wsdl-cache-enabled
soap.wsdl_cache_enabled=1

; Sets the directory name where SOAP extension will put cache files.
; https://php.net/soap.wsdl-cache-dir
soap.wsdl_cache_dir=&quot;/tmp&quot;

; (time to live) Sets the number of second while cached file will be used
; instead of original one.
; https://php.net/soap.wsdl-cache-ttl
soap.wsdl_cache_ttl=86400

; Sets the size of the cache limit. (Max. number of WSDL files to cache)
soap.wsdl_cache_limit = 5

[sysvshm]
; A default size of the shared memory segment
;sysvshm.init_mem = 10000

[ldap]
; Sets the maximum number of open links or -1 for unlimited.
ldap.max_links = -1

[dba]
;dba.default_handler=

[opcache]
; Determines if Zend OPCache is enabled
;opcache.enable=1

; Determines if Zend OPCache is enabled for the CLI version of PHP
;opcache.enable_cli=0

; The OPcache shared memory storage size.
;opcache.memory_consumption=128

; The amount of memory for interned strings in Mbytes.
;opcache.interned_strings_buffer=8

; The maximum number of keys (scripts) in the OPcache hash table.
; Only numbers between 200 and 1000000 are allowed.
;opcache.max_accelerated_files=10000

; The maximum percentage of &quot;wasted&quot; memory until a restart is scheduled.
;opcache.max_wasted_percentage=5

; When this directive is enabled, the OPcache appends the current working
; directory to the script key, thus eliminating possible collisions between
; files with the same name (basename). Disabling the directive improves
; performance, but may break existing applications.
;opcache.use_cwd=1

; When disabled, you must reset the OPcache manually or restart the
; webserver for changes to the filesystem to take effect.
;opcache.validate_timestamps=1

; How often (in seconds) to check file timestamps for changes to the shared
; memory storage allocation. (&quot;1&quot; means validate once per second, but only
; once per request. &quot;0&quot; means always validate)
;opcache.revalidate_freq=2

; Enables or disables file search in include_path optimization
;opcache.revalidate_path=0

; If disabled, all PHPDoc comments are dropped from the code to reduce the
; size of the optimized code.
;opcache.save_comments=1

; If enabled, compilation warnings (including notices and deprecations) will
; be recorded and replayed each time a file is included. Otherwise, compilation
; warnings will only be emitted when the file is first cached.
;opcache.record_warnings=0

; Allow file existence override (file_exists, etc.) performance feature.
;opcache.enable_file_override=0

; A bitmask, where each bit enables or disables the appropriate OPcache
; passes
;opcache.optimization_level=0x7FFFBFFF

;opcache.dups_fix=0

; The location of the OPcache blacklist file (wildcards allowed).
; Each OPcache blacklist file is a text file that holds the names of files
; that should not be accelerated. The file format is to add each filename
; to a new line. The filename may be a full path or just a file prefix
; (i.e., /var/www/x  blacklists all the files and directories in /var/www
; that start with &apos;x&apos;). Line starting with a ; are ignored (comments).
;opcache.blacklist_filename=

; Allows exclusion of large files from being cached. By default all files
; are cached.
;opcache.max_file_size=0

; How long to wait (in seconds) for a scheduled restart to begin if the cache
; is not being accessed.
;opcache.force_restart_timeout=180

; OPcache error_log file name. Empty string assumes &quot;stderr&quot;.
;opcache.error_log=

; All OPcache errors go to the Web server log.
; By default, only fatal errors (level 0) or errors (level 1) are logged.
; You can also enable warnings (level 2), info messages (level 3) or
; debug messages (level 4).
;opcache.log_verbosity_level=1

; Preferred Shared Memory back-end. Leave empty and let the system decide.
;opcache.preferred_memory_model=

; Protect the shared memory from unexpected writing during script execution.
; Useful for internal debugging only.
;opcache.protect_memory=0

; Allows calling OPcache API functions only from PHP scripts which path is
; started from specified string. The default &quot;&quot; means no restriction
;opcache.restrict_api=

; Mapping base of shared memory segments (for Windows only). All the PHP
; processes have to map shared memory into the same address space. This
; directive allows to manually fix the &quot;Unable to reattach to base address&quot;
; errors.
;opcache.mmap_base=

; Facilitates multiple OPcache instances per user (for Windows only). All PHP
; processes with the same cache ID and user share an OPcache instance.
;opcache.cache_id=

; Enables and sets the second level cache directory.
; It should improve performance when SHM memory is full, at server restart or
; SHM reset. The default &quot;&quot; disables file based caching.
;opcache.file_cache=

; Enables or disables opcode caching in shared memory.
;opcache.file_cache_only=0

; Enables or disables checksum validation when script loaded from file cache.
;opcache.file_cache_consistency_checks=1

; Implies opcache.file_cache_only=1 for a certain process that failed to
; reattach to the shared memory (for Windows only). Explicitly enabled file
; cache is required.
;opcache.file_cache_fallback=1

; Enables or disables copying of PHP code (text segment) into HUGE PAGES.
; Under certain circumstances (if only a single global PHP process is
; started from which all others fork), this can increase performance
; by a tiny amount because TLB misses are reduced.  On the other hand, this
; delays PHP startup, increases memory usage and degrades performance
; under memory pressure - use with care.
; Requires appropriate OS configuration.
;opcache.huge_code_pages=0

; Validate cached file permissions.
;opcache.validate_permission=0

; Prevent name collisions in chroot&apos;ed environment.
;opcache.validate_root=0

; If specified, it produces opcode dumps for debugging different stages of
; optimizations.
;opcache.opt_debug_level=0

; Specifies a PHP script that is going to be compiled and executed at server
; start-up.
; https://php.net/opcache.preload
;opcache.preload=

; Preloading code as root is not allowed for security reasons. This directive
; facilitates to let the preloading to be run as another user.
; https://php.net/opcache.preload_user
;opcache.preload_user=

; Prevents caching files that are less than this number of seconds old. It
; protects from caching of incompletely updated files. In case all file updates
; on your site are atomic, you may increase performance by setting it to &quot;0&quot;.
;opcache.file_update_protection=2

; Absolute path used to store shared lockfiles (for *nix only).
;opcache.lockfile_path=/tmp

[curl]
; A default value for the CURLOPT_CAINFO option. This is required to be an
; absolute path.
;curl.cainfo =

[openssl]
; The location of a Certificate Authority (CA) file on the local filesystem
; to use when verifying the identity of SSL/TLS peers. Most users should
; not specify a value for this directive as PHP will attempt to use the
; OS-managed cert stores in its absence. If specified, this value may still
; be overridden on a per-stream basis via the &quot;cafile&quot; SSL stream context
; option.
;openssl.cafile=

; If openssl.cafile is not specified or if the CA file is not found, the
; directory pointed to by openssl.capath is searched for a suitable
; certificate. This value must be a correctly hashed certificate directory.
; Most users should not specify a value for this directive as PHP will
; attempt to use the OS-managed cert stores in its absence. If specified,
; this value may still be overridden on a per-stream basis via the &quot;capath&quot;
; SSL stream context option.
;openssl.capath=

[ffi]
; FFI API restriction. Possible values:
; &quot;preload&quot; - enabled in CLI scripts and preloaded files (default)
; &quot;false&quot;   - always disabled
; &quot;true&quot;    - always enabled
;ffi.enable=preload

; List of headers files to preload, wildcard patterns allowed.
;ffi.preload=</file><file path="docker/nginx/Dockerfile">FROM nginx:alpine

# set main params
ARG BUILD_ARGUMENT_ENV=dev
ENV ENV=$BUILD_ARGUMENT_ENV

RUN ln -sf /dev/stdout /var/log/nginx/access.log &amp;&amp; \
    ln -sf /dev/stderr /var/log/nginx/error.log &amp;&amp; \
    rm -rf /etc/nginx/conf.d/*

# install openssl
RUN apk add --update openssl &amp;&amp; \
    rm -rf /var/cache/apk/*

# create folder for certificates
RUN mkdir -p /etc/nginx/certificates

# generate certificates
# TODO: change it and make additional logic for production environment
RUN openssl req -x509 -nodes -days 365 -newkey rsa:2048 -keyout /etc/nginx/certificates/key.pem -out /etc/nginx/certificates/cert.pem -subj &quot;/C=DK/ST=Odense/L=Odense/O=Baander/OU=Development/CN=baander.test&quot;

# put nginx config
COPY ./$BUILD_ARGUMENT_ENV/nginx.conf /etc/nginx/conf.d/default.conf</file><file path="resources/app/api-client-ext/interceptors/refresh-access-token.interceptor.ts">import { OpenAPI } from &apos;@/api-client/requests&apos;;
import { InternalAxiosRequestConfig } from &apos;axios&apos;;
import { refreshToken } from &apos;@/services/auth/refresh-token.service.ts&apos;;
import { store } from &apos;@/store&apos;;
export function refreshAccessTokenInterceptor() {
  OpenAPI.interceptors.response.use(
    async (response) =&gt; {
      const request = response.config as AccessTokenRequest;
      if (response?.status === 401 || response?.status === 403 &amp;&amp; !request?._didRetry) {
        const requestToken = request.headers.get(&apos;Authorization&apos;)?.toString().replace(&apos;Bearer &apos;, &apos;&apos;);
        if (!requestToken) {
          console.error(&apos;Unable to find a token on the request&apos;);
          return response;
        }
        const accessToken = store.getState().auth?.accessToken;
        const streamToken = store.getState().auth?.streamToken;
        const isAccessToken = accessToken?.token === requestToken;
        const isStreamToken = streamToken?.token === requestToken;
        let type: &apos;access&apos; | &apos;stream&apos; | undefined = undefined;
        if (isAccessToken) {
          type = &apos;access&apos;;
        } else if (isStreamToken) {
          type = &apos;stream&apos;;
        } else {
          return response;
        }
        request._didRetry = true;
        await refreshToken(type!);
      }
      return response;
    },
  );
}
interface AccessTokenRequest extends InternalAxiosRequestConfig {
  _didRetry?: boolean;
}</file><file path="resources/app/api-client/requests/core/OpenAPI.ts">import type { AxiosRequestConfig, AxiosResponse } from &apos;axios&apos;;
import type { ApiRequestOptions } from &apos;./ApiRequestOptions&apos;;
type Headers = Record&lt;string, string&gt;;
type Middleware&lt;T&gt; = (value: T) =&gt; T | Promise&lt;T&gt;;
type Resolver&lt;T&gt; = (options: ApiRequestOptions&lt;T&gt;) =&gt; Promise&lt;T&gt;;
export class Interceptors&lt;T&gt; {
  _fns: Middleware&lt;T&gt;[];
  constructor() {
    this._fns = [];
  }
  eject(fn: Middleware&lt;T&gt;): void {
    const index = this._fns.indexOf(fn);
    if (index !== -1) {
      this._fns = [...this._fns.slice(0, index), ...this._fns.slice(index + 1)];
    }
  }
  use(fn: Middleware&lt;T&gt;): void {
    this._fns = [...this._fns, fn];
  }
}
export type OpenAPIConfig = {
	BASE: string;
	CREDENTIALS: &apos;include&apos; | &apos;omit&apos; | &apos;same-origin&apos;;
	ENCODE_PATH?: ((path: string) =&gt; string) | undefined;
	HEADERS?: Headers | Resolver&lt;Headers&gt; | undefined;
	PASSWORD?: string | Resolver&lt;string&gt; | undefined;
	TOKEN?: string | Resolver&lt;string&gt; | undefined;
	USERNAME?: string | Resolver&lt;string&gt; | undefined;
	VERSION: string;
	WITH_CREDENTIALS: boolean;
	interceptors: {
		request: Interceptors&lt;AxiosRequestConfig&gt;;
		response: Interceptors&lt;AxiosResponse&gt;;
	};
};
export const OpenAPI: OpenAPIConfig = {
	BASE: &apos;https://baander.test&apos;,
	CREDENTIALS: &apos;include&apos;,
	ENCODE_PATH: undefined,
	HEADERS: undefined,
	PASSWORD: undefined,
	TOKEN: undefined,
	USERNAME: undefined,
	VERSION: &apos;0.0.1&apos;,
	WITH_CREDENTIALS: false,
	interceptors: {
		request: new Interceptors(),
		response: new Interceptors(),
	},
};</file><file path="resources/app/layouts/dashboard-layout/components/dashboard-menu.tsx">import { Box, Flex, ScrollArea, Text } from &apos;@radix-ui/themes&apos;;
import { NavLink } from &apos;@/ui/nav-link.tsx&apos;;
import { lazyImport } from &apos;@/utils/lazy-import.ts&apos;;
import { Iconify } from &apos;@/ui/icons/iconify.tsx&apos;;
import styles from &apos;./dashboard-menu.module.scss&apos;;
const {BaanderLogo} = lazyImport(() =&gt; import(&apos;@/ui/branding/baander-logo/baander-logo.tsx&apos;), &apos;BaanderLogo&apos;);
interface MenuLink {
  label: string;
  to?: string;
  href?: string;
}
interface MenuSection {
  label: string;
  iconName: string;
  links: MenuLink[];
}
type Menu = MenuSection[];
const menu: Menu = [
  {
    label: &apos;Libraries&apos;,
    iconName: &apos;ion:library&apos;,
    links: [
      {label: &apos;New&apos;, to: &apos;libraries/new&apos;},
      {label: &apos;Manage&apos;, to: &apos;libraries/list&apos;},
    ],
  },
  {
    label: &apos;Music&apos;,
    iconName: &apos;ion:musical-notes&apos;,
    links: [
      {label: &apos;Tasks&apos;, to: &apos;music/tasks&apos;},
    ],
  },
  {
    label: &apos;Users&apos;,
    iconName: &apos;heroicons:user-circle-solid&apos;,
    links: [
      {label: &apos;View list&apos;, to: &apos;users/list&apos;},
      {label: &apos;Prune tokens&apos;, to: &apos;&apos;},
    ],
  },
  {
    label: &apos;System&apos;,
    iconName: &apos;heroicons:cog&apos;,
    links: [
      {label: &apos;Logs&apos;, to: &apos;system/log-viewer&apos;},
      {label: &apos;OpCache&apos;, to: &apos;&apos;},
      {label: &apos;Queue monitor&apos;, to: &apos;system/queue-monitor&apos;},
      {label: &apos;Php&apos;, to: &apos;system/php&apos;}
    ],
  },
  {
    label: &apos;Documentation&apos;,
    iconName: &apos;heroicons:book-open-20-solid&apos;,
    links: [
      {label: &apos;Api&apos;, href: route(&apos;scramble.docs.ui&apos;)},
    ],
  },
];
export function DashboardMenu() {
  return (
    &lt;Box className={styles.sidebar}&gt;
      &lt;Flex align=&quot;center&quot; justify=&quot;center&quot; py=&quot;4&quot;&gt;
        &lt;BaanderLogo /&gt;
      &lt;/Flex&gt;
      &lt;ScrollArea&gt;
        &lt;Box className={styles.menuContainer}&gt;
          &lt;NavLink to=&quot;/&quot; className={styles.homeLink}&gt;
            &lt;Flex align=&quot;center&quot; gap=&quot;2&quot;&gt;
              &lt;Iconify icon=&quot;heroicons:home&quot; /&gt;
              &lt;Text&gt;Home&lt;/Text&gt;
            &lt;/Flex&gt;
          &lt;/NavLink&gt;
          {menu.map((section: MenuSection, index: number) =&gt; (
            &lt;Box key={index} className={styles.menuSection}&gt;
              &lt;Text className={styles.sectionTitle}&gt;
                &lt;Flex align=&quot;center&quot; gap=&quot;2&quot;&gt;
                  &lt;Iconify icon={section.iconName} /&gt;
                  {section.label}
                &lt;/Flex&gt;
              &lt;/Text&gt;
              &lt;Box className={styles.linksList}&gt;
                {section.links.map((link: MenuLink, linkIndex: number) =&gt; (
                  link.to ? (
                    &lt;NavLink 
                      key={linkIndex} 
                      to={link.to} 
                      className={styles.menuLink}
                      activeClassName={styles.activeLink}
                    &gt;
                      {link.label}
                    &lt;/NavLink&gt;
                  ) : link.href ? (
                    &lt;a 
                      key={linkIndex} 
                      href={link.href} 
                      className={styles.menuLink}
                    &gt;
                      {link.label}
                    &lt;/a&gt;
                  ) : null
                ))}
              &lt;/Box&gt;
            &lt;/Box&gt;
          ))}
        &lt;/Box&gt;
      &lt;/ScrollArea&gt;
    &lt;/Box&gt;
  );
}</file><file path="resources/app/layouts/root-layout/components/root-menu.module.scss">.sidebar {
  width: 250px;
  height: 100%;
  background-color: var(--color-panel);
  border-right: 1px solid var(--gray-5);
  overflow: hidden;
  display: flex;
  flex-direction: column;
}
.menuContainer {
  padding: 1rem;
}
.homeLink {
  display: block;
  padding: 0.875rem 1rem;
  margin-bottom: 1.5rem;
  border-radius: 4px;
  color: var(--gray-12);
  text-decoration: none;
  transition: background-color 0.2s;
  &amp;:hover {
    background-color: var(--gray-4);
  }
}
.menuSection {
  margin-top: 1.5rem;
  margin-bottom: 2rem;
}
.sectionTitle {
  font-size: 0.875rem;
  font-weight: 600;
  color: var(--gray-11);
  margin-bottom: 0.75rem;
  padding: 0.75rem 0 0.5rem;
}
.linksList {
  display: flex;
  flex-direction: column;
  gap: 0.5rem;
}
.menuLink {
  display: block;
  margin-left: 0.5rem;
  border-radius: 4px;
  color: var(--gray-11);
  text-decoration: none;
  font-size: 0.875rem;
  transition: background-color 0.2s, color 0.2s;
  &amp;:hover {
    background-color: var(--gray-4);
    color: var(--gray-12);
  }
}
.activeLink {
  background-color: var(--accent-3);
  color: var(--accent-11);
  font-weight: 500;
  &amp;:hover {
    background-color: var(--accent-4);
    color: var(--accent-11);
  }
}
.subsectionHeader {
  font-weight: 600;
  color: var(--gray-12);
  &amp;:hover {
    color: var(--gray-12);
  }
}
.subsectionItem {
  padding-left: 0.5rem !important;
  margin-left: 0.3rem !important;
}
.innerSectionItem {
  padding-left: 1.5rem;
  margin-left: 3rem;
  color: var(--gray-10);
}
.innerSectionHeader {
  font-weight: 500;
  margin-left: 2.5rem;
  color: var(--gray-11);
  &amp;:hover {
    color: var(--gray-12);
  }
}
.deepestLevelItem {
  padding-left: 1.5rem;
  font-size: 0.75rem;
  margin-left: 4rem;
  color: var(--gray-9);
  &amp;:hover {
    color: var(--gray-11);
  }
}</file><file path="resources/app/modules/auth/routes/login.module.scss">.loginContainer {
  display: flex;
  flex-direction: row;
  justify-content: space-between;
  align-items: center;
  gap: 30px;
  min-height: 80vh;
  padding: 20px;
  max-width: 1200px;
  margin: 0 auto;
}
.formContent {
  flex: 1;
  max-width: 400px;
  .welcomeText {
    margin-bottom: 10px;
  }
  .tagline {
    margin-bottom: 20px;
  }
}
.form {
  display: flex;
  flex-direction: column;
  padding: 40px;
  border-radius: 10px;
  box-shadow: 0 4px 20px rgba(0, 0, 0, 0.1);
  position: relative;
}
.animationSection {
  position: absolute;
  top: 0;
  left: 0;
  width: 64px;
  height: 64px;
  pointer-events: none;
  transform: translate(-35%, -35%);
}
.animation {
  width: 100%;
  height: 100%;
  object-fit: contain;
}
.links {
  margin-top: 15px;
  a {
    color: #007bff;
    text-decoration: none;
    cursor: pointer;
    &amp;:hover {
      text-decoration: underline;
    }
  }
}
@media screen and (max-width: 900px) {
  .loginContainer {
    flex-direction: column;
    gap: 40px;
  }
}</file><file path="resources/app/modules/dashboard/documentation/musicbrainz/musicbrainz-schema.tsx">export function MusicBrainzSchema() {
  // const { data } = useSchemaServiceSchemaFetchSchema();
  return (
    &lt;div style={{ height: &apos;100%&apos;, width: &apos;100%&apos; }}&gt;
      {/*{data &amp;&amp; &lt;RngVisualizer*/}
      {/*  data={{*/}
      {/*    name: &apos;MusicBrainz Schema&apos;,*/}
      {/*    // children: data,*/}
      {/*  }}/&gt;}*/}
    &lt;/div&gt;
  );
}</file><file path="resources/app/modules/dashboard/routes.tsx">import { Navigate, Route, Routes } from &apos;react-router-dom&apos;;
import { LibrariesList } from &apos;@/modules/dashboard/libraries/libraries-list.tsx&apos;;
import { LibrariesNew } from &apos;@/modules/dashboard/libraries/libraries-new.tsx&apos;;
import { LogViewer } from &apos;@/modules/dashboard/routes/log-viewer.tsx&apos;;
import { QueueMonitor } from &apos;@/modules/dashboard/queue-monitor/queue-monitor.tsx&apos;;
import { UsersList } from &apos;@/modules/dashboard/users/users-list.tsx&apos;;
import { Php } from &apos;@/modules/dashboard/system-info/php.tsx&apos;;
import { DashboardHome } from &apos;@/modules/dashboard/dashboard-home/dashboard-home.tsx&apos;;
import { MusicTasks } from &apos;@/modules/dashboard/music/MusicTasks.tsx&apos;;
export const DashboardRoutes = () =&gt; {
  return (
    &lt;Routes&gt;
      &lt;Route path=&quot;/home&quot; element={&lt;DashboardHome/&gt;}/&gt;
      &lt;Route path=&quot;libraries/list&quot; element={&lt;LibrariesList/&gt;}/&gt;
      &lt;Route path=&quot;libraries/new&quot; element={&lt;LibrariesNew/&gt;}/&gt;
      &lt;Route path=&quot;music/tasks&quot; element={&lt;MusicTasks /&gt;} /&gt;
      &lt;Route path=&quot;system/log-viewer&quot; element={&lt;LogViewer/&gt;}/&gt;
      &lt;Route path=&quot;system/queue-monitor&quot; element={&lt;QueueMonitor/&gt;}/&gt;
      &lt;Route path=&quot;system/php&quot; element={&lt;Php/&gt;}/&gt;
      &lt;Route path=&quot;users/list&quot; element={&lt;UsersList/&gt;}/&gt;
      &lt;Route path=&quot;*&quot; element={&lt;Navigate to=&quot;/home&quot;/&gt;}/&gt;
    &lt;/Routes&gt;
  );
};</file><file path="resources/app/modules/equalizer/components/power.tsx">import { Iconify } from &apos;@/ui/icons/iconify.tsx&apos;;
import { Button } from &apos;@radix-ui/themes&apos;;
export interface PowerProps {
  [key: string]: any;
  isActive: boolean;
  handleOnPowerClick: () =&gt; void;
}
export function Power(props: PowerProps) {
  const { handleOnPowerClick, isActive, ...rest } = props;
  return (
    &lt;div {...rest}&gt;
      &lt;Button
        onClick={() =&gt; handleOnPowerClick()}
        // @ts-expect-error
        c={isActive ? &apos;orange&apos; : &apos;gray&apos;}
      &gt;
        &lt;Iconify icon=&quot;ph:power&quot; fontSize={16} /&gt;
      &lt;/Button&gt;
    &lt;/div&gt;
  );
}</file><file path="resources/app/modules/equalizer/equalizer.tsx">import { Grid } from &apos;@radix-ui/themes&apos;;
import { vfdFrequencyBars } from &apos;@/modules/equalizer/vfd-frequency-bars.ts&apos;;
import { VfdDisplay } from &apos;@/modules/equalizer/components/vfd-display.tsx&apos;;
import { Knob } from &apos;@/modules/equalizer/components/knob.tsx&apos;;
import { Description } from &apos;@/modules/equalizer/components/description.tsx&apos;;
import { EqButton } from &apos;@/modules/equalizer/components/eq-button.tsx&apos;;
import { Power } from &apos;@/modules/equalizer/components/power.tsx&apos;;
import { useAppDispatch, useAppSelector } from &apos;@/store/hooks.ts&apos;;
import {
  setIsStereoEnabled,
  setIsEnabled as setIsEqualizerEnabled,
  setIsKaraokeEnabled,
  setMicrophoneBooster,
  setIsMicrophoneEnabled,
  setTrebleBooster,
  setMiddleBooster,
  setBassBooster,
  setBalance, setBarsMode,
} from &apos;@/store/audio/equalizer.ts&apos;;
import { setIsMuted, setVolume } from &apos;@/store/music/music-player-slice.ts&apos;;
import styles from &apos;./equalizer.module.scss&apos;;
export function Equalizer() {
  const dispatch = useAppDispatch();
  const {
    isEnabled: isEqualizerEnabled,
    isStereoEnabled: isStereoEnabledEnabled,
    isMicrophoneEnabled: isMicrophoneEnabledEnabled,
    isKaraokeEnabled: isKaraokeEnabledEnabled,
    balance: channelBalanceValue,
    barsMode: barsModeValue,
  } = useAppSelector(state =&gt; state.equalizer);
  const { source } = useAppSelector((state) =&gt; state.musicPlayer);
  const {
    treble: trebleValue,
    middle: middleValue,
    bass: bassValue,
  } = useAppSelector((state) =&gt; state.equalizer.boostThreeBands);
  const { isMuted, level: volumeLevelValue } = useAppSelector(
    (state) =&gt; state.musicPlayer.volume,
  );
  const { isRepeatEnabled, isShuffleEnabled } = useAppSelector(
    (state) =&gt; state.musicPlayer.mode,
  );
  const {
    isKaraokeEnabled,
    isMicrophoneEnabled,
    isStereoEnabled,
    microphoneBoost,
  } = useAppSelector((state) =&gt; state.equalizer);
  const { leftChannel, rightChannel, frequencies } = useAppSelector(
    (state) =&gt; state.musicPlayer.analysis,
  );
  const onEqPowerClick = () =&gt; {
    setTimeout(() =&gt; {
      dispatch(setIsEqualizerEnabled(!isEqualizerEnabled));
    }, 200);
  };
  const onEqStereoClick = () =&gt; {
    dispatch(setIsStereoEnabled(!isStereoEnabledEnabled));
  };
  const onEqMuteClick = () =&gt; {
    dispatch(setIsMuted(!isMuted));
  };
  const onEqKaraokeClick = () =&gt; {
    if (isMicrophoneEnabledEnabled)
      dispatch(setIsKaraokeEnabled(!isKaraokeEnabledEnabled));
  };
  const onEqMicrophoneClick = () =&gt; {
    if (!isMicrophoneEnabledEnabled) {
      dispatch(setIsKaraokeEnabled(true));
      dispatch(setMicrophoneBooster(10));
      dispatch(setIsMicrophoneEnabled(true));
    } else {
      dispatch(setMicrophoneBooster(0));
      dispatch(setIsMicrophoneEnabled(false));
    }
  };
  const onEqResetClick = () =&gt; {
    dispatch(setTrebleBooster(0));
    dispatch(setMiddleBooster(0));
    dispatch(setBassBooster(0));
    dispatch(setBalance(50));
    dispatch(setBarsMode(&apos;bars&apos;));
  };
  const onEqBarsModeClick = () =&gt; {
    switch (barsModeValue) {
      case &apos;bars&apos;:
        dispatch(setBarsMode(&apos;pointer&apos;));
        break;
      case &apos;pointer&apos;:
        dispatch(setBarsMode(&apos;off&apos;));
        break;
      case &apos;off&apos;:
        dispatch(setBarsMode(&apos;bars&apos;));
        break;
    }
  };
  const handleVolumeChange = (value: number) =&gt; {
    dispatch(setVolume(value));
  };
  const handleTrebleChange = (value: number) =&gt; {
    dispatch(setTrebleBooster(value));
  };
  const handleMiddleChange = (value: number) =&gt; {
    dispatch(setMiddleBooster(value));
  };
  const handleBassChange = (value: number) =&gt; {
    dispatch(setBassBooster(value));
  };
  const handleBalanceChange = (value: number) =&gt; {
    dispatch(setBalance(value));
  };
  const handleMicrophoneChange = (value: number) =&gt; {
    dispatch(setMicrophoneBooster(value));
  };
  return (
    &lt;Grid className={styles.eqContainer}&gt;
      &lt;Grid columns=&quot;3&quot; gap=&quot;3&quot; className={styles.gridCol}&gt;
        &lt;Power
          className={styles.power}
          isActive={isEqualizerEnabled}
          handleOnPowerClick={onEqPowerClick}
        /&gt;
        &lt;Knob
          isIndicatorsVisible={true}
          className=&quot;volume&quot;
          name=&quot;Volume&quot;
          leftLabel=&quot;MIN&quot;
          rightLabel=&quot;MAX&quot;
          isEnabled={isEqualizerEnabled}
          value={volumeLevelValue}
          onChange={handleVolumeChange}
        /&gt;
        &lt;div className={`${styles.buttonsContainer} buttons`}&gt;
          &lt;EqButton label=&quot;Stereo&quot; handleOnClick={onEqStereoClick}/&gt;
          &lt;EqButton label=&quot;Mute&quot; handleOnClick={onEqMuteClick}/&gt;
          &lt;EqButton label=&quot;Mic&quot; handleOnClick={onEqMicrophoneClick}/&gt;
          &lt;EqButton label=&quot;Karaoke&quot; handleOnClick={onEqKaraokeClick}/&gt;
          &lt;EqButton
            title=&quot;Resets knobs and display&quot;
            className={styles.reset}
            label=&quot;Reset&quot;
            handleOnClick={onEqResetClick}
          /&gt;
          &lt;EqButton
            className={styles.barsMode}
            label=&quot;BARS MODE&quot;
            handleOnClick={onEqBarsModeClick}
          /&gt;
        &lt;/div&gt;
        &lt;Description label=&quot;Three band&quot; className=&quot;tones&quot;/&gt;
      &lt;/Grid&gt;
      &lt;Grid columns=&quot;5&quot; gap=&quot;2&quot; className={styles.knobCol}&gt;
        &lt;Knob
          className={styles.treble}
          name=&quot;Treble&quot;
          leftLabel=&quot;L&quot;
          rightLabel=&quot;H&quot;
          isEnabled={isEqualizerEnabled}
          onChange={handleTrebleChange}
          value={trebleValue}
        /&gt;
        &lt;Knob
          className={styles.middle}
          name=&quot;Middle&quot;
          leftLabel=&quot;L&quot;
          rightLabel=&quot;H&quot;
          isEnabled={isEqualizerEnabled}
          onChange={handleMiddleChange}
          value={middleValue}
        /&gt;
        &lt;Knob
          className={styles.bass}
          name=&quot;Bass&quot;
          leftLabel=&quot;L&quot;
          rightLabel=&quot;H&quot;
          isEnabled={isEqualizerEnabled}
          onChange={handleBassChange}
          value={bassValue}
        /&gt;
        &lt;Knob
          className={styles.balance}
          name=&quot;Balance&quot;
          leftLabel=&quot;L&quot;
          rightLabel=&quot;R&quot;
          isEnabled={isEqualizerEnabled}
          onChange={handleBalanceChange}
          value={channelBalanceValue}
        /&gt;
        &lt;Knob
          className={styles.mic}
          name=&quot;Microphone&quot;
          leftLabel=&quot;L&quot;
          rightLabel=&quot;H&quot;
          value={microphoneBoost}
          onChange={handleMicrophoneChange}
          isEnabled={isEqualizerEnabled &amp;&amp; isMicrophoneEnabledEnabled}
        /&gt;
      &lt;/Grid&gt;
      &lt;VfdDisplay
        className=&quot;vfd&quot;
        isEnabled={isEqualizerEnabled}
        audioSource={source}
        isMuted={isMuted}
        isRepeatEnabled={isRepeatEnabled}
        isShuffleEnabled={isShuffleEnabled}
        isMicrophoneEnabled={isMicrophoneEnabled}
        leftChannel={leftChannel}
        rightChannel={rightChannel}
        isStereoEnabled={isStereoEnabled}
        isKaraokeEnabled={isKaraokeEnabled}
        frequencies={frequencies}
        frequencyBars={vfdFrequencyBars}
        barsMode={barsModeValue}
      /&gt;
    &lt;/Grid&gt;
  );
}</file><file path="resources/app/modules/library-movies/components/movie-list/movie-list.tsx">import { forwardRef } from &apos;react&apos;;
import { VirtuosoGrid, Components } from &apos;react-virtuoso&apos;;
import { MediaItem } from &apos;@/ui/media-library/media-item/media-item.tsx&apos;;
import { useMovieServiceGetApiLibrariesByLibraryMovies } from &apos;@/api-client/queries&apos;;
import { MovieResource } from &apos;@/api-client/requests&apos;;
// Ensure that this stays out of the component,
// Otherwise the grid will remount with each render due to new component instances.
const gridComponents: Components&lt;MovieResource&gt; = {
    List: forwardRef(({ style, children, ...props }, ref) =&gt; (
      &lt;div
        ref={ref}
        {...props}
        style={{
          display: &apos;flex&apos;,
          flexWrap: &apos;wrap&apos;,
          ...style,
        }}
      &gt;
        {children}
      &lt;/div&gt;
    )),
    Item: ({ children, ...props }) =&gt; (
      &lt;div
        {...props}
        style={{
          padding: &apos;0.5rem&apos;,
          width: &apos;33%&apos;,
          display: &apos;flex&apos;,
          flex: &apos;none&apos;,
          alignContent: &apos;stretch&apos;,
          boxSizing: &apos;border-box&apos;,
        }}
      &gt;
        {children}
      &lt;/div&gt;
    ),
  }
;
export function MovieList() {
  const {
    data,
  } = useMovieServiceGetApiLibrariesByLibraryMovies({
    library: &apos;movies&apos;
  })
  return (
    &lt;&gt;
      &lt;VirtuosoGrid
        style={{ display: &apos;flex&apos;, flexWrap: &apos;wrap&apos;, flex: 1, overflowY: &apos;unset&apos; }}
        data={data?.data ?? []}
        totalCount={data?.meta.total}
        // @ts-expect-error
        components={gridComponents}
        itemContent={(index, data) =&gt; &lt;MediaItem key={index} item={data}/&gt;}
      /&gt;
    &lt;/&gt;
  );
}</file><file path="resources/app/modules/library-music-player/components/player-face-plate/player-face-plate.module.scss">.progressContainer {
  justify-content: space-between;
  width: 100%;
}</file><file path="resources/app/modules/library-music-player/components/player-meta-controls/player-meta-controls.module.scss">.playerMetaControls {
  display: flex;
  justify-content: center;
  align-items: center;
  height: 100%;
  flex-grow: 1;
}
.lyrics {
  background-color: transparent;
  border: unset;
  cursor: pointer;
  color: var(--accent-10);
  transition: color 150ms ease-in-out;
  &amp;:hover {
    color: var(--primary-text-hover);
  }
  &amp;[aria-disabled=&quot;true&quot;] {
    color: var(--gray-4);
    pointer-events: none;
    cursor: not-allowed;
  }
}</file><file path="resources/app/modules/library-music-player/components/progress-bar/progress-bar.tsx">import { Slider } from &apos;radix-ui&apos;;
import styles from &apos;./progress-bar.module.css&apos;;
interface ProgressBarProps {
  duration: number;
  currentProgress: number;
  buffered: number;
  setProgress: (currentProgress: number) =&gt; void;
}
export function ProgressBar({ duration, currentProgress, setProgress }: ProgressBarProps) {
  // const progressBarWidth = isNaN(currentProgress / duration)
  //   ? 0
  //   : currentProgress / duration;
  // const bufferedWidth = isNaN(buffered / duration) ? 0 : buffered / duration;
  // // @ts-ignore
  // const progressStyles: ProgressCSSProps = {
  //   &apos;--progress-width&apos;: progressBarWidth,
  //   &apos;--buffered-width&apos;: bufferedWidth,
  // };
  return (
    &lt;Slider.Root
      className={styles.Root}
      min={0}
      defaultValue={[currentProgress]}
      max={Number(duration)}
      onValueChange={(progress) =&gt; setProgress(progress[0])}
    &gt;
      &lt;Slider.Track className={styles.Track}&gt;
        &lt;Slider.Range className={styles.RangeProgress}/&gt;
        {/*&lt;Slider.Range className={styles.RangeProgress}/&gt;*/}
      &lt;/Slider.Track&gt;
      &lt;Slider.Thumb className={styles.Thumb} aria-label=&quot;Song progress&quot;/&gt;
    &lt;/Slider.Root&gt;
  );
}</file><file path="resources/app/modules/library-music/components/scroll-list/scroll-list.tsx">import React, { useEffect, useState } from &apos;react&apos;;
import { Virtuoso } from &apos;react-virtuoso&apos;;
import { Separator, Text } from &apos;@radix-ui/themes&apos;;
import styles from &apos;./scroll-list.module.scss&apos;;
export interface ScrollListItem {
  label: string;
  key?: string;
}
interface ScrollListProps extends React.HTMLProps&lt;HTMLDivElement&gt; {
  listItems: ScrollListItem[];
  totalCount: number;
  header?: string;
  onItemPress?: (item?: ScrollListItem) =&gt; void;
  style?: React.CSSProperties;
}
export function ScrollList({ header, listItems, totalCount, onItemPress, style }: ScrollListProps) {
  const [activeIndex, setActiveIndex] = useState(0);
  useEffect(() =&gt; {
    if (listItems &amp;&amp; listItems.length &gt; 0 &amp;&amp; listItems[0].key !== &apos;*&apos;) {
      listItems.splice(0, 0, { label: &apos;Any&apos;, key: &apos;*&apos; });
    }
  }, [listItems]);
  return (
    &lt;div className={styles.scrollList}&gt;
      {header &amp;&amp; (
        &lt;&gt;
          &lt;Text size=&quot;3&quot; className={styles.title}&gt;{header}&lt;/Text&gt;
          &lt;Separator/&gt;
        &lt;/&gt;
      )}
      &lt;Virtuoso&lt;ScrollListItem&gt;
        totalCount={totalCount}
        style={style}
        components={{
          Scroller,
        }}
        itemContent={(index) =&gt; {
          return (
            &lt;div
              className={`${styles.listItem} ${activeIndex === index ? styles.activeItem : &apos;&apos;}`}
              onClick={() =&gt; {
                setActiveIndex(index);
                const item = listItems[index];
                if (onItemPress) {
                  if (item.key === &apos;*&apos;) {
                    onItemPress();
                  } else {
                    onItemPress(item);
                  }
                }
              }}
            &gt;
              &lt;Text size=&quot;3&quot;&gt;{listItems[index].label}&lt;/Text&gt;
            &lt;/div&gt;
          );
        }}
      /&gt;
    &lt;/div&gt;
  );
}
interface ScrollerProps {
  style: React.CSSProperties;
  [key: string]: any;
}
const Scroller = React.forwardRef&lt;HTMLDivElement, ScrollerProps&gt;(({ style, ...props }, ref) =&gt; {
  // an alternative option to assign the ref is
  // &lt;div ref={(r) =&gt; ref.current = r}&gt;
  return &lt;div className={styles.scrollbar} style={{ ...style }} ref={ref} {...props} /&gt;;
});</file><file path="resources/app/modules/library-music/routes/_routes.tsx">import { Navigate, Route, Routes } from &apos;react-router-dom&apos;;
import Artists from &apos;@/modules/library-music/routes/artists.tsx&apos;;
import Albums  from &apos;@/modules/library-music/routes/albums.tsx&apos;;
import Songs   from &apos;@/modules/library-music/routes/songs.tsx&apos;;
export const LibraryMusicRoutes = () =&gt; {
  return (
    &lt;Routes&gt;
      &lt;Route path=&quot;/artists&quot; element={&lt;Artists/&gt;}&gt;&lt;/Route&gt;
      &lt;Route path=&quot;/albums&quot; element={&lt;Albums/&gt;}&gt;&lt;/Route&gt;
      &lt;Route path=&quot;/songs&quot; element={&lt;Songs/&gt;}&gt;&lt;/Route&gt;
      &lt;Route path=&quot;/*&quot; element={&lt;Navigate to=&quot;/&quot; /&gt;} /&gt;
    &lt;/Routes&gt;
  );
};
export interface LibraryParams {
  library: string;
}</file><file path="resources/app/modules/library-music/routes/albums.module.scss">.albumsLayout {
    display: flex;
    flex-wrap: wrap;
}
.sidebar {
    flex-basis: 25rem;
    flex-grow: 1;
}
.grid {
    flex-basis: 0;
    flex-grow: 999;
}</file><file path="resources/app/modules/library-music/routes/songs.tsx">import { ScrollList, ScrollListItem } from &apos;@/modules/library-music/components/scroll-list&apos;;
import { Flex } from &apos;@radix-ui/themes&apos;;
import {
  useAlbumServiceGetApiLibrariesByLibraryAlbums,
  useArtistServiceGetApiLibrariesByLibraryArtists,
  useGenreServiceGetApiGenres,
} from &apos;@/api-client/queries&apos;;
import { useEffect, useState } from &apos;react&apos;;
import { SongList } from &apos;@/modules/library-music/components/song-list/song-list.tsx&apos;;
import { GenreResource } from &apos;@/api-client/requests&apos;;
import { usePathParam } from &apos;@/hooks/use-path-param.ts&apos;;
import { LibraryParams } from &apos;@/modules/library-music/routes/_routes.tsx&apos;;
export default function Songs() {
  const { library } = usePathParam&lt;LibraryParams&gt;();
  const { data: genreData } = useGenreServiceGetApiGenres({ librarySlug: library });
  const [genres, setGenres] = useState&lt;ScrollListItem[]&gt;([]);
  const [selectedGenres, setSelectedGenres] = useState&lt;ScrollListItem | undefined&gt;();
  useEffect(() =&gt; {
    if (genreData) {
      const data = genreData.data.map((x: GenreResource) =&gt; ({
        label: x.name,
        key: x.slug,
      }));
      setGenres(data);
    }
  }, [genreData]);
  const { data: albumData } = useAlbumServiceGetApiLibrariesByLibraryAlbums({
    library,
    genres: selectedGenres?.key ?? undefined,
  });
  const [albums, setAlbums] = useState&lt;ScrollListItem[]&gt;([]);
  useEffect(() =&gt; {
    if (albumData) {
      const items = albumData.data.map(x =&gt; ({
        label: x.title,
        key: x.slug,
      }));
      setAlbums(items);
    }
  }, [albumData]);
  const { data: artistData } = useArtistServiceGetApiLibrariesByLibraryArtists({ library });
  const [artists, setArtists] = useState&lt;ScrollListItem[]&gt;([]);
  useEffect(() =&gt; {
    if (artistData) {
      const items = artistData.data.map(x =&gt; ({
        label: x.name,
        key: x.slug,
      }));
      setArtists(items);
    }
  }, [artistData]);
  return (
    &lt;&gt;
      &lt;Flex style={{ width: &apos;100vw&apos; }}&gt;
        &lt;ScrollList
          header=&quot;Genres&quot;
          listItems={genres}
          totalCount={genres.length}
          style={{ height: 150 }}
          onItemPress={item =&gt; setSelectedGenres(item)}
        /&gt;
        &lt;ScrollList
          header=&quot;Artists&quot;
          listItems={artists}
          totalCount={artists.length}
          style={{ height: 150 }}
        /&gt;
        &lt;ScrollList
          header=&quot;Albums&quot;
          listItems={albums}
          totalCount={albums.length}
          style={{ height: 150 }}
        /&gt;
      &lt;/Flex&gt;
      &lt;SongList/&gt;
    &lt;/&gt;
  );
}</file><file path="resources/app/modules/user-settings/features/passkeys/create-passkey.tsx">import { useWebauthn } from &apos;@/hooks/use-webauthn.ts&apos;;
import { Button, Flex, TextField } from &apos;@radix-ui/themes&apos;;
import { AuthService } from &apos;@/api-client/requests&apos;;
import { useForm } from &apos;react-hook-form&apos;;
import { Iconify } from &apos;@/ui/icons/iconify.tsx&apos;;
import { useEffect } from &apos;react&apos;;
type FormValues = {
  name: string,
}
export function CreatePasskey() {
  const { startRegistration, browserSupportsWebAuthn } = useWebauthn();
  const form = useForm&lt;FormValues&gt;({
  });
  useEffect(() =&gt; {
    if (!browserSupportsWebAuthn) {
      alert(&apos;WebAuthn is not supported by your browser&apos;);
    }
  }, []);
  const onSubmit = async (values: FormValues) =&gt; {
    const options = await AuthService.getWebauthnPasskeyRegister();
    // @ts-ignore
    const registration = await startRegistration(options);
    AuthService.postWebauthnPasskeyRegister({
      requestBody: {
        name: values.name,
        passkey: JSON.stringify(registration),
      },
    }).then((res) =&gt; {
      console.log(res);
    });
  };
  return (
    &lt;form
      onSubmit={form.handleSubmit(onSubmit)}
    &gt;
      &lt;Flex gap=&quot;2&quot;&gt;
        &lt;TextField.Root
          {...form.register(&apos;name&apos;)}
        &gt;
          &lt;TextField.Slot&gt;
            &lt;Iconify icon=&quot;ion:key-outline&quot; /&gt;
          &lt;/TextField.Slot&gt;
        &lt;/TextField.Root&gt;
        &lt;Flex mt=&quot;md&quot;&gt;
          &lt;Button type=&quot;submit&quot;&gt;Create&lt;/Button&gt;
        &lt;/Flex&gt;
      &lt;/Flex&gt;
    &lt;/form&gt;
  );
}</file><file path="resources/app/modules/user-settings/features/tokens/token-detail.tsx">import { PersonalAccessTokenViewResource } from &apos;@/api-client/requests&apos;;
import { Code, Badge, Card, DataList } from &apos;@radix-ui/themes&apos;;
import { useDateFormatter } from &apos;@/providers/dayjs-provider.tsx&apos;;
import { DateTime } from &apos;@/ui/dates/date-time.tsx&apos;;
export interface TokenDetailProps {
  item: PersonalAccessTokenViewResource;
}
export function TokenDetail({ item }: TokenDetailProps) {
  const { fromNow } = useDateFormatter();
  return (
    &lt;Card&gt;
      &lt;DataList.Root&gt;
        &lt;DataList.Item&gt;
          &lt;DataList.Label&gt;Name&lt;/DataList.Label&gt;
          &lt;DataList.Value&gt;{item.name}&lt;/DataList.Value&gt;
        &lt;/DataList.Item&gt;
        {item.abilities &amp;&amp; (
          &lt;DataList.Item&gt;
            &lt;DataList.Label&gt;Abilities&lt;/DataList.Label&gt;
            &lt;DataList.Value&gt;
              {item.abilities &amp;&amp; (
                &lt;&gt;
                  {item.abilities.map((ability, index) =&gt; &lt;Badge key={index} variant=&quot;soft&quot; radius=&quot;full&quot;&gt;{ability}&lt;/Badge&gt;)}
                &lt;/&gt;
              )}
            &lt;/DataList.Value&gt;
          &lt;/DataList.Item&gt;
        )}
        &lt;DataList.Item&gt;
          &lt;DataList.Label&gt;User Agent&lt;/DataList.Label&gt;
          &lt;DataList.Value&gt;
            &lt;Code&gt;{item.userAgent}&lt;/Code&gt;
          &lt;/DataList.Value&gt;
        &lt;/DataList.Item&gt;
        &lt;DataList.Item&gt;
          &lt;DataList.Label&gt;Client Type&lt;/DataList.Label&gt;
          &lt;DataList.Value&gt;{item.clientType ?? &apos;&apos;}&lt;/DataList.Value&gt;
        &lt;/DataList.Item&gt;
        &lt;DataList.Item&gt;
          &lt;DataList.Label&gt;Client Name&lt;/DataList.Label&gt;
          &lt;DataList.Value&gt;{item.clientName ?? &apos;&apos;}&lt;/DataList.Value&gt;
        &lt;/DataList.Item&gt;
        &lt;DataList.Item&gt;
          &lt;DataList.Label&gt;Client Version&lt;/DataList.Label&gt;
          &lt;DataList.Value&gt;{item.clientVersion ?? &apos;&apos;}&lt;/DataList.Value&gt;
        &lt;/DataList.Item&gt;
        &lt;DataList.Item&gt;
          &lt;DataList.Label&gt;Device OS&lt;/DataList.Label&gt;
          &lt;DataList.Value&gt;{item.deviceOperatingSystem ?? &apos;&apos;}&lt;/DataList.Value&gt;
        &lt;/DataList.Item&gt;
        &lt;DataList.Item&gt;
          &lt;DataList.Label&gt;Device Name&lt;/DataList.Label&gt;
          &lt;DataList.Value&gt;{item.deviceName ?? &apos;&apos;}&lt;/DataList.Value&gt;
        &lt;/DataList.Item&gt;
        &lt;DataList.Item&gt;
          &lt;DataList.Label&gt;Created&lt;/DataList.Label&gt;
          &lt;DataList.Value&gt;
            &lt;DateTime date={item.createdAt ?? &apos;&apos;} /&gt;
          &lt;/DataList.Value&gt;
        &lt;/DataList.Item&gt;
        &lt;DataList.Item&gt;
          &lt;DataList.Label&gt;Expires&lt;/DataList.Label&gt;
          &lt;DataList.Value&gt;
            &lt;DateTime date={item.expiresAt ?? &apos;&apos;} /&gt;
          &lt;/DataList.Value&gt;
        &lt;/DataList.Item&gt;
        &lt;DataList.Item&gt;
          &lt;DataList.Label&gt;Last used&lt;/DataList.Label&gt;
          &lt;DataList.Value&gt;{fromNow(item.lastUsedAt) ?? &apos;&apos;}&lt;/DataList.Value&gt;
        &lt;/DataList.Item&gt;
      &lt;/DataList.Root&gt;
    &lt;/Card&gt;
  );
}</file><file path="resources/app/modules/user-settings/layouts/settings-page-layout.tsx">import { ReactNode } from &apos;react&apos;;
import { Container, Heading } from &apos;@radix-ui/themes&apos;;
export interface SettingsPageLayoutProps {
  title: string;
  children?: ReactNode;
}
export function SettingsPageLayout({title, children}: SettingsPageLayoutProps) {
  return (
    &lt;Container&gt;
      &lt;Heading mt=&quot;2&quot; mb=&quot;2&quot;&gt;{title}&lt;/Heading&gt;
      &lt;main&gt;{children}&lt;/main&gt;
    &lt;/Container&gt;
  )
}</file><file path="resources/app/store/hooks.ts">import { useDispatch, useSelector } from &apos;react-redux&apos;
import { RootState, AppDispatch } from &apos;./index&apos;
export const useAppDispatch = useDispatch.withTypes&lt;AppDispatch&gt;()
export const useAppSelector = useSelector.withTypes&lt;RootState&gt;()</file><file path="resources/app/ui/feedback/loading/beach-ball.tsx">import { motion } from &apos;motion/react&apos;;
import { CSSProperties } from &apos;react&apos;;
export const BeachBall = () =&gt; {
  const transitionValues = {
    duration: 0.8,
    yoyo: Infinity,
    ease: &apos;easeOut&apos;,
  };
  // @ts-expect-error
  const ballStyle = {
    display: &apos;block&apos;,
    width: &apos;5rem&apos;,
    height: &apos;5rem&apos;,
    borderRadius: &apos;50%&apos;,
    margin: &apos;auto&apos;,
    position: &apos;relative&apos;,
    background: &apos;conic-gradient(red, yellow, green, blue, red)&apos;,
    boxShadow: &apos;0 3px 6px rgba(0, 0, 0, 0.2)&apos;,
  };
  const highlightStyle: CSSProperties = {
    position: &apos;absolute&apos;,
    top: &apos;10%&apos;,
    left: &apos;10%&apos;,
    width: &apos;30%&apos;,
    height: &apos;30%&apos;,
    background: &apos;rgba(255, 255, 255, 0.6)&apos;,
    borderRadius: &apos;50%&apos;,
    filter: &apos;blur(5px)&apos;,
    pointerEvents: &apos;none&apos;,
  };
  return (
    &lt;motion.div
      // style={ballStyle}
      transition={transitionValues}
      animate={{
        rotate: [0, 360],
      }}
    &gt;
      &lt;span style={highlightStyle}/&gt;
    &lt;/motion.div&gt;
  );
};</file><file path="resources/app/ui/lyrics-viewer/lyrics-viewer.tsx">import { motion } from &quot;motion/react&quot;
import { Box, Flex, IconButton, Popover, Tooltip } from &apos;@radix-ui/themes&apos;;
import { LyricsAnimation } from &apos;@/ui/lyrics-viewer/components/lyrics-animation/lyrics-animation.tsx&apos;;
import { useAudioPlayer } from &apos;@/modules/library-music-player/providers/audio-player-provider.tsx&apos;;
import { MixerHorizontalIcon } from &apos;@radix-ui/react-icons&apos;;
import { LyricsSettings } from &apos;@/ui/lyrics-viewer/components/lyrics-settings/lyrics-settings.tsx&apos;;
import styles from &apos;./lyrics-viewer.module.scss&apos;;
const AnimatedBackground = motion.div;
export function LyricsViewer() {
  const { currentProgress } = useAudioPlayer();
  const { song } = useAudioPlayer();
  const backgroundVariants = {
    initial: {
      filter: &apos;blur(0px)&apos;,
    },
    animate: {
      filter: &apos;blur(16px)&apos;,
      transition: {
        duration: 1,
      },
    },
  };
  return (
    &lt;Box className={styles.lyricsContainer}&gt;
      &lt;AnimatedBackground
        className={styles.background}
        initial=&quot;initial&quot;
        animate=&quot;animate&quot;
        layout
        variants={backgroundVariants}
        style={{
          backgroundImage: `url(${song?.album?.cover?.url ?? &apos;&apos;})`,
          backgroundSize: &apos;cover&apos;,
          backgroundPosition: &apos;center&apos;,
        }}
      /&gt;
      &lt;div className={styles.overlay} /&gt;
      &lt;LyricsAnimation currentTime={currentProgress}/&gt;
      &lt;Flex className={styles.footer}&gt;
        &lt;Popover.Root&gt;
          &lt;Popover.Trigger&gt;
            &lt;Tooltip content=&quot;Lyrics settings&quot;&gt;
              &lt;IconButton style={{ cursor: &apos;pointer&apos; }}&gt;
                &lt;MixerHorizontalIcon /&gt;
              &lt;/IconButton&gt;
            &lt;/Tooltip&gt;
          &lt;/Popover.Trigger&gt;
          &lt;Popover.Content&gt;
            &lt;LyricsSettings /&gt;
          &lt;/Popover.Content&gt;
        &lt;/Popover.Root&gt;
      &lt;/Flex&gt;
    &lt;/Box&gt;
  );
}</file><file path="resources/app/ui/lyrics-viewer/providers/lyrics-provider.tsx">import React, { createContext, ReactEventHandler, ReactNode, useContext, useEffect, useState } from &apos;react&apos;;
import { Lrc } from &apos;@/libs/lyrics/lrc.ts&apos;;
import { AudioLyricSynchronizer } from &apos;@/libs/lyrics/audio-lyric-synchronizer.ts&apos;;
import { useAudioPlayer } from &apos;@/modules/library-music-player/providers/audio-player-provider.tsx&apos;;
import { useAppSelector } from &apos;@/store/hooks.ts&apos;;
interface LyricsProviderContextProps {
  lyrics: Lrc | undefined;
  synchronizer: AudioLyricSynchronizer | undefined;
  setLyrics: (lyrics?: string | undefined) =&gt; void;
}
const LyricsProviderContext = createContext&lt;LyricsProviderContextProps | undefined&gt;(undefined);
LyricsProviderContext.displayName = &apos;LyricsProviderContext&apos;;
const LyricsProvider: React.FC&lt;{ children: ReactNode }&gt; = ({ children }) =&gt; {
  const { lyrics: lyricOptions } = useAppSelector(state =&gt; state.musicPlayer);
  const [lyrics, _setLyrics] = useState&lt;Lrc&gt;();
  const { song } = useAudioPlayer();
  const audioLyricsSynchronizer = new AudioLyricSynchronizer();
  const { audioRef } = useAudioPlayer();
  useEffect(() =&gt; {
    if (lyricOptions.offsetMs &amp;&amp; audioLyricsSynchronizer.defaultOffset !== lyricOptions.offsetMs) {
      audioLyricsSynchronizer.setDefaultOffset(lyricOptions.offsetMs);
    }
  }, [lyricOptions, audioLyricsSynchronizer]);
  useEffect(() =&gt; {
    if (song?.lyrics) {
      setLyrics(song.lyrics);
    }
  }, [song, song?.lyrics]);
  useEffect(() =&gt; {
    const handler: ReactEventHandler&lt;HTMLAudioElement&gt; = () =&gt; {
      audioLyricsSynchronizer.timeUpdate(audioRef.current.currentTime);
    };
    const audioRefCurrent = audioRef.current;
    // @ts-ignore
    audioRefCurrent.addEventListener(&apos;timeupdate&apos;, handler);
    return () =&gt; {
      // @ts-ignore
      audioRefCurrent.removeEventListener(&apos;timeupdate&apos;, handler);
    };
  }, []);
  const setLyrics = (value?: string | undefined) =&gt; {
    if (!value) {
      _setLyrics(undefined);
      return;
    }
    const lrc = Lrc.parse(value);
    _setLyrics(lrc);
    audioLyricsSynchronizer.setLrc(lrc);
  };
  return (
    &lt;LyricsProviderContext.Provider value={{
      lyrics,
      setLyrics: setLyrics,
      synchronizer: audioLyricsSynchronizer,
    }}&gt;
      {children}
    &lt;/LyricsProviderContext.Provider&gt;
  );
};
LyricsProvider.displayName = &apos;LyricsProvider&apos;;
const useLyrics = () =&gt; {
  const context = useContext(LyricsProviderContext);
  if (!context) {
    throw new Error(&apos;useLyrics must be used within a LyricsProvider&apos;);
  }
  return context;
};
export {
  LyricsProvider,
  useLyrics,
};</file><file path="resources/app/ui/media-library/media-item/media-item.tsx">import { Box, Text } from &apos;@radix-ui/themes&apos;;
import { MovieResource } from &apos;@/api-client/requests&apos;;
export interface MediaItemProps {
  item: MovieResource;
}
export function MediaItem({ item }: MediaItemProps) {
  return (
    &lt;Box&gt;
      &lt;img src={&apos;https://placehold.co/180x260&apos;}  alt=&quot;&quot;/&gt;
      &lt;Text&gt;{item.title}&lt;/Text&gt;
    &lt;/Box&gt;
  )
}</file><file path="resources/app/ui/nav-link.tsx">import * as React from &apos;react&apos;;
import { ReactNode } from &apos;react&apos;;
import { Link as RouterNavLink, RelativeRoutingType, To } from &apos;react-router-dom&apos;;
import { Box, Link as RadixLink } from &apos;@radix-ui/themes&apos;;
import { clsx } from &apos;clsx&apos;;
interface NavLinkProps {
  to: To;
  children?: React.ReactNode;
  reloadDocument?: boolean;
  replace?: boolean;
  state?: any;
  preventScrollReset?: boolean;
  relative?: RelativeRoutingType;
  className?: string;
  activeClassName?: string;
  label?: string;
  leftSection?: ReactNode;
  rightSection?: ReactNode;
}
export function NavLink({
                          children,
                          to,
                          reloadDocument,
                          replace,
                          state,
                          preventScrollReset,
                          relative,
                          className,
                          activeClassName = &apos;active-class&apos;,
                          label,
                          leftSection,
                          rightSection,
                          ...rest
                        }: NavLinkProps) {
  return (
    &lt;Box&gt;
      {leftSection &amp;&amp; &lt;div&gt;{leftSection}&lt;/div&gt;}
      &lt;RadixLink asChild&gt;
        &lt;RouterNavLink
          to={to}
          reloadDocument={reloadDocument}
          replace={replace}
          state={state}
          preventScrollReset={preventScrollReset}
          relative={relative}
          className={clsx(
            className,
            ({ isActive }: { isActive: boolean }) =&gt;
              clsx(className, {
                [activeClassName]: isActive,
              }))}
          {...rest}
        &gt;
          {label &amp;&amp; &lt;span className=&quot;sr-only&quot;&gt;{label}&lt;/span&gt;}
          {children}
        &lt;/RouterNavLink&gt;
      &lt;/RadixLink&gt;
      {rightSection &amp;&amp; &lt;div&gt;{rightSection}&lt;/div&gt;}
    &lt;/Box&gt;
  );
}</file><file path="resources/app/ui/schema/rng-visualizer/rng-visualizer.tsx">import { ReactNode, useMemo, useRef } from &apos;react&apos;;
import { Circle, Group, Layer, Line, Rect, Stage, Text } from &apos;react-konva&apos;;
import { hierarchy, Tree } from &apos;@visx/hierarchy&apos;;
import { Zoom } from &apos;@visx/zoom&apos;;
import { NodeProps } from &apos;@visx/hierarchy/lib/HierarchyDefaultNode&apos;;
import { useSize } from &apos;ahooks&apos;;
const peach = &apos;#fd9b93&apos;;
const pink = &apos;#fe6e9e&apos;;
const blue = &apos;#03c0dc&apos;;
const green = &apos;#26deb0&apos;;
const plum = &apos;#71248e&apos;;
const lightpurple = &apos;#374469&apos;;
const white = &apos;#ffffff&apos;;
const background = &apos;#eea947&apos;;
interface TreeNode {
  name: string;
  attributes: Record&lt;string, string&gt;;
  children?: TreeNode[];
}
interface RngVisualizerProps {
  data: TreeNode;
  margin?: { top: number; right: number; bottom: number; left: number };
}
interface HierarchyNode extends NodeProps {
  data: TreeNode;
  depth: number;
  height: number;
  parent: HierarchyNode;
  x: number;
  y: number;
}
const defaultMargin = { top: 50, left: 100, right: 100, bottom: 50 };
const NodeLabel = ({ node }: { node: HierarchyNode }) =&gt; {
  const attributes = typeof node.data.attributes === &apos;object&apos;
                     ? Object.entries(node.data.attributes)
                             .map(([key, value]) =&gt; `${key}: ${value}`)
                             .join(&apos;, &apos;)
                     : &apos;&apos;;
  return (
    &lt;&gt;
      &lt;Text text={node.data.name} fontSize={9} fontFamily=&quot;Arial&quot; fill={plum} y={-20} align=&quot;center&quot; /&gt;
      &lt;Text text={attributes} fontSize={9} fontFamily=&quot;Arial&quot; fill={white} y={0} align=&quot;center&quot; /&gt;
    &lt;/&gt;
  );
};
const RootNode = ({ node }: { node: HierarchyNode }) =&gt; (
  &lt;Group x={node.x} y={node.y}&gt;
    &lt;Circle radius={12}
            fillLinearGradientStartPoint={{ x: -12, y: 0 }}
            fillLinearGradientEndPoint={{ x: 12, y: 0 }}
            fillLinearGradientColorStops={[0, peach, 1, pink]} /&gt;
    &lt;NodeLabel node={node} /&gt;
  &lt;/Group&gt;
);
const ParentNode = ({ node }: { node: HierarchyNode }) =&gt; (
  &lt;Group x={node.x} y={node.y}&gt;
    &lt;Rect
      width={80}
      height={40}
      offsetX={40}
      offsetY={20}
      fill={background}
      stroke={blue}
      strokeWidth={1}
    /&gt;
    &lt;NodeLabel node={node} /&gt;
  &lt;/Group&gt;
);
const LeafNode = ({ node }: { node: HierarchyNode }) =&gt; {
  console.log(node);
  return (
    &lt;Group x={node.x} y={node.y}&gt;
      &lt;Rect
        width={80}
        height={60}
        offsetX={40}
        offsetY={20}
        fill={background}
        stroke={green}
        strokeWidth={1}
        dash={[4, 4]}
        strokeOpacity={0.6}
        cornerRadius={5}
      /&gt;
      &lt;NodeLabel node={node}/&gt;
    &lt;/Group&gt;
  );
};
const Node = ({ node }: { node: HierarchyNode }) =&gt; {
  if (node?.depth === 0) return &lt;RootNode node={node} /&gt;;
  // @ts-expect-error
  if (node?.children) return &lt;ParentNode node={node} /&gt;;
  return &lt;LeafNode node={node} /&gt;;
};
const initialTransform = {
  scaleX: 1.27,
  scaleY: 1.27,
  translateX: -211.62,
  translateY: 162.59,
  skewX: 0,
  skewY: 0,
};
export function RngVisualizer({
                                data,
                                margin = defaultMargin,
                              }: RngVisualizerProps): ReactNode | null {
  const root = useMemo(() =&gt; hierarchy(data), [data]);
  const ref = useRef&lt;HTMLDivElement&gt;(null);
  const size = useSize(ref);
  const xMax = (size &amp;&amp; size.width - margin.left - margin.right) || 50;
  const yMax = (size &amp;&amp; size.height - margin.top - margin.bottom) || 50;
  if (!size || size.width &lt; 10 || size.height &lt; 10) {
    // return null;
  }
  return (
    &lt;div ref={ref} style={{ width: &apos;100%&apos;, height: &apos;inherit&apos;, border: &apos;1px solid red&apos; }}&gt;
      &lt;Stage width={size?.width ?? 1000} height={size?.height ?? 1000}&gt;
        &lt;Layer&gt;
          &lt;Zoom
            width={size?.width ?? 100}
            height={size?.height ?? 100}
            scaleXMin={0.5}
            scaleXMax={4}
            scaleYMin={0.5}
            scaleYMax={4}
            initialTransformMatrix={initialTransform}
          &gt;
            {(zoom) =&gt; (
              &lt;Group
                x={margin.left}
                y={margin.top}
                scaleX={zoom.transformMatrix.scaleX}
                scaleY={zoom.transformMatrix.scaleY}
                offsetX={zoom.transformMatrix.translateX}
                offsetY={zoom.transformMatrix.translateY}
              &gt;
                &lt;Tree&lt;TreeNode&gt; root={root} size={[xMax, yMax]} nodeSize={[200, 75]}&gt;
                  {(tree) =&gt; (
                    &lt;&gt;
                      {tree.links().map((link, i) =&gt; (
                        &lt;Line
                          key={`link-${i}`}
                          points={[link.source.x, link.source.y, link.target.x, link.target.y]}
                          stroke={lightpurple}
                          strokeWidth={1}
                        /&gt;
                      ))}
                      {tree.descendants().map((node, i) =&gt; (
                        // @ts-expect-error
                        &lt;Node key={`node-${i}`} node={node}/&gt;
                      ))}
                    &lt;/&gt;
                  )}
                &lt;/Tree&gt;
              &lt;/Group&gt;
            )}
          &lt;/Zoom&gt;
        &lt;/Layer&gt;
      &lt;/Stage&gt;
    &lt;/div&gt;
  );
}</file><file path="resources/app/ui/user-button/user-button.tsx">import styles from &apos;./user-button.module.scss&apos;;
import { Button, Text } from &apos;@radix-ui/themes&apos;;
import { useUserServiceGetApiUsersMe } from &apos;@/api-client/queries&apos;;
export function UserButton() {
  const {data} = useUserServiceGetApiUsersMe();
  return (
    &lt;Button className={styles.user} variant=&quot;ghost&quot; size=&quot;1&quot;&gt;
      &lt;Text size=&quot;2&quot; weight=&quot;medium&quot;&gt;
        {data?.name}
      &lt;/Text&gt;
    &lt;/Button&gt;
  );
}</file><file path="resources/app/ui/users/user-table/user-table.tsx">import { ColumnDef, getCoreRowModel, getSortedRowModel, SortingState, useReactTable } from &apos;@tanstack/react-table&apos;;
import { useMemo, useState } from &apos;react&apos;;
import { Iconify } from &apos;@/ui/icons/iconify.tsx&apos;;
import { useUserServiceGetApiUsers } from &apos;@/api-client/queries&apos;;
import { UserResource } from &apos;@/api-client/requests&apos;;
import { Tooltip } from &apos;radix-ui&apos;;
import { Button, Flex, Text } from &apos;@radix-ui/themes&apos;;
import  { Table } from &apos;@radix-ui/themes&apos;;
export function UserTable() {
  const columns = useMemo&lt;ColumnDef&lt;UserResource&gt;[]&gt;(
    () =&gt; [
      {
        accessorKey: &apos;name&apos;,
        header: &apos;Name&apos;,
      },
      {
        accessorKey: &apos;email&apos;,
        header: &apos;Email&apos;,
      },
      {
        accessorKey: &apos;isAdmin&apos;,
        header: &apos;Is Admin&apos;,
      },
      {
        accessorKey: &apos;createdAt&apos;,
        header: &apos;Created at&apos;,
      },
      {
        accessorKey: &apos;updatedAt&apos;,
        header: &apos;Updated at&apos;,
      },
    ],
    [],
  );
  const [sorting, setSorting] = useState&lt;SortingState&gt;([]);
  const [pagination, setPagination] = useState({
    pageIndex: 0,
    pageSize: 30,
  });
  const { data, isLoading, refetch } = useUserServiceGetApiUsers({
    sorting: JSON.stringify(sorting),
    page: pagination.pageIndex,
    limit: pagination.pageSize,
  });
  const fetchedUsers = data?.data ?? [];
  const table = useReactTable({
    data: fetchedUsers,
    rowCount: data?.meta?.total,
    columns,
    state: {
      sorting,
      pagination,
    },
    manualSorting: true,
    manualPagination: true,
    getCoreRowModel: getCoreRowModel(),
    getSortedRowModel: getSortedRowModel(),
    onSortingChange: setSorting,
    onPaginationChange: setPagination,
  });
  return (
    &lt;&gt;
      &lt;Flex justify=&quot;end&quot; mb=&quot;2&quot;&gt;
        &lt;Tooltip.Root&gt;
          &lt;Tooltip.Trigger asChild&gt;
            &lt;Button onClick={() =&gt; refetch()} disabled={isLoading}&gt;
              &lt;Iconify icon=&quot;eva:refresh-fill&quot;/&gt;
            &lt;/Button&gt;
          &lt;/Tooltip.Trigger&gt;
          &lt;Tooltip.Portal&gt;
            &lt;Tooltip.Content&gt;
              Refresh
            &lt;/Tooltip.Content&gt;
          &lt;/Tooltip.Portal&gt;
        &lt;/Tooltip.Root&gt;
      &lt;/Flex&gt;
      &lt;Table.Root&gt;
        &lt;Table.Header&gt;
          &lt;Table.Row&gt;
            {table.getHeaderGroups()[0]?.headers.map((header, index) =&gt; (
              &lt;Table.ColumnHeaderCell key={index}&gt;
                {header.isPlaceholder ? null : (
                  &lt;Flex 
                    style={{ cursor: header.column.getCanSort() ? &apos;pointer&apos; : &apos;default&apos; }}
                    onClick={header.column.getToggleSortingHandler()}
                  &gt;
                    {header.column.columnDef.header instanceof Function
                      ? header.column.columnDef.header(header.getContext())
                      : header.column.columnDef.header}
                    {header.column.getIsSorted() === &apos;asc&apos; 
                      ? &apos; 🔼&apos; 
                      : header.column.getIsSorted() === &apos;desc&apos; 
                        ? &apos; 🔽&apos; 
                        : &apos;&apos;}
                  &lt;/Flex&gt;
                )}
              &lt;/Table.ColumnHeaderCell&gt;
            ))}
          &lt;/Table.Row&gt;
        &lt;/Table.Header&gt;
        &lt;Table.Body&gt;
          {table.getRowModel().rows.map((row, rowIndex) =&gt; (
            &lt;Table.Row key={rowIndex}&gt;
              {row.getVisibleCells().map((cell, cellIndex) =&gt; (
                cellIndex === 0 ? (
                  &lt;Table.RowHeaderCell key={cellIndex}&gt;
                    {cell.column.columnDef.cell instanceof Function
                      ? cell.column.columnDef.cell(cell.getContext())
                      : cell.getValue()}
                  &lt;/Table.RowHeaderCell&gt;
                ) : (
                  &lt;Table.Cell key={cellIndex}&gt;
                    {cell.column.columnDef.cell instanceof Function
                      ? cell.column.columnDef.cell(cell.getContext())
                      : cell.getValue()}
                  &lt;/Table.Cell&gt;
                )
              ))}
            &lt;/Table.Row&gt;
          ))}
        &lt;/Table.Body&gt;
      &lt;/Table.Root&gt;
      &lt;Flex justify=&quot;between&quot; align=&quot;center&quot; mt=&quot;4&quot;&gt;
        &lt;Button 
          onClick={() =&gt; table.previousPage()}
          disabled={!table.getCanPreviousPage()}
        &gt;
          Previous
        &lt;/Button&gt;
        &lt;Text&gt;
          Page {table.getState().pagination.pageIndex + 1} of{&apos; &apos;}
          {table.getPageCount()}
        &lt;/Text&gt;
        &lt;Button
          onClick={() =&gt; table.nextPage()}
          disabled={!table.getCanNextPage()}
        &gt;
          Next
        &lt;/Button&gt;
      &lt;/Flex&gt;
    &lt;/&gt;
  );
}</file><file path="routes/channels.php">&lt;?php</file><file path="routes/web.php">&lt;?php
use Illuminate\Support\Facades\Route;
Route::get(&apos;/dbg&apos;, [\App\Http\Controllers\UIController::class, &apos;dbg&apos;])-&gt;name(&apos;dbg&apos;);
Route::get(&apos;/{any}&apos;, [\App\Http\Controllers\UIController::class, &apos;getUI&apos;])
    -&gt;name(&apos;webui&apos;)
    -&gt;where(&apos;any&apos;, &apos;^(?!api|docs|storage|public-api|clockwork|system|2fa|login|dbg|jobs).*$&apos;);</file><file path=".env.example">APP_NAME=Bånder
APP_ENV=production
APP_KEY=
APP_DEBUG=false
APP_URL=https://baander.test
ASSET_URL=https://baander.test
SANCTUM_STATEFUL_DOMAINS=https://baander.test

LOG_CHANNEL=stack
LOG_DEPRECATIONS_CHANNEL=null
LOG_LEVEL=info

DB_CONNECTION=&quot;pgsql&quot;
DB_HOST=&quot;postgres&quot;
DB_PORT=&quot;5432&quot;
DB_DATABASE=&quot;baander&quot;
DB_USERNAME=&quot;baander&quot;
DB_PASSWORD=&quot;baander&quot;

BROADCAST_CONNECTION=reverb
BROADCAST_DRIVER=reverb
CACHE_DRIVER=redis
FILESYSTEM_DISK=local
QUEUE_CONNECTION=redis
SESSION_DRIVER=redis
SESSION_CONNECTION=sessions
SESSION_LIFETIME=120

PASSPORT_PERSONAL_ACCESS_CLIENT_ID=1
PASSPORT_PERSONAL_ACCESS_CLIENT_SECRET=

REDIS_CLIENT=phpredis
REDIS_HOST=redis
REDIS_PASSWORD=null
REDIS_PORT=6379

MAIL_MAILER=smtp
MAIL_HOST=mailpit
MAIL_PORT=1025
MAIL_USERNAME=null
MAIL_PASSWORD=null
MAIL_ENCRYPTION=null
MAIL_FROM_ADDRESS=&quot;noreply@baander.test&quot;
MAIL_FROM_NAME=&quot;${APP_NAME}&quot;

TASTE_DIVE_API_KEY=

VITE_APP_NAME=&quot;${APP_NAME}&quot;
VITE_APP_URL=&quot;https://baander.test&quot;

REVERB_APP_ID=199099
REVERB_APP_KEY=ws
REVERB_APP_SECRET=
REVERB_HOST=&quot;baander.test&quot;
REVERB_PORT=8080

VITE_REVERB_APP_KEY=&quot;${REVERB_APP_KEY}&quot;
VITE_REVERB_HOST=&quot;${REVERB_HOST}&quot;
VITE_REVERB_PORT=&quot;443&quot;
VITE_REVERB_SCHEME=&quot;${REVERB_SCHEME}&quot;</file><file path="app/Http/Controllers/Api/Auth/Concerns/HandlesUserTokens.php">&lt;?php
namespace App\Http\Controllers\Api\Auth\Concerns;
use App\Http\Resources\Auth\NewAccessTokenResource;
use App\Models\{PersonalAccessToken, TokenAbility, User};
use Illuminate\Http\Request;
use Illuminate\Support\Carbon;
trait HandlesUserTokens
{
    private function createTokenSet(Request $request, User $user)
    {
        $device = PersonalAccessToken::prepareDeviceFromRequest($request);
        $accessToken = $user-&gt;createToken(
            name: &apos;access_token&apos;,
            abilities: [TokenAbility::ACCESS_API-&gt;value, TokenAbility::ACCESS_BROADCASTING-&gt;value],
            expiresAt: Carbon::now()-&gt;addMinutes(config(&apos;sanctum.access_token_expiration&apos;)),
            device: $device,
        );
        $refreshToken = $user-&gt;createToken(
            name: &apos;refresh_token&apos;,
            abilities: [TokenAbility::ISSUE_ACCESS_TOKEN-&gt;value],
            expiresAt: Carbon::now()-&gt;addMinutes(config(&apos;sanctum.refresh_token_expiration&apos;)),
            device: $device,
        );
        return response()-&gt;json([
            &apos;accessToken&apos;  =&gt; new NewAccessTokenResource($accessToken),
            &apos;refreshToken&apos; =&gt; new NewAccessTokenResource($refreshToken),
        ]);
    }
}</file><file path="app/Http/Controllers/Api/PlaylistController.php">&lt;?php
namespace App\Http\Controllers\Api;
use App\Http\Controllers\Controller;
use App\Http\Requests\Playlist\{CreatePlaylistRequest,
    CreateSmartPlaylistRequest,
    PlaylistShowRequest,
    UpdatePlaylistRequest,
    UpdateSmartPlaylistRulesRequest};
use App\Http\Resources\Playlist\PlaylistResource;
use App\Models\{Playlist, PlaylistStatistic, Song, TokenAbility, User};
use App\Modules\Pagination\JsonPaginator;
use Illuminate\Http\Request;
use Illuminate\Http\Resources\Json\AnonymousResourceCollection;
use Illuminate\Support\Facades\Auth;
use Spatie\RouteAttributes\Attributes\{Delete, Get, Middleware, Post, Prefix, Put};
#[Middleware([&apos;force.json&apos;])]
#[Prefix(&apos;/playlists&apos;)]
class PlaylistController extends Controller
{
    /**
     * Get a collection of playlists
     *
     * @param Request $request
     * @return AnonymousResourceCollection&lt;JsonPaginator&lt;PlaylistResource&gt;&gt;
     */
    #[Get(&apos;&apos;, &apos;api.playlist.index&apos;, [&apos;auth:sanctum&apos;, &apos;ability:&apos; . TokenAbility::ACCESS_API-&gt;value])]
    public function index(Request $request)
    {
        $playlists = Playlist::whereUserId($request-&gt;user()-&gt;id)
            -&gt;orWhere(&apos;is_public&apos;, true)
            -&gt;paginate();
        return PlaylistResource::collection($playlists);
    }
    /**
     * Create a playlist
     *
     * @param CreatePlaylistRequest $request
     * @return PlaylistResource
     * @throws \Throwable
     */
    #[Post(&apos;&apos;, &apos;api.playlist.store&apos;, [&apos;auth:sanctum&apos;, &apos;ability:&apos; . TokenAbility::ACCESS_API-&gt;value])]
    public function store(CreatePlaylistRequest $request)
    {
        $playlist = new Playlist([
            &apos;name&apos;        =&gt; $request-&gt;get(&apos;name&apos;),
            &apos;description&apos; =&gt; $request-&gt;get(&apos;description&apos;),
            &apos;is_public&apos;   =&gt; $request-&gt;boolean(&apos;is_public&apos;),
        ]);
        $playlist-&gt;user()-&gt;associate($request-&gt;user());
        $playlist-&gt;saveOrFail();
        return new PlaylistResource($playlist);
    }
    /**
     * Show a playlist
     *
     * @param Playlist $playlist
     * @return PlaylistResource
     */
    #[Get(&apos;{playlist}&apos;, &apos;api.playlist.show&apos;, [&apos;auth:sanctum&apos;, &apos;ability:&apos; . TokenAbility::ACCESS_API-&gt;value])]
    public function show(PlaylistShowRequest $request, Playlist $playlist)
    {
        $this-&gt;authorize(&apos;view&apos;, $playlist);
        $playlist-&gt;loadMissing(&apos;cover&apos;, &apos;songs&apos;, &apos;songs.artists&apos;, &apos;songs.album&apos;);
        return new PlaylistResource($playlist);
    }
    /**
     * Update a playlist
     *
     * @param UpdatePlaylistRequest $request
     * @param Playlist $playlist
     * @return PlaylistResource
     */
    #[Put(&apos;{playlist}&apos;, &apos;api.playlist.update&apos;, [&apos;auth:sanctum&apos;, &apos;ability:&apos; . TokenAbility::ACCESS_API-&gt;value])]
    public function update(UpdatePlaylistRequest $request, Playlist $playlist)
    {
        $this-&gt;authorize(&apos;update&apos;, $playlist);
        $playlist-&gt;update([
            &apos;name&apos;        =&gt; $request-&gt;get(&apos;name&apos;),
            &apos;description&apos; =&gt; $request-&gt;get(&apos;description&apos;),
            &apos;is_public&apos;   =&gt; $request-&gt;boolean(&apos;is_public&apos;),
        ]);
        return new PlaylistResource($playlist);
    }
    /**
     * Delete a playlist
     *
     * @param Playlist $playlist
     * @return \Illuminate\Http\Response
     */
    #[Delete(&apos;{playlist}&apos;, &apos;api.playlist.destroy&apos;, [&apos;auth:sanctum&apos;, &apos;ability:&apos; . TokenAbility::ACCESS_API-&gt;value])]
    public function destroy(Playlist $playlist)
    {
        $this-&gt;authorize(&apos;delete&apos;, $playlist);
        $playlist-&gt;delete();
        return response()-&gt;noContent();
    }
    /**
     * Add a song
     *
     * @param Playlist $playlist
     * @param Song $song
     * @return \Illuminate\Http\JsonResponse
     */
    #[Post(&apos;{playlist}/songs/{song}&apos;, &apos;api.playlist.add-song&apos;, [&apos;auth:sanctum&apos;,
                                                                &apos;ability:&apos; . TokenAbility::ACCESS_API-&gt;value])]
    public function addSong(Playlist $playlist, Song $song)
    {
        $this-&gt;authorize(&apos;update&apos;, $playlist);
        // Prevent duplicate songs in playlist
        if (!$playlist-&gt;songs()-&gt;where(&apos;song_id&apos;, $song-&gt;id)-&gt;exists()) {
            $position = $playlist-&gt;songs()-&gt;max(&apos;position&apos;) + 1;
            $playlist-&gt;songs()-&gt;attach($song, [&apos;position&apos; =&gt; $position]);
        }
        return response()-&gt;json([&apos;message&apos; =&gt; &apos;Song added to playlist&apos;]);
    }
    /**
     * Remove a song
     *
     * @param Playlist $playlist
     * @param Song $song
     * @return \Illuminate\Http\JsonResponse
     */
    #[Delete(&apos;{playlist}/songs/{song}&apos;, &apos;api.playlist.remove-song&apos;, [
        &apos;auth:sanctum&apos;,
        &apos;ability:&apos; . TokenAbility::ACCESS_API-&gt;value])
    ]
    public function removeSong(Playlist $playlist, Song $song)
    {
        $this-&gt;authorize(&apos;update&apos;, $playlist);
        $playlist-&gt;songs()-&gt;detach($song);
        // Reorder remaining songs
        $playlist-&gt;songs()
            -&gt;get()
            -&gt;each(function ($song, $index) {
                $song-&gt;pivot-&gt;update([&apos;position&apos; =&gt; $index + 1]);
            });
        return response()-&gt;json([&apos;message&apos; =&gt; &apos;Song removed from playlist&apos;]);
    }
    /**
     * Reorder songs
     *
     * @param Request $request
     * @param Playlist $playlist
     * @return \Illuminate\Http\JsonResponse
     */
    #[Post(&apos;{playlist}/reorder&apos;, &apos;api.playlist.reorder&apos;, [
        &apos;auth:sanctum&apos;,
        &apos;ability:&apos; . TokenAbility::ACCESS_API-&gt;value])
    ]
    public function reorderSongs(Request $request, Playlist $playlist)
    {
        $this-&gt;authorize(&apos;update&apos;, $playlist);
        $request-&gt;validate([
            &apos;song_ids&apos;   =&gt; &apos;required|array&apos;,
            &apos;song_ids.*&apos; =&gt; &apos;exists:songs,id&apos;,
        ]);
        $songIds = $request-&gt;song_ids;
        foreach ($songIds as $index =&gt; $songId) {
            $playlist-&gt;songs()-&gt;updateExistingPivot($songId, [
                &apos;position&apos; =&gt; $index + 1,
            ]);
        }
        return response()-&gt;json([&apos;message&apos; =&gt; &apos;Playlist reordered&apos;]);
    }
    /**
     * Add collaborator
     *
     * @param Request $request
     * @param Playlist $playlist
     * @return \Illuminate\Http\JsonResponse
     */
    #[Post(&apos;{playlist}/collaborators&apos;, &apos;api.playlist.collaborators.store&apos;, [
        &apos;auth:sanctum&apos;,
        &apos;ability:&apos; . TokenAbility::ACCESS_API-&gt;value])
    ]
    public function addCollaborator(Request $request, Playlist $playlist)
    {
        $this-&gt;authorize(&apos;update&apos;, $playlist);
        $request-&gt;validate([
            &apos;user_id&apos; =&gt; &apos;required|exists:users,id&apos;,
            &apos;role&apos;    =&gt; &apos;sometimes|in:editor,contributor&apos;,
        ]);
        $playlist-&gt;collaborators()-&gt;syncWithoutDetaching([
            $request-&gt;user_id =&gt; [&apos;role&apos; =&gt; $request-&gt;role ?? &apos;contributor&apos;],
        ]);
        return response()-&gt;json([&apos;message&apos; =&gt; &apos;Collaborator added&apos;]);
    }
    /**
     * Remove collaborator
     *
     * @param Playlist $playlist
     * @param User $user
     * @return \Illuminate\Http\JsonResponse
     */
    #[Delete(&apos;{playlist}/collaborators/{user}&apos;, &apos;api.playlist.collaborators.destroy&apos;, [
        &apos;auth:sanctum&apos;,
        &apos;ability:&apos; . TokenAbility::ACCESS_API-&gt;value])
    ]
    public function removeCollaborator(Playlist $playlist, User $user)
    {
        $this-&gt;authorize(&apos;update&apos;, $playlist);
        $playlist-&gt;collaborators()-&gt;detach($user);
        return response()-&gt;json([&apos;message&apos; =&gt; &apos;Collaborator removed&apos;]);
    }
    /**
     * Clone playlist
     *
     * @param Playlist $playlist
     * @return PlaylistResource
     */
    #[Post(&apos;{playlist}/clone&apos;, &apos;api.playlist.clone&apos;, [&apos;auth:sanctum&apos;, &apos;ability:&apos; . TokenAbility::ACCESS_API-&gt;value])]
    public function clone(Playlist $playlist)
    {
        $this-&gt;authorize(&apos;view&apos;, $playlist);
        $newPlaylist = $playlist-&gt;replicate();
        $newPlaylist-&gt;name = $playlist-&gt;name . &apos; (Copy)&apos;;
        $newPlaylist-&gt;user_id = Auth::id();
        $newPlaylist-&gt;is_public = false;
        $newPlaylist-&gt;is_collaborative = false;
        $newPlaylist-&gt;save();
        // Copy songs with their positions
        $songs = $playlist-&gt;songs()-&gt;get();
        $songData = $songs-&gt;mapWithKeys(function ($song) {
            return [$song-&gt;id =&gt; [&apos;position&apos; =&gt; $song-&gt;pivot-&gt;position]];
        });
        $newPlaylist-&gt;songs()-&gt;sync($songData);
        return new PlaylistResource($newPlaylist);
    }
    /**
     * Get statistics
     *
     * @param Playlist $playlist
     * @return PlaylistStatistic
     */
    #[Get(&apos;{playlist}/statistics&apos;, &apos;api.playlist.statistics&apos;, [
        &apos;auth:sanctum&apos;,
        &apos;ability:&apos; . TokenAbility::ACCESS_API-&gt;value,
    ])]
    public function statistics(Playlist $playlist)
    {
        $this-&gt;authorize(&apos;view&apos;, $playlist);
        $statistic = $playlist-&gt;statistics()-&gt;first();
        return new PlaylistStatistic($statistic);
    }
    /**
     * Statistics - Record view
     *
     * @param Playlist $playlist
     * @return \Illuminate\Http\JsonResponse
     */
    #[Post(&apos;{playlist}/statistics/record/view&apos;, &apos;api.playlist.statistics.record.view&apos;, [
        &apos;auth:sanctum&apos;,
        &apos;ability:&apos; . TokenAbility::ACCESS_API-&gt;value,
    ])]
    public function recordView(Playlist $playlist)
    {
        $this-&gt;authorize(&apos;view&apos;, $playlist);
        $playlist-&gt;incrementViews();
        return response()-&gt;json([&apos;message&apos; =&gt; &apos;View recorded&apos;]);
    }
    /**
     * Statistics - Record play
     *
     * @param Playlist $playlist
     * @return \Illuminate\Http\JsonResponse
     */
    #[Post(&apos;{playlist}/statistics/record/play&apos;, &apos;api.playlist.statistics.record.view&apos;, [
        &apos;auth:sanctum&apos;,
        &apos;ability:&apos; . TokenAbility::ACCESS_API-&gt;value,
    ])]
    public function recordPlay(Playlist $playlist)
    {
        $this-&gt;authorize(&apos;view&apos;, $playlist);
        $playlist-&gt;incrementPlays();
        return response()-&gt;json([&apos;message&apos; =&gt; &apos;Play recorded&apos;]);
    }
    /**
     * Share
     *
     * @param Playlist $playlist
     * @return \Illuminate\Http\JsonResponse
     */
    #[Post(&apos;{playlist}/statistics/record/share&apos;, &apos;api.playlist.statistics.record.view&apos;, [
        &apos;auth:sanctum&apos;,
        &apos;ability:&apos; . TokenAbility::ACCESS_API-&gt;value,
    ])]
    public function share(Playlist $playlist)
    {
        $this-&gt;authorize(&apos;view&apos;, $playlist);
        $playlist-&gt;incrementShares();
        return response()-&gt;json([&apos;message&apos; =&gt; &apos;Share recorded&apos;]);
    }
    /**
     * Favorite
     *
     * @param Playlist $playlist
     * @return \Illuminate\Http\JsonResponse
     */
    #[Post(&apos;{playlist}/statistics/record/favorite&apos;, &apos;api.playlist.statistics.record.view&apos;, [
        &apos;auth:sanctum&apos;,
        &apos;ability:&apos; . TokenAbility::ACCESS_API-&gt;value,
    ])]
    public function favorite(Playlist $playlist)
    {
        $this-&gt;authorize(&apos;view&apos;, $playlist);
        $playlist-&gt;incrementFavorites();
        return response()-&gt;json([&apos;message&apos; =&gt; &apos;Favorite recorded&apos;]);
    }
    /**
     * Smart playlist - Create
     *
     * @param CreateSmartPlaylistRequest $request
     * @return PlaylistResource
     * @throws \Throwable
     */
    #[Post(&apos;/smart&apos;, &apos;api.playlist.smart&apos;, [&apos;auth:sanctum&apos;, &apos;ability:&apos; . TokenAbility::ACCESS_API-&gt;value])]
    public function createSmartPlaylist(CreateSmartPlaylistRequest $request)
    {
//        $this-&gt;authorize(&apos;create&apos;, Playlist::class);
        $playlist = new Playlist([
            &apos;name&apos;        =&gt; $request-&gt;name,
            &apos;description&apos; =&gt; $request-&gt;description,
            &apos;is_public&apos;   =&gt; $request-&gt;boolean(&apos;is_public&apos;),
            &apos;is_smart&apos;    =&gt; true,
            &apos;smart_rules&apos; =&gt; $request-&gt;rules,
        ]);
        $playlist-&gt;user()-&gt;associate($request-&gt;user());
        $playlist-&gt;saveOrFail();
        $playlist-&gt;syncSmartPlaylist();
        return new PlaylistResource($playlist);
    }
    /**
     * Smart playlist - Update rules
     *
     * @param UpdateSmartPlaylistRulesRequest $request
     * @param Playlist $playlist
     * @return PlaylistResource
     */
    #[Put(&apos;{playlist}/smart&apos;, &apos;api.playlist.smart&apos;, [&apos;auth:sanctum&apos;, &apos;ability:&apos; . TokenAbility::ACCESS_API-&gt;value])]
    public function updateSmartRules(UpdateSmartPlaylistRulesRequest $request, Playlist $playlist)
    {
        $this-&gt;authorize(&apos;update&apos;, $playlist);
        if (!$playlist-&gt;is_smart) {
            abort(400, &apos;Not a smart playlist&apos;);
        }
        $playlist-&gt;update([&apos;smart_rules&apos; =&gt; $request-&gt;get(&apos;rules&apos;)]);
        $playlist-&gt;syncSmartPlaylist();
        return new PlaylistResource($playlist);
    }
    /**
     * Smart playlist - Sync
     *
     * @param Playlist $playlist
     * @return \Illuminate\Http\JsonResponse
     */
    #[Post(&apos;{playlist}/smart/sync&apos;, &apos;api.playlist.smart&apos;, [&apos;auth:sanctum&apos;,
                                                           &apos;ability:&apos; . TokenAbility::ACCESS_API-&gt;value])]
    public function syncSmartPlaylist(Playlist $playlist)
    {
        $this-&gt;authorize(&apos;update&apos;, $playlist);
        if (!$playlist-&gt;is_smart) {
            abort(400, &apos;Not a smart playlist&apos;);
        }
        $playlist-&gt;syncSmartPlaylist();
        return response()-&gt;json([&apos;message&apos; =&gt; &apos;Smart playlist synced&apos;]);
    }
}</file><file path="app/Http/Controllers/Api/SystemInfoController.php">&lt;?php
namespace App\Http\Controllers\Api;
use App\Http\Controllers\Controller;
use App\Models\TokenAbility;
use App\Modules\PhpInfoParser\Info;
use App\Services\SystemMetricsCollectorService;
use Spatie\RouteAttributes\Attributes\{Get, Middleware, Prefix};
#[Prefix(&apos;/system-info&apos;)]
#[Middleware([
    &apos;auth:sanctum&apos;,
    &apos;ability:&apos; . TokenAbility::ACCESS_API-&gt;value,
    &apos;force.json&apos;,
])]
class SystemInfoController extends Controller
{
    /**
     * Get php info
     *
     * @response array{
     *   section: string,
     *   values: array{
     *     key: string,
     *     value: string|int|bool|float|null,
     *   }[]
     * }[]
     */
    #[Get(&apos;/&apos;, &apos;api.system-info.php&apos;)]
    public function php()
    {
        $this-&gt;gateCheckViewDashboard();
        return response()-&gt;json(Info::getModules());
    }
    /**
     * @response array{
     *   memoryUsage: int,
     *   systemLoadAverage: int[],
     *   swooleVm: array{
     *     object_num: int,
     *     resource_num: int
     *   }
     * }
     */
    #[Get(&apos;/sys&apos;, &apos;api.system-info.sys&apos;)]
    public function system()
    {
        $this-&gt;gateCheckViewDashboard();
        $service = app(SystemMetricsCollectorService::class);
        return response()-&gt;json([
            &apos;memoryUsage&apos;       =&gt; $service-&gt;memoryUsage(),
            &apos;systemLoadAverage&apos; =&gt; $service-&gt;systemLoadAverage(),
            &apos;swooleVm&apos;          =&gt; $service-&gt;swooleVm(),
        ]);
    }
}</file><file path="app/Http/Controllers/Api/UserTokenController.php">&lt;?php
namespace App\Http\Controllers\Api;
use App\Http\Controllers\Controller;
use App\Http\Requests\UserToken\UserTokenIndexRequest;
use App\Http\Resources\UserToken\PersonalAccessTokenViewResource;
use App\Models\{PersonalAccessToken, TokenAbility};
use App\Modules\Pagination\JsonPaginator;
use Illuminate\Http\Request;
use Illuminate\Http\Resources\Json\AnonymousResourceCollection;
use Spatie\RouteAttributes\Attributes\{Delete, Get, Middleware, Prefix};
#[Prefix(&apos;users/tokens&apos;)]
#[Middleware([
    &apos;auth:sanctum&apos;,
    &apos;ability:&apos; . TokenAbility::ACCESS_API-&gt;value,
    &apos;force.json&apos;,
])]
class UserTokenController extends Controller
{
    /**
     * Get a collection of tokens
     *
     * @param UserTokenIndexRequest $request The HTTP request instance.
     *
     * @return AnonymousResourceCollection&lt;JsonPaginator&lt;PersonalAccessTokenViewResource&gt;&gt; The collection of personal access tokens.
     */
    #[Get(&apos;/{user}&apos;)]
    public function getUserTokens(UserTokenIndexRequest $request)
    {
        $tokens = $request-&gt;user()-&gt;tokens()-&gt;paginate();
        return PersonalAccessTokenViewResource::collection($tokens);
    }
    /**
     * Revoke a given token
     *
     * @param Request $request
     * @param PersonalAccessToken $token
     * @return \Illuminate\Http\Response
     */
    #[Delete(&apos;/{token}&apos;)]
    public function revokeToken(Request $request, PersonalAccessToken $token)
    {
        if ($request-&gt;user()-&gt;id !== $token-&gt;tokenable_id) {
            abort(401);
        }
        $token-&gt;delete();
        return response(null, 204);
    }
}</file><file path="app/Http/Requests/Library/LibraryIndexRequest.php">&lt;?php
namespace App\Http\Requests\Library;
use Illuminate\Foundation\Http\FormRequest;
class LibraryIndexRequest extends FormRequest
{
    /**
     * Determine if the user is authorized to make this request.
     */
    public function authorize(): bool
    {
        return true;
    }
    /**
     * Get the validation rules that apply to the request.
     *
     * @return array&lt;string, \Illuminate\Contracts\Validation\ValidationRule|array&lt;mixed&gt;|string&gt;
     */
    public function rules(): array
    {
        return [
            /**
             * @query
             * Current page
             */
            &apos;page&apos;  =&gt; &apos;int&apos;,
            /**
             * @query
             * Items per page
             */
            &apos;limit&apos; =&gt; &apos;int&apos;,
        ];
    }
}</file><file path="app/Http/Resources/Genre/GenreResource.php">&lt;?php
namespace App\Http\Resources\Genre;
use App\Http\Resources\HasJsonCollection;
use App\Http\Resources\Song\SongResource;
use App\Models\Genre;
use Illuminate\Http\Request;
use Illuminate\Http\Resources\Json\JsonResource;
/**
 * @mixin Genre
 */
class GenreResource extends JsonResource
{
    use HasJsonCollection;
    /**
     * Transform the resource into an array.
     *
     * @return array&lt;string, mixed&gt;
     */
    public function toArray(Request $request): array
    {
        return [
            &apos;name&apos;      =&gt; $this-&gt;name,
            &apos;slug&apos;      =&gt; $this-&gt;slug,
            &apos;createdAt&apos; =&gt; $this-&gt;created_at,
            &apos;updatedAt&apos; =&gt; $this-&gt;updated_at,
            /**
             * Songs relation
             */
            &apos;songs&apos;     =&gt; SongResource::collection($this-&gt;whenLoaded(&apos;songs&apos;)),
        ];
    }
}</file><file path="app/Http/Resources/HasJsonCollection.php">&lt;?php
namespace App\Http\Resources;
use App\Modules\Http\Resources\Json\JsonAnonymousResourceCollection;
trait HasJsonCollection
{
    public static function collection($resource)
    {
        return tap(new JsonAnonymousResourceCollection($resource, static::class), function ($collection) {
            if (property_exists(static::class, &apos;preserveKeys&apos;)) {
                $collection-&gt;preserveKeys = (new static([]))-&gt;preserveKeys === true;
            }
        });
    }
}</file><file path="app/Http/Resources/UserToken/PersonalAccessTokenViewResource.php">&lt;?php
namespace App\Http\Resources\UserToken;
use App\Http\Resources\HasJsonCollection;
use App\Models\PersonalAccessToken;
use Illuminate\Http\Request;
use Illuminate\Http\Resources\Json\JsonResource;
/**
 * @mixin PersonalAccessToken
 */
class PersonalAccessTokenViewResource extends JsonResource
{
    use HasJsonCollection;
    /**
     * Transform the resource into an array.
     *
     * @return array&lt;string, mixed&gt;
     */
    public function toArray(Request $request): array
    {
        return [
            &apos;id&apos;                    =&gt; $this-&gt;id,
            &apos;name&apos;                  =&gt; $this-&gt;name,
            /**
             * @var array&lt;string&gt;|null
             */
            &apos;abilities&apos;             =&gt; $this-&gt;abilities,
            &apos;userAgent&apos;             =&gt; $this-&gt;user_agent,
            &apos;clientName&apos;            =&gt; $this-&gt;client_name,
            &apos;clientVersion&apos;         =&gt; $this-&gt;client_version,
            &apos;clientType&apos;            =&gt; $this-&gt;client_type,
            &apos;deviceOperatingSystem&apos; =&gt; $this-&gt;device_operating_system,
            &apos;deviceName&apos;            =&gt; $this-&gt;device_name,
            &apos;lastUsedAt&apos;            =&gt; $this-&gt;last_used_at,
            &apos;expiresAt&apos;             =&gt; $this-&gt;expires_at,
            &apos;createdAt&apos;             =&gt; $this-&gt;created_at,
            &apos;updatedAt&apos;             =&gt; $this-&gt;updated_at,
        ];
    }
}</file><file path="app/Jobs/Library/Music/SaveAlbumCoverJob.php">&lt;?php
namespace App\Jobs\Library\Music;
use App\Jobs\BaseJob;
use App\Models\Album;
use Illuminate\Contracts\Queue\ShouldQueue;
use Illuminate\Queue\Middleware\WithoutOverlapping;
use App\Modules\MediaMeta\Frame\Apic;
use App\Modules\MediaMeta\MediaMeta;
use Illuminate\Support\Facades\Log;
class SaveAlbumCoverJob extends BaseJob implements ShouldQueue
{
    private Album $album;
    /**
     * Create a new job instance.
     */
    public function __construct(Album $album)
    {
        $this-&gt;album = $album;
    }
    /**
     * Get the middleware the job should pass through.
     *
     * @return array&lt;int, object&gt;
     */
    public function middleware(): array
    {
        return [new WithoutOverlapping(&quot;album_cover_{$this-&gt;album-&gt;id}&quot;)-&gt;dontRelease()];
    }
    /**
     * Execute the job.
     */
    public function handle(): void
    {
        $this-&gt;queueProgress(0);
        try {
            $song = $this-&gt;album-&gt;songs()-&gt;firstOrFail();
            $mediaMeta = new MediaMeta($song-&gt;path);
            $images = $mediaMeta-&gt;getImages();
            $imageCount = count($images);
            if ($imageCount === 0) {
                $this-&gt;queueProgress(100);
                return;
            }
            $this-&gt;queueProgress(50);
            // Use the first image if front cover isn&apos;t available
            try {
                $cover = $mediaMeta-&gt;getFrontCoverImage() ?: $images[0];
            } catch (\Exception $e) {
                Log::warning(&apos;Failed to get front cover, using first available image&apos;, [
                    &apos;error&apos; =&gt; $e-&gt;getMessage(),
                    &apos;album_id&apos; =&gt; $this-&gt;album-&gt;id
                ]);
                $cover = $images[0];
            }
            $imageData = $this-&gt;createImage($cover);
            $this-&gt;queueProgress(75);
            $this-&gt;album-&gt;cover()-&gt;create($imageData);
            $this-&gt;queueProgress(100);
        } catch (\Exception $e) {
            Log::error(&apos;Failed to save album cover&apos;, [
                &apos;album_id&apos; =&gt; $this-&gt;album-&gt;id,
                &apos;error&apos; =&gt; $e-&gt;getMessage(),
                &apos;trace&apos; =&gt; $e-&gt;getTraceAsString()
            ]);
            throw $e;
        } finally {
            // Clean up resources
            unset($this-&gt;album);
        }
    }
    private function createImage(Apic $artwork): array
    {
        $extension = $this-&gt;detectFileExtension($artwork-&gt;getImageData());
        $fileName = $this-&gt;album-&gt;title . &apos;_&apos; . Apic::$types[$artwork-&gt;getImageType()];
        $destination = config(&apos;image.storage.covers&apos;) . DIRECTORY_SEPARATOR . $fileName . &apos;.&apos; . $extension;
        \File::put($destination, $artwork-&gt;getImageData());
        $imageInfo = getimagesize($destination);
        return [
            &apos;extension&apos; =&gt; $extension,
            &apos;path&apos;      =&gt; $destination,
            &apos;mime_type&apos; =&gt; $imageInfo[&apos;mime&apos;],
            &apos;size&apos;      =&gt; $artwork-&gt;getImageSize(),
            &apos;width&apos;     =&gt; $imageInfo[0],
            &apos;height&apos;    =&gt; $imageInfo[1],
        ];
    }
    private function detectFileExtension(string $imageData): string
    {
        $extensions = new \finfo(FILEINFO_EXTENSION)-&gt;buffer($imageData);
        if (!is_string($extensions)) {
            throw new \RuntimeException(&apos;Unable to parse the correct extension for imagedata&apos;);
        }
        $extensions = explode(&apos;/&apos;, $extensions);
        return $extensions[0];
    }
}</file><file path="app/Models/Concerns/IsBaseModel.php">&lt;?php
namespace App\Models\Concerns;
use App\Modules\Eloquent\BaseBuilder;
/**
 * @method BaseBuilder query()
 */
trait IsBaseModel
{
    public function formatForException(): string
    {
        return implode(&apos;|&apos;, [
            get_class($this), &quot;id:$$this-&gt;id&quot;,
        ]);
    }
    public function newEloquentBuilder($query)
    {
        return new BaseBuilder($query);
    }
}</file><file path="app/Models/Passkey.php">&lt;?php
namespace App\Models;
use App\Modules\Webauthn\WebauthnService;
use Database\Factories\PasskeyFactory;
use Illuminate\Database\Eloquent\Casts\Attribute;
use Illuminate\Database\Eloquent\Factories\{Factory, HasFactory};
use ParagonIE\ConstantTime\Base64UrlSafe;
use Webauthn\PublicKeyCredentialSource;
class Passkey extends BaseModel
{
    use HasFactory;
    protected $fillable = [
        &apos;name&apos;,
        &apos;credential_id&apos;,
        &apos;data&apos;,
        &apos;last_used_at&apos;,
        &apos;counter&apos;,
    ];
    protected $casts = [
        &apos;last_used_at&apos; =&gt; &apos;datetime&apos;,
    ];
    public function user()
    {
        return $this-&gt;belongsTo(User::class);
    }
    public function data(): Attribute
    {
        $service = app(WebauthnService::class);
        return new Attribute(
            get: fn(string $value)
                =&gt; $service-&gt;deserialize(
                self::decodeBase64($value),
                PublicKeyCredentialSource::class,
            ),
            set: fn(PublicKeyCredentialSource $value)
                =&gt; [
                &apos;credential_id&apos; =&gt; self::encodeBase64($value-&gt;publicKeyCredentialId),
                &apos;data&apos;          =&gt; $service-&gt;serialize($value),
            ],
        );
    }
    public static function encodeBase64(string $data)
    {
        return Base64UrlSafe::encodeUnpadded($data);
    }
    public static function decodeBase64(string $data)
    {
        return Base64UrlSafe::decodeNoPadding($data);
    }
    protected static function newFactory(): Factory
    {
        return PasskeyFactory::new();
    }
}</file><file path="app/Providers/ScrambleServiceProvider.php">&lt;?php
namespace App\Providers;
use App\Modules\Humanize\HumanDuration;
use Dedoc\Scramble\Scramble;
use Dedoc\Scramble\Support\Generator\OpenApi;
use Dedoc\Scramble\Support\Generator\SecurityScheme;
use Illuminate\Routing\Route;
use Illuminate\Support\ServiceProvider;
use Illuminate\Support\Str;
class ScrambleServiceProvider extends ServiceProvider
{
    /**
     * Bootstrap services.
     */
    public function boot(): void
    {
        $humanDuration = new HumanDuration();
        $accessTokenLifeTime = $humanDuration-&gt;humanize(config(&apos;sanctum.access_token_expiration&apos;) * 60);
        $refreshTokenLifeTime = $humanDuration-&gt;humanize(config(&apos;sanctum.refresh_token_expiration&apos;) * 60);
        $streamTokenLifeTime = $humanDuration-&gt;humanize(config(&apos;sanctum.stream_token_expiration&apos;) * 60);
        $desc = &lt;&lt;&lt;DESC
### Access token
Only tokens with the ability &apos;access-api&apos; will have access to the endpoints. Access tokens have a lifetime of $accessTokenLifeTime.
### Stream token
Stream tokens can only be used for accessing media streams. Stream tokens have a lifetime of $streamTokenLifeTime.
### Refresh token
The refresh token has the &apos;issue-access-token&apos; ability. Refresh tokens have a lifetime of $refreshTokenLifeTime.
It can be used to refresh access and stream tokens.
#### Tip
Tokens can be used as a query parameter in cases where its not possible to add a header (e.g. mp3 streaming in the browser). Append the query parameter `_token=YOUR_TOKEN`.
DESC;
        Scramble::afterOpenApiGenerated(function (OpenApi $openApi) use ($desc) {
            $openApi-&gt;secure(
                (SecurityScheme::http(&apos;bearer&apos;))
                    -&gt;setDescription($desc),
            );
        });
        Scramble::routes(function (Route $route) {
            $whitelist = [&apos;api/&apos;, &apos;webauthn&apos;];
            foreach ($whitelist as $str) {
                if (Str::contains($route-&gt;uri, $str)) {
                    return true;
                }
            }
        });
    }
}</file><file path="config/octane.php">&lt;?php
use Laravel\Octane\Contracts\OperationTerminated;
use Laravel\Octane\Events\{RequestHandled,
    RequestReceived,
    RequestTerminated,
    TaskReceived,
    TaskTerminated,
    TickReceived,
    TickTerminated,
    WorkerErrorOccurred,
    WorkerStarting,
    WorkerStopping};
use Laravel\Octane\Listeners\{CloseMonologHandlers,
    EnsureUploadedFilesAreValid,
    EnsureUploadedFilesCanBeMoved,
    FlushOnce,
    FlushTemporaryContainerInstances,
    ReportException,
    StopWorkerIfNecessary};
use Laravel\Octane\Octane;
return [
    /*
    |--------------------------------------------------------------------------
    | Octane Server
    |--------------------------------------------------------------------------
    |
    | This value determines the default &quot;server&quot; that will be used by Octane
    | when starting, restarting, or stopping your server via the CLI. You
    | are free to change this to the supported server of your choosing.
    |
    | Supported: &quot;roadrunner&quot;, &quot;swoole&quot;, &quot;frankenphp&quot;
    |
    */
    &apos;server&apos; =&gt; env(&apos;OCTANE_SERVER&apos;, &apos;swoole&apos;),
    &apos;swoole&apos; =&gt; [
        &apos;command&apos;          =&gt; &apos;/var/www/html/start-swoole-server&apos;,
        &apos;show_fatal_error&apos; =&gt; env(&apos;OCTANE_SHOW_FATAL_ERROR&apos;, true),
        &apos;options&apos;          =&gt; [
            &apos;log_file&apos; =&gt; storage_path(&apos;logs/swoole_http.log&apos;),
        ],
    ],
    /*
    |--------------------------------------------------------------------------
    | Force HTTPS
    |--------------------------------------------------------------------------
    |
    | When this configuration value is set to &quot;true&quot;, Octane will inform the
    | framework that all absolute links must be generated using the HTTPS
    | protocol. Otherwise your links may be generated using plain HTTP.
    |
    */
    &apos;https&apos; =&gt; env(&apos;OCTANE_HTTPS&apos;, true),
    /*
    |--------------------------------------------------------------------------
    | Octane Listeners
    |--------------------------------------------------------------------------
    |
    | All of the event listeners for Octane&apos;s events are defined below. These
    | listeners are responsible for resetting your application&apos;s state for
    | the next request. You may even add your own listeners to the list.
    |
    */
    &apos;listeners&apos; =&gt; [
        WorkerStarting::class =&gt; [
            EnsureUploadedFilesAreValid::class,
            EnsureUploadedFilesCanBeMoved::class,
        ],
        RequestReceived::class =&gt; [
            ...Octane::prepareApplicationForNextOperation(),
            ...Octane::prepareApplicationForNextRequest(),
            //
        ],
        RequestHandled::class =&gt; [
            //
        ],
        RequestTerminated::class =&gt; [
            // FlushUploadedFiles::class,
        ],
        TaskReceived::class =&gt; [
            ...Octane::prepareApplicationForNextOperation(),
            //
        ],
        TaskTerminated::class =&gt; [
            //
        ],
        TickReceived::class =&gt; [
            ...Octane::prepareApplicationForNextOperation(),
            //
        ],
        TickTerminated::class =&gt; [
            //
        ],
        OperationTerminated::class =&gt; [
            FlushOnce::class,
            FlushTemporaryContainerInstances::class,
            // DisconnectFromDatabases::class,
            // CollectGarbage::class,
        ],
        WorkerErrorOccurred::class =&gt; [
            ReportException::class,
            StopWorkerIfNecessary::class,
        ],
        WorkerStopping::class =&gt; [
            CloseMonologHandlers::class,
        ],
    ],
    /*
    |--------------------------------------------------------------------------
    | Warm / Flush Bindings
    |--------------------------------------------------------------------------
    |
    | The bindings listed below will either be pre-warmed when a worker boots
    | or they will be flushed before every new request. Flushing a binding
    | will force the container to resolve that binding again when asked.
    |
    */
    &apos;warm&apos; =&gt; [
        ...Octane::defaultServicesToWarm(),
    ],
    &apos;flush&apos; =&gt; [
        //
    ],
    /*
    |--------------------------------------------------------------------------
    | Octane Swoole Tables
    |--------------------------------------------------------------------------
    |
    | While using Swoole, you may define additional tables as required by the
    | application. These tables can be used to store data that needs to be
    | quickly accessed by other workers on the particular Swoole server.
    |
    */
    &apos;tables&apos; =&gt; [
        &apos;apm_queue_transactions:200&apos; =&gt; [
            &apos;start_time&apos; =&gt; &apos;float&apos;,
            &apos;job_name&apos;   =&gt; &apos;string:255&apos;,
            &apos;queue_name&apos; =&gt; &apos;string:255&apos;,
            &apos;connection&apos; =&gt; &apos;string:255&apos;,
        ],
        &apos;metrics_state:1000&apos; =&gt; [
            &apos;timer_id&apos; =&gt; &apos;int&apos;,
            &apos;running&apos; =&gt; &apos;int&apos;,
        ],
        &apos;job_resource_monitor:5000&apos; =&gt; [
            &apos;samples&apos; =&gt; &apos;int&apos;,
            &apos;cpu_avg&apos; =&gt; &apos;float&apos;,
            &apos;memory_avg&apos; =&gt; &apos;float&apos;,
            &apos;cpu_peak&apos; =&gt; &apos;float&apos;,
            &apos;memory_peak&apos; =&gt; &apos;float&apos;,
            &apos;cpu_min&apos; =&gt; &apos;float&apos;,
            &apos;memory_min&apos; =&gt; &apos;float&apos;,
            &apos;started_at&apos; =&gt; &apos;int&apos;,
            &apos;last_updated&apos; =&gt; &apos;int&apos;,
            &apos;last_cpu&apos; =&gt; &apos;float&apos;,
            &apos;last_memory&apos; =&gt; &apos;float&apos;,
            &apos;memory_mb&apos; =&gt; &apos;float&apos;,
            &apos;status&apos; =&gt; &apos;string:20&apos;,
            &apos;finished_at&apos; =&gt; &apos;int&apos;,
        ],
    ],
    /*
    |--------------------------------------------------------------------------
    | Octane Swoole Cache Table
    |--------------------------------------------------------------------------
    |
    | While using Swoole, you may leverage the Octane cache, which is powered
    | by a Swoole table. You may set the maximum number of rows as well as
    | the number of bytes per row using the configuration options below.
    |
    */
    &apos;cache&apos; =&gt; [
        &apos;rows&apos;  =&gt; 1000,
        &apos;bytes&apos; =&gt; 10000,
    ],
    /*
    |--------------------------------------------------------------------------
    | File Watching
    |--------------------------------------------------------------------------
    |
    | The following list of files and directories will be watched when using
    | the --watch option offered by Octane. If any of the directories and
    | files are changed, Octane will automatically reload your workers.
    |
    */
    &apos;watch&apos; =&gt; [
        &apos;app&apos;,
        &apos;bootstrap&apos;,
        &apos;config/**/*.php&apos;,
        &apos;database/**/*.php&apos;,
        &apos;public/**/*.php&apos;,
        &apos;resources/**/*.php&apos;,
        &apos;routes&apos;,
        &apos;composer.lock&apos;,
        &apos;.env&apos;,
    ],
    /*
    |--------------------------------------------------------------------------
    | Garbage Collection Threshold
    |--------------------------------------------------------------------------
    |
    | When executing long-lived PHP scripts such as Octane, memory can build
    | up before being cleared by PHP. You can force Octane to run garbage
    | collection if your application consumes this amount of megabytes.
    |
    */
    &apos;garbage&apos; =&gt; 50,
    /*
    |--------------------------------------------------------------------------
    | Maximum Execution Time
    |--------------------------------------------------------------------------
    |
    | The following setting configures the maximum execution time for requests
    | being handled by Octane. You may set this value to 0 to indicate that
    | there isn&apos;t a specific time limit on Octane request execution time.
    |
    */
    &apos;max_execution_time&apos; =&gt; 30,
];</file><file path="config/scramble.php">&lt;?php
use Dedoc\Scramble\Http\Middleware\RestrictedDocsAccess;
return [
    /*
     * Your API path. By default, all routes starting with this path will be added to the docs.
     * If you need to change this behavior, you can add your custom routes resolver using `Scramble::routes()`.
     */
    &apos;api_path&apos;    =&gt; &apos;&apos;,
    /*
     * Your API domain. By default, app domain is used. This is also a part of the default API routes
     * matcher, so when implementing your own, make sure you use this config if needed.
     */
    &apos;api_domain&apos;  =&gt; null,
    /*
     * The path where your OpenAPI specification will be exported.
     */
    &apos;export_path&apos; =&gt; &apos;api.json&apos;,
    &apos;info&apos;    =&gt; [
        /*
         * API version.
         */
        &apos;version&apos;     =&gt; env(&apos;API_VERSION&apos;, &apos;0.0.1&apos;),
        /*
         * Description rendered on the home page of the API documentation (`/docs/api`).
         */
        &apos;description&apos; =&gt; &lt;&lt;&lt;DESCRIPTION
Bånder.App is a sophisticated media server developed with the primary goal to deliver high performance and seamless experience for users.
Being built on top of Laravel framework and PostgreSQL for database, it leverages the power of robust backend technologies, providing high security, reliability, and scalability.
The main focus of Bånder.App is efficient media management and delivery.
This application is designed to handle large amounts of media files while ensuring quick and efficient access.
Implemented queuing functionality through Redis offers efficient job management and load handling.
The media information is organized and easily searchable, ensuring users can always find what they are looking for quickly and easily.
DESCRIPTION
,
    ],
    /*
     * Customize Stoplight Elements UI
     */
    &apos;ui&apos;      =&gt; [
        /*
         * Define the title of the documentation&apos;s website. App name is used when this config is `null`.
         */
        &apos;title&apos;                     =&gt; &apos;Bånder api docs&apos;,
        /*
         * Define the theme of the documentation. Available options are `light` and `dark`.
         */
        &apos;theme&apos;                     =&gt; &apos;light&apos;,
        /*
         * Hide the `Try It` feature. Enabled by default.
         */
        &apos;hide_try_it&apos;               =&gt; false,
        /*
         * URL to an image that displays as a small square logo next to the title, above the table of contents.
         */
        &apos;logo&apos;                      =&gt; &apos;https://baander.test/baander-logo.svg&apos;,
        /*
         * Use to fetch the credential policy for the Try It feature. Options are: omit, include (default), and same-origin
         */
        &apos;try_it_credentials_policy&apos; =&gt; &apos;include&apos;,
    ],
    /*
     * The list of servers of the API. By default, when `null`, server URL will be created from
     * `scramble.api_path` and `scramble.api_domain` config variables. When providing an array, you
     * will need to specify the local server URL manually (if needed).
     *
     * Example of non-default config (final URLs are generated using Laravel `url` helper):
     *
     * ```php
     * &apos;servers&apos; =&gt; [
     *     &apos;Live&apos; =&gt; &apos;api&apos;,
     *     &apos;Prod&apos; =&gt; &apos;https://scramble.dedoc.co/api&apos;,
     * ],
     * ```
     */
    &apos;servers&apos; =&gt; null,
    &apos;middleware&apos; =&gt; [
        &apos;web&apos;,
        RestrictedDocsAccess::class,
    ],
    &apos;extensions&apos; =&gt; [
        \App\Modules\OpenApi\JsonPaginatorExtension::class,
        \App\Modules\OpenApi\LaravelDataRequestExtension::class,
        \App\Modules\OpenApi\LaravelDataToSchema::class,
    ],
];</file><file path="database/migrations/2024_04_07_121115_create_albums_table.php">&lt;?php
use Illuminate\Database\Migrations\Migration;
use Tpetry\PostgresqlEnhanced\Schema\Blueprint;
use Tpetry\PostgresqlEnhanced\Support\Facades\Schema;
return new class extends Migration {
    /**
     * Run the migrations.
     */
    public function up(): void
    {
        Schema::create(&apos;albums&apos;, function (Blueprint $table) {
            $table-&gt;id();
            $table-&gt;foreignId(&apos;library_id&apos;)
                -&gt;references(&apos;id&apos;)
                -&gt;on(&apos;libraries&apos;)
                -&gt;cascadeOnDelete()
                -&gt;cascadeOnUpdate();
            $table-&gt;caseInsensitiveText(&apos;title&apos;);
            $table-&gt;text(&apos;slug&apos;)-&gt;unique();
            $table-&gt;integer(&apos;year&apos;)-&gt;nullable()-&gt;comment(&apos;The year the album was released&apos;);
            $table-&gt;timestampsTz();
            $table-&gt;index(&apos;library_id&apos;);
        });
    }
    /**
     * Reverse the migrations.
     */
    public function down(): void
    {
        Schema::dropIfExists(&apos;albums&apos;);
    }
};</file><file path="docker/general/supervisord.conf">[supervisord]
nodaemon=true
logfile=/dev/null
logfile_maxbytes=0
pidfile=/tmp/supervisord.pid
minfds=10000

;[program:webserver]
;process_name=%(program_name)s_%(process_num)02d
;command=/usr/local/bin/php -d variables_order=EGPCS /var/www/html/artisan octane:start --watch --log-level=debug --host=0.0.0.0 --port=8000 --workers=auto --task-workers=auto --max-requests=250
;autostart=true
;autorestart=unexpected
;user=www-data
;group=www-data
;stdout_logfile=/dev/fd/1
;stdout_logfile_maxbytes=0
;stderr_logfile=/dev/fd/2
;stderr_logfile_maxbytes=0

[program:reverb]
process_name=%(program_name)s_%(process_num)02d
command=/usr/local/bin/php -d variables_order=EGPCS /var/www/html/artisan reverb:start --debug
autostart=true
autorestart=unexpected
user=www-data
group=www-data
stdout_logfile=/dev/fd/1
stdout_logfile_maxbytes=0
stderr_logfile=/dev/fd/2
stderr_logfile_maxbytes=0

;[program:worker]
;process_name=%(program_name)s_%(process_num)02d
;command=/usr/local/bin/php /var/www/html/artisan queue:listen
;user=www-data
;group=www-data
;autostart=true
;autorestart=true
;stdout_logfile=/dev/fd/1
;stdout_logfile_maxbytes=0
;stderr_logfile=/dev/fd/2
;stderr_logfile_maxbytes=0</file><file path="resources/app/api-client/queries/index.ts">// generated with @7nohe/openapi-react-query-codegen@1.6.2 
export * from &quot;./common&quot;;
export * from &quot;./queries&quot;;</file><file path="resources/app/env.d.ts">/// &lt;reference types=&quot;vite/client&quot; /&gt;
interface ImportMetaEnv {
  readonly VITE_APP_NAME: string;
  readonly VITE_APP_URL: string;
  readonly VITE_APP_ENV: string;
}
interface ImportMeta {
  readonly env: ImportMetaEnv;
}
declare interface Window {
  BaanderAppInfo: {
    name: string;
    url: string;
    environment: &apos;local&apos; | &apos;production&apos; | &apos;testing&apos;;
    debug: boolean;
    locale: string;
    version: string;
  };
}</file><file path="resources/app/hooks/use-stream-token.ts">import { useEffect, useState } from &apos;react&apos;;
import { NewAccessTokenResource } from &apos;@/api-client/requests&apos;;
import { isTokenExpired, Token } from &apos;@/services/auth/token&apos;;
import { refreshStreamToken } from &apos;@/services/auth/stream-token.ts&apos;;
import { useSelector } from &apos;react-redux&apos;;
import { selectIsAuthenticated } from &apos;@/store/users/auth-slice.ts&apos;;
export function useStreamToken() {
  const [token, setToken] = useState&lt;NewAccessTokenResource | undefined&gt;(Token.getStreamToken());
  const isAuthenticated = useSelector(selectIsAuthenticated);
  useEffect(() =&gt; {
    const refresh = () =&gt; {
      if (!isAuthenticated) {
        return;
      }
      if (!token || isTokenExpired(token.expiresAt)) {
        refreshStreamToken()
          .then(t =&gt; {
            setToken(t);
            Token.setStreamToken(t);
          });
      }
    }
    refresh();
    let timerId = setInterval(() =&gt; {
      refresh();
    }, 30_000);
    return () =&gt; clearInterval(timerId);
  }, [token, token?.expiresAt, isAuthenticated]);
  const authenticateUrl = (url: string) =&gt; {
    if (isAuthenticated &amp;&amp; token) {
      return `${url}?_token=${token.token}`;
    } else {
      console.warn(&apos;Did not authenticate url&apos;);
      return url;
    }
  }
  return {
    authenticateUrl,
    streamToken: token?.token,
  };
}</file><file path="resources/app/index.css">@import &quot;reset.css&quot;;
@import &quot;@radix-ui/themes/styles.css&quot;;
/*@import &quot;theme/dark/accent.css&quot;;*/
/*@import &quot;theme/dark/background.css&quot;;*/
/*@import &quot;theme/dark/gray.css&quot;;*/
/*@import &quot;theme/dark/text.css&quot;;*/
/*@import &quot;theme/light/accent.css&quot;;*/
/*@import &quot;theme/light/background.css&quot;;*/
/*@import &quot;theme/light/gray.css&quot;;*/
/*@import &quot;theme/light/text.css&quot;;*/
:root {
    --progress-width: 0;
    --buffered-width: 0;
    --color-text-primary: #0b0e0c;
    --color-text-secondary: #6b7280;
}
@media (prefers-color-scheme: dark) {
    :root {
        --color-text-primary: #f3f4f6;
        --color-text-secondary: #d1d5db;
    }
}
html, body {
    margin: 0;
    height: 100vh;
    color: var(--color-text-primary);
    background-color: var(--color-background);
}
body, html {
    margin: 0;
    padding: 0;
}
* {
    text-wrap: pretty;
    box-sizing: border-box;
}
.radix-themes {
    --default-font-family: &apos;Inter Variable&apos;, sans-serif;
    --default-letter-spacing: -0.03em;
}
.rt-Button, a {
    cursor: pointer;
}
table {
    width: 100%;
}
th, td {
    word-wrap: break-word;
}</file><file path="resources/app/modules/auth/routes/login.tsx">import { SyntheticEvent } from &apos;react&apos;;
import { useAppDispatch } from &apos;@/store/hooks.ts&apos;;
import { loginUser } from &apos;@/store/users/auth-slice.ts&apos;;
import { Box, Button, Flex, Text, TextField } from &apos;@radix-ui/themes&apos;;
import styles from &apos;./login.module.scss&apos;;
import { VinylSpinAnimation } from &apos;@/ui/animations/vinyl-spin-animation/vinyl-spin-animation.tsx&apos;;
import { Form } from &apos;radix-ui&apos;;
import { Link } from &apos;react-router-dom&apos;;
export default function Login() {
  const dispatch = useAppDispatch();
  const onSubmit = async (event: SyntheticEvent&lt;HTMLFormElement&gt;) =&gt; {
    event.preventDefault();
    const formData = event.target;
    // @ts-expect-error
    const email = formData.email.value;
    // @ts-expect-error
    const password = formData.password.value;
    dispatch(loginUser({ email, password }));
  };
  return (
    &lt;Flex direction=&quot;row&quot; className={styles.loginContainer}&gt;
      &lt;Flex direction=&quot;column&quot; gap=&quot;3&quot; className={styles.formContent}&gt;
        &lt;Text size=&quot;7&quot; weight=&quot;bold&quot; align=&quot;center&quot; className={styles.welcomeText}&gt;
          Welcome Back!
        &lt;/Text&gt;
        &lt;Text size=&quot;4&quot; align=&quot;center&quot; color=&quot;gray&quot; className={styles.tagline}&gt;
          Sign in to continue to your account
        &lt;/Text&gt;
        &lt;Form.Root className={styles.form} onSubmit={onSubmit}&gt;
          &lt;Box className={styles.animationSection}&gt;
            &lt;VinylSpinAnimation className={styles.animation}/&gt;
          &lt;/Box&gt;
          &lt;Flex direction=&quot;column&quot; gap=&quot;3&quot;&gt;
            &lt;Form.Field className={styles.Field} name=&quot;email&quot;&gt;
              &lt;Form.Label className={styles.Label}&gt;Email&lt;/Form.Label&gt;
              &lt;Form.Control asChild&gt;
                &lt;TextField.Root type=&quot;email&quot; radius=&quot;large&quot; size=&quot;3&quot; required&gt;
                  &lt;TextField.Slot&gt;&lt;/TextField.Slot&gt;
                &lt;/TextField.Root&gt;
              &lt;/Form.Control&gt;
            &lt;/Form.Field&gt;
            &lt;Form.Field className={styles.Field} name=&quot;password&quot;&gt;
              &lt;Form.Label className={styles.Label}&gt;Password&lt;/Form.Label&gt;
              &lt;Form.Control asChild&gt;
                &lt;TextField.Root type=&quot;password&quot; radius=&quot;large&quot; size=&quot;3&quot; required&gt;
                  &lt;TextField.Slot&gt;&lt;/TextField.Slot&gt;
                &lt;/TextField.Root&gt;
              &lt;/Form.Control&gt;
            &lt;/Form.Field&gt;
            &lt;Form.Submit asChild&gt;
              &lt;Button variant=&quot;solid&quot; size=&quot;3&quot; className={styles.Button}&gt;
                Login
              &lt;/Button&gt;
            &lt;/Form.Submit&gt;
          &lt;/Flex&gt;
        &lt;/Form.Root&gt;
        &lt;Flex direction=&quot;row&quot; justify=&quot;between&quot; className={styles.links}&gt;
          &lt;Link to=&quot;/auth/forgot-password&quot;&gt;
            &lt;Text size=&quot;3&quot;&gt;
              Forgot Password?
            &lt;/Text&gt;
          &lt;/Link&gt;
          &lt;Link to=&quot;/auth/create-account&quot;&gt;
            &lt;Text size=&quot;3&quot;&gt;
              Create an Account
            &lt;/Text&gt;
          &lt;/Link&gt;
        &lt;/Flex&gt;
      &lt;/Flex&gt;
    &lt;/Flex&gt;
  );
}</file><file path="resources/app/modules/dashboard/libraries/libraries-list.tsx">import { Box, Button, Container, Heading } from &apos;@radix-ui/themes&apos;;
import { ReactNode, useEffect, useState } from &apos;react&apos;;
import { JobService } from &apos;@/api-client/requests&apos;;
import { useLibraryServiceGetApiLibraries } from &apos;@/api-client/queries&apos;;
import { useAppDispatch } from &apos;@/store/hooks.ts&apos;;
import { createNotification } from &apos;@/store/notifications/notifications-slice.ts&apos;;
export function LibrariesList() {
  const {data} = useLibraryServiceGetApiLibraries();
  const [rows, setRows] = useState&lt;ReactNode[]&gt;([]);
  const dispatch = useAppDispatch();
  const startScanJob = (slug: string) =&gt; {
    JobService.postApiJobsScanLibraryBySlug({slug})
      .then(res =&gt; {
        if (typeof res !== &apos;string&apos;) {
          dispatch(createNotification({
            type: &apos;info&apos;,
            title: &apos;Library scan&apos;,
            message: res.message,
            toast: true,
          }));
        }
      });
  };
  useEffect(() =&gt; {
    if (data?.data) {
      const items = data.data.map(x =&gt; (
        &lt;tr key={x.slug}&gt;
          &lt;td&gt;{x.name} ({x.type})&lt;/td&gt;
          &lt;td&gt;{x.path}&lt;/td&gt;
          &lt;td&gt;{x.lastScan}&lt;/td&gt;
          &lt;td&gt;{x.createdAt}&lt;/td&gt;
          &lt;td&gt;{x.updatedAt}&lt;/td&gt;
          &lt;td&gt;
            &lt;Box&gt;
              &lt;Button
                onClick={() =&gt; startScanJob(x.slug)}
              &gt;Scan&lt;/Button&gt;
            &lt;/Box&gt;
          &lt;/td&gt;
        &lt;/tr&gt;
      ));
      setRows(items);
    }
  }, [data?.data]);
  return (
    &lt;Container mt=&quot;3&quot;&gt;
      &lt;Heading&gt;Libraries - list&lt;/Heading&gt;
     &lt;Box mt=&quot;4&quot;&gt;
       &lt;table&gt;
         &lt;thead&gt;
         &lt;tr&gt;
           &lt;th&gt;Name&lt;/th&gt;
           &lt;th&gt;Path&lt;/th&gt;
           &lt;th&gt;Last scan&lt;/th&gt;
           &lt;th&gt;Created&lt;/th&gt;
           &lt;th&gt;Updated&lt;/th&gt;
           &lt;th&gt;Actions&lt;/th&gt;
         &lt;/tr&gt;
         &lt;/thead&gt;
         &lt;tbody&gt;{rows}&lt;/tbody&gt;
       &lt;/table&gt;
     &lt;/Box&gt;
    &lt;/Container&gt;
  );
}</file><file path="resources/app/modules/library-music-player/components/player-face-plate/player-face-plate.tsx">import { Flex, Text } from &apos;@radix-ui/themes&apos;;
import { ProgressBar } from &apos;@/modules/library-music-player/components/progress-bar/progress-bar.tsx&apos;;
import { formatDuration } from &apos;@/utils/time/format-duration.ts&apos;;
import { Cover } from &apos;@/modules/library-music/components/artwork/cover&apos;;
import styles from &apos;./player-face-plate.module.scss&apos;;
import { withTestMode } from &apos;@/providers/test-mode-provider.tsx&apos;;
export interface PlayerFacePlateViewModel {
  coverUrl: string;
  title: string;
  artists: string[];
  artist: string;
  album: string;
}
export interface PlayerFacePlateProps {
  buffered: number;
  duration: number;
  currentProgress: number;
  setProgress: (progress: number) =&gt; void;
  viewModel: Partial&lt;PlayerFacePlateViewModel&gt;;
}
export function PlayerFacePlate({
                                  buffered,
                                  duration,
                                  currentProgress,
                                  setProgress,
                                  viewModel,
                                }: PlayerFacePlateProps) {
  const durationDisplay = formatDuration(duration);
  const elapsedDisplay = formatDuration(currentProgress);
  const artistNames = viewModel.artists?.join(&apos;, &apos;);
  return (
    &lt;Flex flexGrow=&quot;2&quot; align=&quot;center&quot;&gt;
      &lt;Cover imgSrc={viewModel.coverUrl} size={64} /&gt;
      &lt;Flex
        direction=&quot;column&quot;
        width=&quot;100%&quot;
        ml=&quot;3&quot;
      &gt;
        &lt;Flex
          direction=&quot;column&quot;
          justify=&quot;center&quot;
          align=&quot;center&quot;
        &gt;
          &lt;Text weight=&quot;bold&quot; size=&quot;2&quot;&gt;
            {viewModel?.title}
          &lt;/Text&gt;
          &lt;Text size=&quot;1&quot;&gt;
            {viewModel.album ? `${viewModel.album}` : &apos;&apos;}
            {artistNames ? ` | ${artistNames}` : &apos;&apos;}
          &lt;/Text&gt;
        &lt;/Flex&gt;
        &lt;Flex
          direction=&quot;row&quot;
          className={styles.progressContainer}
          align=&quot;center&quot;
        &gt;
          &lt;Text size=&quot;2&quot; mr=&quot;2&quot;&gt;
            {elapsedDisplay}
          &lt;/Text&gt;
          &lt;ProgressBar
            duration={duration}
            currentProgress={currentProgress}
            buffered={buffered}
            setProgress={setProgress}
          /&gt;
          &lt;Text size=&quot;2&quot; ml=&quot;2&quot;&gt;
            {durationDisplay}
          &lt;/Text&gt;
        &lt;/Flex&gt;
      &lt;/Flex&gt;
    &lt;/Flex&gt;
  );
}
// Wrap the component with withTestMode and pass the viewModel type as a plain object
export default withTestMode(PlayerFacePlate, {
  coverUrl: &apos;&apos;,
  title: &apos;&apos;,
  artists: [&apos;&apos;],
  artist: &apos;&apos;,
  album: &apos;&apos;,
});</file><file path="resources/app/modules/library-music-player/components/player-meta-controls/player-meta-controls.tsx">import {
  LyricsButton,
  VisualizerButton,
} from &apos;@/modules/library-music-player/components/player-buttons/player-buttons.tsx&apos;;
import { Waveform } from &apos;@/ui/waveform/waveform.tsx&apos;;
import styles from &apos;./player-meta-controls.module.scss&apos;;
import { SongResource } from &apos;@/api-client/requests&apos;;
import { VolumeSlider } from &apos;@/modules/library-music-player/components/volume-slider/volume-slider.tsx&apos;;
import { useLyrics } from &apos;@/ui/lyrics-viewer/providers/lyrics-provider.tsx&apos;;
import { LyricsViewer } from &apos;@/ui/lyrics-viewer/lyrics-viewer.tsx&apos;;
import { useEffect } from &apos;react&apos;;
import { useDisclosure } from &apos;@/hooks/use-disclosure&apos;;
import { Box, Button, Flex } from &apos;@radix-ui/themes&apos;;
import { Iconify } from &apos;@/ui/icons/iconify.tsx&apos;;
import { AudioStats } from &apos;@/ui/audio-stats/audio-stats.tsx&apos;;
import { useAudioPlayer } from &apos;@/modules/library-music-player/providers/audio-player-provider.tsx&apos;;
export interface PlayerMetaControlsProps {
  song?: SongResource;
}
export function PlayerMetaControls({ song }: PlayerMetaControlsProps) {
  const [showWaveform, waveformHandlers] = useDisclosure(false);
  const [showLyrics, lyricHandlers] = useDisclosure(false);
  const [showDebug, debugHandlers] = useDisclosure(false);
  const { setLyrics } = useLyrics();
  const {audioRef} = useAudioPlayer();
  useEffect(() =&gt; {
    if (!song?.lyricsExist) {
      lyricHandlers.close();
    }
  }, [song?.lyricsExist]);
  return (
    &lt;&gt;
      &lt;div className={styles.playerMetaControls}&gt;
        &lt;VolumeSlider /&gt;
        &lt;VisualizerButton
          isActive={showWaveform}
          onClick={() =&gt; waveformHandlers.toggle()}
        /&gt;
        &lt;LyricsButton
          aria-disabled={song?.lyricsExist === false}
          className={styles.lyrics}
          onClick={() =&gt; {
            song?.lyrics &amp;&amp; setLyrics(song.lyrics);
            lyricHandlers.toggle();
          }}
        /&gt;
        &lt;Button variant=&quot;ghost&quot; onClick={() =&gt; debugHandlers.toggle()}&gt;
          &lt;Iconify icon=&quot;codicon:debug&quot; height={20} /&gt;
        &lt;/Button&gt;
      &lt;/div&gt;
      {showWaveform &amp;&amp; (
        &lt;Waveform key=&quot;waveform&quot; onClose={() =&gt; waveformHandlers.close()} /&gt;
      )}
      {showLyrics &amp;&amp; (
        &lt;Box style={{ position: &apos;absolute&apos;, right: 20, bottom: 90 }}&gt;
          &lt;LyricsViewer key=&quot;lyrics&quot; /&gt;
        &lt;/Box&gt;
      )}
      {showDebug &amp;&amp; (
        &lt;Flex style={{ position: &apos;absolute&apos;, right: 20, bottom: 90 }}&gt;
          &lt;AudioStats audioRef={audioRef} /&gt;
        &lt;/Flex&gt;
      )}
    &lt;/&gt;
  );
}</file><file path="resources/app/modules/library-music-player/providers/audio-player-provider.tsx">import React, { ReactEventHandler, RefObject, useCallback, useContext, useEffect, useRef, useState } from &apos;react&apos;;
import { noop } from &apos;@/utils/noop.ts&apos;;
import { useMusicSource } from &apos;@/providers/music-source-provider&apos;;
import { SongResource } from &apos;@/api-client/requests&apos;;
import { useAppDispatch } from &apos;@/store/hooks.ts&apos;;
import { createNotification } from &apos;@/store/notifications/notifications-slice.ts&apos;;
interface AudioPlayerContextType {
  audioRef: RefObject&lt;HTMLAudioElement&gt;;
  isPlaying: boolean;
  play: () =&gt; void;
  duration: number;
  currentProgress: number;
  setCurrentProgress: (value: number) =&gt; void;
  buffered: number;
  togglePlayPause: () =&gt; void;
  volume: number;
  setCurrentVolume: (value: number) =&gt; void;
  isMuted: boolean;
  mute: () =&gt; void;
  unmute: () =&gt; void;
  toggleMuteUnmute: () =&gt; void;
  song: SongResource | null;
  setSong: (song: SongResource | null) =&gt; void;
}
export const AudioPlayerContext = React.createContext&lt;AudioPlayerContextType&gt;({
  audioRef: null as unknown as RefObject&lt;HTMLAudioElement&gt;,
  isPlaying: false,
  play: () =&gt; noop(),
  duration: 0,
  currentProgress: 0,
  setCurrentProgress: () =&gt; noop(),
  buffered: 0,
  togglePlayPause: () =&gt; noop(),
  volume: 100,
  setCurrentVolume: () =&gt; noop(),
  isMuted: false,
  mute: () =&gt; noop(),
  unmute: () =&gt; noop(),
  toggleMuteUnmute: () =&gt; noop(),
  song: null,
  setSong: () =&gt; noop(),
});
AudioPlayerContext.displayName = &apos;AudioPlayerContext&apos;;
export function AudioPlayerContextProvider({ children }: { children: React.ReactNode }) {
  const dispatch = useAppDispatch();
  const {
    setAudioRef,
    authenticatedSource,
  } = useMusicSource();
  const audioRef = useRef&lt;HTMLAudioElement&gt;(new Audio());
  const [isPlaying, setIsPlaying] = useState(false);
  const [duration, setDuration] = useState(0);
  const [isReady, setIsReady] = useState(false);
  const [currentProgress, setCurrentProgress] = useState(0);
  const [buffered, setBuffered] = useState(0);
  const [isMuted, setIsMuted] = useState(false);
  const [volume, setVolume] = useState(1);
  const [currentVolume, setCurrentVolume] = useState(100);
  const [song, setSong] = useState&lt;SongResource | null&gt;(null);
  const togglePlayPause = () =&gt; {
    if (isPlaying) {
      setIsPlaying(false);
    } else if (isReady) {
      setIsPlaying(true);
    }
  };
  const toggleMuteUnmute = () =&gt; {
    if (isMuted) {
      unmute();
    } else {
      mute();
    }
  };
  const handleBufferProgress: ReactEventHandler&lt;HTMLAudioElement&gt; = (e) =&gt; {
    const audio = e.currentTarget;
    const dur = audio.duration;
    if (dur &gt; 0) {
      for (let i = 0; i &lt; audio.buffered.length; i++) {
        if (
          audio.buffered.start(audio.buffered.length - 1 - i) &lt; audio.currentTime
        ) {
          const bufferedLength = audio.buffered.end(
            audio.buffered.length - 1 - i,
          );
          setBuffered(bufferedLength);
          break;
        }
      }
    }
  };
  const handleTimeUpdate: ReactEventHandler&lt;HTMLAudioElement&gt; = (e) =&gt; {
    const audio = e.currentTarget;
    setCurrentProgress(audio.currentTime);
    handleBufferProgress(e);
  };
  const mute = () =&gt; {
    if (audioRef.current) {
      audioRef.current.volume = 0;
      setIsMuted(true);
    }
  };
  const unmute = useCallback(() =&gt; {
    if (audioRef.current) {
      audioRef.current.volume = currentVolume / 100;
      setIsMuted(false);
    }
  }, [currentVolume]);
  useEffect(() =&gt; {
    const handleCanPlay = () =&gt; {
      setIsReady(true);
    };
    const currentAudioRef = audioRef.current;
    if (currentAudioRef) {
      currentAudioRef.addEventListener(&apos;canplay&apos;, handleCanPlay);
    }
    return () =&gt; {
      if (currentAudioRef) {
        currentAudioRef.removeEventListener(&apos;canplay&apos;, handleCanPlay);
      }
    };
  }, []);
  useEffect(() =&gt; {
    if (audioRef.current &amp;&amp; currentVolume) {
      audioRef.current.volume = currentVolume / 100;
    }
  }, [currentVolume]);
  useEffect(() =&gt; {
    if (audioRef.current) {
      setAudioRef(audioRef);
    }
  }, [setAudioRef]);
  useEffect(() =&gt; {
    if (currentVolume) {
      setVolume(currentVolume);
    }
  }, [currentVolume]);
  useEffect(() =&gt; {
    const currentAudioRef = audioRef.current;
    if (currentAudioRef) {
      currentAudioRef.volume = currentVolume / 100;
    }
  }, [volume]);
  useEffect(() =&gt; {
    const currentAudioRef = audioRef.current;
    return () =&gt; {
      currentAudioRef.pause();
    };
  }, []);
  useEffect(() =&gt; {
    if (isPlaying &amp;&amp; isReady) {
      audioRef.current.play().catch((e) =&gt; {
        dispatch(createNotification({
          type: &apos;error&apos;,
          title: &apos;Audio player error&apos;,
          message: e?.message ?? &apos;Unable to autoplay song&apos;,
          toast: true,
        }));
      });
    } else {
      audioRef.current.pause();
    }
  }, [isPlaying, isReady]);
  useEffect(() =&gt; {
    if (!authenticatedSource) {
      return;
    }
    if (!audioRef.current) {
      audioRef.current = new Audio(authenticatedSource);
    } else if (authenticatedSource) {
      audioRef.current.pause();
      audioRef.current.src = authenticatedSource;
    }
    audioRef.current.volume = volume / 100;
    audioRef.current.preload = &apos;auto&apos;;
    // @ts-ignore
    audioRef.current.ondurationchange = (e) =&gt; setDuration(e.currentTarget.duration);
    // @ts-ignore
    audioRef.current.ontimeupdate = (e) =&gt; handleTimeUpdate(e);
    // @ts-ignore
    audioRef.current.onprogress = (e) =&gt; handleBufferProgress(e);
    audioRef.current.play().then(() =&gt; {
      setIsPlaying(true);
    });
  }, [authenticatedSource]);
  return (
    &lt;AudioPlayerContext.Provider
      value={{
        audioRef,
        isPlaying,
        play: togglePlayPause,
        duration,
        currentProgress,
        setCurrentProgress,
        buffered,
        togglePlayPause,
        volume,
        setCurrentVolume,
        isMuted,
        mute,
        unmute,
        toggleMuteUnmute,
        song,
        setSong,
      }}
    &gt;{children}&lt;/AudioPlayerContext.Provider&gt;
  );
}
export function useAudioPlayer() {
  return useContext(AudioPlayerContext);
}</file><file path="resources/app/modules/library-music/components/album-detail/album-detail.module.scss">.trackRow {
    cursor: pointer;
    border: unset;
    &amp;:hover {
        background-color: rgba(0, 0, 0, 0.05);
    }
}
.card {
    position: relative;
    box-shadow: -1px -1px 15px 2px rgba(0,0,0,0.1),0px 5px 7px -3px rgba(0,0,0,0.1);
}
.image {
    position: absolute;
    inset: 0;
    background-size: cover;
    transition: transform 500ms ease;
    opacity: 0.4;
}
.overlay {
    position: absolute;
    top: 20%;
    left: 0;
    right: 0;
    bottom: 0;
    background-image: linear-gradient(180deg, rgba(0, 0, 0, 0) 0%, rgba(0, 0, 0, 0.85) 90%);
}
.content {
    height: 100%;
    position: relative;
    display: flex;
    flex-direction: column;
    justify-content: flex-end;
    z-index: 1;
}
.title {
    margin-bottom: 5px;
}
.bodyText {
    margin-left: 7px;
}
.author {
}</file><file path="resources/app/modules/library-music/components/album/album.module.scss">.album {
  display: flex;
  flex-direction: column;
  height: auto;
  width: 200px;
  .title {
    margin-top: 8px;
    font-size: clamp(0.85em, 2vw, 1em);
    font-weight: bold;
    line-clamp: 3;
    -webkit-line-clamp: 3;
    -webkit-box-orient: vertical;
    overflow: hidden;
    text-overflow: ellipsis;
    color: var(--color-text-primary);
    transition: color 0.15s ease-in-out;
  }
  .artist {
    font-size: 0.9em;
    color: var(--color-text-secondary);
    margin-top: 2px;
    text-overflow: ellipsis;
    white-space: nowrap;
    overflow: hidden;
  }
  &amp;:hover {
    cursor: pointer;
    .title,
    .artist {
      color: var(--color-text-primary);
    }
  }
}
@media (max-width: 600px) {
  .album {
    width: 150px;
  }
  .title {
    font-size: 0.9em;
  }
  .artist {
    font-size: 0.8em;
  }
}</file><file path="resources/app/modules/library-music/components/artwork/cover/cover.module.scss">.interactive {
  transition: box-shadow 0.15s ease-in-out;
  &amp;:hover {
    box-shadow: 0 0 12px 0 rgba(0, 0, 0, 0.2);
  }
}
.coverFallBack {
  background-color: #f5f5f5;
  border-radius: 6px;
  display: flex;
  justify-content: center;
  align-items: center;
  width: 100%;
  height: 100%;
  overflow: hidden;
  position: relative;
}
@media (prefers-color-scheme: dark) {
  .coverFallBack {
    background-color: #222;
  }
}
.shadow {
  // HACK: buggy in chrome based browsers
  &amp;:not(img) {
    border-radius: 7px;
    box-shadow: 0px 0px 17px -11px rgba(0,0,0,0.1),0px 4px 11px 0px rgba(0,0,0,0.1);
  }
  img {
    border-radius: 7px;
    box-shadow: 0px 0px 17px -11px rgba(0,0,0,0.1),0px 4px 11px 0px rgba(0,0,0,0.1);
  }
}</file><file path="resources/app/modules/library-music/components/artwork/cover/cover.tsx">import { Icon } from &apos;@iconify/react&apos;;
import styles from &apos;./cover.module.scss&apos;;
interface CoverProps {
  imgSrc?: string;
  size?: number;
  interactive?: boolean;
}
export function Cover({ imgSrc, size, interactive = false }: CoverProps) {
  return (
    &lt;&gt;
      &lt;div style={{ height: `${size}px`, width: `${size}px` }} className={styles.shadow}&gt;
        {imgSrc
         ? &lt;img
           src={imgSrc}
           height={size}
           width={size}
           className={`${interactive ? styles.interactive : undefined}`}
           alt=&quot;&quot;/&gt;
         : &lt;FallbackImage size={size} interactive={interactive}/&gt;
        }
      &lt;/div&gt;
    &lt;/&gt;
  );
}
function FallbackImage({ size = 150, interactive = false }: { size?: number, interactive?: boolean }) {
  return (
    &lt;div style={{ height: size, width: size }}
         className={`${styles.coverFallBack} ${interactive ? styles.interactive : undefined}`}&gt;
      &lt;Icon icon=&quot;akar-icons:music-album-fill&quot; height={size / 3} opacity={0.3}/&gt;
    &lt;/div&gt;
  );
}</file><file path="resources/app/modules/library-music/components/song-detail/song-detail.tsx">import { useSongServiceGetApiLibrariesByLibrarySongsByPublicId } from &apos;@/api-client/queries&apos;;
import {
  Box,
  Callout,
  Grid,
  Spinner,
  Text,
  TextArea,
  TextField,
} from &apos;@radix-ui/themes&apos;;
import { DateTime } from &apos;@/ui/dates/date-time.tsx&apos;;
import { useEffect, useState } from &apos;react&apos;;
export interface SongDetailProps {
  publicId: string;
}
export function SongDetail({ publicId }: SongDetailProps) {
  const { data, error, isLoading } = useSongServiceGetApiLibrariesByLibrarySongsByPublicId({ library: &apos;music&apos;, publicId });
  const [title, setTitle] = useState(&apos;&apos;);
  const [year, setYear] = useState&lt;number | &apos;&apos;&gt;(&apos;&apos;);
  const [disc, setDisc] = useState&lt;number | &apos;&apos;&gt;(&apos;&apos;);
  const [track, setTrack] = useState&lt;number | &apos;&apos;&gt;(&apos;&apos;);
  const [comment, setComment] = useState(&apos;&apos;);
  // Synchronize state with data
  useEffect(() =&gt; {
    if (data) {
      setTitle(data.title || &apos;&apos;);
      setYear(data.year ?? &apos;&apos;);
      setDisc(data.disc ?? &apos;&apos;);
      setTrack(data.track ?? &apos;&apos;);
      setComment(data.comment ?? &apos;&apos;);
    }
  }, [data]);
  if (isLoading) return &lt;Spinner/&gt;;
  if (error) {
    return (
      &lt;Callout.Root color=&quot;red&quot;&gt;
        &lt;Callout.Text&gt;{
          // @ts-expect-error
          error?.message
        }&lt;/Callout.Text&gt;
      &lt;/Callout.Root&gt;
    );
  }
  if (!data) return &lt;Text&gt;No data available&lt;/Text&gt;;
  const { public_id, path, durationHuman, sizeHuman, createdAt, updatedAt } = data;
  return (
    &lt;Grid columns=&quot;2&quot;&gt;
      &lt;Box&gt;
        &lt;TextField.Root&gt;
          &lt;label&gt;Title&lt;/label&gt;
          &lt;input
            type=&quot;text&quot;
            value={title}
            onChange={(e) =&gt; setTitle(e.target.value)}
          /&gt;
        &lt;/TextField.Root&gt;
        &lt;TextField.Root&gt;
          &lt;label&gt;Year&lt;/label&gt;
          &lt;input
            type=&quot;number&quot;
            value={year}
            // @ts-expect-error
            onChange={(e) =&gt; setYear(e.target.value)}
            min={0}
            max={9999}
          /&gt;
        &lt;/TextField.Root&gt;
        &lt;TextField.Root&gt;
          &lt;label&gt;Disc number&lt;/label&gt;
          &lt;input
            type=&quot;number&quot;
            value={disc}
            // @ts-expect-error
            onChange={(e) =&gt; setDisc(e.target.value)}
            min={0}
            max={9999}
          /&gt;
        &lt;/TextField.Root&gt;
        &lt;TextField.Root&gt;
          &lt;label&gt;Track number&lt;/label&gt;
          &lt;input
            type=&quot;number&quot;
            value={track}
            // @ts-expect-error
            onChange={(e) =&gt; setTrack(e.target.value)}
            min={0}
            max={9999}
          /&gt;
        &lt;/TextField.Root&gt;
        &lt;TextField.Root&gt;
          &lt;label&gt;Comment&lt;/label&gt;
          &lt;TextArea
            value={comment}
            onChange={(e) =&gt; setComment(e.target.value)}
          /&gt;
        &lt;/TextField.Root&gt;
      &lt;/Box&gt;
      &lt;Box&gt;
        &lt;Text&gt;{public_id}&lt;/Text&gt;
        &lt;Text&gt;{path}&lt;/Text&gt;
        &lt;Text&gt;{durationHuman}&lt;/Text&gt;
        &lt;Text&gt;{sizeHuman}&lt;/Text&gt;
        &lt;Text&gt;&lt;DateTime date={createdAt!}/&gt;&lt;/Text&gt;
        &lt;Text&gt;{updatedAt}&lt;/Text&gt;
      &lt;/Box&gt;
    &lt;/Grid&gt;
  );
}</file><file path="resources/app/modules/library-music/components/song-list/song-list.module.scss">.songListTable {
  height: calc(100vh - 260px);
  border-bottom: 1px solid #e0dddd;
}
.scrollList {
  border-right: 1px solid #e0dddd;
  border-bottom: 1px solid #e0dddd;
  overflow-x: auto;
  max-width: 100%;
  height: calc(100vh - 260px);
  .title {
    margin-left: 3px;
  }
  table {
    border-spacing: unset;
    table-layout: fixed;
    border-collapse: collapse;
  }
  th {
    background-color: var(--red-1);
    position: sticky;
    top: 0;
    z-index: 10;
    padding: 6px;
    text-align: left;
    font-weight: var(--font-weight-bold);
    font-size: 0.875rem;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
  }
  td {
    padding: 6px;
    text-align: left;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
  }
  tbody tr:hover {
    background-color: var(--accent-2);
  }
}
.listItem {
  cursor: pointer;
}
.titleCell {
  display: flex;
  align-items: center;
}
.titleCellNowPlayingIcon {
  color: var(--accent-8);
  margin-right: 8px;
}
.scrollbar {
  --sb-track-color: &apos;transparent&apos;;
  --sb-thumb-color: #828282;
  --sb-size: 6px;
}
.scrollbar::-webkit-scrollbar {
  width: var(--sb-size)
}
.scrollbar::-webkit-scrollbar-track {
  background: var(--sb-track-color);
  border-radius: 3px;
}
.scrollbar::-webkit-scrollbar-thumb {
  background: var(--sb-thumb-color);
  border-radius: 3px;
}
@supports not selector(::-webkit-scrollbar) {
  .scrollbar {
    scrollbar-color: var(--sb-thumb-color)
    var(--sb-track-color);
  }
}</file><file path="resources/app/modules/user-settings/pages/settings-overview.tsx">import { SettingsPageLayout } from &apos;@/modules/user-settings/layouts/settings-page-layout.tsx&apos;;
import { Box, Button } from &apos;@radix-ui/themes&apos;;
import { DevPanel } from &apos;@/modules/user-settings/features/dev-panel.tsx&apos;;
import { useAppDispatch, useAppSelector } from &apos;@/store/hooks.ts&apos;;
import { logoutUser } from &apos;@/store/users/auth-slice.ts&apos;;
import { setTheme } from &apos;@/store/users/ui-slice.ts&apos;;
export function SettingsOverview() {
  const { theme } = useAppSelector(state =&gt; state.ui);
  const dispatch = useAppDispatch();
  const toggleTheme = () =&gt; {
    dispatch(setTheme(theme === &apos;light&apos; ? &apos;dark&apos; : &apos;light&apos;));
  }
  return (
    &lt;SettingsPageLayout title=&quot;Settings&quot;&gt;
      &lt;a href=&quot;#&quot; onClick={() =&gt; dispatch(logoutUser())}&gt;
        &lt;span&gt;Logout&lt;/span&gt;
      &lt;/a&gt;
      &lt;Box&gt;
        &lt;Button onClick={() =&gt; toggleTheme()}&gt;Toggle Theme&lt;/Button&gt;
      &lt;/Box&gt;
      &lt;Box mt=&quot;2&quot;&gt;
        &lt;DevPanel/&gt;
      &lt;/Box&gt;
    &lt;/SettingsPageLayout&gt;
  );
}</file><file path="resources/app/vite-env.d.ts">/// &lt;reference types=&quot;vite-plugin-react-rich-svg/client&quot; /&gt;
/// &lt;reference types=&quot;vite/client&quot; /&gt;
/// &lt;reference types=&quot;unplugin-info/client&quot; /&gt;
global {
  let LARAVEL_TRANSLATIONS: any;
  interface Window {
    BaanderAppInfo: {
      name: string;
      environment: &apos;local&apos; | &apos;production&apos; | &apos;testing&apos;;
      debug: boolean;
      locale: string;
    }
  }
}</file><file path="resources/views/app.blade.php">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;{{ str_replace(&apos;_&apos;, &apos;-&apos;, app()-&gt;getLocale()) }}&quot; data-app-env=&quot;{{ config(&apos;app.env&apos;) }}&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;utf-8&quot;&gt;
    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1&quot;&gt;
    &lt;title&gt;{{ config(&apos;app.name&apos;) }}&lt;/title&gt;
    &lt;link rel=&quot;apple-touch-icon&quot; sizes=&quot;180x180&quot; href=&quot;{{ secure_url(&apos;/apple-touch-icon.png&apos;) }}&quot;&gt;
    &lt;link rel=&quot;icon&quot; type=&quot;image/png&quot; sizes=&quot;32x32&quot; href=&quot;{{ secure_url(&apos;/favicon-32x32.png&apos;) }}&quot;&gt;
    &lt;link rel=&quot;icon&quot; type=&quot;image/png&quot; sizes=&quot;16x16&quot; href=&quot;{{ secure_url(&apos;/favicon-16x16.png&apos;) }}&quot;&gt;
    &lt;link rel=&quot;manifest&quot; href=&quot;{{ secure_url(&apos;/manifest.json&apos;)  }}&quot;&gt;
    &lt;link rel=&quot;mask-icon&quot; href=&quot;{{ secure_url(&apos;/safari-pinned-tab.svg&apos;) }}&quot; color=&quot;#414141&quot;&gt;
    &lt;meta name=&quot;msapplication-TileColor&quot; content=&quot;#414141&quot;&gt;
    &lt;meta name=&quot;theme-color&quot; content=&quot;#ffffff&quot;&gt;
    &lt;meta property=&quot;csp-nonce&quot; content=&quot;{{ Vite::cspNonce() }}&quot;&gt;
    &lt;meta name=&quot;csrf-token&quot; content=&quot;{{ csrf_token() }}&quot;&gt;
    @if(app()-&gt;isLocal())
        @viteReactRefresh
    @endif
    @vite(&quot;resources/app/index.tsx&quot;)
    @routes(nonce: Vite::cspNonce())
    &lt;script nonce=&quot;{{ Vite::cspNonce() }}&quot;&gt;
      Ziggy.url = &apos;{{ config(&apos;app.url&apos;) }}&apos;
    &lt;/script&gt;
    &lt;script nonce=&quot;{{ Vite::cspNonce() }}&quot;&gt;
      window.BaanderAppInfo = @js($appInfo)
    &lt;/script&gt;
    &lt;style&gt;
        .clockwork-toolbar {
            display: none !important;
        }
    &lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;div id=&quot;baanderapproot&quot;&gt;&lt;/div&gt;
&lt;/body&gt;
&lt;/html&gt;</file><file path="start-swoole-server">#!/usr/bin/env php
&lt;?php

use App\Octane\OnWorkerStart;
use Laravel\Octane\RequestContext;
use Laravel\Octane\Swoole\{ServerStateFile, SwooleExtension, WorkerState};
use Laravel\Octane\Swoole\Handlers\{OnManagerStart, OnServerStart};
use Swoole\Http\Server;
use Swoole\Timer;

ini_set(&apos;display_errors&apos;, &apos;stderr&apos;);


$octanePath = __DIR__ . &apos;/vendor/laravel/octane&apos;;

if (!file_exists($octanePath)) {
    $octanePath = &apos;/var/www/vendor/laravel/octane&apos;;
}

require_once $octanePath . &apos;/src/Stream.php&apos;;
require_once $octanePath . &apos;/fixes/fix-symfony-dd.php&apos;;

$bootstrap = fn($serverState) =&gt; require $octanePath . &apos;/bin/bootstrap.php&apos;;

/*
|--------------------------------------------------------------------------
| Create The Swoole Server
|--------------------------------------------------------------------------
|
| First, we will load the server state file from disk. This file contains
| various information we need to boot Swoole such as the configuration
| and application name. We can use this data to start up our server.
|
*/

$serverState = json_decode(file_get_contents(
    $serverStateFile = $_SERVER[&apos;argv&apos;][1],
), true)[&apos;state&apos;];

$server = require $octanePath . &apos;/bin/createSwooleServer.php&apos;;

$timerTable = require $octanePath . &apos;/bin/createSwooleTimerTable.php&apos;;

/*
|--------------------------------------------------------------------------
| Handle Server &amp; Manager Start
|--------------------------------------------------------------------------
|
| The following callbacks manage the master process and manager process
| start events. These handlers primarily are responsible for writing
| the process ID to the server state file so we can remember them.
|
*/

$server-&gt;on(&apos;start&apos;, fn(Server $server) =&gt; $bootstrap($serverState) &amp;&amp; (new OnServerStart(
        new ServerStateFile($serverStateFile),
        new SwooleExtension,
        $serverState[&apos;appName&apos;],
        $serverState[&apos;octaneConfig&apos;][&apos;max_execution_time&apos;] ?? 0,
        $timerTable,
        $serverState[&apos;octaneConfig&apos;][&apos;tick&apos;] ?? true,
    ))($server));

$server-&gt;on(&apos;managerstart&apos;, fn() =&gt; $bootstrap($serverState) &amp;&amp; (new OnManagerStart(
        new SwooleExtension, $serverState[&apos;appName&apos;],
    ))());

/*
|--------------------------------------------------------------------------
| Handle Worker Start
|--------------------------------------------------------------------------
|
| Swoole will start multiple worker processes and the following callback
| will handle their state events. When a worker starts we will create
| a new Octane worker and inform it to start handling our requests.
|
| We will also create a &quot;workerState&quot; variable which will maintain state
| and allow us to access the worker and client from the callback that
| will handle incoming requests. Basically this works like a cache.
|
*/

require_once $octanePath . &apos;/bin/WorkerState.php&apos;;

$workerState = new WorkerState;

$workerState-&gt;cacheTable = require $octanePath . &apos;/bin/createSwooleCacheTable.php&apos;;
$workerState-&gt;timerTable = $timerTable;
$workerState-&gt;tables = require $octanePath . &apos;/bin/createSwooleTables.php&apos;;

$server-&gt;on(&apos;workerstart&apos;, fn(Server $server, $workerId)
    =&gt; (fn($basePath) =&gt; (new OnWorkerStart(
    new SwooleExtension, $basePath, $serverState, $workerState,
))($server, $workerId))($bootstrap($serverState)),
);

/*
|--------------------------------------------------------------------------
| Handle Incoming Requests
|--------------------------------------------------------------------------
|
| The following callback will handle all incoming requests plus send them
| the worker. The worker will send the request through the application
| and ask the client to send the response back to the Swoole server.
|
*/

$server-&gt;on(&apos;request&apos;, function ($request, $response) use ($server, $workerState, $serverState) {
    $workerState-&gt;lastRequestTime = microtime(true);

    if ($workerState-&gt;timerTable) {
        $workerState-&gt;timerTable-&gt;set($workerState-&gt;workerId, [
            &apos;worker_pid&apos; =&gt; $workerState-&gt;workerPid,
            &apos;time&apos;       =&gt; time(),
            &apos;fd&apos;         =&gt; $request-&gt;fd,
        ]);
    }

    $workerState-&gt;worker-&gt;handle(...$workerState-&gt;client-&gt;marshalRequest(new RequestContext([
        &apos;swooleRequest&apos;  =&gt; $request,
        &apos;swooleResponse&apos; =&gt; $response,
        &apos;publicPath&apos;     =&gt; $serverState[&apos;publicPath&apos;],
        &apos;octaneConfig&apos;   =&gt; $serverState[&apos;octaneConfig&apos;],
    ])));

    if ($workerState-&gt;timerTable) {
        $workerState-&gt;timerTable-&gt;del($workerState-&gt;workerId);
    }
});
/*
|--------------------------------------------------------------------------
| Handle Tasks
|--------------------------------------------------------------------------
|
| Swoole tasks can be used to offload concurrent work onto a group of
| background processes which handle the work in isolation and with
| separate application state. We should handle these tasks below.
|
*/

$server-&gt;on(&apos;task&apos;, fn(Server $server, int $taskId, int $fromWorkerId, $data)
    =&gt; $data === &apos;octane-tick&apos;
    ? $workerState-&gt;worker-&gt;handleTick()
    : $workerState-&gt;worker-&gt;handleTask($data),
);

$server-&gt;on(&apos;finish&apos;, fn(Server $server, int $taskId, $result) =&gt; $result);

/*
|--------------------------------------------------------------------------
| Handle Worker &amp; Server Shutdown
|--------------------------------------------------------------------------
|
| The following callbacks handle the master and worker shutdown events so
| we can clean up any state, including the server state file. An event
| will be dispatched by the worker so the developer can take action.
|
*/

$server-&gt;on(&apos;workerstop&apos;, function () use ($workerState) {
    if ($workerState-&gt;tickTimerId) {
        Timer::clear($workerState-&gt;tickTimerId);
    }

    $workerState-&gt;worker-&gt;terminate();
});

$server-&gt;start();</file><file path="tsconfig.json">{
  &quot;compilerOptions&quot;: {
    &quot;target&quot;: &quot;esnext&quot;,
    &quot;useDefineForClassFields&quot;: true,
    &quot;lib&quot;: [
      &quot;es2022&quot;,
      &quot;dom&quot;,
      &quot;DOM.Iterable&quot;,
      &quot;WebWorker&quot;
    ],
    &quot;module&quot;: &quot;esnext&quot;,
    &quot;skipLibCheck&quot;: true,
    &quot;esModuleInterop&quot;: true,
    /* Bundler mode */
    &quot;moduleResolution&quot;: &quot;node&quot;,
    &quot;allowImportingTsExtensions&quot;: true,
    &quot;resolveJsonModule&quot;: true,
    &quot;isolatedModules&quot;: true,
    &quot;noEmit&quot;: true,
    &quot;jsx&quot;: &quot;react-jsx&quot;,
    /* Linting */
    &quot;strict&quot;: true,
    &quot;noUnusedLocals&quot;: true,
    &quot;noUnusedParameters&quot;: true,
    &quot;noFallthroughCasesInSwitch&quot;: true,
    &quot;baseUrl&quot;: &quot;./resources/app&quot;,
    &quot;paths&quot;: {
      &quot;@/*&quot;: [
        &quot;*&quot;
      ]
    },
  },
  &quot;include&quot;: [
    &quot;resources/app&quot;
  ],
  &quot;references&quot;: [
    {
      &quot;path&quot;: &quot;./tsconfig.node.json&quot;
    }
  ],
  &quot;extends&quot;: &quot;./tsconfig.paths.json&quot;
}</file><file path="app/Http/Controllers/Api/ArtistController.php">&lt;?php
namespace App\Http\Controllers\Api;
use App\Http\Requests\Artist\ArtistIndexRequest;
use App\Http\Resources\Artist\ArtistResource;
use App\Models\{Artist, TokenAbility};
use App\Modules\Pagination\JsonPaginator;
use Spatie\RouteAttributes\Attributes\{Get, Middleware, Prefix};
#[Prefix(&apos;/libraries/{library}/artists&apos;)]
#[Middleware([
    &apos;auth:sanctum&apos;,
    &apos;ability:&apos; . TokenAbility::ACCESS_API-&gt;value,
    &apos;force.json&apos;,
])]
class ArtistController
{
    /**
     * Get a collection of artists
     *
     * @return \Illuminate\Http\Resources\Json\AnonymousResourceCollection&lt;JsonPaginator&lt;ArtistResource&gt;&gt;
     */
    #[Get(&apos;/&apos;, &apos;api.artists.index&apos;)]
    public function index(ArtistIndexRequest $request)
    {
        $fields = $request-&gt;query(&apos;fields&apos;);
        $relations = $request-&gt;query(&apos;relations&apos;);
        $data = Artist::query()
            -&gt;selectFields(Artist::$filterFields, $fields)
            -&gt;withRelations(Artist::$filterRelations, $relations)
            -&gt;paginate();
        return ArtistResource::collection($data);
    }
    /**
     * Get an artist
     *
     * @param Artist $artist
     * @return ArtistResource
     */
    #[Get(&apos;{artist}&apos;, &apos;api.artists.show&apos;)]
    public function show(Artist $artist)
    {
        return new ArtistResource($artist);
    }
}</file><file path="app/Http/Controllers/Api/JobController.php">&lt;?php
namespace App\Http\Controllers\Api;
use App\Exceptions\Jobs\Manager\CouldNotFindJobException;
use App\Http\Controllers\Controller;
use App\Jobs\Library\Music\ScanMusicLibraryJob;
use App\Jobs\Movies\ScanMovieLibraryJob;
use App\Models\{Library, TokenAbility};
use Illuminate\Database\Eloquent\ModelNotFoundException;
use Illuminate\Foundation\Bus\DispatchesJobs;
use Illuminate\Http\Request;
use Spatie\RouteAttributes\Attributes\{Middleware, Post, Prefix};
#[Prefix(&apos;jobs&apos;)]
#[Middleware([
    &apos;auth:sanctum&apos;,
    &apos;ability:&apos; . TokenAbility::ACCESS_API-&gt;value,
    &apos;force.json&apos;,
])]
class JobController extends Controller
{
    use DispatchesJobs;
    /**
     * Scan a library
     */
    #[Post(&apos;/scanLibrary/{slug}&apos;, &apos;api.job.library-scan&apos;)]
    public function startLibraryScan(Request $request)
    {
        $this-&gt;gateCheckExecuteJob();
        $slug = $request-&gt;route(&apos;slug&apos;);
        try {
            $library = Library::whereSlug($slug)-&gt;firstOrFail();
        } catch (ModelNotFoundException $e) {
            throw CouldNotFindJobException::throwFromController($e);
        }
        $job = match ($library-&gt;type) {
            &apos;movie&apos; =&gt; new ScanMovieLibraryJob($library),
            &apos;music&apos; =&gt; new ScanMusicLibraryJob($library),
        };
        $this-&gt;dispatch($job);
        return [
            &apos;message&apos; =&gt; &apos;Job started successfully&apos;,
        ];
    }
}</file><file path="app/Http/Kernel.php">&lt;?php
namespace App\Http;
use Illuminate\Foundation\Http\Kernel as HttpKernel;
class Kernel extends HttpKernel
{
    /**
     * The application&apos;s global HTTP middleware stack.
     *
     * These middleware are run during every request to your application.
     *
     * @var array&lt;int, class-string|string&gt;
     */
    protected $middleware = [
        // \App\Http\Middleware\TrustHosts::class,
        \App\Http\Middleware\TrustProxies::class,
        \Illuminate\Http\Middleware\HandleCors::class,
        \App\Http\Middleware\PreventRequestsDuringMaintenance::class,
        \Illuminate\Foundation\Http\Middleware\ValidatePostSize::class,
        \App\Http\Middleware\TrimStrings::class,
        \Illuminate\Foundation\Http\Middleware\ConvertEmptyStringsToNull::class,
        //        \App\Http\Middleware\SecurityHeadersMiddleware::class,
        \App\Modules\Apm\Middleware\ApmMiddleware::class,
        \App\Modules\Apm\Middleware\SwooleMetricsSampler::class,
    ];
    /**
     * The application&apos;s route middleware groups.
     *
     * @var array&lt;string, array&lt;int, class-string|string&gt;&gt;
     */
    protected $middlewareGroups = [
        &apos;web&apos; =&gt; [
            \App\Http\Middleware\EncryptCookies::class,
            \Illuminate\Cookie\Middleware\AddQueuedCookiesToResponse::class,
            \Illuminate\Session\Middleware\StartSession::class,
            \Illuminate\View\Middleware\ShareErrorsFromSession::class,
            \App\Http\Middleware\VerifyCsrfToken::class,
            //            \App\Http\Middleware\AddContentSecurityPolicyHeaders::class,
            \Illuminate\Routing\Middleware\SubstituteBindings::class,
        ],
        &apos;api&apos; =&gt; [
            \Laravel\Sanctum\Http\Middleware\EnsureFrontendRequestsAreStateful::class,
            \App\Http\Middleware\ConvertQueryTokenToHeaderMiddleware::class,
            \Illuminate\Routing\Middleware\ThrottleRequests::class . &apos;:api&apos;,
            \Illuminate\Routing\Middleware\SubstituteBindings::class,
        ],
        &apos;public-api&apos; =&gt; [
            // \Illuminate\Routing\Middleware\ThrottleRequests::class . &apos;:publicApi&apos;,
            \Illuminate\Routing\Middleware\SubstituteBindings::class,
        ],
    ];
    /**
     * The application&apos;s middleware aliases.
     *
     * Aliases may be used instead of class names to conveniently assign middleware to routes and groups.
     *
     * @var array&lt;string, class-string|string&gt;
     */
    protected $middlewareAliases = [
        &apos;abilities&apos;        =&gt; \Laravel\Sanctum\Http\Middleware\CheckAbilities::class,
        &apos;ability&apos;          =&gt; \Laravel\Sanctum\Http\Middleware\CheckForAnyAbility::class,
        &apos;auth&apos;             =&gt; \App\Http\Middleware\Authenticate::class,
        &apos;auth.basic&apos;       =&gt; \Illuminate\Auth\Middleware\AuthenticateWithBasicAuth::class,
        &apos;auth.session&apos;     =&gt; \Illuminate\Session\Middleware\AuthenticateSession::class,
        &apos;cache.headers&apos;    =&gt; \Illuminate\Http\Middleware\SetCacheHeaders::class,
        &apos;can&apos;              =&gt; \Illuminate\Auth\Middleware\Authorize::class,
        &apos;force.json&apos;       =&gt; \App\Http\Middleware\ForceJsonResponse::class,
        &apos;guest&apos;            =&gt; \App\Http\Middleware\RedirectIfAuthenticated::class,
        &apos;password.confirm&apos; =&gt; \Illuminate\Auth\Middleware\RequirePassword::class,
        &apos;precognitive&apos;     =&gt; \Illuminate\Foundation\Http\Middleware\HandlePrecognitiveRequests::class,
        &apos;signed&apos;           =&gt; \App\Http\Middleware\ValidateSignature::class,
        &apos;throttle&apos;         =&gt; \Illuminate\Routing\Middleware\ThrottleRequests::class,
        &apos;verified&apos;         =&gt; \Illuminate\Auth\Middleware\EnsureEmailIsVerified::class,
    ];
}</file><file path="app/Http/Requests/Album/AlbumIndexRequest.php">&lt;?php
namespace App\Http\Requests\Album;
use Illuminate\Foundation\Http\FormRequest;
class AlbumIndexRequest extends FormRequest
{
    /**
     * Determine if the user is authorized to make this request.
     */
    public function authorize(): bool
    {
        return true;
    }
    /**
     * Get the validation rules that apply to the request.
     *
     * @return array&lt;string, \Illuminate\Contracts\Validation\ValidationRule|array&lt;mixed&gt;|string&gt;
     */
    public function rules(): array
    {
        return [
            /**
             * @query
             * Comma seperated string of fields you want to select. If nothing is defined `select *` is default.
             * - title
             * - slug
             * - year
             * - directory
             */
            &apos;fields&apos;    =&gt; &apos;string&apos;,
            /**
             * @query
             * Comma seperated string of relations
             * - artists
             * - cover
             * - library
             * - songs
             */
            &apos;relations&apos; =&gt; &apos;string&apos;,
            /**
             * @query
             * Current page
             */
            &apos;page&apos;      =&gt; &apos;int&apos;,
            /**
             * @query
             * Items per page
             */
            &apos;limit&apos;     =&gt; &apos;int&apos;,
            /**
             * @query
             * _Extension_ Comma seperated list of genres
             */
            &apos;genres&apos;    =&gt; &apos;string&apos;,
        ];
    }
}</file><file path="app/Http/Resources/Album/AlbumWithoutSongsResource.php">&lt;?php
namespace App\Http\Resources\Album;
use App\Http\Resources\Artist\ArtistResource;
use App\Http\Resources\HasJsonCollection;
use App\Http\Resources\Image\ImageResource;
use App\Models\Album;
use Illuminate\Http\Request;
use Illuminate\Http\Resources\Json\JsonResource;
/**
 * @mixin Album
 */
class AlbumWithoutSongsResource extends JsonResource
{
    use HasJsonCollection;
    /**
     * Transform the resource into an array.
     *
     * @return array&lt;string, mixed&gt;
     */
    public function toArray(Request $request): array
    {
        return [
            &apos;title&apos;     =&gt; $this-&gt;title,
            &apos;slug&apos;      =&gt; $this-&gt;slug,
            &apos;year&apos;      =&gt; $this-&gt;year,
            &apos;createdAt&apos; =&gt; $this-&gt;created_at,
            &apos;updatedAt&apos; =&gt; $this-&gt;updated_at,
            /**
             * Cover relation
             */
            &apos;cover&apos;     =&gt; ImageResource::make($this-&gt;whenLoaded(&apos;cover&apos;)),
            /**
             * Album artist relation
             */
            &apos;artists&apos;   =&gt; ArtistResource::make($this-&gt;whenLoaded(&apos;artists&apos;)),
        ];
    }
}</file><file path="app/Models/BasePivot.php">&lt;?php
namespace App\Models;
use App\Modules\Eloquent\BaseBuilder;
use GeneaLabs\LaravelPivotEvents\Traits\PivotEventTrait;
use Illuminate\Database\Eloquent\Relations\Pivot;
abstract class BasePivot extends Pivot
{
    public $incrementing = true;
    protected $dateFormat = &apos;Y-m-d H:i:sO&apos;;
    public function newEloquentBuilder($query)
    {
        return new BaseBuilder($query);
    }
}</file><file path="config/route-attributes.php">&lt;?php
return [
    /*
     *  Automatic registration of routes will only happen if this setting is `true`
     */
    &apos;enabled&apos;     =&gt; true,
    /*
     * Controllers in these directories that have routing attributes
     * will automatically be registered.
     *
     * Optionally, you can specify group configuration by using key/values
     */
    &apos;directories&apos; =&gt; [
        app_path(&apos;Http/Controllers/Api&apos;) =&gt; [
            &apos;prefix&apos;     =&gt; &apos;api&apos;,
            &apos;middleware&apos; =&gt; &apos;api&apos;,
            &apos;patterns&apos;   =&gt; [&apos;*Controller.php&apos;],
        ],
        app_path(&apos;Http/Controllers/Web&apos;) =&gt; [
            &apos;middleware&apos; =&gt; &apos;web&apos;,
            &apos;patterns&apos;   =&gt; [&apos;*Controller.php&apos;],
        ],
    ],
    /**
     * This middleware will be applied to all routes.
     */
    &apos;middleware&apos;  =&gt; [
        \Illuminate\Routing\Middleware\SubstituteBindings::class,
    ],
];</file><file path="Makefile">export WEB_PORT_HTTP=80
export WEB_PORT_SSL=443
export XDEBUG_CONFIG=main
export XDEBUG_VERSION=3.3.2

# Determine if .env file exist
ifneq (&quot;$(wildcard .env)&quot;,&quot;&quot;)
	include .env
endif

HOST_UID := $(shell id -u)
HOST_GID := $(shell id -g)
PHP_USER := -u www-data
INTERACTIVE := $(shell [ -t 0 ] &amp;&amp; echo 1)
ERROR_ONLY_FOR_HOST = @printf &quot;\033[33mThis command for host machine\033[39m\n&quot;

ifndef INSIDE_DOCKER_CONTAINER
	INSIDE_DOCKER_CONTAINER = 0
endif

help: ## Shows available commands with description
	@echo &quot;\033[34mList of available commands:\033[39m&quot;
	@grep -E &apos;^[a-zA-Z-]+:.*?## .*$$&apos; Makefile | sort | awk &apos;BEGIN {FS = &quot;:.*?## &quot;}; {printf &quot;[32m%-27s[0m %s\n&quot;, $$1, $$2}&apos;

build: ## Build dev environment
ifeq ($(INSIDE_DOCKER_CONTAINER), 0)
	@HOST_UID=$(HOST_UID) HOST_GID=$(HOST_GID) WEB_PORT_HTTP=$(WEB_PORT_HTTP) WEB_PORT_SSL=$(WEB_PORT_SSL) XDEBUG_CONFIG=$(XDEBUG_CONFIG) XDEBUG_VERSION=$(XDEBUG_VERSION) docker compose -f docker-compose.yml build --progress=plain
else
	$(ERROR_ONLY_FOR_HOST)
endif

build-clean: ## Build dev environment
ifeq ($(INSIDE_DOCKER_CONTAINER), 0)
	@HOST_UID=$(HOST_UID) HOST_GID=$(HOST_GID) WEB_PORT_HTTP=$(WEB_PORT_HTTP) WEB_PORT_SSL=$(WEB_PORT_SSL) XDEBUG_CONFIG=$(XDEBUG_CONFIG) XDEBUG_VERSION=$(XDEBUG_VERSION) docker compose -f docker-compose.yml build --progress=plain --no-cache
else
	$(ERROR_ONLY_FOR_HOST)
endif

build-ffmpeg: ## Build the ffmpeg Docker image
	cd docker/ffmpeg; docker build --progress=plain --tag martinjuul/ffmpeg-baander-static:latest .; cd ../..

build-all:
	build-ffmpeg build-clean

start: ## Start dev environment
ifeq ($(INSIDE_DOCKER_CONTAINER), 0)
	@HOST_UID=$(HOST_UID) HOST_GID=$(HOST_GID) WEB_PORT_HTTP=$(WEB_PORT_HTTP) WEB_PORT_SSL=$(WEB_PORT_SSL) XDEBUG_CONFIG=$(XDEBUG_CONFIG) XDEBUG_VERSION=$(XDEBUG_VERSION) docker compose -f docker-compose.yml up -d
else
	$(ERROR_ONLY_FOR_HOST)
endif

stop: ## Stop dev environment containers
ifeq ($(INSIDE_DOCKER_CONTAINER), 0)
	@HOST_UID=$(HOST_UID) HOST_GID=$(HOST_GID) WEB_PORT_HTTP=$(WEB_PORT_HTTP) WEB_PORT_SSL=$(WEB_PORT_SSL) XDEBUG_CONFIG=$(XDEBUG_CONFIG) XDEBUG_VERSION=$(XDEBUG_VERSION) docker compose -f docker-compose.yml stop
else
	$(ERROR_ONLY_FOR_HOST)
endif

down: ## Stop and remove dev environment containers, networks
ifeq ($(INSIDE_DOCKER_CONTAINER), 0)
	@HOST_UID=$(HOST_UID) HOST_GID=$(HOST_GID) WEB_PORT_HTTP=$(WEB_PORT_HTTP) WEB_PORT_SSL=$(WEB_PORT_SSL) XDEBUG_CONFIG=$(XDEBUG_CONFIG) XDEBUG_VERSION=$(XDEBUG_VERSION) docker-compose -f docker-compose.yml down
else
	$(ERROR_ONLY_FOR_HOST)
endif

restart: stop start ## Stop and start dev environment

env-dev: ## Creates config for dev environment
	@make exec cmd=&quot;cp ./.env.example ./.env&quot;

restart-app: ## Get bash inside laravel docker container
ifeq ($(INSIDE_DOCKER_CONTAINER), 0)
	@HOST_UID=$(HOST_UID) HOST_GID=$(HOST_GID) WEB_PORT_HTTP=$(WEB_PORT_HTTP) WEB_PORT_SSL=$(WEB_PORT_SSL) XDEBUG_CONFIG=$(XDEBUG_CONFIG) XDEBUG_VERSION=$(XDEBUG_VERSION) docker-compose restart app
else
	$(ERROR_ONLY_FOR_HOST)
endif

ssh: ## Get bash inside laravel docker container
ifeq ($(INSIDE_DOCKER_CONTAINER), 0)
	@HOST_UID=$(HOST_UID) HOST_GID=$(HOST_GID) WEB_PORT_HTTP=$(WEB_PORT_HTTP) WEB_PORT_SSL=$(WEB_PORT_SSL) XDEBUG_CONFIG=$(XDEBUG_CONFIG) XDEBUG_VERSION=$(XDEBUG_VERSION) docker-compose exec $(OPTION_T) $(PHP_USER) app bash
else
	$(ERROR_ONLY_FOR_HOST)
endif

ssh-root: ## Get bash as root user inside laravel docker container
ifeq ($(INSIDE_DOCKER_CONTAINER), 0)
	@HOST_UID=$(HOST_UID) HOST_GID=$(HOST_GID) WEB_PORT_HTTP=$(WEB_PORT_HTTP) WEB_PORT_SSL=$(WEB_PORT_SSL) XDEBUG_CONFIG=$(XDEBUG_CONFIG) XDEBUG_VERSION=$(XDEBUG_VERSION) docker-compose  exec $(OPTION_T) app bash
else
	$(ERROR_ONLY_FOR_HOST)
endif

ssh-nginx: ## Get bash inside nginx docker container
ifeq ($(INSIDE_DOCKER_CONTAINER), 0)
	@HOST_UID=$(HOST_UID) HOST_GID=$(HOST_GID) WEB_PORT_HTTP=$(WEB_PORT_HTTP) WEB_PORT_SSL=$(WEB_PORT_SSL) XDEBUG_CONFIG=$(XDEBUG_CONFIG) XDEBUG_VERSION=$(XDEBUG_VERSION) docker-compose  exec nginx /bin/sh
else
	$(ERROR_ONLY_FOR_HOST)
endif

exec:
ifeq ($(INSIDE_DOCKER_CONTAINER), 1)
	@$$cmd
else
	@HOST_UID=$(HOST_UID) HOST_GID=$(HOST_GID) WEB_PORT_HTTP=$(WEB_PORT_HTTP) WEB_PORT_SSL=$(WEB_PORT_SSL) XDEBUG_CONFIG=$(XDEBUG_CONFIG) XDEBUG_VERSION=$(XDEBUG_VERSION) docker-compose exec $(OPTION_T) $(PHP_USER) app $$cmd
endif

exec-bash:
ifeq ($(INSIDE_DOCKER_CONTAINER), 1)
	@bash -c &quot;$(cmd)&quot;
else
	@HOST_UID=$(HOST_UID) HOST_GID=$(HOST_GID) WEB_PORT_HTTP=$(WEB_PORT_HTTP) WEB_PORT_SSL=$(WEB_PORT_SSL) XDEBUG_CONFIG=$(XDEBUG_CONFIG) XDEBUG_VERSION=$(XDEBUG_VERSION) docker-compose  exec $(OPTION_T) $(PHP_USER) app bash -c &quot;$(cmd)&quot;
endif

exec-by-root:
ifeq ($(INSIDE_DOCKER_CONTAINER), 0)
	@HOST_UID=$(HOST_UID) HOST_GID=$(HOST_GID) WEB_PORT_HTTP=$(WEB_PORT_HTTP) WEB_PORT_SSL=$(WEB_PORT_SSL) XDEBUG_CONFIG=$(XDEBUG_CONFIG) XDEBUG_VERSION=$(XDEBUG_VERSION) docker-compose  exec $(OPTION_T) app $$cmd
else
	$(ERROR_ONLY_FOR_HOST)
endif

composer-install-no-dev: ## Installs composer no-dev dependencies
	@make exec-bash cmd=&quot;COMPOSER_MEMORY_LIMIT=-1 composer install --optimize-autoloader --no-dev&quot;

composer-install: ## Installs composer dependencies
	@make exec-bash cmd=&quot;COMPOSER_MEMORY_LIMIT=-1 composer install --optimize-autoloader&quot;

composer-update: ## Updates composer dependencies
	@make exec-bash cmd=&quot;COMPOSER_MEMORY_LIMIT=-1 composer update&quot;

key-generate: ## Sets the application key
	@make exec cmd=&quot;php artisan key:generate&quot;

info: ## Shows Php and Laravel version
	@make exec cmd=&quot;php artisan --version&quot;
	@make exec cmd=&quot;php artisan env&quot;
	@make exec cmd=&quot;php --version&quot;
	@make exec cmd=&quot;composer --version&quot;

logs: ## Shows logs from the laravel container. Use ctrl+c in order to exit
ifeq ($(INSIDE_DOCKER_CONTAINER), 0)
	@docker logs -f baander-app
else
	$(ERROR_ONLY_FOR_HOST)
endif

logs-nginx: ## Shows logs from the nginx container. Use ctrl+c in order to exit
ifeq ($(INSIDE_DOCKER_CONTAINER), 0)
	@docker logs -f baander-nginx
else
	$(ERROR_ONLY_FOR_HOST)
endif

drop-migrate: ## Drops databases and runs all migrations for the main/test databases
	@make exec cmd=&quot;php artisan migrate:fresh&quot;
	@make exec cmd=&quot;php artisan migrate:fresh --env=test&quot;

migrate-no-test: ## Runs all migrations for main database
	@make exec cmd=&quot;php artisan migrate --force&quot;

migrate: ## Runs all migrations for main/test databases
	@make exec cmd=&quot;php artisan migrate --force&quot;
	@make exec cmd=&quot;php artisan migrate --force --env=test&quot;

seed: ## Runs all seeds for test database
	@make exec cmd=&quot;php artisan db:seed --force&quot;

phpunit: ## Runs PhpUnit tests
	@make exec cmd=&quot;./vendor/bin/phpunit -c phpunit.xml --coverage-html reports/coverage $(PHPUNIT_OPTIONS) --coverage-clover reports/clover.xml --log-junit reports/junit.xml&quot;

typescript-transform:
	@make exec cmd=&quot;php artisan typescript:transform&quot;

ziggy-routes:
	@make exec cmd=&quot;php artisan ziggy:generate resources/app/ziggy.js&quot;

composer-normalize: ## Normalizes composer.json file content
	@make exec cmd=&quot;composer normalize&quot;

composer-validate: ## Validates composer.json file content
	@make exec cmd=&quot;composer validate --no-check-version&quot;

composer-require-checker: ## Checks the defined dependencies against your code
	@make exec-bash cmd=&quot;XDEBUG_MODE=off php ./vendor/bin/composer-require-checker&quot;

composer-unused: ## Shows unused packages by scanning and comparing package namespaces against your code
	@make exec-bash cmd=&quot;XDEBUG_MODE=off php ./vendor/bin/composer-unused&quot;</file><file path="README.md">&lt;div align=&quot;center&quot;&gt;
    &lt;a href=&quot;https://baander.app&quot; target=&quot;_blank&quot;&gt;
        &lt;img src=&quot;/docs/assets/baander-logo.svg&quot; width=&quot;200&quot; alt=&quot;Baander Logo&quot;&gt;
        &lt;p style=&quot;font-weight:bold;font-size:48px&quot;&gt;Bånder&lt;/p&gt;
    &lt;/a&gt;
&lt;/div&gt;


&lt;h4 align=&quot;center&quot;&gt;Media server for the modern generation&lt;/h4&gt;

&lt;div&gt;
    &lt;img alt=&quot;GitHub License&quot; src=&quot;https://img.shields.io/github/license/baander-app/baander&quot;&gt;
    &lt;img alt=&quot;GitHub top language&quot; src=&quot;https://img.shields.io/github/languages/top/baander-app/baander&quot;&gt;

&lt;/div&gt;

## Table of Contents

&lt;!-- TOC --&gt;
  * [Table of Contents](#table-of-contents)
  * [Development](#development)
  * [License](#license)
  * [Copyright](#copyright)
&lt;!-- TOC --&gt;

## Development

- [Configure host](/docs/dev_setup_host.md)
- [Platform development](/docs/dev_workflow.md)
- [Test users](/docs/dev_users.md)
- [Docker services](/docs/dev_docker_services.md)
- [Phpstorm configuration](/docs/phpstorm.md)
- [Using XDebug](/docs/xdebug.md)

# Screenshots

![#login page](/docs/images/readme/page_login.png)
![#albums page](/docs/images/readme/page_albums.png)
![#songs page](/docs/images/readme/page_songs.png)
![#songs lyrics page](/docs/images/readme/page_songs_lyrics.png)

## Api documentation

We use [Scramble](https://scramble.dedoc.co/) to generate the documentation.

Visit `yourapp.tld/api/docs` for the documentation page.
![#login page](/docs/images/readme/page_api_docs.png)

The openapi collection is available at `yourapp.tld/api/docs.json`

## License

Apache 2.0 See [LICENSE](/LICENSE)

## Copyright

Copyright 2024 &lt;a href=&quot;https://www.juul.xyz/&quot;&gt;Martin Christiansen&lt;/a&gt;</file><file path="resources/app/api-client/queries/ensureQueryData.ts">// generated with @7nohe/openapi-react-query-codegen@1.6.2 
import { type QueryClient } from &quot;@tanstack/react-query&quot;;
import { AlbumService, ArtistService, AuthService, BatchesService, CompletedJobsService, DashboardStatsService, FailedJobsService, FilesService, FoldersService, GenreService, HostsService, ImageService, JobMetricsService, JobsService, LibraryService, LogsService, MasterSupervisorService, MonitoringService, MovieService, OpCacheService, PasskeyService, PendingJobsService, PlaylistService, QueueMetricsService, QueueService, SchemaService, SilencedJobsService, SongService, StreamService, SystemInfoService, UserService, UserTokenService, WorkloadService } from &quot;../requests/services.gen&quot;;
import * as Common from &quot;./common&quot;;
/**
* Get a collection of albums
* @param data The data for the request.
* @param data.library The library slug
* @param data.fields
* @param data.relations
* @param data.page
* @param data.limit
* @param data.genres
* @returns unknown Paginated set of `AlbumResource`
* @throws ApiError
*/
export const ensureUseAlbumServiceGetApiLibrariesByLibraryAlbumsData = (queryClient: QueryClient, { fields, genres, library, limit, page, relations }: {
  fields?: string;
  genres?: string;
  library: string;
  limit?: number;
  page?: number;
  relations?: string;
}) =&gt; queryClient.ensureQueryData({ queryKey: Common.UseAlbumServiceGetApiLibrariesByLibraryAlbumsKeyFn({ fields, genres, library, limit, page, relations }), queryFn: () =&gt; AlbumService.getApiLibrariesByLibraryAlbums({ fields, genres, library, limit, page, relations }) });
/**
* Get an album
* @param data The data for the request.
* @param data.library The library slug
* @param data.album The album slug
* @returns AlbumResource `AlbumResource`
* @throws ApiError
*/
export const ensureUseAlbumServiceGetApiLibrariesByLibraryAlbumsByAlbumData = (queryClient: QueryClient, { album, library }: {
  album: string;
  library: string;
}) =&gt; queryClient.ensureQueryData({ queryKey: Common.UseAlbumServiceGetApiLibrariesByLibraryAlbumsByAlbumKeyFn({ album, library }), queryFn: () =&gt; AlbumService.getApiLibrariesByLibraryAlbumsByAlbum({ album, library }) });
/**
* Get a collection of artists
* @param data The data for the request.
* @param data.library
* @param data.fields
* @param data.relations
* @param data.page
* @param data.limit
* @param data.genres
* @returns unknown Paginated set of `ArtistResource`
* @throws ApiError
*/
export const ensureUseArtistServiceGetApiLibrariesByLibraryArtistsData = (queryClient: QueryClient, { fields, genres, library, limit, page, relations }: {
  fields?: string;
  genres?: string;
  library: string;
  limit?: number;
  page?: number;
  relations?: string;
}) =&gt; queryClient.ensureQueryData({ queryKey: Common.UseArtistServiceGetApiLibrariesByLibraryArtistsKeyFn({ fields, genres, library, limit, page, relations }), queryFn: () =&gt; ArtistService.getApiLibrariesByLibraryArtists({ fields, genres, library, limit, page, relations }) });
/**
* Get an artist
* @param data The data for the request.
* @param data.library
* @param data.artist The artist slug
* @returns ArtistResource `ArtistResource`
* @throws ApiError
*/
export const ensureUseArtistServiceGetApiLibrariesByLibraryArtistsByArtistData = (queryClient: QueryClient, { artist, library }: {
  artist: string;
  library: string;
}) =&gt; queryClient.ensureQueryData({ queryKey: Common.UseArtistServiceGetApiLibrariesByLibraryArtistsByArtistKeyFn({ artist, library }), queryFn: () =&gt; ArtistService.getApiLibrariesByLibraryArtistsByArtist({ artist, library }) });
/**
* Get a passkey challenge
* @returns unknown
* @throws ApiError
*/
export const ensureUseAuthServiceGetWebauthnPasskeyData = (queryClient: QueryClient) =&gt; queryClient.ensureQueryData({ queryKey: Common.UseAuthServiceGetWebauthnPasskeyKeyFn(), queryFn: () =&gt; AuthService.getWebauthnPasskey() });
/**
* Get passkey registration options
* @returns unknown
* @throws ApiError
*/
export const ensureUseAuthServiceGetWebauthnPasskeyRegisterData = (queryClient: QueryClient) =&gt; queryClient.ensureQueryData({ queryKey: Common.UseAuthServiceGetWebauthnPasskeyRegisterKeyFn(), queryFn: () =&gt; AuthService.getWebauthnPasskeyRegister() });
/**
* Get a passkey challenge
* @returns unknown
* @throws ApiError
*/
export const ensureUsePasskeyServiceGetWebauthnPasskeyData = (queryClient: QueryClient) =&gt; queryClient.ensureQueryData({ queryKey: Common.UsePasskeyServiceGetWebauthnPasskeyKeyFn(), queryFn: () =&gt; PasskeyService.getWebauthnPasskey() });
/**
* Get passkey registration options
* @returns unknown
* @throws ApiError
*/
export const ensureUsePasskeyServiceGetWebauthnPasskeyRegisterData = (queryClient: QueryClient) =&gt; queryClient.ensureQueryData({ queryKey: Common.UsePasskeyServiceGetWebauthnPasskeyRegisterKeyFn(), queryFn: () =&gt; PasskeyService.getWebauthnPasskeyRegister() });
/**
* Get all of the batches
* @returns unknown
* @throws ApiError
*/
export const ensureUseBatchesServiceGetHorizonApiBatchesData = (queryClient: QueryClient) =&gt; queryClient.ensureQueryData({ queryKey: Common.UseBatchesServiceGetHorizonApiBatchesKeyFn(), queryFn: () =&gt; BatchesService.getHorizonApiBatches() });
/**
* Get the details of a batch by ID
* @param data The data for the request.
* @param data.id
* @returns unknown
* @throws ApiError
*/
export const ensureUseBatchesServiceGetHorizonApiBatchesByIdData = (queryClient: QueryClient, { id }: {
  id: string;
}) =&gt; queryClient.ensureQueryData({ queryKey: Common.UseBatchesServiceGetHorizonApiBatchesByIdKeyFn({ id }), queryFn: () =&gt; BatchesService.getHorizonApiBatchesById({ id }) });
/**
* Get all of the completed jobs
* @param data The data for the request.
* @param data.startingAt
* @returns unknown
* @throws ApiError
*/
export const ensureUseCompletedJobsServiceGetHorizonApiJobsCompletedData = (queryClient: QueryClient, { startingAt }: {
  startingAt?: string;
} = {}) =&gt; queryClient.ensureQueryData({ queryKey: Common.UseCompletedJobsServiceGetHorizonApiJobsCompletedKeyFn({ startingAt }), queryFn: () =&gt; CompletedJobsService.getHorizonApiJobsCompleted({ startingAt }) });
/**
* Get the key performance stats for the dashboard
* @returns unknown
* @throws ApiError
*/
export const ensureUseDashboardStatsServiceGetHorizonApiStatsData = (queryClient: QueryClient) =&gt; queryClient.ensureQueryData({ queryKey: Common.UseDashboardStatsServiceGetHorizonApiStatsKeyFn(), queryFn: () =&gt; DashboardStatsService.getHorizonApiStats() });
/**
* Get all of the failed jobs
* @param data The data for the request.
* @param data.tag
* @returns unknown
* @throws ApiError
*/
export const ensureUseFailedJobsServiceGetHorizonApiJobsFailedData = (queryClient: QueryClient, { tag }: {
  tag?: string;
} = {}) =&gt; queryClient.ensureQueryData({ queryKey: Common.UseFailedJobsServiceGetHorizonApiJobsFailedKeyFn({ tag }), queryFn: () =&gt; FailedJobsService.getHorizonApiJobsFailed({ tag }) });
/**
* Get a failed job instance
* @param data The data for the request.
* @param data.id
* @returns unknown
* @throws ApiError
*/
export const ensureUseFailedJobsServiceGetHorizonApiJobsFailedByIdData = (queryClient: QueryClient, { id }: {
  id: string;
}) =&gt; queryClient.ensureQueryData({ queryKey: Common.UseFailedJobsServiceGetHorizonApiJobsFailedByIdKeyFn({ id }), queryFn: () =&gt; FailedJobsService.getHorizonApiJobsFailedById({ id }) });
/**
* @returns LogFileResource Array of `LogFileResource`
* @throws ApiError
*/
export const ensureUseFilesServiceGetSystemLogViewerApiFilesData = (queryClient: QueryClient) =&gt; queryClient.ensureQueryData({ queryKey: Common.UseFilesServiceGetSystemLogViewerApiFilesKeyFn(), queryFn: () =&gt; FilesService.getSystemLogViewerApiFiles() });
/**
* @param data The data for the request.
* @param data.fileIdentifier
* @returns unknown
* @throws ApiError
*/
export const ensureUseFilesServiceGetSystemLogViewerApiFilesByFileIdentifierDownloadRequestData = (queryClient: QueryClient, { fileIdentifier }: {
  fileIdentifier: string;
}) =&gt; queryClient.ensureQueryData({ queryKey: Common.UseFilesServiceGetSystemLogViewerApiFilesByFileIdentifierDownloadRequestKeyFn({ fileIdentifier }), queryFn: () =&gt; FilesService.getSystemLogViewerApiFilesByFileIdentifierDownloadRequest({ fileIdentifier }) });
/**
* @param data The data for the request.
* @param data.fileIdentifier
* @returns string
* @throws ApiError
*/
export const ensureUseFilesServiceGetSystemLogViewerApiFilesByFileIdentifierDownloadData = (queryClient: QueryClient, { fileIdentifier }: {
  fileIdentifier: string;
}) =&gt; queryClient.ensureQueryData({ queryKey: Common.UseFilesServiceGetSystemLogViewerApiFilesByFileIdentifierDownloadKeyFn({ fileIdentifier }), queryFn: () =&gt; FilesService.getSystemLogViewerApiFilesByFileIdentifierDownload({ fileIdentifier }) });
/**
* @param data The data for the request.
* @param data.direction
* @returns LogFolderResource Array of `LogFolderResource`
* @throws ApiError
*/
export const ensureUseFoldersServiceGetSystemLogViewerApiFoldersData = (queryClient: QueryClient, { direction }: {
  direction?: string;
} = {}) =&gt; queryClient.ensureQueryData({ queryKey: Common.UseFoldersServiceGetSystemLogViewerApiFoldersKeyFn({ direction }), queryFn: () =&gt; FoldersService.getSystemLogViewerApiFolders({ direction }) });
/**
* @param data The data for the request.
* @param data.folderIdentifier
* @returns unknown
* @throws ApiError
*/
export const ensureUseFoldersServiceGetSystemLogViewerApiFoldersByFolderIdentifierDownloadRequestData = (queryClient: QueryClient, { folderIdentifier }: {
  folderIdentifier: string;
}) =&gt; queryClient.ensureQueryData({ queryKey: Common.UseFoldersServiceGetSystemLogViewerApiFoldersByFolderIdentifierDownloadRequestKeyFn({ folderIdentifier }), queryFn: () =&gt; FoldersService.getSystemLogViewerApiFoldersByFolderIdentifierDownloadRequest({ folderIdentifier }) });
/**
* @param data The data for the request.
* @param data.folderIdentifier
* @returns string
* @throws ApiError
*/
export const ensureUseFoldersServiceGetSystemLogViewerApiFoldersByFolderIdentifierDownloadData = (queryClient: QueryClient, { folderIdentifier }: {
  folderIdentifier: string;
}) =&gt; queryClient.ensureQueryData({ queryKey: Common.UseFoldersServiceGetSystemLogViewerApiFoldersByFolderIdentifierDownloadKeyFn({ folderIdentifier }), queryFn: () =&gt; FoldersService.getSystemLogViewerApiFoldersByFolderIdentifierDownload({ folderIdentifier }) });
/**
* Get a collection of genres
* @param data The data for the request.
* @param data.fields
* @param data.relations
* @param data.librarySlug
* @param data.page
* @param data.limit
* @returns unknown Paginated set of `GenreResource`
* @throws ApiError
*/
export const ensureUseGenreServiceGetApiGenresData = (queryClient: QueryClient, { fields, librarySlug, limit, page, relations }: {
  fields?: string;
  librarySlug?: string;
  limit?: number;
  page?: number;
  relations?: string;
} = {}) =&gt; queryClient.ensureQueryData({ queryKey: Common.UseGenreServiceGetApiGenresKeyFn({ fields, librarySlug, limit, page, relations }), queryFn: () =&gt; GenreService.getApiGenres({ fields, librarySlug, limit, page, relations }) });
/**
* Get a genre
* @param data The data for the request.
* @param data.genre The genre slug
* @returns GenreResource `GenreResource`
* @throws ApiError
*/
export const ensureUseGenreServiceGetApiGenresByGenreData = (queryClient: QueryClient, { genre }: {
  genre: string;
}) =&gt; queryClient.ensureQueryData({ queryKey: Common.UseGenreServiceGetApiGenresByGenreKeyFn({ genre }), queryFn: () =&gt; GenreService.getApiGenresByGenre({ genre }) });
/**
* @returns LogViewerHostResource Array of `LogViewerHostResource`
* @throws ApiError
*/
export const ensureUseHostsServiceGetSystemLogViewerApiHostsData = (queryClient: QueryClient) =&gt; queryClient.ensureQueryData({ queryKey: Common.UseHostsServiceGetSystemLogViewerApiHostsKeyFn(), queryFn: () =&gt; HostsService.getSystemLogViewerApiHosts() });
/**
* Get an image asset
* @param data The data for the request.
* @param data.image The image public id
* @returns string
* @throws ApiError
*/
export const ensureUseImageServiceGetApiImagesByImageData = (queryClient: QueryClient, { image }: {
  image: string;
}) =&gt; queryClient.ensureQueryData({ queryKey: Common.UseImageServiceGetApiImagesByImageKeyFn({ image }), queryFn: () =&gt; ImageService.getApiImagesByImage({ image }) });
/**
* Get all of the measured jobs
* @returns unknown
* @throws ApiError
*/
export const ensureUseJobMetricsServiceGetHorizonApiMetricsJobsData = (queryClient: QueryClient) =&gt; queryClient.ensureQueryData({ queryKey: Common.UseJobMetricsServiceGetHorizonApiMetricsJobsKeyFn(), queryFn: () =&gt; JobMetricsService.getHorizonApiMetricsJobs() });
/**
* Get metrics for a given job
* @param data The data for the request.
* @param data.id
* @returns unknown
* @throws ApiError
*/
export const ensureUseJobMetricsServiceGetHorizonApiMetricsJobsByIdData = (queryClient: QueryClient, { id }: {
  id: string;
}) =&gt; queryClient.ensureQueryData({ queryKey: Common.UseJobMetricsServiceGetHorizonApiMetricsJobsByIdKeyFn({ id }), queryFn: () =&gt; JobMetricsService.getHorizonApiMetricsJobsById({ id }) });
/**
* Get the details of a recent job by ID
* @param data The data for the request.
* @param data.id
* @returns unknown
* @throws ApiError
*/
export const ensureUseJobsServiceGetHorizonApiJobsByIdData = (queryClient: QueryClient, { id }: {
  id: string;
}) =&gt; queryClient.ensureQueryData({ queryKey: Common.UseJobsServiceGetHorizonApiJobsByIdKeyFn({ id }), queryFn: () =&gt; JobsService.getHorizonApiJobsById({ id }) });
/**
* Get a collection of media libraries
* @param data The data for the request.
* @param data.page
* @param data.limit
* @returns unknown Paginated set of `LibraryResource`
* @throws ApiError
*/
export const ensureUseLibraryServiceGetApiLibrariesData = (queryClient: QueryClient, { limit, page }: {
  limit?: number;
  page?: number;
} = {}) =&gt; queryClient.ensureQueryData({ queryKey: Common.UseLibraryServiceGetApiLibrariesKeyFn({ limit, page }), queryFn: () =&gt; LibraryService.getApiLibraries({ limit, page }) });
/**
* Show library
* @param data The data for the request.
* @param data.slug
* @returns LibraryResource `LibraryResource`
* @throws ApiError
*/
export const ensureUseLibraryServiceGetApiLibrariesBySlugData = (queryClient: QueryClient, { slug }: {
  slug: string;
}) =&gt; queryClient.ensureQueryData({ queryKey: Common.UseLibraryServiceGetApiLibrariesBySlugKeyFn({ slug }), queryFn: () =&gt; LibraryService.getApiLibrariesBySlug({ slug }) });
/**
* @param data The data for the request.
* @param data.file
* @param data.query
* @param data.direction
* @param data.log
* @param data.excludeLevels
* @param data.excludeFileTypes
* @param data.perPage
* @param data.shorterStackTraces
* @returns unknown
* @throws ApiError
*/
export const ensureUseLogsServiceGetSystemLogViewerApiLogsData = (queryClient: QueryClient, { direction, excludeFileTypes, excludeLevels, file, log, perPage, query, shorterStackTraces }: {
  direction?: string;
  excludeFileTypes?: string;
  excludeLevels?: string;
  file?: string;
  log?: string;
  perPage?: string;
  query?: string;
  shorterStackTraces?: boolean;
} = {}) =&gt; queryClient.ensureQueryData({ queryKey: Common.UseLogsServiceGetSystemLogViewerApiLogsKeyFn({ direction, excludeFileTypes, excludeLevels, file, log, perPage, query, shorterStackTraces }), queryFn: () =&gt; LogsService.getSystemLogViewerApiLogs({ direction, excludeFileTypes, excludeLevels, file, log, perPage, query, shorterStackTraces }) });
/**
* Get all of the master supervisors and their underlying supervisors
* @returns unknown
* @throws ApiError
*/
export const ensureUseMasterSupervisorServiceGetHorizonApiMastersData = (queryClient: QueryClient) =&gt; queryClient.ensureQueryData({ queryKey: Common.UseMasterSupervisorServiceGetHorizonApiMastersKeyFn(), queryFn: () =&gt; MasterSupervisorService.getHorizonApiMasters() });
/**
* Get all of the monitored tags and their job counts
* @returns unknown
* @throws ApiError
*/
export const ensureUseMonitoringServiceGetHorizonApiMonitoringData = (queryClient: QueryClient) =&gt; queryClient.ensureQueryData({ queryKey: Common.UseMonitoringServiceGetHorizonApiMonitoringKeyFn(), queryFn: () =&gt; MonitoringService.getHorizonApiMonitoring() });
/**
* Paginate the jobs for a given tag
* @param data The data for the request.
* @param data.tag
* @param data.limit
* @returns unknown
* @throws ApiError
*/
export const ensureUseMonitoringServiceGetHorizonApiMonitoringByTagData = (queryClient: QueryClient, { limit, tag }: {
  limit?: string;
  tag: string;
}) =&gt; queryClient.ensureQueryData({ queryKey: Common.UseMonitoringServiceGetHorizonApiMonitoringByTagKeyFn({ limit, tag }), queryFn: () =&gt; MonitoringService.getHorizonApiMonitoringByTag({ limit, tag }) });
/**
* Get a collection of movies
* @param data The data for the request.
* @param data.library The library slug
* @returns unknown Paginated set of `MovieResource`
* @throws ApiError
*/
export const ensureUseMovieServiceGetApiLibrariesByLibraryMoviesData = (queryClient: QueryClient, { library }: {
  library: string;
}) =&gt; queryClient.ensureQueryData({ queryKey: Common.UseMovieServiceGetApiLibrariesByLibraryMoviesKeyFn({ library }), queryFn: () =&gt; MovieService.getApiLibrariesByLibraryMovies({ library }) });
/**
* Get a movie
* @param data The data for the request.
* @param data.library The library slug
* @param data.movie The movie slug
* @returns MovieResource `MovieResource`
* @throws ApiError
*/
export const ensureUseMovieServiceGetApiLibrariesByLibraryMoviesByMovieData = (queryClient: QueryClient, { library, movie }: {
  library: string;
  movie: string;
}) =&gt; queryClient.ensureQueryData({ queryKey: Common.UseMovieServiceGetApiLibrariesByLibraryMoviesByMovieKeyFn({ library, movie }), queryFn: () =&gt; MovieService.getApiLibrariesByLibraryMoviesByMovie({ library, movie }) });
/**
* Get status
* @returns unknown
* @throws ApiError
*/
export const ensureUseOpCacheServiceGetApiOpcacheStatusData = (queryClient: QueryClient) =&gt; queryClient.ensureQueryData({ queryKey: Common.UseOpCacheServiceGetApiOpcacheStatusKeyFn(), queryFn: () =&gt; OpCacheService.getApiOpcacheStatus() });
/**
* Get config
* @returns unknown
* @throws ApiError
*/
export const ensureUseOpCacheServiceGetApiOpcacheConfigData = (queryClient: QueryClient) =&gt; queryClient.ensureQueryData({ queryKey: Common.UseOpCacheServiceGetApiOpcacheConfigKeyFn(), queryFn: () =&gt; OpCacheService.getApiOpcacheConfig() });
/**
* Get all of the pending jobs
* @param data The data for the request.
* @param data.startingAt
* @returns unknown
* @throws ApiError
*/
export const ensureUsePendingJobsServiceGetHorizonApiJobsPendingData = (queryClient: QueryClient, { startingAt }: {
  startingAt?: string;
} = {}) =&gt; queryClient.ensureQueryData({ queryKey: Common.UsePendingJobsServiceGetHorizonApiJobsPendingKeyFn({ startingAt }), queryFn: () =&gt; PendingJobsService.getHorizonApiJobsPending({ startingAt }) });
/**
* Get a collection of playlists
* @returns unknown Paginated set of `PlaylistResource`
* @throws ApiError
*/
export const ensureUsePlaylistServiceGetApiPlaylistsData = (queryClient: QueryClient) =&gt; queryClient.ensureQueryData({ queryKey: Common.UsePlaylistServiceGetApiPlaylistsKeyFn(), queryFn: () =&gt; PlaylistService.getApiPlaylists() });
/**
* Show a playlist
* @param data The data for the request.
* @param data.playlist The playlist public id
* @param data.relations
* @returns PlaylistResource `PlaylistResource`
* @throws ApiError
*/
export const ensureUsePlaylistServiceGetApiPlaylistsByPlaylistData = (queryClient: QueryClient, { playlist, relations }: {
  playlist: string;
  relations?: string;
}) =&gt; queryClient.ensureQueryData({ queryKey: Common.UsePlaylistServiceGetApiPlaylistsByPlaylistKeyFn({ playlist, relations }), queryFn: () =&gt; PlaylistService.getApiPlaylistsByPlaylist({ playlist, relations }) });
/**
* Get statistics
* @param data The data for the request.
* @param data.playlist The playlist public id
* @returns PlaylistStatistic `PlaylistStatistic`
* @throws ApiError
*/
export const ensureUsePlaylistServiceGetApiPlaylistsByPlaylistStatisticsData = (queryClient: QueryClient, { playlist }: {
  playlist: string;
}) =&gt; queryClient.ensureQueryData({ queryKey: Common.UsePlaylistServiceGetApiPlaylistsByPlaylistStatisticsKeyFn({ playlist }), queryFn: () =&gt; PlaylistService.getApiPlaylistsByPlaylistStatistics({ playlist }) });
/**
* Get a collection of monitor entries
* @param data The data for the request.
* @param data.page
* @param data.limit
* @param data.status
* @param data.queue
* @param data.name
* @param data.queuedFirst
* @returns unknown Paginated set of `QueueMonitorResource`
* @throws ApiError
*/
export const ensureUseQueueServiceGetApiQueueMetricsData = (queryClient: QueryClient, { limit, name, page, queue, queuedFirst, status }: {
  limit?: number;
  name?: string;
  page?: number;
  queue?: string;
  queuedFirst?: boolean;
  status?: &quot;running&quot; | &quot;succeeded&quot; | &quot;failed&quot; | &quot;stale&quot; | &quot;queued&quot;;
} = {}) =&gt; queryClient.ensureQueryData({ queryKey: Common.UseQueueServiceGetApiQueueMetricsKeyFn({ limit, name, page, queue, queuedFirst, status }), queryFn: () =&gt; QueueService.getApiQueueMetrics({ limit, name, page, queue, queuedFirst, status }) });
/**
* Get a list of queue names
* @returns unknown
* @throws ApiError
*/
export const ensureUseQueueServiceGetApiQueueMetricsQueuesData = (queryClient: QueryClient) =&gt; queryClient.ensureQueryData({ queryKey: Common.UseQueueServiceGetApiQueueMetricsQueuesKeyFn(), queryFn: () =&gt; QueueService.getApiQueueMetricsQueues() });
/**
* Get a metrics collection
* @param data The data for the request.
* @param data.aggregateDays
* @returns unknown
* @throws ApiError
*/
export const ensureUseQueueServiceGetApiQueueMetricsMetricsData = (queryClient: QueryClient, { aggregateDays }: {
  aggregateDays?: number;
} = {}) =&gt; queryClient.ensureQueryData({ queryKey: Common.UseQueueServiceGetApiQueueMetricsMetricsKeyFn({ aggregateDays }), queryFn: () =&gt; QueueService.getApiQueueMetricsMetrics({ aggregateDays }) });
/**
* Get all of the measured queues
* @returns unknown
* @throws ApiError
*/
export const ensureUseQueueMetricsServiceGetHorizonApiMetricsQueuesData = (queryClient: QueryClient) =&gt; queryClient.ensureQueryData({ queryKey: Common.UseQueueMetricsServiceGetHorizonApiMetricsQueuesKeyFn(), queryFn: () =&gt; QueueMetricsService.getHorizonApiMetricsQueues() });
/**
* Get metrics for a given queue
* @param data The data for the request.
* @param data.id
* @returns unknown
* @throws ApiError
*/
export const ensureUseQueueMetricsServiceGetHorizonApiMetricsQueuesByIdData = (queryClient: QueryClient, { id }: {
  id: string;
}) =&gt; queryClient.ensureQueryData({ queryKey: Common.UseQueueMetricsServiceGetHorizonApiMetricsQueuesByIdKeyFn({ id }), queryFn: () =&gt; QueueMetricsService.getHorizonApiMetricsQueuesById({ id }) });
/**
* @returns unknown
* @throws ApiError
*/
export const ensureUseSchemaServiceGetApiSchemasMusicbrainzData = (queryClient: QueryClient) =&gt; queryClient.ensureQueryData({ queryKey: Common.UseSchemaServiceGetApiSchemasMusicbrainzKeyFn(), queryFn: () =&gt; SchemaService.getApiSchemasMusicbrainz() });
/**
* Get all of the silenced jobs
* @param data The data for the request.
* @param data.startingAt
* @returns unknown
* @throws ApiError
*/
export const ensureUseSilencedJobsServiceGetHorizonApiJobsSilencedData = (queryClient: QueryClient, { startingAt }: {
  startingAt?: string;
} = {}) =&gt; queryClient.ensureQueryData({ queryKey: Common.UseSilencedJobsServiceGetHorizonApiJobsSilencedKeyFn({ startingAt }), queryFn: () =&gt; SilencedJobsService.getHorizonApiJobsSilenced({ startingAt }) });
/**
* Get a collection of songs
* @param data The data for the request.
* @param data.library The library slug
* @param data.page
* @param data.limit
* @param data.genreNames
* @param data.genreSlugs
* @param data.relations
* @returns unknown Paginated set of `SongResource`
* @throws ApiError
*/
export const ensureUseSongServiceGetApiLibrariesByLibrarySongsData = (queryClient: QueryClient, { genreNames, genreSlugs, library, limit, page, relations }: {
  genreNames?: string;
  genreSlugs?: string;
  library: string;
  limit?: number;
  page?: number;
  relations?: string;
}) =&gt; queryClient.ensureQueryData({ queryKey: Common.UseSongServiceGetApiLibrariesByLibrarySongsKeyFn({ genreNames, genreSlugs, library, limit, page, relations }), queryFn: () =&gt; SongService.getApiLibrariesByLibrarySongs({ genreNames, genreSlugs, library, limit, page, relations }) });
/**
* Get a song by public id
* @param data The data for the request.
* @param data.library The library slug
* @param data.publicId
* @param data.relations
* @returns SongResource `SongResource`
* @throws ApiError
*/
export const ensureUseSongServiceGetApiLibrariesByLibrarySongsByPublicIdData = (queryClient: QueryClient, { library, publicId, relations }: {
  library: string;
  publicId: string;
  relations?: string;
}) =&gt; queryClient.ensureQueryData({ queryKey: Common.UseSongServiceGetApiLibrariesByLibrarySongsByPublicIdKeyFn({ library, publicId, relations }), queryFn: () =&gt; SongService.getApiLibrariesByLibrarySongsByPublicId({ library, publicId, relations }) });
/**
* Direct stream the song.
* Requires token with &quot;access-stream&quot;
* @param data The data for the request.
* @param data.song The song public id
* @returns unknown
* @throws ApiError
*/
export const ensureUseStreamServiceGetApiStreamSongBySongDirectData = (queryClient: QueryClient, { song }: {
  song: string;
}) =&gt; queryClient.ensureQueryData({ queryKey: Common.UseStreamServiceGetApiStreamSongBySongDirectKeyFn({ song }), queryFn: () =&gt; StreamService.getApiStreamSongBySongDirect({ song }) });
/**
* Get php info
* @returns unknown
* @throws ApiError
*/
export const ensureUseSystemInfoServiceGetApiSystemInfoData = (queryClient: QueryClient) =&gt; queryClient.ensureQueryData({ queryKey: Common.UseSystemInfoServiceGetApiSystemInfoKeyFn(), queryFn: () =&gt; SystemInfoService.getApiSystemInfo() });
/**
* @returns unknown
* @throws ApiError
*/
export const ensureUseSystemInfoServiceGetApiSystemInfoSysData = (queryClient: QueryClient) =&gt; queryClient.ensureQueryData({ queryKey: Common.UseSystemInfoServiceGetApiSystemInfoSysKeyFn(), queryFn: () =&gt; SystemInfoService.getApiSystemInfoSys() });
/**
* Get a collection of users
* @param data The data for the request.
* @param data.page
* @param data.limit
* @param data.globalFilter
* @param data.filters
* @param data.filterModes
* @param data.sorting
* @returns unknown Paginated set of `UserResource`
* @throws ApiError
*/
export const ensureUseUserServiceGetApiUsersData = (queryClient: QueryClient, { filterModes, filters, globalFilter, limit, page, sorting }: {
  filterModes?: string;
  filters?: string;
  globalFilter?: string;
  limit?: number;
  page?: number;
  sorting?: string;
} = {}) =&gt; queryClient.ensureQueryData({ queryKey: Common.UseUserServiceGetApiUsersKeyFn({ filterModes, filters, globalFilter, limit, page, sorting }), queryFn: () =&gt; UserService.getApiUsers({ filterModes, filters, globalFilter, limit, page, sorting }) });
/**
* Get small user detail info
* @param data The data for the request.
* @param data.user The user ID
* @returns UserResource `UserResource`
* @throws ApiError
*/
export const ensureUseUserServiceGetApiUsersByUserData = (queryClient: QueryClient, { user }: {
  user: number;
}) =&gt; queryClient.ensureQueryData({ queryKey: Common.UseUserServiceGetApiUsersByUserKeyFn({ user }), queryFn: () =&gt; UserService.getApiUsersByUser({ user }) });
/**
* Get the authenticated user
* @returns UserResource `UserResource`
* @throws ApiError
*/
export const ensureUseUserServiceGetApiUsersMeData = (queryClient: QueryClient) =&gt; queryClient.ensureQueryData({ queryKey: Common.UseUserServiceGetApiUsersMeKeyFn(), queryFn: () =&gt; UserService.getApiUsersMe() });
/**
* Get a collection of tokens
* @param data The data for the request.
* @param data.user
* @param data.page
* @param data.perPage
* @returns unknown Paginated set of `PersonalAccessTokenViewResource`
* @throws ApiError
*/
export const ensureUseUserTokenServiceGetApiUsersTokensByUserData = (queryClient: QueryClient, { page, perPage, user }: {
  page?: number;
  perPage?: number;
  user: string;
}) =&gt; queryClient.ensureQueryData({ queryKey: Common.UseUserTokenServiceGetApiUsersTokensByUserKeyFn({ page, perPage, user }), queryFn: () =&gt; UserTokenService.getApiUsersTokensByUser({ page, perPage, user }) });
/**
* Get the current queue workload for the application
* @returns unknown
* @throws ApiError
*/
export const ensureUseWorkloadServiceGetHorizonApiWorkloadData = (queryClient: QueryClient) =&gt; queryClient.ensureQueryData({ queryKey: Common.UseWorkloadServiceGetHorizonApiWorkloadKeyFn(), queryFn: () =&gt; WorkloadService.getHorizonApiWorkload() });</file><file path="resources/app/app.module.scss">.ToastViewport {
  --viewport-padding: 25px;
  position: fixed;
  bottom: 0;
  right: 0;
  display: flex;
  flex-direction: column;
  padding: var(--viewport-padding);
  gap: 10px;
  width: 390px;
  max-width: 100vw;
  margin: 0;
  list-style: none;
  z-index: 2147483647;
  outline: none;
}
.ToastRoot {
  background-color: white;
  border-radius: 6px;
  box-shadow: hsl(206 22% 7% / 35%) 0px 10px 38px -10px,
  hsl(206 22% 7% / 20%) 0px 10px 20px -15px;
  padding: 15px;
  display: grid;
  grid-template-areas: &quot;title action&quot; &quot;description action&quot;;
  grid-template-columns: auto max-content;
  column-gap: 15px;
  align-items: center;
}
@media (prefers-color-scheme: dark) {
  .ToastRoot {
    background-color: var(--slate-10);
  }
}
.ToastRoot[data-state=&quot;open&quot;] {
  animation: slideIn 150ms cubic-bezier(0.16, 1, 0.3, 1);
}
.ToastRoot[data-state=&quot;closed&quot;] {
  animation: hide 100ms ease-in;
}
.ToastRoot[data-swipe=&quot;move&quot;] {
  transform: translateX(var(--radix-toast-swipe-move-x));
}
.ToastRoot[data-swipe=&quot;cancel&quot;] {
  transform: translateX(0);
  transition: transform 200ms ease-out;
}
.ToastRoot[data-swipe=&quot;end&quot;] {
  animation: swipeOut 100ms ease-out;
}
@keyframes hide {
  from {
    opacity: 1;
  }
  to {
    opacity: 0;
  }
}
@keyframes slideIn {
  from {
    transform: translateX(calc(100% + var(--viewport-padding)));
  }
  to {
    transform: translateX(0);
  }
}
@keyframes swipeOut {
  from {
    transform: translateX(var(--radix-toast-swipe-end-x));
  }
  to {
    transform: translateX(calc(100% + var(--viewport-padding)));
  }
}
.ToastTitle {
  grid-area: title;
  margin-bottom: 5px;
  font-weight: 500;
  color: var(--slate-13);
  font-size: 15px;
}
.ToastDescription {
  grid-area: description;
  margin: 0;
  color: var(--slate-11);
  font-size: 13px;
  line-height: 1.3;
}
.ToastAction {
  grid-area: action;
}</file><file path="resources/app/modules/library-music/components/album-detail/album-detail.tsx">import { Cover } from &apos;@/modules/library-music/components/artwork/cover&apos;;
import { useAlbumServiceGetApiLibrariesByLibraryAlbumsByAlbum } from &apos;@/api-client/queries&apos;;
import { SongResource } from &apos;@/api-client/requests&apos;;
import { Text, Card, Flex, Box, ScrollArea, Skeleton } from &apos;@radix-ui/themes&apos;;
import { AlertLoadingError } from &apos;@/ui/alerts/alert-loading-error.tsx&apos;;
import { useAppDispatch } from &apos;@/store/hooks.ts&apos;;
import { setQueueAndSong } from &apos;@/store/music/music-player-slice.ts&apos;;
import { TrackRow } from &apos;@/ui/music/track-row/track-row.tsx&apos;;
import styles from &apos;./album-detail.module.scss&apos;;
import { usePathParam } from &apos;@/hooks/use-path-param.ts&apos;;
import { LibraryParams } from &apos;@/modules/library-music/routes/_routes.tsx&apos;;
import { generateBlurhashBackgroundImage } from &apos;@/libs/blurhash/generate-bg-image.ts&apos;;
import { useCallback } from &apos;react&apos;;
interface AlbumDetailProps extends React.HTMLAttributes&lt;HTMLDivElement&gt; {
  albumSlug: string;
}
export function AlbumDetail({ albumSlug, ...rest }: AlbumDetailProps) {
  const { library } = usePathParam&lt;LibraryParams&gt;();
  const { data, isLoadingError, refetch } = useAlbumServiceGetApiLibrariesByLibraryAlbumsByAlbum({
    album: albumSlug,
    library: library,
  });
  const genres = data?.genres?.map((genre) =&gt; genre.name).join(&apos;, &apos;);
  const blurhash = data?.cover &amp;&amp; generateBlurhashBackgroundImage(data.cover.blurhash, 128, 128);
  return (
    &lt;Box {...rest}&gt;
      {/*TODO: fix popin{isFetching &amp;&amp; &lt;AlbumDetailSkeleton/&gt;}*/}
      {isLoadingError &amp;&amp; &lt;AlertLoadingError retry={async () =&gt; {
        await refetch();
      }}/&gt;}
      {data &amp;&amp; (
        &lt;Card className={styles.card}&gt;
          {blurhash &amp;&amp; (
            &lt;div
              className={styles.image}
              style={{
                backgroundImage: blurhash.backgroundUrl,
              }}
            /&gt;
          )}
          &lt;div className={styles.content}&gt;
            &lt;div&gt;
              &lt;Flex align=&quot;stretch&quot;&gt;
                &lt;Box p=&quot;3&quot;&gt;
                  &lt;Cover imgSrc={data?.cover?.url} size={180}/&gt;
                &lt;/Box&gt;
                &lt;Flex p=&quot;sm&quot; align=&quot;start&quot; direction=&quot;column&quot; justify=&quot;center&quot;&gt;
                  &lt;Text size=&quot;6&quot; weight=&quot;bold&quot;&gt;{data?.title}&lt;/Text&gt;
                  {data?.artists &amp;&amp; (
                    &lt;Text &gt;{data.artists.map(x =&gt; x.name).join(&apos;, &apos;)}&lt;/Text&gt;
                  )}
                  &lt;Text&gt;{genres} - {data?.year}&lt;/Text&gt;
                &lt;/Flex&gt;
                &lt;Box&gt;&lt;/Box&gt;
              &lt;/Flex&gt;
              &lt;Flex&gt;
                {data?.songs &amp;&amp; &lt;AlbumSongs title={data.title} coverUrl={data.cover?.url} songs={data.songs}/&gt;}
              &lt;/Flex&gt;
            &lt;/div&gt;
          &lt;/div&gt;
        &lt;/Card&gt;
      )}
    &lt;/Box&gt;
  );
}
interface AlbumSongProps {
  title: string;
  coverUrl?: string;
  songs: SongResource[];
}
function AlbumSongs({ songs }: AlbumSongProps) {
  const dispatch = useAppDispatch();
  const onSongClick = useCallback((song: SongResource, songs: SongResource[]) =&gt; {
    console.group(&apos;onSongClick&apos;);
    console.log(&apos;song&apos;, song);
    console.log(&apos;songs&apos;, songs);
    console.groupEnd();
    const newQueue = [...songs];
    const index = newQueue.findIndex(x =&gt; x.public_id === song.public_id);
    newQueue.splice(0, 0, newQueue.splice(index, 1)[0]);
    dispatch(setQueueAndSong({
      queue: newQueue,
      playPublicId: song.public_id,
    }));
  }, [dispatch]);
  const rows = songs.map((song) =&gt; (
    &lt;TrackRow
      className={styles.trackRow}
      song={song}
      key={song.public_id}
      onClick={() =&gt; {
        onSongClick(song, songs);
      }}
    /&gt;
  ));
  return (
    &lt;&gt;
      &lt;ScrollArea&gt;
        &lt;table &gt;
          &lt;thead&gt;
            &lt;tr&gt;
              &lt;th&gt;Track&lt;/th&gt;
              &lt;th&gt;Title&lt;/th&gt;
              &lt;th&gt;Duration&lt;/th&gt;
            &lt;/tr&gt;
          &lt;/thead&gt;
          &lt;tbody&gt;{rows}&lt;/tbody&gt;
        &lt;/table&gt;
      &lt;/ScrollArea&gt;
    &lt;/&gt;
  );
}
// @ts-expect-error
function AlbumDetailSkeleton() {
  return (
    &lt;Card&gt;
      &lt;Flex&gt;
        &lt;Box p=&quot;sm&quot;&gt;
          &lt;Skeleton height=&quot;180px&quot; width=&quot;180px&quot; /&gt;
        &lt;/Box&gt;
        &lt;Box p=&quot;sm&quot; width=&quot;100%&quot;&gt;
          &lt;Skeleton height=&quot;16px&quot; mt=&quot;sm&quot;/&gt;
          &lt;Flex&gt;
            &lt;Skeleton height=&quot;8px&quot; mt=&quot;sm&quot; width=&quot;50px&quot;/&gt;
            &lt;Skeleton height=&quot;8px&quot; mt=&quot;sm&quot; ml=&quot;sm&quot; width=&quot;50px&quot;/&gt;
          &lt;/Flex&gt;
        &lt;/Box&gt;
      &lt;/Flex&gt;
      &lt;Flex&gt;
        &lt;Skeleton height=&quot;16px&quot;/&gt;
        &lt;Skeleton height=&quot;16px&quot;/&gt;
        &lt;Skeleton height=&quot;16px&quot;/&gt;
        &lt;Skeleton height=&quot;16px&quot;/&gt;
        &lt;Skeleton height=&quot;16px&quot;/&gt;
        &lt;Skeleton height=&quot;16px&quot;/&gt;
        &lt;Skeleton height=&quot;16px&quot;/&gt;
      &lt;/Flex&gt;
    &lt;/Card&gt;
  );
}</file><file path="resources/app/modules/user-settings/features/dev-panel.tsx">import { Box, Button, Container, Flex, Heading, Text } from &apos;@radix-ui/themes&apos;;
import { useAppDispatch, useAppSelector } from &apos;@/store/hooks.ts&apos;;
import { useCallback } from &apos;react&apos;;
import { selectAccessToken, selectRefreshToken, selectStreamToken } from &apos;@/store/users/auth-slice.ts&apos;;
import { useTestMode } from &apos;@/providers/test-mode-provider.tsx&apos;;
import { CreateNotification } from &apos;@/modules/notifications/models.ts&apos;;
import { createNotification } from &apos;@/store/notifications/notifications-slice.ts&apos;;
export function DevPanel() {
  const dispatch = useAppDispatch();
  const accessToken = useAppSelector(selectAccessToken);
  const refreshToken = useAppSelector(selectRefreshToken);
  const streamToken = useAppSelector(selectStreamToken);
  const { isTestMode, toggleTestMode } = useTestMode();
  const copyAccessToken = useCallback(() =&gt; {
    if (accessToken &amp;&amp; accessToken.token) {
      navigator.clipboard.writeText(accessToken.token);
    }
  }, [accessToken]);
  const copyRefreshToken = useCallback(() =&gt; {
    if (refreshToken &amp;&amp; refreshToken.token) {
      navigator.clipboard.writeText(refreshToken.token);
    }
  }, [refreshToken]);
  const copyStreamToken = useCallback(() =&gt; {
    if (streamToken &amp;&amp; streamToken.token) {
      navigator.clipboard.writeText(streamToken.token);
    }
  }, [streamToken]);
  const addTestNotification = () =&gt; {
    const notifications: CreateNotification[] = [
      {
        type: &apos;info&apos;,
        message: &apos;Test notification&apos;,
      },
      {
        title: &apos;Test title&apos;,
        type: &apos;success&apos;,
        message: &apos;Test success notification&apos;,
        toast: true,
      },
      {
        type: &apos;warning&apos;,
        message: &apos;Test warning notification&apos;,
      },
      {
        type: &apos;error&apos;,
        message: &apos;Test error notification&apos;,
      }
    ]
    notifications.forEach((notification) =&gt; {
      dispatch(createNotification(notification));
    })
  }
  return (
    &lt;Container&gt;
      &lt;Heading&gt;Dev Panel&lt;/Heading&gt;
      &lt;Flex mt=&quot;2&quot; direction=&quot;column&quot;&gt;
        &lt;Text&gt;Current tokens&lt;/Text&gt;
        &lt;Flex gap=&quot;2&quot; mt=&quot;2&quot;&gt;
          &lt;Button onClick={() =&gt; copyAccessToken()}&gt;Access token&lt;/Button&gt;
          &lt;Button onClick={() =&gt; copyRefreshToken()}&gt;Refresh token&lt;/Button&gt;
          &lt;Button onClick={() =&gt; copyStreamToken()}&gt;Stream token&lt;/Button&gt;
        &lt;/Flex&gt;
      &lt;/Flex&gt;
      &lt;Flex direction=&quot;column&quot; mt=&quot;2&quot;&gt;
        &lt;Text&gt;Test mode&lt;/Text&gt;
        &lt;Box mt=&quot;2&quot;&gt;
          &lt;Button onClick={() =&gt; toggleTestMode()}&gt;
            {isTestMode ? &apos;Disable&apos; : &apos;Enable&apos;}
          &lt;/Button&gt;
        &lt;/Box&gt;
      &lt;/Flex&gt;
      &lt;Flex direction=&quot;column&quot; mt=&quot;2&quot;&gt;
        &lt;Text weight=&quot;bold&quot;&gt;Add test notifications&lt;/Text&gt;
        &lt;Box mt=&quot;2&quot;&gt;
          &lt;Button onClick={() =&gt; addTestNotification()}&gt;Add&lt;/Button&gt;
        &lt;/Box&gt;
      &lt;/Flex&gt;
    &lt;/Container&gt;
  );
}</file><file path="resources/app/routes/public.tsx">import { BareLayout } from &apos;@/layouts/bare-layout/bare-layout.tsx&apos;;
import { Navigate, Outlet } from &apos;react-router-dom&apos;;
import { AuthorizeRoutes } from &apos;@/modules/authorize/routes.tsx&apos;;
import Login from &apos;@/modules/auth/routes/login.tsx&apos;;
import { AuthRoutes } from &apos;@/modules/auth/routes/_routes.tsx&apos;;
const App = () =&gt; {
  return (
    &lt;BareLayout&gt;
      &lt;Outlet/&gt;
    &lt;/BareLayout&gt;
  );
};
export const publicRoutes = [
  {
    path: &apos;/&apos;,
    element: &lt;App/&gt;,
    children: [
      { path: &apos;&apos;, element: &lt;Login/&gt; },
      { path: &apos;auth/*&apos;, element: &lt;AuthRoutes/&gt; },
      { path: &apos;authorize/*&apos;, element: &lt;AuthorizeRoutes/&gt; },
      { path: &apos;*&apos;, element: &lt;Navigate to=&quot;/&quot;/&gt; },
    ],
  },
];</file><file path="app/Http/Controllers/Api/QueueController.php">&lt;?php
namespace App\Http\Controllers\Api;
use App\Http\Controllers\Controller;
use App\Http\Requests\QueueMetrics\{MetricsRequest, ShowQueueMetricsRequest};
use App\Http\Requests\QueueMonitor\RetryJobRequest;
use App\Http\Resources\QueueMonitor\QueueMonitorResource;
use App\Models\QueueMonitor;
use App\Models\TokenAbility;
use App\Modules\{Pagination\JsonPaginator};
use App\Modules\Eloquent\BaseBuilder;
use App\Modules\Http\Resources\Json\JsonAnonymousResourceCollection;
use App\Modules\QueueMonitor\MonitorStatus;
use App\Services\QueueMetrics\QueueMetricsService;
use Spatie\RouteAttributes\Attributes\{Delete, Get, Middleware, Post, Prefix};
#[Prefix(&apos;/queue-metrics&apos;)]
#[Middleware([
    &apos;auth:sanctum&apos;,
    &apos;ability:&apos; . TokenAbility::ACCESS_API-&gt;value,
    &apos;force.json&apos;,
])]
class QueueController extends Controller
{
    public function __construct(private readonly QueueMetricsService $metricsService)
    {
    }
    /**
     * Get a collection of monitor entries
     *
     * @param ShowQueueMetricsRequest $request
     * @return JsonAnonymousResourceCollection&lt;JsonPaginator&lt;QueueMonitorResource&gt;&gt;
     */
    #[Get(&apos;/&apos;, &apos;api.queue-metrics.show&apos;)]
    public function show(ShowQueueMetricsRequest $request)
    {
        $this-&gt;gateCheckViewDashboard();
        $queuedFirst = $request-&gt;query(&apos;queuedFirst&apos;);
        $status = $request-&gt;query(&apos;status&apos;);
        $queue = $request-&gt;query(&apos;queue&apos;);
        $name = $request-&gt;query(&apos;name&apos;);
        $models = QueueMonitor::when($status, function (BaseBuilder $query, $status) {
            return $query-&gt;where(&apos;status&apos;, $status);
        })-&gt;when($queue, function (BaseBuilder $query, $queue) {
            return $query-&gt;where(&apos;queue&apos;, $queue);
        })-&gt;when($name, function (BaseBuilder $query, $name) {
            return $query-&gt;where(&apos;name&apos;, &apos;like&apos;, &apos;%&apos; . $name . &apos;%&apos;);
        })-&gt;when($queuedFirst, function (BaseBuilder $query) {
            return $query-&gt;orderByRaw(&apos;started_at DESC NULLS LAST&apos;);
        })-&gt;paginate();
        return QueueMonitorResource::collection($models);
    }
    /**
     * Get a list of queue names
     *
     * @response array{
     *   name: string
     * }[]
     */
    #[Get(&apos;/queues&apos;, &apos;api.queue-metrics.queues&apos;)]
    public function queues()
    {
        $this-&gt;gateCheckViewDashboard();
        $queues = QueueMonitor::select(&apos;queue&apos;)
            -&gt;groupBy(&apos;queue&apos;)
            -&gt;get()
            -&gt;map(function (QueueMonitor $queueMonitor) {
                return [&apos;name&apos; =&gt; $queueMonitor-&gt;queue];
            });
        return response()-&gt;json($queues);
    }
    /**
     * Get a metrics collection
     *
     * @response array{
     *   title: string,
     *   value: float,
     *   previousValue: int|null,
     *   format: string,
     *   formattedValue: string,
     *   formattedPreviousValue: string|null,
     * }[]
     */
    #[Get(&apos;/metrics&apos;, &apos;api.queue-metrics.metrics&apos;)]
    public function metrics(MetricsRequest $request)
    {
        $this-&gt;gateCheckViewDashboard();
        $aggregateDays = $request-&gt;query(&apos;aggregateDays&apos;, 14);
        $metrics = $this-&gt;metricsService-&gt;collect(aggregateDays: (int)$aggregateDays);
        return response()-&gt;json($metrics);
    }
    /**
     * Retry a job
     *
     * @param RetryJobRequest $request
     * @param string $id
     * @return \Illuminate\Http\JsonResponse
     */
    #[Post(&apos;/retry/{id}&apos;, &apos;api.queue-metrics.retry-job&apos;)]
    public function retry(RetryJobRequest $request, string $id)
    {
        $this-&gt;gateCheckViewDashboard();
        $monitor = QueueMonitor::whereId($id)
            -&gt;whereStatus(MonitorStatus::Failed)
            -&gt;whereRetried(false)
            -&gt;whereNotNull(&apos;job_uuid&apos;)
            -&gt;firstOrFail();
        abort_if(!$monitor-&gt;canBeRetried(), 400, &apos;Job cannot be retried&apos;);
        try {
            $monitor-&gt;retry();
        } catch (\Throwable $exception) {
            return response()-&gt;json([
                &apos;status&apos;  =&gt; &apos;failed&apos;,
                &apos;message&apos; =&gt; &apos;An error occurred while executing the job&apos;,
            ]);
        }
        return response()-&gt;json([
            &apos;status&apos;  =&gt; &apos;success&apos;,
            &apos;message&apos; =&gt; &apos;Job has been successfully retried&apos;,
        ]);
    }
    /**
     * Delete by id
     *
     * @param string $id
     * @return \Illuminate\Contracts\Routing\ResponseFactory|\Illuminate\Foundation\Application|\Illuminate\Http\Response
     */
    #[Delete(&apos;{id}&apos;, &apos;api.queue-metrics.delete&apos;)]
    public function delete(string $id)
    {
        $this-&gt;gateCheckViewDashboard();
        QueueMonitor::whereId($id)-&gt;delete();
        return response(null, 204);
    }
    /**
     * Purge all records
     *
     * @return \Illuminate\Contracts\Routing\ResponseFactory|\Illuminate\Foundation\Application|\Illuminate\Http\Response
     */
    #[Delete(&apos;/purge&apos;, &apos;api.queue-metrics.purge&apos;)]
    public function purge()
    {
        $this-&gt;gateCheckViewDashboard();
        QueueMonitor::truncate();
        return response(null, 204);
    }
}</file><file path="app/Http/Controllers/Web/PasskeyController.php">&lt;?php
namespace App\Http\Controllers\Web;
use App\Events\Auth\PasskeyUsedToAuthenticateEvent;
use App\Http\Controllers\Api\Auth\Concerns\HandlesUserTokens;
use App\Http\Controllers\Controller;
use App\Http\Requests\Auth\{AuthenticateUsingPasskeyRequest, StorePasskeyRequest};
use App\Models\User;
use App\Modules\Webauthn\Actions\{GeneratePasskeyAuthenticationOptionsAction};
use App\Modules\Webauthn\Actions\FindPasskeyToAuthenticateAction;
use App\Modules\Webauthn\Actions\GeneratePasskeyRegisterOptionsAction;
use App\Modules\Webauthn\Actions\StorePasskeyAction;
use Illuminate\Contracts\Auth\Authenticatable;
use Illuminate\Http\Request;
use Illuminate\Support\Facades\{Log, Session};
use Spatie\RouteAttributes\Attributes\{Get, Post, Prefix};
/**
 * @tags Auth
 */
#[Prefix(&apos;/webauthn/passkey&apos;)]
class PasskeyController extends Controller
{
    use HandlesUserTokens;
    public const string REGISTER_OPTIONS_SESSION_KEY = &apos;passkey-registration-options&apos;;
    /**
     * Get a passkey challenge
     *
     * @unauthenticated
     *
     * @response array{
     *   challenge: string,
     *   rpId: string,
     *   allowCredentials: array{}
     * }
     */
    #[Get(&apos;/&apos;, &apos;auth.passkey.options&apos;)]
    public function getOptions(Request $request)
    {
        $action = new GeneratePasskeyAuthenticationOptionsAction();
        $options = $action-&gt;execute($request-&gt;user());
        return response()-&gt;json($options);
    }
    /**
     * Login with a passkey
     * @unauthenticated
     */
    #[Post(&apos;/&apos;, &apos;auth.passkey.login&apos;)]
    public function authenticate(AuthenticateUsingPasskeyRequest $request)
    {
        $findAuthenticatableUsingPasskey = new FindPasskeyToAuthenticateAction();
        $passkey = $findAuthenticatableUsingPasskey-&gt;execute(
            $request-&gt;get(&apos;start_authentication_response&apos;),
            Session::get(&apos;passkey-authentication-options&apos;),
        );
        if (!$passkey) {
            return $this-&gt;invalidPasskeyResponse();
        }
        $authenticatable = $passkey-&gt;user;
        if (!$authenticatable) {
            return $this-&gt;invalidPasskeyResponse();
        }
        $this-&gt;logInAuthenticatable($authenticatable);
        event(new PasskeyUsedToAuthenticateEvent($passkey));
        return $this-&gt;validPasskeyResponse($request, $authenticatable);
    }
    /**
     * Get passkey registration options
     */
    #[Get(&apos;/register&apos;, &apos;auth.passkey.register-option&apos;, [&apos;auth:sanctum&apos;])]
    public function getRegisterOptions(Request $request)
    {
        if (!$user = $request-&gt;user()) {
            abort(401, &apos;You must be logged in&apos;);
        }
        $action = new GeneratePasskeyRegisterOptionsAction();
        $options = $action-&gt;execute($user);
        session()-&gt;put(&apos;passkey-registration-options&apos;, $options);
        return $options;
    }
    /**
     * Register passkey
     */
    #[Post(&apos;/register&apos;, &apos;auth.passkey.register&apos;, [&apos;auth:sanctum&apos;])]
    public function registerPasskey(StorePasskeyRequest $request)
    {
        $action = new StorePasskeyAction();
        try {
            $action-&gt;execute(
                $request-&gt;user(),
                $request-&gt;get(&apos;passkey&apos;),
                $this-&gt;previouslyGeneratedPasskeyOptions(),
                $request-&gt;host(),
                [&apos;name&apos; =&gt; $request-&gt;get(&apos;name&apos;)],
            );
        } catch (\Throwable $e) {
            Log::error(&apos;Could not store passkey&apos;, [
                &apos;exception.message&apos; =&gt; $e-&gt;getMessage(),
                &apos;exception.code&apos;    =&gt; $e-&gt;getCode(),
            ]);
            return response()-&gt;json([&apos;error&apos; =&gt; &apos;Could not store passkey&apos;], 500);
        }
        return response()-&gt;json([
            &apos;message&apos; =&gt; &apos;Passkey successfully stored&apos;,
        ]);
    }
    public function logInAuthenticatable(Authenticatable $authenticatable): self
    {
        auth()-&gt;login($authenticatable);
        Session::regenerate();
        return $this;
    }
    public function validPasskeyResponse(Request $request, User $user)
    {
        $url = Session::has(&apos;passkeys.redirect&apos;)
            ? Session::pull(&apos;passkeys.redirect&apos;)
            : null;
        if ($url) {
            return redirect($url);
        }
        return $this-&gt;createTokenSet($request, $user);
    }
    protected function invalidPasskeyResponse()
    {
        return response()-&gt;json([
            &apos;message&apos; =&gt; __(&apos;passkeys::passkeys.invalid&apos;),
        ])-&gt;setStatusCode(401);
    }
    protected function previouslyGeneratedPasskeyOptions(): ?string
    {
        return Session::pull(self::REGISTER_OPTIONS_SESSION_KEY);
    }
}</file><file path="app/Http/Requests/Song/SongIndexRequest.php">&lt;?php
namespace App\Http\Requests\Song;
use Illuminate\Foundation\Http\FormRequest;
class SongIndexRequest extends FormRequest
{
    /**
     * Determine if the user is authorized to make this request.
     */
    public function authorize(): bool
    {
        return true;
    }
    /**
     * Get the validation rules that apply to the request.
     *
     * @return array&lt;string, \Illuminate\Contracts\Validation\ValidationRule|array&lt;mixed&gt;|string&gt;
     */
    public function rules(): array
    {
        return [
            /**
             * @query
             * Current page
             */
            &apos;page&apos;       =&gt; &apos;int&apos;,
            /**
             * @query
             * Items per page
             */
            &apos;limit&apos;      =&gt; &apos;int&apos;,
            /**
             * @query
             * Comma seperated list of genre names
             *
             * You can only search for names or slugs. Not both.
             */
            &apos;genreNames&apos; =&gt; &apos;string&apos;,
            /**
             * @query
             * Comma seperated list of genre slugs
             */
            &apos;genreSlugs&apos; =&gt; &apos;string&apos;,
            /**
             * @query
             * Comma seperated string of relations
             * - album
             * - artists
             * - album.albumArtist
             * - genres
             */
            &apos;relations&apos;  =&gt; &apos;string&apos;,
        ];
    }
}</file><file path="app/Http/Resources/Album/AlbumResource.php">&lt;?php
namespace App\Http\Resources\Album;
use App\Http\Resources\Artist\ArtistResource;
use App\Http\Resources\HasJsonCollection;
use App\Http\Resources\Image\ImageResource;
use App\Http\Resources\Song\SongResource;
use App\Models\Album;
use Illuminate\Http\Request;
/**
 * @mixin Album
 */
class AlbumResource extends AlbumWithoutSongsResource
{
    use HasJsonCollection;
    /**
     * Transform the resource into an array.
     *
     * @return array&lt;string, mixed&gt;
     */
    public function toArray(Request $request): array
    {
        return [
            &apos;title&apos;     =&gt; $this-&gt;title,
            &apos;slug&apos;      =&gt; $this-&gt;slug,
            &apos;year&apos;      =&gt; $this-&gt;year,
            &apos;createdAt&apos; =&gt; $this-&gt;created_at,
            &apos;updatedAt&apos; =&gt; $this-&gt;updated_at,
            /**
             * Cover relation
             */
            &apos;cover&apos;     =&gt; ImageResource::make($this-&gt;whenLoaded(&apos;cover&apos;)),
            /**
             * Album artists relation
             */
            &apos;artists&apos;   =&gt; ArtistResource::collection($this-&gt;whenLoaded(&apos;artists&apos;)),
            /**
             * Songs relation
             */
            &apos;songs&apos;     =&gt; SongResource::collection($this-&gt;whenLoaded(&apos;songs&apos;)),
            /**
             * @var array{
             *   slug: string,
             *   name: string
             * }[]
             */
            &apos;genres&apos;    =&gt; $this-&gt;whenLoaded(&apos;songs&apos;, function () {
                return $this-&gt;songs-&gt;flatMap(fn($song) =&gt; $song-&gt;genres)-&gt;unique(&apos;id&apos;)-&gt;values()-&gt;map(fn($genre)
                    =&gt; [
                    &apos;slug&apos; =&gt; $genre-&gt;slug,
                    &apos;name&apos; =&gt; $genre-&gt;name,
                ]);
            }),
        ];
    }
}</file><file path="app/Models/Genre.php">&lt;?php
namespace App\Models;
use Illuminate\Database\Eloquent\Factories\HasFactory;
use Spatie\Sluggable\{HasSlug, SlugOptions};
use Staudenmeir\LaravelAdjacencyList\Eloquent\HasRecursiveRelationships;
class Genre extends BaseModel
{
    use HasFactory, HasSlug, HasRecursiveRelationships;
    public static array $filterFields = [
        &apos;name&apos;,
        &apos;slug&apos;,
    ];
    public static array $filterRelations = [
        &apos;songs&apos;,
    ];
    protected $fillable = [
        &apos;name&apos;,
        &apos;slug&apos;,
    ];
    /**
     * Get the options for generating the slug.
     */
    public function getSlugOptions(): SlugOptions
    {
        return SlugOptions::create()
            -&gt;generateSlugsFrom(&apos;name&apos;)
            -&gt;saveSlugsTo(&apos;slug&apos;);
    }
    public function getRouteKeyName(): string
    {
        return &apos;slug&apos;;
    }
    public function songs()
    {
        return $this-&gt;belongsTo(Song::class)
            -&gt;using(GenreSong::class);
    }
}</file><file path="app/Models/Library.php">&lt;?php
namespace App\Models;
use Illuminate\Database\Eloquent\Factories\HasFactory;
use Spatie\Sluggable\{HasSlug, SlugOptions};
use Illuminate\Support\Carbon;
use Illuminate\Support\Facades\Storage;
class Library extends BaseModel
{
    use HasFactory, HasSlug;
    protected $fillable = [
        &apos;name&apos;,
        &apos;slug&apos;,
        &apos;path&apos;,
        &apos;type&apos;,
        &apos;order&apos;,
        &apos;last_scan&apos;,
    ];
    /**
     * Get the options for generating the slug.
     */
    public function getSlugOptions(): SlugOptions
    {
        return SlugOptions::create()
            -&gt;generateSlugsFrom(&apos;name&apos;)
            -&gt;saveSlugsTo(&apos;slug&apos;);
    }
    public function getRouteKeyName(): string
    {
        return &apos;slug&apos;;
    }
    public function updateLastScan(?Carbon $date = null): void
    {
        $this-&gt;update([
            &apos;last_scan&apos; =&gt; $date ?? now(),
        ]);
    }
    public function getDisk()
    {
        return Storage::build([
            &apos;driver&apos; =&gt; &apos;local&apos;,
            &apos;root&apos;   =&gt; $this-&gt;path,
        ]);
    }
    public function albums()
    {
        return $this-&gt;hasMany(Album::class);
    }
    public function users()
    {
        return $this-&gt;belongsToMany(User::class)
            -&gt;using(UserLibrary::class);
    }
}</file><file path="app/Models/PersonalAccessToken.php">&lt;?php
namespace App\Models;
use App\Modules\DeviceDetector\Device;
use Illuminate\Database\Eloquent\Casts\Attribute;
use Illuminate\Database\Query\Builder;
use Illuminate\Http\Request;
use Illuminate\Support\Facades\Cache;
use Illuminate\Support\Facades\Crypt;
use Illuminate\Support\Str;
use JetBrains\PhpStorm\ArrayShape;
use Laravel\Sanctum\PersonalAccessToken as SanctumPersonalAccessToken;
use Laravel\Sanctum\NewAccessToken;
class PersonalAccessToken extends SanctumPersonalAccessToken
{
    protected $fillable = [
        &apos;name&apos;,
        &apos;token&apos;,
        &apos;abilities&apos;,
        &apos;expires_at&apos;,
        &apos;user_agent&apos;,
        &apos;client_name&apos;,
        &apos;client_version&apos;,
        &apos;client_type&apos;,
        &apos;device_operating_system&apos;,
        &apos;device_name&apos;,
    ];
    /**
     * The &quot;booted&quot; method of the model.
     *
     * @return void
     */
    protected static function booted()
    {
        // Cache token when created
        static::created(function ($token) {
            self::cacheToken($token);
        });
        // Update cache when token is updated
        static::updated(function ($token) {
            self::cacheToken($token);
        });
        // Remove from cache when token is deleted
        static::deleted(function ($token) {
            self::invalidateTokenCache($token-&gt;id);
        });
    }
    /**
     * Create a new personal access token for the user.
     *
     * @param  mixed  $tokenable
     * @param  string  $name
     * @param  array  $abilities
     * @param \DateTimeInterface|null $expiresAt
     * @return \Laravel\Sanctum\NewAccessToken
     */
    public static function createToken($tokenable, string $name, array $abilities = [&apos;*&apos;], ?\DateTimeInterface $expiresAt = null)
    {
        $plainTextToken = Str::random(40);
        $token = $tokenable-&gt;tokens()-&gt;create([
            &apos;name&apos; =&gt; $name,
            &apos;token&apos; =&gt; hash(&apos;sha256&apos;, $plainTextToken),
            &apos;abilities&apos; =&gt; $abilities,
            &apos;expires_at&apos; =&gt; $expiresAt,
        ]);
        // Token will be cached via the created event
        return new NewAccessToken($token, $tokenable-&gt;getKey().&apos;|&apos;.$plainTextToken);
    }
    /**
     * Find the token instance matching the given token.
     *
     * @param string $token
     * @return static|null
     */
    public static function findToken($token)
    {
        if (!config(&apos;sanctum.token_cache.enabled&apos;, true)) {
            return self::findTokenWithoutCache($token);
        }
        try {
            if (!str_contains($token, &apos;|&apos;)) {
                $token = Crypt::decryptString($token);
            }
            [$id, $tokenValue] = explode(&apos;|&apos;, $token, 2);
            return self::findTokenFromCache($id, $tokenValue);
        } catch (\Exception $e) {
            report($e);
            return null;
        }
    }
    /**
     * Find token from Redis cache or database with caching.
     *
     * @param string $id
     * @param string $tokenValue
     * @return static|null
     */
    protected static function findTokenFromCache($id, $tokenValue)
    {
        $cacheConfig = config(&apos;sanctum.token_cache&apos;);
        $cacheKey = $cacheConfig[&apos;prefix&apos;] . $id;
        $cacheStore = $cacheConfig[&apos;store&apos;];
        // Get the TTL value as integer or null
        $ttl = is_numeric($cacheConfig[&apos;ttl&apos;]) ? (int) $cacheConfig[&apos;ttl&apos;] : null;
        return Cache::store($cacheStore)-&gt;remember(
            $cacheKey,
            $ttl ? now()-&gt;addMinutes($ttl) : null,
            function () use ($id, $tokenValue) {
                if ($instance = static::find($id)) {
                    return hash_equals($instance-&gt;token, hash(&apos;sha256&apos;, $tokenValue)) ? $instance : null;
                }
                return null;
            }
        );
    }
    /**
     * Find token without using cache (fallback method).
     *
     * @param string $token
     * @return static|null
     */
    protected static function findTokenWithoutCache($token)
    {
        if (!str_contains($token, &apos;|&apos;)) {
            $token = Crypt::decryptString($token);
        }
        [$id, $tokenValue] = explode(&apos;|&apos;, $token, 2);
        if ($instance = static::find($id)) {
            return hash_equals($instance-&gt;token, hash(&apos;sha256&apos;, $tokenValue)) ? $instance : null;
        }
        return null;
    }
    /**
     * Cache token instance.
     *
     * @param PersonalAccessToken $token
     * @return void
     */
    public static function cacheToken($token)
    {
        if (!config(&apos;sanctum.token_cache.enabled&apos;, true)) {
            return;
        }
        $cacheConfig = config(&apos;sanctum.token_cache&apos;);
        $cacheKey = $cacheConfig[&apos;prefix&apos;] . $token-&gt;id;
        // Ensure TTL is a proper integer or null
        $ttl = is_numeric($cacheConfig[&apos;ttl&apos;]) ? (int) $cacheConfig[&apos;ttl&apos;] : null;
        Cache::store($cacheConfig[&apos;store&apos;])-&gt;put(
            $cacheKey,
            $token,
            $ttl ? now()-&gt;addMinutes($ttl) : null
        );
    }
    /**
     * Invalidate token cache by ID.
     *
     * @param int $tokenId
     * @return void
     */
    public static function invalidateTokenCache($tokenId)
    {
        $cacheConfig = config(&apos;sanctum.token_cache&apos;);
        $cacheKey = $cacheConfig[&apos;prefix&apos;] . $tokenId;
        Cache::store($cacheConfig[&apos;store&apos;])-&gt;forget($cacheKey);
    }
    #[ArrayShape([
        &apos;user_agent&apos;              =&gt; &quot;null|string&quot;,
        &apos;client_type&apos;             =&gt; &quot;array|null|string&quot;,
        &apos;client_name&apos;             =&gt; &quot;array|null|string&quot;,
        &apos;client_version&apos;          =&gt; &quot;array|null|string&quot;,
        &apos;device_operating_system&apos; =&gt; &quot;null|string&quot;,
        &apos;device_name&apos;             =&gt; &quot;null|string&quot;,
    ])]
    public static function prepareDeviceFromRequest(Request $request): array
    {
        $deviceDetector = Device::detectRequest($request);
        $osName = $deviceDetector-&gt;getOs(&apos;name&apos;);
        if ($osName === &apos;UNK&apos;) {
            $osName = null;
        }
        $osVersion = $deviceDetector-&gt;getOs(&apos;version&apos;);
        if ($osVersion === &apos;UNK&apos;) {
            $osVersion = null;
        }
        if ($osName === &apos;Windows&apos; &amp;&amp; $osVersion === &apos;10&apos;) {
            $osVersion = &apos;&gt;=10&apos;;
        }
        $deviceName = $deviceDetector-&gt;getDeviceName();
        return [
            &apos;user_agent&apos;              =&gt; $request-&gt;userAgent(),
            &apos;client_type&apos;             =&gt; $deviceDetector-&gt;getClient(&apos;type&apos;),
            &apos;client_name&apos;             =&gt; $deviceDetector-&gt;getClient(&apos;name&apos;),
            &apos;client_version&apos;          =&gt; $deviceDetector-&gt;getClient(&apos;version&apos;),
            &apos;device_operating_system&apos; =&gt; $osName || $osVersion ? implode(&apos;|&apos;, [$osName, $osVersion]) : null,
            &apos;device_name&apos;             =&gt; $deviceName ?: null,
        ];
    }
    /**
     * @param Builder $q
     */
    protected function scopeWhereExpired($q)
    {
        return $q-&gt;where(&apos;expires_at&apos;, &apos;&lt;&apos;, now());
    }
    /**
     * Get the expiration time as a Carbon instance.
     */
    protected function expiresAt(): Attribute
    {
        return Attribute::make(
            get: fn ($value) =&gt; $value ? new \Carbon\Carbon($value) : null,
        );
    }
}</file><file path="resources/app/layouts/bare-layout/bare-layout.tsx">import { ReactNode } from &apos;react&apos;;
import { Flex } from &apos;@radix-ui/themes&apos;;
import { lazyImport } from &apos;@/utils/lazy-import.ts&apos;;
const { Brand } = lazyImport(() =&gt; import(&apos;@/ui/brand/Brand.tsx&apos;), &apos;Brand&apos;);
export function BareLayout(props: { children?: ReactNode }) {
  return (
    &lt;Flex height=&quot;100vh&quot; direction=&quot;column&quot; overflowY=&quot;auto&quot;&gt;
      &lt;Flex flexBasis=&quot;50px&quot; pl=&quot;8px&quot;&gt;
        &lt;Brand /&gt;
      &lt;/Flex&gt;
      &lt;Flex style={{ flex: 1 }}&gt;
        {props.children}
      &lt;/Flex&gt;
    &lt;/Flex&gt;
  );
}</file><file path="resources/app/layouts/root-layout/components/root-menu.tsx">import { Box, Button, ContextMenu, Dialog, Flex, ScrollArea, Text } from &apos;@radix-ui/themes&apos;;
import { NavLink } from &apos;@/ui/nav-link&apos;;
import { lazyImport } from &apos;@/utils/lazy-import&apos;;
import { Iconify } from &apos;@/ui/icons/iconify&apos;;
import styles from &apos;./root-menu.module.scss&apos;;
import { ReactNode, useMemo, useCallback } from &apos;react&apos;;
import { useLibraryServiceGetApiLibraries, usePlaylistServiceGetApiPlaylists } from &apos;@/api-client/queries&apos;;
import { CreatePlaylist } from &apos;@/modules/library-music-playlists/components/create-playlist/create-playlist.tsx&apos;;
import { CreateSmartPlaylist } from &apos;@/modules/library-music-playlists/components/create-smart-playlist/create-smart-playlist.tsx&apos;;
import { LibraryResource, PlaylistResource } from &apos;@/api-client/requests/types.gen&apos;;
import { useApmUserInteractions } from &apos;@/services/apm-user-interactions&apos;;
import {
  PlaylistLayoutContextMenu
} from &apos;@/modules/library-music-playlists/components/context-menu/playlist-layout-context-menu/playlist-layout-context-menu.tsx&apos;;
const { Brand } = lazyImport(() =&gt; import(&apos;@/ui/brand/Brand&apos;), &apos;Brand&apos;);
interface MenuLink {
  label: string;
  to?: string;
  href?: string;
  isSubsectionHeader?: boolean;
  isInnerSectionItem?: boolean;
  isDeepestLevelItem?: boolean;
  isTextOnly?: boolean;
  type?: &apos;playlist&apos;;
}
interface MenuSection {
  label: string;
  iconName: string;
  rightSide?: ReactNode;
  links: MenuLink[];
}
export function RootMenu() {
  const { data: libraryData } = useLibraryServiceGetApiLibraries();
  const { data: playlistData } = usePlaylistServiceGetApiPlaylists([&apos;playlists&apos;]);
  const { trackNavigation, trackButtonClick } = useApmUserInteractions();
  // Handler for tracking menu navigation
  const handleNavigation = useCallback((destination: string, label: string, section?: string) =&gt; {
    trackNavigation(destination, {
      menuItem: label,
      section: section || &apos;main&apos;,
      timestamp: new Date().toISOString(),
    });
  }, [trackNavigation]);
  // Handler for tracking button clicks
  const handleButtonClick = useCallback((buttonName: string, section?: string) =&gt; {
    trackButtonClick(buttonName, {
      section: section || &apos;main&apos;,
      timestamp: new Date().toISOString(),
    });
  }, [trackButtonClick]);
  const musicLibraries: LibraryResource[] = useMemo(() =&gt; libraryData?.data?.filter(library =&gt; library?.type === &apos;music&apos;) ?? [], [libraryData]);
  const movieLibraries: LibraryResource[] = useMemo(() =&gt; libraryData?.data?.filter(library =&gt; library?.type === &apos;movie&apos;) ?? [], [libraryData]);
  const playlists: PlaylistResource[] = useMemo(() =&gt; playlistData?.data ?? [], [playlistData]);
  const librariesMenu: MenuSection[] = useMemo(() =&gt; {
    const sections: MenuSection[] = [];
    const musicSection: MenuSection = {
      label: &apos;Music&apos;,
      iconName: &apos;ion:musical-notes&apos;,
      links: [],
      rightSide: (
        &lt;Flex gap=&quot;1&quot;&gt;
          &lt;Dialog.Root&gt;
            &lt;Dialog.Trigger&gt;
              &lt;Button
                size=&quot;1&quot;
                variant=&quot;ghost&quot;
                onClick={() =&gt; handleButtonClick(&apos;New Playlist&apos;, &apos;Music&apos;)}
              &gt;New&lt;/Button&gt;
            &lt;/Dialog.Trigger&gt;
            &lt;Dialog.Content&gt;
              &lt;Dialog.Title&gt;Create Playlist&lt;/Dialog.Title&gt;
              &lt;Dialog.Description&gt;&lt;/Dialog.Description&gt;
              &lt;CreatePlaylist /&gt;
            &lt;/Dialog.Content&gt;
          &lt;/Dialog.Root&gt;
          &lt;Dialog.Root&gt;
            &lt;Dialog.Trigger&gt;
              &lt;Button
                size=&quot;1&quot;
                variant=&quot;ghost&quot;
                onClick={() =&gt; handleButtonClick(&apos;Smart Playlist&apos;, &apos;Music&apos;)}
              &gt;Smart&lt;/Button&gt;
            &lt;/Dialog.Trigger&gt;
            &lt;Dialog.Content&gt;
              &lt;Dialog.Title&gt;Create Smart Playlist&lt;/Dialog.Title&gt;
              &lt;Dialog.Description&gt;Smart playlists automatically update based on rules you define.&lt;/Dialog.Description&gt;
              &lt;CreateSmartPlaylist /&gt;
            &lt;/Dialog.Content&gt;
          &lt;/Dialog.Root&gt;
        &lt;/Flex&gt;
      ),
    };
    // Add music libraries as subsections
    if (musicLibraries.length &gt; 0) {
      for (const library of musicLibraries) {
        // Add library as a subsection header
        musicSection.links.push({
          label: library.name,
          isSubsectionHeader: true,
          isTextOnly: true,
        });
        // Add library links as subsection items
        musicSection.links.push(
          {
            label: &apos;Artists&apos;,
            to: `/library/${library.slug}/artists`,
          },
          {
            label: &apos;Albums&apos;,
            to: `/library/${library.slug}/albums`,
          },
          {
            label: &apos;Songs&apos;,
            to: `/library/${library.slug}/songs`,
          },
          {
            label: &apos;Genres&apos;,
            to: `/library/${library.slug}/genres`,
          }
        );
      }
    }
    // Add Playlists subsection
    musicSection.links.push({
      label: &apos;Playlists&apos;,
      isSubsectionHeader: true,
      isTextOnly: true,
    });
    // Add individual playlists directly by title
    playlists.forEach(playlist =&gt; {
      musicSection.links.push({
        label: playlist.name,
        to: `/playlists/music/${playlist.id}`,
        type: &apos;playlist&apos;,
      });
    });
    // Add the music section to the menu
    sections.push(musicSection);
    // Add movie libraries
    if (movieLibraries.length &gt; 0) {
      for (const library of movieLibraries) {
        sections.push({
          label: library.name,
          iconName: &apos;ion-film-outline&apos;,
          links: [
            {
              label: &apos;Overview&apos;,
              to: `/library/${library.slug}/overview`,
            },
          ],
        });
      }
    }
    return sections;
  }, [musicLibraries, playlists]);
  const staticMenu: MenuSection[] = [
    {
      label: &apos;Navigation&apos;,
      iconName: &apos;heroicons:home&apos;,
      links: [
        { label: &apos;Dashboard&apos;, to: &apos;/dashboard/home&apos; },
      ],
    },
    {
      label: &apos;User&apos;,
      iconName: &apos;heroicons:user-circle-solid&apos;,
      links: [
        { label: &apos;Settings&apos;, to: &apos;/user/settings&apos; },
        { label: &apos;Equalizer&apos;, to: &apos;/user/settings/equalizer&apos; },
        { label: &apos;Sessions&apos;, to: &apos;/user/settings/sessions&apos; },
        { label: &apos;Passkeys&apos;, to: &apos;/user/settings/passkeys&apos; },
      ],
    },
  ];
  const menu = [...librariesMenu, ...staticMenu];
  return (
    &lt;Box className={styles.sidebar}&gt;
      &lt;Flex align=&quot;center&quot; justify=&quot;center&quot;&gt;
        &lt;Brand/&gt;
      &lt;/Flex&gt;
      &lt;ScrollArea&gt;
        &lt;Box className={styles.menuContainer}&gt;
          &lt;NavLink 
            to=&quot;/&quot; 
            className={styles.homeLink}
            onClick={() =&gt; handleNavigation(&apos;/&apos;, &apos;Home&apos;)}
          &gt;
            &lt;Flex align=&quot;center&quot; gap=&quot;2&quot;&gt;
              &lt;Iconify icon=&quot;heroicons:home&quot; width=&quot;24&quot; height=&quot;24&quot;/&gt;
              &lt;Text&gt;Home&lt;/Text&gt;
            &lt;/Flex&gt;
          &lt;/NavLink&gt;
          {menu.map((section: MenuSection, index: number) =&gt; (
            &lt;Box key={index} className={styles.menuSection}&gt;
              &lt;Text className={styles.sectionTitle}&gt;
                &lt;Flex align=&quot;center&quot; gap=&quot;1&quot;&gt;
                  &lt;Iconify icon={section.iconName} width=&quot;20&quot; height=&quot;20&quot;/&gt;
                  {section.label}
                  {section?.rightSide &amp;&amp; (
                    &lt;&gt;
                      {section.rightSide}
                    &lt;/&gt;
                  )}
                &lt;/Flex&gt;
              &lt;/Text&gt;
              &lt;Box className={styles.linksList}&gt;
                {section.links.map((link: MenuLink, linkIndex: number) =&gt; {
                  const isSubsectionHeader = link.isSubsectionHeader === true;
                  const isInnerSectionItem = link.isInnerSectionItem === true;
                  const isDeepestLevelItem = link.isDeepestLevelItem === true;
                  let isPartOfSubsection = false;
                  if (!isSubsectionHeader &amp;&amp; !isInnerSectionItem &amp;&amp; !isDeepestLevelItem) {
                    // Find the last subsection header before this link
                    for (let i = linkIndex - 1; i &gt;= 0; i--) {
                      if (section.links[i].isSubsectionHeader) {
                        // If we find a subsection header, this link is part of that subsection
                        isPartOfSubsection = true;
                        break;
                      }
                    }
                  }
                  // Create an array of class names and filter out any falsy values
                  const classNames = [
                    styles.menuLink,
                    isSubsectionHeader &amp;&amp; !isInnerSectionItem &amp;&amp; styles.subsectionHeader,
                    isSubsectionHeader &amp;&amp; isInnerSectionItem &amp;&amp; styles.innerSectionHeader,
                    isPartOfSubsection &amp;&amp; styles.subsectionItem,
                    isInnerSectionItem &amp;&amp; !isSubsectionHeader &amp;&amp; !isDeepestLevelItem &amp;&amp; styles.innerSectionItem,
                    isDeepestLevelItem &amp;&amp; styles.deepestLevelItem
                  ].filter(Boolean);
                  // Join the class names with a space
                  const linkClassName = classNames.join(&apos; &apos;);
                  if (link.isTextOnly) {
                    return (
                      &lt;Text
                        key={linkIndex}
                        className={linkClassName}
                        aria-disabled
                      &gt;
                        {link.label}
                      &lt;/Text&gt;
                    );
                  }
                  if (link.to &amp;&amp; link.type === &apos;playlist&apos;) {
                    return (
                      &lt;ContextMenu.Root key={linkIndex}&gt;
                        &lt;ContextMenu.Trigger&gt;
                          &lt;NavLink
                            key={linkIndex}
                            to={link.to}
                            className={linkClassName}
                            activeClassName={styles.activeLink}
                            onClick={() =&gt; handleNavigation(link.to, link.label, &apos;playlist&apos;)}
                          &gt;
                            {link.label}
                          &lt;/NavLink&gt;
                        &lt;/ContextMenu.Trigger&gt;
                        &lt;PlaylistLayoutContextMenu id={link.to.split(&apos;/&apos;).at(-1)!} /&gt;
                      &lt;/ContextMenu.Root&gt;
                    )
                  }
                  // Otherwise, render it as a link
                  return link.to ? (
                    &lt;NavLink
                      key={linkIndex}
                      to={link.to}
                      className={linkClassName}
                      activeClassName={styles.activeLink}
                      onClick={() =&gt; handleNavigation(link.to, link.label, section.label)}
                    &gt;
                      {link.label}
                    &lt;/NavLink&gt;
                  ) : link.href ? (
                    &lt;a
                      key={linkIndex}
                      href={link.href}
                      className={linkClassName}
                      onClick={() =&gt; handleNavigation(link.href, link.label, section.label)}
                    &gt;
                      {link.label}
                    &lt;/a&gt;
                  ) : null;
                })}
              &lt;/Box&gt;
            &lt;/Box&gt;
          ))}
        &lt;/Box&gt;
      &lt;/ScrollArea&gt;
    &lt;/Box&gt;
  );
}</file><file path="resources/app/modules/library-music/routes/albums.tsx">import { useState } from &apos;react&apos;;
import styles from &apos;./albums.module.scss&apos;;
import { AlbumDetail } from &apos;@/modules/library-music/components/album-detail/album-detail.tsx&apos;;
import { CoverGrid } from &apos;@/modules/library-music/components/cover-grid&apos;;
import { Album } from &apos;@/modules/library-music/components/album&apos;;
import { useAlbumServiceGetApiLibrariesByLibraryAlbums } from &apos;@/api-client/queries&apos;;
import { Box, ContextMenu, Flex, Skeleton } from &apos;@radix-ui/themes&apos;;
import { usePathParam } from &apos;@/hooks/use-path-param.ts&apos;;
import { LibraryParams } from &apos;@/modules/library-music/routes/_routes.tsx&apos;;
import { AlbumResource } from &apos;@/api-client/requests&apos;;
import { motion } from &apos;motion/react&apos;;
// @ts-expect-error
function AlbumContextMenu({ album }: { album: AlbumResource }) {
  return (
    &lt;ContextMenu.Content&gt;
      &lt;ContextMenu.Item&gt;Play&lt;/ContextMenu.Item&gt;
      &lt;ContextMenu.Item&gt;Edit&lt;/ContextMenu.Item&gt;
      &lt;ContextMenu.Separator/&gt;
      &lt;ContextMenu.Item color=&quot;red&quot;&gt;Delete&lt;/ContextMenu.Item&gt;
    &lt;/ContextMenu.Content&gt;
  );
}
export default function Albums() {
  const { library: libraryParam } = usePathParam&lt;LibraryParams&gt;();
  const [showAlbumDetail, setShowAlbumDetail] = useState&lt;string | null&gt;(null);
  const { data, isLoading } = useAlbumServiceGetApiLibrariesByLibraryAlbums({
    library: libraryParam,
    relations: &apos;artists,cover&apos;,
  });
  return (
    &lt;Flex justify=&quot;between&quot; align=&quot;stretch&quot; className={styles.albumsLayout}&gt;
      &lt;Box m=&quot;3&quot; className={styles.grid}&gt;
        &lt;CoverGrid&gt;
          {isLoading &amp;&amp; &lt;AlbumsSkeleton/&gt;}
          {data?.data &amp;&amp; (
            &lt;&gt;
              {data.data.map((album) =&gt; (
                &lt;div className={styles.album} key={album.slug}&gt;
                  &lt;ContextMenu.Root&gt;
                    &lt;ContextMenu.Trigger&gt;
                      &lt;Album
                        title={album.title}
                        primaryArtist={album?.artists?.map(x =&gt; x.name).join(&apos;,&apos;) ?? &apos;Unknown&apos;}
                        imgSrc={album?.cover?.url ?? undefined}
                        onClick={() =&gt; setShowAlbumDetail(album.slug)}
                      /&gt;
                    &lt;/ContextMenu.Trigger&gt;
                    &lt;AlbumContextMenu album={album}/&gt;
                  &lt;/ContextMenu.Root&gt;
                &lt;/div&gt;
              ))}
            &lt;/&gt;
          )}
        &lt;/CoverGrid&gt;
      &lt;/Box&gt;
      &lt;Box display=&quot;block&quot; minHeight=&quot;300px&quot; minWidth=&quot;300px&quot; className={styles.sidebar} mt=&quot;2&quot; mr=&quot;2&quot;&gt;
        {showAlbumDetail &amp;&amp; (
          &lt;motion.div
            layout
            initial={{ opacity: 0, scale: 0.5 }}
            animate={{ opacity: 1, scale: 1 }}
            transition={{
              duration: 0.3,
              ease: [0, 0.71, 0.2, 1.01],
            }}
          &gt;
            &lt;AlbumDetail albumSlug={showAlbumDetail}/&gt;
          &lt;/motion.div&gt;
        )}
      &lt;/Box&gt;
    &lt;/Flex&gt;
  );
}
function AlbumsSkeleton() {
  const generateItems = 24;
  const skeletons = [];
  for (let i = 0; i &lt; generateItems; i++) {
    skeletons.push(&lt;Skeleton key={i} height=&quot;220px&quot; width=&quot;200px&quot;/&gt;);
  }
  return (
    &lt;&gt;
      {skeletons}
    &lt;/&gt;
  );
}</file><file path="resources/app/services/auth/refresh-token.service.ts">import { Token } from &apos;@/services/auth/token.ts&apos;;
import { AuthService, OpenAPI } from &apos;@/api-client/requests&apos;;
import { setAccessToken, setStreamToken } from &apos;@/store/users/auth-slice.ts&apos;;
import { store } from &apos;@/store&apos;;
import { NotificationFacade } from &apos;@/modules/notifications/notification-facade.ts&apos;;
export async function refreshToken(type: &apos;access&apos; | &apos;stream&apos;) {
  const refreshToken = store.getState().auth?.refreshToken;
  if (refreshToken) {
    OpenAPI.TOKEN = refreshToken.token;
  } else {
    throw new Error(&apos;Refresh token not found&apos;);
  }
  if (type === &apos;access&apos;) {
    try {
      const accessToken = await AuthService.postApiAuthRefreshToken();
      Token.set({
        accessToken: accessToken.accessToken,
        refreshToken: refreshToken,
      });
      store.dispatch(setAccessToken(accessToken.accessToken));
      OpenAPI.TOKEN = accessToken.accessToken.token;
    } catch (e) {
      NotificationFacade.create({
        type: &apos;error&apos;,
        title: &apos;Authentication error&apos;,
        message: &apos;Failed to refresh access token&apos;,
        toast: true,
      });
      throw e;
    }
    return;
  }
  if (type === &apos;stream&apos;) {
    try {
      const streamToken = await AuthService.postApiAuthStreamToken();
      Token.setStreamToken(streamToken.streamToken);
      store.dispatch(setStreamToken(streamToken.streamToken));
    } catch (e) {
      NotificationFacade.create({
        type: &apos;error&apos;,
        title: &apos;Authentication error&apos;,
        message: &apos;Failed to refresh stream token&apos;,
      });
      throw e;
    }
    return;
  }
}</file><file path="resources/app/store/music/music-player-slice.ts">import { createSlice, PayloadAction } from &apos;@reduxjs/toolkit&apos;;
import { SongResource } from &apos;@/api-client/requests&apos;;
import { PlaybackSource } from &apos;@/modules/equalizer/models/playback-source.ts&apos;;
interface MusicPlayerSlice {
  queue: SongResource[];
  currentSongIndex: number;
  currentSongPublicId: string | null;
  progress: number;
  isPlaying: boolean;
  isMuted: boolean;
  source: PlaybackSource;
  mode: {
    isShuffleEnabled: boolean;
    isRepeatEnabled: boolean;
  };
  volume: {
    level: number;
    isMuted: boolean;
  };
  analysis: {
    leftChannel: number;
    rightChannel: number;
    frequencies: number[];
    bufferSize: number;
  };
  lyrics: {
    offsetMs: number;
  };
}
const initialState: MusicPlayerSlice = {
  queue: [],
  currentSongIndex: -1,
  currentSongPublicId: null,
  progress: 0,
  isPlaying: false,
  isMuted: false,
  source: PlaybackSource.NONE,
  mode: {
    isRepeatEnabled: false,
    isShuffleEnabled: false,
  },
  volume: {
    level: 100,
    isMuted: false,
  },
  analysis: {
    leftChannel: 0,
    rightChannel: 0,
    frequencies: [],
    bufferSize: 0,
  },
  lyrics: {
    offsetMs: -150,
  },
};
export const musicPlayerSlice = createSlice({
  name: &apos;musicPlayer&apos;,
  initialState,
  reducers: {
    addSongToQueue: (state, action: PayloadAction&lt;SongResource&gt;) =&gt; {
      state.source = PlaybackSource.LIBRARY;
      state.queue.push(action.payload);
    },
    addSongsToQueue: (state, action: PayloadAction&lt;SongResource[]&gt;) =&gt; {
      state.source = PlaybackSource.LIBRARY;
      state.queue.push(...action.payload);
    },
    setQueue(state, action: PayloadAction&lt;SongResource[]&gt;) {
      state.source = PlaybackSource.LIBRARY;
      state.queue = action.payload;
    },
    setQueueAndSong(state, action: PayloadAction&lt;{ queue: SongResource[], playPublicId: string }&gt;) {
      state.source = PlaybackSource.LIBRARY;
      state.queue = action.payload.queue;
      state.currentSongIndex = state.queue.findIndex(song =&gt; song.public_id === action.payload.playPublicId);
      state.currentSongPublicId = action.payload.playPublicId;
    },
    removeSongFromQueue: (state, action: PayloadAction&lt;number&gt;) =&gt; {
      state.queue.splice(action.payload, 1);
    },
    playNextSong: (state) =&gt; {
      if (state.currentSongIndex &lt; state.queue.length - 1) {
        state.currentSongIndex += 1;
      } else {
        state.currentSongIndex = 0; // Loop back to the start if at the end
      }
      state.currentSongPublicId = state.queue[state.currentSongIndex].public_id;
    },
    playPreviousSong: (state) =&gt; {
      if (state.currentSongIndex &gt; 0) {
        state.currentSongIndex -= 1;
      } else {
        state.currentSongIndex = state.queue.length - 1; // Loop back to the end if at the start
      }
      state.currentSongPublicId = state.queue[state.currentSongIndex].public_id;
    },
    setCurrentSongIndex: (state, action: PayloadAction&lt;number&gt;) =&gt; {
      if (action.payload &gt;= 0 &amp;&amp; action.payload &lt; state.queue.length) {
        state.currentSongIndex = action.payload;
        state.currentSongPublicId = state.queue[state.currentSongIndex].public_id;
      }
    },
    setIsShuffleEnabled: (state, action: PayloadAction&lt;boolean&gt;) =&gt; {
      state.mode.isShuffleEnabled = action.payload;
      state.mode.isRepeatEnabled = false;
    },
    setIsRepeatEnabled: (state, action: PayloadAction&lt;boolean&gt;) =&gt; {
      state.mode.isRepeatEnabled = action.payload;
      state.mode.isShuffleEnabled = false;
    },
    setIsMuted: (state, action: PayloadAction&lt;boolean&gt;) =&gt; {
      state.volume.isMuted = action.payload;
    },
    setVolume: (state, action: PayloadAction&lt;number&gt;) =&gt; {
      state.volume.level = action.payload;
    },
    setProgress: (state, action: PayloadAction&lt;number&gt;) =&gt; {
      state.progress = action.payload;
    },
    setIsPlaying: (state, action: PayloadAction&lt;boolean&gt;) =&gt; {
      state.isPlaying = action.payload;
    },
    setLeftChannel: (state, action: PayloadAction&lt;number&gt;) =&gt; {
      state.analysis.leftChannel = action.payload;
    },
    setRightChannel: (state, action: PayloadAction&lt;number&gt;) =&gt; {
      state.analysis.rightChannel = action.payload;
    },
    setFrequencies: (state, action: PayloadAction&lt;number[]&gt;) =&gt; {
      state.analysis.frequencies = action.payload;
    },
    setBufferSize: (state, action: PayloadAction&lt;number&gt;) =&gt; {
      state.analysis.bufferSize = action.payload;
    },
    setLyricsOffset: (state, action: PayloadAction&lt;{ ms: number }&gt;) =&gt; {
      state.lyrics.offsetMs = action.payload.ms;
    },
  },
  selectors: {
    selectSong: (sliceState) =&gt;
      sliceState.queue.length &gt; 0 &amp;&amp; sliceState.currentSongIndex &gt;= 0
      ? sliceState.queue[sliceState.currentSongIndex]
      : null,
  },
});
export const {
  addSongToQueue,
  addSongsToQueue,
  removeSongFromQueue,
  playNextSong,
  playPreviousSong,
  setCurrentSongIndex,
  setIsShuffleEnabled,
  setIsRepeatEnabled,
  setIsMuted,
  setVolume,
  setProgress,
  setIsPlaying,
  setQueue,
  setQueueAndSong,
  setLeftChannel,
  setRightChannel,
  setFrequencies,
  setBufferSize,
  setLyricsOffset,
} = musicPlayerSlice.actions;
export const {
  selectSong,
} = musicPlayerSlice.selectors;</file><file path=".gitignore">/.phpunit.cache
/node_modules
/public/build
/public/hot
/public/storage
/storage/*.key
/vendor
.env
.env.backup
.env.production
.phpunit.result.cache
Homestead.json
Homestead.yaml
auth.json
npm-debug.log
yarn-error.log
/.fleet
/.idea
/.vscode
bundle-visualization.html

# Project exclude paths
/storage/testlibrary/
/storage/framework/
/storage/muzak
/storage/muzak/
/storage/movies/
/storage/clockwork/*
.env.sentry-build-plugin
/api.json
/*.pem</file><file path="app/Console/Commands/SetupDevCommand.php">&lt;?php
namespace App\Console\Commands;
use Database\Seeders\DatabaseSeeder;
use Database\Seeders\UsersSeed;
use File;
use Illuminate\Console\Command;
class SetupDevCommand extends Command
{
    /**
     * The name and signature of the console command.
     *
     * @var string
     */
    protected $signature = &apos;setup:dev {--fresh : Drop and re-create database}&apos;;
    /**
     * The console command description.
     *
     * @var string
     */
    protected $description = &apos;Migrates database, generates secret and seeds test users.&apos;;
    /**
     * Execute the console command.
     */
    public function handle()
    {
        $this-&gt;envFile();
        $this-&gt;database();
    }
    private function envFile()
    {
        $examplePath = base_path(&apos;.env.example&apos;);
        $destPath = base_path(&apos;.env&apos;);
        if (!File::exists($destPath)) {
            $this-&gt;info(&apos;Copying .env.example to .env&apos;);
            File::copy($examplePath, $destPath);
        } else {
            $this-&gt;warn(&apos;.env already exists.&apos;);
        }
        $this-&gt;call(&apos;key:generate&apos;);
    }
    private function database()
    {
        if ($this-&gt;option(&apos;fresh&apos;)) {
            $this-&gt;call(&apos;migrate:fresh&apos;);
        } else {
            $this-&gt;call(&apos;migrate&apos;);
        }
        $this-&gt;call(&apos;db:seed&apos;, [
            &apos;--class&apos; =&gt; DatabaseSeeder::class,
        ]);
        $this-&gt;call(&apos;db:seed&apos;, [
            &apos;--class&apos; =&gt; UsersSeed::class,
        ]);
    }
}</file><file path="app/Http/Controllers/Api/GenreController.php">&lt;?php
namespace App\Http\Controllers\Api;
use App\Http\Requests\Genre\{GenreIndexRequest, UpdateGenreRequest};
use App\Http\Resources\Genre\GenreResource;
use App\Models\{Genre, TokenAbility};
use App\Modules\Pagination\JsonPaginator;
use Illuminate\Http\Resources\Json\AnonymousResourceCollection;
use Spatie\RouteAttributes\Attributes\{Delete, Get, Middleware, Patch, Prefix};
#[Prefix(&apos;/genres&apos;)]
#[Middleware([
    &apos;auth:sanctum&apos;,
    &apos;ability:&apos; . TokenAbility::ACCESS_API-&gt;value,
    &apos;force.json&apos;,
])]
class GenreController
{
    /**
     * Get a collection of genres
     *
     * @param GenreIndexRequest $request
     * @return AnonymousResourceCollection&lt;JsonPaginator&lt;GenreResource&gt;&gt;
     */
    #[Get(&apos;/&apos;, &apos;api.genres.index&apos;)]
    public function index(GenreIndexRequest $request)
    {
        $fields = $request-&gt;query(&apos;fields&apos;);
        $librarySlug = $request-&gt;query(&apos;librarySlug&apos;);
        $genres = Genre::query()
//            -&gt;selectFields(Genre::$filterFields, $fields)
            -&gt;withRelations(Genre::$filterFields, $fields)
            -&gt;paginate();
        return GenreResource::collection($genres);
    }
    /**
     * Get a genre
     */
    #[Get(&apos;{genre}&apos;, &apos;api.genres.show&apos;)]
    public function show(Genre $genre)
    {
        return new GenreResource($genre);
    }
    /**
     * Update a genre
     */
    #[Patch(&apos;/{genre}&apos;, &apos;api.genres.update&apos;)]
    public function update(UpdateGenreRequest $request, Genre $genre)
    {
        $genre-&gt;update($request-&gt;validated());
        return new GenreResource($genre);
    }
    /**
     * Delete a genre
     */
    #[Delete(&apos;/{genre}&apos;, &apos;api.genres.destroy&apos;)]
    public function delete(Genre $genre)
    {
        $genre-&gt;delete();
        return response(null, 204);
    }
}</file><file path="app/Http/Controllers/Api/UserController.php">&lt;?php
namespace App\Http\Controllers\Api;
use App\Http\Concerns\Filterable;
use App\Http\Requests\User\{CreateUserRequest, UpdateUserRequest, UserIndexRequest};
use App\Http\Resources\User\UserResource;
use App\Models\{TokenAbility, User};
use App\Modules\Pagination\JsonPaginator;
use Illuminate\Http\Request;
use Spatie\RouteAttributes\Attributes\{Delete, Get, Middleware, Patch, Post, Prefix};
#[Prefix(&apos;users&apos;)]
#[Middleware([
    &apos;auth:sanctum&apos;,
    &apos;ability:&apos; . TokenAbility::ACCESS_API-&gt;value,
    &apos;force.json&apos;,
])]
class UserController
{
    use Filterable;
    /**
     * Get a collection of users
     *
     * @return \Illuminate\Http\Resources\Json\AnonymousResourceCollection&lt;JsonPaginator&lt;UserResource&gt;&gt;
     */
    #[Get(&apos;/&apos;, &apos;api.users.index&apos;)]
    public function index(UserIndexRequest $request)
    {
        $columnsForGlobalFilter = [&apos;name&apos;, &apos;email&apos;];
        $users = $this-&gt;applyFilters($request, User::class, $columnsForGlobalFilter);
        return UserResource::collection($users);
    }
    /**
     * Create user
     *
     * This is endpoint allows administrators to create users
     */
    #[Post(&apos;/&apos;, &apos;api.users.store&apos;)]
    public function create(CreateUserRequest $request)
    {
        $user = User::create($request-&gt;validated());
        return new UserResource($user);
    }
    /**
     * Update a user
     */
    #[Patch(&apos;/{user}&apos;, &apos;api.users.update&apos;)]
    public function update(User $user, UpdateUserRequest $request)
    {
        $user-&gt;update($request-&gt;validated());
        return new UserResource($user);
    }
    /**
     * Get the authenticated user
     */
    #[Get(&apos;/me&apos;, &apos;api.users.me&apos;)]
    public function me(Request $request)
    {
        return new UserResource($request-&gt;user());
    }
    /**
     * Get small user detail info
     */
    #[Get(&apos;/{user}&apos;, &apos;api.users.show&apos;)]
    public function show(User $user)
    {
        return new UserResource($user);
    }
    /**
     * Delete a user
     */
    #[Delete(&apos;/{user}&apos;, &apos;api.users.destroy&apos;)]
    public function destroy($user)
    {
        $user-&gt;delete();
        return response(null, 204);
    }
}</file><file path="app/Http/Resources/Song/SongResource.php">&lt;?php
namespace App\Http\Resources\Song;
use App\Http\Resources\Album\AlbumWithoutSongsResource;
use App\Http\Resources\Artist\ArtistResource;
use App\Http\Resources\HasJsonCollection;
use App\Models\Song;
use App\Modules\Humanize\HumanDuration;
use Illuminate\Http\Request;
use Illuminate\Http\Resources\Json\JsonResource;
use function App\Modules\Humanize\humanize_bytes;
/**
 * @mixin Song
 */
class SongResource extends JsonResource
{
    use HasJsonCollection;
    /**
     * Transform the resource into an array.
     *
     * @return array&lt;string, mixed&gt;
     */
    public function toArray(Request $request): array
    {
        return [
            &apos;public_id&apos;     =&gt; $this-&gt;public_id,
            &apos;title&apos;         =&gt; $this-&gt;title,
            &apos;year&apos;          =&gt; $this-&gt;year,
            &apos;comment&apos;       =&gt; $this-&gt;comment,
            &apos;disc&apos;          =&gt; $this-&gt;disc,
            &apos;length&apos;        =&gt; $this-&gt;length,
            &apos;durationHuman&apos; =&gt; (new HumanDuration)-&gt;humanize($this-&gt;length),
            &apos;lyrics&apos;        =&gt; $this-&gt;lyrics,
            &apos;lyricsExist&apos;   =&gt; (bool)$this-&gt;lyrics,
            &apos;modifiedTime&apos;  =&gt; $this-&gt;modified_time,
            &apos;path&apos;          =&gt; $this-&gt;path,
            &apos;track&apos;         =&gt; $this-&gt;track,
            &apos;size&apos;          =&gt; $this-&gt;size,
            &apos;sizeHuman&apos;     =&gt; humanize_bytes($this-&gt;size),
            &apos;mimeType&apos;      =&gt; $this-&gt;mime_type,
            &apos;hash&apos;          =&gt; $this-&gt;hash,
            &apos;streamUrl&apos; =&gt; route(&apos;api.stream.song-direct&apos;, [&apos;song&apos; =&gt; $this-&gt;public_id]),
            &apos;createdAt&apos;     =&gt; $this-&gt;created_at,
            &apos;updatedAt&apos;     =&gt; $this-&gt;updated_at,
            &apos;album&apos;         =&gt; AlbumWithoutSongsResource::make($this-&gt;whenLoaded(&apos;album&apos;)),
            &apos;artists&apos;       =&gt; ArtistResource::collection($this-&gt;whenLoaded(&apos;artists&apos;)),
        ];
    }
}</file><file path="app/Jobs/Library/Music/ScanDirectoryJob.php">&lt;?php
namespace App\Jobs\Library\Music;
use App\Extensions\StrExt;
use App\Jobs\BaseJob;
use App\Models\{Album, Artist, Genre, Library, Song};
use App\Modules\Lyrics\Lrc;
use App\Modules\MediaMeta\MediaMeta;
use App\Modules\Translation\LocaleString;
use Arr;
use Illuminate\Contracts\Queue\ShouldQueue;
use Illuminate\Queue\Middleware\WithoutOverlapping;
use Illuminate\Support\Facades\{DB, File, Log};
use Illuminate\Support\LazyCollection;
use SplFileInfo;
class ScanDirectoryJob extends BaseJob implements ShouldQueue
{
    public const string ARTIST_SEPARATOR = &apos;;&apos;;
    public const string GENRE_SEPARATOR = &apos;;&apos;;
    private const int BATCH_SIZE = 50;
    public function __construct(
        public string  $directory,
        public Library $library,
    )
    {
    }
    /**
     * Get the middleware the job should pass through.
     *
     * @return array&lt;int, object&gt;
     */
    public function middleware(): array
    {
        $sha = hash(&apos;sha256&apos;, $this-&gt;directory);
        return [new WithoutOverlapping(&quot;scan_music_directory_$sha&quot;)-&gt;dontRelease()];
    }
    /**
     * @throws \Throwable
     */
    public function handle(): void
    {
        $this-&gt;queueProgress(0);
        DB::transaction(function () {
            $files = LazyCollection::make(File::files($this-&gt;directory));
            $this-&gt;processFiles($files);
        });
        unset($this-&gt;directory, $this-&gt;library, $this-&gt;tagger);
    }
    private function processFiles(LazyCollection $files): void
    {
        $coverJobs = [];
        $songs = [];
        $processedFiles = 0;
        $fileCount = $files-&gt;count();
        $files-&gt;each(function (SplFileInfo $file) use (&amp;$songs, &amp;$coverJobs, &amp;$lyrics, &amp;$processedFiles, &amp;$fileCount) {
            $mediaMeta = new MediaMeta($file-&gt;getRealPath());
            $this-&gt;processFile($mediaMeta, $file, $songs, $coverJobs);
            if (count($songs) &gt;= self::BATCH_SIZE) {
                $this-&gt;batchSaveSongs($songs);
                $songs = [];
                $this-&gt;queueProgressChunk($fileCount, self::BATCH_SIZE);
            }
        });
        if (!empty($songs)) {
            $this-&gt;batchSaveSongs($songs);
        }
        $this-&gt;queueProgress(100);
        $this-&gt;queueData([&apos;processedFiles&apos; =&gt; $processedFiles, &apos;fileCount&apos; =&gt; $fileCount]);
        $this-&gt;delete();
    }
    private function batchSaveSongs(array $songs): void
    {
        foreach ($songs as $songData) {
            $song = new Song($songData[&apos;attributes&apos;]);
            $song-&gt;album()-&gt;associate($songData[&apos;album&apos;]);
            try {
                $song-&gt;saveOrFail();
                $song-&gt;artists()-&gt;sync($this-&gt;getArtistIds($songData[&apos;artists&apos;]));
                $song-&gt;genres()-&gt;sync($this-&gt;getGenreIds($songData[&apos;genres&apos;]));
            } catch (\Throwable $e) {
                Log::error(&quot;Failed to save song: $song-&gt;title&quot;, [
                    &apos;exception&apos; =&gt; $e,
                ]);
            }
        }
    }
    private function processFile(MediaMeta $mediaMeta, SplFileInfo $file, array &amp;$songs, array &amp;$coverJobs): void
    {
        try {
            $filePath = $file-&gt;getRealPath();
            $hash = hash(&apos;sha256&apos;, $filePath);
            if (!$mediaMeta-&gt;isAudioFile() || Song::whereHash($hash)-&gt;exists()) {
                return;
            }
            if ($songData = $this-&gt;processMetadata(mediaMeta: $mediaMeta, filePath: $filePath, hash: $hash, file: $file, coverJobs: $coverJobs)) {
                $songs[] = $songData;
            }
        } catch (\Exception $e) {
            Log::error(&quot;Failed to process file: {$file-&gt;getRealPath()}&quot;, [
                &apos;isReadable&apos; =&gt; $file-&gt;isReadable(),
                &apos;isFile&apos;     =&gt; $file-&gt;isFile(),
                &apos;exception&apos;  =&gt; $e,
            ]);
        }
    }
    private function processMetadata(MediaMeta $mediaMeta, string $filePath, string $hash, SplFileInfo $file, array &amp;$coverJobs): ?array
    {
        try {
            $directoryName = basename(File::basename($file));
            $album = $this-&gt;findOrCreateAlbum(directoryName: $directoryName, albumTitle: $mediaMeta-&gt;getAlbum(), year: $mediaMeta-&gt;getYear());
            if (!$album) {
                return null;
            }
            $songAttributes = $this-&gt;makeSongAttributes(mediaMeta: $mediaMeta, file: $file, hash: $hash, lyric: $this-&gt;getLyric($file));
            if ($songAttributes) {
                $this-&gt;queueCoverJob($album, $coverJobs);
                $cleanBadNames = fn($v) =&gt; trim($v) !== &apos;&apos; &amp;&amp; $v !== null;
                $artists = $mediaMeta-&gt;getArtist();
                $artists = is_array($artists) ? array_filter($mediaMeta-&gt;getArtist(), $cleanBadNames) : array_filter(explode(self::ARTIST_SEPARATOR, $artists ?? &apos;&apos;), $cleanBadNames);
                $artistIds = $this-&gt;getArtistIds($artists);
                $album-&gt;artists()-&gt;sync($artistIds);
                return [
                    &apos;attributes&apos; =&gt; $songAttributes,
                    &apos;album&apos;      =&gt; $album,
                    &apos;artists&apos;    =&gt; $artists,
                    &apos;genres&apos;     =&gt; array_filter(explode(self::GENRE_SEPARATOR, $mediaMeta-&gt;getGenre() ?? &apos;&apos;), $cleanBadNames),
                ];
            }
            return null;
        } catch (\Exception $e) {
            Log::error(&quot;Error processing metadata for file: $filePath&quot;, [
                &apos;exception&apos; =&gt; $e,
            ]);
            return null;
        }
    }
    private function getLyric(SplFileInfo $file): ?string
    {
        $fullPath = $file-&gt;getRealPath();
        if (!$fullPath) {
            return null;
        }
        $pathWithoutFileName = pathinfo($fullPath, PATHINFO_DIRNAME);
        $lyricPath = $pathWithoutFileName . DIRECTORY_SEPARATOR . pathinfo($fullPath, PATHINFO_FILENAME) . &apos;.&apos; . Lrc::FILE_EXTENSION;
        return File::exists($lyricPath) ? File::get($lyricPath) : null;
    }
    private function findOrCreateAlbum(string $directoryName, string|null $albumTitle = null, int|null $year = null): ?Album
    {
        $title = $albumTitle;
        $album = Album::whereTitle($title)-&gt;whereLibraryId($this-&gt;library-&gt;id)-&gt;first();
        $fallback = $this-&gt;isSongInBaseDirectory($directoryName) ? LocaleString::delimitString(&apos;library.album.fallback&apos;) : $directoryName;
        if (!$album) {
            $album = new Album([
                &apos;title&apos; =&gt; $title ?: $fallback,
                &apos;year&apos;  =&gt; $year,
            ]);
            $album-&gt;library()-&gt;associate($this-&gt;library);
            try {
                $album-&gt;saveOrFail();
            } catch (\Exception $e) {
                Log::error(&quot;Failed to save album: $title&quot;, [
                    &apos;exception&apos; =&gt; $e,
                ]);
                return null;
            }
        }
        return $album;
    }
    private function makeSongAttributes(MediaMeta $mediaMeta, SplFileInfo $file, string $hash, ?string $lyric): ?array
    {
        $mimeType = $mediaMeta-&gt;getMimeType();
        if (!$mimeType) {
            return null;
        }
        return [
            &apos;title&apos;         =&gt; $mediaMeta-&gt;getTitle() ?? $file-&gt;getBasename(),
            &apos;track&apos;         =&gt; $mediaMeta-&gt;getTrackNumber(),
            &apos;length&apos;        =&gt; $mediaMeta-&gt;probeLength(),
            &apos;lyrics&apos;        =&gt; $lyric ? StrExt::convertToUtf8($lyric) : null,
            &apos;path&apos;          =&gt; $file-&gt;getRealPath(),
            &apos;mime_type&apos;     =&gt; $mediaMeta-&gt;getMimeType(),
            &apos;modified_time&apos; =&gt; $file-&gt;getMTime(),
            &apos;size&apos;          =&gt; is_int($file-&gt;getSize()) ? $file-&gt;getSize() : 0,
            &apos;hash&apos;          =&gt; $hash,
        ];
    }
    private function getArtistIds(array $artists): array
    {
        return array_map(function ($artistName) {
            return Artist::firstOrCreate([&apos;name&apos; =&gt; trim($artistName)])-&gt;id;
        }, $artists);
    }
    private function getGenreIds(array $genres): array
    {
        return array_map(function ($genreName) {
            return Genre::firstOrCreate([&apos;name&apos; =&gt; ucfirst(trim($genreName))])-&gt;id;
        }, $genres);
    }
    private function queueCoverJob(Album $album, array &amp;$coverJobs): void
    {
        if (!in_array($album-&gt;id, $coverJobs)
            &amp;&amp; !$album-&gt;cover()-&gt;exists()
            &amp;&amp; !$this-&gt;isCoverJobQueued($album, $coverJobs)) {
            SaveAlbumCoverJob::dispatch($album)-&gt;afterCommit();
            $coverJobs[] = $album-&gt;id;
        }
    }
    private function isCoverJobQueued(Album $album, array $coverJobs): bool
    {
        return Arr::has($coverJobs, $album-&gt;id);
    }
    private function isSongInBaseDirectory(string $path): bool
    {
        $baseDirectory = $this-&gt;library-&gt;path;
        $relativePath = str_replace($baseDirectory, &apos;&apos;, $path);
        return $relativePath[0] !== DIRECTORY_SEPARATOR;
    }
}</file><file path="app/Models/BaseModel.php">&lt;?php
namespace App\Models;
use App\Models\Concerns\IsBaseModel;
use Illuminate\Database\Eloquent\Model;
abstract class BaseModel extends Model
{
    use IsBaseModel;
    protected $dateFormat = &apos;Y-m-d H:i:sO&apos;;
}</file><file path="config/database.php">&lt;?php
use Illuminate\Support\Str;
return [
    /*
    |--------------------------------------------------------------------------
    | Default Database Connection Name
    |--------------------------------------------------------------------------
    |
    | Here you may specify which of the database connections below you wish
    | to use as your default connection for all database work. Of course
    | you may use many connections at once using the Database library.
    |
    */
    &apos;default&apos; =&gt; env(&apos;DB_CONNECTION&apos;, &apos;pgsql&apos;),
    /*
    |--------------------------------------------------------------------------
    | Database Connections
    |--------------------------------------------------------------------------
    |
    | Here are each of the database connections setup for your application.
    | Of course, examples of configuring each database platform that is
    | supported by Laravel is shown below to make development simple.
    |
    |
    | All database work in Laravel is done through the PHP PDO facilities
    | so make sure you have the driver for your particular database of
    | choice installed on your machine before you begin development.
    |
    */
    &apos;connections&apos; =&gt; [
        &apos;sqlite&apos; =&gt; [
            &apos;driver&apos;                  =&gt; &apos;sqlite&apos;,
            &apos;url&apos;                     =&gt; env(&apos;DATABASE_URL&apos;),
            &apos;database&apos;                =&gt; env(&apos;DB_DATABASE&apos;, database_path(&apos;database.sqlite&apos;)),
            &apos;prefix&apos;                  =&gt; &apos;&apos;,
            &apos;foreign_key_constraints&apos; =&gt; env(&apos;DB_FOREIGN_KEYS&apos;, true),
        ],
        &apos;pgsql&apos; =&gt; [
            &apos;driver&apos;         =&gt; &apos;pgsql&apos;,
            &apos;url&apos;            =&gt; env(&apos;DATABASE_URL&apos;),
            &apos;host&apos;           =&gt; env(&apos;DB_HOST&apos;, &apos;127.0.0.1&apos;),
            &apos;port&apos;           =&gt; env(&apos;DB_PORT&apos;, &apos;5432&apos;),
            &apos;database&apos;       =&gt; env(&apos;DB_DATABASE&apos;, &apos;forge&apos;),
            &apos;username&apos;       =&gt; env(&apos;DB_USERNAME&apos;, &apos;forge&apos;),
            &apos;password&apos;       =&gt; env(&apos;DB_PASSWORD&apos;, &apos;&apos;),
            &apos;charset&apos;        =&gt; &apos;utf8&apos;,
            &apos;prefix&apos;         =&gt; &apos;&apos;,
            &apos;prefix_indexes&apos; =&gt; true,
            &apos;search_path&apos;    =&gt; &apos;public&apos;,
            &apos;sslmode&apos;        =&gt; &apos;prefer&apos;,
        ],
    ],
    /*
    |--------------------------------------------------------------------------
    | Migration Repository Table
    |--------------------------------------------------------------------------
    |
    | This table keeps track of all the migrations that have already run for
    | your application. Using this information, we can determine which of
    | the migrations on disk haven&apos;t actually been run in the database.
    |
    */
    &apos;migrations&apos; =&gt; [
        &apos;table&apos;                  =&gt; &apos;migrations&apos;,
        &apos;update_date_on_publish&apos; =&gt; true,
    ],
    /*
    |--------------------------------------------------------------------------
    | Redis Databases
    |--------------------------------------------------------------------------
    |
    | Redis is an open source, fast, and advanced key-value store that also
    | provides a richer body of commands than a typical key-value system
    | such as APC or Memcached. Laravel makes it easy to dig right in.
    |
    */
    &apos;redis&apos; =&gt; [
        &apos;client&apos; =&gt; env(&apos;REDIS_CLIENT&apos;, &apos;phpredis&apos;),
        &apos;options&apos; =&gt; [
            &apos;cluster&apos;     =&gt; env(&apos;REDIS_CLUSTER&apos;, &apos;redis&apos;),
            &apos;prefix&apos;      =&gt; env(&apos;REDIS_PREFIX&apos;, &apos;&apos;),
            &apos;serializer&apos;  =&gt; Redis::SERIALIZER_IGBINARY,
            &apos;compression&apos; =&gt; Redis::COMPRESSION_ZSTD,
        ],
        &apos;default&apos; =&gt; [
            &apos;url&apos;      =&gt; env(&apos;REDIS_URL&apos;),
            &apos;host&apos;     =&gt; env(&apos;REDIS_HOST&apos;, &apos;127.0.0.1&apos;),
            &apos;username&apos; =&gt; env(&apos;REDIS_USERNAME&apos;),
            &apos;password&apos; =&gt; env(&apos;REDIS_PASSWORD&apos;),
            &apos;port&apos;     =&gt; env(&apos;REDIS_PORT&apos;, &apos;6379&apos;),
            &apos;database&apos; =&gt; env(&apos;REDIS_DB&apos;, &apos;0&apos;),
        ],
        &apos;cache&apos; =&gt; [
            &apos;url&apos;      =&gt; env(&apos;REDIS_URL&apos;),
            &apos;host&apos;     =&gt; env(&apos;REDIS_HOST&apos;, &apos;127.0.0.1&apos;),
            &apos;username&apos; =&gt; env(&apos;REDIS_USERNAME&apos;),
            &apos;password&apos; =&gt; env(&apos;REDIS_PASSWORD&apos;),
            &apos;port&apos;     =&gt; env(&apos;REDIS_PORT&apos;, &apos;6379&apos;),
            &apos;database&apos; =&gt; env(&apos;REDIS_CACHE_DB&apos;, &apos;1&apos;),
        ],
        &apos;sessions&apos; =&gt; [
            &apos;url&apos;      =&gt; env(&apos;REDIS_URL&apos;),
            &apos;host&apos;     =&gt; env(&apos;REDIS_HOST&apos;, &apos;127.0.0.1&apos;),
            &apos;username&apos; =&gt; env(&apos;REDIS_USERNAME&apos;),
            &apos;password&apos; =&gt; env(&apos;REDIS_PASSWORD&apos;),
            &apos;port&apos;     =&gt; env(&apos;REDIS_PORT&apos;, &apos;6379&apos;),
            &apos;database&apos; =&gt; env(&apos;REDIS_SESSION_DB&apos;, &apos;2&apos;),
        ],
        &apos;horizon&apos; =&gt; [
            &apos;url&apos;      =&gt; env(&apos;REDIS_URL&apos;),
            &apos;host&apos;     =&gt; env(&apos;REDIS_HOST&apos;, &apos;127.0.0.1&apos;),
            &apos;username&apos; =&gt; env(&apos;REDIS_USERNAME&apos;),
            &apos;password&apos; =&gt; env(&apos;REDIS_PASSWORD&apos;),
            &apos;port&apos;     =&gt; env(&apos;REDIS_PORT&apos;, &apos;6379&apos;),
            &apos;database&apos; =&gt; env(&apos;QUEUE_HORIZON_DB&apos;, &apos;3&apos;),
        ],
        &apos;secret&apos; =&gt; [
            &apos;url&apos;      =&gt; env(&apos;REDIS_URL&apos;),
            &apos;host&apos;     =&gt; env(&apos;REDIS_HOST&apos;, &apos;127.0.0.1&apos;),
            &apos;username&apos; =&gt; env(&apos;REDIS_USERNAME&apos;),
            &apos;password&apos; =&gt; env(&apos;REDIS_PASSWORD&apos;),
            &apos;port&apos;     =&gt; env(&apos;REDIS_PORT&apos;, &apos;6379&apos;),
            &apos;database&apos; =&gt; env(&apos;REDIS_SECRET_DB&apos;, &apos;5&apos;),
        ],
        &apos;transcodes&apos; =&gt; [
            &apos;url&apos;      =&gt; env(&apos;REDIS_URL&apos;),
            &apos;host&apos;     =&gt; env(&apos;REDIS_HOST&apos;, &apos;127.0.0.1&apos;),
            &apos;username&apos; =&gt; env(&apos;REDIS_USERNAME&apos;),
            &apos;password&apos; =&gt; env(&apos;REDIS_PASSWORD&apos;),
            &apos;port&apos;     =&gt; env(&apos;REDIS_PORT&apos;, &apos;6379&apos;),
            &apos;database&apos; =&gt; env(&apos;REDIS_TRANSCODE_DB&apos;, &apos;6&apos;),
        ],
        &apos;sanctum&apos; =&gt; [
            &apos;url&apos; =&gt; env(&apos;REDIS_URL&apos;),
            &apos;host&apos; =&gt; env(&apos;REDIS_HOST&apos;, &apos;127.0.0.1&apos;),
            &apos;username&apos; =&gt; env(&apos;REDIS_USERNAME&apos;),
            &apos;password&apos; =&gt; env(&apos;REDIS_PASSWORD&apos;),
            &apos;port&apos; =&gt; env(&apos;REDIS_PORT&apos;, &apos;6379&apos;),
            &apos;database&apos; =&gt; env(&apos;REDIS_SANCTUM_DB&apos;, &apos;7&apos;),
            &apos;read_timeout&apos; =&gt; 30,
        ],
    ],
];</file><file path="config/logging.php">&lt;?php
use Monolog\Handler\NullHandler;
use Monolog\Handler\StreamHandler;
use Monolog\Processor\PsrLogMessageProcessor;
return [
    /*
    |--------------------------------------------------------------------------
    | Default Log Channel
    |--------------------------------------------------------------------------
    |
    | This option defines the default log channel that gets used when writing
    | messages to the logs. The name specified in this option should match
    | one of the channels defined in the &quot;channels&quot; configuration array.
    |
    */
    &apos;default&apos; =&gt; env(&apos;LOG_CHANNEL&apos;, &apos;stack&apos;),
    /*
    |--------------------------------------------------------------------------
    | Deprecations Log Channel
    |--------------------------------------------------------------------------
    |
    | This option controls the log channel that should be used to log warnings
    | regarding deprecated PHP and library features. This allows you to get
    | your application ready for upcoming major versions of dependencies.
    |
    */
    &apos;deprecations&apos; =&gt; [
        &apos;channel&apos; =&gt; env(&apos;LOG_DEPRECATIONS_CHANNEL&apos;, &apos;single&apos;),
        &apos;trace&apos;   =&gt; false,
    ],
    /*
    |--------------------------------------------------------------------------
    | Log Channels
    |--------------------------------------------------------------------------
    |
    | Here you may configure the log channels for your application. Out of
    | the box, Laravel uses the Monolog PHP logging library. This gives
    | you a variety of powerful log handlers / formatters to use.
    |
    | Available Drivers: &quot;single&quot;, &quot;daily&quot;, &quot;slack&quot;, &quot;syslog&quot;,
    |                    &quot;errorlog&quot;, &quot;monolog&quot;,
    |                    &quot;custom&quot;, &quot;stack&quot;
    |
    */
    &apos;channels&apos; =&gt; [
        &apos;stack&apos; =&gt; [
            &apos;driver&apos;            =&gt; &apos;stack&apos;,
            &apos;channels&apos;          =&gt; [&apos;single&apos;],
            &apos;ignore_exceptions&apos; =&gt; false,
        ],
        &apos;single&apos; =&gt; [
            &apos;driver&apos;               =&gt; &apos;single&apos;,
            &apos;path&apos;                 =&gt; storage_path(&apos;logs/laravel.log&apos;),
            &apos;level&apos;                =&gt; env(&apos;LOG_LEVEL&apos;, &apos;debug&apos;),
            &apos;replace_placeholders&apos; =&gt; true,
        ],
        &apos;jobs_file&apos; =&gt; [
            &apos;driver&apos;               =&gt; &apos;single&apos;,
            &apos;path&apos;                 =&gt; storage_path(&apos;logs/jobs.log&apos;),
            &apos;level&apos;                =&gt; env(&apos;LOG_LEVEL&apos;, &apos;debug&apos;),
            &apos;replace_placeholders&apos; =&gt; true,
        ],
        &apos;daily&apos; =&gt; [
            &apos;driver&apos;               =&gt; &apos;daily&apos;,
            &apos;path&apos;                 =&gt; storage_path(&apos;logs/laravel.log&apos;),
            &apos;level&apos;                =&gt; env(&apos;LOG_LEVEL&apos;, &apos;debug&apos;),
            &apos;days&apos;                 =&gt; 14,
            &apos;replace_placeholders&apos; =&gt; true,
        ],
        &apos;stderr&apos; =&gt; [
            &apos;driver&apos;     =&gt; &apos;monolog&apos;,
            &apos;level&apos;      =&gt; env(&apos;LOG_LEVEL&apos;, &apos;error&apos;),
            &apos;handler&apos;    =&gt; StreamHandler::class,
            &apos;formatter&apos;  =&gt; env(&apos;LOG_STDERR_FORMATTER&apos;),
            &apos;with&apos;       =&gt; [
                &apos;stream&apos; =&gt; &apos;php://stderr&apos;,
            ],
            &apos;processors&apos; =&gt; [PsrLogMessageProcessor::class],
        ],
        &apos;stdout&apos; =&gt; [
            &apos;driver&apos;     =&gt; &apos;monolog&apos;,
            &apos;level&apos;      =&gt; &apos;debug&apos;,
            &apos;handler&apos;    =&gt; StreamHandler::class,
            &apos;formatter&apos;  =&gt; env(&apos;LOG_STDOUT_FORMATTER&apos;),
            &apos;with&apos;       =&gt; [
                &apos;stream&apos; =&gt; &apos;php://stdout&apos;,
            ],
            &apos;processors&apos; =&gt; [PsrLogMessageProcessor::class],
        ],
        &apos;syslog&apos; =&gt; [
            &apos;driver&apos;               =&gt; &apos;syslog&apos;,
            &apos;level&apos;                =&gt; env(&apos;LOG_LEVEL&apos;, &apos;debug&apos;),
            &apos;facility&apos;             =&gt; LOG_USER,
            &apos;replace_placeholders&apos; =&gt; true,
        ],
        &apos;errorlog&apos; =&gt; [
            &apos;driver&apos;               =&gt; &apos;errorlog&apos;,
            &apos;level&apos;                =&gt; env(&apos;LOG_LEVEL&apos;, &apos;debug&apos;),
            &apos;replace_placeholders&apos; =&gt; true,
        ],
        &apos;null&apos; =&gt; [
            &apos;driver&apos;  =&gt; &apos;monolog&apos;,
            &apos;handler&apos; =&gt; NullHandler::class,
        ],
        &apos;emergency&apos; =&gt; [
            &apos;driver&apos; =&gt; &apos;monolog&apos;,
            &apos;path&apos;   =&gt; storage_path(&apos;logs/laravel.log&apos;),
        ],
        &apos;musicbrainz&apos; =&gt; [
            &apos;driver&apos;               =&gt; &apos;single&apos;,
            &apos;path&apos;                 =&gt; storage_path(&apos;logs/musicbrainz.log&apos;),
            &apos;level&apos;                =&gt; env(&apos;LOG_LEVEL&apos;, &apos;debug&apos;),
            &apos;replace_placeholders&apos; =&gt; true,
        ],
        //
        //        &apos;php_deprecations&apos; =&gt; [
        //            &apos;driver&apos;               =&gt; &apos;single&apos;,
        //            &apos;path&apos;                 =&gt; storage_path(&apos;logs/deprecations.log&apos;),
        //            &apos;level&apos;                =&gt; env(&apos;LOG_LEVEL&apos;, &apos;debug&apos;),
        //            &apos;replace_placeholders&apos; =&gt; true,
        //        ],
        //
        //        &apos;deprecations&apos; =&gt; [
        //            &apos;channel&apos; =&gt; env(&apos;LOG_DEPRECATIONS_CHANNEL&apos;, &apos;php_deprecations&apos;),
        //            &apos;trace&apos;   =&gt; env(&apos;LOG_DEPRECATIONS_TRACE&apos;, false),
        //        ],
    ],
];</file><file path="resources/app/bootstrap.ts">// External CSS imports
import &apos;overlayscrollbars/overlayscrollbars.css&apos;;
// dayjs and its plugins
import dayjs from &apos;dayjs&apos;;
import duration from &apos;dayjs/plugin/duration&apos;;
import relativeTime from &apos;dayjs/plugin/relativeTime&apos;;
import localizedFormat from &apos;dayjs/plugin/localizedFormat&apos;;
// Import dayjs locales
import &apos;dayjs/locale/da&apos;;
import &apos;dayjs/locale/de&apos;;
import &apos;dayjs/locale/en&apos;;
import &apos;dayjs/locale/en-gb&apos;;
import &apos;dayjs/locale/es&apos;;
import &apos;dayjs/locale/th&apos;;
import &apos;dayjs/locale/zh-cn&apos;;
// Extend dayjs with plugins
dayjs.extend(duration);
dayjs.extend(relativeTime);
dayjs.extend(localizedFormat);
// Internal imports
import { applyInterceptors } from &apos;@/api-client-ext/interceptors&apos;;
import { OpenAPI as OpenAPIConfig } from &apos;@/api-client/requests&apos;;
import { Token } from &apos;@/services/auth/token.ts&apos;;
// OpenAPI configuration
OpenAPIConfig.BASE = `${import.meta.env.VITE_APP_URL}`;
OpenAPIConfig.CREDENTIALS = &apos;same-origin&apos;;
OpenAPIConfig.HEADERS = {
  &apos;accept&apos;: &apos;application/json&apos;,
  &apos;X-CSRF-TOKEN&apos;: document.head.querySelector(&apos;meta[name=&quot;csrf-token&quot;]&apos;)!.getAttribute(&apos;content&apos;) as string,
  &apos;X-Requested-With&apos;: &apos;XMLHttpRequest&apos;,
};
OpenAPIConfig.TOKEN = Token.get()?.accessToken.token;
// Apply request interceptors
applyInterceptors();</file><file path="resources/app/layouts/root-layout/root-layout.module.scss">.shell {
    display: grid;
    grid-template-rows: 1fr auto; /* Main | Footer */
    grid-template-columns: 250px 1fr; /* Sidebar | Content */
    height: 100vh;
    overflow: hidden;
}
.sidebar {
    grid-row: 1 / 3; /* Spans the Sidebar across Main and Footer */
    grid-column: 1; /* Occupies the first column */
    display: flex;
    flex-direction: column;
    width: 100%;
    overflow: hidden;
}
.main {
    grid-row: 1; /* Occupies the first row */
    grid-column: 2; /* Starts next to the Sidebar */
    display: flex;
    flex-direction: column;
    flex: 1;
    min-height: 0;
    overflow: hidden;
}
.content {
    flex-grow: 1;
    overflow-y: auto;
}
.content &gt; .page {
    display: flex;
    flex-direction: column;
    height: 100%;
    width: 100%;
    max-width: 100%;
    overflow-x: hidden;
    overflow-y: auto;
    box-sizing: border-box;
}
.footer {
    background-color: var(--color-panel);
    height: 85px;
    width: 100%;
    display: flex;
    flex-wrap: wrap;
    flex-grow: 1;
}</file><file path="resources/app/modules/library-music/components/song-list/song-list.tsx">import { usePathParam } from &apos;@/hooks/use-path-param&apos;;
import { LibraryParams } from &apos;@/modules/library-music/routes/_routes&apos;;
import { useSongServiceGetApiLibrariesByLibrarySongsInfinite } from &apos;@/api-client/queries/infiniteQueries&apos;;
import { SongTable } from &apos;@/components/song-table/song-table&apos;;
import styles from &apos;./song-list.module.scss&apos;;
export function SongList() {
  const { library: libraryParam } = usePathParam&lt;LibraryParams&gt;();
  const {
    data: songData,
    fetchNextPage,
    hasNextPage,
    isFetchingNextPage,
  } = useSongServiceGetApiLibrariesByLibrarySongsInfinite({
    library: libraryParam,
    relations: &apos;album,artists,album.cover,songs.genres&apos;,
  });
  const allSongs = songData ? songData.pages.flatMap((page) =&gt; page.data) : [];
  return (
    &lt;SongTable
      songs={allSongs}
      onFetchNextPage={fetchNextPage}
      hasNextPage={hasNextPage}
      isFetchingNextPage={isFetchingNextPage}
      className={styles.songListTable}
    /&gt;
  );
}</file><file path="resources/app/providers/music-source-provider.tsx">import React, { RefObject, useCallback, useContext, useEffect, useMemo, useState } from &apos;react&apos;;
import { noop } from &apos;@/utils/noop.ts&apos;;
import { useStreamToken } from &apos;@/hooks/use-stream-token.ts&apos;;
import { useAppDispatch, useAppSelector } from &apos;@/store/hooks.ts&apos;;
import { playNextSong, selectSong } from &apos;@/store/music/music-player-slice.ts&apos;;
interface MusicSourceContextType {
  authenticatedSource: string | undefined;
  audioRef: RefObject&lt;HTMLAudioElement | null&gt; | undefined;
  setAudioRef: (audioRef: RefObject&lt;HTMLAudioElement | null&gt;) =&gt; void;
}
export const MusicSourceContext = React.createContext&lt;MusicSourceContextType&gt;({
  authenticatedSource: undefined,
  audioRef: undefined,
  setAudioRef: () =&gt; noop(),
});
MusicSourceContext.displayName = &apos;MusicSourceContext&apos;;
export function MusicSourceProvider({ children }: { children: React.ReactNode }) {
  const dispatch = useAppDispatch();
  const { streamToken } = useStreamToken();
  const currentSong = useAppSelector(selectSong);
  const [audioRef, setAudioRef] = useState&lt;RefObject&lt;HTMLAudioElement | null&gt;&gt;();
  const authenticatedSource = useMemo(() =&gt; {
    if (currentSong?.streamUrl &amp;&amp; streamToken) {
      return `${currentSong.streamUrl}?_token=${streamToken}`;
    }
    return undefined;
  }, [currentSong, streamToken]);
  const onSongEnd = useCallback(() =&gt; {
    dispatch(playNextSong());
  }, [dispatch]);
  useEffect(() =&gt; {
    if (audioRef?.current) {
      audioRef.current.addEventListener(&apos;ended&apos;, onSongEnd);
      return () =&gt; audioRef.current?.removeEventListener(&apos;ended&apos;, onSongEnd);
    }
  }, [audioRef, onSongEnd]);
  return (
    &lt;MusicSourceContext.Provider
      value={{
        authenticatedSource,
        audioRef,
        setAudioRef,
      }}
    &gt;
      {children}
    &lt;/MusicSourceContext.Provider&gt;
  );
}
export function useMusicSource() {
  return useContext(MusicSourceContext);
}</file><file path="resources/app/store/users/auth-slice.ts">import { createAppSlice } from &apos;@/store/create-app-slice.ts&apos;;
import { createAsyncThunk, PayloadAction } from &apos;@reduxjs/toolkit&apos;;
import { Token } from &apos;@/services/auth/token.ts&apos;;
import { AuthService, NewAccessTokenResource, RegisterRequest } from &apos;@/api-client/requests&apos;;
import { clearAuthState, setAuthState } from &apos;@/store/users/auth-slice.utils.ts&apos;;
export const logoutUser = createAsyncThunk(&apos;auth/logout&apos;, async () =&gt; {
  const token = Token.get();
  if (!token) {
    return;
  }
  return AuthService.postApiAuthLogout({ requestBody: { refreshToken: token.refreshToken?.token } });
});
export const createUser = createAsyncThunk(&apos;auth/register&apos;, async (options: RegisterRequest) =&gt; {
  return AuthService.postApiAuthRegister({
    requestBody: options,
  });
});
export const loginUser = createAsyncThunk(&apos;auth/login&apos;, (options: { email: string, password: string }) =&gt; {
  return AuthService.postApiAuthLogin({
    requestBody: options,
  });
});
export interface UserModel {
  name: string;
  email: string;
  isAdmin: boolean;
}
export interface AuthSliceState {
  authenticated: boolean;
  accessToken: NewAccessTokenResource | null;
  refreshToken: NewAccessTokenResource | null;
  streamToken: NewAccessTokenResource | null;
  user: UserModel | null;
  loading: boolean;
}
const initialState: AuthSliceState = {
  authenticated: false,
  accessToken: null,
  refreshToken: null,
  streamToken: null,
  user: null,
  loading: false,
};
export const authSlice = createAppSlice({
  name: &apos;auth&apos;,
  initialState,
  reducers: {
    setIsAuthenticated(state, action: PayloadAction&lt;boolean&gt;) {
      state.authenticated = action.payload;
    },
    setAccessToken(state, action: PayloadAction&lt;NewAccessTokenResource&gt;) {
      state.accessToken = action.payload;
    },
    setRefreshToken(state, action: PayloadAction&lt;NewAccessTokenResource&gt;) {
      state.refreshToken = action.payload;
    },
    setStreamToken(state, action: PayloadAction&lt;NewAccessTokenResource&gt;) {
      state.streamToken = action.payload;
    },
    setUser(state, action: PayloadAction&lt;UserModel&gt;) {
      state.user = action.payload;
    },
    removeUser(state) {
      state.user = null;
    },
  },
  extraReducers: builder =&gt; {
    builder.addCase(logoutUser.pending, (state) =&gt; {
      state.loading = true;
    });
    builder.addCase(logoutUser.fulfilled, (state) =&gt; {
      clearAuthState(state);
    });
    builder.addCase(logoutUser.rejected, (state) =&gt; {
      clearAuthState(state);
    });
    builder.addCase(createUser.pending, (state) =&gt; {
      state.loading = true;
    });
    builder.addCase(createUser.fulfilled, (state, action) =&gt; {
      setAuthState(state, action.payload);
    });
    builder.addCase(loginUser.pending, (state) =&gt; {
      state.loading = true;
    });
    builder.addCase(loginUser.fulfilled, (state, action) =&gt; {
      setAuthState(state, action.payload);
    });
  },
  selectors: {
    selectIsAuthenticated: auth =&gt; auth.authenticated,
    selectAccessToken: auth =&gt; auth.accessToken,
    selectRefreshToken: auth =&gt; auth.refreshToken,
    selectStreamToken: auth =&gt; auth.streamToken,
    selectUser: auth =&gt; auth.user,
  },
});
export const {
  setIsAuthenticated,
  setAccessToken,
  setRefreshToken,
  setStreamToken,
  setUser,
  removeUser,
} = authSlice.actions;
export const {
  selectIsAuthenticated,
  selectAccessToken,
  selectRefreshToken,
  selectStreamToken,
  selectUser,
} = authSlice.selectors;</file><file path="app/Providers/AuthServiceProvider.php">&lt;?php
namespace App\Providers;
use App\Models\PersonalAccessToken;
use App\Modules\Webauthn\CounterChecker;
use App\Modules\Webauthn\WebauthnService;
use Illuminate\Support\Facades\Gate;
use Illuminate\Support\ServiceProvider;
use Laravel\Passport\Passport;
use Laravel\Sanctum\Sanctum;
use Webauthn\AttestationStatement\AttestationStatementSupportManager;
use Webauthn\AttestationStatement\NoneAttestationStatementSupport;
use Webauthn\CeremonyStep\CeremonyStepManagerFactory;
use Webauthn\Denormalizer\WebauthnSerializerFactory;
class AuthServiceProvider extends ServiceProvider
{
    public function register()
    {
        $this-&gt;app-&gt;scoped(CeremonyStepManagerFactory::class, function () {
            $csm = new CeremonyStepManagerFactory();
            $csm-&gt;setCounterChecker(new CounterChecker());
            return $csm;
        });
        $this-&gt;app-&gt;scoped(WebauthnService::class, function () {
            $attestationStatementSupportManager = AttestationStatementSupportManager::create();
            $attestationStatementSupportManager-&gt;add(NoneAttestationStatementSupport::create());
            $factory = new WebauthnSerializerFactory($attestationStatementSupportManager);
            $webauthnSerializer = $factory-&gt;create();
            return new WebauthnService($attestationStatementSupportManager, $webauthnSerializer);
        });
    }
    public function boot(): void
    {
        Passport::withCookieEncryption();
        Sanctum::usePersonalAccessTokenModel(PersonalAccessToken::class);
        Gate::define(&apos;viewApiDoc&apos;, function ($user) {
            return $user-&gt;isAdmin();
        });
        Gate::define(&apos;viewDashboard&apos;, function ($user) {
            return $user-&gt;isAdmin();
        });
        Gate::define(&apos;executeJob&apos;, function ($user) {
            return $user-&gt;isAdmin();
        });
    }
}</file><file path="docker-compose.yml">services:
  nginx:
    image: martinjuul/baander-nginx:latest
    container_name: baander-nginx
    build:
      context: ./docker/
      args:
        BUILD_ARGUMENT_ENV: dev
      dockerfile: ./nginx/Dockerfile
    restart: unless-stopped
    ports:
      - &quot;${WEB_PORT_HTTP}:80&quot;
      - &quot;${WEB_PORT_TLS}:443&quot;
    networks:
      - baander-backtier
    volumes:
      - ./:/var/www/html:ro,cached
      - ./docker/dev/nginx.conf:/etc/nginx/conf.d/default.conf:ro
      - ./cert.pem:/etc/nginx/certificates/cert.pem:ro
      - ./key.pem:/etc/nginx/certificates/key.pem:ro
    depends_on:
      - app
  app:
    image: martinjuul/baander-app:latest
    container_name: baander-app
    build:
      context: .
      args:
        BUILD_ARGUMENT_ENV: dev
        HOST_UID: ${HOST_UID}
        HOST_GID: ${HOST_GID}
        XDEBUG_CONFIG: ${XDEBUG_CONFIG}
        XDEBUG_VERSION: ${XDEBUG_VERSION}
      dockerfile: ./Dockerfile
    ulimits:
      nofile:
        soft: 10000
        hard: 10000
    extra_hosts:
      - &apos;host.docker.internal:host-gateway&apos;
    volumes:
      - /mnt/c/baander-library:/storage/baander-library
      - ./:/var/www/html:cached
      - ./docker/general/supervisord.conf:/etc/supervisor/conf.d/supervisord.conf:ro
    networks:
      - baander-backtier
#    environment:
#      - ELASTIC_APM_SERVER_URL=https://192.168.50.151:8200
#      - ELASTIC_APM_SERVICE_NAME=baander
#      - ELASTIC_APM_VERIFY_SERVER_CERT=false
#      - ELASTIC_APM_SECRET_TOKEN=jPEaWP9B6JqXPNVJ
  postgres:
    image: postgres:17.5-bookworm
    container_name: baander-postgres
    restart: unless-stopped
    networks:
      - baander-backtier
    ports:
      - &quot;127.0.0.1:5432:5432&quot;
    shm_size: 128mb
    environment:
      POSTGRES_USER: ${DB_USERNAME}
      POSTGRES_PASSWORD: ${DB_PASSWORD}
  redis:
    image: redis/redis-stack-server:edge
    container_name: baander-redis
    restart: unless-stopped
    networks:
      - baander-backtier
    ports:
      - &quot;127.0.0.1:6379:6379&quot;
  buggregator:
    image: ghcr.io/buggregator/server:latest
    container_name: baander-buggregator
    restart: unless-stopped
    networks:
      - baander-backtier
    ports:
      - &quot;127.0.0.1:8000:8000&quot;
      - &quot;127.0.0.1:1025:1025&quot;
      - &quot;127.0.0.1:9912:9912&quot;
      - &quot;127.0.0.1:9913:9913&quot;
networks:
  baander-backtier:
    name: baander-backtier
    external: true</file><file path="resources/app/store/index.ts">import { Action, combineSlices, configureStore, ThunkAction } from &apos;@reduxjs/toolkit&apos;;
import { persistReducer, persistStore } from &apos;redux-persist&apos;;
import storage from &apos;redux-persist/lib/storage&apos;;
import { authSlice } from &apos;@/store/users/auth-slice.ts&apos;;
import { equalizerSlice } from &apos;@/store/audio/equalizer.ts&apos;;
import { musicPlayerSlice } from &apos;@/store/music/music-player-slice.ts&apos;;
import { notificationsSlice } from &apos;@/store/notifications/notifications-slice.ts&apos;;
import { uiSlice } from &apos;@/store/users/ui-slice.ts&apos;;
const rootReducer = combineSlices(
  authSlice,
  equalizerSlice,
  musicPlayerSlice,
  notificationsSlice,
  uiSlice,
);
export type RootState = ReturnType&lt;typeof rootReducer&gt;
const persistConfig = {
  key: &apos;root&apos;,
  storage,
};
const persistedReducer = persistReducer(persistConfig, rootReducer);// as unknown as typeof rootReducer;
export const makeStore = () =&gt; {
  const store = configureStore({
    devTools: true,
    reducer: persistedReducer,
    middleware: (getDefaultMiddleware) =&gt;
      getDefaultMiddleware({
        serializableCheck: false,
      }),
  });
  return store;
};
export const store = makeStore();
export const persistor = persistStore(store);
// Infer the type of `store`
export type AppStore = typeof store
// Infer the `AppDispatch` type from the store itself
export type AppDispatch = AppStore[&quot;dispatch&quot;]
export type AppThunk&lt;ThunkReturnType = void&gt; = ThunkAction&lt;
  ThunkReturnType,
  RootState,
  unknown,
  Action
&gt;</file><file path="vite.config.mts">import { defineConfig, loadEnv } from &apos;vite&apos;;
import laravel from &apos;laravel-vite-plugin&apos;;
import { fileURLToPath } from &apos;url&apos;;
import { resolve } from &apos;path&apos;;
import richSvg from &apos;vite-plugin-react-rich-svg&apos;;
import manifestSRI from &apos;vite-plugin-manifest-sri&apos;;
import filterReplace from &apos;vite-plugin-filter-replace&apos;;
import react from &apos;@vitejs/plugin-react&apos;;
import { optimizeCssModules } from &apos;vite-plugin-optimize-css-modules&apos;;
import Info from &apos;unplugin-info/vite&apos;;
import { visualizer } from &apos;rollup-plugin-visualizer&apos;;
import laravelTranslations from &apos;vite-plugin-laravel-translations&apos;;

const ReactCompilerConfig = {};

const lottieScopeVariables = [
  &apos;value&apos;,
  &apos;content&apos;,
  &apos;loopOut&apos;,
  &apos;numKeys&apos;,
  &apos;$bm_mul&apos;,
  &apos;$bm_sum&apos;,
  &apos;$bm_sub&apos;,
  &apos;$bm_div&apos;,
  &apos;$bm_mod&apos;,
  &apos;$bm_isInstanceOfArray&apos;,
  &apos;$bm_transform&apos;,
  &apos;anchorPoint&apos;,
  &apos;time&apos;,
  &apos;velocity&apos;,
  &apos;inPoint&apos;,
  &apos;outPoint&apos;,
  &apos;width&apos;,
  &apos;height&apos;,
  &apos;name&apos;,
  &apos;loop_in&apos;,
  &apos;loop_out&apos;,
  &apos;smooth&apos;,
  &apos;toComp&apos;,
  &apos;fromCompToSurface&apos;,
  &apos;toWorld&apos;,
  &apos;fromWorld&apos;,
  &apos;mask&apos;,
  &apos;position&apos;,
  &apos;rotation&apos;,
  &apos;scale&apos;,
  &apos;thisComp&apos;,
  &apos;active&apos;,
  &apos;wiggle&apos;,
  &apos;loopInDuration&apos;,
  &apos;loopOutDuration&apos;,
  &apos;comp&apos;,
  &apos;lookAt&apos;,
  &apos;easeOut&apos;,
  &apos;easeIn&apos;,
  &apos;ease&apos;,
  &apos;nearestKey&apos;,
  &apos;key&apos;,
  &apos;text&apos;,
  &apos;textIndex&apos;,
  &apos;textTotal&apos;,
  &apos;selectorValue&apos;,
  &apos;framesToTime&apos;,
  &apos;timeToFrames&apos;,
  &apos;sourceRectAtTime&apos;,
  &apos;substring&apos;,
  &apos;substr&apos;,
  &apos;posterizeTime&apos;,
  &apos;index&apos;,
  &apos;globalData&apos;,
  &apos;frames&apos;,
  &apos;$bm_neg&apos;,
  &apos;add&apos;,
  &apos;clamp&apos;,
  &apos;radians_to_degrees&apos;,
  &apos;degreesToRadians&apos;,
  &apos;degrees_to_radians&apos;,
  &apos;normalize&apos;,
  &apos;rgbToHsl&apos;,
  &apos;hslToRgb&apos;,
  &apos;linear&apos;,
  &apos;random&apos;,
  &apos;createPath&apos;,
  &apos;_lottieGlobal&apos;,
  &apos;transform&apos;,
  &apos;effect&apos;,
  &apos;thisProperty&apos;,
  &apos;loopIn&apos;,
  &apos;fromComp&apos;,
  &apos;thisLayer&apos;,
  &apos;valueAtTime&apos;,
  &apos;velocityAtTime&apos;,
];

// https://vitejs.dev/config/
export default defineConfig(config =&gt; {

  // Load env file based on `mode` in the current working directory.
  // https://main.vitejs.dev/config/#using-environment-variables-in-config
  const env = loadEnv(config.mode, process.cwd(), &apos;&apos;);

  return {
    define: {
      __APP_ENV__: JSON.stringify(env.APP_ENV),
    },
    server: {
      port: 3000,
    },
    build: {
      sourcemap: false,
      target: [&apos;chrome128&apos;, &apos;firefox128&apos;, &apos;safari16&apos;, &apos;esnext&apos;],
      rollupOptions: {
        treeshake: true,
      },
    },
    plugins: [
      laravel({
        input: [
          &apos;resources/app/index.tsx&apos;,
        ],
        refresh: true,
      }),
      react({
        babel: {
          plugins: [[&apos;babel-plugin-react-compiler&apos;, ReactCompilerConfig]],
        },
      }),
      laravelTranslations({ namespace: &apos;translation&apos; }),
      visualizer({ open: false, template: &apos;flamegraph&apos;, filename: &apos;bundle-visualization.html&apos; }),
      optimizeCssModules(),
      Info(),
      richSvg(),
      manifestSRI(),
      // workaround for a warning with lottie https://github.com/airbnb/lottie-web/issues/2927
      filterReplace([
        {
          filter: [&apos;node_modules/lottie-web/build/player/lottie.js&apos;],
          replace: {
            from: &apos;eval(\&apos;[function _expression_function(){\&apos; + val + \&apos;;scoped_bm_rt=$bm_rt}]\&apos;)[0]&apos;,
            to: `
          function _expression_function() {
            var valToEval = val;
            scoped_bm_rt = (new Function(
              &apos;valToEval&apos;, ${lottieScopeVariables.map((v) =&gt; `&apos;${v}&apos;`).join(&apos;,&apos;)},
              &apos;try {&apos;
                + val + \`;
                return $bm_rt;
              } catch (e) {
                console.error(&quot;Error in lottie-web workaround. Fix the issue in vite.config.ts:&quot;, e, &quot;Failed expression:&quot;, valToEval);
                throw e;
              }\`
            ))(valToEval, ${lottieScopeVariables.join(&apos;,&apos;)});
          }`,
          },
        },
      ]),
      // inspect(),
    ],
    resolve: {
      alias: {
        // for TypeScript path alias import like : @/x/y/z
        &apos;@&apos;: fileURLToPath(new URL(&apos;./resources/app&apos;, import.meta.url)),
        &apos;ziggy-js&apos;: resolve(&apos;vendor/tightenco/ziggy&apos;),
      },
    },
    css: {
      preprocessorOptions: {
        scss: {
          api: &apos;modern-compiler&apos;,
        },
      },
    },
  };
});</file><file path="app/Http/Controllers/Api/AlbumController.php">&lt;?php
namespace App\Http\Controllers\Api;
use App\Http\Controllers\Controller;
use App\Http\Requests\Album\AlbumIndexRequest;
use App\Http\Resources\Album\AlbumResource;
use App\Models\{Album, Library, TokenAbility};
use App\Modules\{Pagination\JsonPaginator};
use App\Modules\Eloquent\BaseBuilder;
use Illuminate\Http\Resources\Json\AnonymousResourceCollection;
use Spatie\RouteAttributes\Attributes\{Get, Middleware, Prefix};
#[Prefix(&apos;/libraries/{library}/albums&apos;)]
#[Middleware([
    &apos;auth:sanctum&apos;,
    &apos;ability:&apos; . TokenAbility::ACCESS_API-&gt;value,
    &apos;force.json&apos;,
])]
class AlbumController extends Controller
{
    /**
     * Get a collection of albums
     *
     * @param Library $library
     * @param AlbumIndexRequest $request
     * @return AnonymousResourceCollection&lt;JsonPaginator&lt;AlbumResource&gt;&gt;
     */
    #[Get(&apos;/&apos;, &apos;api.albums.index&apos;)]
    public function index(Library $library, AlbumIndexRequest $request)
    {
        $fields = $request-&gt;query(&apos;fields&apos;);
        $relations = $request-&gt;query(&apos;relations&apos;);
        $genres = $request-&gt;query(&apos;genres&apos;);
        $albums = Album::query()
            -&gt;selectFields(Album::$filterFields, $fields)
            -&gt;withRelations(Album::$filterRelations, $relations)
            -&gt;when($relations, function (BaseBuilder $q) use ($relations) {
                return $q-&gt;with(explode(&apos;,&apos;, $relations));
            })-&gt;when($fields, function (BaseBuilder $query) use ($fields) {
                $fields = array_merge(explode(&apos;,&apos;, $fields));
                return $query-&gt;select($fields);
            })-&gt;when($genres, function (BaseBuilder $q) use ($genres) {
                $q-&gt;whereGenreNames($genres);
            })
            -&gt;paginate();
        $albums-&gt;each(function (Album $album) use ($library) {
            $album-&gt;setRelation(&apos;library&apos;, $library);
        });
        return AlbumResource::collection($albums);
    }
    /**
     * Get an album
     *
     * @param Library $library
     * @param Album $album
     * @return AlbumResource
     */
    #[Get(&apos;{album}&apos;, &apos;api.albums.show&apos;)]
    public function show(Library $library, Album $album)
    {
        $album-&gt;setRelation(&apos;library&apos;, $library);
        $album-&gt;loadMissing([&apos;artists&apos;, &apos;cover&apos;, &apos;songs&apos;]);
        return new AlbumResource($album);
    }
}</file><file path="app/Http/Controllers/Api/LibraryController.php">&lt;?php
namespace App\Http\Controllers\Api;
use App\Http\Controllers\Controller;
use App\Http\Requests\Library\{CreateLibraryRequest, LibraryIndexRequest, UpdateLibraryRequest};
use App\Http\Resources\Library\LibraryResource;
use App\Models\{Library, TokenAbility};
use App\Modules\Pagination\JsonPaginator;
use Illuminate\Http\Resources\Json\AnonymousResourceCollection;
use Illuminate\Http\Response;
use Spatie\RouteAttributes\Attributes\{Delete, Get, Middleware, Patch, Post, Prefix};
#[Prefix(&apos;/libraries&apos;)]
#[Middleware([
    &apos;auth:sanctum&apos;,
    &apos;ability:&apos; . TokenAbility::ACCESS_API-&gt;value,
    &apos;force.json&apos;,
])]
class LibraryController extends Controller
{
    /**
     * Get a collection of media libraries
     *
     * @return AnonymousResourceCollection&lt;JsonPaginator&lt;LibraryResource&gt;&gt;
     */
    #[Get(&apos;/&apos;, &apos;api.libraries.index&apos;)]
    public function index(LibraryIndexRequest $request)
    {
        $libraries = Library::paginate();
        return LibraryResource::collection($libraries);
    }
    /**
     * Create a library
     */
    #[Post(&apos;/&apos;, &apos;api.library.create&apos;)]
    public function create(CreateLibraryRequest $request)
    {
        $data = $request-&gt;validated();
        $library = Library::create($data);
        return new LibraryResource($library);
    }
    /**
     * Show library
     *
     * @param string $slug
     * @return LibraryResource
     */
    #[Get(&apos;/{slug}&apos;, &apos;api.library.show&apos;)]
    public function show(string $slug)
    {
        $library = Library::whereSlug($slug)-&gt;firstOrFail();
        return new LibraryResource($library);
    }
    /**
     * Update a library specified by the provided slug.
     */
    #[Patch(&apos;/{slug}&apos;, &apos;api.library.update&apos;)]
    public function update(string $slug, UpdateLibraryRequest $request)
    {
        $library = Library::whereSlug($slug)-&gt;firstOrFail();
        $library-&gt;update($request-&gt;validated());
        return new LibraryResource($library);
    }
    /**
     * Delete a library
     */
    #[Delete(&apos;/{slug}&apos;, &apos;api.library.delete&apos;)]
    public function destroy(string $slug)
    {
        Library::whereSlug($slug)-&gt;delete();
        return response(null, Response::HTTP_NO_CONTENT);
    }
}</file><file path="app/Models/User.php">&lt;?php
namespace App\Models;
use App\Auth\Role;
use App\Modules\Webauthn\Concerns\HasPasskeys;
use DateTimeInterface;
use Illuminate\Database\Eloquent\Factories\HasFactory;
use Illuminate\Database\Eloquent\Relations\HasMany;
use Illuminate\Foundation\Auth\User as Authenticatable;
use Illuminate\Notifications\Notifiable;
use Illuminate\Support\Str;
use Laravel\Fortify\TwoFactorAuthenticatable;
use Laravel\Sanctum\{HasApiTokens, NewAccessToken};
use Ramsey\Uuid\Uuid;
use Spatie\Permission\Traits\HasRoles;
class User extends Authenticatable implements HasPasskeys
{
    use HasFactory,
        HasApiTokens,
        HasRoles,
        Notifiable,
        TwoFactorAuthenticatable;
    protected $dateFormat = &apos;Y-m-d H:i:sO&apos;;
    /**
     * The attributes that are mass assignable.
     *
     * @var array&lt;int, string&gt;
     */
    protected $fillable = [
        &apos;name&apos;,
        &apos;email&apos;,
        &apos;password&apos;,
    ];
    /**
     * The attributes that should be hidden for serialization.
     *
     * @var array&lt;int, string&gt;
     */
    protected $hidden = [
        &apos;password&apos;,
        &apos;remember_token&apos;,
    ];
    /**
     * The attributes that should be cast.
     *
     * @var array&lt;string, string&gt;
     */
    protected $casts = [
        &apos;email_verified_at&apos; =&gt; &apos;datetime&apos;,
        &apos;password&apos;          =&gt; &apos;hashed&apos;,
    ];
    /**
     * Create a new personal access token for the user.
     *
     * @param string $name
     * @param array $abilities
     * @param \DateTimeInterface|null $expiresAt
     * @param array $device
     * @return NewAccessToken
     */
    public function createToken(string $name, array $abilities = [&apos;*&apos;], ?DateTimeInterface $expiresAt = null, array $device = [])
    {
        $plainTextToken = $this-&gt;generateTokenString();
        $broadcastToken = Str::replace(&apos;-&apos;, &apos;&apos;, Uuid::uuid4()-&gt;toString());
        $attributes = [
            &apos;name&apos;            =&gt; $name,
            &apos;token&apos;           =&gt; hash(&apos;sha256&apos;, $plainTextToken),
            &apos;broadcast_token&apos; =&gt; $broadcastToken,
            &apos;abilities&apos;       =&gt; $abilities,
            &apos;expires_at&apos;      =&gt; $expiresAt,
        ];
        $attributes += $device;
        $token = $this-&gt;tokens()-&gt;create($attributes);
        return new NewAccessToken($token, $token-&gt;getKey() . &apos;|&apos; . $plainTextToken);
    }
    protected function getDefaultGuardName(): string
    {
        return &apos;web&apos;;
    }
    public function isAdmin()
    {
        return $this-&gt;hasRole(Role::Admin-&gt;value);
    }
    public function accessibleLibraries()
    {
        return $this-&gt;belongsToMany(Library::class)
            -&gt;using(UserLibrary::class);
    }
    public function userMediaActivities()
    {
        return $this-&gt;hasMany(UserMediaActivity::class);
    }
    public function passkeys(): HasMany
    {
        return $this-&gt;hasMany(Passkey::class);
    }
    public function getPassKeyName(): string
    {
        return $this-&gt;email;
    }
    public function getPassKeyId(): string
    {
        return $this-&gt;id;
    }
    public function getPassKeyDisplayName(): string
    {
        return $this-&gt;name;
    }
}</file><file path="config/app.php">&lt;?php
use Illuminate\Support\Facades\Facade;
use Illuminate\Support\ServiceProvider;
return [
    /*
    |--------------------------------------------------------------------------
    | Application Name
    |--------------------------------------------------------------------------
    |
    | This value is the name of your application. This value is used when the
    | framework needs to place the application&apos;s name in a notification or
    | any other location as required by the application or its packages.
    |
    */
    &apos;name&apos; =&gt; env(&apos;APP_NAME&apos;, &apos;baander&apos;),
    /*
    |--------------------------------------------------------------------------
    | Application Environment
    |--------------------------------------------------------------------------
    |
    | This value determines the &quot;environment&quot; your application is currently
    | running in. This may determine how you prefer to configure various
    | services the application utilizes. Set this in your &quot;.env&quot; file.
    |
    */
    &apos;env&apos; =&gt; env(&apos;APP_ENV&apos;, &apos;production&apos;),
    /*
    |--------------------------------------------------------------------------
    | Application Debug Mode
    |--------------------------------------------------------------------------
    |
    | When your application is in debug mode, detailed error messages with
    | stack traces will be shown on every error that occurs within your
    | application. If disabled, a simple generic error page is shown.
    |
    */
    &apos;debug&apos; =&gt; (bool)env(&apos;APP_DEBUG&apos;, false),
    /*
    |--------------------------------------------------------------------------
    | Application URL
    |--------------------------------------------------------------------------
    |
    | This URL is used by the console to properly generate URLs when using
    | the Artisan command line tool. You should set this to the root of
    | your application so that it is used when running Artisan tasks.
    |
    */
    &apos;url&apos;       =&gt; env(&apos;APP_URL&apos;, &apos;http://localhost&apos;),
    &apos;asset_url&apos; =&gt; env(&apos;ASSET_URL&apos;),
    /*
    |--------------------------------------------------------------------------
    | Application Timezone
    |--------------------------------------------------------------------------
    |
    | Here you may specify the default timezone for your application, which
    | will be used by the PHP date and date-time functions. We have gone
    | ahead and set this to a sensible default for you out of the box.
    |
    */
    &apos;timezone&apos; =&gt; &apos;UTC&apos;,
    /*
    |--------------------------------------------------------------------------
    | Application Locale Configuration
    |--------------------------------------------------------------------------
    |
    | The application locale determines the default locale that will be used
    | by the translation service provider. You are free to set this value
    | to any of the locales which will be supported by the application.
    |
    */
    &apos;locale&apos; =&gt; &apos;en&apos;,
    /*
    |--------------------------------------------------------------------------
    | Application Fallback Locale
    |--------------------------------------------------------------------------
    |
    | The fallback locale determines the locale to use when the current one
    | is not available. You may change the value to correspond to any of
    | the language folders that are provided through your application.
    |
    */
    &apos;fallback_locale&apos; =&gt; &apos;en&apos;,
    /*
    |--------------------------------------------------------------------------
    | Faker Locale
    |--------------------------------------------------------------------------
    |
    | This locale will be used by the Faker PHP library when generating fake
    | data for your database seeds. For example, this will be used to get
    | localized telephone numbers, street address information and more.
    |
    */
    &apos;faker_locale&apos; =&gt; &apos;en_US&apos;,
    /*
    |--------------------------------------------------------------------------
    | Encryption Key
    |--------------------------------------------------------------------------
    |
    | This key is utilized by Laravel&apos;s encryption services and should be set
    | to a random, 32 character string to ensure that all encrypted values
    | are secure. You should do this prior to deploying the application.
    |
    */
    &apos;cipher&apos; =&gt; &apos;AES-256-CBC&apos;,
    &apos;key&apos; =&gt; env(&apos;APP_KEY&apos;),
    &apos;previous_keys&apos; =&gt; [
        ...array_filter(
            explode(&apos;,&apos;, env(&apos;APP_PREVIOUS_KEYS&apos;, &apos;&apos;)),
        ),
    ],
    /*
    |--------------------------------------------------------------------------
    | Maintenance Mode Driver
    |--------------------------------------------------------------------------
    |
    | These configuration options determine the driver used to determine and
    | manage Laravel&apos;s &quot;maintenance mode&quot; status. The &quot;cache&quot; driver will
    | allow maintenance mode to be controlled across multiple machines.
    |
    | Supported drivers: &quot;file&quot;, &quot;cache&quot;
    |
    */
    &apos;maintenance&apos; =&gt; [
        &apos;driver&apos; =&gt; &apos;file&apos;,
        // &apos;store&apos; =&gt; &apos;redis&apos;,
    ],
    &apos;csp&apos; =&gt; [
        &apos;disable_paths&apos; =&gt; [
            &apos;docs&apos;,
            &apos;system/log-viewer&apos;,
        ],
    ],
    /*
    |--------------------------------------------------------------------------
    | Autoloaded Service Providers
    |--------------------------------------------------------------------------
    |
    | The service providers listed here will be automatically loaded on the
    | request to your application. Feel free to add your own services to
    | this array to grant expanded functionality to your applications.
    |
    */
    &apos;providers&apos; =&gt; ServiceProvider::defaultProviders()-&gt;merge([
        /*
         * Package Service Providers...
         */
        App\Modules\DeviceDetector\DeviceDetectorServiceProvider::class,
        App\Modules\Nanoid\NanoIdServiceProvider::class,
        App\Modules\BlurHash\BlurHashServiceProvider::class,
        App\Providers\FortifyServiceProvider::class,
        /*
         * Application Service Providers...
         */
        App\Providers\AppServiceProvider::class,
        App\Modules\Apm\ElasticApmAgentServiceProvider::class,
        App\Providers\LogConfigurationServiceProvider::class,
        App\Providers\AuthServiceProvider::class,
        App\Providers\BroadcastServiceProvider::class,
        App\Providers\EventServiceProvider::class,
        App\Providers\QueueMonitorProvider::class,
        App\Providers\HorizonServiceProvider::class,
        App\Providers\RouteServiceProvider::class,
        App\Providers\ScrambleServiceProvider::class,
        App\Providers\RecommendationServiceProvider::class,
    ])-&gt;toArray(),
    /*
    |--------------------------------------------------------------------------
    | Class Aliases
    |--------------------------------------------------------------------------
    |
    | This array of class aliases will be registered when this application
    | is started. However, feel free to register as many as you wish as
    | the aliases are &quot;lazy&quot; loaded so they don&apos;t hinder performance.
    |
    */
    &apos;aliases&apos; =&gt; Facade::defaultAliases()-&gt;merge([
        &apos;Apm&apos; =&gt; App\Modules\Apm\Apm::class,
    ])-&gt;toArray(),
];</file><file path="resources/app/index.tsx">import &apos;./services/apm.ts&apos;
import React from &apos;react&apos;;
import ReactDOM from &apos;react-dom/client&apos;;
import App from &apos;./App&apos;;
import { Provider } from &apos;react-redux&apos;;
import { store } from &apos;@/store&apos;;
import &apos;./index.css&apos;;
import { PersistQueryClientProvider } from &apos;@tanstack/react-query-persist-client&apos;;
// @ts-ignore
import { Ziggy } from &apos;./ziggy.js&apos;;
import &apos;./bootstrap.ts&apos;;
import &apos;./common/i18n.ts&apos;;
import { DateFormatterProvider } from &apos;@/providers/dayjs-provider.tsx&apos;;
import { createIDBPersister, queryClient } from &apos;@/common/react-query.ts&apos;;
import { RadixProvider } from &apos;@/providers/radix-provider.tsx&apos;;
import { Reset } from &apos;@radix-ui/themes&apos;;
import { TestModeProvider } from &apos;@/providers/test-mode-provider.tsx&apos;;
// @ts-ignore
globalThis.Ziggy = Ziggy;
const reactQueryPersister = createIDBPersister();
ReactDOM.createRoot(document.getElementById(&apos;baanderapproot&apos;) as HTMLElement).render(
  &lt;React.StrictMode&gt;
    &lt;TestModeProvider&gt;
      &lt;PersistQueryClientProvider
        client={queryClient}
        persistOptions={{ buster: &apos;baander&apos;, persister: reactQueryPersister }}
      &gt;
        &lt;Provider store={store}&gt;
          &lt;DateFormatterProvider&gt;
            &lt;RadixProvider&gt;
              &lt;Reset&gt;
                &lt;App/&gt;
              &lt;/Reset&gt;
            &lt;/RadixProvider&gt;
          &lt;/DateFormatterProvider&gt;
        &lt;/Provider&gt;
      &lt;/PersistQueryClientProvider&gt;
    &lt;/TestModeProvider&gt;
  &lt;/React.StrictMode&gt;,
);</file><file path="app/Http/Controllers/Api/SongController.php">&lt;?php
namespace App\Http\Controllers\Api;
use App\Http\Controllers\Controller;
use App\Http\Requests\Song\{SongIndexRequest, SongShowRequest};
use App\Http\Resources\Song\SongResource;
use App\Models\{Album, Library, Song, TokenAbility};
use App\Modules\{Pagination\JsonPaginator};
use App\Modules\Http\Resources\Json\JsonAnonymousResourceCollection;
use Spatie\RouteAttributes\Attributes\{Get, Middleware, Prefix};
use Symfony\Component\HttpFoundation\BinaryFileResponse;
#[Middleware([&apos;force.json&apos;])]
#[Prefix(&apos;/libraries/{library}/songs&apos;)]
class SongController extends Controller
{
    /**
     * Get a collection of songs
     *
     * @param SongIndexRequest $request
     * @param Library $library
     * @param Album $album
     * @return JsonAnonymousResourceCollection&lt;JsonPaginator&lt;SongResource&gt;&gt;
     */
    #[Get(&apos;&apos;, &apos;api.songs.index&apos;, [&apos;auth:sanctum&apos;, &apos;ability:&apos; . TokenAbility::ACCESS_API-&gt;value])]
    public function index(SongIndexRequest $request, Library $library)
    {
        $relations = $request-&gt;query(&apos;relations&apos;);
        $genreNames = $request-&gt;query(&apos;genreNames&apos;);
        $genreSlugs = $request-&gt;query(&apos;genreSlugs&apos;);
        abort_if(
            $genreNames &amp;&amp; $genreSlugs,
            400,
            &apos;You cannot search for genre names and slugs at the same time&apos;,
        );
        $songs = Song::query()
            -&gt;withRelations(Song::$filterRelations, $relations)
            -&gt;when($genreSlugs, function ($query) use ($library, $genreSlugs) {
                return $query-&gt;whereGenreSlugs($genreSlugs);
            })-&gt;when($genreNames, function ($query) use ($library, $genreNames) {
                return $query-&gt;whereGenreNames($genreNames);
            })
            -&gt;orderBy(Album::select(&apos;title&apos;)-&gt;whereColumn(&apos;songs.album_id&apos;, &apos;albums.id&apos;))
            -&gt;orderBy(&apos;track&apos;)
            -&gt;paginate();
        $songs-&gt;each(function (Song $song) use ($library) {
            $song-&gt;librarySlug = $library-&gt;slug;
        });
        return SongResource::collection($songs);
    }
    /**
     * Get a song by public id
     *
     * @param SongShowRequest $request
     * @param Library $library
     * @param string $publicId
     * @return SongResource
     */
    #[Get(&apos;{publicId}&apos;, &apos;api.songs.show&apos;, [&apos;auth:sanctum&apos;, &apos;ability:&apos; . TokenAbility::ACCESS_API-&gt;value])]
    public function show(SongShowRequest $request, Library $library, string $publicId)
    {
        $relations = $request-&gt;query(&apos;relations&apos;);
        $song = Song::query()-&gt;wherePublicId($publicId)
            -&gt;withRelations(Song::$filterRelations, $relations)
            -&gt;firstOrFail();
        $song-&gt;librarySlug = $library-&gt;slug;
        return new SongResource($song);
    }
}</file><file path="app/Http/Controllers/UIController.php">&lt;?php
namespace App\Http\Controllers;
use App\Baander;
use App\Models\Album;
use App\Models\Song;
use App\Modules\MediaMeta\MediaMeta;
class UIController
{
    public function getUI()
    {
        return view(&apos;app&apos;, [
            &apos;appInfo&apos; =&gt; Baander::getAppInfo(),
        ]);
    }
    public function dbg()
    {
        $data = Song::find(1);
        $rec = $data-&gt;getRecommendations(&apos;same_genre&apos;);
        dd([
            &apos;song&apos; =&gt; $data-&gt;toArray(),
            &apos;recom&apos; =&gt; $rec-&gt;each(fn($a) =&gt; $a-&gt;get(&apos;title&apos;))-&gt;toArray(),
        ]);
    }
}</file><file path="app/Providers/AppServiceProvider.php">&lt;?php
namespace App\Providers;
use App\Baander;
use App\Http\Integrations\Transcoder\TranscoderClient;
use App\Repositories\Cache\CacheRepositoryInterface;
use App\Repositories\Cache\LaravelCacheRepository;
use Ergebnis\Clock\SystemClock;
use GuzzleHttp\Client;
use Illuminate\Foundation\Application;
use Illuminate\Http\Resources\Json\JsonResource;
use Illuminate\Support\Facades\URL;
use Illuminate\Support\ServiceProvider;
use Intervention\Image\Drivers\Gd\Driver;
use Intervention\Image\ImageManager;
use MusicBrainz\HttpAdapter\GuzzleHttpAdapter;
use MusicBrainz\MusicBrainz;
use Psr\Log\LoggerInterface;
class AppServiceProvider extends ServiceProvider
{
    /**
     * Register any application services.
     */
    public function register(): void
    {
        $this-&gt;app-&gt;scoped(SystemClock::class, function () {
            $timeZone = new \DateTimeZone(config(&apos;app.timezone&apos;));
            return new SystemClock($timeZone);
        });
        $this-&gt;app-&gt;scoped(CacheRepositoryInterface::class, LaravelCacheRepository::class);
        $this-&gt;app-&gt;scoped(ImageManager::class, function () {
            return new ImageManager(new Driver());
        });
        $this-&gt;app-&gt;scoped(MusicBrainz::class, function (Application $app) {
            $guzzle = new GuzzleHttpAdapter(new Client());
            $musicBrainz = new MusicBrainz($guzzle, $app-&gt;get(LoggerInterface::class)-&gt;channel(&apos;buggregator&apos;));
            $musicBrainz-&gt;config()
                -&gt;setUserAgent(&apos;Baander server/&apos; . Baander::VERSION);
            return $musicBrainz;
        });
        $this-&gt;app-&gt;scoped(TranscoderClient::class, function (Application $app) {
            $guzzle = new Client();
            return new TranscoderClient(
                client: $guzzle,
                baseUrl: &apos;http://&apos; . config(&apos;transcoder.host&apos;) . &apos;:&apos; . config(&apos;transcoder.port&apos;),
            );
        });
    }
    /**
     * Bootstrap any application services.
     */
    public function boot(): void
    {
        JsonResource::withoutWrapping();
        JsonResource::macro(&apos;paginationInformation&apos;, function ($request, $paginated, $default) {
            unset($default[&apos;links&apos;]);
            return $default;
        });
        URL::forceScheme(&apos;https&apos;);
    }
}</file><file path="Dockerfile">FROM php:bookworm

COPY --from=martinjuul/ffmpeg-baander-static /usr/src/ffmpeg-build-script/workspace/bin/ffmpeg /bin/ffmpeg
COPY --from=martinjuul/ffmpeg-baander-static /usr/src/ffmpeg-build-script/workspace/bin/ffprobe /bin/ffprobe
COPY --from=martinjuul/ffmpeg-baander-static /usr/src/ffmpeg-build-script/workspace/bin/ffplay /bin/ffplay

# set main params
ARG BUILD_ARGUMENT_ENV=dev
ENV ENV=$BUILD_ARGUMENT_ENV
ENV APP_HOME /var/www/html
ARG HOST_UID=1000
ARG HOST_GID=1000
ENV USERNAME=www-data
ARG INSIDE_DOCKER_CONTAINER=1
ENV INSIDE_DOCKER_CONTAINER=$INSIDE_DOCKER_CONTAINER
ARG XDEBUG_CONFIG=main
ENV XDEBUG_CONFIG=$XDEBUG_CONFIG
ARG XDEBUG_VERSION=3.4.3
ENV XDEBUG_VERSION=$XDEBUG_VERSION

# Check environment
RUN set -xe &amp;&amp; \
    if [ &quot;${BUILD_ARGUMENT_ENV}&quot; = &quot;default&quot; ]; then echo &quot;Set BUILD_ARGUMENT_ENV in docker build-args like --build-arg BUILD_ARGUMENT_ENV=dev&quot; &amp;&amp; exit 2; \
    elif [ &quot;${BUILD_ARGUMENT_ENV}&quot; = &quot;dev&quot; ]; then echo &quot;Building development environment.&quot;; \
    else echo &quot;Set correct BUILD_ARGUMENT_ENV in docker build-args like --build-arg BUILD_ARGUMENT_ENV=dev. Available choices are dev&quot; &amp;&amp; exit 2; \
    fi

# Install all the dependencies and enable PHP modules
RUN set -xe \
    &amp;&amp; curl -sL https://deb.nodesource.com/setup_22.x  | bash - \
    &amp;&amp; DEBIAN_FRONTEND=noninteractive apt-get update -qq \
    &amp;&amp; DEBIAN_FRONTEND=noninteractive apt-get upgrade -yqq \
    &amp;&amp; DEBIAN_FRONTEND=noninteractive apt-get install -yqq -o=Dpkg::Use-Pty=0 \
      ca-certificates \
      cron \
      curl \
      wget \
      git \
      nano \
      nodejs \
      procps \
      sudo \
      supervisor \
      unzip \
      iputils-ping \
      libavif-dev \
      libbz2-dev \
      libc-ares-dev \
      libcurl4-openssl-dev \
      libfreetype6-dev \
      libicu-dev \
      libjpeg-dev \
      libjpeg62-turbo-dev \
      liblz4-dev \
      libmagickwand-dev \
      libpng-dev \
      libpq-dev \
      libreadline-dev \
      libsqlite3-dev \
      libssh2-1-dev \
      libwebp-dev \
      libxml2-dev \
      libxpm-dev \
      libzip-dev \
      libzstd-dev \
      libyaml-dev \
      libuv1-dev \
      zlib1g-dev

RUN set -xe \
    &amp;&amp; docker-php-ext-configure gd --with-webp --with-jpeg --with-xpm --with-freetype \
    &amp;&amp; docker-php-ext-configure pgsql -with-pgsql=/usr/local/pgsql \
    &amp;&amp; docker-php-ext-configure intl \
    &amp;&amp; npm i -g yarn

RUN set -xe &amp;&amp; \
    docker-php-ext-install -j &quot;$(nproc)&quot; \
      exif \
      ffi \
      gd \
      gettext \
      intl \
      opcache \
      pcntl \
      pdo \
      pdo_pgsql \
      pgsql \
      sockets \
      zip \
      shmop \
      sysvmsg

RUN set -xe \
    &amp;&amp; pecl channel-update pecl.php.net \
    &amp;&amp; mkdir -p /usr/local/src/pecl \
    # protobuf
    &amp;&amp; pecl bundle -d /usr/local/src/pecl protobuf \
    &amp;&amp; docker-php-ext-configure /usr/local/src/pecl/protobuf \
    &amp;&amp; docker-php-ext-install -j$(nproc) /usr/local/src/pecl/protobuf \
    # grpc
    &amp;&amp; pecl bundle -d /usr/local/src/pecl grpc \
    &amp;&amp; docker-php-ext-configure /usr/local/src/pecl/grpc \
    &amp;&amp; docker-php-ext-install -j$(nproc) /usr/local/src/pecl/grpc \
    # jsonpath
    &amp;&amp; pecl bundle -d /usr/local/src/pecl jsonpath \
    &amp;&amp; docker-php-ext-configure /usr/local/src/pecl/jsonpath \
    &amp;&amp; docker-php-ext-install -j$(nproc) /usr/local/src/pecl/jsonpath \
    # ssh2
    &amp;&amp; pecl bundle -d /usr/local/src/pecl ssh2 \
    &amp;&amp; docker-php-ext-configure /usr/local/src/pecl/ssh2 \
    &amp;&amp; docker-php-ext-install -j$(nproc) /usr/local/src/pecl/ssh2 \
    # imagick
    &amp;&amp; pecl bundle -d /usr/local/src/pecl imagick \
    &amp;&amp; docker-php-ext-configure /usr/local/src/pecl/imagick \
    &amp;&amp; docker-php-ext-install -j$(nproc) /usr/local/src/pecl/imagick \
    # igbinary
    &amp;&amp; pecl bundle -d /usr/local/src/pecl igbinary \
    &amp;&amp; docker-php-ext-configure /usr/local/src/pecl/igbinary \
    &amp;&amp; docker-php-ext-install -j$(nproc) /usr/local/src/pecl/igbinary \
    # redis
    &amp;&amp; pecl bundle -d /usr/local/src/pecl redis \
    &amp;&amp; docker-php-ext-configure /usr/local/src/pecl/redis --enable-redis-igbinary --enable-redis-lzf --enable-redis-zstd --with-liblz4 \
    &amp;&amp; docker-php-ext-install -j$(nproc) /usr/local/src/pecl/redis \
    # mailparse
    &amp;&amp; pecl bundle -d /usr/local/src/pecl mailparse \
    &amp;&amp; docker-php-ext-configure /usr/local/src/pecl/mailparse \
    &amp;&amp; docker-php-ext-install -j$(nproc) /usr/local/src/pecl/mailparse \
    # inotify
    &amp;&amp; pecl bundle -d /usr/local/src/pecl inotify \
    &amp;&amp; docker-php-ext-configure /usr/local/src/pecl/inotify \
    &amp;&amp; docker-php-ext-install -j$(nproc) /usr/local/src/pecl/inotify \
    # excimer
    &amp;&amp; pecl bundle -d /usr/local/src/pecl excimer \
    &amp;&amp; docker-php-ext-configure /usr/local/src/pecl/excimer \
    &amp;&amp; docker-php-ext-install -j$(nproc) /usr/local/src/pecl/excimer \
    # yaml
    &amp;&amp; pecl bundle -d /usr/local/src/pecl yaml \
    &amp;&amp; docker-php-ext-configure /usr/local/src/pecl/yaml \
    &amp;&amp; docker-php-ext-install -j$(nproc) /usr/local/src/pecl/yaml \
    # parallel
#    &amp;&amp; pecl bundle -d /usr/local/src/pecl parallel \
#    &amp;&amp; docker-php-ext-configure /usr/local/src/pecl/parallel \
#    &amp;&amp; docker-php-ext-install -j$(nproc) /usr/local/src/pecl/parallel \
    # uv
    &amp;&amp; pecl bundle -d /usr/local/src/pecl uv \
    &amp;&amp; docker-php-ext-configure /usr/local/src/pecl/uv \
    &amp;&amp; docker-php-ext-install -j$(nproc) /usr/local/src/pecl/uv \
    # swoole
    &amp;&amp; pecl bundle -d /usr/local/src/pecl swoole \
    &amp;&amp; docker-php-ext-configure /usr/local/src/pecl/swoole --enable-sockets --enable-swoole-curl --enable-cares --enable-swoole-pgsql \
    &amp;&amp; docker-php-ext-install -j$(nproc) /usr/local/src/pecl/swoole \
    # elastic apm
    &amp;&amp; wget https://github.com/elastic/apm-agent-php/releases/download/v1.15.0/apm-agent-php_1.15.0_amd64.deb \
    &amp;&amp; dpkg -i apm-agent-php_1.15.0_amd64.deb \
    &amp;&amp; rm apm-agent-php_1.15.0_amd64.deb \
    &amp;&amp; rm -rf /usr/local/src/pecl \
    &amp;&amp; rm -rf /tmp/* \
    &amp;&amp; rm -rf /var/list/apt/* \
    &amp;&amp; rm -rf /var/lib/apt/lists/* \
    &amp;&amp; apt-get clean

# create document root, fix permissions for www-data user and change owner to www-data
RUN set -xe \
    &amp;&amp; mkdir -p ${APP_HOME}/public \
    &amp;&amp; mkdir -p /home/${USERNAME} &amp;&amp; chown ${USERNAME}:${USERNAME} /home/${USERNAME} \
    &amp;&amp; usermod -o -u ${HOST_UID} ${USERNAME} -d /home/${USERNAME} \
    &amp;&amp; groupmod -o -g ${HOST_GID} ${USERNAME} \
    &amp;&amp; chown -R ${USERNAME}:${USERNAME} ${APP_HOME}

# put php config for Laravel
#COPY ./docker/$BUILD_ARGUMENT_ENV/php.ini /usr/local/etc/php/php.ini

COPY ./docker/dev/ca.crt /usr/local/share/ca-certificates/ca-self.crt

RUN set -xe \
    &amp;&amp; update-ca-certificates

# install Xdebug in case dev/test environment
#COPY ./docker/general/do_we_need_xdebug.sh /tmp/
#COPY ./docker/dev/xdebug-${XDEBUG_CONFIG}.ini /tmp/xdebug.ini
#RUN chmod u+x /tmp/do_we_need_xdebug.sh &amp;&amp; /tmp/do_we_need_xdebug.sh

#COPY /docker/dev/xdebug-main.ini /docker/dev/xdebug.ini
#
#RUN set -xe \
#    &amp;&amp; pecl install xdebug-3.4.0 \
#    &amp;&amp; mv /docker/dev/xdebug.ini /usr/local/etc/php/conf.d/

# install composer
COPY --from=composer:latest /usr/bin/composer /usr/bin/composer
RUN chmod +x /usr/bin/composer
ENV COMPOSER_ALLOW_SUPERUSER 1

# add supervisor
RUN mkdir -p /var/log/supervisor
COPY --chown=root:root ./docker/general/supervisord.conf /etc/supervisor/conf.d/supervisord.conf
# add crontab
COPY --chown=root:crontab ./docker/general/cron /var/spool/cron/crontabs/root
RUN chmod 0600 /var/spool/cron/crontabs/root

# set working directory
WORKDIR ${APP_HOME}
USER ${USERNAME}

# Add necessary stuff to bash autocomplete
RUN set -xe \
    &amp;&amp; echo &apos;alias artisan=&quot;php /var/www/html/artisan&quot;&apos; &gt;&gt; /home/${USERNAME}/.bashrc

# copy source files and config file
COPY --chown=${USERNAME}:${USERNAME} . ${APP_HOME}/
COPY --chown=${USERNAME}:${USERNAME} .env ${APP_HOME}/.env
COPY --chown=${USERNAME}:${USERNAME} start-swoole-server ${APP_HOME}/start-swoole-server

RUN set -xe \
    &amp;&amp; chmod +x ./start-swoole-server

# install all PHP dependencies
# TODO fix
#RUN if [ &quot;${BUILD_ARGUMENT_ENV}&quot; = &quot;dev&quot; ] || [ &quot;${BUILD_ARGUMENT_ENV}&quot; = &quot;test&quot; ]; then COMPOSER_MEMORY_LIMIT=-1 composer install --optimize-autoloader --no-interaction --no-progress; \
#    else COMPOSER_MEMORY_LIMIT=-1 composer install --optimize-autoloader --no-interaction --no-progress --no-dev; \
#    fi
RUN set -xe \
    &amp;&amp; COMPOSER_MEMORY_LIMIT=-1 composer install

CMD [&quot;supervisord&quot;, &quot;-c&quot;, &quot;/etc/supervisor/conf.d/supervisord.conf&quot;]</file><file path="resources/app/api-client/queries/infiniteQueries.ts">// generated with @7nohe/openapi-react-query-codegen@1.6.2 
import { InfiniteData, useInfiniteQuery, UseInfiniteQueryOptions } from &quot;@tanstack/react-query&quot;;
import { AlbumService, ArtistService, GenreService, LibraryService, QueueService, SongService, UserService, UserTokenService } from &quot;../requests/services.gen&quot;;
import * as Common from &quot;./common&quot;;
/**
* Get a collection of albums
* @param data The data for the request.
* @param data.library The library slug
* @param data.fields
* @param data.relations
* @param data.page
* @param data.limit
* @param data.genres
* @returns unknown Paginated set of `AlbumResource`
* @throws ApiError
*/
export const useAlbumServiceGetApiLibrariesByLibraryAlbumsInfinite = &lt;TData = InfiniteData&lt;Common.AlbumServiceGetApiLibrariesByLibraryAlbumsDefaultResponse&gt;, TError = unknown, TQueryKey extends Array&lt;unknown&gt; = unknown[]&gt;({ fields, genres, library, limit, relations }: {
  fields?: string;
  genres?: string;
  library: string;
  limit?: number;
  relations?: string;
}, queryKey?: TQueryKey, options?: Omit&lt;UseInfiniteQueryOptions&lt;TData, TError&gt;, &quot;queryKey&quot; | &quot;queryFn&quot;&gt;) =&gt; useInfiniteQuery({
  queryKey: Common.UseAlbumServiceGetApiLibrariesByLibraryAlbumsKeyFn({ fields, genres, library, limit, relations }, queryKey), queryFn: ({ pageParam }) =&gt; AlbumService.getApiLibrariesByLibraryAlbums({ fields, genres, library, limit, page: pageParam as number, relations }) as TData, initialPageParam: &quot;1&quot;, getNextPageParam: response =&gt; (response as {
    nextPage: number;
  }).nextPage, ...options
});
/**
* Get a collection of artists
* @param data The data for the request.
* @param data.library
* @param data.fields
* @param data.relations
* @param data.page
* @param data.limit
* @param data.genres
* @returns unknown Paginated set of `ArtistResource`
* @throws ApiError
*/
export const useArtistServiceGetApiLibrariesByLibraryArtistsInfinite = &lt;TData = InfiniteData&lt;Common.ArtistServiceGetApiLibrariesByLibraryArtistsDefaultResponse&gt;, TError = unknown, TQueryKey extends Array&lt;unknown&gt; = unknown[]&gt;({ fields, genres, library, limit, relations }: {
  fields?: string;
  genres?: string;
  library: string;
  limit?: number;
  relations?: string;
}, queryKey?: TQueryKey, options?: Omit&lt;UseInfiniteQueryOptions&lt;TData, TError&gt;, &quot;queryKey&quot; | &quot;queryFn&quot;&gt;) =&gt; useInfiniteQuery({
  queryKey: Common.UseArtistServiceGetApiLibrariesByLibraryArtistsKeyFn({ fields, genres, library, limit, relations }, queryKey), queryFn: ({ pageParam }) =&gt; ArtistService.getApiLibrariesByLibraryArtists({ fields, genres, library, limit, page: pageParam as number, relations }) as TData, initialPageParam: &quot;1&quot;, getNextPageParam: response =&gt; (response as {
    nextPage: number;
  }).nextPage, ...options
});
/**
* Get a collection of genres
* @param data The data for the request.
* @param data.fields
* @param data.relations
* @param data.librarySlug
* @param data.page
* @param data.limit
* @returns unknown Paginated set of `GenreResource`
* @throws ApiError
*/
export const useGenreServiceGetApiGenresInfinite = &lt;TData = InfiniteData&lt;Common.GenreServiceGetApiGenresDefaultResponse&gt;, TError = unknown, TQueryKey extends Array&lt;unknown&gt; = unknown[]&gt;({ fields, librarySlug, limit, relations }: {
  fields?: string;
  librarySlug?: string;
  limit?: number;
  relations?: string;
} = {}, queryKey?: TQueryKey, options?: Omit&lt;UseInfiniteQueryOptions&lt;TData, TError&gt;, &quot;queryKey&quot; | &quot;queryFn&quot;&gt;) =&gt; useInfiniteQuery({
  queryKey: Common.UseGenreServiceGetApiGenresKeyFn({ fields, librarySlug, limit, relations }, queryKey), queryFn: ({ pageParam }) =&gt; GenreService.getApiGenres({ fields, librarySlug, limit, page: pageParam as number, relations }) as TData, initialPageParam: &quot;1&quot;, getNextPageParam: response =&gt; (response as {
    nextPage: number;
  }).nextPage, ...options
});
/**
* Get a collection of media libraries
* @param data The data for the request.
* @param data.page
* @param data.limit
* @returns unknown Paginated set of `LibraryResource`
* @throws ApiError
*/
export const useLibraryServiceGetApiLibrariesInfinite = &lt;TData = InfiniteData&lt;Common.LibraryServiceGetApiLibrariesDefaultResponse&gt;, TError = unknown, TQueryKey extends Array&lt;unknown&gt; = unknown[]&gt;({ limit }: {
  limit?: number;
} = {}, queryKey?: TQueryKey, options?: Omit&lt;UseInfiniteQueryOptions&lt;TData, TError&gt;, &quot;queryKey&quot; | &quot;queryFn&quot;&gt;) =&gt; useInfiniteQuery({
  queryKey: Common.UseLibraryServiceGetApiLibrariesKeyFn({ limit }, queryKey), queryFn: ({ pageParam }) =&gt; LibraryService.getApiLibraries({ limit, page: pageParam as number }) as TData, initialPageParam: &quot;1&quot;, getNextPageParam: response =&gt; (response as {
    nextPage: number;
  }).nextPage, ...options
});
/**
* Get a collection of monitor entries
* @param data The data for the request.
* @param data.page
* @param data.limit
* @param data.status
* @param data.queue
* @param data.name
* @param data.queuedFirst
* @returns unknown Paginated set of `QueueMonitorResource`
* @throws ApiError
*/
export const useQueueServiceGetApiQueueMetricsInfinite = &lt;TData = InfiniteData&lt;Common.QueueServiceGetApiQueueMetricsDefaultResponse&gt;, TError = unknown, TQueryKey extends Array&lt;unknown&gt; = unknown[]&gt;({ limit, name, queue, queuedFirst, status }: {
  limit?: number;
  name?: string;
  queue?: string;
  queuedFirst?: boolean;
  status?: &quot;running&quot; | &quot;succeeded&quot; | &quot;failed&quot; | &quot;stale&quot; | &quot;queued&quot;;
} = {}, queryKey?: TQueryKey, options?: Omit&lt;UseInfiniteQueryOptions&lt;TData, TError&gt;, &quot;queryKey&quot; | &quot;queryFn&quot;&gt;) =&gt; useInfiniteQuery({
  queryKey: Common.UseQueueServiceGetApiQueueMetricsKeyFn({ limit, name, queue, queuedFirst, status }, queryKey), queryFn: ({ pageParam }) =&gt; QueueService.getApiQueueMetrics({ limit, name, page: pageParam as number, queue, queuedFirst, status }) as TData, initialPageParam: &quot;1&quot;, getNextPageParam: response =&gt; (response as {
    nextPage: number;
  }).nextPage, ...options
});
/**
* Get a collection of songs
* @param data The data for the request.
* @param data.library The library slug
* @param data.page
* @param data.limit
* @param data.genreNames
* @param data.genreSlugs
* @param data.relations
* @returns unknown Paginated set of `SongResource`
* @throws ApiError
*/
export const useSongServiceGetApiLibrariesByLibrarySongsInfinite = &lt;TData = InfiniteData&lt;Common.SongServiceGetApiLibrariesByLibrarySongsDefaultResponse&gt;, TError = unknown, TQueryKey extends Array&lt;unknown&gt; = unknown[]&gt;({ genreNames, genreSlugs, library, limit, relations }: {
  genreNames?: string;
  genreSlugs?: string;
  library: string;
  limit?: number;
  relations?: string;
}, queryKey?: TQueryKey, options?: Omit&lt;UseInfiniteQueryOptions&lt;TData, TError&gt;, &quot;queryKey&quot; | &quot;queryFn&quot;&gt;) =&gt; useInfiniteQuery({
  queryKey: Common.UseSongServiceGetApiLibrariesByLibrarySongsKeyFn({ genreNames, genreSlugs, library, limit, relations }, queryKey), queryFn: ({ pageParam }) =&gt; SongService.getApiLibrariesByLibrarySongs({ genreNames, genreSlugs, library, limit, page: pageParam as number, relations }) as TData, initialPageParam: &quot;1&quot;, getNextPageParam: response =&gt; (response as {
    nextPage: number;
  }).nextPage, ...options
});
/**
* Get a collection of users
* @param data The data for the request.
* @param data.page
* @param data.limit
* @param data.globalFilter
* @param data.filters
* @param data.filterModes
* @param data.sorting
* @returns unknown Paginated set of `UserResource`
* @throws ApiError
*/
export const useUserServiceGetApiUsersInfinite = &lt;TData = InfiniteData&lt;Common.UserServiceGetApiUsersDefaultResponse&gt;, TError = unknown, TQueryKey extends Array&lt;unknown&gt; = unknown[]&gt;({ filterModes, filters, globalFilter, limit, sorting }: {
  filterModes?: string;
  filters?: string;
  globalFilter?: string;
  limit?: number;
  sorting?: string;
} = {}, queryKey?: TQueryKey, options?: Omit&lt;UseInfiniteQueryOptions&lt;TData, TError&gt;, &quot;queryKey&quot; | &quot;queryFn&quot;&gt;) =&gt; useInfiniteQuery({
  queryKey: Common.UseUserServiceGetApiUsersKeyFn({ filterModes, filters, globalFilter, limit, sorting }, queryKey), queryFn: ({ pageParam }) =&gt; UserService.getApiUsers({ filterModes, filters, globalFilter, limit, page: pageParam as number, sorting }) as TData, initialPageParam: &quot;1&quot;, getNextPageParam: response =&gt; (response as {
    nextPage: number;
  }).nextPage, ...options
});
/**
* Get a collection of tokens
* @param data The data for the request.
* @param data.user
* @param data.page
* @param data.perPage
* @returns unknown Paginated set of `PersonalAccessTokenViewResource`
* @throws ApiError
*/
export const useUserTokenServiceGetApiUsersTokensByUserInfinite = &lt;TData = InfiniteData&lt;Common.UserTokenServiceGetApiUsersTokensByUserDefaultResponse&gt;, TError = unknown, TQueryKey extends Array&lt;unknown&gt; = unknown[]&gt;({ perPage, user }: {
  perPage?: number;
  user: string;
}, queryKey?: TQueryKey, options?: Omit&lt;UseInfiniteQueryOptions&lt;TData, TError&gt;, &quot;queryKey&quot; | &quot;queryFn&quot;&gt;) =&gt; useInfiniteQuery({
  queryKey: Common.UseUserTokenServiceGetApiUsersTokensByUserKeyFn({ perPage, user }, queryKey), queryFn: ({ pageParam }) =&gt; UserTokenService.getApiUsersTokensByUser({ page: pageParam as number, perPage, user }) as TData, initialPageParam: &quot;1&quot;, getNextPageParam: response =&gt; (response as {
    nextPage: number;
  }).nextPage, ...options
});</file><file path="resources/app/ziggy.js">const Ziggy = {&quot;url&quot;:&quot;https:\/\/baander.test&quot;,&quot;port&quot;:null,&quot;defaults&quot;:{},&quot;routes&quot;:{&quot;login.store&quot;:{&quot;uri&quot;:&quot;login&quot;,&quot;methods&quot;:[&quot;POST&quot;]},&quot;logout&quot;:{&quot;uri&quot;:&quot;logout&quot;,&quot;methods&quot;:[&quot;POST&quot;]},&quot;password.email&quot;:{&quot;uri&quot;:&quot;forgot-password&quot;,&quot;methods&quot;:[&quot;POST&quot;]},&quot;password.update&quot;:{&quot;uri&quot;:&quot;reset-password&quot;,&quot;methods&quot;:[&quot;POST&quot;]},&quot;verification.verify&quot;:{&quot;uri&quot;:&quot;email\/verify\/{id}\/{hash}&quot;,&quot;methods&quot;:[&quot;GET&quot;,&quot;HEAD&quot;],&quot;parameters&quot;:[&quot;id&quot;,&quot;hash&quot;]},&quot;verification.send&quot;:{&quot;uri&quot;:&quot;email\/verification-notification&quot;,&quot;methods&quot;:[&quot;POST&quot;]},&quot;password.confirmation&quot;:{&quot;uri&quot;:&quot;user\/confirmed-password-status&quot;,&quot;methods&quot;:[&quot;GET&quot;,&quot;HEAD&quot;]},&quot;password.confirm.store&quot;:{&quot;uri&quot;:&quot;user\/confirm-password&quot;,&quot;methods&quot;:[&quot;POST&quot;]},&quot;two-factor.login.store&quot;:{&quot;uri&quot;:&quot;two-factor-challenge&quot;,&quot;methods&quot;:[&quot;POST&quot;]},&quot;two-factor.enable&quot;:{&quot;uri&quot;:&quot;user\/two-factor-authentication&quot;,&quot;methods&quot;:[&quot;POST&quot;]},&quot;two-factor.confirm&quot;:{&quot;uri&quot;:&quot;user\/confirmed-two-factor-authentication&quot;,&quot;methods&quot;:[&quot;POST&quot;]},&quot;two-factor.disable&quot;:{&quot;uri&quot;:&quot;user\/two-factor-authentication&quot;,&quot;methods&quot;:[&quot;DELETE&quot;]},&quot;two-factor.qr-code&quot;:{&quot;uri&quot;:&quot;user\/two-factor-qr-code&quot;,&quot;methods&quot;:[&quot;GET&quot;,&quot;HEAD&quot;]},&quot;two-factor.secret-key&quot;:{&quot;uri&quot;:&quot;user\/two-factor-secret-key&quot;,&quot;methods&quot;:[&quot;GET&quot;,&quot;HEAD&quot;]},&quot;two-factor.recovery-codes&quot;:{&quot;uri&quot;:&quot;user\/two-factor-recovery-codes&quot;,&quot;methods&quot;:[&quot;GET&quot;,&quot;HEAD&quot;]},&quot;horizon.stats.index&quot;:{&quot;uri&quot;:&quot;-\/horizon\/api\/stats&quot;,&quot;methods&quot;:[&quot;GET&quot;,&quot;HEAD&quot;]},&quot;horizon.workload.index&quot;:{&quot;uri&quot;:&quot;-\/horizon\/api\/workload&quot;,&quot;methods&quot;:[&quot;GET&quot;,&quot;HEAD&quot;]},&quot;horizon.masters.index&quot;:{&quot;uri&quot;:&quot;-\/horizon\/api\/masters&quot;,&quot;methods&quot;:[&quot;GET&quot;,&quot;HEAD&quot;]},&quot;horizon.monitoring.index&quot;:{&quot;uri&quot;:&quot;-\/horizon\/api\/monitoring&quot;,&quot;methods&quot;:[&quot;GET&quot;,&quot;HEAD&quot;]},&quot;horizon.monitoring.store&quot;:{&quot;uri&quot;:&quot;-\/horizon\/api\/monitoring&quot;,&quot;methods&quot;:[&quot;POST&quot;]},&quot;horizon.monitoring-tag.paginate&quot;:{&quot;uri&quot;:&quot;-\/horizon\/api\/monitoring\/{tag}&quot;,&quot;methods&quot;:[&quot;GET&quot;,&quot;HEAD&quot;],&quot;parameters&quot;:[&quot;tag&quot;]},&quot;horizon.monitoring-tag.destroy&quot;:{&quot;uri&quot;:&quot;-\/horizon\/api\/monitoring\/{tag}&quot;,&quot;methods&quot;:[&quot;DELETE&quot;],&quot;wheres&quot;:{&quot;tag&quot;:&quot;.*&quot;},&quot;parameters&quot;:[&quot;tag&quot;]},&quot;horizon.jobs-metrics.index&quot;:{&quot;uri&quot;:&quot;-\/horizon\/api\/metrics\/jobs&quot;,&quot;methods&quot;:[&quot;GET&quot;,&quot;HEAD&quot;]},&quot;horizon.jobs-metrics.show&quot;:{&quot;uri&quot;:&quot;-\/horizon\/api\/metrics\/jobs\/{id}&quot;,&quot;methods&quot;:[&quot;GET&quot;,&quot;HEAD&quot;],&quot;parameters&quot;:[&quot;id&quot;]},&quot;horizon.queues-metrics.index&quot;:{&quot;uri&quot;:&quot;-\/horizon\/api\/metrics\/queues&quot;,&quot;methods&quot;:[&quot;GET&quot;,&quot;HEAD&quot;]},&quot;horizon.queues-metrics.show&quot;:{&quot;uri&quot;:&quot;-\/horizon\/api\/metrics\/queues\/{id}&quot;,&quot;methods&quot;:[&quot;GET&quot;,&quot;HEAD&quot;],&quot;parameters&quot;:[&quot;id&quot;]},&quot;horizon.jobs-batches.index&quot;:{&quot;uri&quot;:&quot;-\/horizon\/api\/batches&quot;,&quot;methods&quot;:[&quot;GET&quot;,&quot;HEAD&quot;]},&quot;horizon.jobs-batches.show&quot;:{&quot;uri&quot;:&quot;-\/horizon\/api\/batches\/{id}&quot;,&quot;methods&quot;:[&quot;GET&quot;,&quot;HEAD&quot;],&quot;parameters&quot;:[&quot;id&quot;]},&quot;horizon.jobs-batches.retry&quot;:{&quot;uri&quot;:&quot;-\/horizon\/api\/batches\/retry\/{id}&quot;,&quot;methods&quot;:[&quot;POST&quot;],&quot;parameters&quot;:[&quot;id&quot;]},&quot;horizon.pending-jobs.index&quot;:{&quot;uri&quot;:&quot;-\/horizon\/api\/jobs\/pending&quot;,&quot;methods&quot;:[&quot;GET&quot;,&quot;HEAD&quot;]},&quot;horizon.completed-jobs.index&quot;:{&quot;uri&quot;:&quot;-\/horizon\/api\/jobs\/completed&quot;,&quot;methods&quot;:[&quot;GET&quot;,&quot;HEAD&quot;]},&quot;horizon.silenced-jobs.index&quot;:{&quot;uri&quot;:&quot;-\/horizon\/api\/jobs\/silenced&quot;,&quot;methods&quot;:[&quot;GET&quot;,&quot;HEAD&quot;]},&quot;horizon.failed-jobs.index&quot;:{&quot;uri&quot;:&quot;-\/horizon\/api\/jobs\/failed&quot;,&quot;methods&quot;:[&quot;GET&quot;,&quot;HEAD&quot;]},&quot;horizon.failed-jobs.show&quot;:{&quot;uri&quot;:&quot;-\/horizon\/api\/jobs\/failed\/{id}&quot;,&quot;methods&quot;:[&quot;GET&quot;,&quot;HEAD&quot;],&quot;parameters&quot;:[&quot;id&quot;]},&quot;horizon.retry-jobs.show&quot;:{&quot;uri&quot;:&quot;-\/horizon\/api\/jobs\/retry\/{id}&quot;,&quot;methods&quot;:[&quot;POST&quot;],&quot;parameters&quot;:[&quot;id&quot;]},&quot;horizon.jobs.show&quot;:{&quot;uri&quot;:&quot;-\/horizon\/api\/jobs\/{id}&quot;,&quot;methods&quot;:[&quot;GET&quot;,&quot;HEAD&quot;],&quot;parameters&quot;:[&quot;id&quot;]},&quot;horizon.index&quot;:{&quot;uri&quot;:&quot;-\/horizon\/{view?}&quot;,&quot;methods&quot;:[&quot;GET&quot;,&quot;HEAD&quot;],&quot;wheres&quot;:{&quot;view&quot;:&quot;(.*)&quot;},&quot;parameters&quot;:[&quot;view&quot;]},&quot;passport.token&quot;:{&quot;uri&quot;:&quot;oauth\/token&quot;,&quot;methods&quot;:[&quot;POST&quot;]},&quot;passport.authorizations.authorize&quot;:{&quot;uri&quot;:&quot;oauth\/authorize&quot;,&quot;methods&quot;:[&quot;GET&quot;,&quot;HEAD&quot;]},&quot;passport.token.refresh&quot;:{&quot;uri&quot;:&quot;oauth\/token\/refresh&quot;,&quot;methods&quot;:[&quot;POST&quot;]},&quot;passport.authorizations.approve&quot;:{&quot;uri&quot;:&quot;oauth\/authorize&quot;,&quot;methods&quot;:[&quot;POST&quot;]},&quot;passport.authorizations.deny&quot;:{&quot;uri&quot;:&quot;oauth\/authorize&quot;,&quot;methods&quot;:[&quot;DELETE&quot;]},&quot;passport.tokens.index&quot;:{&quot;uri&quot;:&quot;oauth\/tokens&quot;,&quot;methods&quot;:[&quot;GET&quot;,&quot;HEAD&quot;]},&quot;passport.tokens.destroy&quot;:{&quot;uri&quot;:&quot;oauth\/tokens\/{token_id}&quot;,&quot;methods&quot;:[&quot;DELETE&quot;],&quot;parameters&quot;:[&quot;token_id&quot;]},&quot;passport.clients.index&quot;:{&quot;uri&quot;:&quot;oauth\/clients&quot;,&quot;methods&quot;:[&quot;GET&quot;,&quot;HEAD&quot;]},&quot;passport.clients.store&quot;:{&quot;uri&quot;:&quot;oauth\/clients&quot;,&quot;methods&quot;:[&quot;POST&quot;]},&quot;passport.clients.update&quot;:{&quot;uri&quot;:&quot;oauth\/clients\/{client_id}&quot;,&quot;methods&quot;:[&quot;PUT&quot;],&quot;parameters&quot;:[&quot;client_id&quot;]},&quot;passport.clients.destroy&quot;:{&quot;uri&quot;:&quot;oauth\/clients\/{client_id}&quot;,&quot;methods&quot;:[&quot;DELETE&quot;],&quot;parameters&quot;:[&quot;client_id&quot;]},&quot;passport.scopes.index&quot;:{&quot;uri&quot;:&quot;oauth\/scopes&quot;,&quot;methods&quot;:[&quot;GET&quot;,&quot;HEAD&quot;]},&quot;passport.personal.tokens.index&quot;:{&quot;uri&quot;:&quot;oauth\/personal-access-tokens&quot;,&quot;methods&quot;:[&quot;GET&quot;,&quot;HEAD&quot;]},&quot;passport.personal.tokens.store&quot;:{&quot;uri&quot;:&quot;oauth\/personal-access-tokens&quot;,&quot;methods&quot;:[&quot;POST&quot;]},&quot;passport.personal.tokens.destroy&quot;:{&quot;uri&quot;:&quot;oauth\/personal-access-tokens\/{token_id}&quot;,&quot;methods&quot;:[&quot;DELETE&quot;],&quot;parameters&quot;:[&quot;token_id&quot;]},&quot;pulse&quot;:{&quot;uri&quot;:&quot;-\/pulse&quot;,&quot;methods&quot;:[&quot;GET&quot;,&quot;HEAD&quot;]},&quot;sanctum.csrf-cookie&quot;:{&quot;uri&quot;:&quot;sanctum\/csrf-cookie&quot;,&quot;methods&quot;:[&quot;GET&quot;,&quot;HEAD&quot;]},&quot;livewire.update&quot;:{&quot;uri&quot;:&quot;livewire\/update&quot;,&quot;methods&quot;:[&quot;POST&quot;]},&quot;livewire.upload-file&quot;:{&quot;uri&quot;:&quot;livewire\/upload-file&quot;,&quot;methods&quot;:[&quot;POST&quot;]},&quot;livewire.preview-file&quot;:{&quot;uri&quot;:&quot;livewire\/preview-file\/{filename}&quot;,&quot;methods&quot;:[&quot;GET&quot;,&quot;HEAD&quot;],&quot;parameters&quot;:[&quot;filename&quot;]},&quot;log-viewer.hosts&quot;:{&quot;uri&quot;:&quot;system\/log-viewer\/api\/hosts&quot;,&quot;methods&quot;:[&quot;GET&quot;,&quot;HEAD&quot;]},&quot;log-viewer.folders&quot;:{&quot;uri&quot;:&quot;system\/log-viewer\/api\/folders&quot;,&quot;methods&quot;:[&quot;GET&quot;,&quot;HEAD&quot;]},&quot;log-viewer.folders.request-download&quot;:{&quot;uri&quot;:&quot;system\/log-viewer\/api\/folders\/{folderIdentifier}\/download\/request&quot;,&quot;methods&quot;:[&quot;GET&quot;,&quot;HEAD&quot;],&quot;parameters&quot;:[&quot;folderIdentifier&quot;]},&quot;log-viewer.folders.clear-cache&quot;:{&quot;uri&quot;:&quot;system\/log-viewer\/api\/folders\/{folderIdentifier}\/clear-cache&quot;,&quot;methods&quot;:[&quot;POST&quot;],&quot;parameters&quot;:[&quot;folderIdentifier&quot;]},&quot;log-viewer.folders.delete&quot;:{&quot;uri&quot;:&quot;system\/log-viewer\/api\/folders\/{folderIdentifier}&quot;,&quot;methods&quot;:[&quot;DELETE&quot;],&quot;parameters&quot;:[&quot;folderIdentifier&quot;]},&quot;log-viewer.files&quot;:{&quot;uri&quot;:&quot;system\/log-viewer\/api\/files&quot;,&quot;methods&quot;:[&quot;GET&quot;,&quot;HEAD&quot;]},&quot;log-viewer.files.request-download&quot;:{&quot;uri&quot;:&quot;system\/log-viewer\/api\/files\/{fileIdentifier}\/download\/request&quot;,&quot;methods&quot;:[&quot;GET&quot;,&quot;HEAD&quot;],&quot;parameters&quot;:[&quot;fileIdentifier&quot;]},&quot;log-viewer.files.clear-cache&quot;:{&quot;uri&quot;:&quot;system\/log-viewer\/api\/files\/{fileIdentifier}\/clear-cache&quot;,&quot;methods&quot;:[&quot;POST&quot;],&quot;parameters&quot;:[&quot;fileIdentifier&quot;]},&quot;log-viewer.files.delete&quot;:{&quot;uri&quot;:&quot;system\/log-viewer\/api\/files\/{fileIdentifier}&quot;,&quot;methods&quot;:[&quot;DELETE&quot;],&quot;parameters&quot;:[&quot;fileIdentifier&quot;]},&quot;log-viewer.files.clear-cache-all&quot;:{&quot;uri&quot;:&quot;system\/log-viewer\/api\/clear-cache-all&quot;,&quot;methods&quot;:[&quot;POST&quot;]},&quot;log-viewer.files.delete-multiple-files&quot;:{&quot;uri&quot;:&quot;system\/log-viewer\/api\/delete-multiple-files&quot;,&quot;methods&quot;:[&quot;POST&quot;]},&quot;log-viewer.logs&quot;:{&quot;uri&quot;:&quot;system\/log-viewer\/api\/logs&quot;,&quot;methods&quot;:[&quot;GET&quot;,&quot;HEAD&quot;]},&quot;log-viewer.folders.download&quot;:{&quot;uri&quot;:&quot;system\/log-viewer\/api\/folders\/{folderIdentifier}\/download&quot;,&quot;methods&quot;:[&quot;GET&quot;,&quot;HEAD&quot;],&quot;parameters&quot;:[&quot;folderIdentifier&quot;]},&quot;log-viewer.files.download&quot;:{&quot;uri&quot;:&quot;system\/log-viewer\/api\/files\/{fileIdentifier}\/download&quot;,&quot;methods&quot;:[&quot;GET&quot;,&quot;HEAD&quot;],&quot;parameters&quot;:[&quot;fileIdentifier&quot;]},&quot;log-viewer.index&quot;:{&quot;uri&quot;:&quot;system\/log-viewer\/{view?}&quot;,&quot;methods&quot;:[&quot;GET&quot;,&quot;HEAD&quot;],&quot;wheres&quot;:{&quot;view&quot;:&quot;(.*)&quot;},&quot;parameters&quot;:[&quot;view&quot;]},&quot;ignition.healthCheck&quot;:{&quot;uri&quot;:&quot;_ignition\/health-check&quot;,&quot;methods&quot;:[&quot;GET&quot;,&quot;HEAD&quot;]},&quot;ignition.executeSolution&quot;:{&quot;uri&quot;:&quot;_ignition\/execute-solution&quot;,&quot;methods&quot;:[&quot;POST&quot;]},&quot;ignition.updateConfig&quot;:{&quot;uri&quot;:&quot;_ignition\/update-config&quot;,&quot;methods&quot;:[&quot;POST&quot;]},&quot;api.albums.index&quot;:{&quot;uri&quot;:&quot;api\/libraries\/{library}\/albums&quot;,&quot;methods&quot;:[&quot;GET&quot;,&quot;HEAD&quot;],&quot;parameters&quot;:[&quot;library&quot;],&quot;bindings&quot;:{&quot;library&quot;:&quot;slug&quot;}},&quot;api.albums.show&quot;:{&quot;uri&quot;:&quot;api\/libraries\/{library}\/albums\/{album}&quot;,&quot;methods&quot;:[&quot;GET&quot;,&quot;HEAD&quot;],&quot;parameters&quot;:[&quot;library&quot;,&quot;album&quot;],&quot;bindings&quot;:{&quot;library&quot;:&quot;slug&quot;,&quot;album&quot;:&quot;slug&quot;}},&quot;api.artists.index&quot;:{&quot;uri&quot;:&quot;api\/libraries\/{library}\/artists&quot;,&quot;methods&quot;:[&quot;GET&quot;,&quot;HEAD&quot;],&quot;parameters&quot;:[&quot;library&quot;]},&quot;api.artists.show&quot;:{&quot;uri&quot;:&quot;api\/libraries\/{library}\/artists\/{artist}&quot;,&quot;methods&quot;:[&quot;GET&quot;,&quot;HEAD&quot;],&quot;parameters&quot;:[&quot;library&quot;,&quot;artist&quot;],&quot;bindings&quot;:{&quot;artist&quot;:&quot;slug&quot;}},&quot;auth.login&quot;:{&quot;uri&quot;:&quot;api\/auth\/login&quot;,&quot;methods&quot;:[&quot;POST&quot;]},&quot;auth.refreshToken&quot;:{&quot;uri&quot;:&quot;api\/auth\/refreshToken&quot;,&quot;methods&quot;:[&quot;POST&quot;]},&quot;auth.streamToken&quot;:{&quot;uri&quot;:&quot;api\/auth\/streamToken&quot;,&quot;methods&quot;:[&quot;POST&quot;]},&quot;auth.register&quot;:{&quot;uri&quot;:&quot;api\/auth\/register&quot;,&quot;methods&quot;:[&quot;POST&quot;]},&quot;auth.forgotPassword&quot;:{&quot;uri&quot;:&quot;api\/auth\/forgotPassword&quot;,&quot;methods&quot;:[&quot;POST&quot;]},&quot;auth.resetPassword&quot;:{&quot;uri&quot;:&quot;api\/auth\/resetPassword&quot;,&quot;methods&quot;:[&quot;POST&quot;]},&quot;auth.verifyEmail&quot;:{&quot;uri&quot;:&quot;api\/auth\/verify\/{id}\/{hash}&quot;,&quot;methods&quot;:[&quot;POST&quot;],&quot;parameters&quot;:[&quot;id&quot;,&quot;hash&quot;]},&quot;auth.logout&quot;:{&quot;uri&quot;:&quot;api\/auth\/logout&quot;,&quot;methods&quot;:[&quot;POST&quot;]},&quot;api.genres.index&quot;:{&quot;uri&quot;:&quot;api\/genres&quot;,&quot;methods&quot;:[&quot;GET&quot;,&quot;HEAD&quot;]},&quot;api.genres.show&quot;:{&quot;uri&quot;:&quot;api\/genres\/{genre}&quot;,&quot;methods&quot;:[&quot;GET&quot;,&quot;HEAD&quot;],&quot;parameters&quot;:[&quot;genre&quot;],&quot;bindings&quot;:{&quot;genre&quot;:&quot;slug&quot;}},&quot;api.genres.update&quot;:{&quot;uri&quot;:&quot;api\/genres\/{genre}&quot;,&quot;methods&quot;:[&quot;PATCH&quot;],&quot;parameters&quot;:[&quot;genre&quot;],&quot;bindings&quot;:{&quot;genre&quot;:&quot;slug&quot;}},&quot;api.genres.destroy&quot;:{&quot;uri&quot;:&quot;api\/genres\/{genre}&quot;,&quot;methods&quot;:[&quot;DELETE&quot;],&quot;parameters&quot;:[&quot;genre&quot;],&quot;bindings&quot;:{&quot;genre&quot;:&quot;slug&quot;}},&quot;api.image.serve&quot;:{&quot;uri&quot;:&quot;api\/images\/{image}&quot;,&quot;methods&quot;:[&quot;GET&quot;,&quot;HEAD&quot;],&quot;parameters&quot;:[&quot;image&quot;],&quot;bindings&quot;:{&quot;image&quot;:&quot;public_id&quot;}},&quot;api.job.library-scan&quot;:{&quot;uri&quot;:&quot;api\/jobs\/scanLibrary\/{slug}&quot;,&quot;methods&quot;:[&quot;POST&quot;],&quot;parameters&quot;:[&quot;slug&quot;]},&quot;api.libraries.index&quot;:{&quot;uri&quot;:&quot;api\/libraries&quot;,&quot;methods&quot;:[&quot;GET&quot;,&quot;HEAD&quot;]},&quot;api.library.create&quot;:{&quot;uri&quot;:&quot;api\/libraries&quot;,&quot;methods&quot;:[&quot;POST&quot;]},&quot;api.library.show&quot;:{&quot;uri&quot;:&quot;api\/libraries\/{slug}&quot;,&quot;methods&quot;:[&quot;GET&quot;,&quot;HEAD&quot;],&quot;parameters&quot;:[&quot;slug&quot;]},&quot;api.library.update&quot;:{&quot;uri&quot;:&quot;api\/libraries\/{slug}&quot;,&quot;methods&quot;:[&quot;PATCH&quot;],&quot;parameters&quot;:[&quot;slug&quot;]},&quot;api.library.delete&quot;:{&quot;uri&quot;:&quot;api\/libraries\/{slug}&quot;,&quot;methods&quot;:[&quot;DELETE&quot;],&quot;parameters&quot;:[&quot;slug&quot;]},&quot;api.opcache.getConfig&quot;:{&quot;uri&quot;:&quot;api\/opcache\/config&quot;,&quot;methods&quot;:[&quot;GET&quot;,&quot;HEAD&quot;]},&quot;api.opcache.clear&quot;:{&quot;uri&quot;:&quot;api\/opcache\/clear&quot;,&quot;methods&quot;:[&quot;POST&quot;]},&quot;api.opcache.compile&quot;:{&quot;uri&quot;:&quot;api\/opcache\/compile&quot;,&quot;methods&quot;:[&quot;POST&quot;]},&quot;api.queue-metrics.show&quot;:{&quot;uri&quot;:&quot;api\/queue-metrics&quot;,&quot;methods&quot;:[&quot;GET&quot;,&quot;HEAD&quot;]},&quot;api.queue-metrics.queues&quot;:{&quot;uri&quot;:&quot;api\/queue-metrics\/queues&quot;,&quot;methods&quot;:[&quot;GET&quot;,&quot;HEAD&quot;]},&quot;api.queue-metrics.metrics&quot;:{&quot;uri&quot;:&quot;api\/queue-metrics\/metrics&quot;,&quot;methods&quot;:[&quot;GET&quot;,&quot;HEAD&quot;]},&quot;api.queue-metrics.retry-job&quot;:{&quot;uri&quot;:&quot;api\/queue-metrics\/retry\/{id}&quot;,&quot;methods&quot;:[&quot;POST&quot;],&quot;parameters&quot;:[&quot;id&quot;]},&quot;api.queue-metrics.delete&quot;:{&quot;uri&quot;:&quot;api\/queue-metrics\/{id}&quot;,&quot;methods&quot;:[&quot;DELETE&quot;],&quot;parameters&quot;:[&quot;id&quot;]},&quot;api.queue-metrics.purge&quot;:{&quot;uri&quot;:&quot;api\/queue-metrics\/purge&quot;,&quot;methods&quot;:[&quot;DELETE&quot;]},&quot;api.songs.index&quot;:{&quot;uri&quot;:&quot;api\/libraries\/{library}\/songs&quot;,&quot;methods&quot;:[&quot;GET&quot;,&quot;HEAD&quot;],&quot;parameters&quot;:[&quot;library&quot;],&quot;bindings&quot;:{&quot;library&quot;:&quot;slug&quot;}},&quot;api.songs.show&quot;:{&quot;uri&quot;:&quot;api\/libraries\/{library}\/songs\/{publicId}&quot;,&quot;methods&quot;:[&quot;GET&quot;,&quot;HEAD&quot;],&quot;parameters&quot;:[&quot;library&quot;,&quot;publicId&quot;],&quot;bindings&quot;:{&quot;library&quot;:&quot;slug&quot;}},&quot;api.songs.stream&quot;:{&quot;uri&quot;:&quot;api\/libraries\/{library}\/songs\/stream\/song\/{song}\/direct&quot;,&quot;methods&quot;:[&quot;GET&quot;,&quot;HEAD&quot;],&quot;parameters&quot;:[&quot;library&quot;,&quot;song&quot;],&quot;bindings&quot;:{&quot;library&quot;:&quot;slug&quot;,&quot;song&quot;:&quot;public_id&quot;}},&quot;api.system-info.php&quot;:{&quot;uri&quot;:&quot;api\/system-info&quot;,&quot;methods&quot;:[&quot;GET&quot;,&quot;HEAD&quot;]},&quot;api.system-info.sys&quot;:{&quot;uri&quot;:&quot;api\/system-info\/sys&quot;,&quot;methods&quot;:[&quot;GET&quot;,&quot;HEAD&quot;]},&quot;api.users.index&quot;:{&quot;uri&quot;:&quot;api\/users&quot;,&quot;methods&quot;:[&quot;GET&quot;,&quot;HEAD&quot;]},&quot;api.users.store&quot;:{&quot;uri&quot;:&quot;api\/users&quot;,&quot;methods&quot;:[&quot;POST&quot;]},&quot;api.users.update&quot;:{&quot;uri&quot;:&quot;api\/users\/{user}&quot;,&quot;methods&quot;:[&quot;PATCH&quot;],&quot;parameters&quot;:[&quot;user&quot;],&quot;bindings&quot;:{&quot;user&quot;:&quot;id&quot;}},&quot;api.users.me&quot;:{&quot;uri&quot;:&quot;api\/users\/me&quot;,&quot;methods&quot;:[&quot;GET&quot;,&quot;HEAD&quot;]},&quot;api.users.show&quot;:{&quot;uri&quot;:&quot;api\/users\/{user}&quot;,&quot;methods&quot;:[&quot;GET&quot;,&quot;HEAD&quot;],&quot;parameters&quot;:[&quot;user&quot;],&quot;bindings&quot;:{&quot;user&quot;:&quot;id&quot;}},&quot;api.users.destroy&quot;:{&quot;uri&quot;:&quot;api\/users\/{user}&quot;,&quot;methods&quot;:[&quot;DELETE&quot;],&quot;parameters&quot;:[&quot;user&quot;]},&quot;auth.passkey.options&quot;:{&quot;uri&quot;:&quot;webauthn\/passkey&quot;,&quot;methods&quot;:[&quot;GET&quot;,&quot;HEAD&quot;]},&quot;auth.passkey.login&quot;:{&quot;uri&quot;:&quot;webauthn\/passkey&quot;,&quot;methods&quot;:[&quot;POST&quot;]},&quot;auth.passkey.register-option&quot;:{&quot;uri&quot;:&quot;webauthn\/passkey\/register&quot;,&quot;methods&quot;:[&quot;GET&quot;,&quot;HEAD&quot;]},&quot;auth.passkey.register&quot;:{&quot;uri&quot;:&quot;webauthn\/passkey\/register&quot;,&quot;methods&quot;:[&quot;POST&quot;]},&quot;mailbook.dashboard&quot;:{&quot;uri&quot;:&quot;mailbook&quot;,&quot;methods&quot;:[&quot;GET&quot;,&quot;HEAD&quot;]},&quot;mailbook.content&quot;:{&quot;uri&quot;:&quot;mailbook\/content&quot;,&quot;methods&quot;:[&quot;GET&quot;,&quot;HEAD&quot;]},&quot;mailbook.send&quot;:{&quot;uri&quot;:&quot;mailbook\/send&quot;,&quot;methods&quot;:[&quot;GET&quot;,&quot;HEAD&quot;]},&quot;dbg&quot;:{&quot;uri&quot;:&quot;dbg&quot;,&quot;methods&quot;:[&quot;GET&quot;,&quot;HEAD&quot;]},&quot;webui&quot;:{&quot;uri&quot;:&quot;{any}&quot;,&quot;methods&quot;:[&quot;GET&quot;,&quot;HEAD&quot;],&quot;wheres&quot;:{&quot;any&quot;:&quot;^(?!api|docs|storage|public-api|clockwork|system|2fa|login|dbg|jobs).*$&quot;},&quot;parameters&quot;:[&quot;any&quot;]},&quot;scramble.docs.ui&quot;:{&quot;uri&quot;:&quot;docs\/api&quot;,&quot;methods&quot;:[&quot;GET&quot;,&quot;HEAD&quot;]},&quot;scramble.docs.document&quot;:{&quot;uri&quot;:&quot;docs\/api.json&quot;,&quot;methods&quot;:[&quot;GET&quot;,&quot;HEAD&quot;]}}};
if (typeof window !== &apos;undefined&apos; &amp;&amp; typeof window.Ziggy !== &apos;undefined&apos;) {
  Object.assign(Ziggy.routes, window.Ziggy.routes);
}
export { Ziggy };</file><file path="resources/app/layouts/root-layout/root-layout.tsx">import { ReactNode } from &apos;react&apos;;
import styles from &apos;./root-layout.module.scss&apos;;
import { lazyImport } from &apos;@/utils/lazy-import&apos;;
import { RootMenu } from &apos;@/layouts/root-layout/components/root-menu&apos;;
import { NotificationArea } from &apos;@/modules/notifications/notification-area.tsx&apos;;
import { ApmErrorBoundary } from &apos;@/components/apm/apm-error-boundary.tsx&apos;;
const { InlinePlayer } = lazyImport(() =&gt; import(&apos;@/modules/library-music-player/inline-player.tsx&apos;), &apos;InlinePlayer&apos;);
export function RootLayout(props: { children?: ReactNode }) {
  return (
    &lt;div className={styles.shell}&gt;
      &lt;aside className={styles.sidebar}&gt;
        &lt;ApmErrorBoundary&gt;
          &lt;RootMenu /&gt;
          &lt;NotificationArea /&gt;
        &lt;/ApmErrorBoundary&gt;
      &lt;/aside&gt;
      &lt;main className={styles.main}&gt;
        &lt;div className={styles.content}&gt;
          &lt;div className={styles.page}&gt;
            &lt;ApmErrorBoundary&gt;
              {props.children}
            &lt;/ApmErrorBoundary&gt;
          &lt;/div&gt;
        &lt;/div&gt;
      &lt;/main&gt;
      &lt;footer className={styles.footer}&gt;
        &lt;ApmErrorBoundary&gt;
          &lt;InlinePlayer /&gt;
        &lt;/ApmErrorBoundary&gt;
      &lt;/footer&gt;
    &lt;/div&gt;
  );
}</file><file path="app/Http/Controllers/Api/Auth/AuthController.php">&lt;?php
namespace App\Http\Controllers\Api\Auth;
use App\Auth\TokenName;
use App\Http\Controllers\Api\Auth\Concerns\HandlesUserTokens;
use App\Jobs\Auth\RevokeTokenJob;
use App\Http\Requests\Auth\{ForgotPasswordRequest, LoginRequest, LogoutRequest, RegisterRequest, ResetPasswordRequest};
use App\Http\Resources\Auth\NewAccessTokenResource;
use App\Http\Resources\User\UserResource;
use Illuminate\Http\Response;
use App\Models\{PersonalAccessToken, TokenAbility, User};
use App\Notifications\ForgotPasswordNotification;
use Illuminate\Auth\Events\Verified;
use Illuminate\Contracts\Auth\MustVerifyEmail;
use Illuminate\Http\Request;
use Illuminate\Notifications\AnonymousNotifiable;
use Illuminate\Support\Carbon;
use Illuminate\Support\Facades\{Hash, Password};
use Spatie\RouteAttributes\Attributes\{Post, Prefix};
use Queue;
/**
 * @tags Auth
 */
#[Prefix(&apos;auth&apos;)]
class AuthController
{
    use HandlesUserTokens;
    /**
     * Login
     * @unauthenticated
     *
     * @response array{
     *   accessToken: NewAccessTokenResource,
     *   refreshToken: NewAccessTokenResource
     * }
     */
    #[Post(&apos;login&apos;, &apos;auth.login&apos;)]
    public function login(LoginRequest $request)
    {
        $user = User::whereEmail($request-&gt;input(&apos;email&apos;))-&gt;first();
        if (!$user) {
            abort(401, &apos;Invalid credentials.&apos;);
        }
        $attempt = auth()-&gt;attempt($request-&gt;only(&apos;email&apos;, &apos;password&apos;), $request-&gt;filled(&apos;remember&apos;));
        if (!$attempt) {
            abort(401, &apos;Invalid credentials.&apos;);
        }
        return $this-&gt;createTokenSet($request, $user);
    }
    /**
     * Refresh token
     *
     * Needs refresh token with ability &quot;issue-access-token&quot;
     */
    #[Post(&apos;refreshToken&apos;, &apos;auth.refreshToken&apos;, [&apos;auth:sanctum&apos;, &apos;ability:&apos; . TokenAbility::ISSUE_ACCESS_TOKEN-&gt;value])]
    public function refreshToken(Request $request)
    {
        $device = PersonalAccessToken::prepareDeviceFromRequest($request);
        $accessToken = $request-&gt;user()-&gt;createToken(
            name: &apos;access_token&apos;,
            abilities: [TokenAbility::ACCESS_API-&gt;value, TokenAbility::ACCESS_BROADCASTING-&gt;value],
            expiresAt: Carbon::now()-&gt;addMinutes(config(&apos;sanctum.access_token_expiration&apos;)),
            device: $device,
        );
        return response([
           &apos;accessToken&apos; =&gt; new NewAccessTokenResource($accessToken),
        ]);
    }
    /**
     * Get a stream token
     *
     * Needs refresh token with ability &quot;issue-access-token&quot;
     *
     * @param Request $request
     * @response array{
     *     streamToken: NewAccessTokenResource,
     * }
     */
    #[Post(&apos;streamToken&apos;, &apos;auth.streamToken&apos;, [&apos;auth:sanctum&apos;, &apos;ability:&apos; . TokenAbility::ISSUE_ACCESS_TOKEN-&gt;value])]
    public function getStreamToken(Request $request)
    {
        $device = PersonalAccessToken::prepareDeviceFromRequest($request);
        $streamToken = $request-&gt;user()-&gt;createToken(
            name: &apos;stream_token&apos;,
            abilities: [TokenAbility::ACCESS_STREAM-&gt;value],
            expiresAt: Carbon::now()-&gt;addMinutes(config(&apos;sanctum.stream_token_expiration&apos;)),
            device: $device,
        );
        return response()-&gt;json([
           &apos;streamToken&apos; =&gt; new NewAccessTokenResource($streamToken),
        ]);
    }
    /**
     * Register
     * @unauthenticated
     *
     * @response array{
     *   accessToken: NewAccessTokenResource,
     *   refreshToken: NewAccessTokenResource
     * }
     */
    #[Post(&apos;register&apos;, &apos;auth.register&apos;)]
    public function register(RegisterRequest $request)
    {
        $user = User::forceCreate([
            &apos;name&apos;     =&gt; $request-&gt;input(&apos;name&apos;),
            &apos;email&apos;    =&gt; $request-&gt;input(&apos;email&apos;),
            &apos;password&apos; =&gt; Hash::make($request-&gt;input(&apos;password&apos;)),
        ]);
        return $this-&gt;createTokenSet($request, $user);
    }
    /**
     * Request reset password link
     * @unauthenticated
     */
    #[Post(&apos;forgotPassword&apos;, &apos;auth.forgotPassword&apos;)]
    public function forgotPassword(ForgotPasswordRequest $request)
    {
        $user = User::query()-&gt;where($request-&gt;only(&apos;email&apos;))-&gt;firstOrFail();
        $token = Password::createToken($user);
        $url = str_replace(
            [&apos;{token}&apos;, &apos;{email}&apos;],
            [$token, $user-&gt;email],
            $request-&gt;input(&apos;url&apos;) ?? config(&apos;app.url&apos;) . &apos;/password/reset?token={token}&amp;email={email}&apos;,
        );
        (new AnonymousNotifiable())-&gt;route(&apos;mail&apos;, $user-&gt;email)-&gt;notify(new ForgotPasswordNotification($url));
        return response()-&gt;json([&apos;message&apos; =&gt; __(&apos;Reset password link sent to your email.&apos;)]);
    }
    /**
     * Reset password
     * @unauthenticated
     */
    #[Post(&apos;resetPassword&apos;, &apos;auth.resetPassword&apos;)]
    public function resetPassword(ResetPasswordRequest $request)
    {
        $user = User::whereEmail($request-&gt;only(&apos;email&apos;))-&gt;firstOrFail();
        if (!Password::getRepository()-&gt;exists($user, $request-&gt;input(&apos;token&apos;))) {
            abort(400, &apos;Provided invalid token.&apos;);
        }
        $user-&gt;password = Hash::make($request-&gt;input(&apos;password&apos;));
        $user-&gt;saveOrFail();
        Password::deleteToken($user);
        return response()-&gt;json([&apos;message&apos; =&gt; &apos;Password reset successfully.&apos;]);
    }
    /**
     * Verify email
     * @unauthenticated
     */
    #[Post(&apos;verify/{id}/{hash}&apos;, &apos;auth.verifyEmail&apos;)]
    public function verify(int $id, string $hash)
    {
        $user = User::query()-&gt;findOrFail($id);
        if (method_exists($user, &apos;createToken&apos;) &amp;&amp; !hash_equals((string)$hash, sha1($user-&gt;getEmailForVerification()))) {
            throw new \Exception(&apos;Invalid hash&apos;);
        }
        if ($user instanceof MustVerifyEmail &amp;&amp; $user-&gt;markEmailAsVerified()) {
            event(new Verified($user));
        }
        return new UserResource($user);
    }
    /**
     * Logout
     *
     * Invalidates the current session
     */
    #[Post(&apos;logout&apos;, &apos;auth.logout&apos;, [&apos;auth:sanctum&apos;])]
    public function logout(LogoutRequest $request)
    {
        $accessToken = $request-&gt;user()-&gt;currentAccessToken()-&gt;token;
        if ($accessToken) {
            RevokeTokenJob::dispatch($accessToken);
        }
        $refreshToken = $request-&gt;get(&apos;refreshToken&apos;);
        if ($refreshToken) {
            RevokeTokenJob::dispatch($refreshToken);
        }
        return response(null, Response::HTTP_NO_CONTENT);
    }
}</file><file path="resources/app/App.tsx">import { BrowserRouter } from &apos;react-router-dom&apos;;
import &apos;@fontsource-variable/inter&apos;;
import &apos;@fontsource-variable/source-code-pro&apos;;
import { AppRoutes } from &apos;@/routes&apos;;
import { ReactQueryDevtools } from &apos;@tanstack/react-query-devtools&apos;;
import { MusicSourceProvider } from &apos;@/providers/music-source-provider&apos;;
import { HelmetProvider } from &apos;react-helmet-async&apos;;
import { Button, Text, Theme } from &apos;@radix-ui/themes&apos;;
import { Toast } from &apos;radix-ui&apos;;
import { useAppDispatch, useAppSelector } from &apos;@/store/hooks.ts&apos;;
import styles from &apos;./app.module.scss&apos;;
import { removeToast } from &apos;@/store/notifications/notifications-slice.ts&apos;;
import { Iconify } from &apos;./ui/icons/iconify&apos;;
import { useEffect } from &apos;react&apos;;
import { apm } from &apos;@/services/apm.ts&apos;;
import { useApmRouteTracking } from &apos;@/hooks/use-apm-route-tracking&apos;;
import { ApmErrorBoundary } from &apos;@/components/apm/apm-error-boundary&apos;;
import { withApmInstrumentation } from &apos;@/components/apm/with-apm-instrumentation&apos;;
// Create a wrapper component that uses the hook
function AppWithRouteTracking() {
  useApmRouteTracking();
  return (
    &lt;ApmErrorBoundary&gt;
      &lt;AppRoutes /&gt;
    &lt;/ApmErrorBoundary&gt;
  );
}
// Instrument the main app component
const InstrumentedApp = withApmInstrumentation(function App() {
  const { toasts } = useAppSelector(state =&gt; state.notifications);
  const { theme } = useAppSelector(state =&gt; state.ui);
  const { user } = useAppSelector(state =&gt; state.auth);
  const dispatch = useAppDispatch();
  useEffect(() =&gt; {
    if (user) {
      apm.setUserContext({
        email: user.email,
        username: user.name,
      });
    } else {
      apm.setUserContext({
        email: undefined,
        username: undefined,
      })
    }
  }, [user]);
  const dispatchRemoveToast = (id: string) =&gt; {
    dispatch(removeToast({ id }));
  };
  return (
    &lt;HelmetProvider&gt;
      &lt;Theme
        accentColor=&quot;red&quot;
        panelBackground=&quot;solid&quot;
        radius=&quot;full&quot;
        appearance={theme}
      &gt;
        &lt;MusicSourceProvider&gt;
          &lt;BrowserRouter&gt;
            &lt;AppWithRouteTracking /&gt;
          &lt;/BrowserRouter&gt;
          &lt;ReactQueryDevtools/&gt;
          &lt;Toast.Root&gt;&lt;/Toast.Root&gt;
        &lt;/MusicSourceProvider&gt;
        {toasts.map((toast) =&gt; (
          &lt;Toast.Root
            key={toast.id}
            duration={toast.duration}
            className={styles.ToastRoot}
            onOpenChange={(isOpen) =&gt; {
              if (!isOpen) dispatchRemoveToast(toast.id);
            }}
          &gt;
            {toast.title &amp;&amp; (&lt;Toast.Title className={styles.ToastTitle}&gt;{toast.title}&lt;/Toast.Title&gt;)}
            &lt;Toast.Description className={styles.ToastDescription}&gt;
              &lt;Text&gt;{toast.message}&lt;/Text&gt;
            &lt;/Toast.Description&gt;
            &lt;Toast.Action
              className={styles.ToastAction}
              altText=&quot;Clear&quot;
              asChild
            &gt;
              &lt;Button variant=&quot;ghost&quot;&gt;
                &lt;Iconify icon=&quot;ion:close&quot;/&gt;
              &lt;/Button&gt;
            &lt;/Toast.Action&gt;
          &lt;/Toast.Root&gt;
        ))}
        &lt;Toast.Viewport className={styles.ToastViewport}/&gt;
      &lt;/Theme&gt;
    &lt;/HelmetProvider&gt;
  );
}, &apos;App&apos;);
export default InstrumentedApp;</file><file path="resources/app/routes/protected.tsx">import { RootLayout } from &apos;@/layouts/root-layout/root-layout.tsx&apos;;
import { Navigate, Outlet, RouteObject } from &apos;react-router-dom&apos;;
import { Suspense } from &apos;react&apos;;
import { LibraryMusicRoutes } from &apos;@/modules/library-music/routes/_routes.tsx&apos;;
import { DashboardLayout } from &apos;@/layouts/dashboard-layout/dashboard-layout.tsx&apos;;
import { DashboardRoutes } from &apos;@/modules/dashboard/routes.tsx&apos;;
import { AudioPlayerContextProvider } from &apos;@/modules/library-music-player/providers/audio-player-provider.tsx&apos;;
import { UserSettingsRoutes } from &apos;@/modules/user-settings/routes.tsx&apos;;
import { useLibraryServiceGetApiLibrariesBySlug } from &apos;@/api-client/queries&apos;;
import { usePathParam } from &apos;@/hooks/use-path-param.ts&apos;;
import { LibraryMoviesRoutes } from &apos;@/modules/library-movies/routes/_routes.tsx&apos;;
import { LibraryType } from &apos;@/models/library-type.ts&apos;;
import { Overview } from &apos;@/modules/overview/overview.tsx&apos;;
import { LibraryMusicPlaylistsRoutes } from &apos;@/modules/library-music-playlists/_routes.tsx&apos;;
const App = () =&gt; {
  return (
    &lt;AudioPlayerContextProvider&gt;
      &lt;RootLayout&gt;
        &lt;Suspense&gt;
          &lt;Outlet/&gt;
        &lt;/Suspense&gt;
      &lt;/RootLayout&gt;
    &lt;/AudioPlayerContextProvider&gt;
  );
};
const DashboardApp = () =&gt; {
  return (
    &lt;DashboardLayout&gt;
      &lt;Suspense&gt;
        &lt;Outlet/&gt;
      &lt;/Suspense&gt;
    &lt;/DashboardLayout&gt;
  );
};
const LibraryRoutes = () =&gt; {
  const { library } = usePathParam&lt;{ library: string }&gt;();
  const { data: libraryData, failureReason, isLoading } = useLibraryServiceGetApiLibrariesBySlug({ slug: library });
  if (isLoading) return &lt;div&gt;Loading...&lt;/div&gt;;
  if (failureReason) return &lt;div&gt;Error: {failureReason as string}&lt;/div&gt;;
  switch (libraryData?.type) {
    case LibraryType.Music:
      return &lt;LibraryMusicRoutes/&gt;;
    case LibraryType.Movie:
      return &lt;LibraryMoviesRoutes/&gt;;
    default:
      return &lt;Navigate to=&quot;/&quot;/&gt;;
  }
};
export const protectedRoutes: RouteObject[] = [
  {
    path: &apos;/&apos;,
    element: &lt;App/&gt;,
    children: [
      {
        path: &apos;/&apos;,
        element: &lt;Overview title=&quot;Albums&quot; /&gt;
      },
      {
        path: &apos;/library/:library/*&apos;,
        element: &lt;LibraryRoutes/&gt;,
      },
      {
        path: &apos;/playlists/music/*&apos;,
        element: &lt;LibraryMusicPlaylistsRoutes /&gt;
      },
      {
        path: &apos;/user/settings/*&apos;,
        element: &lt;UserSettingsRoutes/&gt;,
      },
      {
        path: &apos;*&apos;,
        element: &lt;Navigate to=&quot;/&quot;/&gt;,
      },
    ],
  },
  {
    path: &apos;/dashboard&apos;,
    element: &lt;DashboardApp/&gt;,
    children: [
      {
        path: &apos;*&apos;,
        element: &lt;DashboardRoutes/&gt;,
      },
    ],
  },
  {
    path: &apos;/*&apos;,
    element: &lt;Navigate to=&quot;/&quot;/&gt;,
  },
];</file><file path="app/Models/Album.php">&lt;?php
namespace App\Models;
use App\Models\Concerns\HasLibraryAccess;
use App\Modules\Eloquent\BaseBuilder;
use App\Modules\Translation\LocaleString;
use Illuminate\Database\Eloquent\Factories\HasFactory;
use Illuminate\Database\Eloquent\Relations\MorphOne;
use Overtrue\LaravelVersionable\Versionable;
use Spatie\Sluggable\{HasSlug, SlugOptions};
class Album extends BaseModel
{
    use HasFactory, HasLibraryAccess, HasSlug, Versionable;
    public static array $filterFields = [
        &apos;title&apos;,
        &apos;slug&apos;,
        &apos;year&apos;,
        &apos;directory&apos;,
    ];
    public static array $filterRelations = [
        &apos;artists&apos;,
        &apos;cover&apos;,
        &apos;library&apos;,
        &apos;songs&apos;,
        &apos;songs.genres&apos;,
    ];
    public static array $advancedFilters = [
        &apos;genres&apos;,
    ];
    protected $fillable = [
        &apos;title&apos;,
        &apos;slug&apos;,
        &apos;year&apos;,
        &apos;mbid&apos;,
        &apos;discogs_id&apos;,
    ];
    protected $versionable = [
        &apos;title&apos;,
        &apos;year&apos;,
    ];
    protected $perPage = 60;
    /**
     * Get the options for generating the slug.
     */
    public function getSlugOptions(): SlugOptions
    {
        return SlugOptions::create()
            -&gt;generateSlugsFrom([&apos;title&apos;, &apos;year&apos;])
            -&gt;saveSlugsTo(&apos;slug&apos;);
    }
    public function getRouteKeyName(): string
    {
        return &apos;slug&apos;;
    }
    public function getTitleAttribute()
    {
        $title = $this-&gt;attributes[&apos;title&apos;];
        if (LocaleString::isLocaleString($title)) {
            return __(LocaleString::removeDelimiters($title));
        }
        return $title;
    }
    public function artists()
    {
        return $this-&gt;belongsToMany(Artist::class)
            -&gt;using(AlbumArtist::class);
    }
    public function cover(): MorphOne
    {
        return $this-&gt;morphOne(Image::class, &apos;imageable&apos;);
    }
    public function library()
    {
        return $this-&gt;belongsTo(Library::class);
    }
    public function songs()
    {
        return $this-&gt;hasMany(Song::class)-&gt;orderByNullsLast(&apos;track&apos;);
    }
    protected function scopeWhereGenreNames(BaseBuilder $q, array $names)
    {
        return $q-&gt;whereHas(&apos;songs&apos;, function ($q) use ($names) {
            $q-&gt;whereHas(&apos;genres&apos;, function ($q) use ($names) {
                $q-&gt;whereIn(&apos;name&apos;, $names);
            });
        });
    }
}</file><file path="app/Models/Song.php">&lt;?php
namespace App\Models;
use App\Models\Concerns\HasLibraryAccess;
use App\Modules\Eloquent\BaseBuilder;
use App\Modules\Http\Concerns\DirectStreamableFile;
use App\Modules\Nanoid\Concerns\HasNanoPublicId;
use App\Modules\Recommendation\Concerns\Recommendable;
use App\Modules\Recommendation\HasRecommendation;
use Illuminate\Database\Eloquent\Factories\HasFactory;
/**
 * @property string $librarySlug Available in SongController
 */
class Song extends BaseModel implements DirectStreamableFile, Recommendable
{
    use HasFactory, HasLibraryAccess, HasNanoPublicId, HasRecommendation;
    public static array $filterRelations = [
        &apos;album&apos;,
        &apos;album.cover&apos;,
        &apos;artists&apos;,
        &apos;genres&apos;,
    ];
    protected $perPage = 30;
    protected $with = [&apos;album&apos;];
    protected $fillable = [
        &apos;public_id&apos;,
        &apos;album_id&apos;,
        &apos;title&apos;,
        &apos;path&apos;,
        &apos;size&apos;,
        &apos;mime_type&apos;,
        &apos;length&apos;,
        &apos;lyrics&apos;,
        &apos;track&apos;,
        &apos;disc&apos;,
        &apos;modified_time&apos;,
        &apos;year&apos;,
        &apos;comment&apos;,
        &apos;hash&apos;,
        &apos;librarySlug&apos;,
        &apos;mbid&apos;,
        &apos;discogs_id&apos;,
    ];
    public function getRouteKeyName(): string
    {
        return &apos;public_id&apos;;
    }
    public function getPath(): string
    {
        return $this-&gt;path;
    }
    public function getSize(): int
    {
        return $this-&gt;size;
    }
    public function getMimeType(): string
    {
        return $this-&gt;mime_type;
    }
    public static function getRecommendationConfig(): array
    {
        return [
            &apos;same_genre&apos; =&gt; [
                &apos;algorithm&apos;       =&gt; &apos;db_relation&apos;,
                &apos;data_table&apos;      =&gt; &apos;genre_song&apos;,
                &apos;data_field&apos;      =&gt; &apos;song_id&apos;,
                &apos;data_field_type&apos; =&gt; self::class,
                &apos;group_field&apos;     =&gt; &apos;genre_id&apos;,
                &apos;count&apos;           =&gt; 10,
            ],
        ];
    }
    public function album()
    {
        return $this-&gt;belongsTo(Album::class);
    }
    public function artists()
    {
        return $this-&gt;belongsToMany(Artist::class)
            -&gt;using(ArtistSong::class);
    }
    public function userMediaActivies()
    {
        return $this-&gt;morphToMany(UserMediaActivity::class, &apos;userMediaActivityable&apos;);
    }
    public function genres()
    {
        return $this-&gt;belongsToMany(Genre::class)
            -&gt;using(GenreSong::class);
    }
    protected function scopeWhereGenreNames(BaseBuilder $q, array $names)
    {
        return $q-&gt;whereHas(&apos;genres&apos;, function ($q) use ($names) {
            $q-&gt;whereIn(&apos;name&apos;, $names);
        });
    }
    protected function scopeWhereGenreSlugs(BaseBuilder $q, array $slugs)
    {
        return $q-&gt;whereHas(&apos;genres&apos;, function ($q) use ($slugs) {
            $q-&gt;whereIn(&apos;name&apos;, $slugs);
        });
    }
}</file><file path="package.json">{
    &quot;name&quot;: &quot;baander&quot;,
    &quot;version&quot;: &quot;1.0.0&quot;,
    &quot;private&quot;: true,
    &quot;license&quot;: &quot;Apache-2.0&quot;,
    &quot;scripts&quot;: {
        &quot;clean&quot;: &quot;rimraf public/build&quot;,
        &quot;build&quot;: &quot;yarn clean &amp;&amp; tsc &amp;&amp; vite build&quot;,
        &quot;dev&quot;: &quot;yarn clean &amp;&amp; vite&quot;,
        &quot;generate-api-client&quot;: &quot;openapi-rq -i ./api.json -c axios --initialPageParam=1 --nextPageParam=nextPage -o resources/app/api-client&quot;
    },
    &quot;dependencies&quot;: {
        &quot;@elastic/apm-rum&quot;: &quot;^5.17.0&quot;,
        &quot;@fontsource-variable/inter&quot;: &quot;^5.1.1&quot;,
        &quot;@fontsource-variable/source-code-pro&quot;: &quot;^5.1.0&quot;,
        &quot;@fontsource/open-sans&quot;: &quot;^5.1.0&quot;,
        &quot;@microlink/react-json-view&quot;: &quot;^1.23.3&quot;,
        &quot;@radix-ui/colors&quot;: &quot;^3.0.0&quot;,
        &quot;@radix-ui/react-icons&quot;: &quot;^1.3.2&quot;,
        &quot;@radix-ui/themes&quot;: &quot;^3.2.1&quot;,
        &quot;@reduxjs/toolkit&quot;: &quot;^2.5.1&quot;,
        &quot;@simplewebauthn/browser&quot;: &quot;^10.0.0&quot;,
        &quot;@tabler/icons-react&quot;: &quot;^3.29.0&quot;,
        &quot;@tanstack/react-query&quot;: &quot;^5.65.1&quot;,
        &quot;@tanstack/react-query-devtools&quot;: &quot;^5.65.1&quot;,
        &quot;@tanstack/react-query-persist-client&quot;: &quot;^5.65.1&quot;,
        &quot;@tanstack/react-table&quot;: &quot;^8.20.6&quot;,
        &quot;@tanstack/react-virtual&quot;: &quot;^3.13.8&quot;,
        &quot;@visx/hierarchy&quot;: &quot;^3.12.0&quot;,
        &quot;@visx/zoom&quot;: &quot;^3.12.0&quot;,
        &quot;ahooks&quot;: &quot;^3.8.4&quot;,
        &quot;axios&quot;: &quot;^1.7.9&quot;,
        &quot;dashjs&quot;: &quot;^5.0.3&quot;,
        &quot;dayjs&quot;: &quot;^1.11.13&quot;,
        &quot;embla-carousel&quot;: &quot;^8.6.0&quot;,
        &quot;embla-carousel-react&quot;: &quot;^8.5.2&quot;,
        &quot;fast-blurhash&quot;: &quot;^1.1.4&quot;,
        &quot;hls.js&quot;: &quot;^1.6.5&quot;,
        &quot;i18next&quot;: &quot;^24.2.2&quot;,
        &quot;i18next-browser-languagedetector&quot;: &quot;^8.0.2&quot;,
        &quot;idb-keyval&quot;: &quot;^6.2.1&quot;,
        &quot;konva&quot;: &quot;^9.3.18&quot;,
        &quot;motion&quot;: &quot;^12.10.5&quot;,
        &quot;nanoid&quot;: &quot;^5.0.9&quot;,
        &quot;overlayscrollbars&quot;: &quot;^2.10.1&quot;,
        &quot;overlayscrollbars-react&quot;: &quot;^0.5.6&quot;,
        &quot;radix-ui&quot;: &quot;^1.4.1&quot;,
        &quot;react&quot;: &quot;^19.0.0&quot;,
        &quot;react-cookie&quot;: &quot;^7.2.2&quot;,
        &quot;react-dom&quot;: &quot;^19.0.0&quot;,
        &quot;react-error-boundary&quot;: &quot;^5.0.0&quot;,
        &quot;react-helmet&quot;: &quot;^6.1.0&quot;,
        &quot;react-helmet-async&quot;: &quot;^2.0.5&quot;,
        &quot;react-hook-form&quot;: &quot;^7.54.2&quot;,
        &quot;react-i18next&quot;: &quot;^15.4.0&quot;,
        &quot;react-konva&quot;: &quot;^19.0.2&quot;,
        &quot;react-lottie-player&quot;: &quot;^2.1.0&quot;,
        &quot;react-redux&quot;: &quot;^9.2.0&quot;,
        &quot;react-rnd&quot;: &quot;^10.4.14&quot;,
        &quot;react-router-dom&quot;: &quot;^7.1.3&quot;,
        &quot;react-virtuoso&quot;: &quot;^4.12.3&quot;,
        &quot;redux-persist&quot;: &quot;^6.0.0&quot;,
        &quot;wavesurfer.js&quot;: &quot;^7.9.0&quot;,
        &quot;ziggy-js&quot;: &quot;^2.5.0&quot;
    },
    &quot;devDependencies&quot;: {
        &quot;@7nohe/openapi-react-query-codegen&quot;: &quot;^1.6.2&quot;,
        &quot;@hookform/devtools&quot;: &quot;^4.4.0&quot;,
        &quot;@iconify/react&quot;: &quot;^5.2.0&quot;,
        &quot;@types/node&quot;: &quot;^22.12.0&quot;,
        &quot;@types/react&quot;: &quot;^19.0.8&quot;,
        &quot;@types/react-dom&quot;: &quot;^19.0.3&quot;,
        &quot;@types/react-helmet&quot;: &quot;^6.1.11&quot;,
        &quot;@vitejs/plugin-react&quot;: &quot;^4.3.4&quot;,
        &quot;babel-plugin-react-compiler&quot;: &quot;^19.0.0-beta-27714ef-20250124&quot;,
        &quot;chokidar&quot;: &quot;^4.0.3&quot;,
        &quot;laravel-vite-plugin&quot;: &quot;^1.2.0&quot;,
        &quot;postcss&quot;: &quot;^8.5.1&quot;,
        &quot;postcss-simple-vars&quot;: &quot;^7.0.1&quot;,
        &quot;resolve-url-loader&quot;: &quot;^5.0.0&quot;,
        &quot;rimraf&quot;: &quot;^6.0.1&quot;,
        &quot;rollup-plugin-visualizer&quot;: &quot;^5.14.0&quot;,
        &quot;sass-embedded&quot;: &quot;^1.83.4&quot;,
        &quot;sass-loader&quot;: &quot;^16.0.4&quot;,
        &quot;ts-morph&quot;: &quot;^23.0.0&quot;,
        &quot;typescript&quot;: &quot;^5.7.3&quot;,
        &quot;unplugin-info&quot;: &quot;^1.2.1&quot;,
        &quot;vite&quot;: &quot;^6.0.11&quot;,
        &quot;vite-plugin-filter-replace&quot;: &quot;^0.1.13&quot;,
        &quot;vite-plugin-laravel-translations&quot;: &quot;^0.2.2&quot;,
        &quot;vite-plugin-manifest-sri&quot;: &quot;^0.2.0&quot;,
        &quot;vite-plugin-optimize-css-modules&quot;: &quot;^1.2.0&quot;,
        &quot;vite-plugin-react-rich-svg&quot;: &quot;^1.2.0&quot;,
        &quot;vite-plugin-watch-and-run&quot;: &quot;^1.7.3&quot;
    }
}</file><file path="resources/app/api-client/queries/common.ts">// generated with @7nohe/openapi-react-query-codegen@1.6.2 
import { UseQueryResult } from &quot;@tanstack/react-query&quot;;
import { AlbumService, ArtistService, AuthService, BatchesService, CompletedJobsService, DashboardStatsService, FailedJobsService, FilesService, FoldersService, GenreService, HostsService, ImageService, JobMetricsService, JobService, JobsService, LibraryService, LogsService, MasterSupervisorService, MonitoringService, MovieService, OpCacheService, PasskeyService, PendingJobsService, PlaylistService, QueueMetricsService, QueueService, RetryService, SchemaService, SilencedJobsService, SongService, StreamService, SystemInfoService, UserService, UserTokenService, WorkloadService } from &quot;../requests/services.gen&quot;;
export type AlbumServiceGetApiLibrariesByLibraryAlbumsDefaultResponse = Awaited&lt;ReturnType&lt;typeof AlbumService.getApiLibrariesByLibraryAlbums&gt;&gt;;
export type AlbumServiceGetApiLibrariesByLibraryAlbumsQueryResult&lt;TData = AlbumServiceGetApiLibrariesByLibraryAlbumsDefaultResponse, TError = unknown&gt; = UseQueryResult&lt;TData, TError&gt;;
export const useAlbumServiceGetApiLibrariesByLibraryAlbumsKey = &quot;AlbumServiceGetApiLibrariesByLibraryAlbums&quot;;
export const UseAlbumServiceGetApiLibrariesByLibraryAlbumsKeyFn = ({ fields, genres, library, limit, page, relations }: {
  fields?: string;
  genres?: string;
  library: string;
  limit?: number;
  page?: number;
  relations?: string;
}, queryKey?: Array&lt;unknown&gt;) =&gt; [useAlbumServiceGetApiLibrariesByLibraryAlbumsKey, ...(queryKey ?? [{ fields, genres, library, limit, page, relations }])];
export type AlbumServiceGetApiLibrariesByLibraryAlbumsByAlbumDefaultResponse = Awaited&lt;ReturnType&lt;typeof AlbumService.getApiLibrariesByLibraryAlbumsByAlbum&gt;&gt;;
export type AlbumServiceGetApiLibrariesByLibraryAlbumsByAlbumQueryResult&lt;TData = AlbumServiceGetApiLibrariesByLibraryAlbumsByAlbumDefaultResponse, TError = unknown&gt; = UseQueryResult&lt;TData, TError&gt;;
export const useAlbumServiceGetApiLibrariesByLibraryAlbumsByAlbumKey = &quot;AlbumServiceGetApiLibrariesByLibraryAlbumsByAlbum&quot;;
export const UseAlbumServiceGetApiLibrariesByLibraryAlbumsByAlbumKeyFn = ({ album, library }: {
  album: string;
  library: string;
}, queryKey?: Array&lt;unknown&gt;) =&gt; [useAlbumServiceGetApiLibrariesByLibraryAlbumsByAlbumKey, ...(queryKey ?? [{ album, library }])];
export type ArtistServiceGetApiLibrariesByLibraryArtistsDefaultResponse = Awaited&lt;ReturnType&lt;typeof ArtistService.getApiLibrariesByLibraryArtists&gt;&gt;;
export type ArtistServiceGetApiLibrariesByLibraryArtistsQueryResult&lt;TData = ArtistServiceGetApiLibrariesByLibraryArtistsDefaultResponse, TError = unknown&gt; = UseQueryResult&lt;TData, TError&gt;;
export const useArtistServiceGetApiLibrariesByLibraryArtistsKey = &quot;ArtistServiceGetApiLibrariesByLibraryArtists&quot;;
export const UseArtistServiceGetApiLibrariesByLibraryArtistsKeyFn = ({ fields, genres, library, limit, page, relations }: {
  fields?: string;
  genres?: string;
  library: string;
  limit?: number;
  page?: number;
  relations?: string;
}, queryKey?: Array&lt;unknown&gt;) =&gt; [useArtistServiceGetApiLibrariesByLibraryArtistsKey, ...(queryKey ?? [{ fields, genres, library, limit, page, relations }])];
export type ArtistServiceGetApiLibrariesByLibraryArtistsByArtistDefaultResponse = Awaited&lt;ReturnType&lt;typeof ArtistService.getApiLibrariesByLibraryArtistsByArtist&gt;&gt;;
export type ArtistServiceGetApiLibrariesByLibraryArtistsByArtistQueryResult&lt;TData = ArtistServiceGetApiLibrariesByLibraryArtistsByArtistDefaultResponse, TError = unknown&gt; = UseQueryResult&lt;TData, TError&gt;;
export const useArtistServiceGetApiLibrariesByLibraryArtistsByArtistKey = &quot;ArtistServiceGetApiLibrariesByLibraryArtistsByArtist&quot;;
export const UseArtistServiceGetApiLibrariesByLibraryArtistsByArtistKeyFn = ({ artist, library }: {
  artist: string;
  library: string;
}, queryKey?: Array&lt;unknown&gt;) =&gt; [useArtistServiceGetApiLibrariesByLibraryArtistsByArtistKey, ...(queryKey ?? [{ artist, library }])];
export type AuthServiceGetWebauthnPasskeyDefaultResponse = Awaited&lt;ReturnType&lt;typeof AuthService.getWebauthnPasskey&gt;&gt;;
export type AuthServiceGetWebauthnPasskeyQueryResult&lt;TData = AuthServiceGetWebauthnPasskeyDefaultResponse, TError = unknown&gt; = UseQueryResult&lt;TData, TError&gt;;
export const useAuthServiceGetWebauthnPasskeyKey = &quot;AuthServiceGetWebauthnPasskey&quot;;
export const UseAuthServiceGetWebauthnPasskeyKeyFn = (queryKey?: Array&lt;unknown&gt;) =&gt; [useAuthServiceGetWebauthnPasskeyKey, ...(queryKey ?? [])];
export type AuthServiceGetWebauthnPasskeyRegisterDefaultResponse = Awaited&lt;ReturnType&lt;typeof AuthService.getWebauthnPasskeyRegister&gt;&gt;;
export type AuthServiceGetWebauthnPasskeyRegisterQueryResult&lt;TData = AuthServiceGetWebauthnPasskeyRegisterDefaultResponse, TError = unknown&gt; = UseQueryResult&lt;TData, TError&gt;;
export const useAuthServiceGetWebauthnPasskeyRegisterKey = &quot;AuthServiceGetWebauthnPasskeyRegister&quot;;
export const UseAuthServiceGetWebauthnPasskeyRegisterKeyFn = (queryKey?: Array&lt;unknown&gt;) =&gt; [useAuthServiceGetWebauthnPasskeyRegisterKey, ...(queryKey ?? [])];
export type PasskeyServiceGetWebauthnPasskeyDefaultResponse = Awaited&lt;ReturnType&lt;typeof PasskeyService.getWebauthnPasskey&gt;&gt;;
export type PasskeyServiceGetWebauthnPasskeyQueryResult&lt;TData = PasskeyServiceGetWebauthnPasskeyDefaultResponse, TError = unknown&gt; = UseQueryResult&lt;TData, TError&gt;;
export const usePasskeyServiceGetWebauthnPasskeyKey = &quot;PasskeyServiceGetWebauthnPasskey&quot;;
export const UsePasskeyServiceGetWebauthnPasskeyKeyFn = (queryKey?: Array&lt;unknown&gt;) =&gt; [usePasskeyServiceGetWebauthnPasskeyKey, ...(queryKey ?? [])];
export type PasskeyServiceGetWebauthnPasskeyRegisterDefaultResponse = Awaited&lt;ReturnType&lt;typeof PasskeyService.getWebauthnPasskeyRegister&gt;&gt;;
export type PasskeyServiceGetWebauthnPasskeyRegisterQueryResult&lt;TData = PasskeyServiceGetWebauthnPasskeyRegisterDefaultResponse, TError = unknown&gt; = UseQueryResult&lt;TData, TError&gt;;
export const usePasskeyServiceGetWebauthnPasskeyRegisterKey = &quot;PasskeyServiceGetWebauthnPasskeyRegister&quot;;
export const UsePasskeyServiceGetWebauthnPasskeyRegisterKeyFn = (queryKey?: Array&lt;unknown&gt;) =&gt; [usePasskeyServiceGetWebauthnPasskeyRegisterKey, ...(queryKey ?? [])];
export type BatchesServiceGetHorizonApiBatchesDefaultResponse = Awaited&lt;ReturnType&lt;typeof BatchesService.getHorizonApiBatches&gt;&gt;;
export type BatchesServiceGetHorizonApiBatchesQueryResult&lt;TData = BatchesServiceGetHorizonApiBatchesDefaultResponse, TError = unknown&gt; = UseQueryResult&lt;TData, TError&gt;;
export const useBatchesServiceGetHorizonApiBatchesKey = &quot;BatchesServiceGetHorizonApiBatches&quot;;
export const UseBatchesServiceGetHorizonApiBatchesKeyFn = (queryKey?: Array&lt;unknown&gt;) =&gt; [useBatchesServiceGetHorizonApiBatchesKey, ...(queryKey ?? [])];
export type BatchesServiceGetHorizonApiBatchesByIdDefaultResponse = Awaited&lt;ReturnType&lt;typeof BatchesService.getHorizonApiBatchesById&gt;&gt;;
export type BatchesServiceGetHorizonApiBatchesByIdQueryResult&lt;TData = BatchesServiceGetHorizonApiBatchesByIdDefaultResponse, TError = unknown&gt; = UseQueryResult&lt;TData, TError&gt;;
export const useBatchesServiceGetHorizonApiBatchesByIdKey = &quot;BatchesServiceGetHorizonApiBatchesById&quot;;
export const UseBatchesServiceGetHorizonApiBatchesByIdKeyFn = ({ id }: {
  id: string;
}, queryKey?: Array&lt;unknown&gt;) =&gt; [useBatchesServiceGetHorizonApiBatchesByIdKey, ...(queryKey ?? [{ id }])];
export type CompletedJobsServiceGetHorizonApiJobsCompletedDefaultResponse = Awaited&lt;ReturnType&lt;typeof CompletedJobsService.getHorizonApiJobsCompleted&gt;&gt;;
export type CompletedJobsServiceGetHorizonApiJobsCompletedQueryResult&lt;TData = CompletedJobsServiceGetHorizonApiJobsCompletedDefaultResponse, TError = unknown&gt; = UseQueryResult&lt;TData, TError&gt;;
export const useCompletedJobsServiceGetHorizonApiJobsCompletedKey = &quot;CompletedJobsServiceGetHorizonApiJobsCompleted&quot;;
export const UseCompletedJobsServiceGetHorizonApiJobsCompletedKeyFn = ({ startingAt }: {
  startingAt?: string;
} = {}, queryKey?: Array&lt;unknown&gt;) =&gt; [useCompletedJobsServiceGetHorizonApiJobsCompletedKey, ...(queryKey ?? [{ startingAt }])];
export type DashboardStatsServiceGetHorizonApiStatsDefaultResponse = Awaited&lt;ReturnType&lt;typeof DashboardStatsService.getHorizonApiStats&gt;&gt;;
export type DashboardStatsServiceGetHorizonApiStatsQueryResult&lt;TData = DashboardStatsServiceGetHorizonApiStatsDefaultResponse, TError = unknown&gt; = UseQueryResult&lt;TData, TError&gt;;
export const useDashboardStatsServiceGetHorizonApiStatsKey = &quot;DashboardStatsServiceGetHorizonApiStats&quot;;
export const UseDashboardStatsServiceGetHorizonApiStatsKeyFn = (queryKey?: Array&lt;unknown&gt;) =&gt; [useDashboardStatsServiceGetHorizonApiStatsKey, ...(queryKey ?? [])];
export type FailedJobsServiceGetHorizonApiJobsFailedDefaultResponse = Awaited&lt;ReturnType&lt;typeof FailedJobsService.getHorizonApiJobsFailed&gt;&gt;;
export type FailedJobsServiceGetHorizonApiJobsFailedQueryResult&lt;TData = FailedJobsServiceGetHorizonApiJobsFailedDefaultResponse, TError = unknown&gt; = UseQueryResult&lt;TData, TError&gt;;
export const useFailedJobsServiceGetHorizonApiJobsFailedKey = &quot;FailedJobsServiceGetHorizonApiJobsFailed&quot;;
export const UseFailedJobsServiceGetHorizonApiJobsFailedKeyFn = ({ tag }: {
  tag?: string;
} = {}, queryKey?: Array&lt;unknown&gt;) =&gt; [useFailedJobsServiceGetHorizonApiJobsFailedKey, ...(queryKey ?? [{ tag }])];
export type FailedJobsServiceGetHorizonApiJobsFailedByIdDefaultResponse = Awaited&lt;ReturnType&lt;typeof FailedJobsService.getHorizonApiJobsFailedById&gt;&gt;;
export type FailedJobsServiceGetHorizonApiJobsFailedByIdQueryResult&lt;TData = FailedJobsServiceGetHorizonApiJobsFailedByIdDefaultResponse, TError = unknown&gt; = UseQueryResult&lt;TData, TError&gt;;
export const useFailedJobsServiceGetHorizonApiJobsFailedByIdKey = &quot;FailedJobsServiceGetHorizonApiJobsFailedById&quot;;
export const UseFailedJobsServiceGetHorizonApiJobsFailedByIdKeyFn = ({ id }: {
  id: string;
}, queryKey?: Array&lt;unknown&gt;) =&gt; [useFailedJobsServiceGetHorizonApiJobsFailedByIdKey, ...(queryKey ?? [{ id }])];
export type FilesServiceGetSystemLogViewerApiFilesDefaultResponse = Awaited&lt;ReturnType&lt;typeof FilesService.getSystemLogViewerApiFiles&gt;&gt;;
export type FilesServiceGetSystemLogViewerApiFilesQueryResult&lt;TData = FilesServiceGetSystemLogViewerApiFilesDefaultResponse, TError = unknown&gt; = UseQueryResult&lt;TData, TError&gt;;
export const useFilesServiceGetSystemLogViewerApiFilesKey = &quot;FilesServiceGetSystemLogViewerApiFiles&quot;;
export const UseFilesServiceGetSystemLogViewerApiFilesKeyFn = (queryKey?: Array&lt;unknown&gt;) =&gt; [useFilesServiceGetSystemLogViewerApiFilesKey, ...(queryKey ?? [])];
export type FilesServiceGetSystemLogViewerApiFilesByFileIdentifierDownloadRequestDefaultResponse = Awaited&lt;ReturnType&lt;typeof FilesService.getSystemLogViewerApiFilesByFileIdentifierDownloadRequest&gt;&gt;;
export type FilesServiceGetSystemLogViewerApiFilesByFileIdentifierDownloadRequestQueryResult&lt;TData = FilesServiceGetSystemLogViewerApiFilesByFileIdentifierDownloadRequestDefaultResponse, TError = unknown&gt; = UseQueryResult&lt;TData, TError&gt;;
export const useFilesServiceGetSystemLogViewerApiFilesByFileIdentifierDownloadRequestKey = &quot;FilesServiceGetSystemLogViewerApiFilesByFileIdentifierDownloadRequest&quot;;
export const UseFilesServiceGetSystemLogViewerApiFilesByFileIdentifierDownloadRequestKeyFn = ({ fileIdentifier }: {
  fileIdentifier: string;
}, queryKey?: Array&lt;unknown&gt;) =&gt; [useFilesServiceGetSystemLogViewerApiFilesByFileIdentifierDownloadRequestKey, ...(queryKey ?? [{ fileIdentifier }])];
export type FilesServiceGetSystemLogViewerApiFilesByFileIdentifierDownloadDefaultResponse = Awaited&lt;ReturnType&lt;typeof FilesService.getSystemLogViewerApiFilesByFileIdentifierDownload&gt;&gt;;
export type FilesServiceGetSystemLogViewerApiFilesByFileIdentifierDownloadQueryResult&lt;TData = FilesServiceGetSystemLogViewerApiFilesByFileIdentifierDownloadDefaultResponse, TError = unknown&gt; = UseQueryResult&lt;TData, TError&gt;;
export const useFilesServiceGetSystemLogViewerApiFilesByFileIdentifierDownloadKey = &quot;FilesServiceGetSystemLogViewerApiFilesByFileIdentifierDownload&quot;;
export const UseFilesServiceGetSystemLogViewerApiFilesByFileIdentifierDownloadKeyFn = ({ fileIdentifier }: {
  fileIdentifier: string;
}, queryKey?: Array&lt;unknown&gt;) =&gt; [useFilesServiceGetSystemLogViewerApiFilesByFileIdentifierDownloadKey, ...(queryKey ?? [{ fileIdentifier }])];
export type FoldersServiceGetSystemLogViewerApiFoldersDefaultResponse = Awaited&lt;ReturnType&lt;typeof FoldersService.getSystemLogViewerApiFolders&gt;&gt;;
export type FoldersServiceGetSystemLogViewerApiFoldersQueryResult&lt;TData = FoldersServiceGetSystemLogViewerApiFoldersDefaultResponse, TError = unknown&gt; = UseQueryResult&lt;TData, TError&gt;;
export const useFoldersServiceGetSystemLogViewerApiFoldersKey = &quot;FoldersServiceGetSystemLogViewerApiFolders&quot;;
export const UseFoldersServiceGetSystemLogViewerApiFoldersKeyFn = ({ direction }: {
  direction?: string;
} = {}, queryKey?: Array&lt;unknown&gt;) =&gt; [useFoldersServiceGetSystemLogViewerApiFoldersKey, ...(queryKey ?? [{ direction }])];
export type FoldersServiceGetSystemLogViewerApiFoldersByFolderIdentifierDownloadRequestDefaultResponse = Awaited&lt;ReturnType&lt;typeof FoldersService.getSystemLogViewerApiFoldersByFolderIdentifierDownloadRequest&gt;&gt;;
export type FoldersServiceGetSystemLogViewerApiFoldersByFolderIdentifierDownloadRequestQueryResult&lt;TData = FoldersServiceGetSystemLogViewerApiFoldersByFolderIdentifierDownloadRequestDefaultResponse, TError = unknown&gt; = UseQueryResult&lt;TData, TError&gt;;
export const useFoldersServiceGetSystemLogViewerApiFoldersByFolderIdentifierDownloadRequestKey = &quot;FoldersServiceGetSystemLogViewerApiFoldersByFolderIdentifierDownloadRequest&quot;;
export const UseFoldersServiceGetSystemLogViewerApiFoldersByFolderIdentifierDownloadRequestKeyFn = ({ folderIdentifier }: {
  folderIdentifier: string;
}, queryKey?: Array&lt;unknown&gt;) =&gt; [useFoldersServiceGetSystemLogViewerApiFoldersByFolderIdentifierDownloadRequestKey, ...(queryKey ?? [{ folderIdentifier }])];
export type FoldersServiceGetSystemLogViewerApiFoldersByFolderIdentifierDownloadDefaultResponse = Awaited&lt;ReturnType&lt;typeof FoldersService.getSystemLogViewerApiFoldersByFolderIdentifierDownload&gt;&gt;;
export type FoldersServiceGetSystemLogViewerApiFoldersByFolderIdentifierDownloadQueryResult&lt;TData = FoldersServiceGetSystemLogViewerApiFoldersByFolderIdentifierDownloadDefaultResponse, TError = unknown&gt; = UseQueryResult&lt;TData, TError&gt;;
export const useFoldersServiceGetSystemLogViewerApiFoldersByFolderIdentifierDownloadKey = &quot;FoldersServiceGetSystemLogViewerApiFoldersByFolderIdentifierDownload&quot;;
export const UseFoldersServiceGetSystemLogViewerApiFoldersByFolderIdentifierDownloadKeyFn = ({ folderIdentifier }: {
  folderIdentifier: string;
}, queryKey?: Array&lt;unknown&gt;) =&gt; [useFoldersServiceGetSystemLogViewerApiFoldersByFolderIdentifierDownloadKey, ...(queryKey ?? [{ folderIdentifier }])];
export type GenreServiceGetApiGenresDefaultResponse = Awaited&lt;ReturnType&lt;typeof GenreService.getApiGenres&gt;&gt;;
export type GenreServiceGetApiGenresQueryResult&lt;TData = GenreServiceGetApiGenresDefaultResponse, TError = unknown&gt; = UseQueryResult&lt;TData, TError&gt;;
export const useGenreServiceGetApiGenresKey = &quot;GenreServiceGetApiGenres&quot;;
export const UseGenreServiceGetApiGenresKeyFn = ({ fields, librarySlug, limit, page, relations }: {
  fields?: string;
  librarySlug?: string;
  limit?: number;
  page?: number;
  relations?: string;
} = {}, queryKey?: Array&lt;unknown&gt;) =&gt; [useGenreServiceGetApiGenresKey, ...(queryKey ?? [{ fields, librarySlug, limit, page, relations }])];
export type GenreServiceGetApiGenresByGenreDefaultResponse = Awaited&lt;ReturnType&lt;typeof GenreService.getApiGenresByGenre&gt;&gt;;
export type GenreServiceGetApiGenresByGenreQueryResult&lt;TData = GenreServiceGetApiGenresByGenreDefaultResponse, TError = unknown&gt; = UseQueryResult&lt;TData, TError&gt;;
export const useGenreServiceGetApiGenresByGenreKey = &quot;GenreServiceGetApiGenresByGenre&quot;;
export const UseGenreServiceGetApiGenresByGenreKeyFn = ({ genre }: {
  genre: string;
}, queryKey?: Array&lt;unknown&gt;) =&gt; [useGenreServiceGetApiGenresByGenreKey, ...(queryKey ?? [{ genre }])];
export type HostsServiceGetSystemLogViewerApiHostsDefaultResponse = Awaited&lt;ReturnType&lt;typeof HostsService.getSystemLogViewerApiHosts&gt;&gt;;
export type HostsServiceGetSystemLogViewerApiHostsQueryResult&lt;TData = HostsServiceGetSystemLogViewerApiHostsDefaultResponse, TError = unknown&gt; = UseQueryResult&lt;TData, TError&gt;;
export const useHostsServiceGetSystemLogViewerApiHostsKey = &quot;HostsServiceGetSystemLogViewerApiHosts&quot;;
export const UseHostsServiceGetSystemLogViewerApiHostsKeyFn = (queryKey?: Array&lt;unknown&gt;) =&gt; [useHostsServiceGetSystemLogViewerApiHostsKey, ...(queryKey ?? [])];
export type ImageServiceGetApiImagesByImageDefaultResponse = Awaited&lt;ReturnType&lt;typeof ImageService.getApiImagesByImage&gt;&gt;;
export type ImageServiceGetApiImagesByImageQueryResult&lt;TData = ImageServiceGetApiImagesByImageDefaultResponse, TError = unknown&gt; = UseQueryResult&lt;TData, TError&gt;;
export const useImageServiceGetApiImagesByImageKey = &quot;ImageServiceGetApiImagesByImage&quot;;
export const UseImageServiceGetApiImagesByImageKeyFn = ({ image }: {
  image: string;
}, queryKey?: Array&lt;unknown&gt;) =&gt; [useImageServiceGetApiImagesByImageKey, ...(queryKey ?? [{ image }])];
export type JobMetricsServiceGetHorizonApiMetricsJobsDefaultResponse = Awaited&lt;ReturnType&lt;typeof JobMetricsService.getHorizonApiMetricsJobs&gt;&gt;;
export type JobMetricsServiceGetHorizonApiMetricsJobsQueryResult&lt;TData = JobMetricsServiceGetHorizonApiMetricsJobsDefaultResponse, TError = unknown&gt; = UseQueryResult&lt;TData, TError&gt;;
export const useJobMetricsServiceGetHorizonApiMetricsJobsKey = &quot;JobMetricsServiceGetHorizonApiMetricsJobs&quot;;
export const UseJobMetricsServiceGetHorizonApiMetricsJobsKeyFn = (queryKey?: Array&lt;unknown&gt;) =&gt; [useJobMetricsServiceGetHorizonApiMetricsJobsKey, ...(queryKey ?? [])];
export type JobMetricsServiceGetHorizonApiMetricsJobsByIdDefaultResponse = Awaited&lt;ReturnType&lt;typeof JobMetricsService.getHorizonApiMetricsJobsById&gt;&gt;;
export type JobMetricsServiceGetHorizonApiMetricsJobsByIdQueryResult&lt;TData = JobMetricsServiceGetHorizonApiMetricsJobsByIdDefaultResponse, TError = unknown&gt; = UseQueryResult&lt;TData, TError&gt;;
export const useJobMetricsServiceGetHorizonApiMetricsJobsByIdKey = &quot;JobMetricsServiceGetHorizonApiMetricsJobsById&quot;;
export const UseJobMetricsServiceGetHorizonApiMetricsJobsByIdKeyFn = ({ id }: {
  id: string;
}, queryKey?: Array&lt;unknown&gt;) =&gt; [useJobMetricsServiceGetHorizonApiMetricsJobsByIdKey, ...(queryKey ?? [{ id }])];
export type JobsServiceGetHorizonApiJobsByIdDefaultResponse = Awaited&lt;ReturnType&lt;typeof JobsService.getHorizonApiJobsById&gt;&gt;;
export type JobsServiceGetHorizonApiJobsByIdQueryResult&lt;TData = JobsServiceGetHorizonApiJobsByIdDefaultResponse, TError = unknown&gt; = UseQueryResult&lt;TData, TError&gt;;
export const useJobsServiceGetHorizonApiJobsByIdKey = &quot;JobsServiceGetHorizonApiJobsById&quot;;
export const UseJobsServiceGetHorizonApiJobsByIdKeyFn = ({ id }: {
  id: string;
}, queryKey?: Array&lt;unknown&gt;) =&gt; [useJobsServiceGetHorizonApiJobsByIdKey, ...(queryKey ?? [{ id }])];
export type LibraryServiceGetApiLibrariesDefaultResponse = Awaited&lt;ReturnType&lt;typeof LibraryService.getApiLibraries&gt;&gt;;
export type LibraryServiceGetApiLibrariesQueryResult&lt;TData = LibraryServiceGetApiLibrariesDefaultResponse, TError = unknown&gt; = UseQueryResult&lt;TData, TError&gt;;
export const useLibraryServiceGetApiLibrariesKey = &quot;LibraryServiceGetApiLibraries&quot;;
export const UseLibraryServiceGetApiLibrariesKeyFn = ({ limit, page }: {
  limit?: number;
  page?: number;
} = {}, queryKey?: Array&lt;unknown&gt;) =&gt; [useLibraryServiceGetApiLibrariesKey, ...(queryKey ?? [{ limit, page }])];
export type LibraryServiceGetApiLibrariesBySlugDefaultResponse = Awaited&lt;ReturnType&lt;typeof LibraryService.getApiLibrariesBySlug&gt;&gt;;
export type LibraryServiceGetApiLibrariesBySlugQueryResult&lt;TData = LibraryServiceGetApiLibrariesBySlugDefaultResponse, TError = unknown&gt; = UseQueryResult&lt;TData, TError&gt;;
export const useLibraryServiceGetApiLibrariesBySlugKey = &quot;LibraryServiceGetApiLibrariesBySlug&quot;;
export const UseLibraryServiceGetApiLibrariesBySlugKeyFn = ({ slug }: {
  slug: string;
}, queryKey?: Array&lt;unknown&gt;) =&gt; [useLibraryServiceGetApiLibrariesBySlugKey, ...(queryKey ?? [{ slug }])];
export type LogsServiceGetSystemLogViewerApiLogsDefaultResponse = Awaited&lt;ReturnType&lt;typeof LogsService.getSystemLogViewerApiLogs&gt;&gt;;
export type LogsServiceGetSystemLogViewerApiLogsQueryResult&lt;TData = LogsServiceGetSystemLogViewerApiLogsDefaultResponse, TError = unknown&gt; = UseQueryResult&lt;TData, TError&gt;;
export const useLogsServiceGetSystemLogViewerApiLogsKey = &quot;LogsServiceGetSystemLogViewerApiLogs&quot;;
export const UseLogsServiceGetSystemLogViewerApiLogsKeyFn = ({ direction, excludeFileTypes, excludeLevels, file, log, perPage, query, shorterStackTraces }: {
  direction?: string;
  excludeFileTypes?: string;
  excludeLevels?: string;
  file?: string;
  log?: string;
  perPage?: string;
  query?: string;
  shorterStackTraces?: boolean;
} = {}, queryKey?: Array&lt;unknown&gt;) =&gt; [useLogsServiceGetSystemLogViewerApiLogsKey, ...(queryKey ?? [{ direction, excludeFileTypes, excludeLevels, file, log, perPage, query, shorterStackTraces }])];
export type MasterSupervisorServiceGetHorizonApiMastersDefaultResponse = Awaited&lt;ReturnType&lt;typeof MasterSupervisorService.getHorizonApiMasters&gt;&gt;;
export type MasterSupervisorServiceGetHorizonApiMastersQueryResult&lt;TData = MasterSupervisorServiceGetHorizonApiMastersDefaultResponse, TError = unknown&gt; = UseQueryResult&lt;TData, TError&gt;;
export const useMasterSupervisorServiceGetHorizonApiMastersKey = &quot;MasterSupervisorServiceGetHorizonApiMasters&quot;;
export const UseMasterSupervisorServiceGetHorizonApiMastersKeyFn = (queryKey?: Array&lt;unknown&gt;) =&gt; [useMasterSupervisorServiceGetHorizonApiMastersKey, ...(queryKey ?? [])];
export type MonitoringServiceGetHorizonApiMonitoringDefaultResponse = Awaited&lt;ReturnType&lt;typeof MonitoringService.getHorizonApiMonitoring&gt;&gt;;
export type MonitoringServiceGetHorizonApiMonitoringQueryResult&lt;TData = MonitoringServiceGetHorizonApiMonitoringDefaultResponse, TError = unknown&gt; = UseQueryResult&lt;TData, TError&gt;;
export const useMonitoringServiceGetHorizonApiMonitoringKey = &quot;MonitoringServiceGetHorizonApiMonitoring&quot;;
export const UseMonitoringServiceGetHorizonApiMonitoringKeyFn = (queryKey?: Array&lt;unknown&gt;) =&gt; [useMonitoringServiceGetHorizonApiMonitoringKey, ...(queryKey ?? [])];
export type MonitoringServiceGetHorizonApiMonitoringByTagDefaultResponse = Awaited&lt;ReturnType&lt;typeof MonitoringService.getHorizonApiMonitoringByTag&gt;&gt;;
export type MonitoringServiceGetHorizonApiMonitoringByTagQueryResult&lt;TData = MonitoringServiceGetHorizonApiMonitoringByTagDefaultResponse, TError = unknown&gt; = UseQueryResult&lt;TData, TError&gt;;
export const useMonitoringServiceGetHorizonApiMonitoringByTagKey = &quot;MonitoringServiceGetHorizonApiMonitoringByTag&quot;;
export const UseMonitoringServiceGetHorizonApiMonitoringByTagKeyFn = ({ limit, tag }: {
  limit?: string;
  tag: string;
}, queryKey?: Array&lt;unknown&gt;) =&gt; [useMonitoringServiceGetHorizonApiMonitoringByTagKey, ...(queryKey ?? [{ limit, tag }])];
export type MovieServiceGetApiLibrariesByLibraryMoviesDefaultResponse = Awaited&lt;ReturnType&lt;typeof MovieService.getApiLibrariesByLibraryMovies&gt;&gt;;
export type MovieServiceGetApiLibrariesByLibraryMoviesQueryResult&lt;TData = MovieServiceGetApiLibrariesByLibraryMoviesDefaultResponse, TError = unknown&gt; = UseQueryResult&lt;TData, TError&gt;;
export const useMovieServiceGetApiLibrariesByLibraryMoviesKey = &quot;MovieServiceGetApiLibrariesByLibraryMovies&quot;;
export const UseMovieServiceGetApiLibrariesByLibraryMoviesKeyFn = ({ library }: {
  library: string;
}, queryKey?: Array&lt;unknown&gt;) =&gt; [useMovieServiceGetApiLibrariesByLibraryMoviesKey, ...(queryKey ?? [{ library }])];
export type MovieServiceGetApiLibrariesByLibraryMoviesByMovieDefaultResponse = Awaited&lt;ReturnType&lt;typeof MovieService.getApiLibrariesByLibraryMoviesByMovie&gt;&gt;;
export type MovieServiceGetApiLibrariesByLibraryMoviesByMovieQueryResult&lt;TData = MovieServiceGetApiLibrariesByLibraryMoviesByMovieDefaultResponse, TError = unknown&gt; = UseQueryResult&lt;TData, TError&gt;;
export const useMovieServiceGetApiLibrariesByLibraryMoviesByMovieKey = &quot;MovieServiceGetApiLibrariesByLibraryMoviesByMovie&quot;;
export const UseMovieServiceGetApiLibrariesByLibraryMoviesByMovieKeyFn = ({ library, movie }: {
  library: string;
  movie: string;
}, queryKey?: Array&lt;unknown&gt;) =&gt; [useMovieServiceGetApiLibrariesByLibraryMoviesByMovieKey, ...(queryKey ?? [{ library, movie }])];
export type OpCacheServiceGetApiOpcacheStatusDefaultResponse = Awaited&lt;ReturnType&lt;typeof OpCacheService.getApiOpcacheStatus&gt;&gt;;
export type OpCacheServiceGetApiOpcacheStatusQueryResult&lt;TData = OpCacheServiceGetApiOpcacheStatusDefaultResponse, TError = unknown&gt; = UseQueryResult&lt;TData, TError&gt;;
export const useOpCacheServiceGetApiOpcacheStatusKey = &quot;OpCacheServiceGetApiOpcacheStatus&quot;;
export const UseOpCacheServiceGetApiOpcacheStatusKeyFn = (queryKey?: Array&lt;unknown&gt;) =&gt; [useOpCacheServiceGetApiOpcacheStatusKey, ...(queryKey ?? [])];
export type OpCacheServiceGetApiOpcacheConfigDefaultResponse = Awaited&lt;ReturnType&lt;typeof OpCacheService.getApiOpcacheConfig&gt;&gt;;
export type OpCacheServiceGetApiOpcacheConfigQueryResult&lt;TData = OpCacheServiceGetApiOpcacheConfigDefaultResponse, TError = unknown&gt; = UseQueryResult&lt;TData, TError&gt;;
export const useOpCacheServiceGetApiOpcacheConfigKey = &quot;OpCacheServiceGetApiOpcacheConfig&quot;;
export const UseOpCacheServiceGetApiOpcacheConfigKeyFn = (queryKey?: Array&lt;unknown&gt;) =&gt; [useOpCacheServiceGetApiOpcacheConfigKey, ...(queryKey ?? [])];
export type PendingJobsServiceGetHorizonApiJobsPendingDefaultResponse = Awaited&lt;ReturnType&lt;typeof PendingJobsService.getHorizonApiJobsPending&gt;&gt;;
export type PendingJobsServiceGetHorizonApiJobsPendingQueryResult&lt;TData = PendingJobsServiceGetHorizonApiJobsPendingDefaultResponse, TError = unknown&gt; = UseQueryResult&lt;TData, TError&gt;;
export const usePendingJobsServiceGetHorizonApiJobsPendingKey = &quot;PendingJobsServiceGetHorizonApiJobsPending&quot;;
export const UsePendingJobsServiceGetHorizonApiJobsPendingKeyFn = ({ startingAt }: {
  startingAt?: string;
} = {}, queryKey?: Array&lt;unknown&gt;) =&gt; [usePendingJobsServiceGetHorizonApiJobsPendingKey, ...(queryKey ?? [{ startingAt }])];
export type PlaylistServiceGetApiPlaylistsDefaultResponse = Awaited&lt;ReturnType&lt;typeof PlaylistService.getApiPlaylists&gt;&gt;;
export type PlaylistServiceGetApiPlaylistsQueryResult&lt;TData = PlaylistServiceGetApiPlaylistsDefaultResponse, TError = unknown&gt; = UseQueryResult&lt;TData, TError&gt;;
export const usePlaylistServiceGetApiPlaylistsKey = &quot;PlaylistServiceGetApiPlaylists&quot;;
export const UsePlaylistServiceGetApiPlaylistsKeyFn = (queryKey?: Array&lt;unknown&gt;) =&gt; [usePlaylistServiceGetApiPlaylistsKey, ...(queryKey ?? [])];
export type PlaylistServiceGetApiPlaylistsByPlaylistDefaultResponse = Awaited&lt;ReturnType&lt;typeof PlaylistService.getApiPlaylistsByPlaylist&gt;&gt;;
export type PlaylistServiceGetApiPlaylistsByPlaylistQueryResult&lt;TData = PlaylistServiceGetApiPlaylistsByPlaylistDefaultResponse, TError = unknown&gt; = UseQueryResult&lt;TData, TError&gt;;
export const usePlaylistServiceGetApiPlaylistsByPlaylistKey = &quot;PlaylistServiceGetApiPlaylistsByPlaylist&quot;;
export const UsePlaylistServiceGetApiPlaylistsByPlaylistKeyFn = ({ playlist, relations }: {
  playlist: string;
  relations?: string;
}, queryKey?: Array&lt;unknown&gt;) =&gt; [usePlaylistServiceGetApiPlaylistsByPlaylistKey, ...(queryKey ?? [{ playlist, relations }])];
export type PlaylistServiceGetApiPlaylistsByPlaylistStatisticsDefaultResponse = Awaited&lt;ReturnType&lt;typeof PlaylistService.getApiPlaylistsByPlaylistStatistics&gt;&gt;;
export type PlaylistServiceGetApiPlaylistsByPlaylistStatisticsQueryResult&lt;TData = PlaylistServiceGetApiPlaylistsByPlaylistStatisticsDefaultResponse, TError = unknown&gt; = UseQueryResult&lt;TData, TError&gt;;
export const usePlaylistServiceGetApiPlaylistsByPlaylistStatisticsKey = &quot;PlaylistServiceGetApiPlaylistsByPlaylistStatistics&quot;;
export const UsePlaylistServiceGetApiPlaylistsByPlaylistStatisticsKeyFn = ({ playlist }: {
  playlist: string;
}, queryKey?: Array&lt;unknown&gt;) =&gt; [usePlaylistServiceGetApiPlaylistsByPlaylistStatisticsKey, ...(queryKey ?? [{ playlist }])];
export type QueueServiceGetApiQueueMetricsDefaultResponse = Awaited&lt;ReturnType&lt;typeof QueueService.getApiQueueMetrics&gt;&gt;;
export type QueueServiceGetApiQueueMetricsQueryResult&lt;TData = QueueServiceGetApiQueueMetricsDefaultResponse, TError = unknown&gt; = UseQueryResult&lt;TData, TError&gt;;
export const useQueueServiceGetApiQueueMetricsKey = &quot;QueueServiceGetApiQueueMetrics&quot;;
export const UseQueueServiceGetApiQueueMetricsKeyFn = ({ limit, name, page, queue, queuedFirst, status }: {
  limit?: number;
  name?: string;
  page?: number;
  queue?: string;
  queuedFirst?: boolean;
  status?: &quot;running&quot; | &quot;succeeded&quot; | &quot;failed&quot; | &quot;stale&quot; | &quot;queued&quot;;
} = {}, queryKey?: Array&lt;unknown&gt;) =&gt; [useQueueServiceGetApiQueueMetricsKey, ...(queryKey ?? [{ limit, name, page, queue, queuedFirst, status }])];
export type QueueServiceGetApiQueueMetricsQueuesDefaultResponse = Awaited&lt;ReturnType&lt;typeof QueueService.getApiQueueMetricsQueues&gt;&gt;;
export type QueueServiceGetApiQueueMetricsQueuesQueryResult&lt;TData = QueueServiceGetApiQueueMetricsQueuesDefaultResponse, TError = unknown&gt; = UseQueryResult&lt;TData, TError&gt;;
export const useQueueServiceGetApiQueueMetricsQueuesKey = &quot;QueueServiceGetApiQueueMetricsQueues&quot;;
export const UseQueueServiceGetApiQueueMetricsQueuesKeyFn = (queryKey?: Array&lt;unknown&gt;) =&gt; [useQueueServiceGetApiQueueMetricsQueuesKey, ...(queryKey ?? [])];
export type QueueServiceGetApiQueueMetricsMetricsDefaultResponse = Awaited&lt;ReturnType&lt;typeof QueueService.getApiQueueMetricsMetrics&gt;&gt;;
export type QueueServiceGetApiQueueMetricsMetricsQueryResult&lt;TData = QueueServiceGetApiQueueMetricsMetricsDefaultResponse, TError = unknown&gt; = UseQueryResult&lt;TData, TError&gt;;
export const useQueueServiceGetApiQueueMetricsMetricsKey = &quot;QueueServiceGetApiQueueMetricsMetrics&quot;;
export const UseQueueServiceGetApiQueueMetricsMetricsKeyFn = ({ aggregateDays }: {
  aggregateDays?: number;
} = {}, queryKey?: Array&lt;unknown&gt;) =&gt; [useQueueServiceGetApiQueueMetricsMetricsKey, ...(queryKey ?? [{ aggregateDays }])];
export type QueueMetricsServiceGetHorizonApiMetricsQueuesDefaultResponse = Awaited&lt;ReturnType&lt;typeof QueueMetricsService.getHorizonApiMetricsQueues&gt;&gt;;
export type QueueMetricsServiceGetHorizonApiMetricsQueuesQueryResult&lt;TData = QueueMetricsServiceGetHorizonApiMetricsQueuesDefaultResponse, TError = unknown&gt; = UseQueryResult&lt;TData, TError&gt;;
export const useQueueMetricsServiceGetHorizonApiMetricsQueuesKey = &quot;QueueMetricsServiceGetHorizonApiMetricsQueues&quot;;
export const UseQueueMetricsServiceGetHorizonApiMetricsQueuesKeyFn = (queryKey?: Array&lt;unknown&gt;) =&gt; [useQueueMetricsServiceGetHorizonApiMetricsQueuesKey, ...(queryKey ?? [])];
export type QueueMetricsServiceGetHorizonApiMetricsQueuesByIdDefaultResponse = Awaited&lt;ReturnType&lt;typeof QueueMetricsService.getHorizonApiMetricsQueuesById&gt;&gt;;
export type QueueMetricsServiceGetHorizonApiMetricsQueuesByIdQueryResult&lt;TData = QueueMetricsServiceGetHorizonApiMetricsQueuesByIdDefaultResponse, TError = unknown&gt; = UseQueryResult&lt;TData, TError&gt;;
export const useQueueMetricsServiceGetHorizonApiMetricsQueuesByIdKey = &quot;QueueMetricsServiceGetHorizonApiMetricsQueuesById&quot;;
export const UseQueueMetricsServiceGetHorizonApiMetricsQueuesByIdKeyFn = ({ id }: {
  id: string;
}, queryKey?: Array&lt;unknown&gt;) =&gt; [useQueueMetricsServiceGetHorizonApiMetricsQueuesByIdKey, ...(queryKey ?? [{ id }])];
export type SchemaServiceGetApiSchemasMusicbrainzDefaultResponse = Awaited&lt;ReturnType&lt;typeof SchemaService.getApiSchemasMusicbrainz&gt;&gt;;
export type SchemaServiceGetApiSchemasMusicbrainzQueryResult&lt;TData = SchemaServiceGetApiSchemasMusicbrainzDefaultResponse, TError = unknown&gt; = UseQueryResult&lt;TData, TError&gt;;
export const useSchemaServiceGetApiSchemasMusicbrainzKey = &quot;SchemaServiceGetApiSchemasMusicbrainz&quot;;
export const UseSchemaServiceGetApiSchemasMusicbrainzKeyFn = (queryKey?: Array&lt;unknown&gt;) =&gt; [useSchemaServiceGetApiSchemasMusicbrainzKey, ...(queryKey ?? [])];
export type SilencedJobsServiceGetHorizonApiJobsSilencedDefaultResponse = Awaited&lt;ReturnType&lt;typeof SilencedJobsService.getHorizonApiJobsSilenced&gt;&gt;;
export type SilencedJobsServiceGetHorizonApiJobsSilencedQueryResult&lt;TData = SilencedJobsServiceGetHorizonApiJobsSilencedDefaultResponse, TError = unknown&gt; = UseQueryResult&lt;TData, TError&gt;;
export const useSilencedJobsServiceGetHorizonApiJobsSilencedKey = &quot;SilencedJobsServiceGetHorizonApiJobsSilenced&quot;;
export const UseSilencedJobsServiceGetHorizonApiJobsSilencedKeyFn = ({ startingAt }: {
  startingAt?: string;
} = {}, queryKey?: Array&lt;unknown&gt;) =&gt; [useSilencedJobsServiceGetHorizonApiJobsSilencedKey, ...(queryKey ?? [{ startingAt }])];
export type SongServiceGetApiLibrariesByLibrarySongsDefaultResponse = Awaited&lt;ReturnType&lt;typeof SongService.getApiLibrariesByLibrarySongs&gt;&gt;;
export type SongServiceGetApiLibrariesByLibrarySongsQueryResult&lt;TData = SongServiceGetApiLibrariesByLibrarySongsDefaultResponse, TError = unknown&gt; = UseQueryResult&lt;TData, TError&gt;;
export const useSongServiceGetApiLibrariesByLibrarySongsKey = &quot;SongServiceGetApiLibrariesByLibrarySongs&quot;;
export const UseSongServiceGetApiLibrariesByLibrarySongsKeyFn = ({ genreNames, genreSlugs, library, limit, page, relations }: {
  genreNames?: string;
  genreSlugs?: string;
  library: string;
  limit?: number;
  page?: number;
  relations?: string;
}, queryKey?: Array&lt;unknown&gt;) =&gt; [useSongServiceGetApiLibrariesByLibrarySongsKey, ...(queryKey ?? [{ genreNames, genreSlugs, library, limit, page, relations }])];
export type SongServiceGetApiLibrariesByLibrarySongsByPublicIdDefaultResponse = Awaited&lt;ReturnType&lt;typeof SongService.getApiLibrariesByLibrarySongsByPublicId&gt;&gt;;
export type SongServiceGetApiLibrariesByLibrarySongsByPublicIdQueryResult&lt;TData = SongServiceGetApiLibrariesByLibrarySongsByPublicIdDefaultResponse, TError = unknown&gt; = UseQueryResult&lt;TData, TError&gt;;
export const useSongServiceGetApiLibrariesByLibrarySongsByPublicIdKey = &quot;SongServiceGetApiLibrariesByLibrarySongsByPublicId&quot;;
export const UseSongServiceGetApiLibrariesByLibrarySongsByPublicIdKeyFn = ({ library, publicId, relations }: {
  library: string;
  publicId: string;
  relations?: string;
}, queryKey?: Array&lt;unknown&gt;) =&gt; [useSongServiceGetApiLibrariesByLibrarySongsByPublicIdKey, ...(queryKey ?? [{ library, publicId, relations }])];
export type StreamServiceGetApiStreamSongBySongDirectDefaultResponse = Awaited&lt;ReturnType&lt;typeof StreamService.getApiStreamSongBySongDirect&gt;&gt;;
export type StreamServiceGetApiStreamSongBySongDirectQueryResult&lt;TData = StreamServiceGetApiStreamSongBySongDirectDefaultResponse, TError = unknown&gt; = UseQueryResult&lt;TData, TError&gt;;
export const useStreamServiceGetApiStreamSongBySongDirectKey = &quot;StreamServiceGetApiStreamSongBySongDirect&quot;;
export const UseStreamServiceGetApiStreamSongBySongDirectKeyFn = ({ song }: {
  song: string;
}, queryKey?: Array&lt;unknown&gt;) =&gt; [useStreamServiceGetApiStreamSongBySongDirectKey, ...(queryKey ?? [{ song }])];
export type SystemInfoServiceGetApiSystemInfoDefaultResponse = Awaited&lt;ReturnType&lt;typeof SystemInfoService.getApiSystemInfo&gt;&gt;;
export type SystemInfoServiceGetApiSystemInfoQueryResult&lt;TData = SystemInfoServiceGetApiSystemInfoDefaultResponse, TError = unknown&gt; = UseQueryResult&lt;TData, TError&gt;;
export const useSystemInfoServiceGetApiSystemInfoKey = &quot;SystemInfoServiceGetApiSystemInfo&quot;;
export const UseSystemInfoServiceGetApiSystemInfoKeyFn = (queryKey?: Array&lt;unknown&gt;) =&gt; [useSystemInfoServiceGetApiSystemInfoKey, ...(queryKey ?? [])];
export type SystemInfoServiceGetApiSystemInfoSysDefaultResponse = Awaited&lt;ReturnType&lt;typeof SystemInfoService.getApiSystemInfoSys&gt;&gt;;
export type SystemInfoServiceGetApiSystemInfoSysQueryResult&lt;TData = SystemInfoServiceGetApiSystemInfoSysDefaultResponse, TError = unknown&gt; = UseQueryResult&lt;TData, TError&gt;;
export const useSystemInfoServiceGetApiSystemInfoSysKey = &quot;SystemInfoServiceGetApiSystemInfoSys&quot;;
export const UseSystemInfoServiceGetApiSystemInfoSysKeyFn = (queryKey?: Array&lt;unknown&gt;) =&gt; [useSystemInfoServiceGetApiSystemInfoSysKey, ...(queryKey ?? [])];
export type UserServiceGetApiUsersDefaultResponse = Awaited&lt;ReturnType&lt;typeof UserService.getApiUsers&gt;&gt;;
export type UserServiceGetApiUsersQueryResult&lt;TData = UserServiceGetApiUsersDefaultResponse, TError = unknown&gt; = UseQueryResult&lt;TData, TError&gt;;
export const useUserServiceGetApiUsersKey = &quot;UserServiceGetApiUsers&quot;;
export const UseUserServiceGetApiUsersKeyFn = ({ filterModes, filters, globalFilter, limit, page, sorting }: {
  filterModes?: string;
  filters?: string;
  globalFilter?: string;
  limit?: number;
  page?: number;
  sorting?: string;
} = {}, queryKey?: Array&lt;unknown&gt;) =&gt; [useUserServiceGetApiUsersKey, ...(queryKey ?? [{ filterModes, filters, globalFilter, limit, page, sorting }])];
export type UserServiceGetApiUsersByUserDefaultResponse = Awaited&lt;ReturnType&lt;typeof UserService.getApiUsersByUser&gt;&gt;;
export type UserServiceGetApiUsersByUserQueryResult&lt;TData = UserServiceGetApiUsersByUserDefaultResponse, TError = unknown&gt; = UseQueryResult&lt;TData, TError&gt;;
export const useUserServiceGetApiUsersByUserKey = &quot;UserServiceGetApiUsersByUser&quot;;
export const UseUserServiceGetApiUsersByUserKeyFn = ({ user }: {
  user: number;
}, queryKey?: Array&lt;unknown&gt;) =&gt; [useUserServiceGetApiUsersByUserKey, ...(queryKey ?? [{ user }])];
export type UserServiceGetApiUsersMeDefaultResponse = Awaited&lt;ReturnType&lt;typeof UserService.getApiUsersMe&gt;&gt;;
export type UserServiceGetApiUsersMeQueryResult&lt;TData = UserServiceGetApiUsersMeDefaultResponse, TError = unknown&gt; = UseQueryResult&lt;TData, TError&gt;;
export const useUserServiceGetApiUsersMeKey = &quot;UserServiceGetApiUsersMe&quot;;
export const UseUserServiceGetApiUsersMeKeyFn = (queryKey?: Array&lt;unknown&gt;) =&gt; [useUserServiceGetApiUsersMeKey, ...(queryKey ?? [])];
export type UserTokenServiceGetApiUsersTokensByUserDefaultResponse = Awaited&lt;ReturnType&lt;typeof UserTokenService.getApiUsersTokensByUser&gt;&gt;;
export type UserTokenServiceGetApiUsersTokensByUserQueryResult&lt;TData = UserTokenServiceGetApiUsersTokensByUserDefaultResponse, TError = unknown&gt; = UseQueryResult&lt;TData, TError&gt;;
export const useUserTokenServiceGetApiUsersTokensByUserKey = &quot;UserTokenServiceGetApiUsersTokensByUser&quot;;
export const UseUserTokenServiceGetApiUsersTokensByUserKeyFn = ({ page, perPage, user }: {
  page?: number;
  perPage?: number;
  user: string;
}, queryKey?: Array&lt;unknown&gt;) =&gt; [useUserTokenServiceGetApiUsersTokensByUserKey, ...(queryKey ?? [{ page, perPage, user }])];
export type WorkloadServiceGetHorizonApiWorkloadDefaultResponse = Awaited&lt;ReturnType&lt;typeof WorkloadService.getHorizonApiWorkload&gt;&gt;;
export type WorkloadServiceGetHorizonApiWorkloadQueryResult&lt;TData = WorkloadServiceGetHorizonApiWorkloadDefaultResponse, TError = unknown&gt; = UseQueryResult&lt;TData, TError&gt;;
export const useWorkloadServiceGetHorizonApiWorkloadKey = &quot;WorkloadServiceGetHorizonApiWorkload&quot;;
export const UseWorkloadServiceGetHorizonApiWorkloadKeyFn = (queryKey?: Array&lt;unknown&gt;) =&gt; [useWorkloadServiceGetHorizonApiWorkloadKey, ...(queryKey ?? [])];
export type AuthServicePostApiAuthLoginMutationResult = Awaited&lt;ReturnType&lt;typeof AuthService.postApiAuthLogin&gt;&gt;;
export type AuthServicePostApiAuthRefreshTokenMutationResult = Awaited&lt;ReturnType&lt;typeof AuthService.postApiAuthRefreshToken&gt;&gt;;
export type AuthServicePostApiAuthStreamTokenMutationResult = Awaited&lt;ReturnType&lt;typeof AuthService.postApiAuthStreamToken&gt;&gt;;
export type AuthServicePostApiAuthRegisterMutationResult = Awaited&lt;ReturnType&lt;typeof AuthService.postApiAuthRegister&gt;&gt;;
export type AuthServicePostApiAuthForgotPasswordMutationResult = Awaited&lt;ReturnType&lt;typeof AuthService.postApiAuthForgotPassword&gt;&gt;;
export type AuthServicePostApiAuthResetPasswordMutationResult = Awaited&lt;ReturnType&lt;typeof AuthService.postApiAuthResetPassword&gt;&gt;;
export type AuthServicePostApiAuthVerifyByIdByHashMutationResult = Awaited&lt;ReturnType&lt;typeof AuthService.postApiAuthVerifyByIdByHash&gt;&gt;;
export type AuthServicePostApiAuthLogoutMutationResult = Awaited&lt;ReturnType&lt;typeof AuthService.postApiAuthLogout&gt;&gt;;
export type AuthServicePostWebauthnPasskeyMutationResult = Awaited&lt;ReturnType&lt;typeof AuthService.postWebauthnPasskey&gt;&gt;;
export type AuthServicePostWebauthnPasskeyRegisterMutationResult = Awaited&lt;ReturnType&lt;typeof AuthService.postWebauthnPasskeyRegister&gt;&gt;;
export type PasskeyServicePostWebauthnPasskeyMutationResult = Awaited&lt;ReturnType&lt;typeof PasskeyService.postWebauthnPasskey&gt;&gt;;
export type PasskeyServicePostWebauthnPasskeyRegisterMutationResult = Awaited&lt;ReturnType&lt;typeof PasskeyService.postWebauthnPasskeyRegister&gt;&gt;;
export type BatchesServicePostHorizonApiBatchesRetryByIdMutationResult = Awaited&lt;ReturnType&lt;typeof BatchesService.postHorizonApiBatchesRetryById&gt;&gt;;
export type FilesServicePostSystemLogViewerApiFilesByFileIdentifierClearCacheMutationResult = Awaited&lt;ReturnType&lt;typeof FilesService.postSystemLogViewerApiFilesByFileIdentifierClearCache&gt;&gt;;
export type FilesServicePostSystemLogViewerApiClearCacheAllMutationResult = Awaited&lt;ReturnType&lt;typeof FilesService.postSystemLogViewerApiClearCacheAll&gt;&gt;;
export type FilesServicePostSystemLogViewerApiDeleteMultipleFilesMutationResult = Awaited&lt;ReturnType&lt;typeof FilesService.postSystemLogViewerApiDeleteMultipleFiles&gt;&gt;;
export type FoldersServicePostSystemLogViewerApiFoldersByFolderIdentifierClearCacheMutationResult = Awaited&lt;ReturnType&lt;typeof FoldersService.postSystemLogViewerApiFoldersByFolderIdentifierClearCache&gt;&gt;;
export type JobServicePostApiJobsScanLibraryBySlugMutationResult = Awaited&lt;ReturnType&lt;typeof JobService.postApiJobsScanLibraryBySlug&gt;&gt;;
export type LibraryServicePostApiLibrariesMutationResult = Awaited&lt;ReturnType&lt;typeof LibraryService.postApiLibraries&gt;&gt;;
export type MonitoringServicePostHorizonApiMonitoringMutationResult = Awaited&lt;ReturnType&lt;typeof MonitoringService.postHorizonApiMonitoring&gt;&gt;;
export type OpCacheServicePostApiOpcacheClearMutationResult = Awaited&lt;ReturnType&lt;typeof OpCacheService.postApiOpcacheClear&gt;&gt;;
export type OpCacheServicePostApiOpcacheCompileMutationResult = Awaited&lt;ReturnType&lt;typeof OpCacheService.postApiOpcacheCompile&gt;&gt;;
export type PlaylistServicePostApiPlaylistsMutationResult = Awaited&lt;ReturnType&lt;typeof PlaylistService.postApiPlaylists&gt;&gt;;
export type PlaylistServicePostApiPlaylistsByPlaylistSongsBySongMutationResult = Awaited&lt;ReturnType&lt;typeof PlaylistService.postApiPlaylistsByPlaylistSongsBySong&gt;&gt;;
export type PlaylistServicePostApiPlaylistsByPlaylistReorderMutationResult = Awaited&lt;ReturnType&lt;typeof PlaylistService.postApiPlaylistsByPlaylistReorder&gt;&gt;;
export type PlaylistServicePostApiPlaylistsByPlaylistCollaboratorsMutationResult = Awaited&lt;ReturnType&lt;typeof PlaylistService.postApiPlaylistsByPlaylistCollaborators&gt;&gt;;
export type PlaylistServicePostApiPlaylistsByPlaylistCloneMutationResult = Awaited&lt;ReturnType&lt;typeof PlaylistService.postApiPlaylistsByPlaylistClone&gt;&gt;;
export type PlaylistServicePostApiPlaylistsByPlaylistStatisticsRecordViewMutationResult = Awaited&lt;ReturnType&lt;typeof PlaylistService.postApiPlaylistsByPlaylistStatisticsRecordView&gt;&gt;;
export type PlaylistServicePostApiPlaylistsByPlaylistStatisticsRecordPlayMutationResult = Awaited&lt;ReturnType&lt;typeof PlaylistService.postApiPlaylistsByPlaylistStatisticsRecordPlay&gt;&gt;;
export type PlaylistServicePostApiPlaylistsByPlaylistStatisticsRecordShareMutationResult = Awaited&lt;ReturnType&lt;typeof PlaylistService.postApiPlaylistsByPlaylistStatisticsRecordShare&gt;&gt;;
export type PlaylistServicePostApiPlaylistsByPlaylistStatisticsRecordFavoriteMutationResult = Awaited&lt;ReturnType&lt;typeof PlaylistService.postApiPlaylistsByPlaylistStatisticsRecordFavorite&gt;&gt;;
export type PlaylistServicePostApiPlaylistsSmartMutationResult = Awaited&lt;ReturnType&lt;typeof PlaylistService.postApiPlaylistsSmart&gt;&gt;;
export type PlaylistServicePostApiPlaylistsByPlaylistSmartSyncMutationResult = Awaited&lt;ReturnType&lt;typeof PlaylistService.postApiPlaylistsByPlaylistSmartSync&gt;&gt;;
export type QueueServicePostApiQueueMetricsRetryByIdMutationResult = Awaited&lt;ReturnType&lt;typeof QueueService.postApiQueueMetricsRetryById&gt;&gt;;
export type RetryServicePostHorizonApiJobsRetryByIdMutationResult = Awaited&lt;ReturnType&lt;typeof RetryService.postHorizonApiJobsRetryById&gt;&gt;;
export type UserServicePostApiUsersMutationResult = Awaited&lt;ReturnType&lt;typeof UserService.postApiUsers&gt;&gt;;
export type PlaylistServicePutApiPlaylistsByPlaylistMutationResult = Awaited&lt;ReturnType&lt;typeof PlaylistService.putApiPlaylistsByPlaylist&gt;&gt;;
export type PlaylistServicePutApiPlaylistsByPlaylistSmartMutationResult = Awaited&lt;ReturnType&lt;typeof PlaylistService.putApiPlaylistsByPlaylistSmart&gt;&gt;;
export type GenreServicePatchApiGenresByGenreMutationResult = Awaited&lt;ReturnType&lt;typeof GenreService.patchApiGenresByGenre&gt;&gt;;
export type LibraryServicePatchApiLibrariesBySlugMutationResult = Awaited&lt;ReturnType&lt;typeof LibraryService.patchApiLibrariesBySlug&gt;&gt;;
export type UserServicePatchApiUsersByUserMutationResult = Awaited&lt;ReturnType&lt;typeof UserService.patchApiUsersByUser&gt;&gt;;
export type FilesServiceDeleteSystemLogViewerApiFilesByFileIdentifierMutationResult = Awaited&lt;ReturnType&lt;typeof FilesService.deleteSystemLogViewerApiFilesByFileIdentifier&gt;&gt;;
export type FoldersServiceDeleteSystemLogViewerApiFoldersByFolderIdentifierMutationResult = Awaited&lt;ReturnType&lt;typeof FoldersService.deleteSystemLogViewerApiFoldersByFolderIdentifier&gt;&gt;;
export type GenreServiceDeleteApiGenresByGenreMutationResult = Awaited&lt;ReturnType&lt;typeof GenreService.deleteApiGenresByGenre&gt;&gt;;
export type LibraryServiceDeleteApiLibrariesBySlugMutationResult = Awaited&lt;ReturnType&lt;typeof LibraryService.deleteApiLibrariesBySlug&gt;&gt;;
export type MonitoringServiceDeleteHorizonApiMonitoringByTagMutationResult = Awaited&lt;ReturnType&lt;typeof MonitoringService.deleteHorizonApiMonitoringByTag&gt;&gt;;
export type PlaylistServiceDeleteApiPlaylistsByPlaylistMutationResult = Awaited&lt;ReturnType&lt;typeof PlaylistService.deleteApiPlaylistsByPlaylist&gt;&gt;;
export type PlaylistServiceDeleteApiPlaylistsByPlaylistSongsBySongMutationResult = Awaited&lt;ReturnType&lt;typeof PlaylistService.deleteApiPlaylistsByPlaylistSongsBySong&gt;&gt;;
export type PlaylistServiceDeleteApiPlaylistsByPlaylistCollaboratorsByUserMutationResult = Awaited&lt;ReturnType&lt;typeof PlaylistService.deleteApiPlaylistsByPlaylistCollaboratorsByUser&gt;&gt;;
export type QueueServiceDeleteApiQueueMetricsByIdMutationResult = Awaited&lt;ReturnType&lt;typeof QueueService.deleteApiQueueMetricsById&gt;&gt;;
export type QueueServiceDeleteApiQueueMetricsPurgeMutationResult = Awaited&lt;ReturnType&lt;typeof QueueService.deleteApiQueueMetricsPurge&gt;&gt;;
export type UserServiceDeleteApiUsersByUserMutationResult = Awaited&lt;ReturnType&lt;typeof UserService.deleteApiUsersByUser&gt;&gt;;
export type UserTokenServiceDeleteApiUsersTokensByTokenMutationResult = Awaited&lt;ReturnType&lt;typeof UserTokenService.deleteApiUsersTokensByToken&gt;&gt;;</file><file path="resources/app/api-client/queries/prefetch.ts">// generated with @7nohe/openapi-react-query-codegen@1.6.2 
import { type QueryClient } from &quot;@tanstack/react-query&quot;;
import { AlbumService, ArtistService, AuthService, BatchesService, CompletedJobsService, DashboardStatsService, FailedJobsService, FilesService, FoldersService, GenreService, HostsService, ImageService, JobMetricsService, JobsService, LibraryService, LogsService, MasterSupervisorService, MonitoringService, MovieService, OpCacheService, PasskeyService, PendingJobsService, PlaylistService, QueueMetricsService, QueueService, SchemaService, SilencedJobsService, SongService, StreamService, SystemInfoService, UserService, UserTokenService, WorkloadService } from &quot;../requests/services.gen&quot;;
import * as Common from &quot;./common&quot;;
/**
* Get a collection of albums
* @param data The data for the request.
* @param data.library The library slug
* @param data.fields
* @param data.relations
* @param data.page
* @param data.limit
* @param data.genres
* @returns unknown Paginated set of `AlbumResource`
* @throws ApiError
*/
export const prefetchUseAlbumServiceGetApiLibrariesByLibraryAlbums = (queryClient: QueryClient, { fields, genres, library, limit, page, relations }: {
  fields?: string;
  genres?: string;
  library: string;
  limit?: number;
  page?: number;
  relations?: string;
}) =&gt; queryClient.prefetchQuery({ queryKey: Common.UseAlbumServiceGetApiLibrariesByLibraryAlbumsKeyFn({ fields, genres, library, limit, page, relations }), queryFn: () =&gt; AlbumService.getApiLibrariesByLibraryAlbums({ fields, genres, library, limit, page, relations }) });
/**
* Get an album
* @param data The data for the request.
* @param data.library The library slug
* @param data.album The album slug
* @returns AlbumResource `AlbumResource`
* @throws ApiError
*/
export const prefetchUseAlbumServiceGetApiLibrariesByLibraryAlbumsByAlbum = (queryClient: QueryClient, { album, library }: {
  album: string;
  library: string;
}) =&gt; queryClient.prefetchQuery({ queryKey: Common.UseAlbumServiceGetApiLibrariesByLibraryAlbumsByAlbumKeyFn({ album, library }), queryFn: () =&gt; AlbumService.getApiLibrariesByLibraryAlbumsByAlbum({ album, library }) });
/**
* Get a collection of artists
* @param data The data for the request.
* @param data.library
* @param data.fields
* @param data.relations
* @param data.page
* @param data.limit
* @param data.genres
* @returns unknown Paginated set of `ArtistResource`
* @throws ApiError
*/
export const prefetchUseArtistServiceGetApiLibrariesByLibraryArtists = (queryClient: QueryClient, { fields, genres, library, limit, page, relations }: {
  fields?: string;
  genres?: string;
  library: string;
  limit?: number;
  page?: number;
  relations?: string;
}) =&gt; queryClient.prefetchQuery({ queryKey: Common.UseArtistServiceGetApiLibrariesByLibraryArtistsKeyFn({ fields, genres, library, limit, page, relations }), queryFn: () =&gt; ArtistService.getApiLibrariesByLibraryArtists({ fields, genres, library, limit, page, relations }) });
/**
* Get an artist
* @param data The data for the request.
* @param data.library
* @param data.artist The artist slug
* @returns ArtistResource `ArtistResource`
* @throws ApiError
*/
export const prefetchUseArtistServiceGetApiLibrariesByLibraryArtistsByArtist = (queryClient: QueryClient, { artist, library }: {
  artist: string;
  library: string;
}) =&gt; queryClient.prefetchQuery({ queryKey: Common.UseArtistServiceGetApiLibrariesByLibraryArtistsByArtistKeyFn({ artist, library }), queryFn: () =&gt; ArtistService.getApiLibrariesByLibraryArtistsByArtist({ artist, library }) });
/**
* Get a passkey challenge
* @returns unknown
* @throws ApiError
*/
export const prefetchUseAuthServiceGetWebauthnPasskey = (queryClient: QueryClient) =&gt; queryClient.prefetchQuery({ queryKey: Common.UseAuthServiceGetWebauthnPasskeyKeyFn(), queryFn: () =&gt; AuthService.getWebauthnPasskey() });
/**
* Get passkey registration options
* @returns unknown
* @throws ApiError
*/
export const prefetchUseAuthServiceGetWebauthnPasskeyRegister = (queryClient: QueryClient) =&gt; queryClient.prefetchQuery({ queryKey: Common.UseAuthServiceGetWebauthnPasskeyRegisterKeyFn(), queryFn: () =&gt; AuthService.getWebauthnPasskeyRegister() });
/**
* Get a passkey challenge
* @returns unknown
* @throws ApiError
*/
export const prefetchUsePasskeyServiceGetWebauthnPasskey = (queryClient: QueryClient) =&gt; queryClient.prefetchQuery({ queryKey: Common.UsePasskeyServiceGetWebauthnPasskeyKeyFn(), queryFn: () =&gt; PasskeyService.getWebauthnPasskey() });
/**
* Get passkey registration options
* @returns unknown
* @throws ApiError
*/
export const prefetchUsePasskeyServiceGetWebauthnPasskeyRegister = (queryClient: QueryClient) =&gt; queryClient.prefetchQuery({ queryKey: Common.UsePasskeyServiceGetWebauthnPasskeyRegisterKeyFn(), queryFn: () =&gt; PasskeyService.getWebauthnPasskeyRegister() });
/**
* Get all of the batches
* @returns unknown
* @throws ApiError
*/
export const prefetchUseBatchesServiceGetHorizonApiBatches = (queryClient: QueryClient) =&gt; queryClient.prefetchQuery({ queryKey: Common.UseBatchesServiceGetHorizonApiBatchesKeyFn(), queryFn: () =&gt; BatchesService.getHorizonApiBatches() });
/**
* Get the details of a batch by ID
* @param data The data for the request.
* @param data.id
* @returns unknown
* @throws ApiError
*/
export const prefetchUseBatchesServiceGetHorizonApiBatchesById = (queryClient: QueryClient, { id }: {
  id: string;
}) =&gt; queryClient.prefetchQuery({ queryKey: Common.UseBatchesServiceGetHorizonApiBatchesByIdKeyFn({ id }), queryFn: () =&gt; BatchesService.getHorizonApiBatchesById({ id }) });
/**
* Get all of the completed jobs
* @param data The data for the request.
* @param data.startingAt
* @returns unknown
* @throws ApiError
*/
export const prefetchUseCompletedJobsServiceGetHorizonApiJobsCompleted = (queryClient: QueryClient, { startingAt }: {
  startingAt?: string;
} = {}) =&gt; queryClient.prefetchQuery({ queryKey: Common.UseCompletedJobsServiceGetHorizonApiJobsCompletedKeyFn({ startingAt }), queryFn: () =&gt; CompletedJobsService.getHorizonApiJobsCompleted({ startingAt }) });
/**
* Get the key performance stats for the dashboard
* @returns unknown
* @throws ApiError
*/
export const prefetchUseDashboardStatsServiceGetHorizonApiStats = (queryClient: QueryClient) =&gt; queryClient.prefetchQuery({ queryKey: Common.UseDashboardStatsServiceGetHorizonApiStatsKeyFn(), queryFn: () =&gt; DashboardStatsService.getHorizonApiStats() });
/**
* Get all of the failed jobs
* @param data The data for the request.
* @param data.tag
* @returns unknown
* @throws ApiError
*/
export const prefetchUseFailedJobsServiceGetHorizonApiJobsFailed = (queryClient: QueryClient, { tag }: {
  tag?: string;
} = {}) =&gt; queryClient.prefetchQuery({ queryKey: Common.UseFailedJobsServiceGetHorizonApiJobsFailedKeyFn({ tag }), queryFn: () =&gt; FailedJobsService.getHorizonApiJobsFailed({ tag }) });
/**
* Get a failed job instance
* @param data The data for the request.
* @param data.id
* @returns unknown
* @throws ApiError
*/
export const prefetchUseFailedJobsServiceGetHorizonApiJobsFailedById = (queryClient: QueryClient, { id }: {
  id: string;
}) =&gt; queryClient.prefetchQuery({ queryKey: Common.UseFailedJobsServiceGetHorizonApiJobsFailedByIdKeyFn({ id }), queryFn: () =&gt; FailedJobsService.getHorizonApiJobsFailedById({ id }) });
/**
* @returns LogFileResource Array of `LogFileResource`
* @throws ApiError
*/
export const prefetchUseFilesServiceGetSystemLogViewerApiFiles = (queryClient: QueryClient) =&gt; queryClient.prefetchQuery({ queryKey: Common.UseFilesServiceGetSystemLogViewerApiFilesKeyFn(), queryFn: () =&gt; FilesService.getSystemLogViewerApiFiles() });
/**
* @param data The data for the request.
* @param data.fileIdentifier
* @returns unknown
* @throws ApiError
*/
export const prefetchUseFilesServiceGetSystemLogViewerApiFilesByFileIdentifierDownloadRequest = (queryClient: QueryClient, { fileIdentifier }: {
  fileIdentifier: string;
}) =&gt; queryClient.prefetchQuery({ queryKey: Common.UseFilesServiceGetSystemLogViewerApiFilesByFileIdentifierDownloadRequestKeyFn({ fileIdentifier }), queryFn: () =&gt; FilesService.getSystemLogViewerApiFilesByFileIdentifierDownloadRequest({ fileIdentifier }) });
/**
* @param data The data for the request.
* @param data.fileIdentifier
* @returns string
* @throws ApiError
*/
export const prefetchUseFilesServiceGetSystemLogViewerApiFilesByFileIdentifierDownload = (queryClient: QueryClient, { fileIdentifier }: {
  fileIdentifier: string;
}) =&gt; queryClient.prefetchQuery({ queryKey: Common.UseFilesServiceGetSystemLogViewerApiFilesByFileIdentifierDownloadKeyFn({ fileIdentifier }), queryFn: () =&gt; FilesService.getSystemLogViewerApiFilesByFileIdentifierDownload({ fileIdentifier }) });
/**
* @param data The data for the request.
* @param data.direction
* @returns LogFolderResource Array of `LogFolderResource`
* @throws ApiError
*/
export const prefetchUseFoldersServiceGetSystemLogViewerApiFolders = (queryClient: QueryClient, { direction }: {
  direction?: string;
} = {}) =&gt; queryClient.prefetchQuery({ queryKey: Common.UseFoldersServiceGetSystemLogViewerApiFoldersKeyFn({ direction }), queryFn: () =&gt; FoldersService.getSystemLogViewerApiFolders({ direction }) });
/**
* @param data The data for the request.
* @param data.folderIdentifier
* @returns unknown
* @throws ApiError
*/
export const prefetchUseFoldersServiceGetSystemLogViewerApiFoldersByFolderIdentifierDownloadRequest = (queryClient: QueryClient, { folderIdentifier }: {
  folderIdentifier: string;
}) =&gt; queryClient.prefetchQuery({ queryKey: Common.UseFoldersServiceGetSystemLogViewerApiFoldersByFolderIdentifierDownloadRequestKeyFn({ folderIdentifier }), queryFn: () =&gt; FoldersService.getSystemLogViewerApiFoldersByFolderIdentifierDownloadRequest({ folderIdentifier }) });
/**
* @param data The data for the request.
* @param data.folderIdentifier
* @returns string
* @throws ApiError
*/
export const prefetchUseFoldersServiceGetSystemLogViewerApiFoldersByFolderIdentifierDownload = (queryClient: QueryClient, { folderIdentifier }: {
  folderIdentifier: string;
}) =&gt; queryClient.prefetchQuery({ queryKey: Common.UseFoldersServiceGetSystemLogViewerApiFoldersByFolderIdentifierDownloadKeyFn({ folderIdentifier }), queryFn: () =&gt; FoldersService.getSystemLogViewerApiFoldersByFolderIdentifierDownload({ folderIdentifier }) });
/**
* Get a collection of genres
* @param data The data for the request.
* @param data.fields
* @param data.relations
* @param data.librarySlug
* @param data.page
* @param data.limit
* @returns unknown Paginated set of `GenreResource`
* @throws ApiError
*/
export const prefetchUseGenreServiceGetApiGenres = (queryClient: QueryClient, { fields, librarySlug, limit, page, relations }: {
  fields?: string;
  librarySlug?: string;
  limit?: number;
  page?: number;
  relations?: string;
} = {}) =&gt; queryClient.prefetchQuery({ queryKey: Common.UseGenreServiceGetApiGenresKeyFn({ fields, librarySlug, limit, page, relations }), queryFn: () =&gt; GenreService.getApiGenres({ fields, librarySlug, limit, page, relations }) });
/**
* Get a genre
* @param data The data for the request.
* @param data.genre The genre slug
* @returns GenreResource `GenreResource`
* @throws ApiError
*/
export const prefetchUseGenreServiceGetApiGenresByGenre = (queryClient: QueryClient, { genre }: {
  genre: string;
}) =&gt; queryClient.prefetchQuery({ queryKey: Common.UseGenreServiceGetApiGenresByGenreKeyFn({ genre }), queryFn: () =&gt; GenreService.getApiGenresByGenre({ genre }) });
/**
* @returns LogViewerHostResource Array of `LogViewerHostResource`
* @throws ApiError
*/
export const prefetchUseHostsServiceGetSystemLogViewerApiHosts = (queryClient: QueryClient) =&gt; queryClient.prefetchQuery({ queryKey: Common.UseHostsServiceGetSystemLogViewerApiHostsKeyFn(), queryFn: () =&gt; HostsService.getSystemLogViewerApiHosts() });
/**
* Get an image asset
* @param data The data for the request.
* @param data.image The image public id
* @returns string
* @throws ApiError
*/
export const prefetchUseImageServiceGetApiImagesByImage = (queryClient: QueryClient, { image }: {
  image: string;
}) =&gt; queryClient.prefetchQuery({ queryKey: Common.UseImageServiceGetApiImagesByImageKeyFn({ image }), queryFn: () =&gt; ImageService.getApiImagesByImage({ image }) });
/**
* Get all of the measured jobs
* @returns unknown
* @throws ApiError
*/
export const prefetchUseJobMetricsServiceGetHorizonApiMetricsJobs = (queryClient: QueryClient) =&gt; queryClient.prefetchQuery({ queryKey: Common.UseJobMetricsServiceGetHorizonApiMetricsJobsKeyFn(), queryFn: () =&gt; JobMetricsService.getHorizonApiMetricsJobs() });
/**
* Get metrics for a given job
* @param data The data for the request.
* @param data.id
* @returns unknown
* @throws ApiError
*/
export const prefetchUseJobMetricsServiceGetHorizonApiMetricsJobsById = (queryClient: QueryClient, { id }: {
  id: string;
}) =&gt; queryClient.prefetchQuery({ queryKey: Common.UseJobMetricsServiceGetHorizonApiMetricsJobsByIdKeyFn({ id }), queryFn: () =&gt; JobMetricsService.getHorizonApiMetricsJobsById({ id }) });
/**
* Get the details of a recent job by ID
* @param data The data for the request.
* @param data.id
* @returns unknown
* @throws ApiError
*/
export const prefetchUseJobsServiceGetHorizonApiJobsById = (queryClient: QueryClient, { id }: {
  id: string;
}) =&gt; queryClient.prefetchQuery({ queryKey: Common.UseJobsServiceGetHorizonApiJobsByIdKeyFn({ id }), queryFn: () =&gt; JobsService.getHorizonApiJobsById({ id }) });
/**
* Get a collection of media libraries
* @param data The data for the request.
* @param data.page
* @param data.limit
* @returns unknown Paginated set of `LibraryResource`
* @throws ApiError
*/
export const prefetchUseLibraryServiceGetApiLibraries = (queryClient: QueryClient, { limit, page }: {
  limit?: number;
  page?: number;
} = {}) =&gt; queryClient.prefetchQuery({ queryKey: Common.UseLibraryServiceGetApiLibrariesKeyFn({ limit, page }), queryFn: () =&gt; LibraryService.getApiLibraries({ limit, page }) });
/**
* Show library
* @param data The data for the request.
* @param data.slug
* @returns LibraryResource `LibraryResource`
* @throws ApiError
*/
export const prefetchUseLibraryServiceGetApiLibrariesBySlug = (queryClient: QueryClient, { slug }: {
  slug: string;
}) =&gt; queryClient.prefetchQuery({ queryKey: Common.UseLibraryServiceGetApiLibrariesBySlugKeyFn({ slug }), queryFn: () =&gt; LibraryService.getApiLibrariesBySlug({ slug }) });
/**
* @param data The data for the request.
* @param data.file
* @param data.query
* @param data.direction
* @param data.log
* @param data.excludeLevels
* @param data.excludeFileTypes
* @param data.perPage
* @param data.shorterStackTraces
* @returns unknown
* @throws ApiError
*/
export const prefetchUseLogsServiceGetSystemLogViewerApiLogs = (queryClient: QueryClient, { direction, excludeFileTypes, excludeLevels, file, log, perPage, query, shorterStackTraces }: {
  direction?: string;
  excludeFileTypes?: string;
  excludeLevels?: string;
  file?: string;
  log?: string;
  perPage?: string;
  query?: string;
  shorterStackTraces?: boolean;
} = {}) =&gt; queryClient.prefetchQuery({ queryKey: Common.UseLogsServiceGetSystemLogViewerApiLogsKeyFn({ direction, excludeFileTypes, excludeLevels, file, log, perPage, query, shorterStackTraces }), queryFn: () =&gt; LogsService.getSystemLogViewerApiLogs({ direction, excludeFileTypes, excludeLevels, file, log, perPage, query, shorterStackTraces }) });
/**
* Get all of the master supervisors and their underlying supervisors
* @returns unknown
* @throws ApiError
*/
export const prefetchUseMasterSupervisorServiceGetHorizonApiMasters = (queryClient: QueryClient) =&gt; queryClient.prefetchQuery({ queryKey: Common.UseMasterSupervisorServiceGetHorizonApiMastersKeyFn(), queryFn: () =&gt; MasterSupervisorService.getHorizonApiMasters() });
/**
* Get all of the monitored tags and their job counts
* @returns unknown
* @throws ApiError
*/
export const prefetchUseMonitoringServiceGetHorizonApiMonitoring = (queryClient: QueryClient) =&gt; queryClient.prefetchQuery({ queryKey: Common.UseMonitoringServiceGetHorizonApiMonitoringKeyFn(), queryFn: () =&gt; MonitoringService.getHorizonApiMonitoring() });
/**
* Paginate the jobs for a given tag
* @param data The data for the request.
* @param data.tag
* @param data.limit
* @returns unknown
* @throws ApiError
*/
export const prefetchUseMonitoringServiceGetHorizonApiMonitoringByTag = (queryClient: QueryClient, { limit, tag }: {
  limit?: string;
  tag: string;
}) =&gt; queryClient.prefetchQuery({ queryKey: Common.UseMonitoringServiceGetHorizonApiMonitoringByTagKeyFn({ limit, tag }), queryFn: () =&gt; MonitoringService.getHorizonApiMonitoringByTag({ limit, tag }) });
/**
* Get a collection of movies
* @param data The data for the request.
* @param data.library The library slug
* @returns unknown Paginated set of `MovieResource`
* @throws ApiError
*/
export const prefetchUseMovieServiceGetApiLibrariesByLibraryMovies = (queryClient: QueryClient, { library }: {
  library: string;
}) =&gt; queryClient.prefetchQuery({ queryKey: Common.UseMovieServiceGetApiLibrariesByLibraryMoviesKeyFn({ library }), queryFn: () =&gt; MovieService.getApiLibrariesByLibraryMovies({ library }) });
/**
* Get a movie
* @param data The data for the request.
* @param data.library The library slug
* @param data.movie The movie slug
* @returns MovieResource `MovieResource`
* @throws ApiError
*/
export const prefetchUseMovieServiceGetApiLibrariesByLibraryMoviesByMovie = (queryClient: QueryClient, { library, movie }: {
  library: string;
  movie: string;
}) =&gt; queryClient.prefetchQuery({ queryKey: Common.UseMovieServiceGetApiLibrariesByLibraryMoviesByMovieKeyFn({ library, movie }), queryFn: () =&gt; MovieService.getApiLibrariesByLibraryMoviesByMovie({ library, movie }) });
/**
* Get status
* @returns unknown
* @throws ApiError
*/
export const prefetchUseOpCacheServiceGetApiOpcacheStatus = (queryClient: QueryClient) =&gt; queryClient.prefetchQuery({ queryKey: Common.UseOpCacheServiceGetApiOpcacheStatusKeyFn(), queryFn: () =&gt; OpCacheService.getApiOpcacheStatus() });
/**
* Get config
* @returns unknown
* @throws ApiError
*/
export const prefetchUseOpCacheServiceGetApiOpcacheConfig = (queryClient: QueryClient) =&gt; queryClient.prefetchQuery({ queryKey: Common.UseOpCacheServiceGetApiOpcacheConfigKeyFn(), queryFn: () =&gt; OpCacheService.getApiOpcacheConfig() });
/**
* Get all of the pending jobs
* @param data The data for the request.
* @param data.startingAt
* @returns unknown
* @throws ApiError
*/
export const prefetchUsePendingJobsServiceGetHorizonApiJobsPending = (queryClient: QueryClient, { startingAt }: {
  startingAt?: string;
} = {}) =&gt; queryClient.prefetchQuery({ queryKey: Common.UsePendingJobsServiceGetHorizonApiJobsPendingKeyFn({ startingAt }), queryFn: () =&gt; PendingJobsService.getHorizonApiJobsPending({ startingAt }) });
/**
* Get a collection of playlists
* @returns unknown Paginated set of `PlaylistResource`
* @throws ApiError
*/
export const prefetchUsePlaylistServiceGetApiPlaylists = (queryClient: QueryClient) =&gt; queryClient.prefetchQuery({ queryKey: Common.UsePlaylistServiceGetApiPlaylistsKeyFn(), queryFn: () =&gt; PlaylistService.getApiPlaylists() });
/**
* Show a playlist
* @param data The data for the request.
* @param data.playlist The playlist public id
* @param data.relations
* @returns PlaylistResource `PlaylistResource`
* @throws ApiError
*/
export const prefetchUsePlaylistServiceGetApiPlaylistsByPlaylist = (queryClient: QueryClient, { playlist, relations }: {
  playlist: string;
  relations?: string;
}) =&gt; queryClient.prefetchQuery({ queryKey: Common.UsePlaylistServiceGetApiPlaylistsByPlaylistKeyFn({ playlist, relations }), queryFn: () =&gt; PlaylistService.getApiPlaylistsByPlaylist({ playlist, relations }) });
/**
* Get statistics
* @param data The data for the request.
* @param data.playlist The playlist public id
* @returns PlaylistStatistic `PlaylistStatistic`
* @throws ApiError
*/
export const prefetchUsePlaylistServiceGetApiPlaylistsByPlaylistStatistics = (queryClient: QueryClient, { playlist }: {
  playlist: string;
}) =&gt; queryClient.prefetchQuery({ queryKey: Common.UsePlaylistServiceGetApiPlaylistsByPlaylistStatisticsKeyFn({ playlist }), queryFn: () =&gt; PlaylistService.getApiPlaylistsByPlaylistStatistics({ playlist }) });
/**
* Get a collection of monitor entries
* @param data The data for the request.
* @param data.page
* @param data.limit
* @param data.status
* @param data.queue
* @param data.name
* @param data.queuedFirst
* @returns unknown Paginated set of `QueueMonitorResource`
* @throws ApiError
*/
export const prefetchUseQueueServiceGetApiQueueMetrics = (queryClient: QueryClient, { limit, name, page, queue, queuedFirst, status }: {
  limit?: number;
  name?: string;
  page?: number;
  queue?: string;
  queuedFirst?: boolean;
  status?: &quot;running&quot; | &quot;succeeded&quot; | &quot;failed&quot; | &quot;stale&quot; | &quot;queued&quot;;
} = {}) =&gt; queryClient.prefetchQuery({ queryKey: Common.UseQueueServiceGetApiQueueMetricsKeyFn({ limit, name, page, queue, queuedFirst, status }), queryFn: () =&gt; QueueService.getApiQueueMetrics({ limit, name, page, queue, queuedFirst, status }) });
/**
* Get a list of queue names
* @returns unknown
* @throws ApiError
*/
export const prefetchUseQueueServiceGetApiQueueMetricsQueues = (queryClient: QueryClient) =&gt; queryClient.prefetchQuery({ queryKey: Common.UseQueueServiceGetApiQueueMetricsQueuesKeyFn(), queryFn: () =&gt; QueueService.getApiQueueMetricsQueues() });
/**
* Get a metrics collection
* @param data The data for the request.
* @param data.aggregateDays
* @returns unknown
* @throws ApiError
*/
export const prefetchUseQueueServiceGetApiQueueMetricsMetrics = (queryClient: QueryClient, { aggregateDays }: {
  aggregateDays?: number;
} = {}) =&gt; queryClient.prefetchQuery({ queryKey: Common.UseQueueServiceGetApiQueueMetricsMetricsKeyFn({ aggregateDays }), queryFn: () =&gt; QueueService.getApiQueueMetricsMetrics({ aggregateDays }) });
/**
* Get all of the measured queues
* @returns unknown
* @throws ApiError
*/
export const prefetchUseQueueMetricsServiceGetHorizonApiMetricsQueues = (queryClient: QueryClient) =&gt; queryClient.prefetchQuery({ queryKey: Common.UseQueueMetricsServiceGetHorizonApiMetricsQueuesKeyFn(), queryFn: () =&gt; QueueMetricsService.getHorizonApiMetricsQueues() });
/**
* Get metrics for a given queue
* @param data The data for the request.
* @param data.id
* @returns unknown
* @throws ApiError
*/
export const prefetchUseQueueMetricsServiceGetHorizonApiMetricsQueuesById = (queryClient: QueryClient, { id }: {
  id: string;
}) =&gt; queryClient.prefetchQuery({ queryKey: Common.UseQueueMetricsServiceGetHorizonApiMetricsQueuesByIdKeyFn({ id }), queryFn: () =&gt; QueueMetricsService.getHorizonApiMetricsQueuesById({ id }) });
/**
* @returns unknown
* @throws ApiError
*/
export const prefetchUseSchemaServiceGetApiSchemasMusicbrainz = (queryClient: QueryClient) =&gt; queryClient.prefetchQuery({ queryKey: Common.UseSchemaServiceGetApiSchemasMusicbrainzKeyFn(), queryFn: () =&gt; SchemaService.getApiSchemasMusicbrainz() });
/**
* Get all of the silenced jobs
* @param data The data for the request.
* @param data.startingAt
* @returns unknown
* @throws ApiError
*/
export const prefetchUseSilencedJobsServiceGetHorizonApiJobsSilenced = (queryClient: QueryClient, { startingAt }: {
  startingAt?: string;
} = {}) =&gt; queryClient.prefetchQuery({ queryKey: Common.UseSilencedJobsServiceGetHorizonApiJobsSilencedKeyFn({ startingAt }), queryFn: () =&gt; SilencedJobsService.getHorizonApiJobsSilenced({ startingAt }) });
/**
* Get a collection of songs
* @param data The data for the request.
* @param data.library The library slug
* @param data.page
* @param data.limit
* @param data.genreNames
* @param data.genreSlugs
* @param data.relations
* @returns unknown Paginated set of `SongResource`
* @throws ApiError
*/
export const prefetchUseSongServiceGetApiLibrariesByLibrarySongs = (queryClient: QueryClient, { genreNames, genreSlugs, library, limit, page, relations }: {
  genreNames?: string;
  genreSlugs?: string;
  library: string;
  limit?: number;
  page?: number;
  relations?: string;
}) =&gt; queryClient.prefetchQuery({ queryKey: Common.UseSongServiceGetApiLibrariesByLibrarySongsKeyFn({ genreNames, genreSlugs, library, limit, page, relations }), queryFn: () =&gt; SongService.getApiLibrariesByLibrarySongs({ genreNames, genreSlugs, library, limit, page, relations }) });
/**
* Get a song by public id
* @param data The data for the request.
* @param data.library The library slug
* @param data.publicId
* @param data.relations
* @returns SongResource `SongResource`
* @throws ApiError
*/
export const prefetchUseSongServiceGetApiLibrariesByLibrarySongsByPublicId = (queryClient: QueryClient, { library, publicId, relations }: {
  library: string;
  publicId: string;
  relations?: string;
}) =&gt; queryClient.prefetchQuery({ queryKey: Common.UseSongServiceGetApiLibrariesByLibrarySongsByPublicIdKeyFn({ library, publicId, relations }), queryFn: () =&gt; SongService.getApiLibrariesByLibrarySongsByPublicId({ library, publicId, relations }) });
/**
* Direct stream the song.
* Requires token with &quot;access-stream&quot;
* @param data The data for the request.
* @param data.song The song public id
* @returns unknown
* @throws ApiError
*/
export const prefetchUseStreamServiceGetApiStreamSongBySongDirect = (queryClient: QueryClient, { song }: {
  song: string;
}) =&gt; queryClient.prefetchQuery({ queryKey: Common.UseStreamServiceGetApiStreamSongBySongDirectKeyFn({ song }), queryFn: () =&gt; StreamService.getApiStreamSongBySongDirect({ song }) });
/**
* Get php info
* @returns unknown
* @throws ApiError
*/
export const prefetchUseSystemInfoServiceGetApiSystemInfo = (queryClient: QueryClient) =&gt; queryClient.prefetchQuery({ queryKey: Common.UseSystemInfoServiceGetApiSystemInfoKeyFn(), queryFn: () =&gt; SystemInfoService.getApiSystemInfo() });
/**
* @returns unknown
* @throws ApiError
*/
export const prefetchUseSystemInfoServiceGetApiSystemInfoSys = (queryClient: QueryClient) =&gt; queryClient.prefetchQuery({ queryKey: Common.UseSystemInfoServiceGetApiSystemInfoSysKeyFn(), queryFn: () =&gt; SystemInfoService.getApiSystemInfoSys() });
/**
* Get a collection of users
* @param data The data for the request.
* @param data.page
* @param data.limit
* @param data.globalFilter
* @param data.filters
* @param data.filterModes
* @param data.sorting
* @returns unknown Paginated set of `UserResource`
* @throws ApiError
*/
export const prefetchUseUserServiceGetApiUsers = (queryClient: QueryClient, { filterModes, filters, globalFilter, limit, page, sorting }: {
  filterModes?: string;
  filters?: string;
  globalFilter?: string;
  limit?: number;
  page?: number;
  sorting?: string;
} = {}) =&gt; queryClient.prefetchQuery({ queryKey: Common.UseUserServiceGetApiUsersKeyFn({ filterModes, filters, globalFilter, limit, page, sorting }), queryFn: () =&gt; UserService.getApiUsers({ filterModes, filters, globalFilter, limit, page, sorting }) });
/**
* Get small user detail info
* @param data The data for the request.
* @param data.user The user ID
* @returns UserResource `UserResource`
* @throws ApiError
*/
export const prefetchUseUserServiceGetApiUsersByUser = (queryClient: QueryClient, { user }: {
  user: number;
}) =&gt; queryClient.prefetchQuery({ queryKey: Common.UseUserServiceGetApiUsersByUserKeyFn({ user }), queryFn: () =&gt; UserService.getApiUsersByUser({ user }) });
/**
* Get the authenticated user
* @returns UserResource `UserResource`
* @throws ApiError
*/
export const prefetchUseUserServiceGetApiUsersMe = (queryClient: QueryClient) =&gt; queryClient.prefetchQuery({ queryKey: Common.UseUserServiceGetApiUsersMeKeyFn(), queryFn: () =&gt; UserService.getApiUsersMe() });
/**
* Get a collection of tokens
* @param data The data for the request.
* @param data.user
* @param data.page
* @param data.perPage
* @returns unknown Paginated set of `PersonalAccessTokenViewResource`
* @throws ApiError
*/
export const prefetchUseUserTokenServiceGetApiUsersTokensByUser = (queryClient: QueryClient, { page, perPage, user }: {
  page?: number;
  perPage?: number;
  user: string;
}) =&gt; queryClient.prefetchQuery({ queryKey: Common.UseUserTokenServiceGetApiUsersTokensByUserKeyFn({ page, perPage, user }), queryFn: () =&gt; UserTokenService.getApiUsersTokensByUser({ page, perPage, user }) });
/**
* Get the current queue workload for the application
* @returns unknown
* @throws ApiError
*/
export const prefetchUseWorkloadServiceGetHorizonApiWorkload = (queryClient: QueryClient) =&gt; queryClient.prefetchQuery({ queryKey: Common.UseWorkloadServiceGetHorizonApiWorkloadKeyFn(), queryFn: () =&gt; WorkloadService.getHorizonApiWorkload() });</file><file path="resources/app/api-client/queries/suspense.ts">// generated with @7nohe/openapi-react-query-codegen@1.6.2 
import { UseQueryOptions, useSuspenseQuery } from &quot;@tanstack/react-query&quot;;
import { AlbumService, ArtistService, AuthService, BatchesService, CompletedJobsService, DashboardStatsService, FailedJobsService, FilesService, FoldersService, GenreService, HostsService, ImageService, JobMetricsService, JobsService, LibraryService, LogsService, MasterSupervisorService, MonitoringService, MovieService, OpCacheService, PasskeyService, PendingJobsService, PlaylistService, QueueMetricsService, QueueService, SchemaService, SilencedJobsService, SongService, StreamService, SystemInfoService, UserService, UserTokenService, WorkloadService } from &quot;../requests/services.gen&quot;;
import * as Common from &quot;./common&quot;;
/**
* Get a collection of albums
* @param data The data for the request.
* @param data.library The library slug
* @param data.fields
* @param data.relations
* @param data.page
* @param data.limit
* @param data.genres
* @returns unknown Paginated set of `AlbumResource`
* @throws ApiError
*/
export const useAlbumServiceGetApiLibrariesByLibraryAlbumsSuspense = &lt;TData = Common.AlbumServiceGetApiLibrariesByLibraryAlbumsDefaultResponse, TError = unknown, TQueryKey extends Array&lt;unknown&gt; = unknown[]&gt;({ fields, genres, library, limit, page, relations }: {
  fields?: string;
  genres?: string;
  library: string;
  limit?: number;
  page?: number;
  relations?: string;
}, queryKey?: TQueryKey, options?: Omit&lt;UseQueryOptions&lt;TData, TError&gt;, &quot;queryKey&quot; | &quot;queryFn&quot;&gt;) =&gt; useSuspenseQuery&lt;TData, TError&gt;({ queryKey: Common.UseAlbumServiceGetApiLibrariesByLibraryAlbumsKeyFn({ fields, genres, library, limit, page, relations }, queryKey), queryFn: () =&gt; AlbumService.getApiLibrariesByLibraryAlbums({ fields, genres, library, limit, page, relations }) as TData, ...options });
/**
* Get an album
* @param data The data for the request.
* @param data.library The library slug
* @param data.album The album slug
* @returns AlbumResource `AlbumResource`
* @throws ApiError
*/
export const useAlbumServiceGetApiLibrariesByLibraryAlbumsByAlbumSuspense = &lt;TData = Common.AlbumServiceGetApiLibrariesByLibraryAlbumsByAlbumDefaultResponse, TError = unknown, TQueryKey extends Array&lt;unknown&gt; = unknown[]&gt;({ album, library }: {
  album: string;
  library: string;
}, queryKey?: TQueryKey, options?: Omit&lt;UseQueryOptions&lt;TData, TError&gt;, &quot;queryKey&quot; | &quot;queryFn&quot;&gt;) =&gt; useSuspenseQuery&lt;TData, TError&gt;({ queryKey: Common.UseAlbumServiceGetApiLibrariesByLibraryAlbumsByAlbumKeyFn({ album, library }, queryKey), queryFn: () =&gt; AlbumService.getApiLibrariesByLibraryAlbumsByAlbum({ album, library }) as TData, ...options });
/**
* Get a collection of artists
* @param data The data for the request.
* @param data.library
* @param data.fields
* @param data.relations
* @param data.page
* @param data.limit
* @param data.genres
* @returns unknown Paginated set of `ArtistResource`
* @throws ApiError
*/
export const useArtistServiceGetApiLibrariesByLibraryArtistsSuspense = &lt;TData = Common.ArtistServiceGetApiLibrariesByLibraryArtistsDefaultResponse, TError = unknown, TQueryKey extends Array&lt;unknown&gt; = unknown[]&gt;({ fields, genres, library, limit, page, relations }: {
  fields?: string;
  genres?: string;
  library: string;
  limit?: number;
  page?: number;
  relations?: string;
}, queryKey?: TQueryKey, options?: Omit&lt;UseQueryOptions&lt;TData, TError&gt;, &quot;queryKey&quot; | &quot;queryFn&quot;&gt;) =&gt; useSuspenseQuery&lt;TData, TError&gt;({ queryKey: Common.UseArtistServiceGetApiLibrariesByLibraryArtistsKeyFn({ fields, genres, library, limit, page, relations }, queryKey), queryFn: () =&gt; ArtistService.getApiLibrariesByLibraryArtists({ fields, genres, library, limit, page, relations }) as TData, ...options });
/**
* Get an artist
* @param data The data for the request.
* @param data.library
* @param data.artist The artist slug
* @returns ArtistResource `ArtistResource`
* @throws ApiError
*/
export const useArtistServiceGetApiLibrariesByLibraryArtistsByArtistSuspense = &lt;TData = Common.ArtistServiceGetApiLibrariesByLibraryArtistsByArtistDefaultResponse, TError = unknown, TQueryKey extends Array&lt;unknown&gt; = unknown[]&gt;({ artist, library }: {
  artist: string;
  library: string;
}, queryKey?: TQueryKey, options?: Omit&lt;UseQueryOptions&lt;TData, TError&gt;, &quot;queryKey&quot; | &quot;queryFn&quot;&gt;) =&gt; useSuspenseQuery&lt;TData, TError&gt;({ queryKey: Common.UseArtistServiceGetApiLibrariesByLibraryArtistsByArtistKeyFn({ artist, library }, queryKey), queryFn: () =&gt; ArtistService.getApiLibrariesByLibraryArtistsByArtist({ artist, library }) as TData, ...options });
/**
* Get a passkey challenge
* @returns unknown
* @throws ApiError
*/
export const useAuthServiceGetWebauthnPasskeySuspense = &lt;TData = Common.AuthServiceGetWebauthnPasskeyDefaultResponse, TError = unknown, TQueryKey extends Array&lt;unknown&gt; = unknown[]&gt;(queryKey?: TQueryKey, options?: Omit&lt;UseQueryOptions&lt;TData, TError&gt;, &quot;queryKey&quot; | &quot;queryFn&quot;&gt;) =&gt; useSuspenseQuery&lt;TData, TError&gt;({ queryKey: Common.UseAuthServiceGetWebauthnPasskeyKeyFn(queryKey), queryFn: () =&gt; AuthService.getWebauthnPasskey() as TData, ...options });
/**
* Get passkey registration options
* @returns unknown
* @throws ApiError
*/
export const useAuthServiceGetWebauthnPasskeyRegisterSuspense = &lt;TData = Common.AuthServiceGetWebauthnPasskeyRegisterDefaultResponse, TError = unknown, TQueryKey extends Array&lt;unknown&gt; = unknown[]&gt;(queryKey?: TQueryKey, options?: Omit&lt;UseQueryOptions&lt;TData, TError&gt;, &quot;queryKey&quot; | &quot;queryFn&quot;&gt;) =&gt; useSuspenseQuery&lt;TData, TError&gt;({ queryKey: Common.UseAuthServiceGetWebauthnPasskeyRegisterKeyFn(queryKey), queryFn: () =&gt; AuthService.getWebauthnPasskeyRegister() as TData, ...options });
/**
* Get a passkey challenge
* @returns unknown
* @throws ApiError
*/
export const usePasskeyServiceGetWebauthnPasskeySuspense = &lt;TData = Common.PasskeyServiceGetWebauthnPasskeyDefaultResponse, TError = unknown, TQueryKey extends Array&lt;unknown&gt; = unknown[]&gt;(queryKey?: TQueryKey, options?: Omit&lt;UseQueryOptions&lt;TData, TError&gt;, &quot;queryKey&quot; | &quot;queryFn&quot;&gt;) =&gt; useSuspenseQuery&lt;TData, TError&gt;({ queryKey: Common.UsePasskeyServiceGetWebauthnPasskeyKeyFn(queryKey), queryFn: () =&gt; PasskeyService.getWebauthnPasskey() as TData, ...options });
/**
* Get passkey registration options
* @returns unknown
* @throws ApiError
*/
export const usePasskeyServiceGetWebauthnPasskeyRegisterSuspense = &lt;TData = Common.PasskeyServiceGetWebauthnPasskeyRegisterDefaultResponse, TError = unknown, TQueryKey extends Array&lt;unknown&gt; = unknown[]&gt;(queryKey?: TQueryKey, options?: Omit&lt;UseQueryOptions&lt;TData, TError&gt;, &quot;queryKey&quot; | &quot;queryFn&quot;&gt;) =&gt; useSuspenseQuery&lt;TData, TError&gt;({ queryKey: Common.UsePasskeyServiceGetWebauthnPasskeyRegisterKeyFn(queryKey), queryFn: () =&gt; PasskeyService.getWebauthnPasskeyRegister() as TData, ...options });
/**
* Get all of the batches
* @returns unknown
* @throws ApiError
*/
export const useBatchesServiceGetHorizonApiBatchesSuspense = &lt;TData = Common.BatchesServiceGetHorizonApiBatchesDefaultResponse, TError = unknown, TQueryKey extends Array&lt;unknown&gt; = unknown[]&gt;(queryKey?: TQueryKey, options?: Omit&lt;UseQueryOptions&lt;TData, TError&gt;, &quot;queryKey&quot; | &quot;queryFn&quot;&gt;) =&gt; useSuspenseQuery&lt;TData, TError&gt;({ queryKey: Common.UseBatchesServiceGetHorizonApiBatchesKeyFn(queryKey), queryFn: () =&gt; BatchesService.getHorizonApiBatches() as TData, ...options });
/**
* Get the details of a batch by ID
* @param data The data for the request.
* @param data.id
* @returns unknown
* @throws ApiError
*/
export const useBatchesServiceGetHorizonApiBatchesByIdSuspense = &lt;TData = Common.BatchesServiceGetHorizonApiBatchesByIdDefaultResponse, TError = unknown, TQueryKey extends Array&lt;unknown&gt; = unknown[]&gt;({ id }: {
  id: string;
}, queryKey?: TQueryKey, options?: Omit&lt;UseQueryOptions&lt;TData, TError&gt;, &quot;queryKey&quot; | &quot;queryFn&quot;&gt;) =&gt; useSuspenseQuery&lt;TData, TError&gt;({ queryKey: Common.UseBatchesServiceGetHorizonApiBatchesByIdKeyFn({ id }, queryKey), queryFn: () =&gt; BatchesService.getHorizonApiBatchesById({ id }) as TData, ...options });
/**
* Get all of the completed jobs
* @param data The data for the request.
* @param data.startingAt
* @returns unknown
* @throws ApiError
*/
export const useCompletedJobsServiceGetHorizonApiJobsCompletedSuspense = &lt;TData = Common.CompletedJobsServiceGetHorizonApiJobsCompletedDefaultResponse, TError = unknown, TQueryKey extends Array&lt;unknown&gt; = unknown[]&gt;({ startingAt }: {
  startingAt?: string;
} = {}, queryKey?: TQueryKey, options?: Omit&lt;UseQueryOptions&lt;TData, TError&gt;, &quot;queryKey&quot; | &quot;queryFn&quot;&gt;) =&gt; useSuspenseQuery&lt;TData, TError&gt;({ queryKey: Common.UseCompletedJobsServiceGetHorizonApiJobsCompletedKeyFn({ startingAt }, queryKey), queryFn: () =&gt; CompletedJobsService.getHorizonApiJobsCompleted({ startingAt }) as TData, ...options });
/**
* Get the key performance stats for the dashboard
* @returns unknown
* @throws ApiError
*/
export const useDashboardStatsServiceGetHorizonApiStatsSuspense = &lt;TData = Common.DashboardStatsServiceGetHorizonApiStatsDefaultResponse, TError = unknown, TQueryKey extends Array&lt;unknown&gt; = unknown[]&gt;(queryKey?: TQueryKey, options?: Omit&lt;UseQueryOptions&lt;TData, TError&gt;, &quot;queryKey&quot; | &quot;queryFn&quot;&gt;) =&gt; useSuspenseQuery&lt;TData, TError&gt;({ queryKey: Common.UseDashboardStatsServiceGetHorizonApiStatsKeyFn(queryKey), queryFn: () =&gt; DashboardStatsService.getHorizonApiStats() as TData, ...options });
/**
* Get all of the failed jobs
* @param data The data for the request.
* @param data.tag
* @returns unknown
* @throws ApiError
*/
export const useFailedJobsServiceGetHorizonApiJobsFailedSuspense = &lt;TData = Common.FailedJobsServiceGetHorizonApiJobsFailedDefaultResponse, TError = unknown, TQueryKey extends Array&lt;unknown&gt; = unknown[]&gt;({ tag }: {
  tag?: string;
} = {}, queryKey?: TQueryKey, options?: Omit&lt;UseQueryOptions&lt;TData, TError&gt;, &quot;queryKey&quot; | &quot;queryFn&quot;&gt;) =&gt; useSuspenseQuery&lt;TData, TError&gt;({ queryKey: Common.UseFailedJobsServiceGetHorizonApiJobsFailedKeyFn({ tag }, queryKey), queryFn: () =&gt; FailedJobsService.getHorizonApiJobsFailed({ tag }) as TData, ...options });
/**
* Get a failed job instance
* @param data The data for the request.
* @param data.id
* @returns unknown
* @throws ApiError
*/
export const useFailedJobsServiceGetHorizonApiJobsFailedByIdSuspense = &lt;TData = Common.FailedJobsServiceGetHorizonApiJobsFailedByIdDefaultResponse, TError = unknown, TQueryKey extends Array&lt;unknown&gt; = unknown[]&gt;({ id }: {
  id: string;
}, queryKey?: TQueryKey, options?: Omit&lt;UseQueryOptions&lt;TData, TError&gt;, &quot;queryKey&quot; | &quot;queryFn&quot;&gt;) =&gt; useSuspenseQuery&lt;TData, TError&gt;({ queryKey: Common.UseFailedJobsServiceGetHorizonApiJobsFailedByIdKeyFn({ id }, queryKey), queryFn: () =&gt; FailedJobsService.getHorizonApiJobsFailedById({ id }) as TData, ...options });
/**
* @returns LogFileResource Array of `LogFileResource`
* @throws ApiError
*/
export const useFilesServiceGetSystemLogViewerApiFilesSuspense = &lt;TData = Common.FilesServiceGetSystemLogViewerApiFilesDefaultResponse, TError = unknown, TQueryKey extends Array&lt;unknown&gt; = unknown[]&gt;(queryKey?: TQueryKey, options?: Omit&lt;UseQueryOptions&lt;TData, TError&gt;, &quot;queryKey&quot; | &quot;queryFn&quot;&gt;) =&gt; useSuspenseQuery&lt;TData, TError&gt;({ queryKey: Common.UseFilesServiceGetSystemLogViewerApiFilesKeyFn(queryKey), queryFn: () =&gt; FilesService.getSystemLogViewerApiFiles() as TData, ...options });
/**
* @param data The data for the request.
* @param data.fileIdentifier
* @returns unknown
* @throws ApiError
*/
export const useFilesServiceGetSystemLogViewerApiFilesByFileIdentifierDownloadRequestSuspense = &lt;TData = Common.FilesServiceGetSystemLogViewerApiFilesByFileIdentifierDownloadRequestDefaultResponse, TError = unknown, TQueryKey extends Array&lt;unknown&gt; = unknown[]&gt;({ fileIdentifier }: {
  fileIdentifier: string;
}, queryKey?: TQueryKey, options?: Omit&lt;UseQueryOptions&lt;TData, TError&gt;, &quot;queryKey&quot; | &quot;queryFn&quot;&gt;) =&gt; useSuspenseQuery&lt;TData, TError&gt;({ queryKey: Common.UseFilesServiceGetSystemLogViewerApiFilesByFileIdentifierDownloadRequestKeyFn({ fileIdentifier }, queryKey), queryFn: () =&gt; FilesService.getSystemLogViewerApiFilesByFileIdentifierDownloadRequest({ fileIdentifier }) as TData, ...options });
/**
* @param data The data for the request.
* @param data.fileIdentifier
* @returns string
* @throws ApiError
*/
export const useFilesServiceGetSystemLogViewerApiFilesByFileIdentifierDownloadSuspense = &lt;TData = Common.FilesServiceGetSystemLogViewerApiFilesByFileIdentifierDownloadDefaultResponse, TError = unknown, TQueryKey extends Array&lt;unknown&gt; = unknown[]&gt;({ fileIdentifier }: {
  fileIdentifier: string;
}, queryKey?: TQueryKey, options?: Omit&lt;UseQueryOptions&lt;TData, TError&gt;, &quot;queryKey&quot; | &quot;queryFn&quot;&gt;) =&gt; useSuspenseQuery&lt;TData, TError&gt;({ queryKey: Common.UseFilesServiceGetSystemLogViewerApiFilesByFileIdentifierDownloadKeyFn({ fileIdentifier }, queryKey), queryFn: () =&gt; FilesService.getSystemLogViewerApiFilesByFileIdentifierDownload({ fileIdentifier }) as TData, ...options });
/**
* @param data The data for the request.
* @param data.direction
* @returns LogFolderResource Array of `LogFolderResource`
* @throws ApiError
*/
export const useFoldersServiceGetSystemLogViewerApiFoldersSuspense = &lt;TData = Common.FoldersServiceGetSystemLogViewerApiFoldersDefaultResponse, TError = unknown, TQueryKey extends Array&lt;unknown&gt; = unknown[]&gt;({ direction }: {
  direction?: string;
} = {}, queryKey?: TQueryKey, options?: Omit&lt;UseQueryOptions&lt;TData, TError&gt;, &quot;queryKey&quot; | &quot;queryFn&quot;&gt;) =&gt; useSuspenseQuery&lt;TData, TError&gt;({ queryKey: Common.UseFoldersServiceGetSystemLogViewerApiFoldersKeyFn({ direction }, queryKey), queryFn: () =&gt; FoldersService.getSystemLogViewerApiFolders({ direction }) as TData, ...options });
/**
* @param data The data for the request.
* @param data.folderIdentifier
* @returns unknown
* @throws ApiError
*/
export const useFoldersServiceGetSystemLogViewerApiFoldersByFolderIdentifierDownloadRequestSuspense = &lt;TData = Common.FoldersServiceGetSystemLogViewerApiFoldersByFolderIdentifierDownloadRequestDefaultResponse, TError = unknown, TQueryKey extends Array&lt;unknown&gt; = unknown[]&gt;({ folderIdentifier }: {
  folderIdentifier: string;
}, queryKey?: TQueryKey, options?: Omit&lt;UseQueryOptions&lt;TData, TError&gt;, &quot;queryKey&quot; | &quot;queryFn&quot;&gt;) =&gt; useSuspenseQuery&lt;TData, TError&gt;({ queryKey: Common.UseFoldersServiceGetSystemLogViewerApiFoldersByFolderIdentifierDownloadRequestKeyFn({ folderIdentifier }, queryKey), queryFn: () =&gt; FoldersService.getSystemLogViewerApiFoldersByFolderIdentifierDownloadRequest({ folderIdentifier }) as TData, ...options });
/**
* @param data The data for the request.
* @param data.folderIdentifier
* @returns string
* @throws ApiError
*/
export const useFoldersServiceGetSystemLogViewerApiFoldersByFolderIdentifierDownloadSuspense = &lt;TData = Common.FoldersServiceGetSystemLogViewerApiFoldersByFolderIdentifierDownloadDefaultResponse, TError = unknown, TQueryKey extends Array&lt;unknown&gt; = unknown[]&gt;({ folderIdentifier }: {
  folderIdentifier: string;
}, queryKey?: TQueryKey, options?: Omit&lt;UseQueryOptions&lt;TData, TError&gt;, &quot;queryKey&quot; | &quot;queryFn&quot;&gt;) =&gt; useSuspenseQuery&lt;TData, TError&gt;({ queryKey: Common.UseFoldersServiceGetSystemLogViewerApiFoldersByFolderIdentifierDownloadKeyFn({ folderIdentifier }, queryKey), queryFn: () =&gt; FoldersService.getSystemLogViewerApiFoldersByFolderIdentifierDownload({ folderIdentifier }) as TData, ...options });
/**
* Get a collection of genres
* @param data The data for the request.
* @param data.fields
* @param data.relations
* @param data.librarySlug
* @param data.page
* @param data.limit
* @returns unknown Paginated set of `GenreResource`
* @throws ApiError
*/
export const useGenreServiceGetApiGenresSuspense = &lt;TData = Common.GenreServiceGetApiGenresDefaultResponse, TError = unknown, TQueryKey extends Array&lt;unknown&gt; = unknown[]&gt;({ fields, librarySlug, limit, page, relations }: {
  fields?: string;
  librarySlug?: string;
  limit?: number;
  page?: number;
  relations?: string;
} = {}, queryKey?: TQueryKey, options?: Omit&lt;UseQueryOptions&lt;TData, TError&gt;, &quot;queryKey&quot; | &quot;queryFn&quot;&gt;) =&gt; useSuspenseQuery&lt;TData, TError&gt;({ queryKey: Common.UseGenreServiceGetApiGenresKeyFn({ fields, librarySlug, limit, page, relations }, queryKey), queryFn: () =&gt; GenreService.getApiGenres({ fields, librarySlug, limit, page, relations }) as TData, ...options });
/**
* Get a genre
* @param data The data for the request.
* @param data.genre The genre slug
* @returns GenreResource `GenreResource`
* @throws ApiError
*/
export const useGenreServiceGetApiGenresByGenreSuspense = &lt;TData = Common.GenreServiceGetApiGenresByGenreDefaultResponse, TError = unknown, TQueryKey extends Array&lt;unknown&gt; = unknown[]&gt;({ genre }: {
  genre: string;
}, queryKey?: TQueryKey, options?: Omit&lt;UseQueryOptions&lt;TData, TError&gt;, &quot;queryKey&quot; | &quot;queryFn&quot;&gt;) =&gt; useSuspenseQuery&lt;TData, TError&gt;({ queryKey: Common.UseGenreServiceGetApiGenresByGenreKeyFn({ genre }, queryKey), queryFn: () =&gt; GenreService.getApiGenresByGenre({ genre }) as TData, ...options });
/**
* @returns LogViewerHostResource Array of `LogViewerHostResource`
* @throws ApiError
*/
export const useHostsServiceGetSystemLogViewerApiHostsSuspense = &lt;TData = Common.HostsServiceGetSystemLogViewerApiHostsDefaultResponse, TError = unknown, TQueryKey extends Array&lt;unknown&gt; = unknown[]&gt;(queryKey?: TQueryKey, options?: Omit&lt;UseQueryOptions&lt;TData, TError&gt;, &quot;queryKey&quot; | &quot;queryFn&quot;&gt;) =&gt; useSuspenseQuery&lt;TData, TError&gt;({ queryKey: Common.UseHostsServiceGetSystemLogViewerApiHostsKeyFn(queryKey), queryFn: () =&gt; HostsService.getSystemLogViewerApiHosts() as TData, ...options });
/**
* Get an image asset
* @param data The data for the request.
* @param data.image The image public id
* @returns string
* @throws ApiError
*/
export const useImageServiceGetApiImagesByImageSuspense = &lt;TData = Common.ImageServiceGetApiImagesByImageDefaultResponse, TError = unknown, TQueryKey extends Array&lt;unknown&gt; = unknown[]&gt;({ image }: {
  image: string;
}, queryKey?: TQueryKey, options?: Omit&lt;UseQueryOptions&lt;TData, TError&gt;, &quot;queryKey&quot; | &quot;queryFn&quot;&gt;) =&gt; useSuspenseQuery&lt;TData, TError&gt;({ queryKey: Common.UseImageServiceGetApiImagesByImageKeyFn({ image }, queryKey), queryFn: () =&gt; ImageService.getApiImagesByImage({ image }) as TData, ...options });
/**
* Get all of the measured jobs
* @returns unknown
* @throws ApiError
*/
export const useJobMetricsServiceGetHorizonApiMetricsJobsSuspense = &lt;TData = Common.JobMetricsServiceGetHorizonApiMetricsJobsDefaultResponse, TError = unknown, TQueryKey extends Array&lt;unknown&gt; = unknown[]&gt;(queryKey?: TQueryKey, options?: Omit&lt;UseQueryOptions&lt;TData, TError&gt;, &quot;queryKey&quot; | &quot;queryFn&quot;&gt;) =&gt; useSuspenseQuery&lt;TData, TError&gt;({ queryKey: Common.UseJobMetricsServiceGetHorizonApiMetricsJobsKeyFn(queryKey), queryFn: () =&gt; JobMetricsService.getHorizonApiMetricsJobs() as TData, ...options });
/**
* Get metrics for a given job
* @param data The data for the request.
* @param data.id
* @returns unknown
* @throws ApiError
*/
export const useJobMetricsServiceGetHorizonApiMetricsJobsByIdSuspense = &lt;TData = Common.JobMetricsServiceGetHorizonApiMetricsJobsByIdDefaultResponse, TError = unknown, TQueryKey extends Array&lt;unknown&gt; = unknown[]&gt;({ id }: {
  id: string;
}, queryKey?: TQueryKey, options?: Omit&lt;UseQueryOptions&lt;TData, TError&gt;, &quot;queryKey&quot; | &quot;queryFn&quot;&gt;) =&gt; useSuspenseQuery&lt;TData, TError&gt;({ queryKey: Common.UseJobMetricsServiceGetHorizonApiMetricsJobsByIdKeyFn({ id }, queryKey), queryFn: () =&gt; JobMetricsService.getHorizonApiMetricsJobsById({ id }) as TData, ...options });
/**
* Get the details of a recent job by ID
* @param data The data for the request.
* @param data.id
* @returns unknown
* @throws ApiError
*/
export const useJobsServiceGetHorizonApiJobsByIdSuspense = &lt;TData = Common.JobsServiceGetHorizonApiJobsByIdDefaultResponse, TError = unknown, TQueryKey extends Array&lt;unknown&gt; = unknown[]&gt;({ id }: {
  id: string;
}, queryKey?: TQueryKey, options?: Omit&lt;UseQueryOptions&lt;TData, TError&gt;, &quot;queryKey&quot; | &quot;queryFn&quot;&gt;) =&gt; useSuspenseQuery&lt;TData, TError&gt;({ queryKey: Common.UseJobsServiceGetHorizonApiJobsByIdKeyFn({ id }, queryKey), queryFn: () =&gt; JobsService.getHorizonApiJobsById({ id }) as TData, ...options });
/**
* Get a collection of media libraries
* @param data The data for the request.
* @param data.page
* @param data.limit
* @returns unknown Paginated set of `LibraryResource`
* @throws ApiError
*/
export const useLibraryServiceGetApiLibrariesSuspense = &lt;TData = Common.LibraryServiceGetApiLibrariesDefaultResponse, TError = unknown, TQueryKey extends Array&lt;unknown&gt; = unknown[]&gt;({ limit, page }: {
  limit?: number;
  page?: number;
} = {}, queryKey?: TQueryKey, options?: Omit&lt;UseQueryOptions&lt;TData, TError&gt;, &quot;queryKey&quot; | &quot;queryFn&quot;&gt;) =&gt; useSuspenseQuery&lt;TData, TError&gt;({ queryKey: Common.UseLibraryServiceGetApiLibrariesKeyFn({ limit, page }, queryKey), queryFn: () =&gt; LibraryService.getApiLibraries({ limit, page }) as TData, ...options });
/**
* Show library
* @param data The data for the request.
* @param data.slug
* @returns LibraryResource `LibraryResource`
* @throws ApiError
*/
export const useLibraryServiceGetApiLibrariesBySlugSuspense = &lt;TData = Common.LibraryServiceGetApiLibrariesBySlugDefaultResponse, TError = unknown, TQueryKey extends Array&lt;unknown&gt; = unknown[]&gt;({ slug }: {
  slug: string;
}, queryKey?: TQueryKey, options?: Omit&lt;UseQueryOptions&lt;TData, TError&gt;, &quot;queryKey&quot; | &quot;queryFn&quot;&gt;) =&gt; useSuspenseQuery&lt;TData, TError&gt;({ queryKey: Common.UseLibraryServiceGetApiLibrariesBySlugKeyFn({ slug }, queryKey), queryFn: () =&gt; LibraryService.getApiLibrariesBySlug({ slug }) as TData, ...options });
/**
* @param data The data for the request.
* @param data.file
* @param data.query
* @param data.direction
* @param data.log
* @param data.excludeLevels
* @param data.excludeFileTypes
* @param data.perPage
* @param data.shorterStackTraces
* @returns unknown
* @throws ApiError
*/
export const useLogsServiceGetSystemLogViewerApiLogsSuspense = &lt;TData = Common.LogsServiceGetSystemLogViewerApiLogsDefaultResponse, TError = unknown, TQueryKey extends Array&lt;unknown&gt; = unknown[]&gt;({ direction, excludeFileTypes, excludeLevels, file, log, perPage, query, shorterStackTraces }: {
  direction?: string;
  excludeFileTypes?: string;
  excludeLevels?: string;
  file?: string;
  log?: string;
  perPage?: string;
  query?: string;
  shorterStackTraces?: boolean;
} = {}, queryKey?: TQueryKey, options?: Omit&lt;UseQueryOptions&lt;TData, TError&gt;, &quot;queryKey&quot; | &quot;queryFn&quot;&gt;) =&gt; useSuspenseQuery&lt;TData, TError&gt;({ queryKey: Common.UseLogsServiceGetSystemLogViewerApiLogsKeyFn({ direction, excludeFileTypes, excludeLevels, file, log, perPage, query, shorterStackTraces }, queryKey), queryFn: () =&gt; LogsService.getSystemLogViewerApiLogs({ direction, excludeFileTypes, excludeLevels, file, log, perPage, query, shorterStackTraces }) as TData, ...options });
/**
* Get all of the master supervisors and their underlying supervisors
* @returns unknown
* @throws ApiError
*/
export const useMasterSupervisorServiceGetHorizonApiMastersSuspense = &lt;TData = Common.MasterSupervisorServiceGetHorizonApiMastersDefaultResponse, TError = unknown, TQueryKey extends Array&lt;unknown&gt; = unknown[]&gt;(queryKey?: TQueryKey, options?: Omit&lt;UseQueryOptions&lt;TData, TError&gt;, &quot;queryKey&quot; | &quot;queryFn&quot;&gt;) =&gt; useSuspenseQuery&lt;TData, TError&gt;({ queryKey: Common.UseMasterSupervisorServiceGetHorizonApiMastersKeyFn(queryKey), queryFn: () =&gt; MasterSupervisorService.getHorizonApiMasters() as TData, ...options });
/**
* Get all of the monitored tags and their job counts
* @returns unknown
* @throws ApiError
*/
export const useMonitoringServiceGetHorizonApiMonitoringSuspense = &lt;TData = Common.MonitoringServiceGetHorizonApiMonitoringDefaultResponse, TError = unknown, TQueryKey extends Array&lt;unknown&gt; = unknown[]&gt;(queryKey?: TQueryKey, options?: Omit&lt;UseQueryOptions&lt;TData, TError&gt;, &quot;queryKey&quot; | &quot;queryFn&quot;&gt;) =&gt; useSuspenseQuery&lt;TData, TError&gt;({ queryKey: Common.UseMonitoringServiceGetHorizonApiMonitoringKeyFn(queryKey), queryFn: () =&gt; MonitoringService.getHorizonApiMonitoring() as TData, ...options });
/**
* Paginate the jobs for a given tag
* @param data The data for the request.
* @param data.tag
* @param data.limit
* @returns unknown
* @throws ApiError
*/
export const useMonitoringServiceGetHorizonApiMonitoringByTagSuspense = &lt;TData = Common.MonitoringServiceGetHorizonApiMonitoringByTagDefaultResponse, TError = unknown, TQueryKey extends Array&lt;unknown&gt; = unknown[]&gt;({ limit, tag }: {
  limit?: string;
  tag: string;
}, queryKey?: TQueryKey, options?: Omit&lt;UseQueryOptions&lt;TData, TError&gt;, &quot;queryKey&quot; | &quot;queryFn&quot;&gt;) =&gt; useSuspenseQuery&lt;TData, TError&gt;({ queryKey: Common.UseMonitoringServiceGetHorizonApiMonitoringByTagKeyFn({ limit, tag }, queryKey), queryFn: () =&gt; MonitoringService.getHorizonApiMonitoringByTag({ limit, tag }) as TData, ...options });
/**
* Get a collection of movies
* @param data The data for the request.
* @param data.library The library slug
* @returns unknown Paginated set of `MovieResource`
* @throws ApiError
*/
export const useMovieServiceGetApiLibrariesByLibraryMoviesSuspense = &lt;TData = Common.MovieServiceGetApiLibrariesByLibraryMoviesDefaultResponse, TError = unknown, TQueryKey extends Array&lt;unknown&gt; = unknown[]&gt;({ library }: {
  library: string;
}, queryKey?: TQueryKey, options?: Omit&lt;UseQueryOptions&lt;TData, TError&gt;, &quot;queryKey&quot; | &quot;queryFn&quot;&gt;) =&gt; useSuspenseQuery&lt;TData, TError&gt;({ queryKey: Common.UseMovieServiceGetApiLibrariesByLibraryMoviesKeyFn({ library }, queryKey), queryFn: () =&gt; MovieService.getApiLibrariesByLibraryMovies({ library }) as TData, ...options });
/**
* Get a movie
* @param data The data for the request.
* @param data.library The library slug
* @param data.movie The movie slug
* @returns MovieResource `MovieResource`
* @throws ApiError
*/
export const useMovieServiceGetApiLibrariesByLibraryMoviesByMovieSuspense = &lt;TData = Common.MovieServiceGetApiLibrariesByLibraryMoviesByMovieDefaultResponse, TError = unknown, TQueryKey extends Array&lt;unknown&gt; = unknown[]&gt;({ library, movie }: {
  library: string;
  movie: string;
}, queryKey?: TQueryKey, options?: Omit&lt;UseQueryOptions&lt;TData, TError&gt;, &quot;queryKey&quot; | &quot;queryFn&quot;&gt;) =&gt; useSuspenseQuery&lt;TData, TError&gt;({ queryKey: Common.UseMovieServiceGetApiLibrariesByLibraryMoviesByMovieKeyFn({ library, movie }, queryKey), queryFn: () =&gt; MovieService.getApiLibrariesByLibraryMoviesByMovie({ library, movie }) as TData, ...options });
/**
* Get status
* @returns unknown
* @throws ApiError
*/
export const useOpCacheServiceGetApiOpcacheStatusSuspense = &lt;TData = Common.OpCacheServiceGetApiOpcacheStatusDefaultResponse, TError = unknown, TQueryKey extends Array&lt;unknown&gt; = unknown[]&gt;(queryKey?: TQueryKey, options?: Omit&lt;UseQueryOptions&lt;TData, TError&gt;, &quot;queryKey&quot; | &quot;queryFn&quot;&gt;) =&gt; useSuspenseQuery&lt;TData, TError&gt;({ queryKey: Common.UseOpCacheServiceGetApiOpcacheStatusKeyFn(queryKey), queryFn: () =&gt; OpCacheService.getApiOpcacheStatus() as TData, ...options });
/**
* Get config
* @returns unknown
* @throws ApiError
*/
export const useOpCacheServiceGetApiOpcacheConfigSuspense = &lt;TData = Common.OpCacheServiceGetApiOpcacheConfigDefaultResponse, TError = unknown, TQueryKey extends Array&lt;unknown&gt; = unknown[]&gt;(queryKey?: TQueryKey, options?: Omit&lt;UseQueryOptions&lt;TData, TError&gt;, &quot;queryKey&quot; | &quot;queryFn&quot;&gt;) =&gt; useSuspenseQuery&lt;TData, TError&gt;({ queryKey: Common.UseOpCacheServiceGetApiOpcacheConfigKeyFn(queryKey), queryFn: () =&gt; OpCacheService.getApiOpcacheConfig() as TData, ...options });
/**
* Get all of the pending jobs
* @param data The data for the request.
* @param data.startingAt
* @returns unknown
* @throws ApiError
*/
export const usePendingJobsServiceGetHorizonApiJobsPendingSuspense = &lt;TData = Common.PendingJobsServiceGetHorizonApiJobsPendingDefaultResponse, TError = unknown, TQueryKey extends Array&lt;unknown&gt; = unknown[]&gt;({ startingAt }: {
  startingAt?: string;
} = {}, queryKey?: TQueryKey, options?: Omit&lt;UseQueryOptions&lt;TData, TError&gt;, &quot;queryKey&quot; | &quot;queryFn&quot;&gt;) =&gt; useSuspenseQuery&lt;TData, TError&gt;({ queryKey: Common.UsePendingJobsServiceGetHorizonApiJobsPendingKeyFn({ startingAt }, queryKey), queryFn: () =&gt; PendingJobsService.getHorizonApiJobsPending({ startingAt }) as TData, ...options });
/**
* Get a collection of playlists
* @returns unknown Paginated set of `PlaylistResource`
* @throws ApiError
*/
export const usePlaylistServiceGetApiPlaylistsSuspense = &lt;TData = Common.PlaylistServiceGetApiPlaylistsDefaultResponse, TError = unknown, TQueryKey extends Array&lt;unknown&gt; = unknown[]&gt;(queryKey?: TQueryKey, options?: Omit&lt;UseQueryOptions&lt;TData, TError&gt;, &quot;queryKey&quot; | &quot;queryFn&quot;&gt;) =&gt; useSuspenseQuery&lt;TData, TError&gt;({ queryKey: Common.UsePlaylistServiceGetApiPlaylistsKeyFn(queryKey), queryFn: () =&gt; PlaylistService.getApiPlaylists() as TData, ...options });
/**
* Show a playlist
* @param data The data for the request.
* @param data.playlist The playlist public id
* @param data.relations
* @returns PlaylistResource `PlaylistResource`
* @throws ApiError
*/
export const usePlaylistServiceGetApiPlaylistsByPlaylistSuspense = &lt;TData = Common.PlaylistServiceGetApiPlaylistsByPlaylistDefaultResponse, TError = unknown, TQueryKey extends Array&lt;unknown&gt; = unknown[]&gt;({ playlist, relations }: {
  playlist: string;
  relations?: string;
}, queryKey?: TQueryKey, options?: Omit&lt;UseQueryOptions&lt;TData, TError&gt;, &quot;queryKey&quot; | &quot;queryFn&quot;&gt;) =&gt; useSuspenseQuery&lt;TData, TError&gt;({ queryKey: Common.UsePlaylistServiceGetApiPlaylistsByPlaylistKeyFn({ playlist, relations }, queryKey), queryFn: () =&gt; PlaylistService.getApiPlaylistsByPlaylist({ playlist, relations }) as TData, ...options });
/**
* Get statistics
* @param data The data for the request.
* @param data.playlist The playlist public id
* @returns PlaylistStatistic `PlaylistStatistic`
* @throws ApiError
*/
export const usePlaylistServiceGetApiPlaylistsByPlaylistStatisticsSuspense = &lt;TData = Common.PlaylistServiceGetApiPlaylistsByPlaylistStatisticsDefaultResponse, TError = unknown, TQueryKey extends Array&lt;unknown&gt; = unknown[]&gt;({ playlist }: {
  playlist: string;
}, queryKey?: TQueryKey, options?: Omit&lt;UseQueryOptions&lt;TData, TError&gt;, &quot;queryKey&quot; | &quot;queryFn&quot;&gt;) =&gt; useSuspenseQuery&lt;TData, TError&gt;({ queryKey: Common.UsePlaylistServiceGetApiPlaylistsByPlaylistStatisticsKeyFn({ playlist }, queryKey), queryFn: () =&gt; PlaylistService.getApiPlaylistsByPlaylistStatistics({ playlist }) as TData, ...options });
/**
* Get a collection of monitor entries
* @param data The data for the request.
* @param data.page
* @param data.limit
* @param data.status
* @param data.queue
* @param data.name
* @param data.queuedFirst
* @returns unknown Paginated set of `QueueMonitorResource`
* @throws ApiError
*/
export const useQueueServiceGetApiQueueMetricsSuspense = &lt;TData = Common.QueueServiceGetApiQueueMetricsDefaultResponse, TError = unknown, TQueryKey extends Array&lt;unknown&gt; = unknown[]&gt;({ limit, name, page, queue, queuedFirst, status }: {
  limit?: number;
  name?: string;
  page?: number;
  queue?: string;
  queuedFirst?: boolean;
  status?: &quot;running&quot; | &quot;succeeded&quot; | &quot;failed&quot; | &quot;stale&quot; | &quot;queued&quot;;
} = {}, queryKey?: TQueryKey, options?: Omit&lt;UseQueryOptions&lt;TData, TError&gt;, &quot;queryKey&quot; | &quot;queryFn&quot;&gt;) =&gt; useSuspenseQuery&lt;TData, TError&gt;({ queryKey: Common.UseQueueServiceGetApiQueueMetricsKeyFn({ limit, name, page, queue, queuedFirst, status }, queryKey), queryFn: () =&gt; QueueService.getApiQueueMetrics({ limit, name, page, queue, queuedFirst, status }) as TData, ...options });
/**
* Get a list of queue names
* @returns unknown
* @throws ApiError
*/
export const useQueueServiceGetApiQueueMetricsQueuesSuspense = &lt;TData = Common.QueueServiceGetApiQueueMetricsQueuesDefaultResponse, TError = unknown, TQueryKey extends Array&lt;unknown&gt; = unknown[]&gt;(queryKey?: TQueryKey, options?: Omit&lt;UseQueryOptions&lt;TData, TError&gt;, &quot;queryKey&quot; | &quot;queryFn&quot;&gt;) =&gt; useSuspenseQuery&lt;TData, TError&gt;({ queryKey: Common.UseQueueServiceGetApiQueueMetricsQueuesKeyFn(queryKey), queryFn: () =&gt; QueueService.getApiQueueMetricsQueues() as TData, ...options });
/**
* Get a metrics collection
* @param data The data for the request.
* @param data.aggregateDays
* @returns unknown
* @throws ApiError
*/
export const useQueueServiceGetApiQueueMetricsMetricsSuspense = &lt;TData = Common.QueueServiceGetApiQueueMetricsMetricsDefaultResponse, TError = unknown, TQueryKey extends Array&lt;unknown&gt; = unknown[]&gt;({ aggregateDays }: {
  aggregateDays?: number;
} = {}, queryKey?: TQueryKey, options?: Omit&lt;UseQueryOptions&lt;TData, TError&gt;, &quot;queryKey&quot; | &quot;queryFn&quot;&gt;) =&gt; useSuspenseQuery&lt;TData, TError&gt;({ queryKey: Common.UseQueueServiceGetApiQueueMetricsMetricsKeyFn({ aggregateDays }, queryKey), queryFn: () =&gt; QueueService.getApiQueueMetricsMetrics({ aggregateDays }) as TData, ...options });
/**
* Get all of the measured queues
* @returns unknown
* @throws ApiError
*/
export const useQueueMetricsServiceGetHorizonApiMetricsQueuesSuspense = &lt;TData = Common.QueueMetricsServiceGetHorizonApiMetricsQueuesDefaultResponse, TError = unknown, TQueryKey extends Array&lt;unknown&gt; = unknown[]&gt;(queryKey?: TQueryKey, options?: Omit&lt;UseQueryOptions&lt;TData, TError&gt;, &quot;queryKey&quot; | &quot;queryFn&quot;&gt;) =&gt; useSuspenseQuery&lt;TData, TError&gt;({ queryKey: Common.UseQueueMetricsServiceGetHorizonApiMetricsQueuesKeyFn(queryKey), queryFn: () =&gt; QueueMetricsService.getHorizonApiMetricsQueues() as TData, ...options });
/**
* Get metrics for a given queue
* @param data The data for the request.
* @param data.id
* @returns unknown
* @throws ApiError
*/
export const useQueueMetricsServiceGetHorizonApiMetricsQueuesByIdSuspense = &lt;TData = Common.QueueMetricsServiceGetHorizonApiMetricsQueuesByIdDefaultResponse, TError = unknown, TQueryKey extends Array&lt;unknown&gt; = unknown[]&gt;({ id }: {
  id: string;
}, queryKey?: TQueryKey, options?: Omit&lt;UseQueryOptions&lt;TData, TError&gt;, &quot;queryKey&quot; | &quot;queryFn&quot;&gt;) =&gt; useSuspenseQuery&lt;TData, TError&gt;({ queryKey: Common.UseQueueMetricsServiceGetHorizonApiMetricsQueuesByIdKeyFn({ id }, queryKey), queryFn: () =&gt; QueueMetricsService.getHorizonApiMetricsQueuesById({ id }) as TData, ...options });
/**
* @returns unknown
* @throws ApiError
*/
export const useSchemaServiceGetApiSchemasMusicbrainzSuspense = &lt;TData = Common.SchemaServiceGetApiSchemasMusicbrainzDefaultResponse, TError = unknown, TQueryKey extends Array&lt;unknown&gt; = unknown[]&gt;(queryKey?: TQueryKey, options?: Omit&lt;UseQueryOptions&lt;TData, TError&gt;, &quot;queryKey&quot; | &quot;queryFn&quot;&gt;) =&gt; useSuspenseQuery&lt;TData, TError&gt;({ queryKey: Common.UseSchemaServiceGetApiSchemasMusicbrainzKeyFn(queryKey), queryFn: () =&gt; SchemaService.getApiSchemasMusicbrainz() as TData, ...options });
/**
* Get all of the silenced jobs
* @param data The data for the request.
* @param data.startingAt
* @returns unknown
* @throws ApiError
*/
export const useSilencedJobsServiceGetHorizonApiJobsSilencedSuspense = &lt;TData = Common.SilencedJobsServiceGetHorizonApiJobsSilencedDefaultResponse, TError = unknown, TQueryKey extends Array&lt;unknown&gt; = unknown[]&gt;({ startingAt }: {
  startingAt?: string;
} = {}, queryKey?: TQueryKey, options?: Omit&lt;UseQueryOptions&lt;TData, TError&gt;, &quot;queryKey&quot; | &quot;queryFn&quot;&gt;) =&gt; useSuspenseQuery&lt;TData, TError&gt;({ queryKey: Common.UseSilencedJobsServiceGetHorizonApiJobsSilencedKeyFn({ startingAt }, queryKey), queryFn: () =&gt; SilencedJobsService.getHorizonApiJobsSilenced({ startingAt }) as TData, ...options });
/**
* Get a collection of songs
* @param data The data for the request.
* @param data.library The library slug
* @param data.page
* @param data.limit
* @param data.genreNames
* @param data.genreSlugs
* @param data.relations
* @returns unknown Paginated set of `SongResource`
* @throws ApiError
*/
export const useSongServiceGetApiLibrariesByLibrarySongsSuspense = &lt;TData = Common.SongServiceGetApiLibrariesByLibrarySongsDefaultResponse, TError = unknown, TQueryKey extends Array&lt;unknown&gt; = unknown[]&gt;({ genreNames, genreSlugs, library, limit, page, relations }: {
  genreNames?: string;
  genreSlugs?: string;
  library: string;
  limit?: number;
  page?: number;
  relations?: string;
}, queryKey?: TQueryKey, options?: Omit&lt;UseQueryOptions&lt;TData, TError&gt;, &quot;queryKey&quot; | &quot;queryFn&quot;&gt;) =&gt; useSuspenseQuery&lt;TData, TError&gt;({ queryKey: Common.UseSongServiceGetApiLibrariesByLibrarySongsKeyFn({ genreNames, genreSlugs, library, limit, page, relations }, queryKey), queryFn: () =&gt; SongService.getApiLibrariesByLibrarySongs({ genreNames, genreSlugs, library, limit, page, relations }) as TData, ...options });
/**
* Get a song by public id
* @param data The data for the request.
* @param data.library The library slug
* @param data.publicId
* @param data.relations
* @returns SongResource `SongResource`
* @throws ApiError
*/
export const useSongServiceGetApiLibrariesByLibrarySongsByPublicIdSuspense = &lt;TData = Common.SongServiceGetApiLibrariesByLibrarySongsByPublicIdDefaultResponse, TError = unknown, TQueryKey extends Array&lt;unknown&gt; = unknown[]&gt;({ library, publicId, relations }: {
  library: string;
  publicId: string;
  relations?: string;
}, queryKey?: TQueryKey, options?: Omit&lt;UseQueryOptions&lt;TData, TError&gt;, &quot;queryKey&quot; | &quot;queryFn&quot;&gt;) =&gt; useSuspenseQuery&lt;TData, TError&gt;({ queryKey: Common.UseSongServiceGetApiLibrariesByLibrarySongsByPublicIdKeyFn({ library, publicId, relations }, queryKey), queryFn: () =&gt; SongService.getApiLibrariesByLibrarySongsByPublicId({ library, publicId, relations }) as TData, ...options });
/**
* Direct stream the song.
* Requires token with &quot;access-stream&quot;
* @param data The data for the request.
* @param data.song The song public id
* @returns unknown
* @throws ApiError
*/
export const useStreamServiceGetApiStreamSongBySongDirectSuspense = &lt;TData = Common.StreamServiceGetApiStreamSongBySongDirectDefaultResponse, TError = unknown, TQueryKey extends Array&lt;unknown&gt; = unknown[]&gt;({ song }: {
  song: string;
}, queryKey?: TQueryKey, options?: Omit&lt;UseQueryOptions&lt;TData, TError&gt;, &quot;queryKey&quot; | &quot;queryFn&quot;&gt;) =&gt; useSuspenseQuery&lt;TData, TError&gt;({ queryKey: Common.UseStreamServiceGetApiStreamSongBySongDirectKeyFn({ song }, queryKey), queryFn: () =&gt; StreamService.getApiStreamSongBySongDirect({ song }) as TData, ...options });
/**
* Get php info
* @returns unknown
* @throws ApiError
*/
export const useSystemInfoServiceGetApiSystemInfoSuspense = &lt;TData = Common.SystemInfoServiceGetApiSystemInfoDefaultResponse, TError = unknown, TQueryKey extends Array&lt;unknown&gt; = unknown[]&gt;(queryKey?: TQueryKey, options?: Omit&lt;UseQueryOptions&lt;TData, TError&gt;, &quot;queryKey&quot; | &quot;queryFn&quot;&gt;) =&gt; useSuspenseQuery&lt;TData, TError&gt;({ queryKey: Common.UseSystemInfoServiceGetApiSystemInfoKeyFn(queryKey), queryFn: () =&gt; SystemInfoService.getApiSystemInfo() as TData, ...options });
/**
* @returns unknown
* @throws ApiError
*/
export const useSystemInfoServiceGetApiSystemInfoSysSuspense = &lt;TData = Common.SystemInfoServiceGetApiSystemInfoSysDefaultResponse, TError = unknown, TQueryKey extends Array&lt;unknown&gt; = unknown[]&gt;(queryKey?: TQueryKey, options?: Omit&lt;UseQueryOptions&lt;TData, TError&gt;, &quot;queryKey&quot; | &quot;queryFn&quot;&gt;) =&gt; useSuspenseQuery&lt;TData, TError&gt;({ queryKey: Common.UseSystemInfoServiceGetApiSystemInfoSysKeyFn(queryKey), queryFn: () =&gt; SystemInfoService.getApiSystemInfoSys() as TData, ...options });
/**
* Get a collection of users
* @param data The data for the request.
* @param data.page
* @param data.limit
* @param data.globalFilter
* @param data.filters
* @param data.filterModes
* @param data.sorting
* @returns unknown Paginated set of `UserResource`
* @throws ApiError
*/
export const useUserServiceGetApiUsersSuspense = &lt;TData = Common.UserServiceGetApiUsersDefaultResponse, TError = unknown, TQueryKey extends Array&lt;unknown&gt; = unknown[]&gt;({ filterModes, filters, globalFilter, limit, page, sorting }: {
  filterModes?: string;
  filters?: string;
  globalFilter?: string;
  limit?: number;
  page?: number;
  sorting?: string;
} = {}, queryKey?: TQueryKey, options?: Omit&lt;UseQueryOptions&lt;TData, TError&gt;, &quot;queryKey&quot; | &quot;queryFn&quot;&gt;) =&gt; useSuspenseQuery&lt;TData, TError&gt;({ queryKey: Common.UseUserServiceGetApiUsersKeyFn({ filterModes, filters, globalFilter, limit, page, sorting }, queryKey), queryFn: () =&gt; UserService.getApiUsers({ filterModes, filters, globalFilter, limit, page, sorting }) as TData, ...options });
/**
* Get small user detail info
* @param data The data for the request.
* @param data.user The user ID
* @returns UserResource `UserResource`
* @throws ApiError
*/
export const useUserServiceGetApiUsersByUserSuspense = &lt;TData = Common.UserServiceGetApiUsersByUserDefaultResponse, TError = unknown, TQueryKey extends Array&lt;unknown&gt; = unknown[]&gt;({ user }: {
  user: number;
}, queryKey?: TQueryKey, options?: Omit&lt;UseQueryOptions&lt;TData, TError&gt;, &quot;queryKey&quot; | &quot;queryFn&quot;&gt;) =&gt; useSuspenseQuery&lt;TData, TError&gt;({ queryKey: Common.UseUserServiceGetApiUsersByUserKeyFn({ user }, queryKey), queryFn: () =&gt; UserService.getApiUsersByUser({ user }) as TData, ...options });
/**
* Get the authenticated user
* @returns UserResource `UserResource`
* @throws ApiError
*/
export const useUserServiceGetApiUsersMeSuspense = &lt;TData = Common.UserServiceGetApiUsersMeDefaultResponse, TError = unknown, TQueryKey extends Array&lt;unknown&gt; = unknown[]&gt;(queryKey?: TQueryKey, options?: Omit&lt;UseQueryOptions&lt;TData, TError&gt;, &quot;queryKey&quot; | &quot;queryFn&quot;&gt;) =&gt; useSuspenseQuery&lt;TData, TError&gt;({ queryKey: Common.UseUserServiceGetApiUsersMeKeyFn(queryKey), queryFn: () =&gt; UserService.getApiUsersMe() as TData, ...options });
/**
* Get a collection of tokens
* @param data The data for the request.
* @param data.user
* @param data.page
* @param data.perPage
* @returns unknown Paginated set of `PersonalAccessTokenViewResource`
* @throws ApiError
*/
export const useUserTokenServiceGetApiUsersTokensByUserSuspense = &lt;TData = Common.UserTokenServiceGetApiUsersTokensByUserDefaultResponse, TError = unknown, TQueryKey extends Array&lt;unknown&gt; = unknown[]&gt;({ page, perPage, user }: {
  page?: number;
  perPage?: number;
  user: string;
}, queryKey?: TQueryKey, options?: Omit&lt;UseQueryOptions&lt;TData, TError&gt;, &quot;queryKey&quot; | &quot;queryFn&quot;&gt;) =&gt; useSuspenseQuery&lt;TData, TError&gt;({ queryKey: Common.UseUserTokenServiceGetApiUsersTokensByUserKeyFn({ page, perPage, user }, queryKey), queryFn: () =&gt; UserTokenService.getApiUsersTokensByUser({ page, perPage, user }) as TData, ...options });
/**
* Get the current queue workload for the application
* @returns unknown
* @throws ApiError
*/
export const useWorkloadServiceGetHorizonApiWorkloadSuspense = &lt;TData = Common.WorkloadServiceGetHorizonApiWorkloadDefaultResponse, TError = unknown, TQueryKey extends Array&lt;unknown&gt; = unknown[]&gt;(queryKey?: TQueryKey, options?: Omit&lt;UseQueryOptions&lt;TData, TError&gt;, &quot;queryKey&quot; | &quot;queryFn&quot;&gt;) =&gt; useSuspenseQuery&lt;TData, TError&gt;({ queryKey: Common.UseWorkloadServiceGetHorizonApiWorkloadKeyFn(queryKey), queryFn: () =&gt; WorkloadService.getHorizonApiWorkload() as TData, ...options });</file><file path="composer.json">{
  &quot;name&quot;: &quot;martinjuul/baander&quot;,
  &quot;type&quot;: &quot;project&quot;,
  &quot;description&quot;: &quot;a media server project&quot;,
  &quot;license&quot;: &quot;Apache-2.0&quot;,
  &quot;require&quot;: {
    &quot;php&quot;: &quot;^8.4&quot;,
    &quot;ext-curl&quot;: &quot;*&quot;,
    &quot;ext-dom&quot;: &quot;*&quot;,
    &quot;ext-elastic_apm&quot;: &quot;*&quot;,
    &quot;ext-fileinfo&quot;: &quot;*&quot;,
    &quot;ext-gd&quot;: &quot;*&quot;,
    &quot;ext-hash&quot;: &quot;*&quot;,
    &quot;ext-iconv&quot;: &quot;*&quot;,
    &quot;ext-igbinary&quot;: &quot;*&quot;,
    &quot;ext-imagick&quot;: &quot;*&quot;,
    &quot;ext-intl&quot;: &quot;*&quot;,
    &quot;ext-json&quot;: &quot;*&quot;,
    &quot;ext-jsonpath&quot;: &quot;*&quot;,
    &quot;ext-libxml&quot;: &quot;*&quot;,
    &quot;ext-mbstring&quot;: &quot;*&quot;,
    &quot;ext-openssl&quot;: &quot;*&quot;,
    &quot;ext-pcntl&quot;: &quot;*&quot;,
    &quot;ext-redis&quot;: &quot;*&quot;,
    &quot;ext-simplexml&quot;: &quot;*&quot;,
    &quot;ext-swoole&quot;: &quot;*&quot;,
    &quot;ext-zend-opcache&quot;: &quot;*&quot;,
    &quot;amphp/amp&quot;: &quot;v3.1.0&quot;,
    &quot;amphp/log&quot;: &quot;^2.0&quot;,
    &quot;amphp/redis&quot;: &quot;^2.0&quot;,
    &quot;bacon/bacon-qr-code&quot;: &quot;^v3.0.1&quot;,
    &quot;dedoc/scramble&quot;: &quot;^v0.12.9&quot;,
    &quot;ergebnis/clock&quot;: &quot;^2.10.0&quot;,
    &quot;guzzlehttp/guzzle&quot;: &quot;^7.9.2&quot;,
    &quot;hidehalo/nanoid-php&quot;: &quot;^2.0&quot;,
    &quot;intervention/image&quot;: &quot;^3.11.1&quot;,
    &quot;justinrainbow/json-schema&quot;: &quot;^6.1.0&quot;,
    &quot;laravel/fortify&quot;: &quot;^v1.25.4&quot;,
    &quot;laravel/framework&quot;: &quot;^12.0.1&quot;,
    &quot;laravel/horizon&quot;: &quot;^v5.30.3&quot;,
    &quot;laravel/octane&quot;: &quot;^v2.8.1&quot;,
    &quot;laravel/pail&quot;: &quot;^v1.2.2&quot;,
    &quot;laravel/passport&quot;: &quot;^v12.4.2&quot;,
    &quot;laravel/sanctum&quot;: &quot;^v4.0.5&quot;,
    &quot;laravel/tinker&quot;: &quot;^v2.7.3&quot;,
    &quot;league/container&quot;: &quot;^4.2&quot;,
    &quot;league/flysystem-read-only&quot;: &quot;^3.28.0&quot;,
    &quot;league/mime-type-detection&quot;: &quot;^1.16.0&quot;,
    &quot;matomo/device-detector&quot;: &quot;^6.4.3&quot;,
    &quot;maxakawizard/json-collection-parser&quot;: &quot;^1.10.0&quot;,
    &quot;opcodesio/log-viewer&quot;: &quot;^v3.15.0&quot;,
    &quot;overtrue/laravel-versionable&quot;: &quot;^5.4.0&quot;,
    &quot;php-ffmpeg/php-ffmpeg&quot;: &quot;^1.3&quot;,
    &quot;spatie/laravel-data&quot;: &quot;^4.13.1&quot;,
    &quot;spatie/laravel-permission&quot;: &quot;^6.15.0&quot;,
    &quot;spatie/laravel-route-attributes&quot;: &quot;^1.25.1&quot;,
    &quot;spatie/laravel-sluggable&quot;: &quot;^3.7.3&quot;,
    &quot;spomky-labs/otphp&quot;: &quot;^11.3.0&quot;,
    &quot;staudenmeir/laravel-adjacency-list&quot;: &quot;^1.25&quot;,
    &quot;stevebauman/unfinalize&quot;: &quot;^v2.1.1&quot;,
    &quot;symfony/string&quot;: &quot;^v7.2.0&quot;,
    &quot;tightenco/ziggy&quot;: &quot;^v2.5.1&quot;,
    &quot;tpetry/laravel-postgresql-enhanced&quot;: &quot;^3.0&quot;,
    &quot;web-auth/webauthn-lib&quot;: &quot;^5.1.2&quot;,
    &quot;xenos/musicbrainz&quot;: &quot;@dev&quot;,
    &quot;zend/php-reader&quot;: &quot;@dev&quot;
  },
  &quot;require-dev&quot;: {
    &quot;cweagans/composer-patches&quot;: &quot;^1.7&quot;,
    &quot;doctrine/dbal&quot;: &quot;^4.2.2&quot;,
    &quot;fakerphp/faker&quot;: &quot;^v1.24.1&quot;,
    &quot;laracraft-tech/laravel-schema-rules&quot;: &quot;^v1.5.0&quot;,
    &quot;mockery/mockery&quot;: &quot;^1.6.12&quot;,
    &quot;nikic/php-parser&quot;: &quot;^v5.4.0&quot;,
    &quot;nunomaduro/collision&quot;: &quot;^v8.6&quot;,
    &quot;phpmd/phpmd&quot;: &quot;^2.15.0&quot;,
    &quot;phpstan/phpstan&quot;: &quot;^2.1.6&quot;,
    &quot;phpunit/phpunit&quot;: &quot;^11&quot;,
    &quot;spatie/laravel-ignition&quot;: &quot;^2.9.1&quot;,
    &quot;squizlabs/php_codesniffer&quot;: &quot;^3.11.3&quot;,
    &quot;swoole/ide-helper&quot;: &quot;~5.0.0&quot;,
    &quot;xammie/mailbook&quot;: &quot;^1.9.0&quot;
  },
  &quot;replace&quot;: {
    &quot;symfony/polyfill-php80&quot;: &quot;*&quot;,
    &quot;symfony/polyfill-ctype&quot;: &quot;*&quot;,
    &quot;symfony/polyfill-mbstring&quot;: &quot;*&quot;,
    &quot;symfony/polyfill-intl-idn&quot;: &quot;*&quot;
  },
  &quot;autoload&quot;: {
    &quot;psr-4&quot;: {
      &quot;App\\&quot;: &quot;app/&quot;,
      &quot;Baander\\RedisStack\\&quot;: &quot;packages/redis-stack/src/&quot;,
      &quot;Database\\Factories\\&quot;: &quot;database/factories/&quot;,
      &quot;Database\\Seeders\\&quot;: &quot;database/seeders/&quot;
    },
    &quot;files&quot;: [
      &quot;app/Modules/Humanize/bytes.php&quot;
    ]
  },
  &quot;autoload-dev&quot;: {
    &quot;psr-4&quot;: {
      &quot;Tests\\&quot;: &quot;tests/&quot;
    }
  },
  &quot;scripts&quot;: {
    &quot;post-autoload-dump&quot;: [
      &quot;Illuminate\\Foundation\\ComposerScripts::postAutoloadDump&quot;,
      &quot;@php artisan package:discover --ansi&quot;
    ],
    &quot;post-update-cmd&quot;: [
      &quot;@php artisan vendor:publish --tag=laravel-assets --ansi --force&quot;
    ],
    &quot;post-root-package-install&quot;: [
      &quot;@php -r \&quot;file_exists(&apos;.env&apos;) || copy(&apos;.env.example&apos;, &apos;.env&apos;);\&quot;&quot;
    ],
    &quot;post-create-project-cmd&quot;: [
      &quot;@php artisan key:generate --ansi&quot;
    ],
    &quot;phpstan&quot;: [
      &quot;vendor/bin/phpstan analyse -c phpstan.neon&quot;
    ],
    &quot;phpcs&quot;: [
      &quot;vendor/bin/phpcs&quot;
    ],
    &quot;phpcbf&quot;: [
      &quot;vendor/bin/phpcbf&quot;
    ]
  },
  &quot;extra&quot;: {
    &quot;laravel&quot;: {
      &quot;dont-discover&quot;: [
        &quot;laravel/telescope&quot;
      ]
    },
    &quot;patches&quot;: {
      &quot;elastic/apm-agent&quot;: {
        &quot;Support PHP 8.4 and PSR Log 3.x&quot;: &quot;patches/elastic-apm-agent-php84-support.patch&quot;
      }
    }

  },
  &quot;config&quot;: {
    &quot;optimize-autoloader&quot;: true,
    &quot;preferred-install&quot;: &quot;dist&quot;,
    &quot;sort-packages&quot;: true,
    &quot;allow-plugins&quot;: {
      &quot;cweagans/composer-patches&quot;: true,
      &quot;pestphp/pest-plugin&quot;: true,
      &quot;php-http/discovery&quot;: true,
      &quot;tbachert/spi&quot;: true
    }
  },
  &quot;minimum-stability&quot;: &quot;dev&quot;,
  &quot;prefer-stable&quot;: true,
  &quot;repositories&quot;: [
    {
      &quot;type&quot;: &quot;path&quot;,
      &quot;url&quot;: &quot;./third_party/php-reader-1.8.1&quot;,
      &quot;options&quot;: {
        &quot;symlink&quot;: true
      }
    },
    {
      &quot;type&quot;: &quot;path&quot;,
      &quot;url&quot;: &quot;./third_party/music-brainz&quot;,
      &quot;options&quot;: {
        &quot;symlink&quot;: true
      }
    },
    {
      &quot;type&quot;: &quot;path&quot;,
      &quot;url&quot;: &quot;./third_party/elastic-apm-agent&quot;,
      &quot;options&quot;: {
        &quot;symlink&quot;: true
      }
    }
  ]
}</file><file path="resources/app/api-client/queries/queries.ts">// generated with @7nohe/openapi-react-query-codegen@1.6.2 
import { useMutation, UseMutationOptions, useQuery, UseQueryOptions } from &quot;@tanstack/react-query&quot;;
import { AlbumService, ArtistService, AuthService, BatchesService, CompletedJobsService, DashboardStatsService, FailedJobsService, FilesService, FoldersService, GenreService, HostsService, ImageService, JobMetricsService, JobService, JobsService, LibraryService, LogsService, MasterSupervisorService, MonitoringService, MovieService, OpCacheService, PasskeyService, PendingJobsService, PlaylistService, QueueMetricsService, QueueService, RetryService, SchemaService, SilencedJobsService, SongService, StreamService, SystemInfoService, UserService, UserTokenService, WorkloadService } from &quot;../requests/services.gen&quot;;
import { AuthenticateUsingPasskeyRequest, CreateLibraryRequest, CreatePlaylistRequest, CreateSmartPlaylistRequest, CreateUserRequest, ForgotPasswordRequest, LoginRequest, LogoutRequest, RegisterRequest, ResetPasswordRequest, RetryJobRequest, StorePasskeyRequest, UpdateGenreRequest, UpdateLibraryRequest, UpdatePlaylistRequest, UpdateSmartPlaylistRulesRequest, UpdateUserRequest } from &quot;../requests/types.gen&quot;;
import * as Common from &quot;./common&quot;;
/**
* Get a collection of albums
* @param data The data for the request.
* @param data.library The library slug
* @param data.fields
* @param data.relations
* @param data.page
* @param data.limit
* @param data.genres
* @returns unknown Paginated set of `AlbumResource`
* @throws ApiError
*/
export const useAlbumServiceGetApiLibrariesByLibraryAlbums = &lt;TData = Common.AlbumServiceGetApiLibrariesByLibraryAlbumsDefaultResponse, TError = unknown, TQueryKey extends Array&lt;unknown&gt; = unknown[]&gt;({ fields, genres, library, limit, page, relations }: {
  fields?: string;
  genres?: string;
  library: string;
  limit?: number;
  page?: number;
  relations?: string;
}, queryKey?: TQueryKey, options?: Omit&lt;UseQueryOptions&lt;TData, TError&gt;, &quot;queryKey&quot; | &quot;queryFn&quot;&gt;) =&gt; useQuery&lt;TData, TError&gt;({ queryKey: Common.UseAlbumServiceGetApiLibrariesByLibraryAlbumsKeyFn({ fields, genres, library, limit, page, relations }, queryKey), queryFn: () =&gt; AlbumService.getApiLibrariesByLibraryAlbums({ fields, genres, library, limit, page, relations }) as TData, ...options });
/**
* Get an album
* @param data The data for the request.
* @param data.library The library slug
* @param data.album The album slug
* @returns AlbumResource `AlbumResource`
* @throws ApiError
*/
export const useAlbumServiceGetApiLibrariesByLibraryAlbumsByAlbum = &lt;TData = Common.AlbumServiceGetApiLibrariesByLibraryAlbumsByAlbumDefaultResponse, TError = unknown, TQueryKey extends Array&lt;unknown&gt; = unknown[]&gt;({ album, library }: {
  album: string;
  library: string;
}, queryKey?: TQueryKey, options?: Omit&lt;UseQueryOptions&lt;TData, TError&gt;, &quot;queryKey&quot; | &quot;queryFn&quot;&gt;) =&gt; useQuery&lt;TData, TError&gt;({ queryKey: Common.UseAlbumServiceGetApiLibrariesByLibraryAlbumsByAlbumKeyFn({ album, library }, queryKey), queryFn: () =&gt; AlbumService.getApiLibrariesByLibraryAlbumsByAlbum({ album, library }) as TData, ...options });
/**
* Get a collection of artists
* @param data The data for the request.
* @param data.library
* @param data.fields
* @param data.relations
* @param data.page
* @param data.limit
* @param data.genres
* @returns unknown Paginated set of `ArtistResource`
* @throws ApiError
*/
export const useArtistServiceGetApiLibrariesByLibraryArtists = &lt;TData = Common.ArtistServiceGetApiLibrariesByLibraryArtistsDefaultResponse, TError = unknown, TQueryKey extends Array&lt;unknown&gt; = unknown[]&gt;({ fields, genres, library, limit, page, relations }: {
  fields?: string;
  genres?: string;
  library: string;
  limit?: number;
  page?: number;
  relations?: string;
}, queryKey?: TQueryKey, options?: Omit&lt;UseQueryOptions&lt;TData, TError&gt;, &quot;queryKey&quot; | &quot;queryFn&quot;&gt;) =&gt; useQuery&lt;TData, TError&gt;({ queryKey: Common.UseArtistServiceGetApiLibrariesByLibraryArtistsKeyFn({ fields, genres, library, limit, page, relations }, queryKey), queryFn: () =&gt; ArtistService.getApiLibrariesByLibraryArtists({ fields, genres, library, limit, page, relations }) as TData, ...options });
/**
* Get an artist
* @param data The data for the request.
* @param data.library
* @param data.artist The artist slug
* @returns ArtistResource `ArtistResource`
* @throws ApiError
*/
export const useArtistServiceGetApiLibrariesByLibraryArtistsByArtist = &lt;TData = Common.ArtistServiceGetApiLibrariesByLibraryArtistsByArtistDefaultResponse, TError = unknown, TQueryKey extends Array&lt;unknown&gt; = unknown[]&gt;({ artist, library }: {
  artist: string;
  library: string;
}, queryKey?: TQueryKey, options?: Omit&lt;UseQueryOptions&lt;TData, TError&gt;, &quot;queryKey&quot; | &quot;queryFn&quot;&gt;) =&gt; useQuery&lt;TData, TError&gt;({ queryKey: Common.UseArtistServiceGetApiLibrariesByLibraryArtistsByArtistKeyFn({ artist, library }, queryKey), queryFn: () =&gt; ArtistService.getApiLibrariesByLibraryArtistsByArtist({ artist, library }) as TData, ...options });
/**
* Get a passkey challenge
* @returns unknown
* @throws ApiError
*/
export const useAuthServiceGetWebauthnPasskey = &lt;TData = Common.AuthServiceGetWebauthnPasskeyDefaultResponse, TError = unknown, TQueryKey extends Array&lt;unknown&gt; = unknown[]&gt;(queryKey?: TQueryKey, options?: Omit&lt;UseQueryOptions&lt;TData, TError&gt;, &quot;queryKey&quot; | &quot;queryFn&quot;&gt;) =&gt; useQuery&lt;TData, TError&gt;({ queryKey: Common.UseAuthServiceGetWebauthnPasskeyKeyFn(queryKey), queryFn: () =&gt; AuthService.getWebauthnPasskey() as TData, ...options });
/**
* Get passkey registration options
* @returns unknown
* @throws ApiError
*/
export const useAuthServiceGetWebauthnPasskeyRegister = &lt;TData = Common.AuthServiceGetWebauthnPasskeyRegisterDefaultResponse, TError = unknown, TQueryKey extends Array&lt;unknown&gt; = unknown[]&gt;(queryKey?: TQueryKey, options?: Omit&lt;UseQueryOptions&lt;TData, TError&gt;, &quot;queryKey&quot; | &quot;queryFn&quot;&gt;) =&gt; useQuery&lt;TData, TError&gt;({ queryKey: Common.UseAuthServiceGetWebauthnPasskeyRegisterKeyFn(queryKey), queryFn: () =&gt; AuthService.getWebauthnPasskeyRegister() as TData, ...options });
/**
* Get a passkey challenge
* @returns unknown
* @throws ApiError
*/
export const usePasskeyServiceGetWebauthnPasskey = &lt;TData = Common.PasskeyServiceGetWebauthnPasskeyDefaultResponse, TError = unknown, TQueryKey extends Array&lt;unknown&gt; = unknown[]&gt;(queryKey?: TQueryKey, options?: Omit&lt;UseQueryOptions&lt;TData, TError&gt;, &quot;queryKey&quot; | &quot;queryFn&quot;&gt;) =&gt; useQuery&lt;TData, TError&gt;({ queryKey: Common.UsePasskeyServiceGetWebauthnPasskeyKeyFn(queryKey), queryFn: () =&gt; PasskeyService.getWebauthnPasskey() as TData, ...options });
/**
* Get passkey registration options
* @returns unknown
* @throws ApiError
*/
export const usePasskeyServiceGetWebauthnPasskeyRegister = &lt;TData = Common.PasskeyServiceGetWebauthnPasskeyRegisterDefaultResponse, TError = unknown, TQueryKey extends Array&lt;unknown&gt; = unknown[]&gt;(queryKey?: TQueryKey, options?: Omit&lt;UseQueryOptions&lt;TData, TError&gt;, &quot;queryKey&quot; | &quot;queryFn&quot;&gt;) =&gt; useQuery&lt;TData, TError&gt;({ queryKey: Common.UsePasskeyServiceGetWebauthnPasskeyRegisterKeyFn(queryKey), queryFn: () =&gt; PasskeyService.getWebauthnPasskeyRegister() as TData, ...options });
/**
* Get all of the batches
* @returns unknown
* @throws ApiError
*/
export const useBatchesServiceGetHorizonApiBatches = &lt;TData = Common.BatchesServiceGetHorizonApiBatchesDefaultResponse, TError = unknown, TQueryKey extends Array&lt;unknown&gt; = unknown[]&gt;(queryKey?: TQueryKey, options?: Omit&lt;UseQueryOptions&lt;TData, TError&gt;, &quot;queryKey&quot; | &quot;queryFn&quot;&gt;) =&gt; useQuery&lt;TData, TError&gt;({ queryKey: Common.UseBatchesServiceGetHorizonApiBatchesKeyFn(queryKey), queryFn: () =&gt; BatchesService.getHorizonApiBatches() as TData, ...options });
/**
* Get the details of a batch by ID
* @param data The data for the request.
* @param data.id
* @returns unknown
* @throws ApiError
*/
export const useBatchesServiceGetHorizonApiBatchesById = &lt;TData = Common.BatchesServiceGetHorizonApiBatchesByIdDefaultResponse, TError = unknown, TQueryKey extends Array&lt;unknown&gt; = unknown[]&gt;({ id }: {
  id: string;
}, queryKey?: TQueryKey, options?: Omit&lt;UseQueryOptions&lt;TData, TError&gt;, &quot;queryKey&quot; | &quot;queryFn&quot;&gt;) =&gt; useQuery&lt;TData, TError&gt;({ queryKey: Common.UseBatchesServiceGetHorizonApiBatchesByIdKeyFn({ id }, queryKey), queryFn: () =&gt; BatchesService.getHorizonApiBatchesById({ id }) as TData, ...options });
/**
* Get all of the completed jobs
* @param data The data for the request.
* @param data.startingAt
* @returns unknown
* @throws ApiError
*/
export const useCompletedJobsServiceGetHorizonApiJobsCompleted = &lt;TData = Common.CompletedJobsServiceGetHorizonApiJobsCompletedDefaultResponse, TError = unknown, TQueryKey extends Array&lt;unknown&gt; = unknown[]&gt;({ startingAt }: {
  startingAt?: string;
} = {}, queryKey?: TQueryKey, options?: Omit&lt;UseQueryOptions&lt;TData, TError&gt;, &quot;queryKey&quot; | &quot;queryFn&quot;&gt;) =&gt; useQuery&lt;TData, TError&gt;({ queryKey: Common.UseCompletedJobsServiceGetHorizonApiJobsCompletedKeyFn({ startingAt }, queryKey), queryFn: () =&gt; CompletedJobsService.getHorizonApiJobsCompleted({ startingAt }) as TData, ...options });
/**
* Get the key performance stats for the dashboard
* @returns unknown
* @throws ApiError
*/
export const useDashboardStatsServiceGetHorizonApiStats = &lt;TData = Common.DashboardStatsServiceGetHorizonApiStatsDefaultResponse, TError = unknown, TQueryKey extends Array&lt;unknown&gt; = unknown[]&gt;(queryKey?: TQueryKey, options?: Omit&lt;UseQueryOptions&lt;TData, TError&gt;, &quot;queryKey&quot; | &quot;queryFn&quot;&gt;) =&gt; useQuery&lt;TData, TError&gt;({ queryKey: Common.UseDashboardStatsServiceGetHorizonApiStatsKeyFn(queryKey), queryFn: () =&gt; DashboardStatsService.getHorizonApiStats() as TData, ...options });
/**
* Get all of the failed jobs
* @param data The data for the request.
* @param data.tag
* @returns unknown
* @throws ApiError
*/
export const useFailedJobsServiceGetHorizonApiJobsFailed = &lt;TData = Common.FailedJobsServiceGetHorizonApiJobsFailedDefaultResponse, TError = unknown, TQueryKey extends Array&lt;unknown&gt; = unknown[]&gt;({ tag }: {
  tag?: string;
} = {}, queryKey?: TQueryKey, options?: Omit&lt;UseQueryOptions&lt;TData, TError&gt;, &quot;queryKey&quot; | &quot;queryFn&quot;&gt;) =&gt; useQuery&lt;TData, TError&gt;({ queryKey: Common.UseFailedJobsServiceGetHorizonApiJobsFailedKeyFn({ tag }, queryKey), queryFn: () =&gt; FailedJobsService.getHorizonApiJobsFailed({ tag }) as TData, ...options });
/**
* Get a failed job instance
* @param data The data for the request.
* @param data.id
* @returns unknown
* @throws ApiError
*/
export const useFailedJobsServiceGetHorizonApiJobsFailedById = &lt;TData = Common.FailedJobsServiceGetHorizonApiJobsFailedByIdDefaultResponse, TError = unknown, TQueryKey extends Array&lt;unknown&gt; = unknown[]&gt;({ id }: {
  id: string;
}, queryKey?: TQueryKey, options?: Omit&lt;UseQueryOptions&lt;TData, TError&gt;, &quot;queryKey&quot; | &quot;queryFn&quot;&gt;) =&gt; useQuery&lt;TData, TError&gt;({ queryKey: Common.UseFailedJobsServiceGetHorizonApiJobsFailedByIdKeyFn({ id }, queryKey), queryFn: () =&gt; FailedJobsService.getHorizonApiJobsFailedById({ id }) as TData, ...options });
/**
* @returns LogFileResource Array of `LogFileResource`
* @throws ApiError
*/
export const useFilesServiceGetSystemLogViewerApiFiles = &lt;TData = Common.FilesServiceGetSystemLogViewerApiFilesDefaultResponse, TError = unknown, TQueryKey extends Array&lt;unknown&gt; = unknown[]&gt;(queryKey?: TQueryKey, options?: Omit&lt;UseQueryOptions&lt;TData, TError&gt;, &quot;queryKey&quot; | &quot;queryFn&quot;&gt;) =&gt; useQuery&lt;TData, TError&gt;({ queryKey: Common.UseFilesServiceGetSystemLogViewerApiFilesKeyFn(queryKey), queryFn: () =&gt; FilesService.getSystemLogViewerApiFiles() as TData, ...options });
/**
* @param data The data for the request.
* @param data.fileIdentifier
* @returns unknown
* @throws ApiError
*/
export const useFilesServiceGetSystemLogViewerApiFilesByFileIdentifierDownloadRequest = &lt;TData = Common.FilesServiceGetSystemLogViewerApiFilesByFileIdentifierDownloadRequestDefaultResponse, TError = unknown, TQueryKey extends Array&lt;unknown&gt; = unknown[]&gt;({ fileIdentifier }: {
  fileIdentifier: string;
}, queryKey?: TQueryKey, options?: Omit&lt;UseQueryOptions&lt;TData, TError&gt;, &quot;queryKey&quot; | &quot;queryFn&quot;&gt;) =&gt; useQuery&lt;TData, TError&gt;({ queryKey: Common.UseFilesServiceGetSystemLogViewerApiFilesByFileIdentifierDownloadRequestKeyFn({ fileIdentifier }, queryKey), queryFn: () =&gt; FilesService.getSystemLogViewerApiFilesByFileIdentifierDownloadRequest({ fileIdentifier }) as TData, ...options });
/**
* @param data The data for the request.
* @param data.fileIdentifier
* @returns string
* @throws ApiError
*/
export const useFilesServiceGetSystemLogViewerApiFilesByFileIdentifierDownload = &lt;TData = Common.FilesServiceGetSystemLogViewerApiFilesByFileIdentifierDownloadDefaultResponse, TError = unknown, TQueryKey extends Array&lt;unknown&gt; = unknown[]&gt;({ fileIdentifier }: {
  fileIdentifier: string;
}, queryKey?: TQueryKey, options?: Omit&lt;UseQueryOptions&lt;TData, TError&gt;, &quot;queryKey&quot; | &quot;queryFn&quot;&gt;) =&gt; useQuery&lt;TData, TError&gt;({ queryKey: Common.UseFilesServiceGetSystemLogViewerApiFilesByFileIdentifierDownloadKeyFn({ fileIdentifier }, queryKey), queryFn: () =&gt; FilesService.getSystemLogViewerApiFilesByFileIdentifierDownload({ fileIdentifier }) as TData, ...options });
/**
* @param data The data for the request.
* @param data.direction
* @returns LogFolderResource Array of `LogFolderResource`
* @throws ApiError
*/
export const useFoldersServiceGetSystemLogViewerApiFolders = &lt;TData = Common.FoldersServiceGetSystemLogViewerApiFoldersDefaultResponse, TError = unknown, TQueryKey extends Array&lt;unknown&gt; = unknown[]&gt;({ direction }: {
  direction?: string;
} = {}, queryKey?: TQueryKey, options?: Omit&lt;UseQueryOptions&lt;TData, TError&gt;, &quot;queryKey&quot; | &quot;queryFn&quot;&gt;) =&gt; useQuery&lt;TData, TError&gt;({ queryKey: Common.UseFoldersServiceGetSystemLogViewerApiFoldersKeyFn({ direction }, queryKey), queryFn: () =&gt; FoldersService.getSystemLogViewerApiFolders({ direction }) as TData, ...options });
/**
* @param data The data for the request.
* @param data.folderIdentifier
* @returns unknown
* @throws ApiError
*/
export const useFoldersServiceGetSystemLogViewerApiFoldersByFolderIdentifierDownloadRequest = &lt;TData = Common.FoldersServiceGetSystemLogViewerApiFoldersByFolderIdentifierDownloadRequestDefaultResponse, TError = unknown, TQueryKey extends Array&lt;unknown&gt; = unknown[]&gt;({ folderIdentifier }: {
  folderIdentifier: string;
}, queryKey?: TQueryKey, options?: Omit&lt;UseQueryOptions&lt;TData, TError&gt;, &quot;queryKey&quot; | &quot;queryFn&quot;&gt;) =&gt; useQuery&lt;TData, TError&gt;({ queryKey: Common.UseFoldersServiceGetSystemLogViewerApiFoldersByFolderIdentifierDownloadRequestKeyFn({ folderIdentifier }, queryKey), queryFn: () =&gt; FoldersService.getSystemLogViewerApiFoldersByFolderIdentifierDownloadRequest({ folderIdentifier }) as TData, ...options });
/**
* @param data The data for the request.
* @param data.folderIdentifier
* @returns string
* @throws ApiError
*/
export const useFoldersServiceGetSystemLogViewerApiFoldersByFolderIdentifierDownload = &lt;TData = Common.FoldersServiceGetSystemLogViewerApiFoldersByFolderIdentifierDownloadDefaultResponse, TError = unknown, TQueryKey extends Array&lt;unknown&gt; = unknown[]&gt;({ folderIdentifier }: {
  folderIdentifier: string;
}, queryKey?: TQueryKey, options?: Omit&lt;UseQueryOptions&lt;TData, TError&gt;, &quot;queryKey&quot; | &quot;queryFn&quot;&gt;) =&gt; useQuery&lt;TData, TError&gt;({ queryKey: Common.UseFoldersServiceGetSystemLogViewerApiFoldersByFolderIdentifierDownloadKeyFn({ folderIdentifier }, queryKey), queryFn: () =&gt; FoldersService.getSystemLogViewerApiFoldersByFolderIdentifierDownload({ folderIdentifier }) as TData, ...options });
/**
* Get a collection of genres
* @param data The data for the request.
* @param data.fields
* @param data.relations
* @param data.librarySlug
* @param data.page
* @param data.limit
* @returns unknown Paginated set of `GenreResource`
* @throws ApiError
*/
export const useGenreServiceGetApiGenres = &lt;TData = Common.GenreServiceGetApiGenresDefaultResponse, TError = unknown, TQueryKey extends Array&lt;unknown&gt; = unknown[]&gt;({ fields, librarySlug, limit, page, relations }: {
  fields?: string;
  librarySlug?: string;
  limit?: number;
  page?: number;
  relations?: string;
} = {}, queryKey?: TQueryKey, options?: Omit&lt;UseQueryOptions&lt;TData, TError&gt;, &quot;queryKey&quot; | &quot;queryFn&quot;&gt;) =&gt; useQuery&lt;TData, TError&gt;({ queryKey: Common.UseGenreServiceGetApiGenresKeyFn({ fields, librarySlug, limit, page, relations }, queryKey), queryFn: () =&gt; GenreService.getApiGenres({ fields, librarySlug, limit, page, relations }) as TData, ...options });
/**
* Get a genre
* @param data The data for the request.
* @param data.genre The genre slug
* @returns GenreResource `GenreResource`
* @throws ApiError
*/
export const useGenreServiceGetApiGenresByGenre = &lt;TData = Common.GenreServiceGetApiGenresByGenreDefaultResponse, TError = unknown, TQueryKey extends Array&lt;unknown&gt; = unknown[]&gt;({ genre }: {
  genre: string;
}, queryKey?: TQueryKey, options?: Omit&lt;UseQueryOptions&lt;TData, TError&gt;, &quot;queryKey&quot; | &quot;queryFn&quot;&gt;) =&gt; useQuery&lt;TData, TError&gt;({ queryKey: Common.UseGenreServiceGetApiGenresByGenreKeyFn({ genre }, queryKey), queryFn: () =&gt; GenreService.getApiGenresByGenre({ genre }) as TData, ...options });
/**
* @returns LogViewerHostResource Array of `LogViewerHostResource`
* @throws ApiError
*/
export const useHostsServiceGetSystemLogViewerApiHosts = &lt;TData = Common.HostsServiceGetSystemLogViewerApiHostsDefaultResponse, TError = unknown, TQueryKey extends Array&lt;unknown&gt; = unknown[]&gt;(queryKey?: TQueryKey, options?: Omit&lt;UseQueryOptions&lt;TData, TError&gt;, &quot;queryKey&quot; | &quot;queryFn&quot;&gt;) =&gt; useQuery&lt;TData, TError&gt;({ queryKey: Common.UseHostsServiceGetSystemLogViewerApiHostsKeyFn(queryKey), queryFn: () =&gt; HostsService.getSystemLogViewerApiHosts() as TData, ...options });
/**
* Get an image asset
* @param data The data for the request.
* @param data.image The image public id
* @returns string
* @throws ApiError
*/
export const useImageServiceGetApiImagesByImage = &lt;TData = Common.ImageServiceGetApiImagesByImageDefaultResponse, TError = unknown, TQueryKey extends Array&lt;unknown&gt; = unknown[]&gt;({ image }: {
  image: string;
}, queryKey?: TQueryKey, options?: Omit&lt;UseQueryOptions&lt;TData, TError&gt;, &quot;queryKey&quot; | &quot;queryFn&quot;&gt;) =&gt; useQuery&lt;TData, TError&gt;({ queryKey: Common.UseImageServiceGetApiImagesByImageKeyFn({ image }, queryKey), queryFn: () =&gt; ImageService.getApiImagesByImage({ image }) as TData, ...options });
/**
* Get all of the measured jobs
* @returns unknown
* @throws ApiError
*/
export const useJobMetricsServiceGetHorizonApiMetricsJobs = &lt;TData = Common.JobMetricsServiceGetHorizonApiMetricsJobsDefaultResponse, TError = unknown, TQueryKey extends Array&lt;unknown&gt; = unknown[]&gt;(queryKey?: TQueryKey, options?: Omit&lt;UseQueryOptions&lt;TData, TError&gt;, &quot;queryKey&quot; | &quot;queryFn&quot;&gt;) =&gt; useQuery&lt;TData, TError&gt;({ queryKey: Common.UseJobMetricsServiceGetHorizonApiMetricsJobsKeyFn(queryKey), queryFn: () =&gt; JobMetricsService.getHorizonApiMetricsJobs() as TData, ...options });
/**
* Get metrics for a given job
* @param data The data for the request.
* @param data.id
* @returns unknown
* @throws ApiError
*/
export const useJobMetricsServiceGetHorizonApiMetricsJobsById = &lt;TData = Common.JobMetricsServiceGetHorizonApiMetricsJobsByIdDefaultResponse, TError = unknown, TQueryKey extends Array&lt;unknown&gt; = unknown[]&gt;({ id }: {
  id: string;
}, queryKey?: TQueryKey, options?: Omit&lt;UseQueryOptions&lt;TData, TError&gt;, &quot;queryKey&quot; | &quot;queryFn&quot;&gt;) =&gt; useQuery&lt;TData, TError&gt;({ queryKey: Common.UseJobMetricsServiceGetHorizonApiMetricsJobsByIdKeyFn({ id }, queryKey), queryFn: () =&gt; JobMetricsService.getHorizonApiMetricsJobsById({ id }) as TData, ...options });
/**
* Get the details of a recent job by ID
* @param data The data for the request.
* @param data.id
* @returns unknown
* @throws ApiError
*/
export const useJobsServiceGetHorizonApiJobsById = &lt;TData = Common.JobsServiceGetHorizonApiJobsByIdDefaultResponse, TError = unknown, TQueryKey extends Array&lt;unknown&gt; = unknown[]&gt;({ id }: {
  id: string;
}, queryKey?: TQueryKey, options?: Omit&lt;UseQueryOptions&lt;TData, TError&gt;, &quot;queryKey&quot; | &quot;queryFn&quot;&gt;) =&gt; useQuery&lt;TData, TError&gt;({ queryKey: Common.UseJobsServiceGetHorizonApiJobsByIdKeyFn({ id }, queryKey), queryFn: () =&gt; JobsService.getHorizonApiJobsById({ id }) as TData, ...options });
/**
* Get a collection of media libraries
* @param data The data for the request.
* @param data.page
* @param data.limit
* @returns unknown Paginated set of `LibraryResource`
* @throws ApiError
*/
export const useLibraryServiceGetApiLibraries = &lt;TData = Common.LibraryServiceGetApiLibrariesDefaultResponse, TError = unknown, TQueryKey extends Array&lt;unknown&gt; = unknown[]&gt;({ limit, page }: {
  limit?: number;
  page?: number;
} = {}, queryKey?: TQueryKey, options?: Omit&lt;UseQueryOptions&lt;TData, TError&gt;, &quot;queryKey&quot; | &quot;queryFn&quot;&gt;) =&gt; useQuery&lt;TData, TError&gt;({ queryKey: Common.UseLibraryServiceGetApiLibrariesKeyFn({ limit, page }, queryKey), queryFn: () =&gt; LibraryService.getApiLibraries({ limit, page }) as TData, ...options });
/**
* Show library
* @param data The data for the request.
* @param data.slug
* @returns LibraryResource `LibraryResource`
* @throws ApiError
*/
export const useLibraryServiceGetApiLibrariesBySlug = &lt;TData = Common.LibraryServiceGetApiLibrariesBySlugDefaultResponse, TError = unknown, TQueryKey extends Array&lt;unknown&gt; = unknown[]&gt;({ slug }: {
  slug: string;
}, queryKey?: TQueryKey, options?: Omit&lt;UseQueryOptions&lt;TData, TError&gt;, &quot;queryKey&quot; | &quot;queryFn&quot;&gt;) =&gt; useQuery&lt;TData, TError&gt;({ queryKey: Common.UseLibraryServiceGetApiLibrariesBySlugKeyFn({ slug }, queryKey), queryFn: () =&gt; LibraryService.getApiLibrariesBySlug({ slug }) as TData, ...options });
/**
* @param data The data for the request.
* @param data.file
* @param data.query
* @param data.direction
* @param data.log
* @param data.excludeLevels
* @param data.excludeFileTypes
* @param data.perPage
* @param data.shorterStackTraces
* @returns unknown
* @throws ApiError
*/
export const useLogsServiceGetSystemLogViewerApiLogs = &lt;TData = Common.LogsServiceGetSystemLogViewerApiLogsDefaultResponse, TError = unknown, TQueryKey extends Array&lt;unknown&gt; = unknown[]&gt;({ direction, excludeFileTypes, excludeLevels, file, log, perPage, query, shorterStackTraces }: {
  direction?: string;
  excludeFileTypes?: string;
  excludeLevels?: string;
  file?: string;
  log?: string;
  perPage?: string;
  query?: string;
  shorterStackTraces?: boolean;
} = {}, queryKey?: TQueryKey, options?: Omit&lt;UseQueryOptions&lt;TData, TError&gt;, &quot;queryKey&quot; | &quot;queryFn&quot;&gt;) =&gt; useQuery&lt;TData, TError&gt;({ queryKey: Common.UseLogsServiceGetSystemLogViewerApiLogsKeyFn({ direction, excludeFileTypes, excludeLevels, file, log, perPage, query, shorterStackTraces }, queryKey), queryFn: () =&gt; LogsService.getSystemLogViewerApiLogs({ direction, excludeFileTypes, excludeLevels, file, log, perPage, query, shorterStackTraces }) as TData, ...options });
/**
* Get all of the master supervisors and their underlying supervisors
* @returns unknown
* @throws ApiError
*/
export const useMasterSupervisorServiceGetHorizonApiMasters = &lt;TData = Common.MasterSupervisorServiceGetHorizonApiMastersDefaultResponse, TError = unknown, TQueryKey extends Array&lt;unknown&gt; = unknown[]&gt;(queryKey?: TQueryKey, options?: Omit&lt;UseQueryOptions&lt;TData, TError&gt;, &quot;queryKey&quot; | &quot;queryFn&quot;&gt;) =&gt; useQuery&lt;TData, TError&gt;({ queryKey: Common.UseMasterSupervisorServiceGetHorizonApiMastersKeyFn(queryKey), queryFn: () =&gt; MasterSupervisorService.getHorizonApiMasters() as TData, ...options });
/**
* Get all of the monitored tags and their job counts
* @returns unknown
* @throws ApiError
*/
export const useMonitoringServiceGetHorizonApiMonitoring = &lt;TData = Common.MonitoringServiceGetHorizonApiMonitoringDefaultResponse, TError = unknown, TQueryKey extends Array&lt;unknown&gt; = unknown[]&gt;(queryKey?: TQueryKey, options?: Omit&lt;UseQueryOptions&lt;TData, TError&gt;, &quot;queryKey&quot; | &quot;queryFn&quot;&gt;) =&gt; useQuery&lt;TData, TError&gt;({ queryKey: Common.UseMonitoringServiceGetHorizonApiMonitoringKeyFn(queryKey), queryFn: () =&gt; MonitoringService.getHorizonApiMonitoring() as TData, ...options });
/**
* Paginate the jobs for a given tag
* @param data The data for the request.
* @param data.tag
* @param data.limit
* @returns unknown
* @throws ApiError
*/
export const useMonitoringServiceGetHorizonApiMonitoringByTag = &lt;TData = Common.MonitoringServiceGetHorizonApiMonitoringByTagDefaultResponse, TError = unknown, TQueryKey extends Array&lt;unknown&gt; = unknown[]&gt;({ limit, tag }: {
  limit?: string;
  tag: string;
}, queryKey?: TQueryKey, options?: Omit&lt;UseQueryOptions&lt;TData, TError&gt;, &quot;queryKey&quot; | &quot;queryFn&quot;&gt;) =&gt; useQuery&lt;TData, TError&gt;({ queryKey: Common.UseMonitoringServiceGetHorizonApiMonitoringByTagKeyFn({ limit, tag }, queryKey), queryFn: () =&gt; MonitoringService.getHorizonApiMonitoringByTag({ limit, tag }) as TData, ...options });
/**
* Get a collection of movies
* @param data The data for the request.
* @param data.library The library slug
* @returns unknown Paginated set of `MovieResource`
* @throws ApiError
*/
export const useMovieServiceGetApiLibrariesByLibraryMovies = &lt;TData = Common.MovieServiceGetApiLibrariesByLibraryMoviesDefaultResponse, TError = unknown, TQueryKey extends Array&lt;unknown&gt; = unknown[]&gt;({ library }: {
  library: string;
}, queryKey?: TQueryKey, options?: Omit&lt;UseQueryOptions&lt;TData, TError&gt;, &quot;queryKey&quot; | &quot;queryFn&quot;&gt;) =&gt; useQuery&lt;TData, TError&gt;({ queryKey: Common.UseMovieServiceGetApiLibrariesByLibraryMoviesKeyFn({ library }, queryKey), queryFn: () =&gt; MovieService.getApiLibrariesByLibraryMovies({ library }) as TData, ...options });
/**
* Get a movie
* @param data The data for the request.
* @param data.library The library slug
* @param data.movie The movie slug
* @returns MovieResource `MovieResource`
* @throws ApiError
*/
export const useMovieServiceGetApiLibrariesByLibraryMoviesByMovie = &lt;TData = Common.MovieServiceGetApiLibrariesByLibraryMoviesByMovieDefaultResponse, TError = unknown, TQueryKey extends Array&lt;unknown&gt; = unknown[]&gt;({ library, movie }: {
  library: string;
  movie: string;
}, queryKey?: TQueryKey, options?: Omit&lt;UseQueryOptions&lt;TData, TError&gt;, &quot;queryKey&quot; | &quot;queryFn&quot;&gt;) =&gt; useQuery&lt;TData, TError&gt;({ queryKey: Common.UseMovieServiceGetApiLibrariesByLibraryMoviesByMovieKeyFn({ library, movie }, queryKey), queryFn: () =&gt; MovieService.getApiLibrariesByLibraryMoviesByMovie({ library, movie }) as TData, ...options });
/**
* Get status
* @returns unknown
* @throws ApiError
*/
export const useOpCacheServiceGetApiOpcacheStatus = &lt;TData = Common.OpCacheServiceGetApiOpcacheStatusDefaultResponse, TError = unknown, TQueryKey extends Array&lt;unknown&gt; = unknown[]&gt;(queryKey?: TQueryKey, options?: Omit&lt;UseQueryOptions&lt;TData, TError&gt;, &quot;queryKey&quot; | &quot;queryFn&quot;&gt;) =&gt; useQuery&lt;TData, TError&gt;({ queryKey: Common.UseOpCacheServiceGetApiOpcacheStatusKeyFn(queryKey), queryFn: () =&gt; OpCacheService.getApiOpcacheStatus() as TData, ...options });
/**
* Get config
* @returns unknown
* @throws ApiError
*/
export const useOpCacheServiceGetApiOpcacheConfig = &lt;TData = Common.OpCacheServiceGetApiOpcacheConfigDefaultResponse, TError = unknown, TQueryKey extends Array&lt;unknown&gt; = unknown[]&gt;(queryKey?: TQueryKey, options?: Omit&lt;UseQueryOptions&lt;TData, TError&gt;, &quot;queryKey&quot; | &quot;queryFn&quot;&gt;) =&gt; useQuery&lt;TData, TError&gt;({ queryKey: Common.UseOpCacheServiceGetApiOpcacheConfigKeyFn(queryKey), queryFn: () =&gt; OpCacheService.getApiOpcacheConfig() as TData, ...options });
/**
* Get all of the pending jobs
* @param data The data for the request.
* @param data.startingAt
* @returns unknown
* @throws ApiError
*/
export const usePendingJobsServiceGetHorizonApiJobsPending = &lt;TData = Common.PendingJobsServiceGetHorizonApiJobsPendingDefaultResponse, TError = unknown, TQueryKey extends Array&lt;unknown&gt; = unknown[]&gt;({ startingAt }: {
  startingAt?: string;
} = {}, queryKey?: TQueryKey, options?: Omit&lt;UseQueryOptions&lt;TData, TError&gt;, &quot;queryKey&quot; | &quot;queryFn&quot;&gt;) =&gt; useQuery&lt;TData, TError&gt;({ queryKey: Common.UsePendingJobsServiceGetHorizonApiJobsPendingKeyFn({ startingAt }, queryKey), queryFn: () =&gt; PendingJobsService.getHorizonApiJobsPending({ startingAt }) as TData, ...options });
/**
* Get a collection of playlists
* @returns unknown Paginated set of `PlaylistResource`
* @throws ApiError
*/
export const usePlaylistServiceGetApiPlaylists = &lt;TData = Common.PlaylistServiceGetApiPlaylistsDefaultResponse, TError = unknown, TQueryKey extends Array&lt;unknown&gt; = unknown[]&gt;(queryKey?: TQueryKey, options?: Omit&lt;UseQueryOptions&lt;TData, TError&gt;, &quot;queryKey&quot; | &quot;queryFn&quot;&gt;) =&gt; useQuery&lt;TData, TError&gt;({ queryKey: Common.UsePlaylistServiceGetApiPlaylistsKeyFn(queryKey), queryFn: () =&gt; PlaylistService.getApiPlaylists() as TData, ...options });
/**
* Show a playlist
* @param data The data for the request.
* @param data.playlist The playlist public id
* @param data.relations
* @returns PlaylistResource `PlaylistResource`
* @throws ApiError
*/
export const usePlaylistServiceGetApiPlaylistsByPlaylist = &lt;TData = Common.PlaylistServiceGetApiPlaylistsByPlaylistDefaultResponse, TError = unknown, TQueryKey extends Array&lt;unknown&gt; = unknown[]&gt;({ playlist, relations }: {
  playlist: string;
  relations?: string;
}, queryKey?: TQueryKey, options?: Omit&lt;UseQueryOptions&lt;TData, TError&gt;, &quot;queryKey&quot; | &quot;queryFn&quot;&gt;) =&gt; useQuery&lt;TData, TError&gt;({ queryKey: Common.UsePlaylistServiceGetApiPlaylistsByPlaylistKeyFn({ playlist, relations }, queryKey), queryFn: () =&gt; PlaylistService.getApiPlaylistsByPlaylist({ playlist, relations }) as TData, ...options });
/**
* Get statistics
* @param data The data for the request.
* @param data.playlist The playlist public id
* @returns PlaylistStatistic `PlaylistStatistic`
* @throws ApiError
*/
export const usePlaylistServiceGetApiPlaylistsByPlaylistStatistics = &lt;TData = Common.PlaylistServiceGetApiPlaylistsByPlaylistStatisticsDefaultResponse, TError = unknown, TQueryKey extends Array&lt;unknown&gt; = unknown[]&gt;({ playlist }: {
  playlist: string;
}, queryKey?: TQueryKey, options?: Omit&lt;UseQueryOptions&lt;TData, TError&gt;, &quot;queryKey&quot; | &quot;queryFn&quot;&gt;) =&gt; useQuery&lt;TData, TError&gt;({ queryKey: Common.UsePlaylistServiceGetApiPlaylistsByPlaylistStatisticsKeyFn({ playlist }, queryKey), queryFn: () =&gt; PlaylistService.getApiPlaylistsByPlaylistStatistics({ playlist }) as TData, ...options });
/**
* Get a collection of monitor entries
* @param data The data for the request.
* @param data.page
* @param data.limit
* @param data.status
* @param data.queue
* @param data.name
* @param data.queuedFirst
* @returns unknown Paginated set of `QueueMonitorResource`
* @throws ApiError
*/
export const useQueueServiceGetApiQueueMetrics = &lt;TData = Common.QueueServiceGetApiQueueMetricsDefaultResponse, TError = unknown, TQueryKey extends Array&lt;unknown&gt; = unknown[]&gt;({ limit, name, page, queue, queuedFirst, status }: {
  limit?: number;
  name?: string;
  page?: number;
  queue?: string;
  queuedFirst?: boolean;
  status?: &quot;running&quot; | &quot;succeeded&quot; | &quot;failed&quot; | &quot;stale&quot; | &quot;queued&quot;;
} = {}, queryKey?: TQueryKey, options?: Omit&lt;UseQueryOptions&lt;TData, TError&gt;, &quot;queryKey&quot; | &quot;queryFn&quot;&gt;) =&gt; useQuery&lt;TData, TError&gt;({ queryKey: Common.UseQueueServiceGetApiQueueMetricsKeyFn({ limit, name, page, queue, queuedFirst, status }, queryKey), queryFn: () =&gt; QueueService.getApiQueueMetrics({ limit, name, page, queue, queuedFirst, status }) as TData, ...options });
/**
* Get a list of queue names
* @returns unknown
* @throws ApiError
*/
export const useQueueServiceGetApiQueueMetricsQueues = &lt;TData = Common.QueueServiceGetApiQueueMetricsQueuesDefaultResponse, TError = unknown, TQueryKey extends Array&lt;unknown&gt; = unknown[]&gt;(queryKey?: TQueryKey, options?: Omit&lt;UseQueryOptions&lt;TData, TError&gt;, &quot;queryKey&quot; | &quot;queryFn&quot;&gt;) =&gt; useQuery&lt;TData, TError&gt;({ queryKey: Common.UseQueueServiceGetApiQueueMetricsQueuesKeyFn(queryKey), queryFn: () =&gt; QueueService.getApiQueueMetricsQueues() as TData, ...options });
/**
* Get a metrics collection
* @param data The data for the request.
* @param data.aggregateDays
* @returns unknown
* @throws ApiError
*/
export const useQueueServiceGetApiQueueMetricsMetrics = &lt;TData = Common.QueueServiceGetApiQueueMetricsMetricsDefaultResponse, TError = unknown, TQueryKey extends Array&lt;unknown&gt; = unknown[]&gt;({ aggregateDays }: {
  aggregateDays?: number;
} = {}, queryKey?: TQueryKey, options?: Omit&lt;UseQueryOptions&lt;TData, TError&gt;, &quot;queryKey&quot; | &quot;queryFn&quot;&gt;) =&gt; useQuery&lt;TData, TError&gt;({ queryKey: Common.UseQueueServiceGetApiQueueMetricsMetricsKeyFn({ aggregateDays }, queryKey), queryFn: () =&gt; QueueService.getApiQueueMetricsMetrics({ aggregateDays }) as TData, ...options });
/**
* Get all of the measured queues
* @returns unknown
* @throws ApiError
*/
export const useQueueMetricsServiceGetHorizonApiMetricsQueues = &lt;TData = Common.QueueMetricsServiceGetHorizonApiMetricsQueuesDefaultResponse, TError = unknown, TQueryKey extends Array&lt;unknown&gt; = unknown[]&gt;(queryKey?: TQueryKey, options?: Omit&lt;UseQueryOptions&lt;TData, TError&gt;, &quot;queryKey&quot; | &quot;queryFn&quot;&gt;) =&gt; useQuery&lt;TData, TError&gt;({ queryKey: Common.UseQueueMetricsServiceGetHorizonApiMetricsQueuesKeyFn(queryKey), queryFn: () =&gt; QueueMetricsService.getHorizonApiMetricsQueues() as TData, ...options });
/**
* Get metrics for a given queue
* @param data The data for the request.
* @param data.id
* @returns unknown
* @throws ApiError
*/
export const useQueueMetricsServiceGetHorizonApiMetricsQueuesById = &lt;TData = Common.QueueMetricsServiceGetHorizonApiMetricsQueuesByIdDefaultResponse, TError = unknown, TQueryKey extends Array&lt;unknown&gt; = unknown[]&gt;({ id }: {
  id: string;
}, queryKey?: TQueryKey, options?: Omit&lt;UseQueryOptions&lt;TData, TError&gt;, &quot;queryKey&quot; | &quot;queryFn&quot;&gt;) =&gt; useQuery&lt;TData, TError&gt;({ queryKey: Common.UseQueueMetricsServiceGetHorizonApiMetricsQueuesByIdKeyFn({ id }, queryKey), queryFn: () =&gt; QueueMetricsService.getHorizonApiMetricsQueuesById({ id }) as TData, ...options });
/**
* @returns unknown
* @throws ApiError
*/
export const useSchemaServiceGetApiSchemasMusicbrainz = &lt;TData = Common.SchemaServiceGetApiSchemasMusicbrainzDefaultResponse, TError = unknown, TQueryKey extends Array&lt;unknown&gt; = unknown[]&gt;(queryKey?: TQueryKey, options?: Omit&lt;UseQueryOptions&lt;TData, TError&gt;, &quot;queryKey&quot; | &quot;queryFn&quot;&gt;) =&gt; useQuery&lt;TData, TError&gt;({ queryKey: Common.UseSchemaServiceGetApiSchemasMusicbrainzKeyFn(queryKey), queryFn: () =&gt; SchemaService.getApiSchemasMusicbrainz() as TData, ...options });
/**
* Get all of the silenced jobs
* @param data The data for the request.
* @param data.startingAt
* @returns unknown
* @throws ApiError
*/
export const useSilencedJobsServiceGetHorizonApiJobsSilenced = &lt;TData = Common.SilencedJobsServiceGetHorizonApiJobsSilencedDefaultResponse, TError = unknown, TQueryKey extends Array&lt;unknown&gt; = unknown[]&gt;({ startingAt }: {
  startingAt?: string;
} = {}, queryKey?: TQueryKey, options?: Omit&lt;UseQueryOptions&lt;TData, TError&gt;, &quot;queryKey&quot; | &quot;queryFn&quot;&gt;) =&gt; useQuery&lt;TData, TError&gt;({ queryKey: Common.UseSilencedJobsServiceGetHorizonApiJobsSilencedKeyFn({ startingAt }, queryKey), queryFn: () =&gt; SilencedJobsService.getHorizonApiJobsSilenced({ startingAt }) as TData, ...options });
/**
* Get a collection of songs
* @param data The data for the request.
* @param data.library The library slug
* @param data.page
* @param data.limit
* @param data.genreNames
* @param data.genreSlugs
* @param data.relations
* @returns unknown Paginated set of `SongResource`
* @throws ApiError
*/
export const useSongServiceGetApiLibrariesByLibrarySongs = &lt;TData = Common.SongServiceGetApiLibrariesByLibrarySongsDefaultResponse, TError = unknown, TQueryKey extends Array&lt;unknown&gt; = unknown[]&gt;({ genreNames, genreSlugs, library, limit, page, relations }: {
  genreNames?: string;
  genreSlugs?: string;
  library: string;
  limit?: number;
  page?: number;
  relations?: string;
}, queryKey?: TQueryKey, options?: Omit&lt;UseQueryOptions&lt;TData, TError&gt;, &quot;queryKey&quot; | &quot;queryFn&quot;&gt;) =&gt; useQuery&lt;TData, TError&gt;({ queryKey: Common.UseSongServiceGetApiLibrariesByLibrarySongsKeyFn({ genreNames, genreSlugs, library, limit, page, relations }, queryKey), queryFn: () =&gt; SongService.getApiLibrariesByLibrarySongs({ genreNames, genreSlugs, library, limit, page, relations }) as TData, ...options });
/**
* Get a song by public id
* @param data The data for the request.
* @param data.library The library slug
* @param data.publicId
* @param data.relations
* @returns SongResource `SongResource`
* @throws ApiError
*/
export const useSongServiceGetApiLibrariesByLibrarySongsByPublicId = &lt;TData = Common.SongServiceGetApiLibrariesByLibrarySongsByPublicIdDefaultResponse, TError = unknown, TQueryKey extends Array&lt;unknown&gt; = unknown[]&gt;({ library, publicId, relations }: {
  library: string;
  publicId: string;
  relations?: string;
}, queryKey?: TQueryKey, options?: Omit&lt;UseQueryOptions&lt;TData, TError&gt;, &quot;queryKey&quot; | &quot;queryFn&quot;&gt;) =&gt; useQuery&lt;TData, TError&gt;({ queryKey: Common.UseSongServiceGetApiLibrariesByLibrarySongsByPublicIdKeyFn({ library, publicId, relations }, queryKey), queryFn: () =&gt; SongService.getApiLibrariesByLibrarySongsByPublicId({ library, publicId, relations }) as TData, ...options });
/**
* Direct stream the song.
* Requires token with &quot;access-stream&quot;
* @param data The data for the request.
* @param data.song The song public id
* @returns unknown
* @throws ApiError
*/
export const useStreamServiceGetApiStreamSongBySongDirect = &lt;TData = Common.StreamServiceGetApiStreamSongBySongDirectDefaultResponse, TError = unknown, TQueryKey extends Array&lt;unknown&gt; = unknown[]&gt;({ song }: {
  song: string;
}, queryKey?: TQueryKey, options?: Omit&lt;UseQueryOptions&lt;TData, TError&gt;, &quot;queryKey&quot; | &quot;queryFn&quot;&gt;) =&gt; useQuery&lt;TData, TError&gt;({ queryKey: Common.UseStreamServiceGetApiStreamSongBySongDirectKeyFn({ song }, queryKey), queryFn: () =&gt; StreamService.getApiStreamSongBySongDirect({ song }) as TData, ...options });
/**
* Get php info
* @returns unknown
* @throws ApiError
*/
export const useSystemInfoServiceGetApiSystemInfo = &lt;TData = Common.SystemInfoServiceGetApiSystemInfoDefaultResponse, TError = unknown, TQueryKey extends Array&lt;unknown&gt; = unknown[]&gt;(queryKey?: TQueryKey, options?: Omit&lt;UseQueryOptions&lt;TData, TError&gt;, &quot;queryKey&quot; | &quot;queryFn&quot;&gt;) =&gt; useQuery&lt;TData, TError&gt;({ queryKey: Common.UseSystemInfoServiceGetApiSystemInfoKeyFn(queryKey), queryFn: () =&gt; SystemInfoService.getApiSystemInfo() as TData, ...options });
/**
* @returns unknown
* @throws ApiError
*/
export const useSystemInfoServiceGetApiSystemInfoSys = &lt;TData = Common.SystemInfoServiceGetApiSystemInfoSysDefaultResponse, TError = unknown, TQueryKey extends Array&lt;unknown&gt; = unknown[]&gt;(queryKey?: TQueryKey, options?: Omit&lt;UseQueryOptions&lt;TData, TError&gt;, &quot;queryKey&quot; | &quot;queryFn&quot;&gt;) =&gt; useQuery&lt;TData, TError&gt;({ queryKey: Common.UseSystemInfoServiceGetApiSystemInfoSysKeyFn(queryKey), queryFn: () =&gt; SystemInfoService.getApiSystemInfoSys() as TData, ...options });
/**
* Get a collection of users
* @param data The data for the request.
* @param data.page
* @param data.limit
* @param data.globalFilter
* @param data.filters
* @param data.filterModes
* @param data.sorting
* @returns unknown Paginated set of `UserResource`
* @throws ApiError
*/
export const useUserServiceGetApiUsers = &lt;TData = Common.UserServiceGetApiUsersDefaultResponse, TError = unknown, TQueryKey extends Array&lt;unknown&gt; = unknown[]&gt;({ filterModes, filters, globalFilter, limit, page, sorting }: {
  filterModes?: string;
  filters?: string;
  globalFilter?: string;
  limit?: number;
  page?: number;
  sorting?: string;
} = {}, queryKey?: TQueryKey, options?: Omit&lt;UseQueryOptions&lt;TData, TError&gt;, &quot;queryKey&quot; | &quot;queryFn&quot;&gt;) =&gt; useQuery&lt;TData, TError&gt;({ queryKey: Common.UseUserServiceGetApiUsersKeyFn({ filterModes, filters, globalFilter, limit, page, sorting }, queryKey), queryFn: () =&gt; UserService.getApiUsers({ filterModes, filters, globalFilter, limit, page, sorting }) as TData, ...options });
/**
* Get small user detail info
* @param data The data for the request.
* @param data.user The user ID
* @returns UserResource `UserResource`
* @throws ApiError
*/
export const useUserServiceGetApiUsersByUser = &lt;TData = Common.UserServiceGetApiUsersByUserDefaultResponse, TError = unknown, TQueryKey extends Array&lt;unknown&gt; = unknown[]&gt;({ user }: {
  user: number;
}, queryKey?: TQueryKey, options?: Omit&lt;UseQueryOptions&lt;TData, TError&gt;, &quot;queryKey&quot; | &quot;queryFn&quot;&gt;) =&gt; useQuery&lt;TData, TError&gt;({ queryKey: Common.UseUserServiceGetApiUsersByUserKeyFn({ user }, queryKey), queryFn: () =&gt; UserService.getApiUsersByUser({ user }) as TData, ...options });
/**
* Get the authenticated user
* @returns UserResource `UserResource`
* @throws ApiError
*/
export const useUserServiceGetApiUsersMe = &lt;TData = Common.UserServiceGetApiUsersMeDefaultResponse, TError = unknown, TQueryKey extends Array&lt;unknown&gt; = unknown[]&gt;(queryKey?: TQueryKey, options?: Omit&lt;UseQueryOptions&lt;TData, TError&gt;, &quot;queryKey&quot; | &quot;queryFn&quot;&gt;) =&gt; useQuery&lt;TData, TError&gt;({ queryKey: Common.UseUserServiceGetApiUsersMeKeyFn(queryKey), queryFn: () =&gt; UserService.getApiUsersMe() as TData, ...options });
/**
* Get a collection of tokens
* @param data The data for the request.
* @param data.user
* @param data.page
* @param data.perPage
* @returns unknown Paginated set of `PersonalAccessTokenViewResource`
* @throws ApiError
*/
export const useUserTokenServiceGetApiUsersTokensByUser = &lt;TData = Common.UserTokenServiceGetApiUsersTokensByUserDefaultResponse, TError = unknown, TQueryKey extends Array&lt;unknown&gt; = unknown[]&gt;({ page, perPage, user }: {
  page?: number;
  perPage?: number;
  user: string;
}, queryKey?: TQueryKey, options?: Omit&lt;UseQueryOptions&lt;TData, TError&gt;, &quot;queryKey&quot; | &quot;queryFn&quot;&gt;) =&gt; useQuery&lt;TData, TError&gt;({ queryKey: Common.UseUserTokenServiceGetApiUsersTokensByUserKeyFn({ page, perPage, user }, queryKey), queryFn: () =&gt; UserTokenService.getApiUsersTokensByUser({ page, perPage, user }) as TData, ...options });
/**
* Get the current queue workload for the application
* @returns unknown
* @throws ApiError
*/
export const useWorkloadServiceGetHorizonApiWorkload = &lt;TData = Common.WorkloadServiceGetHorizonApiWorkloadDefaultResponse, TError = unknown, TQueryKey extends Array&lt;unknown&gt; = unknown[]&gt;(queryKey?: TQueryKey, options?: Omit&lt;UseQueryOptions&lt;TData, TError&gt;, &quot;queryKey&quot; | &quot;queryFn&quot;&gt;) =&gt; useQuery&lt;TData, TError&gt;({ queryKey: Common.UseWorkloadServiceGetHorizonApiWorkloadKeyFn(queryKey), queryFn: () =&gt; WorkloadService.getHorizonApiWorkload() as TData, ...options });
/**
* Login
* @param data The data for the request.
* @param data.requestBody
* @returns unknown
* @throws ApiError
*/
export const useAuthServicePostApiAuthLogin = &lt;TData = Common.AuthServicePostApiAuthLoginMutationResult, TError = unknown, TContext = unknown&gt;(options?: Omit&lt;UseMutationOptions&lt;TData, TError, {
  requestBody: LoginRequest;
}, TContext&gt;, &quot;mutationFn&quot;&gt;) =&gt; useMutation&lt;TData, TError, {
  requestBody: LoginRequest;
}, TContext&gt;({ mutationFn: ({ requestBody }) =&gt; AuthService.postApiAuthLogin({ requestBody }) as unknown as Promise&lt;TData&gt;, ...options });
/**
* Refresh token
* Needs refresh token with ability &quot;issue-access-token&quot;
* @returns unknown
* @throws ApiError
*/
export const useAuthServicePostApiAuthRefreshToken = &lt;TData = Common.AuthServicePostApiAuthRefreshTokenMutationResult, TError = unknown, TContext = unknown&gt;(options?: Omit&lt;UseMutationOptions&lt;TData, TError, void, TContext&gt;, &quot;mutationFn&quot;&gt;) =&gt; useMutation&lt;TData, TError, void, TContext&gt;({ mutationFn: () =&gt; AuthService.postApiAuthRefreshToken() as unknown as Promise&lt;TData&gt;, ...options });
/**
* Get a stream token
* Needs refresh token with ability &quot;issue-access-token&quot;
* @returns unknown
* @throws ApiError
*/
export const useAuthServicePostApiAuthStreamToken = &lt;TData = Common.AuthServicePostApiAuthStreamTokenMutationResult, TError = unknown, TContext = unknown&gt;(options?: Omit&lt;UseMutationOptions&lt;TData, TError, void, TContext&gt;, &quot;mutationFn&quot;&gt;) =&gt; useMutation&lt;TData, TError, void, TContext&gt;({ mutationFn: () =&gt; AuthService.postApiAuthStreamToken() as unknown as Promise&lt;TData&gt;, ...options });
/**
* Register
* @param data The data for the request.
* @param data.requestBody
* @returns unknown
* @throws ApiError
*/
export const useAuthServicePostApiAuthRegister = &lt;TData = Common.AuthServicePostApiAuthRegisterMutationResult, TError = unknown, TContext = unknown&gt;(options?: Omit&lt;UseMutationOptions&lt;TData, TError, {
  requestBody: RegisterRequest;
}, TContext&gt;, &quot;mutationFn&quot;&gt;) =&gt; useMutation&lt;TData, TError, {
  requestBody: RegisterRequest;
}, TContext&gt;({ mutationFn: ({ requestBody }) =&gt; AuthService.postApiAuthRegister({ requestBody }) as unknown as Promise&lt;TData&gt;, ...options });
/**
* Request reset password link
* @param data The data for the request.
* @param data.requestBody
* @returns unknown
* @throws ApiError
*/
export const useAuthServicePostApiAuthForgotPassword = &lt;TData = Common.AuthServicePostApiAuthForgotPasswordMutationResult, TError = unknown, TContext = unknown&gt;(options?: Omit&lt;UseMutationOptions&lt;TData, TError, {
  requestBody: ForgotPasswordRequest;
}, TContext&gt;, &quot;mutationFn&quot;&gt;) =&gt; useMutation&lt;TData, TError, {
  requestBody: ForgotPasswordRequest;
}, TContext&gt;({ mutationFn: ({ requestBody }) =&gt; AuthService.postApiAuthForgotPassword({ requestBody }) as unknown as Promise&lt;TData&gt;, ...options });
/**
* Reset password
* @param data The data for the request.
* @param data.requestBody
* @returns unknown
* @throws ApiError
*/
export const useAuthServicePostApiAuthResetPassword = &lt;TData = Common.AuthServicePostApiAuthResetPasswordMutationResult, TError = unknown, TContext = unknown&gt;(options?: Omit&lt;UseMutationOptions&lt;TData, TError, {
  requestBody: ResetPasswordRequest;
}, TContext&gt;, &quot;mutationFn&quot;&gt;) =&gt; useMutation&lt;TData, TError, {
  requestBody: ResetPasswordRequest;
}, TContext&gt;({ mutationFn: ({ requestBody }) =&gt; AuthService.postApiAuthResetPassword({ requestBody }) as unknown as Promise&lt;TData&gt;, ...options });
/**
* Verify email
* @param data The data for the request.
* @param data.id
* @param data.hash
* @returns UserResource `UserResource`
* @throws ApiError
*/
export const useAuthServicePostApiAuthVerifyByIdByHash = &lt;TData = Common.AuthServicePostApiAuthVerifyByIdByHashMutationResult, TError = unknown, TContext = unknown&gt;(options?: Omit&lt;UseMutationOptions&lt;TData, TError, {
  hash: string;
  id: number;
}, TContext&gt;, &quot;mutationFn&quot;&gt;) =&gt; useMutation&lt;TData, TError, {
  hash: string;
  id: number;
}, TContext&gt;({ mutationFn: ({ hash, id }) =&gt; AuthService.postApiAuthVerifyByIdByHash({ hash, id }) as unknown as Promise&lt;TData&gt;, ...options });
/**
* Logout
* Invalidates the current session
* @param data The data for the request.
* @param data.requestBody
* @returns void No content
* @throws ApiError
*/
export const useAuthServicePostApiAuthLogout = &lt;TData = Common.AuthServicePostApiAuthLogoutMutationResult, TError = unknown, TContext = unknown&gt;(options?: Omit&lt;UseMutationOptions&lt;TData, TError, {
  requestBody?: LogoutRequest &amp; { refreshToken?: string; };
}, TContext&gt;, &quot;mutationFn&quot;&gt;) =&gt; useMutation&lt;TData, TError, {
  requestBody?: LogoutRequest &amp; { refreshToken?: string; };
}, TContext&gt;({ mutationFn: ({ requestBody }) =&gt; AuthService.postApiAuthLogout({ requestBody }) as unknown as Promise&lt;TData&gt;, ...options });
/**
* Login with a passkey
* @param data The data for the request.
* @param data.requestBody
* @returns unknown
* @throws ApiError
*/
export const useAuthServicePostWebauthnPasskey = &lt;TData = Common.AuthServicePostWebauthnPasskeyMutationResult, TError = unknown, TContext = unknown&gt;(options?: Omit&lt;UseMutationOptions&lt;TData, TError, {
  requestBody: AuthenticateUsingPasskeyRequest;
}, TContext&gt;, &quot;mutationFn&quot;&gt;) =&gt; useMutation&lt;TData, TError, {
  requestBody: AuthenticateUsingPasskeyRequest;
}, TContext&gt;({ mutationFn: ({ requestBody }) =&gt; AuthService.postWebauthnPasskey({ requestBody }) as unknown as Promise&lt;TData&gt;, ...options });
/**
* Register passkey
* @param data The data for the request.
* @param data.requestBody
* @returns unknown
* @throws ApiError
*/
export const useAuthServicePostWebauthnPasskeyRegister = &lt;TData = Common.AuthServicePostWebauthnPasskeyRegisterMutationResult, TError = unknown, TContext = unknown&gt;(options?: Omit&lt;UseMutationOptions&lt;TData, TError, {
  requestBody: StorePasskeyRequest;
}, TContext&gt;, &quot;mutationFn&quot;&gt;) =&gt; useMutation&lt;TData, TError, {
  requestBody: StorePasskeyRequest;
}, TContext&gt;({ mutationFn: ({ requestBody }) =&gt; AuthService.postWebauthnPasskeyRegister({ requestBody }) as unknown as Promise&lt;TData&gt;, ...options });
/**
* Login with a passkey
* @param data The data for the request.
* @param data.requestBody
* @returns unknown
* @throws ApiError
*/
export const usePasskeyServicePostWebauthnPasskey = &lt;TData = Common.PasskeyServicePostWebauthnPasskeyMutationResult, TError = unknown, TContext = unknown&gt;(options?: Omit&lt;UseMutationOptions&lt;TData, TError, {
  requestBody: AuthenticateUsingPasskeyRequest;
}, TContext&gt;, &quot;mutationFn&quot;&gt;) =&gt; useMutation&lt;TData, TError, {
  requestBody: AuthenticateUsingPasskeyRequest;
}, TContext&gt;({ mutationFn: ({ requestBody }) =&gt; PasskeyService.postWebauthnPasskey({ requestBody }) as unknown as Promise&lt;TData&gt;, ...options });
/**
* Register passkey
* @param data The data for the request.
* @param data.requestBody
* @returns unknown
* @throws ApiError
*/
export const usePasskeyServicePostWebauthnPasskeyRegister = &lt;TData = Common.PasskeyServicePostWebauthnPasskeyRegisterMutationResult, TError = unknown, TContext = unknown&gt;(options?: Omit&lt;UseMutationOptions&lt;TData, TError, {
  requestBody: StorePasskeyRequest;
}, TContext&gt;, &quot;mutationFn&quot;&gt;) =&gt; useMutation&lt;TData, TError, {
  requestBody: StorePasskeyRequest;
}, TContext&gt;({ mutationFn: ({ requestBody }) =&gt; PasskeyService.postWebauthnPasskeyRegister({ requestBody }) as unknown as Promise&lt;TData&gt;, ...options });
/**
* Retry the given batch
* @param data The data for the request.
* @param data.id
* @returns unknown
* @throws ApiError
*/
export const useBatchesServicePostHorizonApiBatchesRetryById = &lt;TData = Common.BatchesServicePostHorizonApiBatchesRetryByIdMutationResult, TError = unknown, TContext = unknown&gt;(options?: Omit&lt;UseMutationOptions&lt;TData, TError, {
  id: string;
}, TContext&gt;, &quot;mutationFn&quot;&gt;) =&gt; useMutation&lt;TData, TError, {
  id: string;
}, TContext&gt;({ mutationFn: ({ id }) =&gt; BatchesService.postHorizonApiBatchesRetryById({ id }) as unknown as Promise&lt;TData&gt;, ...options });
/**
* @param data The data for the request.
* @param data.fileIdentifier
* @returns unknown
* @throws ApiError
*/
export const useFilesServicePostSystemLogViewerApiFilesByFileIdentifierClearCache = &lt;TData = Common.FilesServicePostSystemLogViewerApiFilesByFileIdentifierClearCacheMutationResult, TError = unknown, TContext = unknown&gt;(options?: Omit&lt;UseMutationOptions&lt;TData, TError, {
  fileIdentifier: string;
}, TContext&gt;, &quot;mutationFn&quot;&gt;) =&gt; useMutation&lt;TData, TError, {
  fileIdentifier: string;
}, TContext&gt;({ mutationFn: ({ fileIdentifier }) =&gt; FilesService.postSystemLogViewerApiFilesByFileIdentifierClearCache({ fileIdentifier }) as unknown as Promise&lt;TData&gt;, ...options });
/**
* @returns unknown
* @throws ApiError
*/
export const useFilesServicePostSystemLogViewerApiClearCacheAll = &lt;TData = Common.FilesServicePostSystemLogViewerApiClearCacheAllMutationResult, TError = unknown, TContext = unknown&gt;(options?: Omit&lt;UseMutationOptions&lt;TData, TError, void, TContext&gt;, &quot;mutationFn&quot;&gt;) =&gt; useMutation&lt;TData, TError, void, TContext&gt;({ mutationFn: () =&gt; FilesService.postSystemLogViewerApiClearCacheAll() as unknown as Promise&lt;TData&gt;, ...options });
/**
* @param data The data for the request.
* @param data.requestBody
* @returns unknown
* @throws ApiError
*/
export const useFilesServicePostSystemLogViewerApiDeleteMultipleFiles = &lt;TData = Common.FilesServicePostSystemLogViewerApiDeleteMultipleFilesMutationResult, TError = unknown, TContext = unknown&gt;(options?: Omit&lt;UseMutationOptions&lt;TData, TError, {
  requestBody?: { files?: string; };
}, TContext&gt;, &quot;mutationFn&quot;&gt;) =&gt; useMutation&lt;TData, TError, {
  requestBody?: { files?: string; };
}, TContext&gt;({ mutationFn: ({ requestBody }) =&gt; FilesService.postSystemLogViewerApiDeleteMultipleFiles({ requestBody }) as unknown as Promise&lt;TData&gt;, ...options });
/**
* @param data The data for the request.
* @param data.folderIdentifier
* @returns unknown
* @throws ApiError
*/
export const useFoldersServicePostSystemLogViewerApiFoldersByFolderIdentifierClearCache = &lt;TData = Common.FoldersServicePostSystemLogViewerApiFoldersByFolderIdentifierClearCacheMutationResult, TError = unknown, TContext = unknown&gt;(options?: Omit&lt;UseMutationOptions&lt;TData, TError, {
  folderIdentifier: string;
}, TContext&gt;, &quot;mutationFn&quot;&gt;) =&gt; useMutation&lt;TData, TError, {
  folderIdentifier: string;
}, TContext&gt;({ mutationFn: ({ folderIdentifier }) =&gt; FoldersService.postSystemLogViewerApiFoldersByFolderIdentifierClearCache({ folderIdentifier }) as unknown as Promise&lt;TData&gt;, ...options });
/**
* Scan a library
* @param data The data for the request.
* @param data.slug
* @returns unknown
* @throws ApiError
*/
export const useJobServicePostApiJobsScanLibraryBySlug = &lt;TData = Common.JobServicePostApiJobsScanLibraryBySlugMutationResult, TError = unknown, TContext = unknown&gt;(options?: Omit&lt;UseMutationOptions&lt;TData, TError, {
  slug: string;
}, TContext&gt;, &quot;mutationFn&quot;&gt;) =&gt; useMutation&lt;TData, TError, {
  slug: string;
}, TContext&gt;({ mutationFn: ({ slug }) =&gt; JobService.postApiJobsScanLibraryBySlug({ slug }) as unknown as Promise&lt;TData&gt;, ...options });
/**
* Create a library
* @param data The data for the request.
* @param data.requestBody
* @returns LibraryResource `LibraryResource`
* @throws ApiError
*/
export const useLibraryServicePostApiLibraries = &lt;TData = Common.LibraryServicePostApiLibrariesMutationResult, TError = unknown, TContext = unknown&gt;(options?: Omit&lt;UseMutationOptions&lt;TData, TError, {
  requestBody: CreateLibraryRequest;
}, TContext&gt;, &quot;mutationFn&quot;&gt;) =&gt; useMutation&lt;TData, TError, {
  requestBody: CreateLibraryRequest;
}, TContext&gt;({ mutationFn: ({ requestBody }) =&gt; LibraryService.postApiLibraries({ requestBody }) as unknown as Promise&lt;TData&gt;, ...options });
/**
* Start monitoring the given tag
* @returns unknown
* @throws ApiError
*/
export const useMonitoringServicePostHorizonApiMonitoring = &lt;TData = Common.MonitoringServicePostHorizonApiMonitoringMutationResult, TError = unknown, TContext = unknown&gt;(options?: Omit&lt;UseMutationOptions&lt;TData, TError, void, TContext&gt;, &quot;mutationFn&quot;&gt;) =&gt; useMutation&lt;TData, TError, void, TContext&gt;({ mutationFn: () =&gt; MonitoringService.postHorizonApiMonitoring() as unknown as Promise&lt;TData&gt;, ...options });
/**
* Clear
* @returns unknown
* @throws ApiError
*/
export const useOpCacheServicePostApiOpcacheClear = &lt;TData = Common.OpCacheServicePostApiOpcacheClearMutationResult, TError = unknown, TContext = unknown&gt;(options?: Omit&lt;UseMutationOptions&lt;TData, TError, void, TContext&gt;, &quot;mutationFn&quot;&gt;) =&gt; useMutation&lt;TData, TError, void, TContext&gt;({ mutationFn: () =&gt; OpCacheService.postApiOpcacheClear() as unknown as Promise&lt;TData&gt;, ...options });
/**
* Compile cache
* @param data The data for the request.
* @param data.force
* @returns unknown
* @throws ApiError
*/
export const useOpCacheServicePostApiOpcacheCompile = &lt;TData = Common.OpCacheServicePostApiOpcacheCompileMutationResult, TError = unknown, TContext = unknown&gt;(options?: Omit&lt;UseMutationOptions&lt;TData, TError, {
  force?: string;
}, TContext&gt;, &quot;mutationFn&quot;&gt;) =&gt; useMutation&lt;TData, TError, {
  force?: string;
}, TContext&gt;({ mutationFn: ({ force }) =&gt; OpCacheService.postApiOpcacheCompile({ force }) as unknown as Promise&lt;TData&gt;, ...options });
/**
* Create a playlist
* @param data The data for the request.
* @param data.requestBody
* @returns PlaylistResource `PlaylistResource`
* @throws ApiError
*/
export const usePlaylistServicePostApiPlaylists = &lt;TData = Common.PlaylistServicePostApiPlaylistsMutationResult, TError = unknown, TContext = unknown&gt;(options?: Omit&lt;UseMutationOptions&lt;TData, TError, {
  requestBody: CreatePlaylistRequest;
}, TContext&gt;, &quot;mutationFn&quot;&gt;) =&gt; useMutation&lt;TData, TError, {
  requestBody: CreatePlaylistRequest;
}, TContext&gt;({ mutationFn: ({ requestBody }) =&gt; PlaylistService.postApiPlaylists({ requestBody }) as unknown as Promise&lt;TData&gt;, ...options });
/**
* Add a song
* @param data The data for the request.
* @param data.playlist The playlist public id
* @param data.song The song public id
* @returns unknown
* @throws ApiError
*/
export const usePlaylistServicePostApiPlaylistsByPlaylistSongsBySong = &lt;TData = Common.PlaylistServicePostApiPlaylistsByPlaylistSongsBySongMutationResult, TError = unknown, TContext = unknown&gt;(options?: Omit&lt;UseMutationOptions&lt;TData, TError, {
  playlist: string;
  song: string;
}, TContext&gt;, &quot;mutationFn&quot;&gt;) =&gt; useMutation&lt;TData, TError, {
  playlist: string;
  song: string;
}, TContext&gt;({ mutationFn: ({ playlist, song }) =&gt; PlaylistService.postApiPlaylistsByPlaylistSongsBySong({ playlist, song }) as unknown as Promise&lt;TData&gt;, ...options });
/**
* Reorder songs
* @param data The data for the request.
* @param data.playlist The playlist public id
* @param data.requestBody
* @returns unknown
* @throws ApiError
*/
export const usePlaylistServicePostApiPlaylistsByPlaylistReorder = &lt;TData = Common.PlaylistServicePostApiPlaylistsByPlaylistReorderMutationResult, TError = unknown, TContext = unknown&gt;(options?: Omit&lt;UseMutationOptions&lt;TData, TError, {
  playlist: string;
  requestBody: { song_ids: Array&lt;(number)&gt;; };
}, TContext&gt;, &quot;mutationFn&quot;&gt;) =&gt; useMutation&lt;TData, TError, {
  playlist: string;
  requestBody: { song_ids: Array&lt;(number)&gt;; };
}, TContext&gt;({ mutationFn: ({ playlist, requestBody }) =&gt; PlaylistService.postApiPlaylistsByPlaylistReorder({ playlist, requestBody }) as unknown as Promise&lt;TData&gt;, ...options });
/**
* Add collaborator
* @param data The data for the request.
* @param data.playlist The playlist public id
* @param data.requestBody
* @returns unknown
* @throws ApiError
*/
export const usePlaylistServicePostApiPlaylistsByPlaylistCollaborators = &lt;TData = Common.PlaylistServicePostApiPlaylistsByPlaylistCollaboratorsMutationResult, TError = unknown, TContext = unknown&gt;(options?: Omit&lt;UseMutationOptions&lt;TData, TError, {
  playlist: string;
  requestBody: { user_id: number; role?: &quot;editor&quot; | &quot;contributor&quot;; };
}, TContext&gt;, &quot;mutationFn&quot;&gt;) =&gt; useMutation&lt;TData, TError, {
  playlist: string;
  requestBody: { user_id: number; role?: &quot;editor&quot; | &quot;contributor&quot;; };
}, TContext&gt;({ mutationFn: ({ playlist, requestBody }) =&gt; PlaylistService.postApiPlaylistsByPlaylistCollaborators({ playlist, requestBody }) as unknown as Promise&lt;TData&gt;, ...options });
/**
* Clone playlist
* @param data The data for the request.
* @param data.playlist The playlist public id
* @returns PlaylistResource `PlaylistResource`
* @throws ApiError
*/
export const usePlaylistServicePostApiPlaylistsByPlaylistClone = &lt;TData = Common.PlaylistServicePostApiPlaylistsByPlaylistCloneMutationResult, TError = unknown, TContext = unknown&gt;(options?: Omit&lt;UseMutationOptions&lt;TData, TError, {
  playlist: string;
}, TContext&gt;, &quot;mutationFn&quot;&gt;) =&gt; useMutation&lt;TData, TError, {
  playlist: string;
}, TContext&gt;({ mutationFn: ({ playlist }) =&gt; PlaylistService.postApiPlaylistsByPlaylistClone({ playlist }) as unknown as Promise&lt;TData&gt;, ...options });
/**
* Statistics - Record view
* @param data The data for the request.
* @param data.playlist The playlist public id
* @returns unknown
* @throws ApiError
*/
export const usePlaylistServicePostApiPlaylistsByPlaylistStatisticsRecordView = &lt;TData = Common.PlaylistServicePostApiPlaylistsByPlaylistStatisticsRecordViewMutationResult, TError = unknown, TContext = unknown&gt;(options?: Omit&lt;UseMutationOptions&lt;TData, TError, {
  playlist: string;
}, TContext&gt;, &quot;mutationFn&quot;&gt;) =&gt; useMutation&lt;TData, TError, {
  playlist: string;
}, TContext&gt;({ mutationFn: ({ playlist }) =&gt; PlaylistService.postApiPlaylistsByPlaylistStatisticsRecordView({ playlist }) as unknown as Promise&lt;TData&gt;, ...options });
/**
* Statistics - Record play
* @param data The data for the request.
* @param data.playlist The playlist public id
* @returns unknown
* @throws ApiError
*/
export const usePlaylistServicePostApiPlaylistsByPlaylistStatisticsRecordPlay = &lt;TData = Common.PlaylistServicePostApiPlaylistsByPlaylistStatisticsRecordPlayMutationResult, TError = unknown, TContext = unknown&gt;(options?: Omit&lt;UseMutationOptions&lt;TData, TError, {
  playlist: string;
}, TContext&gt;, &quot;mutationFn&quot;&gt;) =&gt; useMutation&lt;TData, TError, {
  playlist: string;
}, TContext&gt;({ mutationFn: ({ playlist }) =&gt; PlaylistService.postApiPlaylistsByPlaylistStatisticsRecordPlay({ playlist }) as unknown as Promise&lt;TData&gt;, ...options });
/**
* Share
* @param data The data for the request.
* @param data.playlist The playlist public id
* @returns unknown
* @throws ApiError
*/
export const usePlaylistServicePostApiPlaylistsByPlaylistStatisticsRecordShare = &lt;TData = Common.PlaylistServicePostApiPlaylistsByPlaylistStatisticsRecordShareMutationResult, TError = unknown, TContext = unknown&gt;(options?: Omit&lt;UseMutationOptions&lt;TData, TError, {
  playlist: string;
}, TContext&gt;, &quot;mutationFn&quot;&gt;) =&gt; useMutation&lt;TData, TError, {
  playlist: string;
}, TContext&gt;({ mutationFn: ({ playlist }) =&gt; PlaylistService.postApiPlaylistsByPlaylistStatisticsRecordShare({ playlist }) as unknown as Promise&lt;TData&gt;, ...options });
/**
* Favorite
* @param data The data for the request.
* @param data.playlist The playlist public id
* @returns unknown
* @throws ApiError
*/
export const usePlaylistServicePostApiPlaylistsByPlaylistStatisticsRecordFavorite = &lt;TData = Common.PlaylistServicePostApiPlaylistsByPlaylistStatisticsRecordFavoriteMutationResult, TError = unknown, TContext = unknown&gt;(options?: Omit&lt;UseMutationOptions&lt;TData, TError, {
  playlist: string;
}, TContext&gt;, &quot;mutationFn&quot;&gt;) =&gt; useMutation&lt;TData, TError, {
  playlist: string;
}, TContext&gt;({ mutationFn: ({ playlist }) =&gt; PlaylistService.postApiPlaylistsByPlaylistStatisticsRecordFavorite({ playlist }) as unknown as Promise&lt;TData&gt;, ...options });
/**
* Smart playlist - Create
* @param data The data for the request.
* @param data.requestBody
* @returns PlaylistResource `PlaylistResource`
* @throws ApiError
*/
export const usePlaylistServicePostApiPlaylistsSmart = &lt;TData = Common.PlaylistServicePostApiPlaylistsSmartMutationResult, TError = unknown, TContext = unknown&gt;(options?: Omit&lt;UseMutationOptions&lt;TData, TError, {
  requestBody: CreateSmartPlaylistRequest;
}, TContext&gt;, &quot;mutationFn&quot;&gt;) =&gt; useMutation&lt;TData, TError, {
  requestBody: CreateSmartPlaylistRequest;
}, TContext&gt;({ mutationFn: ({ requestBody }) =&gt; PlaylistService.postApiPlaylistsSmart({ requestBody }) as unknown as Promise&lt;TData&gt;, ...options });
/**
* Smart playlist - Sync
* @param data The data for the request.
* @param data.playlist The playlist public id
* @returns unknown
* @throws ApiError
*/
export const usePlaylistServicePostApiPlaylistsByPlaylistSmartSync = &lt;TData = Common.PlaylistServicePostApiPlaylistsByPlaylistSmartSyncMutationResult, TError = unknown, TContext = unknown&gt;(options?: Omit&lt;UseMutationOptions&lt;TData, TError, {
  playlist: string;
}, TContext&gt;, &quot;mutationFn&quot;&gt;) =&gt; useMutation&lt;TData, TError, {
  playlist: string;
}, TContext&gt;({ mutationFn: ({ playlist }) =&gt; PlaylistService.postApiPlaylistsByPlaylistSmartSync({ playlist }) as unknown as Promise&lt;TData&gt;, ...options });
/**
* Retry a job
* @param data The data for the request.
* @param data.id
* @param data.requestBody
* @returns unknown
* @throws ApiError
*/
export const useQueueServicePostApiQueueMetricsRetryById = &lt;TData = Common.QueueServicePostApiQueueMetricsRetryByIdMutationResult, TError = unknown, TContext = unknown&gt;(options?: Omit&lt;UseMutationOptions&lt;TData, TError, {
  id: string;
  requestBody?: RetryJobRequest;
}, TContext&gt;, &quot;mutationFn&quot;&gt;) =&gt; useMutation&lt;TData, TError, {
  id: string;
  requestBody?: RetryJobRequest;
}, TContext&gt;({ mutationFn: ({ id, requestBody }) =&gt; QueueService.postApiQueueMetricsRetryById({ id, requestBody }) as unknown as Promise&lt;TData&gt;, ...options });
/**
* Retry a failed job
* @param data The data for the request.
* @param data.id
* @returns unknown
* @throws ApiError
*/
export const useRetryServicePostHorizonApiJobsRetryById = &lt;TData = Common.RetryServicePostHorizonApiJobsRetryByIdMutationResult, TError = unknown, TContext = unknown&gt;(options?: Omit&lt;UseMutationOptions&lt;TData, TError, {
  id: string;
}, TContext&gt;, &quot;mutationFn&quot;&gt;) =&gt; useMutation&lt;TData, TError, {
  id: string;
}, TContext&gt;({ mutationFn: ({ id }) =&gt; RetryService.postHorizonApiJobsRetryById({ id }) as unknown as Promise&lt;TData&gt;, ...options });
/**
* Create user
* This is endpoint allows administrators to create users
* @param data The data for the request.
* @param data.requestBody
* @returns UserResource `UserResource`
* @throws ApiError
*/
export const useUserServicePostApiUsers = &lt;TData = Common.UserServicePostApiUsersMutationResult, TError = unknown, TContext = unknown&gt;(options?: Omit&lt;UseMutationOptions&lt;TData, TError, {
  requestBody: CreateUserRequest;
}, TContext&gt;, &quot;mutationFn&quot;&gt;) =&gt; useMutation&lt;TData, TError, {
  requestBody: CreateUserRequest;
}, TContext&gt;({ mutationFn: ({ requestBody }) =&gt; UserService.postApiUsers({ requestBody }) as unknown as Promise&lt;TData&gt;, ...options });
/**
* Update a playlist
* @param data The data for the request.
* @param data.playlist The playlist public id
* @param data.requestBody
* @returns PlaylistResource `PlaylistResource`
* @throws ApiError
*/
export const usePlaylistServicePutApiPlaylistsByPlaylist = &lt;TData = Common.PlaylistServicePutApiPlaylistsByPlaylistMutationResult, TError = unknown, TContext = unknown&gt;(options?: Omit&lt;UseMutationOptions&lt;TData, TError, {
  playlist: string;
  requestBody?: UpdatePlaylistRequest;
}, TContext&gt;, &quot;mutationFn&quot;&gt;) =&gt; useMutation&lt;TData, TError, {
  playlist: string;
  requestBody?: UpdatePlaylistRequest;
}, TContext&gt;({ mutationFn: ({ playlist, requestBody }) =&gt; PlaylistService.putApiPlaylistsByPlaylist({ playlist, requestBody }) as unknown as Promise&lt;TData&gt;, ...options });
/**
* Smart playlist - Update rules
* @param data The data for the request.
* @param data.playlist The playlist public id
* @param data.requestBody
* @returns PlaylistResource `PlaylistResource`
* @throws ApiError
*/
export const usePlaylistServicePutApiPlaylistsByPlaylistSmart = &lt;TData = Common.PlaylistServicePutApiPlaylistsByPlaylistSmartMutationResult, TError = unknown, TContext = unknown&gt;(options?: Omit&lt;UseMutationOptions&lt;TData, TError, {
  playlist: string;
  requestBody: UpdateSmartPlaylistRulesRequest;
}, TContext&gt;, &quot;mutationFn&quot;&gt;) =&gt; useMutation&lt;TData, TError, {
  playlist: string;
  requestBody: UpdateSmartPlaylistRulesRequest;
}, TContext&gt;({ mutationFn: ({ playlist, requestBody }) =&gt; PlaylistService.putApiPlaylistsByPlaylistSmart({ playlist, requestBody }) as unknown as Promise&lt;TData&gt;, ...options });
/**
* Update a genre
* @param data The data for the request.
* @param data.genre The genre slug
* @param data.requestBody
* @returns GenreResource `GenreResource`
* @throws ApiError
*/
export const useGenreServicePatchApiGenresByGenre = &lt;TData = Common.GenreServicePatchApiGenresByGenreMutationResult, TError = unknown, TContext = unknown&gt;(options?: Omit&lt;UseMutationOptions&lt;TData, TError, {
  genre: string;
  requestBody: UpdateGenreRequest;
}, TContext&gt;, &quot;mutationFn&quot;&gt;) =&gt; useMutation&lt;TData, TError, {
  genre: string;
  requestBody: UpdateGenreRequest;
}, TContext&gt;({ mutationFn: ({ genre, requestBody }) =&gt; GenreService.patchApiGenresByGenre({ genre, requestBody }) as unknown as Promise&lt;TData&gt;, ...options });
/**
* Update a library specified by the provided slug
* @param data The data for the request.
* @param data.slug
* @param data.requestBody
* @returns LibraryResource `LibraryResource`
* @throws ApiError
*/
export const useLibraryServicePatchApiLibrariesBySlug = &lt;TData = Common.LibraryServicePatchApiLibrariesBySlugMutationResult, TError = unknown, TContext = unknown&gt;(options?: Omit&lt;UseMutationOptions&lt;TData, TError, {
  requestBody?: UpdateLibraryRequest;
  slug: string;
}, TContext&gt;, &quot;mutationFn&quot;&gt;) =&gt; useMutation&lt;TData, TError, {
  requestBody?: UpdateLibraryRequest;
  slug: string;
}, TContext&gt;({ mutationFn: ({ requestBody, slug }) =&gt; LibraryService.patchApiLibrariesBySlug({ requestBody, slug }) as unknown as Promise&lt;TData&gt;, ...options });
/**
* Update a user
* @param data The data for the request.
* @param data.user The user ID
* @param data.requestBody
* @returns UserResource `UserResource`
* @throws ApiError
*/
export const useUserServicePatchApiUsersByUser = &lt;TData = Common.UserServicePatchApiUsersByUserMutationResult, TError = unknown, TContext = unknown&gt;(options?: Omit&lt;UseMutationOptions&lt;TData, TError, {
  requestBody?: UpdateUserRequest;
  user: number;
}, TContext&gt;, &quot;mutationFn&quot;&gt;) =&gt; useMutation&lt;TData, TError, {
  requestBody?: UpdateUserRequest;
  user: number;
}, TContext&gt;({ mutationFn: ({ requestBody, user }) =&gt; UserService.patchApiUsersByUser({ requestBody, user }) as unknown as Promise&lt;TData&gt;, ...options });
/**
* @param data The data for the request.
* @param data.fileIdentifier
* @returns unknown
* @throws ApiError
*/
export const useFilesServiceDeleteSystemLogViewerApiFilesByFileIdentifier = &lt;TData = Common.FilesServiceDeleteSystemLogViewerApiFilesByFileIdentifierMutationResult, TError = unknown, TContext = unknown&gt;(options?: Omit&lt;UseMutationOptions&lt;TData, TError, {
  fileIdentifier: string;
}, TContext&gt;, &quot;mutationFn&quot;&gt;) =&gt; useMutation&lt;TData, TError, {
  fileIdentifier: string;
}, TContext&gt;({ mutationFn: ({ fileIdentifier }) =&gt; FilesService.deleteSystemLogViewerApiFilesByFileIdentifier({ fileIdentifier }) as unknown as Promise&lt;TData&gt;, ...options });
/**
* @param data The data for the request.
* @param data.folderIdentifier
* @returns unknown
* @throws ApiError
*/
export const useFoldersServiceDeleteSystemLogViewerApiFoldersByFolderIdentifier = &lt;TData = Common.FoldersServiceDeleteSystemLogViewerApiFoldersByFolderIdentifierMutationResult, TError = unknown, TContext = unknown&gt;(options?: Omit&lt;UseMutationOptions&lt;TData, TError, {
  folderIdentifier: string;
}, TContext&gt;, &quot;mutationFn&quot;&gt;) =&gt; useMutation&lt;TData, TError, {
  folderIdentifier: string;
}, TContext&gt;({ mutationFn: ({ folderIdentifier }) =&gt; FoldersService.deleteSystemLogViewerApiFoldersByFolderIdentifier({ folderIdentifier }) as unknown as Promise&lt;TData&gt;, ...options });
/**
* Delete a genre
* @param data The data for the request.
* @param data.genre The genre slug
* @returns void No content
* @throws ApiError
*/
export const useGenreServiceDeleteApiGenresByGenre = &lt;TData = Common.GenreServiceDeleteApiGenresByGenreMutationResult, TError = unknown, TContext = unknown&gt;(options?: Omit&lt;UseMutationOptions&lt;TData, TError, {
  genre: string;
}, TContext&gt;, &quot;mutationFn&quot;&gt;) =&gt; useMutation&lt;TData, TError, {
  genre: string;
}, TContext&gt;({ mutationFn: ({ genre }) =&gt; GenreService.deleteApiGenresByGenre({ genre }) as unknown as Promise&lt;TData&gt;, ...options });
/**
* Delete a library
* @param data The data for the request.
* @param data.slug
* @returns void No content
* @throws ApiError
*/
export const useLibraryServiceDeleteApiLibrariesBySlug = &lt;TData = Common.LibraryServiceDeleteApiLibrariesBySlugMutationResult, TError = unknown, TContext = unknown&gt;(options?: Omit&lt;UseMutationOptions&lt;TData, TError, {
  slug: string;
}, TContext&gt;, &quot;mutationFn&quot;&gt;) =&gt; useMutation&lt;TData, TError, {
  slug: string;
}, TContext&gt;({ mutationFn: ({ slug }) =&gt; LibraryService.deleteApiLibrariesBySlug({ slug }) as unknown as Promise&lt;TData&gt;, ...options });
/**
* Stop monitoring the given tag
* @param data The data for the request.
* @param data.tag
* @returns unknown
* @throws ApiError
*/
export const useMonitoringServiceDeleteHorizonApiMonitoringByTag = &lt;TData = Common.MonitoringServiceDeleteHorizonApiMonitoringByTagMutationResult, TError = unknown, TContext = unknown&gt;(options?: Omit&lt;UseMutationOptions&lt;TData, TError, {
  tag: string;
}, TContext&gt;, &quot;mutationFn&quot;&gt;) =&gt; useMutation&lt;TData, TError, {
  tag: string;
}, TContext&gt;({ mutationFn: ({ tag }) =&gt; MonitoringService.deleteHorizonApiMonitoringByTag({ tag }) as unknown as Promise&lt;TData&gt;, ...options });
/**
* Delete a playlist
* @param data The data for the request.
* @param data.playlist The playlist public id
* @returns void No content
* @throws ApiError
*/
export const usePlaylistServiceDeleteApiPlaylistsByPlaylist = &lt;TData = Common.PlaylistServiceDeleteApiPlaylistsByPlaylistMutationResult, TError = unknown, TContext = unknown&gt;(options?: Omit&lt;UseMutationOptions&lt;TData, TError, {
  playlist: string;
}, TContext&gt;, &quot;mutationFn&quot;&gt;) =&gt; useMutation&lt;TData, TError, {
  playlist: string;
}, TContext&gt;({ mutationFn: ({ playlist }) =&gt; PlaylistService.deleteApiPlaylistsByPlaylist({ playlist }) as unknown as Promise&lt;TData&gt;, ...options });
/**
* Remove a song
* @param data The data for the request.
* @param data.playlist The playlist public id
* @param data.song The song public id
* @returns unknown
* @throws ApiError
*/
export const usePlaylistServiceDeleteApiPlaylistsByPlaylistSongsBySong = &lt;TData = Common.PlaylistServiceDeleteApiPlaylistsByPlaylistSongsBySongMutationResult, TError = unknown, TContext = unknown&gt;(options?: Omit&lt;UseMutationOptions&lt;TData, TError, {
  playlist: string;
  song: string;
}, TContext&gt;, &quot;mutationFn&quot;&gt;) =&gt; useMutation&lt;TData, TError, {
  playlist: string;
  song: string;
}, TContext&gt;({ mutationFn: ({ playlist, song }) =&gt; PlaylistService.deleteApiPlaylistsByPlaylistSongsBySong({ playlist, song }) as unknown as Promise&lt;TData&gt;, ...options });
/**
* Remove collaborator
* @param data The data for the request.
* @param data.playlist The playlist public id
* @param data.user The user ID
* @returns unknown
* @throws ApiError
*/
export const usePlaylistServiceDeleteApiPlaylistsByPlaylistCollaboratorsByUser = &lt;TData = Common.PlaylistServiceDeleteApiPlaylistsByPlaylistCollaboratorsByUserMutationResult, TError = unknown, TContext = unknown&gt;(options?: Omit&lt;UseMutationOptions&lt;TData, TError, {
  playlist: string;
  user: number;
}, TContext&gt;, &quot;mutationFn&quot;&gt;) =&gt; useMutation&lt;TData, TError, {
  playlist: string;
  user: number;
}, TContext&gt;({ mutationFn: ({ playlist, user }) =&gt; PlaylistService.deleteApiPlaylistsByPlaylistCollaboratorsByUser({ playlist, user }) as unknown as Promise&lt;TData&gt;, ...options });
/**
* Delete by id
* @param data The data for the request.
* @param data.id
* @returns void No content
* @throws ApiError
*/
export const useQueueServiceDeleteApiQueueMetricsById = &lt;TData = Common.QueueServiceDeleteApiQueueMetricsByIdMutationResult, TError = unknown, TContext = unknown&gt;(options?: Omit&lt;UseMutationOptions&lt;TData, TError, {
  id: string;
}, TContext&gt;, &quot;mutationFn&quot;&gt;) =&gt; useMutation&lt;TData, TError, {
  id: string;
}, TContext&gt;({ mutationFn: ({ id }) =&gt; QueueService.deleteApiQueueMetricsById({ id }) as unknown as Promise&lt;TData&gt;, ...options });
/**
* Purge all records
* @returns void No content
* @throws ApiError
*/
export const useQueueServiceDeleteApiQueueMetricsPurge = &lt;TData = Common.QueueServiceDeleteApiQueueMetricsPurgeMutationResult, TError = unknown, TContext = unknown&gt;(options?: Omit&lt;UseMutationOptions&lt;TData, TError, void, TContext&gt;, &quot;mutationFn&quot;&gt;) =&gt; useMutation&lt;TData, TError, void, TContext&gt;({ mutationFn: () =&gt; QueueService.deleteApiQueueMetricsPurge() as unknown as Promise&lt;TData&gt;, ...options });
/**
* Delete a user
* @param data The data for the request.
* @param data.user
* @returns void No content
* @throws ApiError
*/
export const useUserServiceDeleteApiUsersByUser = &lt;TData = Common.UserServiceDeleteApiUsersByUserMutationResult, TError = unknown, TContext = unknown&gt;(options?: Omit&lt;UseMutationOptions&lt;TData, TError, {
  user: string;
}, TContext&gt;, &quot;mutationFn&quot;&gt;) =&gt; useMutation&lt;TData, TError, {
  user: string;
}, TContext&gt;({ mutationFn: ({ user }) =&gt; UserService.deleteApiUsersByUser({ user }) as unknown as Promise&lt;TData&gt;, ...options });
/**
* Revoke a given token
* @param data The data for the request.
* @param data.token The token ID
* @returns void No content
* @throws ApiError
*/
export const useUserTokenServiceDeleteApiUsersTokensByToken = &lt;TData = Common.UserTokenServiceDeleteApiUsersTokensByTokenMutationResult, TError = unknown, TContext = unknown&gt;(options?: Omit&lt;UseMutationOptions&lt;TData, TError, {
  token: number;
}, TContext&gt;, &quot;mutationFn&quot;&gt;) =&gt; useMutation&lt;TData, TError, {
  token: number;
}, TContext&gt;({ mutationFn: ({ token }) =&gt; UserTokenService.deleteApiUsersTokensByToken({ token }) as unknown as Promise&lt;TData&gt;, ...options });</file><file path="resources/app/api-client/requests/services.gen.ts">// This file is auto-generated by @hey-api/openapi-ts
import type { CancelablePromise } from &apos;./core/CancelablePromise&apos;;
import { OpenAPI } from &apos;./core/OpenAPI&apos;;
import { request as __request } from &apos;./core/request&apos;;
import type { GetApiLibrariesByLibraryAlbumsData, GetApiLibrariesByLibraryAlbumsResponse, GetApiLibrariesByLibraryAlbumsByAlbumData, GetApiLibrariesByLibraryAlbumsByAlbumResponse, GetApiLibrariesByLibraryArtistsData, GetApiLibrariesByLibraryArtistsResponse, GetApiLibrariesByLibraryArtistsByArtistData, GetApiLibrariesByLibraryArtistsByArtistResponse, PostApiAuthLoginData, PostApiAuthLoginResponse, PostApiAuthRefreshTokenResponse, PostApiAuthStreamTokenResponse, PostApiAuthRegisterData, PostApiAuthRegisterResponse, PostApiAuthForgotPasswordData, PostApiAuthForgotPasswordResponse, PostApiAuthResetPasswordData, PostApiAuthResetPasswordResponse, PostApiAuthVerifyByIdByHashData, PostApiAuthVerifyByIdByHashResponse, PostApiAuthLogoutData, PostApiAuthLogoutResponse, GetWebauthnPasskeyResponse, PostWebauthnPasskeyData, PostWebauthnPasskeyResponse, GetWebauthnPasskeyRegisterResponse, PostWebauthnPasskeyRegisterData, PostWebauthnPasskeyRegisterResponse, GetHorizonApiBatchesResponse, GetHorizonApiBatchesByIdData, GetHorizonApiBatchesByIdResponse, PostHorizonApiBatchesRetryByIdData, PostHorizonApiBatchesRetryByIdResponse, GetHorizonApiJobsCompletedData, GetHorizonApiJobsCompletedResponse, GetHorizonApiStatsResponse, GetHorizonApiJobsFailedData, GetHorizonApiJobsFailedResponse, GetHorizonApiJobsFailedByIdData, GetHorizonApiJobsFailedByIdResponse, GetSystemLogViewerApiFilesResponse, GetSystemLogViewerApiFilesByFileIdentifierDownloadRequestData, GetSystemLogViewerApiFilesByFileIdentifierDownloadRequestResponse, PostSystemLogViewerApiFilesByFileIdentifierClearCacheData, PostSystemLogViewerApiFilesByFileIdentifierClearCacheResponse, DeleteSystemLogViewerApiFilesByFileIdentifierData, DeleteSystemLogViewerApiFilesByFileIdentifierResponse, PostSystemLogViewerApiClearCacheAllResponse, PostSystemLogViewerApiDeleteMultipleFilesData, PostSystemLogViewerApiDeleteMultipleFilesResponse, GetSystemLogViewerApiFilesByFileIdentifierDownloadData, GetSystemLogViewerApiFilesByFileIdentifierDownloadResponse, GetSystemLogViewerApiFoldersData, GetSystemLogViewerApiFoldersResponse, GetSystemLogViewerApiFoldersByFolderIdentifierDownloadRequestData, GetSystemLogViewerApiFoldersByFolderIdentifierDownloadRequestResponse, PostSystemLogViewerApiFoldersByFolderIdentifierClearCacheData, PostSystemLogViewerApiFoldersByFolderIdentifierClearCacheResponse, DeleteSystemLogViewerApiFoldersByFolderIdentifierData, DeleteSystemLogViewerApiFoldersByFolderIdentifierResponse, GetSystemLogViewerApiFoldersByFolderIdentifierDownloadData, GetSystemLogViewerApiFoldersByFolderIdentifierDownloadResponse, GetApiGenresData, GetApiGenresResponse, GetApiGenresByGenreData, GetApiGenresByGenreResponse, PatchApiGenresByGenreData, PatchApiGenresByGenreResponse, DeleteApiGenresByGenreData, DeleteApiGenresByGenreResponse, GetSystemLogViewerApiHostsResponse, GetApiImagesByImageData, GetApiImagesByImageResponse, PostApiJobsScanLibraryBySlugData, PostApiJobsScanLibraryBySlugResponse, GetHorizonApiMetricsJobsResponse, GetHorizonApiMetricsJobsByIdData, GetHorizonApiMetricsJobsByIdResponse, GetHorizonApiJobsByIdData, GetHorizonApiJobsByIdResponse, GetApiLibrariesData, GetApiLibrariesResponse, PostApiLibrariesData, PostApiLibrariesResponse, GetApiLibrariesBySlugData, GetApiLibrariesBySlugResponse, PatchApiLibrariesBySlugData, PatchApiLibrariesBySlugResponse, DeleteApiLibrariesBySlugData, DeleteApiLibrariesBySlugResponse, GetSystemLogViewerApiLogsData, GetSystemLogViewerApiLogsResponse, GetHorizonApiMastersResponse, GetHorizonApiMonitoringResponse, PostHorizonApiMonitoringResponse, GetHorizonApiMonitoringByTagData, GetHorizonApiMonitoringByTagResponse, DeleteHorizonApiMonitoringByTagData, DeleteHorizonApiMonitoringByTagResponse, GetApiLibrariesByLibraryMoviesData, GetApiLibrariesByLibraryMoviesResponse, GetApiLibrariesByLibraryMoviesByMovieData, GetApiLibrariesByLibraryMoviesByMovieResponse, GetApiOpcacheStatusResponse, GetApiOpcacheConfigResponse, PostApiOpcacheClearResponse, PostApiOpcacheCompileData, PostApiOpcacheCompileResponse, GetHorizonApiJobsPendingData, GetHorizonApiJobsPendingResponse, GetApiPlaylistsResponse, PostApiPlaylistsData, PostApiPlaylistsResponse, GetApiPlaylistsByPlaylistData, GetApiPlaylistsByPlaylistResponse, PutApiPlaylistsByPlaylistData, PutApiPlaylistsByPlaylistResponse, DeleteApiPlaylistsByPlaylistData, DeleteApiPlaylistsByPlaylistResponse, PostApiPlaylistsByPlaylistSongsBySongData, PostApiPlaylistsByPlaylistSongsBySongResponse, DeleteApiPlaylistsByPlaylistSongsBySongData, DeleteApiPlaylistsByPlaylistSongsBySongResponse, PostApiPlaylistsByPlaylistReorderData, PostApiPlaylistsByPlaylistReorderResponse, PostApiPlaylistsByPlaylistCollaboratorsData, PostApiPlaylistsByPlaylistCollaboratorsResponse, DeleteApiPlaylistsByPlaylistCollaboratorsByUserData, DeleteApiPlaylistsByPlaylistCollaboratorsByUserResponse, PostApiPlaylistsByPlaylistCloneData, PostApiPlaylistsByPlaylistCloneResponse, GetApiPlaylistsByPlaylistStatisticsData, GetApiPlaylistsByPlaylistStatisticsResponse, PostApiPlaylistsByPlaylistStatisticsRecordViewData, PostApiPlaylistsByPlaylistStatisticsRecordViewResponse, PostApiPlaylistsByPlaylistStatisticsRecordPlayData, PostApiPlaylistsByPlaylistStatisticsRecordPlayResponse, PostApiPlaylistsByPlaylistStatisticsRecordShareData, PostApiPlaylistsByPlaylistStatisticsRecordShareResponse, PostApiPlaylistsByPlaylistStatisticsRecordFavoriteData, PostApiPlaylistsByPlaylistStatisticsRecordFavoriteResponse, PostApiPlaylistsSmartData, PostApiPlaylistsSmartResponse, PutApiPlaylistsByPlaylistSmartData, PutApiPlaylistsByPlaylistSmartResponse, PostApiPlaylistsByPlaylistSmartSyncData, PostApiPlaylistsByPlaylistSmartSyncResponse, GetApiQueueMetricsData, GetApiQueueMetricsResponse, GetApiQueueMetricsQueuesResponse, GetApiQueueMetricsMetricsData, GetApiQueueMetricsMetricsResponse, PostApiQueueMetricsRetryByIdData, PostApiQueueMetricsRetryByIdResponse, DeleteApiQueueMetricsByIdData, DeleteApiQueueMetricsByIdResponse, DeleteApiQueueMetricsPurgeResponse, GetHorizonApiMetricsQueuesResponse, GetHorizonApiMetricsQueuesByIdData, GetHorizonApiMetricsQueuesByIdResponse, PostHorizonApiJobsRetryByIdData, PostHorizonApiJobsRetryByIdResponse, GetApiSchemasMusicbrainzResponse, GetHorizonApiJobsSilencedData, GetHorizonApiJobsSilencedResponse, GetApiLibrariesByLibrarySongsData, GetApiLibrariesByLibrarySongsResponse, GetApiLibrariesByLibrarySongsByPublicIdData, GetApiLibrariesByLibrarySongsByPublicIdResponse, GetApiStreamSongBySongDirectData, GetApiStreamSongBySongDirectResponse, GetApiSystemInfoResponse, GetApiSystemInfoSysResponse, GetApiUsersData, GetApiUsersResponse, PostApiUsersData, PostApiUsersResponse, PatchApiUsersByUserData, PatchApiUsersByUserResponse, GetApiUsersByUserData, GetApiUsersByUserResponse, DeleteApiUsersByUserData, DeleteApiUsersByUserResponse, GetApiUsersMeResponse, GetApiUsersTokensByUserData, GetApiUsersTokensByUserResponse, DeleteApiUsersTokensByTokenData, DeleteApiUsersTokensByTokenResponse, GetHorizonApiWorkloadResponse } from &apos;./types.gen&apos;;
export class AlbumService {
    /**
     * Get a collection of albums
     * @param data The data for the request.
     * @param data.library The library slug
     * @param data.fields
     * @param data.relations
     * @param data.page
     * @param data.limit
     * @param data.genres
     * @returns unknown Paginated set of `AlbumResource`
     * @throws ApiError
     */
    public static getApiLibrariesByLibraryAlbums(data: GetApiLibrariesByLibraryAlbumsData): CancelablePromise&lt;GetApiLibrariesByLibraryAlbumsResponse&gt; {
        return __request(OpenAPI, {
            method: &apos;GET&apos;,
            url: &apos;/api/libraries/{library}/albums&apos;,
            path: {
                library: data.library
            },
            query: {
                fields: data.fields,
                relations: data.relations,
                page: data.page,
                limit: data.limit,
                genres: data.genres
            },
            errors: {
                401: &apos;Unauthenticated&apos;,
                404: &apos;Not found&apos;,
                422: &apos;Validation error&apos;
            }
        });
    }
    /**
     * Get an album
     * @param data The data for the request.
     * @param data.library The library slug
     * @param data.album The album slug
     * @returns AlbumResource `AlbumResource`
     * @throws ApiError
     */
    public static getApiLibrariesByLibraryAlbumsByAlbum(data: GetApiLibrariesByLibraryAlbumsByAlbumData): CancelablePromise&lt;GetApiLibrariesByLibraryAlbumsByAlbumResponse&gt; {
        return __request(OpenAPI, {
            method: &apos;GET&apos;,
            url: &apos;/api/libraries/{library}/albums/{album}&apos;,
            path: {
                library: data.library,
                album: data.album
            },
            errors: {
                401: &apos;Unauthenticated&apos;,
                404: &apos;Not found&apos;
            }
        });
    }
}
export class ArtistService {
    /**
     * Get a collection of artists
     * @param data The data for the request.
     * @param data.library
     * @param data.fields
     * @param data.relations
     * @param data.page
     * @param data.limit
     * @param data.genres
     * @returns unknown Paginated set of `ArtistResource`
     * @throws ApiError
     */
    public static getApiLibrariesByLibraryArtists(data: GetApiLibrariesByLibraryArtistsData): CancelablePromise&lt;GetApiLibrariesByLibraryArtistsResponse&gt; {
        return __request(OpenAPI, {
            method: &apos;GET&apos;,
            url: &apos;/api/libraries/{library}/artists&apos;,
            path: {
                library: data.library
            },
            query: {
                fields: data.fields,
                relations: data.relations,
                page: data.page,
                limit: data.limit,
                genres: data.genres
            },
            errors: {
                401: &apos;Unauthenticated&apos;,
                422: &apos;Validation error&apos;
            }
        });
    }
    /**
     * Get an artist
     * @param data The data for the request.
     * @param data.library
     * @param data.artist The artist slug
     * @returns ArtistResource `ArtistResource`
     * @throws ApiError
     */
    public static getApiLibrariesByLibraryArtistsByArtist(data: GetApiLibrariesByLibraryArtistsByArtistData): CancelablePromise&lt;GetApiLibrariesByLibraryArtistsByArtistResponse&gt; {
        return __request(OpenAPI, {
            method: &apos;GET&apos;,
            url: &apos;/api/libraries/{library}/artists/{artist}&apos;,
            path: {
                library: data.library,
                artist: data.artist
            },
            errors: {
                401: &apos;Unauthenticated&apos;,
                404: &apos;Not found&apos;
            }
        });
    }
}
export class AuthService {
    /**
     * Login
     * @param data The data for the request.
     * @param data.requestBody
     * @returns unknown
     * @throws ApiError
     */
    public static postApiAuthLogin(data: PostApiAuthLoginData): CancelablePromise&lt;PostApiAuthLoginResponse&gt; {
        return __request(OpenAPI, {
            method: &apos;POST&apos;,
            url: &apos;/api/auth/login&apos;,
            body: data.requestBody,
            mediaType: &apos;application/json&apos;,
            errors: {
                401: &apos;An error&apos;,
                422: &apos;Validation error&apos;
            }
        });
    }
    /**
     * Refresh token
     * Needs refresh token with ability &quot;issue-access-token&quot;
     * @returns unknown
     * @throws ApiError
     */
    public static postApiAuthRefreshToken(): CancelablePromise&lt;PostApiAuthRefreshTokenResponse&gt; {
        return __request(OpenAPI, {
            method: &apos;POST&apos;,
            url: &apos;/api/auth/refreshToken&apos;,
            errors: {
                401: &apos;Unauthenticated&apos;
            }
        });
    }
    /**
     * Get a stream token
     * Needs refresh token with ability &quot;issue-access-token&quot;
     * @returns unknown
     * @throws ApiError
     */
    public static postApiAuthStreamToken(): CancelablePromise&lt;PostApiAuthStreamTokenResponse&gt; {
        return __request(OpenAPI, {
            method: &apos;POST&apos;,
            url: &apos;/api/auth/streamToken&apos;,
            errors: {
                401: &apos;Unauthenticated&apos;
            }
        });
    }
    /**
     * Register
     * @param data The data for the request.
     * @param data.requestBody
     * @returns unknown
     * @throws ApiError
     */
    public static postApiAuthRegister(data: PostApiAuthRegisterData): CancelablePromise&lt;PostApiAuthRegisterResponse&gt; {
        return __request(OpenAPI, {
            method: &apos;POST&apos;,
            url: &apos;/api/auth/register&apos;,
            body: data.requestBody,
            mediaType: &apos;application/json&apos;,
            errors: {
                422: &apos;Validation error&apos;
            }
        });
    }
    /**
     * Request reset password link
     * @param data The data for the request.
     * @param data.requestBody
     * @returns unknown
     * @throws ApiError
     */
    public static postApiAuthForgotPassword(data: PostApiAuthForgotPasswordData): CancelablePromise&lt;PostApiAuthForgotPasswordResponse&gt; {
        return __request(OpenAPI, {
            method: &apos;POST&apos;,
            url: &apos;/api/auth/forgotPassword&apos;,
            body: data.requestBody,
            mediaType: &apos;application/json&apos;,
            errors: {
                422: &apos;Validation error&apos;
            }
        });
    }
    /**
     * Reset password
     * @param data The data for the request.
     * @param data.requestBody
     * @returns unknown
     * @throws ApiError
     */
    public static postApiAuthResetPassword(data: PostApiAuthResetPasswordData): CancelablePromise&lt;PostApiAuthResetPasswordResponse&gt; {
        return __request(OpenAPI, {
            method: &apos;POST&apos;,
            url: &apos;/api/auth/resetPassword&apos;,
            body: data.requestBody,
            mediaType: &apos;application/json&apos;,
            errors: {
                400: &apos;An error&apos;,
                422: &apos;Validation error&apos;
            }
        });
    }
    /**
     * Verify email
     * @param data The data for the request.
     * @param data.id
     * @param data.hash
     * @returns UserResource `UserResource`
     * @throws ApiError
     */
    public static postApiAuthVerifyByIdByHash(data: PostApiAuthVerifyByIdByHashData): CancelablePromise&lt;PostApiAuthVerifyByIdByHashResponse&gt; {
        return __request(OpenAPI, {
            method: &apos;POST&apos;,
            url: &apos;/api/auth/verify/{id}/{hash}&apos;,
            path: {
                id: data.id,
                hash: data.hash
            },
            errors: {
                404: &apos;Not found&apos;
            }
        });
    }
    /**
     * Logout
     * Invalidates the current session
     * @param data The data for the request.
     * @param data.requestBody
     * @returns void No content
     * @throws ApiError
     */
    public static postApiAuthLogout(data: PostApiAuthLogoutData = {}): CancelablePromise&lt;PostApiAuthLogoutResponse&gt; {
        return __request(OpenAPI, {
            method: &apos;POST&apos;,
            url: &apos;/api/auth/logout&apos;,
            body: data.requestBody,
            mediaType: &apos;application/json&apos;,
            errors: {
                401: &apos;Unauthenticated&apos;,
                422: &apos;Validation error&apos;
            }
        });
    }
    /**
     * Get a passkey challenge
     * @returns unknown
     * @throws ApiError
     */
    public static getWebauthnPasskey(): CancelablePromise&lt;GetWebauthnPasskeyResponse&gt; {
        return __request(OpenAPI, {
            method: &apos;GET&apos;,
            url: &apos;/webauthn/passkey&apos;
        });
    }
    /**
     * Login with a passkey
     * @param data The data for the request.
     * @param data.requestBody
     * @returns unknown
     * @throws ApiError
     */
    public static postWebauthnPasskey(data: PostWebauthnPasskeyData): CancelablePromise&lt;PostWebauthnPasskeyResponse&gt; {
        return __request(OpenAPI, {
            method: &apos;POST&apos;,
            url: &apos;/webauthn/passkey&apos;,
            body: data.requestBody,
            mediaType: &apos;application/json&apos;,
            errors: {
                401: &apos;&apos;,
                422: &apos;Validation error&apos;
            }
        });
    }
    /**
     * Get passkey registration options
     * @returns unknown
     * @throws ApiError
     */
    public static getWebauthnPasskeyRegister(): CancelablePromise&lt;GetWebauthnPasskeyRegisterResponse&gt; {
        return __request(OpenAPI, {
            method: &apos;GET&apos;,
            url: &apos;/webauthn/passkey/register&apos;,
            errors: {
                401: &apos;Unauthenticated&apos;
            }
        });
    }
    /**
     * Register passkey
     * @param data The data for the request.
     * @param data.requestBody
     * @returns unknown
     * @throws ApiError
     */
    public static postWebauthnPasskeyRegister(data: PostWebauthnPasskeyRegisterData): CancelablePromise&lt;PostWebauthnPasskeyRegisterResponse&gt; {
        return __request(OpenAPI, {
            method: &apos;POST&apos;,
            url: &apos;/webauthn/passkey/register&apos;,
            body: data.requestBody,
            mediaType: &apos;application/json&apos;,
            errors: {
                401: &apos;Unauthenticated&apos;,
                422: &apos;Validation error&apos;,
                500: &apos;&apos;
            }
        });
    }
}
export class PasskeyService {
    /**
     * Get a passkey challenge
     * @returns unknown
     * @throws ApiError
     */
    public static getWebauthnPasskey(): CancelablePromise&lt;GetWebauthnPasskeyResponse&gt; {
        return __request(OpenAPI, {
            method: &apos;GET&apos;,
            url: &apos;/webauthn/passkey&apos;
        });
    }
    /**
     * Login with a passkey
     * @param data The data for the request.
     * @param data.requestBody
     * @returns unknown
     * @throws ApiError
     */
    public static postWebauthnPasskey(data: PostWebauthnPasskeyData): CancelablePromise&lt;PostWebauthnPasskeyResponse&gt; {
        return __request(OpenAPI, {
            method: &apos;POST&apos;,
            url: &apos;/webauthn/passkey&apos;,
            body: data.requestBody,
            mediaType: &apos;application/json&apos;,
            errors: {
                401: &apos;&apos;,
                422: &apos;Validation error&apos;
            }
        });
    }
    /**
     * Get passkey registration options
     * @returns unknown
     * @throws ApiError
     */
    public static getWebauthnPasskeyRegister(): CancelablePromise&lt;GetWebauthnPasskeyRegisterResponse&gt; {
        return __request(OpenAPI, {
            method: &apos;GET&apos;,
            url: &apos;/webauthn/passkey/register&apos;,
            errors: {
                401: &apos;Unauthenticated&apos;
            }
        });
    }
    /**
     * Register passkey
     * @param data The data for the request.
     * @param data.requestBody
     * @returns unknown
     * @throws ApiError
     */
    public static postWebauthnPasskeyRegister(data: PostWebauthnPasskeyRegisterData): CancelablePromise&lt;PostWebauthnPasskeyRegisterResponse&gt; {
        return __request(OpenAPI, {
            method: &apos;POST&apos;,
            url: &apos;/webauthn/passkey/register&apos;,
            body: data.requestBody,
            mediaType: &apos;application/json&apos;,
            errors: {
                401: &apos;Unauthenticated&apos;,
                422: &apos;Validation error&apos;,
                500: &apos;&apos;
            }
        });
    }
}
export class BatchesService {
    /**
     * Get all of the batches
     * @returns unknown
     * @throws ApiError
     */
    public static getHorizonApiBatches(): CancelablePromise&lt;GetHorizonApiBatchesResponse&gt; {
        return __request(OpenAPI, {
            method: &apos;GET&apos;,
            url: &apos;/-/horizon/api/batches&apos;
        });
    }
    /**
     * Get the details of a batch by ID
     * @param data The data for the request.
     * @param data.id
     * @returns unknown
     * @throws ApiError
     */
    public static getHorizonApiBatchesById(data: GetHorizonApiBatchesByIdData): CancelablePromise&lt;GetHorizonApiBatchesByIdResponse&gt; {
        return __request(OpenAPI, {
            method: &apos;GET&apos;,
            url: &apos;/-/horizon/api/batches/{id}&apos;,
            path: {
                id: data.id
            }
        });
    }
    /**
     * Retry the given batch
     * @param data The data for the request.
     * @param data.id
     * @returns unknown
     * @throws ApiError
     */
    public static postHorizonApiBatchesRetryById(data: PostHorizonApiBatchesRetryByIdData): CancelablePromise&lt;PostHorizonApiBatchesRetryByIdResponse&gt; {
        return __request(OpenAPI, {
            method: &apos;POST&apos;,
            url: &apos;/-/horizon/api/batches/retry/{id}&apos;,
            path: {
                id: data.id
            }
        });
    }
}
export class CompletedJobsService {
    /**
     * Get all of the completed jobs
     * @param data The data for the request.
     * @param data.startingAt
     * @returns unknown
     * @throws ApiError
     */
    public static getHorizonApiJobsCompleted(data: GetHorizonApiJobsCompletedData = {}): CancelablePromise&lt;GetHorizonApiJobsCompletedResponse&gt; {
        return __request(OpenAPI, {
            method: &apos;GET&apos;,
            url: &apos;/-/horizon/api/jobs/completed&apos;,
            query: {
                starting_at: data.startingAt
            }
        });
    }
}
export class DashboardStatsService {
    /**
     * Get the key performance stats for the dashboard
     * @returns unknown
     * @throws ApiError
     */
    public static getHorizonApiStats(): CancelablePromise&lt;GetHorizonApiStatsResponse&gt; {
        return __request(OpenAPI, {
            method: &apos;GET&apos;,
            url: &apos;/-/horizon/api/stats&apos;
        });
    }
}
export class FailedJobsService {
    /**
     * Get all of the failed jobs
     * @param data The data for the request.
     * @param data.tag
     * @returns unknown
     * @throws ApiError
     */
    public static getHorizonApiJobsFailed(data: GetHorizonApiJobsFailedData = {}): CancelablePromise&lt;GetHorizonApiJobsFailedResponse&gt; {
        return __request(OpenAPI, {
            method: &apos;GET&apos;,
            url: &apos;/-/horizon/api/jobs/failed&apos;,
            query: {
                tag: data.tag
            }
        });
    }
    /**
     * Get a failed job instance
     * @param data The data for the request.
     * @param data.id
     * @returns unknown
     * @throws ApiError
     */
    public static getHorizonApiJobsFailedById(data: GetHorizonApiJobsFailedByIdData): CancelablePromise&lt;GetHorizonApiJobsFailedByIdResponse&gt; {
        return __request(OpenAPI, {
            method: &apos;GET&apos;,
            url: &apos;/-/horizon/api/jobs/failed/{id}&apos;,
            path: {
                id: data.id
            }
        });
    }
}
export class FilesService {
    /**
     * @returns LogFileResource Array of `LogFileResource`
     * @throws ApiError
     */
    public static getSystemLogViewerApiFiles(): CancelablePromise&lt;GetSystemLogViewerApiFilesResponse&gt; {
        return __request(OpenAPI, {
            method: &apos;GET&apos;,
            url: &apos;/system/log-viewer/api/files&apos;
        });
    }
    /**
     * @param data The data for the request.
     * @param data.fileIdentifier
     * @returns unknown
     * @throws ApiError
     */
    public static getSystemLogViewerApiFilesByFileIdentifierDownloadRequest(data: GetSystemLogViewerApiFilesByFileIdentifierDownloadRequestData): CancelablePromise&lt;GetSystemLogViewerApiFilesByFileIdentifierDownloadRequestResponse&gt; {
        return __request(OpenAPI, {
            method: &apos;GET&apos;,
            url: &apos;/system/log-viewer/api/files/{fileIdentifier}/download/request&apos;,
            path: {
                fileIdentifier: data.fileIdentifier
            },
            errors: {
                403: &apos;Authorization error&apos;,
                404: &apos;Not found&apos;
            }
        });
    }
    /**
     * @param data The data for the request.
     * @param data.fileIdentifier
     * @returns unknown
     * @throws ApiError
     */
    public static postSystemLogViewerApiFilesByFileIdentifierClearCache(data: PostSystemLogViewerApiFilesByFileIdentifierClearCacheData): CancelablePromise&lt;PostSystemLogViewerApiFilesByFileIdentifierClearCacheResponse&gt; {
        return __request(OpenAPI, {
            method: &apos;POST&apos;,
            url: &apos;/system/log-viewer/api/files/{fileIdentifier}/clear-cache&apos;,
            path: {
                fileIdentifier: data.fileIdentifier
            },
            errors: {
                404: &apos;Not found&apos;
            }
        });
    }
    /**
     * @param data The data for the request.
     * @param data.fileIdentifier
     * @returns unknown
     * @throws ApiError
     */
    public static deleteSystemLogViewerApiFilesByFileIdentifier(data: DeleteSystemLogViewerApiFilesByFileIdentifierData): CancelablePromise&lt;DeleteSystemLogViewerApiFilesByFileIdentifierResponse&gt; {
        return __request(OpenAPI, {
            method: &apos;DELETE&apos;,
            url: &apos;/system/log-viewer/api/files/{fileIdentifier}&apos;,
            path: {
                fileIdentifier: data.fileIdentifier
            },
            errors: {
                403: &apos;Authorization error&apos;
            }
        });
    }
    /**
     * @returns unknown
     * @throws ApiError
     */
    public static postSystemLogViewerApiClearCacheAll(): CancelablePromise&lt;PostSystemLogViewerApiClearCacheAllResponse&gt; {
        return __request(OpenAPI, {
            method: &apos;POST&apos;,
            url: &apos;/system/log-viewer/api/clear-cache-all&apos;
        });
    }
    /**
     * @param data The data for the request.
     * @param data.requestBody
     * @returns unknown
     * @throws ApiError
     */
    public static postSystemLogViewerApiDeleteMultipleFiles(data: PostSystemLogViewerApiDeleteMultipleFilesData = {}): CancelablePromise&lt;PostSystemLogViewerApiDeleteMultipleFilesResponse&gt; {
        return __request(OpenAPI, {
            method: &apos;POST&apos;,
            url: &apos;/system/log-viewer/api/delete-multiple-files&apos;,
            body: data.requestBody,
            mediaType: &apos;application/json&apos;
        });
    }
    /**
     * @param data The data for the request.
     * @param data.fileIdentifier
     * @returns string
     * @throws ApiError
     */
    public static getSystemLogViewerApiFilesByFileIdentifierDownload(data: GetSystemLogViewerApiFilesByFileIdentifierDownloadData): CancelablePromise&lt;GetSystemLogViewerApiFilesByFileIdentifierDownloadResponse&gt; {
        return __request(OpenAPI, {
            method: &apos;GET&apos;,
            url: &apos;/system/log-viewer/api/files/{fileIdentifier}/download&apos;,
            path: {
                fileIdentifier: data.fileIdentifier
            }
        });
    }
}
export class FoldersService {
    /**
     * @param data The data for the request.
     * @param data.direction
     * @returns LogFolderResource Array of `LogFolderResource`
     * @throws ApiError
     */
    public static getSystemLogViewerApiFolders(data: GetSystemLogViewerApiFoldersData = {}): CancelablePromise&lt;GetSystemLogViewerApiFoldersResponse&gt; {
        return __request(OpenAPI, {
            method: &apos;GET&apos;,
            url: &apos;/system/log-viewer/api/folders&apos;,
            query: {
                direction: data.direction
            }
        });
    }
    /**
     * @param data The data for the request.
     * @param data.folderIdentifier
     * @returns unknown
     * @throws ApiError
     */
    public static getSystemLogViewerApiFoldersByFolderIdentifierDownloadRequest(data: GetSystemLogViewerApiFoldersByFolderIdentifierDownloadRequestData): CancelablePromise&lt;GetSystemLogViewerApiFoldersByFolderIdentifierDownloadRequestResponse&gt; {
        return __request(OpenAPI, {
            method: &apos;GET&apos;,
            url: &apos;/system/log-viewer/api/folders/{folderIdentifier}/download/request&apos;,
            path: {
                folderIdentifier: data.folderIdentifier
            },
            errors: {
                403: &apos;Authorization error&apos;,
                404: &apos;Not found&apos;
            }
        });
    }
    /**
     * @param data The data for the request.
     * @param data.folderIdentifier
     * @returns unknown
     * @throws ApiError
     */
    public static postSystemLogViewerApiFoldersByFolderIdentifierClearCache(data: PostSystemLogViewerApiFoldersByFolderIdentifierClearCacheData): CancelablePromise&lt;PostSystemLogViewerApiFoldersByFolderIdentifierClearCacheResponse&gt; {
        return __request(OpenAPI, {
            method: &apos;POST&apos;,
            url: &apos;/system/log-viewer/api/folders/{folderIdentifier}/clear-cache&apos;,
            path: {
                folderIdentifier: data.folderIdentifier
            },
            errors: {
                404: &apos;Not found&apos;
            }
        });
    }
    /**
     * @param data The data for the request.
     * @param data.folderIdentifier
     * @returns unknown
     * @throws ApiError
     */
    public static deleteSystemLogViewerApiFoldersByFolderIdentifier(data: DeleteSystemLogViewerApiFoldersByFolderIdentifierData): CancelablePromise&lt;DeleteSystemLogViewerApiFoldersByFolderIdentifierResponse&gt; {
        return __request(OpenAPI, {
            method: &apos;DELETE&apos;,
            url: &apos;/system/log-viewer/api/folders/{folderIdentifier}&apos;,
            path: {
                folderIdentifier: data.folderIdentifier
            },
            errors: {
                403: &apos;Authorization error&apos;
            }
        });
    }
    /**
     * @param data The data for the request.
     * @param data.folderIdentifier
     * @returns string
     * @throws ApiError
     */
    public static getSystemLogViewerApiFoldersByFolderIdentifierDownload(data: GetSystemLogViewerApiFoldersByFolderIdentifierDownloadData): CancelablePromise&lt;GetSystemLogViewerApiFoldersByFolderIdentifierDownloadResponse&gt; {
        return __request(OpenAPI, {
            method: &apos;GET&apos;,
            url: &apos;/system/log-viewer/api/folders/{folderIdentifier}/download&apos;,
            path: {
                folderIdentifier: data.folderIdentifier
            }
        });
    }
}
export class GenreService {
    /**
     * Get a collection of genres
     * @param data The data for the request.
     * @param data.fields
     * @param data.relations
     * @param data.librarySlug
     * @param data.page
     * @param data.limit
     * @returns unknown Paginated set of `GenreResource`
     * @throws ApiError
     */
    public static getApiGenres(data: GetApiGenresData = {}): CancelablePromise&lt;GetApiGenresResponse&gt; {
        return __request(OpenAPI, {
            method: &apos;GET&apos;,
            url: &apos;/api/genres&apos;,
            query: {
                fields: data.fields,
                relations: data.relations,
                librarySlug: data.librarySlug,
                page: data.page,
                limit: data.limit
            },
            errors: {
                401: &apos;Unauthenticated&apos;,
                422: &apos;Validation error&apos;
            }
        });
    }
    /**
     * Get a genre
     * @param data The data for the request.
     * @param data.genre The genre slug
     * @returns GenreResource `GenreResource`
     * @throws ApiError
     */
    public static getApiGenresByGenre(data: GetApiGenresByGenreData): CancelablePromise&lt;GetApiGenresByGenreResponse&gt; {
        return __request(OpenAPI, {
            method: &apos;GET&apos;,
            url: &apos;/api/genres/{genre}&apos;,
            path: {
                genre: data.genre
            },
            errors: {
                401: &apos;Unauthenticated&apos;,
                404: &apos;Not found&apos;
            }
        });
    }
    /**
     * Update a genre
     * @param data The data for the request.
     * @param data.genre The genre slug
     * @param data.requestBody
     * @returns GenreResource `GenreResource`
     * @throws ApiError
     */
    public static patchApiGenresByGenre(data: PatchApiGenresByGenreData): CancelablePromise&lt;PatchApiGenresByGenreResponse&gt; {
        return __request(OpenAPI, {
            method: &apos;PATCH&apos;,
            url: &apos;/api/genres/{genre}&apos;,
            path: {
                genre: data.genre
            },
            body: data.requestBody,
            mediaType: &apos;application/json&apos;,
            errors: {
                401: &apos;Unauthenticated&apos;,
                404: &apos;Not found&apos;,
                422: &apos;Validation error&apos;
            }
        });
    }
    /**
     * Delete a genre
     * @param data The data for the request.
     * @param data.genre The genre slug
     * @returns void No content
     * @throws ApiError
     */
    public static deleteApiGenresByGenre(data: DeleteApiGenresByGenreData): CancelablePromise&lt;DeleteApiGenresByGenreResponse&gt; {
        return __request(OpenAPI, {
            method: &apos;DELETE&apos;,
            url: &apos;/api/genres/{genre}&apos;,
            path: {
                genre: data.genre
            },
            errors: {
                401: &apos;Unauthenticated&apos;,
                404: &apos;Not found&apos;
            }
        });
    }
}
export class HostsService {
    /**
     * @returns LogViewerHostResource Array of `LogViewerHostResource`
     * @throws ApiError
     */
    public static getSystemLogViewerApiHosts(): CancelablePromise&lt;GetSystemLogViewerApiHostsResponse&gt; {
        return __request(OpenAPI, {
            method: &apos;GET&apos;,
            url: &apos;/system/log-viewer/api/hosts&apos;
        });
    }
}
export class ImageService {
    /**
     * Get an image asset
     * @param data The data for the request.
     * @param data.image The image public id
     * @returns string
     * @throws ApiError
     */
    public static getApiImagesByImage(data: GetApiImagesByImageData): CancelablePromise&lt;GetApiImagesByImageResponse&gt; {
        return __request(OpenAPI, {
            method: &apos;GET&apos;,
            url: &apos;/api/images/{image}&apos;,
            path: {
                image: data.image
            },
            errors: {
                404: &apos;Not found&apos;
            }
        });
    }
}
export class JobService {
    /**
     * Scan a library
     * @param data The data for the request.
     * @param data.slug
     * @returns unknown
     * @throws ApiError
     */
    public static postApiJobsScanLibraryBySlug(data: PostApiJobsScanLibraryBySlugData): CancelablePromise&lt;PostApiJobsScanLibraryBySlugResponse&gt; {
        return __request(OpenAPI, {
            method: &apos;POST&apos;,
            url: &apos;/api/jobs/scanLibrary/{slug}&apos;,
            path: {
                slug: data.slug
            },
            errors: {
                401: &apos;Unauthenticated&apos;
            }
        });
    }
}
export class JobMetricsService {
    /**
     * Get all of the measured jobs
     * @returns unknown
     * @throws ApiError
     */
    public static getHorizonApiMetricsJobs(): CancelablePromise&lt;GetHorizonApiMetricsJobsResponse&gt; {
        return __request(OpenAPI, {
            method: &apos;GET&apos;,
            url: &apos;/-/horizon/api/metrics/jobs&apos;
        });
    }
    /**
     * Get metrics for a given job
     * @param data The data for the request.
     * @param data.id
     * @returns unknown
     * @throws ApiError
     */
    public static getHorizonApiMetricsJobsById(data: GetHorizonApiMetricsJobsByIdData): CancelablePromise&lt;GetHorizonApiMetricsJobsByIdResponse&gt; {
        return __request(OpenAPI, {
            method: &apos;GET&apos;,
            url: &apos;/-/horizon/api/metrics/jobs/{id}&apos;,
            path: {
                id: data.id
            }
        });
    }
}
export class JobsService {
    /**
     * Get the details of a recent job by ID
     * @param data The data for the request.
     * @param data.id
     * @returns unknown
     * @throws ApiError
     */
    public static getHorizonApiJobsById(data: GetHorizonApiJobsByIdData): CancelablePromise&lt;GetHorizonApiJobsByIdResponse&gt; {
        return __request(OpenAPI, {
            method: &apos;GET&apos;,
            url: &apos;/-/horizon/api/jobs/{id}&apos;,
            path: {
                id: data.id
            }
        });
    }
}
export class LibraryService {
    /**
     * Get a collection of media libraries
     * @param data The data for the request.
     * @param data.page
     * @param data.limit
     * @returns unknown Paginated set of `LibraryResource`
     * @throws ApiError
     */
    public static getApiLibraries(data: GetApiLibrariesData = {}): CancelablePromise&lt;GetApiLibrariesResponse&gt; {
        return __request(OpenAPI, {
            method: &apos;GET&apos;,
            url: &apos;/api/libraries&apos;,
            query: {
                page: data.page,
                limit: data.limit
            },
            errors: {
                401: &apos;Unauthenticated&apos;,
                422: &apos;Validation error&apos;
            }
        });
    }
    /**
     * Create a library
     * @param data The data for the request.
     * @param data.requestBody
     * @returns LibraryResource `LibraryResource`
     * @throws ApiError
     */
    public static postApiLibraries(data: PostApiLibrariesData): CancelablePromise&lt;PostApiLibrariesResponse&gt; {
        return __request(OpenAPI, {
            method: &apos;POST&apos;,
            url: &apos;/api/libraries&apos;,
            body: data.requestBody,
            mediaType: &apos;application/json&apos;,
            errors: {
                401: &apos;Unauthenticated&apos;,
                422: &apos;Validation error&apos;
            }
        });
    }
    /**
     * Show library
     * @param data The data for the request.
     * @param data.slug
     * @returns LibraryResource `LibraryResource`
     * @throws ApiError
     */
    public static getApiLibrariesBySlug(data: GetApiLibrariesBySlugData): CancelablePromise&lt;GetApiLibrariesBySlugResponse&gt; {
        return __request(OpenAPI, {
            method: &apos;GET&apos;,
            url: &apos;/api/libraries/{slug}&apos;,
            path: {
                slug: data.slug
            },
            errors: {
                401: &apos;Unauthenticated&apos;
            }
        });
    }
    /**
     * Update a library specified by the provided slug
     * @param data The data for the request.
     * @param data.slug
     * @param data.requestBody
     * @returns LibraryResource `LibraryResource`
     * @throws ApiError
     */
    public static patchApiLibrariesBySlug(data: PatchApiLibrariesBySlugData): CancelablePromise&lt;PatchApiLibrariesBySlugResponse&gt; {
        return __request(OpenAPI, {
            method: &apos;PATCH&apos;,
            url: &apos;/api/libraries/{slug}&apos;,
            path: {
                slug: data.slug
            },
            body: data.requestBody,
            mediaType: &apos;application/json&apos;,
            errors: {
                401: &apos;Unauthenticated&apos;,
                403: &apos;Authorization error&apos;,
                422: &apos;Validation error&apos;
            }
        });
    }
    /**
     * Delete a library
     * @param data The data for the request.
     * @param data.slug
     * @returns void No content
     * @throws ApiError
     */
    public static deleteApiLibrariesBySlug(data: DeleteApiLibrariesBySlugData): CancelablePromise&lt;DeleteApiLibrariesBySlugResponse&gt; {
        return __request(OpenAPI, {
            method: &apos;DELETE&apos;,
            url: &apos;/api/libraries/{slug}&apos;,
            path: {
                slug: data.slug
            },
            errors: {
                401: &apos;Unauthenticated&apos;
            }
        });
    }
}
export class LogsService {
    /**
     * @param data The data for the request.
     * @param data.file
     * @param data.query
     * @param data.direction
     * @param data.log
     * @param data.excludeLevels
     * @param data.excludeFileTypes
     * @param data.perPage
     * @param data.shorterStackTraces
     * @returns unknown
     * @throws ApiError
     */
    public static getSystemLogViewerApiLogs(data: GetSystemLogViewerApiLogsData = {}): CancelablePromise&lt;GetSystemLogViewerApiLogsResponse&gt; {
        return __request(OpenAPI, {
            method: &apos;GET&apos;,
            url: &apos;/system/log-viewer/api/logs&apos;,
            query: {
                file: data.file,
                query: data.query,
                direction: data.direction,
                log: data.log,
                exclude_levels: data.excludeLevels,
                exclude_file_types: data.excludeFileTypes,
                per_page: data.perPage,
                shorter_stack_traces: data.shorterStackTraces
            }
        });
    }
}
export class MasterSupervisorService {
    /**
     * Get all of the master supervisors and their underlying supervisors
     * @returns unknown
     * @throws ApiError
     */
    public static getHorizonApiMasters(): CancelablePromise&lt;GetHorizonApiMastersResponse&gt; {
        return __request(OpenAPI, {
            method: &apos;GET&apos;,
            url: &apos;/-/horizon/api/masters&apos;
        });
    }
}
export class MonitoringService {
    /**
     * Get all of the monitored tags and their job counts
     * @returns unknown
     * @throws ApiError
     */
    public static getHorizonApiMonitoring(): CancelablePromise&lt;GetHorizonApiMonitoringResponse&gt; {
        return __request(OpenAPI, {
            method: &apos;GET&apos;,
            url: &apos;/-/horizon/api/monitoring&apos;
        });
    }
    /**
     * Start monitoring the given tag
     * @returns unknown
     * @throws ApiError
     */
    public static postHorizonApiMonitoring(): CancelablePromise&lt;PostHorizonApiMonitoringResponse&gt; {
        return __request(OpenAPI, {
            method: &apos;POST&apos;,
            url: &apos;/-/horizon/api/monitoring&apos;
        });
    }
    /**
     * Paginate the jobs for a given tag
     * @param data The data for the request.
     * @param data.tag
     * @param data.limit
     * @returns unknown
     * @throws ApiError
     */
    public static getHorizonApiMonitoringByTag(data: GetHorizonApiMonitoringByTagData): CancelablePromise&lt;GetHorizonApiMonitoringByTagResponse&gt; {
        return __request(OpenAPI, {
            method: &apos;GET&apos;,
            url: &apos;/-/horizon/api/monitoring/{tag}&apos;,
            path: {
                tag: data.tag
            },
            query: {
                limit: data.limit
            }
        });
    }
    /**
     * Stop monitoring the given tag
     * @param data The data for the request.
     * @param data.tag
     * @returns unknown
     * @throws ApiError
     */
    public static deleteHorizonApiMonitoringByTag(data: DeleteHorizonApiMonitoringByTagData): CancelablePromise&lt;DeleteHorizonApiMonitoringByTagResponse&gt; {
        return __request(OpenAPI, {
            method: &apos;DELETE&apos;,
            url: &apos;/-/horizon/api/monitoring/{tag}&apos;,
            path: {
                tag: data.tag
            }
        });
    }
}
export class MovieService {
    /**
     * Get a collection of movies
     * @param data The data for the request.
     * @param data.library The library slug
     * @returns unknown Paginated set of `MovieResource`
     * @throws ApiError
     */
    public static getApiLibrariesByLibraryMovies(data: GetApiLibrariesByLibraryMoviesData): CancelablePromise&lt;GetApiLibrariesByLibraryMoviesResponse&gt; {
        return __request(OpenAPI, {
            method: &apos;GET&apos;,
            url: &apos;/api/libraries/{library}/movies&apos;,
            path: {
                library: data.library
            },
            errors: {
                401: &apos;Unauthenticated&apos;,
                404: &apos;Not found&apos;
            }
        });
    }
    /**
     * Get a movie
     * @param data The data for the request.
     * @param data.library The library slug
     * @param data.movie The movie slug
     * @returns MovieResource `MovieResource`
     * @throws ApiError
     */
    public static getApiLibrariesByLibraryMoviesByMovie(data: GetApiLibrariesByLibraryMoviesByMovieData): CancelablePromise&lt;GetApiLibrariesByLibraryMoviesByMovieResponse&gt; {
        return __request(OpenAPI, {
            method: &apos;GET&apos;,
            url: &apos;/api/libraries/{library}/movies/{movie}&apos;,
            path: {
                library: data.library,
                movie: data.movie
            },
            errors: {
                401: &apos;Unauthenticated&apos;,
                404: &apos;Not found&apos;
            }
        });
    }
}
export class OpCacheService {
    /**
     * Get status
     * @returns unknown
     * @throws ApiError
     */
    public static getApiOpcacheStatus(): CancelablePromise&lt;GetApiOpcacheStatusResponse&gt; {
        return __request(OpenAPI, {
            method: &apos;GET&apos;,
            url: &apos;/api/opcache/status&apos;,
            errors: {
                401: &apos;Unauthenticated&apos;
            }
        });
    }
    /**
     * Get config
     * @returns unknown
     * @throws ApiError
     */
    public static getApiOpcacheConfig(): CancelablePromise&lt;GetApiOpcacheConfigResponse&gt; {
        return __request(OpenAPI, {
            method: &apos;GET&apos;,
            url: &apos;/api/opcache/config&apos;,
            errors: {
                401: &apos;Unauthenticated&apos;
            }
        });
    }
    /**
     * Clear
     * @returns unknown
     * @throws ApiError
     */
    public static postApiOpcacheClear(): CancelablePromise&lt;PostApiOpcacheClearResponse&gt; {
        return __request(OpenAPI, {
            method: &apos;POST&apos;,
            url: &apos;/api/opcache/clear&apos;,
            errors: {
                401: &apos;Unauthenticated&apos;
            }
        });
    }
    /**
     * Compile cache
     * @param data The data for the request.
     * @param data.force
     * @returns unknown
     * @throws ApiError
     */
    public static postApiOpcacheCompile(data: PostApiOpcacheCompileData = {}): CancelablePromise&lt;PostApiOpcacheCompileResponse&gt; {
        return __request(OpenAPI, {
            method: &apos;POST&apos;,
            url: &apos;/api/opcache/compile&apos;,
            query: {
                force: data.force
            },
            errors: {
                401: &apos;Unauthenticated&apos;
            }
        });
    }
}
export class PendingJobsService {
    /**
     * Get all of the pending jobs
     * @param data The data for the request.
     * @param data.startingAt
     * @returns unknown
     * @throws ApiError
     */
    public static getHorizonApiJobsPending(data: GetHorizonApiJobsPendingData = {}): CancelablePromise&lt;GetHorizonApiJobsPendingResponse&gt; {
        return __request(OpenAPI, {
            method: &apos;GET&apos;,
            url: &apos;/-/horizon/api/jobs/pending&apos;,
            query: {
                starting_at: data.startingAt
            }
        });
    }
}
export class PlaylistService {
    /**
     * Get a collection of playlists
     * @returns unknown Paginated set of `PlaylistResource`
     * @throws ApiError
     */
    public static getApiPlaylists(): CancelablePromise&lt;GetApiPlaylistsResponse&gt; {
        return __request(OpenAPI, {
            method: &apos;GET&apos;,
            url: &apos;/api/playlists&apos;,
            errors: {
                401: &apos;Unauthenticated&apos;
            }
        });
    }
    /**
     * Create a playlist
     * @param data The data for the request.
     * @param data.requestBody
     * @returns PlaylistResource `PlaylistResource`
     * @throws ApiError
     */
    public static postApiPlaylists(data: PostApiPlaylistsData): CancelablePromise&lt;PostApiPlaylistsResponse&gt; {
        return __request(OpenAPI, {
            method: &apos;POST&apos;,
            url: &apos;/api/playlists&apos;,
            body: data.requestBody,
            mediaType: &apos;application/json&apos;,
            errors: {
                401: &apos;Unauthenticated&apos;,
                422: &apos;Validation error&apos;
            }
        });
    }
    /**
     * Show a playlist
     * @param data The data for the request.
     * @param data.playlist The playlist public id
     * @param data.relations
     * @returns PlaylistResource `PlaylistResource`
     * @throws ApiError
     */
    public static getApiPlaylistsByPlaylist(data: GetApiPlaylistsByPlaylistData): CancelablePromise&lt;GetApiPlaylistsByPlaylistResponse&gt; {
        return __request(OpenAPI, {
            method: &apos;GET&apos;,
            url: &apos;/api/playlists/{playlist}&apos;,
            path: {
                playlist: data.playlist
            },
            query: {
                relations: data.relations
            },
            errors: {
                401: &apos;Unauthenticated&apos;,
                403: &apos;Authorization error&apos;,
                404: &apos;Not found&apos;,
                422: &apos;Validation error&apos;
            }
        });
    }
    /**
     * Update a playlist
     * @param data The data for the request.
     * @param data.playlist The playlist public id
     * @param data.requestBody
     * @returns PlaylistResource `PlaylistResource`
     * @throws ApiError
     */
    public static putApiPlaylistsByPlaylist(data: PutApiPlaylistsByPlaylistData): CancelablePromise&lt;PutApiPlaylistsByPlaylistResponse&gt; {
        return __request(OpenAPI, {
            method: &apos;PUT&apos;,
            url: &apos;/api/playlists/{playlist}&apos;,
            path: {
                playlist: data.playlist
            },
            body: data.requestBody,
            mediaType: &apos;application/json&apos;,
            errors: {
                401: &apos;Unauthenticated&apos;,
                403: &apos;Authorization error&apos;,
                404: &apos;Not found&apos;,
                422: &apos;Validation error&apos;
            }
        });
    }
    /**
     * Delete a playlist
     * @param data The data for the request.
     * @param data.playlist The playlist public id
     * @returns void No content
     * @throws ApiError
     */
    public static deleteApiPlaylistsByPlaylist(data: DeleteApiPlaylistsByPlaylistData): CancelablePromise&lt;DeleteApiPlaylistsByPlaylistResponse&gt; {
        return __request(OpenAPI, {
            method: &apos;DELETE&apos;,
            url: &apos;/api/playlists/{playlist}&apos;,
            path: {
                playlist: data.playlist
            },
            errors: {
                401: &apos;Unauthenticated&apos;,
                403: &apos;Authorization error&apos;,
                404: &apos;Not found&apos;
            }
        });
    }
    /**
     * Add a song
     * @param data The data for the request.
     * @param data.playlist The playlist public id
     * @param data.song The song public id
     * @returns unknown
     * @throws ApiError
     */
    public static postApiPlaylistsByPlaylistSongsBySong(data: PostApiPlaylistsByPlaylistSongsBySongData): CancelablePromise&lt;PostApiPlaylistsByPlaylistSongsBySongResponse&gt; {
        return __request(OpenAPI, {
            method: &apos;POST&apos;,
            url: &apos;/api/playlists/{playlist}/songs/{song}&apos;,
            path: {
                playlist: data.playlist,
                song: data.song
            },
            errors: {
                401: &apos;Unauthenticated&apos;,
                403: &apos;Authorization error&apos;,
                404: &apos;Not found&apos;
            }
        });
    }
    /**
     * Remove a song
     * @param data The data for the request.
     * @param data.playlist The playlist public id
     * @param data.song The song public id
     * @returns unknown
     * @throws ApiError
     */
    public static deleteApiPlaylistsByPlaylistSongsBySong(data: DeleteApiPlaylistsByPlaylistSongsBySongData): CancelablePromise&lt;DeleteApiPlaylistsByPlaylistSongsBySongResponse&gt; {
        return __request(OpenAPI, {
            method: &apos;DELETE&apos;,
            url: &apos;/api/playlists/{playlist}/songs/{song}&apos;,
            path: {
                playlist: data.playlist,
                song: data.song
            },
            errors: {
                401: &apos;Unauthenticated&apos;,
                403: &apos;Authorization error&apos;,
                404: &apos;Not found&apos;
            }
        });
    }
    /**
     * Reorder songs
     * @param data The data for the request.
     * @param data.playlist The playlist public id
     * @param data.requestBody
     * @returns unknown
     * @throws ApiError
     */
    public static postApiPlaylistsByPlaylistReorder(data: PostApiPlaylistsByPlaylistReorderData): CancelablePromise&lt;PostApiPlaylistsByPlaylistReorderResponse&gt; {
        return __request(OpenAPI, {
            method: &apos;POST&apos;,
            url: &apos;/api/playlists/{playlist}/reorder&apos;,
            path: {
                playlist: data.playlist
            },
            body: data.requestBody,
            mediaType: &apos;application/json&apos;,
            errors: {
                401: &apos;Unauthenticated&apos;,
                403: &apos;Authorization error&apos;,
                404: &apos;Not found&apos;,
                422: &apos;Validation error&apos;
            }
        });
    }
    /**
     * Add collaborator
     * @param data The data for the request.
     * @param data.playlist The playlist public id
     * @param data.requestBody
     * @returns unknown
     * @throws ApiError
     */
    public static postApiPlaylistsByPlaylistCollaborators(data: PostApiPlaylistsByPlaylistCollaboratorsData): CancelablePromise&lt;PostApiPlaylistsByPlaylistCollaboratorsResponse&gt; {
        return __request(OpenAPI, {
            method: &apos;POST&apos;,
            url: &apos;/api/playlists/{playlist}/collaborators&apos;,
            path: {
                playlist: data.playlist
            },
            body: data.requestBody,
            mediaType: &apos;application/json&apos;,
            errors: {
                401: &apos;Unauthenticated&apos;,
                403: &apos;Authorization error&apos;,
                404: &apos;Not found&apos;,
                422: &apos;Validation error&apos;
            }
        });
    }
    /**
     * Remove collaborator
     * @param data The data for the request.
     * @param data.playlist The playlist public id
     * @param data.user The user ID
     * @returns unknown
     * @throws ApiError
     */
    public static deleteApiPlaylistsByPlaylistCollaboratorsByUser(data: DeleteApiPlaylistsByPlaylistCollaboratorsByUserData): CancelablePromise&lt;DeleteApiPlaylistsByPlaylistCollaboratorsByUserResponse&gt; {
        return __request(OpenAPI, {
            method: &apos;DELETE&apos;,
            url: &apos;/api/playlists/{playlist}/collaborators/{user}&apos;,
            path: {
                playlist: data.playlist,
                user: data.user
            },
            errors: {
                401: &apos;Unauthenticated&apos;,
                403: &apos;Authorization error&apos;,
                404: &apos;Not found&apos;
            }
        });
    }
    /**
     * Clone playlist
     * @param data The data for the request.
     * @param data.playlist The playlist public id
     * @returns PlaylistResource `PlaylistResource`
     * @throws ApiError
     */
    public static postApiPlaylistsByPlaylistClone(data: PostApiPlaylistsByPlaylistCloneData): CancelablePromise&lt;PostApiPlaylistsByPlaylistCloneResponse&gt; {
        return __request(OpenAPI, {
            method: &apos;POST&apos;,
            url: &apos;/api/playlists/{playlist}/clone&apos;,
            path: {
                playlist: data.playlist
            },
            errors: {
                401: &apos;Unauthenticated&apos;,
                403: &apos;Authorization error&apos;,
                404: &apos;Not found&apos;
            }
        });
    }
    /**
     * Get statistics
     * @param data The data for the request.
     * @param data.playlist The playlist public id
     * @returns PlaylistStatistic `PlaylistStatistic`
     * @throws ApiError
     */
    public static getApiPlaylistsByPlaylistStatistics(data: GetApiPlaylistsByPlaylistStatisticsData): CancelablePromise&lt;GetApiPlaylistsByPlaylistStatisticsResponse&gt; {
        return __request(OpenAPI, {
            method: &apos;GET&apos;,
            url: &apos;/api/playlists/{playlist}/statistics&apos;,
            path: {
                playlist: data.playlist
            },
            errors: {
                401: &apos;Unauthenticated&apos;,
                403: &apos;Authorization error&apos;,
                404: &apos;Not found&apos;
            }
        });
    }
    /**
     * Statistics - Record view
     * @param data The data for the request.
     * @param data.playlist The playlist public id
     * @returns unknown
     * @throws ApiError
     */
    public static postApiPlaylistsByPlaylistStatisticsRecordView(data: PostApiPlaylistsByPlaylistStatisticsRecordViewData): CancelablePromise&lt;PostApiPlaylistsByPlaylistStatisticsRecordViewResponse&gt; {
        return __request(OpenAPI, {
            method: &apos;POST&apos;,
            url: &apos;/api/playlists/{playlist}/statistics/record/view&apos;,
            path: {
                playlist: data.playlist
            },
            errors: {
                401: &apos;Unauthenticated&apos;,
                403: &apos;Authorization error&apos;,
                404: &apos;Not found&apos;
            }
        });
    }
    /**
     * Statistics - Record play
     * @param data The data for the request.
     * @param data.playlist The playlist public id
     * @returns unknown
     * @throws ApiError
     */
    public static postApiPlaylistsByPlaylistStatisticsRecordPlay(data: PostApiPlaylistsByPlaylistStatisticsRecordPlayData): CancelablePromise&lt;PostApiPlaylistsByPlaylistStatisticsRecordPlayResponse&gt; {
        return __request(OpenAPI, {
            method: &apos;POST&apos;,
            url: &apos;/api/playlists/{playlist}/statistics/record/play&apos;,
            path: {
                playlist: data.playlist
            },
            errors: {
                401: &apos;Unauthenticated&apos;,
                403: &apos;Authorization error&apos;,
                404: &apos;Not found&apos;
            }
        });
    }
    /**
     * Share
     * @param data The data for the request.
     * @param data.playlist The playlist public id
     * @returns unknown
     * @throws ApiError
     */
    public static postApiPlaylistsByPlaylistStatisticsRecordShare(data: PostApiPlaylistsByPlaylistStatisticsRecordShareData): CancelablePromise&lt;PostApiPlaylistsByPlaylistStatisticsRecordShareResponse&gt; {
        return __request(OpenAPI, {
            method: &apos;POST&apos;,
            url: &apos;/api/playlists/{playlist}/statistics/record/share&apos;,
            path: {
                playlist: data.playlist
            },
            errors: {
                401: &apos;Unauthenticated&apos;,
                403: &apos;Authorization error&apos;,
                404: &apos;Not found&apos;
            }
        });
    }
    /**
     * Favorite
     * @param data The data for the request.
     * @param data.playlist The playlist public id
     * @returns unknown
     * @throws ApiError
     */
    public static postApiPlaylistsByPlaylistStatisticsRecordFavorite(data: PostApiPlaylistsByPlaylistStatisticsRecordFavoriteData): CancelablePromise&lt;PostApiPlaylistsByPlaylistStatisticsRecordFavoriteResponse&gt; {
        return __request(OpenAPI, {
            method: &apos;POST&apos;,
            url: &apos;/api/playlists/{playlist}/statistics/record/favorite&apos;,
            path: {
                playlist: data.playlist
            },
            errors: {
                401: &apos;Unauthenticated&apos;,
                403: &apos;Authorization error&apos;,
                404: &apos;Not found&apos;
            }
        });
    }
    /**
     * Smart playlist - Create
     * @param data The data for the request.
     * @param data.requestBody
     * @returns PlaylistResource `PlaylistResource`
     * @throws ApiError
     */
    public static postApiPlaylistsSmart(data: PostApiPlaylistsSmartData): CancelablePromise&lt;PostApiPlaylistsSmartResponse&gt; {
        return __request(OpenAPI, {
            method: &apos;POST&apos;,
            url: &apos;/api/playlists/smart&apos;,
            body: data.requestBody,
            mediaType: &apos;application/json&apos;,
            errors: {
                401: &apos;Unauthenticated&apos;,
                422: &apos;Validation error&apos;
            }
        });
    }
    /**
     * Smart playlist - Update rules
     * @param data The data for the request.
     * @param data.playlist The playlist public id
     * @param data.requestBody
     * @returns PlaylistResource `PlaylistResource`
     * @throws ApiError
     */
    public static putApiPlaylistsByPlaylistSmart(data: PutApiPlaylistsByPlaylistSmartData): CancelablePromise&lt;PutApiPlaylistsByPlaylistSmartResponse&gt; {
        return __request(OpenAPI, {
            method: &apos;PUT&apos;,
            url: &apos;/api/playlists/{playlist}/smart&apos;,
            path: {
                playlist: data.playlist
            },
            body: data.requestBody,
            mediaType: &apos;application/json&apos;,
            errors: {
                400: &apos;An error&apos;,
                401: &apos;Unauthenticated&apos;,
                403: &apos;Authorization error&apos;,
                404: &apos;Not found&apos;,
                422: &apos;Validation error&apos;
            }
        });
    }
    /**
     * Smart playlist - Sync
     * @param data The data for the request.
     * @param data.playlist The playlist public id
     * @returns unknown
     * @throws ApiError
     */
    public static postApiPlaylistsByPlaylistSmartSync(data: PostApiPlaylistsByPlaylistSmartSyncData): CancelablePromise&lt;PostApiPlaylistsByPlaylistSmartSyncResponse&gt; {
        return __request(OpenAPI, {
            method: &apos;POST&apos;,
            url: &apos;/api/playlists/{playlist}/smart/sync&apos;,
            path: {
                playlist: data.playlist
            },
            errors: {
                400: &apos;An error&apos;,
                401: &apos;Unauthenticated&apos;,
                403: &apos;Authorization error&apos;,
                404: &apos;Not found&apos;
            }
        });
    }
}
export class QueueService {
    /**
     * Get a collection of monitor entries
     * @param data The data for the request.
     * @param data.page
     * @param data.limit
     * @param data.status
     * @param data.queue
     * @param data.name
     * @param data.queuedFirst
     * @returns unknown Paginated set of `QueueMonitorResource`
     * @throws ApiError
     */
    public static getApiQueueMetrics(data: GetApiQueueMetricsData = {}): CancelablePromise&lt;GetApiQueueMetricsResponse&gt; {
        return __request(OpenAPI, {
            method: &apos;GET&apos;,
            url: &apos;/api/queue-metrics&apos;,
            query: {
                page: data.page,
                limit: data.limit,
                status: data.status,
                queue: data.queue,
                name: data.name,
                queuedFirst: data.queuedFirst
            },
            errors: {
                401: &apos;Unauthenticated&apos;,
                422: &apos;Validation error&apos;
            }
        });
    }
    /**
     * Get a list of queue names
     * @returns unknown
     * @throws ApiError
     */
    public static getApiQueueMetricsQueues(): CancelablePromise&lt;GetApiQueueMetricsQueuesResponse&gt; {
        return __request(OpenAPI, {
            method: &apos;GET&apos;,
            url: &apos;/api/queue-metrics/queues&apos;,
            errors: {
                401: &apos;Unauthenticated&apos;
            }
        });
    }
    /**
     * Get a metrics collection
     * @param data The data for the request.
     * @param data.aggregateDays
     * @returns unknown
     * @throws ApiError
     */
    public static getApiQueueMetricsMetrics(data: GetApiQueueMetricsMetricsData = {}): CancelablePromise&lt;GetApiQueueMetricsMetricsResponse&gt; {
        return __request(OpenAPI, {
            method: &apos;GET&apos;,
            url: &apos;/api/queue-metrics/metrics&apos;,
            query: {
                aggregateDays: data.aggregateDays
            },
            errors: {
                401: &apos;Unauthenticated&apos;,
                422: &apos;Validation error&apos;
            }
        });
    }
    /**
     * Retry a job
     * @param data The data for the request.
     * @param data.id
     * @param data.requestBody
     * @returns unknown
     * @throws ApiError
     */
    public static postApiQueueMetricsRetryById(data: PostApiQueueMetricsRetryByIdData): CancelablePromise&lt;PostApiQueueMetricsRetryByIdResponse&gt; {
        return __request(OpenAPI, {
            method: &apos;POST&apos;,
            url: &apos;/api/queue-metrics/retry/{id}&apos;,
            path: {
                id: data.id
            },
            body: data.requestBody,
            mediaType: &apos;application/json&apos;,
            errors: {
                400: &apos;An error&apos;,
                401: &apos;Unauthenticated&apos;,
                422: &apos;Validation error&apos;
            }
        });
    }
    /**
     * Delete by id
     * @param data The data for the request.
     * @param data.id
     * @returns void No content
     * @throws ApiError
     */
    public static deleteApiQueueMetricsById(data: DeleteApiQueueMetricsByIdData): CancelablePromise&lt;DeleteApiQueueMetricsByIdResponse&gt; {
        return __request(OpenAPI, {
            method: &apos;DELETE&apos;,
            url: &apos;/api/queue-metrics/{id}&apos;,
            path: {
                id: data.id
            },
            errors: {
                401: &apos;Unauthenticated&apos;
            }
        });
    }
    /**
     * Purge all records
     * @returns void No content
     * @throws ApiError
     */
    public static deleteApiQueueMetricsPurge(): CancelablePromise&lt;DeleteApiQueueMetricsPurgeResponse&gt; {
        return __request(OpenAPI, {
            method: &apos;DELETE&apos;,
            url: &apos;/api/queue-metrics/purge&apos;,
            errors: {
                401: &apos;Unauthenticated&apos;
            }
        });
    }
}
export class QueueMetricsService {
    /**
     * Get all of the measured queues
     * @returns unknown
     * @throws ApiError
     */
    public static getHorizonApiMetricsQueues(): CancelablePromise&lt;GetHorizonApiMetricsQueuesResponse&gt; {
        return __request(OpenAPI, {
            method: &apos;GET&apos;,
            url: &apos;/-/horizon/api/metrics/queues&apos;
        });
    }
    /**
     * Get metrics for a given queue
     * @param data The data for the request.
     * @param data.id
     * @returns unknown
     * @throws ApiError
     */
    public static getHorizonApiMetricsQueuesById(data: GetHorizonApiMetricsQueuesByIdData): CancelablePromise&lt;GetHorizonApiMetricsQueuesByIdResponse&gt; {
        return __request(OpenAPI, {
            method: &apos;GET&apos;,
            url: &apos;/-/horizon/api/metrics/queues/{id}&apos;,
            path: {
                id: data.id
            }
        });
    }
}
export class RetryService {
    /**
     * Retry a failed job
     * @param data The data for the request.
     * @param data.id
     * @returns unknown
     * @throws ApiError
     */
    public static postHorizonApiJobsRetryById(data: PostHorizonApiJobsRetryByIdData): CancelablePromise&lt;PostHorizonApiJobsRetryByIdResponse&gt; {
        return __request(OpenAPI, {
            method: &apos;POST&apos;,
            url: &apos;/-/horizon/api/jobs/retry/{id}&apos;,
            path: {
                id: data.id
            }
        });
    }
}
export class SchemaService {
    /**
     * @returns unknown
     * @throws ApiError
     */
    public static getApiSchemasMusicbrainz(): CancelablePromise&lt;GetApiSchemasMusicbrainzResponse&gt; {
        return __request(OpenAPI, {
            method: &apos;GET&apos;,
            url: &apos;/api/schemas/musicbrainz&apos;
        });
    }
}
export class SilencedJobsService {
    /**
     * Get all of the silenced jobs
     * @param data The data for the request.
     * @param data.startingAt
     * @returns unknown
     * @throws ApiError
     */
    public static getHorizonApiJobsSilenced(data: GetHorizonApiJobsSilencedData = {}): CancelablePromise&lt;GetHorizonApiJobsSilencedResponse&gt; {
        return __request(OpenAPI, {
            method: &apos;GET&apos;,
            url: &apos;/-/horizon/api/jobs/silenced&apos;,
            query: {
                starting_at: data.startingAt
            }
        });
    }
}
export class SongService {
    /**
     * Get a collection of songs
     * @param data The data for the request.
     * @param data.library The library slug
     * @param data.page
     * @param data.limit
     * @param data.genreNames
     * @param data.genreSlugs
     * @param data.relations
     * @returns unknown Paginated set of `SongResource`
     * @throws ApiError
     */
    public static getApiLibrariesByLibrarySongs(data: GetApiLibrariesByLibrarySongsData): CancelablePromise&lt;GetApiLibrariesByLibrarySongsResponse&gt; {
        return __request(OpenAPI, {
            method: &apos;GET&apos;,
            url: &apos;/api/libraries/{library}/songs&apos;,
            path: {
                library: data.library
            },
            query: {
                page: data.page,
                limit: data.limit,
                genreNames: data.genreNames,
                genreSlugs: data.genreSlugs,
                relations: data.relations
            },
            errors: {
                400: &apos;An error&apos;,
                401: &apos;Unauthenticated&apos;,
                404: &apos;Not found&apos;,
                422: &apos;Validation error&apos;
            }
        });
    }
    /**
     * Get a song by public id
     * @param data The data for the request.
     * @param data.library The library slug
     * @param data.publicId
     * @param data.relations
     * @returns SongResource `SongResource`
     * @throws ApiError
     */
    public static getApiLibrariesByLibrarySongsByPublicId(data: GetApiLibrariesByLibrarySongsByPublicIdData): CancelablePromise&lt;GetApiLibrariesByLibrarySongsByPublicIdResponse&gt; {
        return __request(OpenAPI, {
            method: &apos;GET&apos;,
            url: &apos;/api/libraries/{library}/songs/{publicId}&apos;,
            path: {
                library: data.library,
                publicId: data.publicId
            },
            query: {
                relations: data.relations
            },
            errors: {
                401: &apos;Unauthenticated&apos;,
                404: &apos;Not found&apos;,
                422: &apos;Validation error&apos;
            }
        });
    }
}
export class StreamService {
    /**
     * Direct stream the song.
     * Requires token with &quot;access-stream&quot;
     * @param data The data for the request.
     * @param data.song The song public id
     * @returns unknown
     * @throws ApiError
     */
    public static getApiStreamSongBySongDirect(data: GetApiStreamSongBySongDirectData): CancelablePromise&lt;GetApiStreamSongBySongDirectResponse&gt; {
        return __request(OpenAPI, {
            method: &apos;GET&apos;,
            url: &apos;/api/stream/song/{song}/direct&apos;,
            path: {
                song: data.song
            },
            errors: {
                401: &apos;Unauthenticated&apos;,
                404: &apos;Not found&apos;
            }
        });
    }
}
export class SystemInfoService {
    /**
     * Get php info
     * @returns unknown
     * @throws ApiError
     */
    public static getApiSystemInfo(): CancelablePromise&lt;GetApiSystemInfoResponse&gt; {
        return __request(OpenAPI, {
            method: &apos;GET&apos;,
            url: &apos;/api/system-info&apos;,
            errors: {
                401: &apos;Unauthenticated&apos;
            }
        });
    }
    /**
     * @returns unknown
     * @throws ApiError
     */
    public static getApiSystemInfoSys(): CancelablePromise&lt;GetApiSystemInfoSysResponse&gt; {
        return __request(OpenAPI, {
            method: &apos;GET&apos;,
            url: &apos;/api/system-info/sys&apos;,
            errors: {
                401: &apos;Unauthenticated&apos;
            }
        });
    }
}
export class UserService {
    /**
     * Get a collection of users
     * @param data The data for the request.
     * @param data.page
     * @param data.limit
     * @param data.globalFilter
     * @param data.filters
     * @param data.filterModes
     * @param data.sorting
     * @returns unknown Paginated set of `UserResource`
     * @throws ApiError
     */
    public static getApiUsers(data: GetApiUsersData = {}): CancelablePromise&lt;GetApiUsersResponse&gt; {
        return __request(OpenAPI, {
            method: &apos;GET&apos;,
            url: &apos;/api/users&apos;,
            query: {
                page: data.page,
                limit: data.limit,
                globalFilter: data.globalFilter,
                filters: data.filters,
                filterModes: data.filterModes,
                sorting: data.sorting
            },
            errors: {
                401: &apos;Unauthenticated&apos;,
                422: &apos;Validation error&apos;
            }
        });
    }
    /**
     * Create user
     * This is endpoint allows administrators to create users
     * @param data The data for the request.
     * @param data.requestBody
     * @returns UserResource `UserResource`
     * @throws ApiError
     */
    public static postApiUsers(data: PostApiUsersData): CancelablePromise&lt;PostApiUsersResponse&gt; {
        return __request(OpenAPI, {
            method: &apos;POST&apos;,
            url: &apos;/api/users&apos;,
            body: data.requestBody,
            mediaType: &apos;application/json&apos;,
            errors: {
                401: &apos;Unauthenticated&apos;,
                422: &apos;Validation error&apos;
            }
        });
    }
    /**
     * Update a user
     * @param data The data for the request.
     * @param data.user The user ID
     * @param data.requestBody
     * @returns UserResource `UserResource`
     * @throws ApiError
     */
    public static patchApiUsersByUser(data: PatchApiUsersByUserData): CancelablePromise&lt;PatchApiUsersByUserResponse&gt; {
        return __request(OpenAPI, {
            method: &apos;PATCH&apos;,
            url: &apos;/api/users/{user}&apos;,
            path: {
                user: data.user
            },
            body: data.requestBody,
            mediaType: &apos;application/json&apos;,
            errors: {
                401: &apos;Unauthenticated&apos;,
                404: &apos;Not found&apos;,
                422: &apos;Validation error&apos;
            }
        });
    }
    /**
     * Get small user detail info
     * @param data The data for the request.
     * @param data.user The user ID
     * @returns UserResource `UserResource`
     * @throws ApiError
     */
    public static getApiUsersByUser(data: GetApiUsersByUserData): CancelablePromise&lt;GetApiUsersByUserResponse&gt; {
        return __request(OpenAPI, {
            method: &apos;GET&apos;,
            url: &apos;/api/users/{user}&apos;,
            path: {
                user: data.user
            },
            errors: {
                401: &apos;Unauthenticated&apos;,
                404: &apos;Not found&apos;
            }
        });
    }
    /**
     * Delete a user
     * @param data The data for the request.
     * @param data.user
     * @returns void No content
     * @throws ApiError
     */
    public static deleteApiUsersByUser(data: DeleteApiUsersByUserData): CancelablePromise&lt;DeleteApiUsersByUserResponse&gt; {
        return __request(OpenAPI, {
            method: &apos;DELETE&apos;,
            url: &apos;/api/users/{user}&apos;,
            path: {
                user: data.user
            },
            errors: {
                401: &apos;Unauthenticated&apos;
            }
        });
    }
    /**
     * Get the authenticated user
     * @returns UserResource `UserResource`
     * @throws ApiError
     */
    public static getApiUsersMe(): CancelablePromise&lt;GetApiUsersMeResponse&gt; {
        return __request(OpenAPI, {
            method: &apos;GET&apos;,
            url: &apos;/api/users/me&apos;,
            errors: {
                401: &apos;Unauthenticated&apos;
            }
        });
    }
}
export class UserTokenService {
    /**
     * Get a collection of tokens
     * @param data The data for the request.
     * @param data.user
     * @param data.page
     * @param data.perPage
     * @returns unknown Paginated set of `PersonalAccessTokenViewResource`
     * @throws ApiError
     */
    public static getApiUsersTokensByUser(data: GetApiUsersTokensByUserData): CancelablePromise&lt;GetApiUsersTokensByUserResponse&gt; {
        return __request(OpenAPI, {
            method: &apos;GET&apos;,
            url: &apos;/api/users/tokens/{user}&apos;,
            path: {
                user: data.user
            },
            query: {
                page: data.page,
                perPage: data.perPage
            },
            errors: {
                401: &apos;Unauthenticated&apos;,
                422: &apos;Validation error&apos;
            }
        });
    }
    /**
     * Revoke a given token
     * @param data The data for the request.
     * @param data.token The token ID
     * @returns void No content
     * @throws ApiError
     */
    public static deleteApiUsersTokensByToken(data: DeleteApiUsersTokensByTokenData): CancelablePromise&lt;DeleteApiUsersTokensByTokenResponse&gt; {
        return __request(OpenAPI, {
            method: &apos;DELETE&apos;,
            url: &apos;/api/users/tokens/{token}&apos;,
            path: {
                token: data.token
            },
            errors: {
                401: &apos;Unauthenticated&apos;,
                404: &apos;Not found&apos;
            }
        });
    }
}
export class WorkloadService {
    /**
     * Get the current queue workload for the application
     * @returns unknown
     * @throws ApiError
     */
    public static getHorizonApiWorkload(): CancelablePromise&lt;GetHorizonApiWorkloadResponse&gt; {
        return __request(OpenAPI, {
            method: &apos;GET&apos;,
            url: &apos;/-/horizon/api/workload&apos;
        });
    }
}</file><file path="resources/app/api-client/requests/schemas.gen.ts">// This file is auto-generated by @hey-api/openapi-ts
export const $AlbumResource = {
    type: &apos;object&apos;,
    properties: {
        title: {
            type: &apos;string&apos;
        },
        slug: {
            type: &apos;string&apos;
        },
        year: {
            type: [&apos;integer&apos;, &apos;null&apos;]
        },
        createdAt: {
            type: [&apos;string&apos;, &apos;null&apos;],
            format: &apos;date-time&apos;
        },
        updatedAt: {
            type: [&apos;string&apos;, &apos;null&apos;],
            format: &apos;date-time&apos;
        },
        cover: {
            description: &apos;Cover relation&apos;,
            &apos;$ref&apos;: &apos;#/components/schemas/ImageResource&apos;
        },
        artists: {
            type: &apos;array&apos;,
            description: &apos;Album artists relation&apos;,
            items: {
                &apos;$ref&apos;: &apos;#/components/schemas/ArtistResource&apos;
            }
        },
        songs: {
            type: &apos;array&apos;,
            description: &apos;Songs relation&apos;,
            items: {
                &apos;$ref&apos;: &apos;#/components/schemas/SongResource&apos;
            }
        },
        genres: {
            type: &apos;array&apos;,
            items: {
                type: &apos;object&apos;,
                properties: {
                    slug: {
                        type: &apos;string&apos;
                    },
                    name: {
                        type: &apos;string&apos;
                    }
                },
                required: [&apos;slug&apos;, &apos;name&apos;]
            }
        }
    },
    required: [&apos;title&apos;, &apos;slug&apos;, &apos;year&apos;, &apos;createdAt&apos;, &apos;updatedAt&apos;],
    title: &apos;AlbumResource&apos;
} as const;
export const $AlbumWithoutSongsResource = {
    type: &apos;object&apos;,
    properties: {
        title: {
            type: &apos;string&apos;
        },
        slug: {
            type: &apos;string&apos;
        },
        year: {
            type: [&apos;integer&apos;, &apos;null&apos;]
        },
        createdAt: {
            type: [&apos;string&apos;, &apos;null&apos;],
            format: &apos;date-time&apos;
        },
        updatedAt: {
            type: [&apos;string&apos;, &apos;null&apos;],
            format: &apos;date-time&apos;
        },
        cover: {
            description: &apos;Cover relation&apos;,
            &apos;$ref&apos;: &apos;#/components/schemas/ImageResource&apos;
        },
        artists: {
            description: &apos;Album artist relation&apos;,
            &apos;$ref&apos;: &apos;#/components/schemas/ArtistResource&apos;
        }
    },
    required: [&apos;title&apos;, &apos;slug&apos;, &apos;year&apos;, &apos;createdAt&apos;, &apos;updatedAt&apos;],
    title: &apos;AlbumWithoutSongsResource&apos;
} as const;
export const $ArtistResource = {
    type: &apos;object&apos;,
    properties: {
        name: {
            type: &apos;string&apos;
        },
        slug: {
            type: &apos;string&apos;
        },
        createdAt: {
            type: [&apos;string&apos;, &apos;null&apos;],
            format: &apos;date-time&apos;
        },
        updatedAt: {
            type: [&apos;string&apos;, &apos;null&apos;],
            format: &apos;date-time&apos;
        },
        portrait: {
            description: &apos;Portrait relation&apos;,
            &apos;$ref&apos;: &apos;#/components/schemas/ImageResource&apos;
        }
    },
    required: [&apos;name&apos;, &apos;slug&apos;, &apos;createdAt&apos;, &apos;updatedAt&apos;],
    title: &apos;ArtistResource&apos;
} as const;
export const $AuthenticateUsingPasskeyRequest = {
    type: &apos;object&apos;,
    properties: {
        start_authentication_response: {
            type: &apos;string&apos;
        }
    },
    required: [&apos;start_authentication_response&apos;],
    title: &apos;AuthenticateUsingPasskeyRequest&apos;
} as const;
export const $CreateLibraryRequest = {
    type: &apos;object&apos;,
    properties: {
        name: {
            type: &apos;string&apos;,
            maxLength: 100
        },
        path: {
            type: &apos;string&apos;,
            maxLength: 1000
        },
        type: {
            &apos;$ref&apos;: &apos;#/components/schemas/LibraryType&apos;
        },
        order: {
            type: &apos;integer&apos;
        }
    },
    required: [&apos;name&apos;, &apos;path&apos;, &apos;type&apos;, &apos;order&apos;],
    title: &apos;CreateLibraryRequest&apos;
} as const;
export const $CreatePlaylistRequest = {
    type: &apos;object&apos;,
    properties: {
        name: {
            type: &apos;string&apos;,
            maxLength: 255
        },
        description: {
            type: [&apos;string&apos;, &apos;null&apos;]
        },
        is_public: {
            type: &apos;boolean&apos;
        }
    },
    required: [&apos;name&apos;],
    title: &apos;CreatePlaylistRequest&apos;
} as const;
export const $CreateSmartPlaylistRequest = {
    type: &apos;object&apos;,
    properties: {
        name: {
            type: &apos;string&apos;,
            maxLength: 255
        },
        description: {
            type: [&apos;string&apos;, &apos;null&apos;]
        },
        is_public: {
            type: &apos;boolean&apos;
        },
        rules: {
            type: &apos;array&apos;,
            items: {
                type: &apos;array&apos;,
                items: {
                    type: &apos;object&apos;,
                    properties: {
                        field: {
                            type: &apos;string&apos;
                        },
                        operator: {
                            type: &apos;string&apos;
                        },
                        value: {
                            type: &apos;string&apos;
                        }
                    },
                    required: [&apos;field&apos;, &apos;operator&apos;, &apos;value&apos;]
                }
            }
        }
    },
    required: [&apos;name&apos;, &apos;rules&apos;],
    title: &apos;CreateSmartPlaylistRequest&apos;
} as const;
export const $CreateUserRequest = {
    type: &apos;object&apos;,
    properties: {
        name: {
            type: &apos;string&apos;,
            maxLength: 160
        },
        email: {
            type: &apos;string&apos;,
            format: &apos;email&apos;,
            maxLength: 254
        },
        password: {
            type: &apos;string&apos;,
            minLength: 1,
            maxLength: 100
        }
    },
    required: [&apos;name&apos;, &apos;email&apos;, &apos;password&apos;],
    title: &apos;CreateUserRequest&apos;
} as const;
export const $ForgotPasswordRequest = {
    type: &apos;object&apos;,
    properties: {
        email: {
            type: &apos;string&apos;,
            format: &apos;email&apos;
        },
        url: {
            type: &apos;string&apos;
        }
    },
    required: [&apos;email&apos;],
    title: &apos;ForgotPasswordRequest&apos;
} as const;
export const $GenreResource = {
    type: &apos;object&apos;,
    properties: {
        name: {
            type: &apos;string&apos;
        },
        slug: {
            type: &apos;string&apos;
        },
        createdAt: {
            type: [&apos;string&apos;, &apos;null&apos;],
            format: &apos;date-time&apos;
        },
        updatedAt: {
            type: [&apos;string&apos;, &apos;null&apos;],
            format: &apos;date-time&apos;
        },
        songs: {
            type: &apos;array&apos;,
            description: &apos;Songs relation&apos;,
            items: {
                &apos;$ref&apos;: &apos;#/components/schemas/SongResource&apos;
            }
        }
    },
    required: [&apos;name&apos;, &apos;slug&apos;, &apos;createdAt&apos;, &apos;updatedAt&apos;],
    title: &apos;GenreResource&apos;
} as const;
export const $ImageResource = {
    type: &apos;object&apos;,
    properties: {
        public_id: {
            type: &apos;string&apos;
        },
        path: {
            type: &apos;string&apos;
        },
        extension: {
            type: &apos;string&apos;
        },
        size: {
            type: &apos;integer&apos;
        },
        mime_type: {
            type: &apos;string&apos;
        },
        width: {
            type: &apos;integer&apos;
        },
        height: {
            type: &apos;integer&apos;
        },
        blurhash: {
            type: &apos;string&apos;
        },
        url: {
            type: &apos;string&apos;
        }
    },
    required: [&apos;public_id&apos;, &apos;path&apos;, &apos;extension&apos;, &apos;size&apos;, &apos;mime_type&apos;, &apos;width&apos;, &apos;height&apos;, &apos;blurhash&apos;, &apos;url&apos;],
    title: &apos;ImageResource&apos;
} as const;
export const $LevelCountResource = {
    type: &apos;object&apos;,
    properties: {
        level: {
            type: &apos;string&apos;
        },
        level_name: {
            type: &apos;string&apos;
        },
        level_class: {
            type: &apos;string&apos;
        },
        count: {
            type: &apos;string&apos;
        },
        selected: {
            type: &apos;string&apos;
        }
    },
    required: [&apos;level&apos;, &apos;level_name&apos;, &apos;level_class&apos;, &apos;count&apos;, &apos;selected&apos;],
    title: &apos;LevelCountResource&apos;
} as const;
export const $LibraryResource = {
    type: &apos;object&apos;,
    properties: {
        name: {
            type: &apos;string&apos;
        },
        slug: {
            type: &apos;string&apos;
        },
        path: {
            type: &apos;string&apos;
        },
        type: {
            type: &apos;string&apos;
        },
        order: {
            type: &apos;integer&apos;
        },
        lastScan: {
            type: [&apos;string&apos;, &apos;null&apos;]
        },
        createdAt: {
            type: [&apos;string&apos;, &apos;null&apos;],
            format: &apos;date-time&apos;
        },
        updatedAt: {
            type: [&apos;string&apos;, &apos;null&apos;],
            format: &apos;date-time&apos;
        }
    },
    required: [&apos;name&apos;, &apos;slug&apos;, &apos;path&apos;, &apos;type&apos;, &apos;order&apos;, &apos;lastScan&apos;, &apos;createdAt&apos;, &apos;updatedAt&apos;],
    title: &apos;LibraryResource&apos;
} as const;
export const $LibraryType = {
    type: &apos;string&apos;,
    enum: [&apos;music&apos;, &apos;podcast&apos;, &apos;audiobook&apos;, &apos;movie&apos;, &apos;tv_show&apos;],
    title: &apos;LibraryType&apos;
} as const;
export const $LogFileResource = {
    type: &apos;object&apos;,
    properties: {
        type: {
            type: &apos;object&apos;,
            properties: {
                value: {
                    type: &apos;string&apos;
                },
                name: {
                    type: &apos;string&apos;
                }
            },
            required: [&apos;value&apos;, &apos;name&apos;]
        },
        identifier: {
            type: &apos;string&apos;
        },
        sub_folder: {
            type: &apos;string&apos;
        },
        sub_folder_identifier: {
            type: &apos;string&apos;
        },
        path: {
            type: &apos;string&apos;
        },
        name: {
            type: &apos;string&apos;
        },
        size: {
            type: &apos;string&apos;
        },
        size_in_mb: {
            type: &apos;string&apos;
        },
        size_formatted: {
            type: &apos;string&apos;
        },
        download_url: {
            type: &apos;string&apos;
        },
        earliest_timestamp: {
            type: &apos;string&apos;
        },
        latest_timestamp: {
            type: &apos;string&apos;
        },
        can_download: {
            type: &apos;string&apos;
        },
        can_delete: {
            type: &apos;string&apos;
        },
        loading: {
            type: &apos;boolean&apos;
        },
        selected_for_deletion: {
            type: &apos;boolean&apos;,
            description: &apos;helper for frontend&apos;
        }
    },
    required: [&apos;type&apos;, &apos;identifier&apos;, &apos;sub_folder&apos;, &apos;sub_folder_identifier&apos;, &apos;path&apos;, &apos;name&apos;, &apos;size&apos;, &apos;size_in_mb&apos;, &apos;size_formatted&apos;, &apos;download_url&apos;, &apos;earliest_timestamp&apos;, &apos;latest_timestamp&apos;, &apos;can_download&apos;, &apos;can_delete&apos;, &apos;loading&apos;, &apos;selected_for_deletion&apos;],
    title: &apos;LogFileResource&apos;
} as const;
export const $LogFolderResource = {
    type: &apos;object&apos;,
    properties: {
        identifier: {
            type: &apos;string&apos;
        },
        path: {
            type: &apos;string&apos;
        },
        clean_path: {
            type: &apos;string&apos;
        },
        is_root: {
            type: &apos;string&apos;
        },
        earliest_timestamp: {
            type: &apos;string&apos;
        },
        latest_timestamp: {
            type: &apos;string&apos;
        },
        download_url: {
            type: &apos;string&apos;
        },
        files: {
            type: &apos;array&apos;,
            items: {
                &apos;$ref&apos;: &apos;#/components/schemas/LogFileResource&apos;
            }
        },
        can_download: {
            type: &apos;string&apos;
        },
        can_delete: {
            type: &apos;string&apos;
        },
        loading: {
            type: &apos;boolean&apos;
        }
    },
    required: [&apos;identifier&apos;, &apos;path&apos;, &apos;clean_path&apos;, &apos;is_root&apos;, &apos;earliest_timestamp&apos;, &apos;latest_timestamp&apos;, &apos;download_url&apos;, &apos;files&apos;, &apos;can_download&apos;, &apos;can_delete&apos;, &apos;loading&apos;],
    title: &apos;LogFolderResource&apos;
} as const;
export const $LogResource = {
    type: &apos;object&apos;,
    properties: {
        index: {
            type: &apos;string&apos;
        },
        file_identifier: {
            type: &apos;string&apos;
        },
        file_position: {
            type: &apos;string&apos;
        },
        level: {
            type: &apos;string&apos;
        },
        level_name: {
            type: &apos;string&apos;
        },
        level_class: {
            type: &apos;string&apos;
        },
        datetime: {
            type: &apos;string&apos;
        },
        time: {
            type: &apos;string&apos;
        },
        message: {
            type: &apos;string&apos;
        },
        context: {
            type: &apos;string&apos;
        },
        extra: {
            type: &apos;string&apos;
        },
        url: {
            type: &apos;string&apos;
        }
    },
    required: [&apos;index&apos;, &apos;file_identifier&apos;, &apos;file_position&apos;, &apos;level&apos;, &apos;level_name&apos;, &apos;level_class&apos;, &apos;datetime&apos;, &apos;time&apos;, &apos;message&apos;, &apos;context&apos;, &apos;extra&apos;, &apos;url&apos;],
    title: &apos;LogResource&apos;
} as const;
export const $LogViewerHostResource = {
    type: &apos;object&apos;,
    properties: {
        identifier: {
            type: &apos;string&apos;
        },
        name: {
            type: &apos;string&apos;
        },
        host: {
            type: &apos;string&apos;
        },
        headers: {
            type: &apos;string&apos;
        },
        auth: {
            type: &apos;string&apos;
        },
        is_remote: {
            type: &apos;string&apos;
        }
    },
    required: [&apos;identifier&apos;, &apos;name&apos;, &apos;host&apos;, &apos;headers&apos;, &apos;auth&apos;, &apos;is_remote&apos;],
    title: &apos;LogViewerHostResource&apos;
} as const;
export const $LoginRequest = {
    type: &apos;object&apos;,
    properties: {
        email: {
            type: &apos;string&apos;,
            format: &apos;email&apos;
        },
        password: {
            type: &apos;string&apos;
        },
        remember: {
            type: &apos;boolean&apos;
        }
    },
    required: [&apos;email&apos;, &apos;password&apos;],
    title: &apos;LoginRequest&apos;
} as const;
export const $LogoutRequest = {
    type: &apos;object&apos;,
    properties: {
        refresh_token: {
            type: &apos;string&apos;
        }
    },
    title: &apos;LogoutRequest&apos;
} as const;
export const $MovieResource = {
    type: &apos;object&apos;,
    properties: {
        title: {
            type: &apos;string&apos;
        },
        slug: {
            type: &apos;string&apos;
        },
        year: {
            type: [&apos;integer&apos;, &apos;null&apos;]
        },
        summary: {
            type: [&apos;string&apos;, &apos;null&apos;]
        },
        created_at: {
            type: [&apos;string&apos;, &apos;null&apos;],
            format: &apos;date-time&apos;
        },
        updated_at: {
            type: [&apos;string&apos;, &apos;null&apos;],
            format: &apos;date-time&apos;
        },
        videos_count: {
            type: &apos;string&apos;
        }
    },
    required: [&apos;title&apos;, &apos;slug&apos;, &apos;year&apos;, &apos;summary&apos;, &apos;created_at&apos;, &apos;updated_at&apos;],
    title: &apos;MovieResource&apos;
} as const;
export const $NewAccessTokenResource = {
    type: &apos;object&apos;,
    properties: {
        token: {
            type: &apos;string&apos;
        },
        abilities: {
            type: &apos;string&apos;
        },
        expiresAt: {
            type: &apos;string&apos;
        }
    },
    required: [&apos;token&apos;, &apos;abilities&apos;, &apos;expiresAt&apos;],
    title: &apos;NewAccessTokenResource&apos;
} as const;
export const $PersonalAccessTokenViewResource = {
    type: &apos;object&apos;,
    properties: {
        id: {
            type: &apos;integer&apos;
        },
        name: {
            type: &apos;string&apos;
        },
        abilities: {
            type: [&apos;array&apos;, &apos;null&apos;],
            items: {
                type: &apos;string&apos;
            }
        },
        userAgent: {
            type: [&apos;string&apos;, &apos;null&apos;]
        },
        clientName: {
            type: [&apos;string&apos;, &apos;null&apos;]
        },
        clientVersion: {
            type: [&apos;string&apos;, &apos;null&apos;]
        },
        clientType: {
            type: [&apos;string&apos;, &apos;null&apos;]
        },
        deviceOperatingSystem: {
            type: [&apos;string&apos;, &apos;null&apos;]
        },
        deviceName: {
            type: [&apos;string&apos;, &apos;null&apos;]
        },
        lastUsedAt: {
            type: [&apos;string&apos;, &apos;null&apos;],
            format: &apos;date-time&apos;
        },
        expiresAt: {
            type: [&apos;string&apos;, &apos;null&apos;]
        },
        createdAt: {
            type: [&apos;string&apos;, &apos;null&apos;],
            format: &apos;date-time&apos;
        },
        updatedAt: {
            type: [&apos;string&apos;, &apos;null&apos;],
            format: &apos;date-time&apos;
        }
    },
    required: [&apos;id&apos;, &apos;name&apos;, &apos;abilities&apos;, &apos;userAgent&apos;, &apos;clientName&apos;, &apos;clientVersion&apos;, &apos;clientType&apos;, &apos;deviceOperatingSystem&apos;, &apos;deviceName&apos;, &apos;lastUsedAt&apos;, &apos;expiresAt&apos;, &apos;createdAt&apos;, &apos;updatedAt&apos;],
    title: &apos;PersonalAccessTokenViewResource&apos;
} as const;
export const $PlaylistResource = {
    type: &apos;object&apos;,
    properties: {
        id: {
            type: &apos;string&apos;
        },
        name: {
            type: &apos;string&apos;
        },
        description: {
            type: [&apos;string&apos;, &apos;null&apos;]
        },
        isPublic: {
            type: &apos;string&apos;
        },
        isCollaborative: {
            type: &apos;string&apos;
        },
        isSmart: {
            type: &apos;string&apos;
        },
        smartRules: {
            type: [&apos;array&apos;, &apos;null&apos;],
            items: {}
        },
        cover: {
            &apos;$ref&apos;: &apos;#/components/schemas/ImageResource&apos;
        },
        createdAt: {
            type: [&apos;string&apos;, &apos;null&apos;],
            format: &apos;date-time&apos;
        },
        updatedAt: {
            type: [&apos;string&apos;, &apos;null&apos;],
            format: &apos;date-time&apos;
        },
        songsCount: {
            type: &apos;integer&apos;
        },
        statistics: {
            type: &apos;object&apos;,
            properties: {
                views: {
                    type: &apos;integer&apos;
                },
                plays: {
                    type: &apos;integer&apos;
                },
                shares: {
                    type: &apos;integer&apos;
                },
                favorites: {
                    type: &apos;integer&apos;
                }
            },
            required: [&apos;views&apos;, &apos;plays&apos;, &apos;shares&apos;, &apos;favorites&apos;]
        },
        songs: {
            type: &apos;array&apos;,
            items: {
                &apos;$ref&apos;: &apos;#/components/schemas/SongResource&apos;
            }
        },
        owner: {
            type: &apos;object&apos;,
            properties: {
                email: {
                    type: &apos;string&apos;
                },
                name: {
                    type: &apos;string&apos;
                }
            },
            required: [&apos;email&apos;, &apos;name&apos;]
        },
        collaborators: {
            type: &apos;string&apos;
        }
    },
    required: [&apos;id&apos;, &apos;name&apos;, &apos;description&apos;, &apos;isPublic&apos;, &apos;isCollaborative&apos;, &apos;isSmart&apos;, &apos;createdAt&apos;, &apos;updatedAt&apos;],
    title: &apos;PlaylistResource&apos;
} as const;
export const $PlaylistStatistic = {
    type: &apos;object&apos;,
    properties: {
        id: {
            type: &apos;integer&apos;
        },
        playlist_id: {
            type: &apos;integer&apos;
        },
        views: {
            type: &apos;integer&apos;
        },
        plays: {
            type: &apos;integer&apos;
        },
        shares: {
            type: &apos;integer&apos;
        },
        favorites: {
            type: &apos;integer&apos;
        },
        created_at: {
            type: [&apos;string&apos;, &apos;null&apos;],
            format: &apos;date-time&apos;
        },
        updated_at: {
            type: [&apos;string&apos;, &apos;null&apos;],
            format: &apos;date-time&apos;
        }
    },
    required: [&apos;id&apos;, &apos;playlist_id&apos;, &apos;views&apos;, &apos;plays&apos;, &apos;shares&apos;, &apos;favorites&apos;, &apos;created_at&apos;, &apos;updated_at&apos;],
    title: &apos;PlaylistStatistic&apos;
} as const;
export const $QueueMonitorResource = {
    type: &apos;object&apos;,
    properties: {
        id: {
            type: &apos;integer&apos;
        },
        job_id: {
            type: &apos;string&apos;
        },
        name: {
            type: [&apos;string&apos;, &apos;null&apos;]
        },
        queue: {
            type: [&apos;string&apos;, &apos;null&apos;]
        },
        started_at: {
            type: [&apos;string&apos;, &apos;null&apos;],
            format: &apos;date-time&apos;
        },
        started_at_exact: {
            type: [&apos;string&apos;, &apos;null&apos;]
        },
        finished_at: {
            type: [&apos;string&apos;, &apos;null&apos;],
            format: &apos;date-time&apos;
        },
        finished_at_exact: {
            type: [&apos;string&apos;, &apos;null&apos;]
        },
        attempt: {
            type: &apos;integer&apos;
        },
        progress: {
            type: [&apos;integer&apos;, &apos;null&apos;]
        },
        exception: {
            type: [&apos;array&apos;, &apos;null&apos;],
            items: {}
        },
        exception_class: {
            type: [&apos;string&apos;, &apos;null&apos;]
        },
        data: {
            type: [&apos;string&apos;, &apos;null&apos;]
        },
        status: {
            type: &apos;string&apos;
        },
        job_uuid: {
            type: [&apos;string&apos;, &apos;null&apos;]
        },
        retried: {
            type: &apos;boolean&apos;
        },
        queued_at: {
            type: [&apos;string&apos;, &apos;null&apos;],
            format: &apos;date-time&apos;
        }
    },
    required: [&apos;id&apos;, &apos;job_id&apos;, &apos;name&apos;, &apos;queue&apos;, &apos;started_at&apos;, &apos;started_at_exact&apos;, &apos;finished_at&apos;, &apos;finished_at_exact&apos;, &apos;attempt&apos;, &apos;progress&apos;, &apos;exception&apos;, &apos;exception_class&apos;, &apos;data&apos;, &apos;status&apos;, &apos;job_uuid&apos;, &apos;retried&apos;, &apos;queued_at&apos;],
    title: &apos;QueueMonitorResource&apos;
} as const;
export const $RegisterRequest = {
    type: &apos;object&apos;,
    properties: {
        name: {
            type: &apos;string&apos;,
            maxLength: 255
        },
        email: {
            type: &apos;string&apos;,
            format: &apos;email&apos;,
            maxLength: 255
        },
        password: {
            type: &apos;string&apos;
        },
        password_confirmation: {
            type: &apos;string&apos;
        }
    },
    required: [&apos;name&apos;, &apos;email&apos;, &apos;password&apos;, &apos;password_confirmation&apos;],
    title: &apos;RegisterRequest&apos;
} as const;
export const $ResetPasswordRequest = {
    type: &apos;object&apos;,
    properties: {
        email: {
            type: &apos;string&apos;,
            format: &apos;email&apos;
        },
        token: {
            type: &apos;string&apos;
        },
        password: {
            type: &apos;string&apos;
        },
        password_confirmation: {
            type: &apos;string&apos;
        }
    },
    required: [&apos;email&apos;, &apos;token&apos;, &apos;password&apos;, &apos;password_confirmation&apos;],
    title: &apos;ResetPasswordRequest&apos;
} as const;
export const $RetryJobRequest = {
    type: &apos;object&apos;,
    properties: {
        id: {
            type: &apos;integer&apos;
        }
    },
    title: &apos;RetryJobRequest&apos;
} as const;
export const $SongResource = {
    type: &apos;object&apos;,
    properties: {
        public_id: {
            type: &apos;string&apos;
        },
        title: {
            type: &apos;string&apos;
        },
        year: {
            type: [&apos;integer&apos;, &apos;null&apos;]
        },
        comment: {
            type: [&apos;string&apos;, &apos;null&apos;]
        },
        disc: {
            type: [&apos;integer&apos;, &apos;null&apos;]
        },
        length: {
            type: [&apos;string&apos;, &apos;null&apos;]
        },
        durationHuman: {
            type: &apos;string&apos;
        },
        lyrics: {
            type: [&apos;string&apos;, &apos;null&apos;]
        },
        lyricsExist: {
            type: &apos;boolean&apos;
        },
        modifiedTime: {
            type: [&apos;integer&apos;, &apos;null&apos;]
        },
        path: {
            type: &apos;string&apos;
        },
        track: {
            type: [&apos;integer&apos;, &apos;null&apos;]
        },
        size: {
            type: &apos;integer&apos;
        },
        sizeHuman: {
            type: &apos;string&apos;
        },
        mimeType: {
            type: &apos;string&apos;
        },
        hash: {
            type: [&apos;string&apos;, &apos;null&apos;]
        },
        streamUrl: {
            type: &apos;string&apos;
        },
        createdAt: {
            type: [&apos;string&apos;, &apos;null&apos;],
            format: &apos;date-time&apos;
        },
        updatedAt: {
            type: [&apos;string&apos;, &apos;null&apos;],
            format: &apos;date-time&apos;
        },
        album: {
            &apos;$ref&apos;: &apos;#/components/schemas/AlbumWithoutSongsResource&apos;
        },
        artists: {
            type: &apos;array&apos;,
            items: {
                &apos;$ref&apos;: &apos;#/components/schemas/ArtistResource&apos;
            }
        }
    },
    required: [&apos;public_id&apos;, &apos;title&apos;, &apos;year&apos;, &apos;comment&apos;, &apos;disc&apos;, &apos;length&apos;, &apos;durationHuman&apos;, &apos;lyrics&apos;, &apos;lyricsExist&apos;, &apos;modifiedTime&apos;, &apos;path&apos;, &apos;track&apos;, &apos;size&apos;, &apos;sizeHuman&apos;, &apos;mimeType&apos;, &apos;hash&apos;, &apos;streamUrl&apos;, &apos;createdAt&apos;, &apos;updatedAt&apos;],
    title: &apos;SongResource&apos;
} as const;
export const $StorePasskeyRequest = {
    type: &apos;object&apos;,
    properties: {
        name: {
            type: &apos;string&apos;,
            maxLength: 255
        },
        passkey: {
            type: &apos;string&apos;
        }
    },
    required: [&apos;name&apos;, &apos;passkey&apos;],
    title: &apos;StorePasskeyRequest&apos;
} as const;
export const $UpdateGenreRequest = {
    type: &apos;object&apos;,
    properties: {
        name: {
            type: &apos;string&apos;,
            minLength: 1,
            maxLength: 255
        }
    },
    required: [&apos;name&apos;],
    title: &apos;UpdateGenreRequest&apos;
} as const;
export const $UpdateLibraryRequest = {
    type: &apos;object&apos;,
    properties: {
        name: {
            type: &apos;string&apos;,
            maxLength: 100
        },
        path: {
            type: &apos;string&apos;,
            maxLength: 1000
        },
        type: {
            &apos;$ref&apos;: &apos;#/components/schemas/LibraryType&apos;
        },
        order: {
            type: &apos;integer&apos;
        }
    },
    title: &apos;UpdateLibraryRequest&apos;
} as const;
export const $UpdatePlaylistRequest = {
    type: &apos;object&apos;,
    properties: {
        name: {
            type: &apos;string&apos;,
            maxLength: 255
        },
        description: {
            type: [&apos;string&apos;, &apos;null&apos;]
        },
        is_public: {
            type: &apos;boolean&apos;
        }
    },
    title: &apos;UpdatePlaylistRequest&apos;
} as const;
export const $UpdateSmartPlaylistRulesRequest = {
    type: &apos;object&apos;,
    properties: {
        rules: {
            type: &apos;array&apos;,
            items: {
                type: &apos;array&apos;,
                items: {
                    type: &apos;object&apos;,
                    properties: {
                        field: {
                            type: &apos;string&apos;
                        },
                        operator: {
                            type: &apos;string&apos;
                        },
                        value: {
                            type: &apos;string&apos;
                        }
                    },
                    required: [&apos;field&apos;, &apos;operator&apos;, &apos;value&apos;]
                }
            }
        }
    },
    required: [&apos;rules&apos;],
    title: &apos;UpdateSmartPlaylistRulesRequest&apos;
} as const;
export const $UpdateUserRequest = {
    type: &apos;object&apos;,
    properties: {
        email: {
            type: &apos;string&apos;,
            format: &apos;email&apos;,
            maxLength: 254
        },
        password: {
            type: &apos;string&apos;,
            maxLength: 100
        }
    },
    title: &apos;UpdateUserRequest&apos;
} as const;
export const $UserResource = {
    type: &apos;object&apos;,
    properties: {
        name: {
            type: &apos;string&apos;
        },
        email: {
            type: &apos;string&apos;
        },
        isAdmin: {
            type: &apos;boolean&apos;
        },
        createdAt: {
            type: [&apos;string&apos;, &apos;null&apos;],
            format: &apos;date-time&apos;
        },
        updatedAt: {
            type: [&apos;string&apos;, &apos;null&apos;],
            format: &apos;date-time&apos;
        }
    },
    required: [&apos;name&apos;, &apos;email&apos;, &apos;isAdmin&apos;, &apos;createdAt&apos;, &apos;updatedAt&apos;],
    title: &apos;UserResource&apos;
} as const;</file><file path="resources/app/api-client/requests/types.gen.ts">// This file is auto-generated by @hey-api/openapi-ts
export type AlbumResource = {
    title: string;
    slug: string;
    year: number | null;
    createdAt: string | null;
    updatedAt: string | null;
    /**
     * Cover relation
     */
    cover?: ImageResource;
    /**
     * Album artists relation
     */
    artists?: Array&lt;ArtistResource&gt;;
    /**
     * Songs relation
     */
    songs?: Array&lt;SongResource&gt;;
    genres?: Array&lt;{
        slug: string;
        name: string;
    }&gt;;
};
export type AlbumWithoutSongsResource = {
    title: string;
    slug: string;
    year: number | null;
    createdAt: string | null;
    updatedAt: string | null;
    /**
     * Cover relation
     */
    cover?: ImageResource;
    /**
     * Album artist relation
     */
    artists?: ArtistResource;
};
export type ArtistResource = {
    name: string;
    slug: string;
    createdAt: string | null;
    updatedAt: string | null;
    /**
     * Portrait relation
     */
    portrait?: ImageResource;
};
export type AuthenticateUsingPasskeyRequest = {
    start_authentication_response: string;
};
export type CreateLibraryRequest = {
    name: string;
    path: string;
    type: LibraryType;
    order: number;
};
export type CreatePlaylistRequest = {
    name: string;
    description?: string | null;
    is_public?: boolean;
};
export type CreateSmartPlaylistRequest = {
    name: string;
    description?: string | null;
    is_public?: boolean;
    rules: Array&lt;Array&lt;{
        field: string;
        operator: string;
        value: string;
    }&gt;&gt;;
};
export type CreateUserRequest = {
    name: string;
    email: string;
    password: string;
};
export type ForgotPasswordRequest = {
    email: string;
    url?: string;
};
export type GenreResource = {
    name: string;
    slug: string;
    createdAt: string | null;
    updatedAt: string | null;
    /**
     * Songs relation
     */
    songs?: Array&lt;SongResource&gt;;
};
export type ImageResource = {
    public_id: string;
    path: string;
    extension: string;
    size: number;
    mime_type: string;
    width: number;
    height: number;
    blurhash: string;
    url: string;
};
export type LevelCountResource = {
    level: string;
    level_name: string;
    level_class: string;
    count: string;
    selected: string;
};
export type LibraryResource = {
    name: string;
    slug: string;
    path: string;
    type: string;
    order: number;
    lastScan: string | null;
    createdAt: string | null;
    updatedAt: string | null;
};
export type LibraryType = &apos;music&apos; | &apos;podcast&apos; | &apos;audiobook&apos; | &apos;movie&apos; | &apos;tv_show&apos;;
export type LogFileResource = {
    type: {
        value: string;
        name: string;
    };
    identifier: string;
    sub_folder: string;
    sub_folder_identifier: string;
    path: string;
    name: string;
    size: string;
    size_in_mb: string;
    size_formatted: string;
    download_url: string;
    earliest_timestamp: string;
    latest_timestamp: string;
    can_download: string;
    can_delete: string;
    loading: boolean;
    /**
     * helper for frontend
     */
    selected_for_deletion: boolean;
};
export type LogFolderResource = {
    identifier: string;
    path: string;
    clean_path: string;
    is_root: string;
    earliest_timestamp: string;
    latest_timestamp: string;
    download_url: string;
    files: Array&lt;LogFileResource&gt;;
    can_download: string;
    can_delete: string;
    loading: boolean;
};
export type LogResource = {
    index: string;
    file_identifier: string;
    file_position: string;
    level: string;
    level_name: string;
    level_class: string;
    datetime: string;
    time: string;
    message: string;
    context: string;
    extra: string;
    url: string;
};
export type LogViewerHostResource = {
    identifier: string;
    name: string;
    host: string;
    headers: string;
    auth: string;
    is_remote: string;
};
export type LoginRequest = {
    email: string;
    password: string;
    remember?: boolean;
};
export type LogoutRequest = {
    refresh_token?: string;
};
export type MovieResource = {
    title: string;
    slug: string;
    year: number | null;
    summary: string | null;
    created_at: string | null;
    updated_at: string | null;
    videos_count?: string;
};
export type NewAccessTokenResource = {
    token: string;
    abilities: string;
    expiresAt: string;
};
export type PersonalAccessTokenViewResource = {
    id: number;
    name: string;
    abilities: Array&lt;(string)&gt; | null;
    userAgent: string | null;
    clientName: string | null;
    clientVersion: string | null;
    clientType: string | null;
    deviceOperatingSystem: string | null;
    deviceName: string | null;
    lastUsedAt: string | null;
    expiresAt: string | null;
    createdAt: string | null;
    updatedAt: string | null;
};
export type PlaylistResource = {
    id: string;
    name: string;
    description: string | null;
    isPublic: string;
    isCollaborative: string;
    isSmart: string;
    smartRules?: Array&lt;unknown&gt; | null;
    cover?: ImageResource;
    createdAt: string | null;
    updatedAt: string | null;
    songsCount?: number;
    statistics?: {
        views: number;
        plays: number;
        shares: number;
        favorites: number;
    };
    songs?: Array&lt;SongResource&gt;;
    owner?: {
        email: string;
        name: string;
    };
    collaborators?: string;
};
export type PlaylistStatistic = {
    id: number;
    playlist_id: number;
    views: number;
    plays: number;
    shares: number;
    favorites: number;
    created_at: string | null;
    updated_at: string | null;
};
export type QueueMonitorResource = {
    id: number;
    job_id: string;
    name: string | null;
    queue: string | null;
    started_at: string | null;
    started_at_exact: string | null;
    finished_at: string | null;
    finished_at_exact: string | null;
    attempt: number;
    progress: number | null;
    exception: Array&lt;unknown&gt; | null;
    exception_class: string | null;
    data: string | null;
    status: string;
    job_uuid: string | null;
    retried: boolean;
    queued_at: string | null;
};
export type RegisterRequest = {
    name: string;
    email: string;
    password: string;
    password_confirmation: string;
};
export type ResetPasswordRequest = {
    email: string;
    token: string;
    password: string;
    password_confirmation: string;
};
export type RetryJobRequest = {
    id?: number;
};
export type SongResource = {
    public_id: string;
    title: string;
    year: number | null;
    comment: string | null;
    disc: number | null;
    length: string | null;
    durationHuman: string;
    lyrics: string | null;
    lyricsExist: boolean;
    modifiedTime: number | null;
    path: string;
    track: number | null;
    size: number;
    sizeHuman: string;
    mimeType: string;
    hash: string | null;
    streamUrl: string;
    createdAt: string | null;
    updatedAt: string | null;
    album?: AlbumWithoutSongsResource;
    artists?: Array&lt;ArtistResource&gt;;
};
export type StorePasskeyRequest = {
    name: string;
    passkey: string;
};
export type UpdateGenreRequest = {
    name: string;
};
export type UpdateLibraryRequest = {
    name?: string;
    path?: string;
    type?: LibraryType;
    order?: number;
};
export type UpdatePlaylistRequest = {
    name?: string;
    description?: string | null;
    is_public?: boolean;
};
export type UpdateSmartPlaylistRulesRequest = {
    rules: Array&lt;Array&lt;{
        field: string;
        operator: string;
        value: string;
    }&gt;&gt;;
};
export type UpdateUserRequest = {
    email?: string;
    password?: string;
};
export type UserResource = {
    name: string;
    email: string;
    isAdmin: boolean;
    createdAt: string | null;
    updatedAt: string | null;
};
export type GetApiLibrariesByLibraryAlbumsData = {
    fields?: string;
    genres?: string;
    /**
     * The library slug
     */
    library: string;
    limit?: number;
    page?: number;
    relations?: string;
};
export type GetApiLibrariesByLibraryAlbumsResponse = {
    data: Array&lt;AlbumResource&gt;;
    meta: {
        /**
         * Total number of items being paginated.
         */
        total: number;
        /**
         * The number of items for the current page
         */
        count: number;
        /**
         * The number of items per page
         */
        limit: number;
        /**
         * The number of current page
         */
        currentPage: number;
        /**
         * The number of next page
         */
        nextPage: number;
        /**
         * The number of last page
         */
        lastPage: number;
    };
    links: {
        first: string | null;
        last: string | null;
        prev: string | null;
        next: string | null;
    };
};
export type GetApiLibrariesByLibraryAlbumsByAlbumData = {
    /**
     * The album slug
     */
    album: string;
    /**
     * The library slug
     */
    library: string;
};
export type GetApiLibrariesByLibraryAlbumsByAlbumResponse = AlbumResource;
export type GetApiLibrariesByLibraryArtistsData = {
    fields?: string;
    genres?: string;
    library: string;
    limit?: number;
    page?: number;
    relations?: string;
};
export type GetApiLibrariesByLibraryArtistsResponse = {
    data: Array&lt;ArtistResource&gt;;
    meta: {
        /**
         * Total number of items being paginated.
         */
        total: number;
        /**
         * The number of items for the current page
         */
        count: number;
        /**
         * The number of items per page
         */
        limit: number;
        /**
         * The number of current page
         */
        currentPage: number;
        /**
         * The number of next page
         */
        nextPage: number;
        /**
         * The number of last page
         */
        lastPage: number;
    };
    links: {
        first: string | null;
        last: string | null;
        prev: string | null;
        next: string | null;
    };
};
export type GetApiLibrariesByLibraryArtistsByArtistData = {
    /**
     * The artist slug
     */
    artist: string;
    library: string;
};
export type GetApiLibrariesByLibraryArtistsByArtistResponse = ArtistResource;
export type PostApiAuthLoginData = {
    requestBody: LoginRequest;
};
export type PostApiAuthLoginResponse = {
    accessToken: NewAccessTokenResource;
    refreshToken: NewAccessTokenResource;
};
export type PostApiAuthRefreshTokenResponse = {
    accessToken: NewAccessTokenResource;
};
export type PostApiAuthStreamTokenResponse = {
    streamToken: NewAccessTokenResource;
};
export type PostApiAuthRegisterData = {
    requestBody: RegisterRequest;
};
export type PostApiAuthRegisterResponse = {
    accessToken: NewAccessTokenResource;
    refreshToken: NewAccessTokenResource;
};
export type PostApiAuthForgotPasswordData = {
    requestBody: ForgotPasswordRequest;
};
export type PostApiAuthForgotPasswordResponse = {
    message: string;
};
export type PostApiAuthResetPasswordData = {
    requestBody: ResetPasswordRequest;
};
export type PostApiAuthResetPasswordResponse = {
    message: &apos;Password reset successfully.&apos;;
};
export type PostApiAuthVerifyByIdByHashData = {
    hash: string;
    id: number;
};
export type PostApiAuthVerifyByIdByHashResponse = UserResource;
export type PostApiAuthLogoutData = {
    requestBody?: LogoutRequest &amp; {
    refreshToken?: string;
};
};
export type PostApiAuthLogoutResponse = void;
export type GetWebauthnPasskeyResponse = {
    challenge: string;
    rpId: string;
    allowCredentials: Array&lt;(string)&gt;;
};
export type PostWebauthnPasskeyData = {
    requestBody: AuthenticateUsingPasskeyRequest;
};
export type PostWebauthnPasskeyResponse = {
    accessToken: NewAccessTokenResource;
    refreshToken: NewAccessTokenResource;
} | string;
export type GetWebauthnPasskeyRegisterResponse = string | {
    [key: string]: unknown;
};
export type PostWebauthnPasskeyRegisterData = {
    requestBody: StorePasskeyRequest;
};
export type PostWebauthnPasskeyRegisterResponse = {
    message: &apos;Passkey successfully stored&apos;;
};
export type GetHorizonApiBatchesResponse = {
    batches: Array&lt;(string)&gt;;
};
export type GetHorizonApiBatchesByIdData = {
    id: string;
};
export type GetHorizonApiBatchesByIdResponse = {
    batch: string;
    failedJobs: string;
};
export type PostHorizonApiBatchesRetryByIdData = {
    id: string;
};
export type PostHorizonApiBatchesRetryByIdResponse = {
    [key: string]: unknown;
};
export type GetHorizonApiJobsCompletedData = {
    startingAt?: string;
};
export type GetHorizonApiJobsCompletedResponse = {
    jobs: string;
    total: string;
};
export type GetHorizonApiStatsResponse = {
    failedJobs: string;
    jobsPerMinute: string;
    pausedMasters: string | 0;
    periods: {
        failedJobs: string;
        recentJobs: string;
    };
    processes: string;
    queueWithMaxRuntime: string;
    queueWithMaxThroughput: string;
    recentJobs: string;
    status: &apos;paused&apos; | &apos;running&apos; | &apos;inactive&apos;;
    wait: string;
};
export type GetHorizonApiJobsFailedData = {
    tag?: string;
};
export type GetHorizonApiJobsFailedResponse = {
    jobs: string;
    total: string;
};
export type GetHorizonApiJobsFailedByIdData = {
    id: string;
};
export type GetHorizonApiJobsFailedByIdResponse = unknown;
export type GetSystemLogViewerApiFilesResponse = Array&lt;LogFileResource&gt;;
export type GetSystemLogViewerApiFilesByFileIdentifierDownloadRequestData = {
    fileIdentifier: string;
};
export type GetSystemLogViewerApiFilesByFileIdentifierDownloadRequestResponse = {
    url: string;
};
export type PostSystemLogViewerApiFilesByFileIdentifierClearCacheData = {
    fileIdentifier: string;
};
export type PostSystemLogViewerApiFilesByFileIdentifierClearCacheResponse = {
    success: boolean;
};
export type DeleteSystemLogViewerApiFilesByFileIdentifierData = {
    fileIdentifier: string;
};
export type DeleteSystemLogViewerApiFilesByFileIdentifierResponse = {
    success: boolean;
};
export type PostSystemLogViewerApiClearCacheAllResponse = {
    success: boolean;
};
export type PostSystemLogViewerApiDeleteMultipleFilesData = {
    requestBody?: {
        files?: string;
    };
};
export type PostSystemLogViewerApiDeleteMultipleFilesResponse = {
    success: boolean;
};
export type GetSystemLogViewerApiFilesByFileIdentifierDownloadData = {
    fileIdentifier: string;
};
export type GetSystemLogViewerApiFilesByFileIdentifierDownloadResponse = string;
export type GetSystemLogViewerApiFoldersData = {
    direction?: string;
};
export type GetSystemLogViewerApiFoldersResponse = Array&lt;LogFolderResource&gt;;
export type GetSystemLogViewerApiFoldersByFolderIdentifierDownloadRequestData = {
    folderIdentifier: string;
};
export type GetSystemLogViewerApiFoldersByFolderIdentifierDownloadRequestResponse = {
    url: string;
};
export type PostSystemLogViewerApiFoldersByFolderIdentifierClearCacheData = {
    folderIdentifier: string;
};
export type PostSystemLogViewerApiFoldersByFolderIdentifierClearCacheResponse = {
    success: boolean;
};
export type DeleteSystemLogViewerApiFoldersByFolderIdentifierData = {
    folderIdentifier: string;
};
export type DeleteSystemLogViewerApiFoldersByFolderIdentifierResponse = {
    success: boolean;
};
export type GetSystemLogViewerApiFoldersByFolderIdentifierDownloadData = {
    folderIdentifier: string;
};
export type GetSystemLogViewerApiFoldersByFolderIdentifierDownloadResponse = string;
export type GetApiGenresData = {
    fields?: string;
    librarySlug?: string;
    limit?: number;
    page?: number;
    relations?: string;
};
export type GetApiGenresResponse = {
    data: Array&lt;GenreResource&gt;;
    meta: {
        /**
         * Total number of items being paginated.
         */
        total: number;
        /**
         * The number of items for the current page
         */
        count: number;
        /**
         * The number of items per page
         */
        limit: number;
        /**
         * The number of current page
         */
        currentPage: number;
        /**
         * The number of next page
         */
        nextPage: number;
        /**
         * The number of last page
         */
        lastPage: number;
    };
    links: {
        first: string | null;
        last: string | null;
        prev: string | null;
        next: string | null;
    };
};
export type GetApiGenresByGenreData = {
    /**
     * The genre slug
     */
    genre: string;
};
export type GetApiGenresByGenreResponse = GenreResource;
export type PatchApiGenresByGenreData = {
    /**
     * The genre slug
     */
    genre: string;
    requestBody: UpdateGenreRequest;
};
export type PatchApiGenresByGenreResponse = GenreResource;
export type DeleteApiGenresByGenreData = {
    /**
     * The genre slug
     */
    genre: string;
};
export type DeleteApiGenresByGenreResponse = void;
export type GetSystemLogViewerApiHostsResponse = Array&lt;LogViewerHostResource&gt;;
export type GetApiImagesByImageData = {
    /**
     * The image public id
     */
    image: string;
};
export type GetApiImagesByImageResponse = string;
export type PostApiJobsScanLibraryBySlugData = {
    slug: string;
};
export type PostApiJobsScanLibraryBySlugResponse = {
    message: &apos;Job started successfully&apos;;
};
export type GetHorizonApiMetricsJobsResponse = Array&lt;unknown&gt;;
export type GetHorizonApiMetricsJobsByIdData = {
    id: string;
};
export type GetHorizonApiMetricsJobsByIdResponse = {
    [key: string]: unknown;
};
export type GetHorizonApiJobsByIdData = {
    id: string;
};
export type GetHorizonApiJobsByIdResponse = Array&lt;unknown&gt;;
export type GetApiLibrariesData = {
    limit?: number;
    page?: number;
};
export type GetApiLibrariesResponse = {
    data: Array&lt;LibraryResource&gt;;
    meta: {
        /**
         * Total number of items being paginated.
         */
        total: number;
        /**
         * The number of items for the current page
         */
        count: number;
        /**
         * The number of items per page
         */
        limit: number;
        /**
         * The number of current page
         */
        currentPage: number;
        /**
         * The number of next page
         */
        nextPage: number;
        /**
         * The number of last page
         */
        lastPage: number;
    };
    links: {
        first: string | null;
        last: string | null;
        prev: string | null;
        next: string | null;
    };
};
export type PostApiLibrariesData = {
    requestBody: CreateLibraryRequest;
};
export type PostApiLibrariesResponse = LibraryResource;
export type GetApiLibrariesBySlugData = {
    slug: string;
};
export type GetApiLibrariesBySlugResponse = LibraryResource;
export type PatchApiLibrariesBySlugData = {
    requestBody?: UpdateLibraryRequest;
    slug: string;
};
export type PatchApiLibrariesBySlugResponse = LibraryResource;
export type DeleteApiLibrariesBySlugData = {
    slug: string;
};
export type DeleteApiLibrariesBySlugResponse = void;
export type GetSystemLogViewerApiLogsData = {
    direction?: string;
    excludeFileTypes?: string;
    excludeLevels?: string;
    file?: string;
    log?: string;
    perPage?: string;
    query?: string;
    shorterStackTraces?: boolean;
};
export type GetSystemLogViewerApiLogsResponse = {
    file: LogFileResource | null;
    levelCounts: Array&lt;LevelCountResource&gt;;
    logs: Array&lt;LogResource&gt;;
    columns: string | null;
    pagination: {
        current_page: string;
        first_page_url: string;
        from: string;
        last_page: string;
        last_page_url: string;
        links: string;
        links_short: string;
        next_page_url: string;
        path: string;
        per_page: string;
        prev_page_url: string;
        to: string;
        total: string;
    } | null;
    expandAutomatically: string;
    cacheRecentlyCleared: string;
    hasMoreResults: string;
    percentScanned: string;
    performance: {
        memoryUsage: string;
        requestTime: string;
        version: string;
    };
};
export type GetHorizonApiMastersResponse = {
    [key: string]: unknown;
};
export type GetHorizonApiMonitoringResponse = {
    [key: string]: unknown;
};
export type PostHorizonApiMonitoringResponse = {
    [key: string]: unknown;
};
export type GetHorizonApiMonitoringByTagData = {
    limit?: string;
    tag: string;
};
export type GetHorizonApiMonitoringByTagResponse = {
    jobs: string;
    total: string;
};
export type DeleteHorizonApiMonitoringByTagData = {
    tag: string;
};
export type DeleteHorizonApiMonitoringByTagResponse = {
    [key: string]: unknown;
};
export type GetApiLibrariesByLibraryMoviesData = {
    /**
     * The library slug
     */
    library: string;
};
export type GetApiLibrariesByLibraryMoviesResponse = {
    data: Array&lt;MovieResource&gt;;
    meta: {
        /**
         * Total number of items being paginated.
         */
        total: number;
        /**
         * The number of items for the current page
         */
        count: number;
        /**
         * The number of items per page
         */
        limit: number;
        /**
         * The number of current page
         */
        currentPage: number;
        /**
         * The number of next page
         */
        nextPage: number;
        /**
         * The number of last page
         */
        lastPage: number;
    };
    links: {
        first: string | null;
        last: string | null;
        prev: string | null;
        next: string | null;
    };
};
export type GetApiLibrariesByLibraryMoviesByMovieData = {
    /**
     * The library slug
     */
    library: string;
    /**
     * The movie slug
     */
    movie: string;
};
export type GetApiLibrariesByLibraryMoviesByMovieResponse = MovieResource;
export type GetApiOpcacheStatusResponse = {
    opcache_enabled: boolean;
    file_cache: string;
    file_cache_only: boolean;
    cache_full: boolean;
    restart_pending: boolean;
    &apos;&apos;?: {
        [key: string]: unknown;
    };
    memory_usage: {
        used_memory: number;
        free_memory: number;
        wasted_memory: number;
        current_wasted_percentage: number;
    };
    interned_strings_usage: {
        buffer_size: number;
        used_memory: number;
        free_memory: number;
        number_of_strings: number;
    };
    opcache_statistics: {
        num_cached_scripts: number;
        num_cached_keys: number;
        max_cached_keys: number;
        hits: number;
        start_time: number;
        last_restart_time: number;
        oom_restarts: number;
        hash_restarts: number;
        manual_restarts: number;
        misses: number;
        blacklist_misses: number;
        blacklist_miss_ratio: number;
        opcache_hit_rate: number;
    };
    jit: {
        enabled: boolean;
        on: boolean;
        kind: number;
        opt_level: number;
        opt_flags: number;
        buffer_size: number;
        buffer_free: number;
    };
};
export type GetApiOpcacheConfigResponse = {
    directives: {
        property: number | boolean | string;
    };
    version: {
        version: string;
        opcache_product_name: string;
    };
    blacklist: Array&lt;(string)&gt;;
};
export type PostApiOpcacheClearResponse = {
    success: boolean;
};
export type PostApiOpcacheCompileData = {
    force?: string;
};
export type PostApiOpcacheCompileResponse = {
    totalFiles: number;
    compiled: number;
};
export type GetHorizonApiJobsPendingData = {
    startingAt?: string;
};
export type GetHorizonApiJobsPendingResponse = {
    jobs: string;
    total: string;
};
export type GetApiPlaylistsResponse = {
    data: Array&lt;PlaylistResource&gt;;
    meta: {
        /**
         * Total number of items being paginated.
         */
        total: number;
        /**
         * The number of items for the current page
         */
        count: number;
        /**
         * The number of items per page
         */
        limit: number;
        /**
         * The number of current page
         */
        currentPage: number;
        /**
         * The number of next page
         */
        nextPage: number;
        /**
         * The number of last page
         */
        lastPage: number;
    };
    links: {
        first: string | null;
        last: string | null;
        prev: string | null;
        next: string | null;
    };
};
export type PostApiPlaylistsData = {
    requestBody: CreatePlaylistRequest;
};
export type PostApiPlaylistsResponse = PlaylistResource;
export type GetApiPlaylistsByPlaylistData = {
    /**
     * The playlist public id
     */
    playlist: string;
    relations?: string;
};
export type GetApiPlaylistsByPlaylistResponse = PlaylistResource;
export type PutApiPlaylistsByPlaylistData = {
    /**
     * The playlist public id
     */
    playlist: string;
    requestBody?: UpdatePlaylistRequest;
};
export type PutApiPlaylistsByPlaylistResponse = PlaylistResource;
export type DeleteApiPlaylistsByPlaylistData = {
    /**
     * The playlist public id
     */
    playlist: string;
};
export type DeleteApiPlaylistsByPlaylistResponse = void;
export type PostApiPlaylistsByPlaylistSongsBySongData = {
    /**
     * The playlist public id
     */
    playlist: string;
    /**
     * The song public id
     */
    song: string;
};
export type PostApiPlaylistsByPlaylistSongsBySongResponse = {
    message: &apos;Song added to playlist&apos;;
};
export type DeleteApiPlaylistsByPlaylistSongsBySongData = {
    /**
     * The playlist public id
     */
    playlist: string;
    /**
     * The song public id
     */
    song: string;
};
export type DeleteApiPlaylistsByPlaylistSongsBySongResponse = {
    message: &apos;Song removed from playlist&apos;;
};
export type PostApiPlaylistsByPlaylistReorderData = {
    /**
     * The playlist public id
     */
    playlist: string;
    requestBody: {
        song_ids: Array&lt;(number)&gt;;
    };
};
export type PostApiPlaylistsByPlaylistReorderResponse = {
    message: &apos;Playlist reordered&apos;;
};
export type PostApiPlaylistsByPlaylistCollaboratorsData = {
    /**
     * The playlist public id
     */
    playlist: string;
    requestBody: {
        user_id: number;
        role?: &apos;editor&apos; | &apos;contributor&apos;;
    };
};
export type PostApiPlaylistsByPlaylistCollaboratorsResponse = {
    message: &apos;Collaborator added&apos;;
};
export type DeleteApiPlaylistsByPlaylistCollaboratorsByUserData = {
    /**
     * The playlist public id
     */
    playlist: string;
    /**
     * The user ID
     */
    user: number;
};
export type DeleteApiPlaylistsByPlaylistCollaboratorsByUserResponse = {
    message: &apos;Collaborator removed&apos;;
};
export type PostApiPlaylistsByPlaylistCloneData = {
    /**
     * The playlist public id
     */
    playlist: string;
};
export type PostApiPlaylistsByPlaylistCloneResponse = PlaylistResource;
export type GetApiPlaylistsByPlaylistStatisticsData = {
    /**
     * The playlist public id
     */
    playlist: string;
};
export type GetApiPlaylistsByPlaylistStatisticsResponse = PlaylistStatistic;
export type PostApiPlaylistsByPlaylistStatisticsRecordViewData = {
    /**
     * The playlist public id
     */
    playlist: string;
};
export type PostApiPlaylistsByPlaylistStatisticsRecordViewResponse = {
    message: &apos;View recorded&apos;;
};
export type PostApiPlaylistsByPlaylistStatisticsRecordPlayData = {
    /**
     * The playlist public id
     */
    playlist: string;
};
export type PostApiPlaylistsByPlaylistStatisticsRecordPlayResponse = {
    message: &apos;Play recorded&apos;;
};
export type PostApiPlaylistsByPlaylistStatisticsRecordShareData = {
    /**
     * The playlist public id
     */
    playlist: string;
};
export type PostApiPlaylistsByPlaylistStatisticsRecordShareResponse = {
    message: &apos;Share recorded&apos;;
};
export type PostApiPlaylistsByPlaylistStatisticsRecordFavoriteData = {
    /**
     * The playlist public id
     */
    playlist: string;
};
export type PostApiPlaylistsByPlaylistStatisticsRecordFavoriteResponse = {
    message: &apos;Favorite recorded&apos;;
};
export type PostApiPlaylistsSmartData = {
    requestBody: CreateSmartPlaylistRequest;
};
export type PostApiPlaylistsSmartResponse = PlaylistResource;
export type PutApiPlaylistsByPlaylistSmartData = {
    /**
     * The playlist public id
     */
    playlist: string;
    requestBody: UpdateSmartPlaylistRulesRequest;
};
export type PutApiPlaylistsByPlaylistSmartResponse = PlaylistResource;
export type PostApiPlaylistsByPlaylistSmartSyncData = {
    /**
     * The playlist public id
     */
    playlist: string;
};
export type PostApiPlaylistsByPlaylistSmartSyncResponse = {
    message: &apos;Smart playlist synced&apos;;
};
export type GetApiQueueMetricsData = {
    limit?: number;
    name?: string;
    page?: number;
    queue?: string;
    queuedFirst?: boolean;
    status?: &apos;running&apos; | &apos;succeeded&apos; | &apos;failed&apos; | &apos;stale&apos; | &apos;queued&apos;;
};
export type GetApiQueueMetricsResponse = {
    data: Array&lt;QueueMonitorResource&gt;;
    meta: {
        /**
         * Total number of items being paginated.
         */
        total: number;
        /**
         * The number of items for the current page
         */
        count: number;
        /**
         * The number of items per page
         */
        limit: number;
        /**
         * The number of current page
         */
        currentPage: number;
        /**
         * The number of next page
         */
        nextPage: number;
        /**
         * The number of last page
         */
        lastPage: number;
    };
    links: {
        first: string | null;
        last: string | null;
        prev: string | null;
        next: string | null;
    };
};
export type GetApiQueueMetricsQueuesResponse = Array&lt;{
    name: string;
}&gt;;
export type GetApiQueueMetricsMetricsData = {
    aggregateDays?: number;
};
export type GetApiQueueMetricsMetricsResponse = Array&lt;{
    title: string;
    value: number;
    previousValue: number | null;
    format: string;
    formattedValue: string;
    formattedPreviousValue: string | null;
}&gt;;
export type PostApiQueueMetricsRetryByIdData = {
    id: string;
    requestBody?: RetryJobRequest;
};
export type PostApiQueueMetricsRetryByIdResponse = {
    status: &apos;success&apos;;
    message: &apos;Job has been successfully retried&apos;;
} | {
    status: &apos;failed&apos;;
    message: &apos;An error occurred while executing the job&apos;;
};
export type DeleteApiQueueMetricsByIdData = {
    id: string;
};
export type DeleteApiQueueMetricsByIdResponse = void;
export type DeleteApiQueueMetricsPurgeResponse = void;
export type GetHorizonApiMetricsQueuesResponse = Array&lt;unknown&gt;;
export type GetHorizonApiMetricsQueuesByIdData = {
    id: string;
};
export type GetHorizonApiMetricsQueuesByIdResponse = {
    [key: string]: unknown;
};
export type PostHorizonApiJobsRetryByIdData = {
    id: string;
};
export type PostHorizonApiJobsRetryByIdResponse = {
    [key: string]: unknown;
};
export type GetApiSchemasMusicbrainzResponse = Array&lt;Array&lt;unknown&gt;&gt;;
export type GetHorizonApiJobsSilencedData = {
    startingAt?: string;
};
export type GetHorizonApiJobsSilencedResponse = {
    jobs: string;
    total: string;
};
export type GetApiLibrariesByLibrarySongsData = {
    genreNames?: string;
    genreSlugs?: string;
    /**
     * The library slug
     */
    library: string;
    limit?: number;
    page?: number;
    relations?: string;
};
export type GetApiLibrariesByLibrarySongsResponse = {
    data: Array&lt;SongResource&gt;;
    meta: {
        /**
         * Total number of items being paginated.
         */
        total: number;
        /**
         * The number of items for the current page
         */
        count: number;
        /**
         * The number of items per page
         */
        limit: number;
        /**
         * The number of current page
         */
        currentPage: number;
        /**
         * The number of next page
         */
        nextPage: number;
        /**
         * The number of last page
         */
        lastPage: number;
    };
    links: {
        first: string | null;
        last: string | null;
        prev: string | null;
        next: string | null;
    };
};
export type GetApiLibrariesByLibrarySongsByPublicIdData = {
    /**
     * The library slug
     */
    library: string;
    publicId: string;
    relations?: string;
};
export type GetApiLibrariesByLibrarySongsByPublicIdResponse = SongResource;
export type GetApiStreamSongBySongDirectData = {
    /**
     * The song public id
     */
    song: string;
};
export type GetApiStreamSongBySongDirectResponse = {
    [key: string]: unknown;
};
export type GetApiSystemInfoResponse = Array&lt;{
    section: string;
    values: Array&lt;{
        key: string;
        value: string | number | boolean | null;
    }&gt;;
}&gt;;
export type GetApiSystemInfoSysResponse = {
    memoryUsage: number;
    systemLoadAverage: Array&lt;(number)&gt;;
    swooleVm: {
        object_num: number;
        resource_num: number;
    };
};
export type GetApiUsersData = {
    filterModes?: string;
    filters?: string;
    globalFilter?: string;
    limit?: number;
    page?: number;
    sorting?: string;
};
export type GetApiUsersResponse = {
    data: Array&lt;UserResource&gt;;
    meta: {
        /**
         * Total number of items being paginated.
         */
        total: number;
        /**
         * The number of items for the current page
         */
        count: number;
        /**
         * The number of items per page
         */
        limit: number;
        /**
         * The number of current page
         */
        currentPage: number;
        /**
         * The number of next page
         */
        nextPage: number;
        /**
         * The number of last page
         */
        lastPage: number;
    };
    links: {
        first: string | null;
        last: string | null;
        prev: string | null;
        next: string | null;
    };
};
export type PostApiUsersData = {
    requestBody: CreateUserRequest;
};
export type PostApiUsersResponse = UserResource;
export type PatchApiUsersByUserData = {
    requestBody?: UpdateUserRequest;
    /**
     * The user ID
     */
    user: number;
};
export type PatchApiUsersByUserResponse = UserResource;
export type GetApiUsersByUserData = {
    /**
     * The user ID
     */
    user: number;
};
export type GetApiUsersByUserResponse = UserResource;
export type DeleteApiUsersByUserData = {
    user: string;
};
export type DeleteApiUsersByUserResponse = void;
export type GetApiUsersMeResponse = UserResource;
export type GetApiUsersTokensByUserData = {
    page?: number;
    perPage?: number;
    user: string;
};
export type GetApiUsersTokensByUserResponse = {
    data: Array&lt;PersonalAccessTokenViewResource&gt;;
    meta: {
        /**
         * Total number of items being paginated.
         */
        total: number;
        /**
         * The number of items for the current page
         */
        count: number;
        /**
         * The number of items per page
         */
        limit: number;
        /**
         * The number of current page
         */
        currentPage: number;
        /**
         * The number of next page
         */
        nextPage: number;
        /**
         * The number of last page
         */
        lastPage: number;
    };
    links: {
        first: string | null;
        last: string | null;
        prev: string | null;
        next: string | null;
    };
};
export type DeleteApiUsersTokensByTokenData = {
    /**
     * The token ID
     */
    token: number;
};
export type DeleteApiUsersTokensByTokenResponse = void;
export type GetHorizonApiWorkloadResponse = Array&lt;unknown&gt;;
export type $OpenApiTs = {
    &apos;/api/libraries/{library}/albums&apos;: {
        get: {
            req: GetApiLibrariesByLibraryAlbumsData;
            res: {
                /**
                 * Paginated set of `AlbumResource`
                 */
                200: {
                    data: Array&lt;AlbumResource&gt;;
                    meta: {
                        /**
                         * Total number of items being paginated.
                         */
                        total: number;
                        /**
                         * The number of items for the current page
                         */
                        count: number;
                        /**
                         * The number of items per page
                         */
                        limit: number;
                        /**
                         * The number of current page
                         */
                        currentPage: number;
                        /**
                         * The number of next page
                         */
                        nextPage: number;
                        /**
                         * The number of last page
                         */
                        lastPage: number;
                    };
                    links: {
                        first: string | null;
                        last: string | null;
                        prev: string | null;
                        next: string | null;
                    };
                };
                /**
                 * Unauthenticated
                 */
                401: {
                    /**
                     * Error overview.
                     */
                    message: string;
                };
                /**
                 * Not found
                 */
                404: {
                    /**
                     * Error overview.
                     */
                    message: string;
                };
                /**
                 * Validation error
                 */
                422: {
                    /**
                     * Errors overview.
                     */
                    message: string;
                    /**
                     * A detailed description of each field that failed validation.
                     */
                    errors: {
                        [key: string]: Array&lt;(string)&gt;;
                    };
                };
            };
        };
    };
    &apos;/api/libraries/{library}/albums/{album}&apos;: {
        get: {
            req: GetApiLibrariesByLibraryAlbumsByAlbumData;
            res: {
                /**
                 * `AlbumResource`
                 */
                200: AlbumResource;
                /**
                 * Unauthenticated
                 */
                401: {
                    /**
                     * Error overview.
                     */
                    message: string;
                };
                /**
                 * Not found
                 */
                404: {
                    /**
                     * Error overview.
                     */
                    message: string;
                };
            };
        };
    };
    &apos;/api/libraries/{library}/artists&apos;: {
        get: {
            req: GetApiLibrariesByLibraryArtistsData;
            res: {
                /**
                 * Paginated set of `ArtistResource`
                 */
                200: {
                    data: Array&lt;ArtistResource&gt;;
                    meta: {
                        /**
                         * Total number of items being paginated.
                         */
                        total: number;
                        /**
                         * The number of items for the current page
                         */
                        count: number;
                        /**
                         * The number of items per page
                         */
                        limit: number;
                        /**
                         * The number of current page
                         */
                        currentPage: number;
                        /**
                         * The number of next page
                         */
                        nextPage: number;
                        /**
                         * The number of last page
                         */
                        lastPage: number;
                    };
                    links: {
                        first: string | null;
                        last: string | null;
                        prev: string | null;
                        next: string | null;
                    };
                };
                /**
                 * Unauthenticated
                 */
                401: {
                    /**
                     * Error overview.
                     */
                    message: string;
                };
                /**
                 * Validation error
                 */
                422: {
                    /**
                     * Errors overview.
                     */
                    message: string;
                    /**
                     * A detailed description of each field that failed validation.
                     */
                    errors: {
                        [key: string]: Array&lt;(string)&gt;;
                    };
                };
            };
        };
    };
    &apos;/api/libraries/{library}/artists/{artist}&apos;: {
        get: {
            req: GetApiLibrariesByLibraryArtistsByArtistData;
            res: {
                /**
                 * `ArtistResource`
                 */
                200: ArtistResource;
                /**
                 * Unauthenticated
                 */
                401: {
                    /**
                     * Error overview.
                     */
                    message: string;
                };
                /**
                 * Not found
                 */
                404: {
                    /**
                     * Error overview.
                     */
                    message: string;
                };
            };
        };
    };
    &apos;/api/auth/login&apos;: {
        post: {
            req: PostApiAuthLoginData;
            res: {
                200: {
                    accessToken: NewAccessTokenResource;
                    refreshToken: NewAccessTokenResource;
                };
                /**
                 * An error
                 */
                401: {
                    /**
                     * Error overview.
                     */
                    message: string;
                };
                /**
                 * Validation error
                 */
                422: {
                    /**
                     * Errors overview.
                     */
                    message: string;
                    /**
                     * A detailed description of each field that failed validation.
                     */
                    errors: {
                        [key: string]: Array&lt;(string)&gt;;
                    };
                };
            };
        };
    };
    &apos;/api/auth/refreshToken&apos;: {
        post: {
            res: {
                200: {
                    accessToken: NewAccessTokenResource;
                };
                /**
                 * Unauthenticated
                 */
                401: {
                    /**
                     * Error overview.
                     */
                    message: string;
                };
            };
        };
    };
    &apos;/api/auth/streamToken&apos;: {
        post: {
            res: {
                200: {
                    streamToken: NewAccessTokenResource;
                };
                /**
                 * Unauthenticated
                 */
                401: {
                    /**
                     * Error overview.
                     */
                    message: string;
                };
            };
        };
    };
    &apos;/api/auth/register&apos;: {
        post: {
            req: PostApiAuthRegisterData;
            res: {
                200: {
                    accessToken: NewAccessTokenResource;
                    refreshToken: NewAccessTokenResource;
                };
                /**
                 * Validation error
                 */
                422: {
                    /**
                     * Errors overview.
                     */
                    message: string;
                    /**
                     * A detailed description of each field that failed validation.
                     */
                    errors: {
                        [key: string]: Array&lt;(string)&gt;;
                    };
                };
            };
        };
    };
    &apos;/api/auth/forgotPassword&apos;: {
        post: {
            req: PostApiAuthForgotPasswordData;
            res: {
                200: {
                    message: string;
                };
                /**
                 * Validation error
                 */
                422: {
                    /**
                     * Errors overview.
                     */
                    message: string;
                    /**
                     * A detailed description of each field that failed validation.
                     */
                    errors: {
                        [key: string]: Array&lt;(string)&gt;;
                    };
                };
            };
        };
    };
    &apos;/api/auth/resetPassword&apos;: {
        post: {
            req: PostApiAuthResetPasswordData;
            res: {
                200: {
                    message: &apos;Password reset successfully.&apos;;
                };
                /**
                 * An error
                 */
                400: {
                    /**
                     * Error overview.
                     */
                    message: string;
                };
                /**
                 * Validation error
                 */
                422: {
                    /**
                     * Errors overview.
                     */
                    message: string;
                    /**
                     * A detailed description of each field that failed validation.
                     */
                    errors: {
                        [key: string]: Array&lt;(string)&gt;;
                    };
                };
            };
        };
    };
    &apos;/api/auth/verify/{id}/{hash}&apos;: {
        post: {
            req: PostApiAuthVerifyByIdByHashData;
            res: {
                /**
                 * `UserResource`
                 */
                200: UserResource;
                /**
                 * Not found
                 */
                404: {
                    /**
                     * Error overview.
                     */
                    message: string;
                };
            };
        };
    };
    &apos;/api/auth/logout&apos;: {
        post: {
            req: PostApiAuthLogoutData;
            res: {
                /**
                 * No content
                 */
                204: void;
                /**
                 * Unauthenticated
                 */
                401: {
                    /**
                     * Error overview.
                     */
                    message: string;
                };
                /**
                 * Validation error
                 */
                422: {
                    /**
                     * Errors overview.
                     */
                    message: string;
                    /**
                     * A detailed description of each field that failed validation.
                     */
                    errors: {
                        [key: string]: Array&lt;(string)&gt;;
                    };
                };
            };
        };
    };
    &apos;/webauthn/passkey&apos;: {
        get: {
            res: {
                200: {
                    challenge: string;
                    rpId: string;
                    allowCredentials: Array&lt;(string)&gt;;
                };
            };
        };
        post: {
            req: PostWebauthnPasskeyData;
            res: {
                200: {
    accessToken: NewAccessTokenResource;
    refreshToken: NewAccessTokenResource;
} | string;
                401: {
                    message: string;
                };
                /**
                 * Validation error
                 */
                422: {
                    /**
                     * Errors overview.
                     */
                    message: string;
                    /**
                     * A detailed description of each field that failed validation.
                     */
                    errors: {
                        [key: string]: Array&lt;(string)&gt;;
                    };
                };
            };
        };
    };
    &apos;/webauthn/passkey/register&apos;: {
        get: {
            res: {
                200: string | {
    [key: string]: unknown;
};
                /**
                 * Unauthenticated
                 */
                401: {
                    /**
                     * Error overview.
                     */
                    message: string;
                };
            };
        };
        post: {
            req: PostWebauthnPasskeyRegisterData;
            res: {
                200: {
                    message: &apos;Passkey successfully stored&apos;;
                };
                /**
                 * Unauthenticated
                 */
                401: {
                    /**
                     * Error overview.
                     */
                    message: string;
                };
                /**
                 * Validation error
                 */
                422: {
                    /**
                     * Errors overview.
                     */
                    message: string;
                    /**
                     * A detailed description of each field that failed validation.
                     */
                    errors: {
                        [key: string]: Array&lt;(string)&gt;;
                    };
                };
                500: {
                    error: &apos;Could not store passkey&apos;;
                };
            };
        };
    };
    &apos;/-/horizon/api/batches&apos;: {
        get: {
            res: {
                200: {
                    batches: Array&lt;(string)&gt;;
                };
            };
        };
    };
    &apos;/-/horizon/api/batches/{id}&apos;: {
        get: {
            req: GetHorizonApiBatchesByIdData;
            res: {
                200: {
                    batch: string;
                    failedJobs: string;
                };
            };
        };
    };
    &apos;/-/horizon/api/batches/retry/{id}&apos;: {
        post: {
            req: PostHorizonApiBatchesRetryByIdData;
            res: {
                200: {
                    [key: string]: unknown;
                };
            };
        };
    };
    &apos;/-/horizon/api/jobs/completed&apos;: {
        get: {
            req: GetHorizonApiJobsCompletedData;
            res: {
                200: {
                    jobs: string;
                    total: string;
                };
            };
        };
    };
    &apos;/-/horizon/api/stats&apos;: {
        get: {
            res: {
                200: {
                    failedJobs: string;
                    jobsPerMinute: string;
                    pausedMasters: string | 0;
                    periods: {
                        failedJobs: string;
                        recentJobs: string;
                    };
                    processes: string;
                    queueWithMaxRuntime: string;
                    queueWithMaxThroughput: string;
                    recentJobs: string;
                    status: &apos;paused&apos; | &apos;running&apos; | &apos;inactive&apos;;
                    wait: string;
                };
            };
        };
    };
    &apos;/-/horizon/api/jobs/failed&apos;: {
        get: {
            req: GetHorizonApiJobsFailedData;
            res: {
                200: {
                    jobs: string;
                    total: string;
                };
            };
        };
    };
    &apos;/-/horizon/api/jobs/failed/{id}&apos;: {
        get: {
            req: GetHorizonApiJobsFailedByIdData;
            res: {
                200: unknown;
            };
        };
    };
    &apos;/system/log-viewer/api/files&apos;: {
        get: {
            res: {
                /**
                 * Array of `LogFileResource`
                 */
                200: Array&lt;LogFileResource&gt;;
            };
        };
    };
    &apos;/system/log-viewer/api/files/{fileIdentifier}/download/request&apos;: {
        get: {
            req: GetSystemLogViewerApiFilesByFileIdentifierDownloadRequestData;
            res: {
                200: {
                    url: string;
                };
                /**
                 * Authorization error
                 */
                403: {
                    /**
                     * Error overview.
                     */
                    message: string;
                };
                /**
                 * Not found
                 */
                404: {
                    /**
                     * Error overview.
                     */
                    message: string;
                };
            };
        };
    };
    &apos;/system/log-viewer/api/files/{fileIdentifier}/clear-cache&apos;: {
        post: {
            req: PostSystemLogViewerApiFilesByFileIdentifierClearCacheData;
            res: {
                200: {
                    success: boolean;
                };
                /**
                 * Not found
                 */
                404: {
                    /**
                     * Error overview.
                     */
                    message: string;
                };
            };
        };
    };
    &apos;/system/log-viewer/api/files/{fileIdentifier}&apos;: {
        delete: {
            req: DeleteSystemLogViewerApiFilesByFileIdentifierData;
            res: {
                200: {
                    success: boolean;
                };
                /**
                 * Authorization error
                 */
                403: {
                    /**
                     * Error overview.
                     */
                    message: string;
                };
            };
        };
    };
    &apos;/system/log-viewer/api/clear-cache-all&apos;: {
        post: {
            res: {
                200: {
                    success: boolean;
                };
            };
        };
    };
    &apos;/system/log-viewer/api/delete-multiple-files&apos;: {
        post: {
            req: PostSystemLogViewerApiDeleteMultipleFilesData;
            res: {
                200: {
                    success: boolean;
                };
            };
        };
    };
    &apos;/system/log-viewer/api/files/{fileIdentifier}/download&apos;: {
        get: {
            req: GetSystemLogViewerApiFilesByFileIdentifierDownloadData;
            res: {
                200: string;
            };
        };
    };
    &apos;/system/log-viewer/api/folders&apos;: {
        get: {
            req: GetSystemLogViewerApiFoldersData;
            res: {
                /**
                 * Array of `LogFolderResource`
                 */
                200: Array&lt;LogFolderResource&gt;;
            };
        };
    };
    &apos;/system/log-viewer/api/folders/{folderIdentifier}/download/request&apos;: {
        get: {
            req: GetSystemLogViewerApiFoldersByFolderIdentifierDownloadRequestData;
            res: {
                200: {
                    url: string;
                };
                /**
                 * Authorization error
                 */
                403: {
                    /**
                     * Error overview.
                     */
                    message: string;
                };
                /**
                 * Not found
                 */
                404: {
                    /**
                     * Error overview.
                     */
                    message: string;
                };
            };
        };
    };
    &apos;/system/log-viewer/api/folders/{folderIdentifier}/clear-cache&apos;: {
        post: {
            req: PostSystemLogViewerApiFoldersByFolderIdentifierClearCacheData;
            res: {
                200: {
                    success: boolean;
                };
                /**
                 * Not found
                 */
                404: {
                    /**
                     * Error overview.
                     */
                    message: string;
                };
            };
        };
    };
    &apos;/system/log-viewer/api/folders/{folderIdentifier}&apos;: {
        delete: {
            req: DeleteSystemLogViewerApiFoldersByFolderIdentifierData;
            res: {
                200: {
                    success: boolean;
                };
                /**
                 * Authorization error
                 */
                403: {
                    /**
                     * Error overview.
                     */
                    message: string;
                };
            };
        };
    };
    &apos;/system/log-viewer/api/folders/{folderIdentifier}/download&apos;: {
        get: {
            req: GetSystemLogViewerApiFoldersByFolderIdentifierDownloadData;
            res: {
                200: string;
            };
        };
    };
    &apos;/api/genres&apos;: {
        get: {
            req: GetApiGenresData;
            res: {
                /**
                 * Paginated set of `GenreResource`
                 */
                200: {
                    data: Array&lt;GenreResource&gt;;
                    meta: {
                        /**
                         * Total number of items being paginated.
                         */
                        total: number;
                        /**
                         * The number of items for the current page
                         */
                        count: number;
                        /**
                         * The number of items per page
                         */
                        limit: number;
                        /**
                         * The number of current page
                         */
                        currentPage: number;
                        /**
                         * The number of next page
                         */
                        nextPage: number;
                        /**
                         * The number of last page
                         */
                        lastPage: number;
                    };
                    links: {
                        first: string | null;
                        last: string | null;
                        prev: string | null;
                        next: string | null;
                    };
                };
                /**
                 * Unauthenticated
                 */
                401: {
                    /**
                     * Error overview.
                     */
                    message: string;
                };
                /**
                 * Validation error
                 */
                422: {
                    /**
                     * Errors overview.
                     */
                    message: string;
                    /**
                     * A detailed description of each field that failed validation.
                     */
                    errors: {
                        [key: string]: Array&lt;(string)&gt;;
                    };
                };
            };
        };
    };
    &apos;/api/genres/{genre}&apos;: {
        get: {
            req: GetApiGenresByGenreData;
            res: {
                /**
                 * `GenreResource`
                 */
                200: GenreResource;
                /**
                 * Unauthenticated
                 */
                401: {
                    /**
                     * Error overview.
                     */
                    message: string;
                };
                /**
                 * Not found
                 */
                404: {
                    /**
                     * Error overview.
                     */
                    message: string;
                };
            };
        };
        patch: {
            req: PatchApiGenresByGenreData;
            res: {
                /**
                 * `GenreResource`
                 */
                200: GenreResource;
                /**
                 * Unauthenticated
                 */
                401: {
                    /**
                     * Error overview.
                     */
                    message: string;
                };
                /**
                 * Not found
                 */
                404: {
                    /**
                     * Error overview.
                     */
                    message: string;
                };
                /**
                 * Validation error
                 */
                422: {
                    /**
                     * Errors overview.
                     */
                    message: string;
                    /**
                     * A detailed description of each field that failed validation.
                     */
                    errors: {
                        [key: string]: Array&lt;(string)&gt;;
                    };
                };
            };
        };
        delete: {
            req: DeleteApiGenresByGenreData;
            res: {
                /**
                 * No content
                 */
                204: void;
                /**
                 * Unauthenticated
                 */
                401: {
                    /**
                     * Error overview.
                     */
                    message: string;
                };
                /**
                 * Not found
                 */
                404: {
                    /**
                     * Error overview.
                     */
                    message: string;
                };
            };
        };
    };
    &apos;/system/log-viewer/api/hosts&apos;: {
        get: {
            res: {
                /**
                 * Array of `LogViewerHostResource`
                 */
                200: Array&lt;LogViewerHostResource&gt;;
            };
        };
    };
    &apos;/api/images/{image}&apos;: {
        get: {
            req: GetApiImagesByImageData;
            res: {
                200: string;
                /**
                 * Not found
                 */
                404: {
                    /**
                     * Error overview.
                     */
                    message: string;
                };
            };
        };
    };
    &apos;/api/jobs/scanLibrary/{slug}&apos;: {
        post: {
            req: PostApiJobsScanLibraryBySlugData;
            res: {
                200: {
                    message: &apos;Job started successfully&apos;;
                };
                /**
                 * Unauthenticated
                 */
                401: {
                    /**
                     * Error overview.
                     */
                    message: string;
                };
            };
        };
    };
    &apos;/-/horizon/api/metrics/jobs&apos;: {
        get: {
            res: {
                200: Array&lt;unknown&gt;;
            };
        };
    };
    &apos;/-/horizon/api/metrics/jobs/{id}&apos;: {
        get: {
            req: GetHorizonApiMetricsJobsByIdData;
            res: {
                200: {
                    [key: string]: unknown;
                };
            };
        };
    };
    &apos;/-/horizon/api/jobs/{id}&apos;: {
        get: {
            req: GetHorizonApiJobsByIdData;
            res: {
                200: Array&lt;unknown&gt;;
            };
        };
    };
    &apos;/api/libraries&apos;: {
        get: {
            req: GetApiLibrariesData;
            res: {
                /**
                 * Paginated set of `LibraryResource`
                 */
                200: {
                    data: Array&lt;LibraryResource&gt;;
                    meta: {
                        /**
                         * Total number of items being paginated.
                         */
                        total: number;
                        /**
                         * The number of items for the current page
                         */
                        count: number;
                        /**
                         * The number of items per page
                         */
                        limit: number;
                        /**
                         * The number of current page
                         */
                        currentPage: number;
                        /**
                         * The number of next page
                         */
                        nextPage: number;
                        /**
                         * The number of last page
                         */
                        lastPage: number;
                    };
                    links: {
                        first: string | null;
                        last: string | null;
                        prev: string | null;
                        next: string | null;
                    };
                };
                /**
                 * Unauthenticated
                 */
                401: {
                    /**
                     * Error overview.
                     */
                    message: string;
                };
                /**
                 * Validation error
                 */
                422: {
                    /**
                     * Errors overview.
                     */
                    message: string;
                    /**
                     * A detailed description of each field that failed validation.
                     */
                    errors: {
                        [key: string]: Array&lt;(string)&gt;;
                    };
                };
            };
        };
        post: {
            req: PostApiLibrariesData;
            res: {
                /**
                 * `LibraryResource`
                 */
                200: LibraryResource;
                /**
                 * Unauthenticated
                 */
                401: {
                    /**
                     * Error overview.
                     */
                    message: string;
                };
                /**
                 * Validation error
                 */
                422: {
                    /**
                     * Errors overview.
                     */
                    message: string;
                    /**
                     * A detailed description of each field that failed validation.
                     */
                    errors: {
                        [key: string]: Array&lt;(string)&gt;;
                    };
                };
            };
        };
    };
    &apos;/api/libraries/{slug}&apos;: {
        get: {
            req: GetApiLibrariesBySlugData;
            res: {
                /**
                 * `LibraryResource`
                 */
                200: LibraryResource;
                /**
                 * Unauthenticated
                 */
                401: {
                    /**
                     * Error overview.
                     */
                    message: string;
                };
            };
        };
        patch: {
            req: PatchApiLibrariesBySlugData;
            res: {
                /**
                 * `LibraryResource`
                 */
                200: LibraryResource;
                /**
                 * Unauthenticated
                 */
                401: {
                    /**
                     * Error overview.
                     */
                    message: string;
                };
                /**
                 * Authorization error
                 */
                403: {
                    /**
                     * Error overview.
                     */
                    message: string;
                };
                /**
                 * Validation error
                 */
                422: {
                    /**
                     * Errors overview.
                     */
                    message: string;
                    /**
                     * A detailed description of each field that failed validation.
                     */
                    errors: {
                        [key: string]: Array&lt;(string)&gt;;
                    };
                };
            };
        };
        delete: {
            req: DeleteApiLibrariesBySlugData;
            res: {
                /**
                 * No content
                 */
                204: void;
                /**
                 * Unauthenticated
                 */
                401: {
                    /**
                     * Error overview.
                     */
                    message: string;
                };
            };
        };
    };
    &apos;/system/log-viewer/api/logs&apos;: {
        get: {
            req: GetSystemLogViewerApiLogsData;
            res: {
                200: {
                    file: LogFileResource | null;
                    levelCounts: Array&lt;LevelCountResource&gt;;
                    logs: Array&lt;LogResource&gt;;
                    columns: string | null;
                    pagination: {
                        current_page: string;
                        first_page_url: string;
                        from: string;
                        last_page: string;
                        last_page_url: string;
                        links: string;
                        links_short: string;
                        next_page_url: string;
                        path: string;
                        per_page: string;
                        prev_page_url: string;
                        to: string;
                        total: string;
                    } | null;
                    expandAutomatically: string;
                    cacheRecentlyCleared: string;
                    hasMoreResults: string;
                    percentScanned: string;
                    performance: {
                        memoryUsage: string;
                        requestTime: string;
                        version: string;
                    };
                };
            };
        };
    };
    &apos;/-/horizon/api/masters&apos;: {
        get: {
            res: {
                200: {
                    [key: string]: unknown;
                };
            };
        };
    };
    &apos;/-/horizon/api/monitoring&apos;: {
        get: {
            res: {
                200: {
                    [key: string]: unknown;
                };
            };
        };
        post: {
            res: {
                200: {
                    [key: string]: unknown;
                };
            };
        };
    };
    &apos;/-/horizon/api/monitoring/{tag}&apos;: {
        get: {
            req: GetHorizonApiMonitoringByTagData;
            res: {
                200: {
                    jobs: string;
                    total: string;
                };
            };
        };
        delete: {
            req: DeleteHorizonApiMonitoringByTagData;
            res: {
                200: {
                    [key: string]: unknown;
                };
            };
        };
    };
    &apos;/api/libraries/{library}/movies&apos;: {
        get: {
            req: GetApiLibrariesByLibraryMoviesData;
            res: {
                /**
                 * Paginated set of `MovieResource`
                 */
                200: {
                    data: Array&lt;MovieResource&gt;;
                    meta: {
                        /**
                         * Total number of items being paginated.
                         */
                        total: number;
                        /**
                         * The number of items for the current page
                         */
                        count: number;
                        /**
                         * The number of items per page
                         */
                        limit: number;
                        /**
                         * The number of current page
                         */
                        currentPage: number;
                        /**
                         * The number of next page
                         */
                        nextPage: number;
                        /**
                         * The number of last page
                         */
                        lastPage: number;
                    };
                    links: {
                        first: string | null;
                        last: string | null;
                        prev: string | null;
                        next: string | null;
                    };
                };
                /**
                 * Unauthenticated
                 */
                401: {
                    /**
                     * Error overview.
                     */
                    message: string;
                };
                /**
                 * Not found
                 */
                404: {
                    /**
                     * Error overview.
                     */
                    message: string;
                };
            };
        };
    };
    &apos;/api/libraries/{library}/movies/{movie}&apos;: {
        get: {
            req: GetApiLibrariesByLibraryMoviesByMovieData;
            res: {
                /**
                 * `MovieResource`
                 */
                200: MovieResource;
                /**
                 * Unauthenticated
                 */
                401: {
                    /**
                     * Error overview.
                     */
                    message: string;
                };
                /**
                 * Not found
                 */
                404: {
                    /**
                     * Error overview.
                     */
                    message: string;
                };
            };
        };
    };
    &apos;/api/opcache/status&apos;: {
        get: {
            res: {
                200: {
                    opcache_enabled: boolean;
                    file_cache: string;
                    file_cache_only: boolean;
                    cache_full: boolean;
                    restart_pending: boolean;
                    &apos;&apos;?: {
                        [key: string]: unknown;
                    };
                    memory_usage: {
                        used_memory: number;
                        free_memory: number;
                        wasted_memory: number;
                        current_wasted_percentage: number;
                    };
                    interned_strings_usage: {
                        buffer_size: number;
                        used_memory: number;
                        free_memory: number;
                        number_of_strings: number;
                    };
                    opcache_statistics: {
                        num_cached_scripts: number;
                        num_cached_keys: number;
                        max_cached_keys: number;
                        hits: number;
                        start_time: number;
                        last_restart_time: number;
                        oom_restarts: number;
                        hash_restarts: number;
                        manual_restarts: number;
                        misses: number;
                        blacklist_misses: number;
                        blacklist_miss_ratio: number;
                        opcache_hit_rate: number;
                    };
                    jit: {
                        enabled: boolean;
                        on: boolean;
                        kind: number;
                        opt_level: number;
                        opt_flags: number;
                        buffer_size: number;
                        buffer_free: number;
                    };
                };
                /**
                 * Unauthenticated
                 */
                401: {
                    /**
                     * Error overview.
                     */
                    message: string;
                };
            };
        };
    };
    &apos;/api/opcache/config&apos;: {
        get: {
            res: {
                200: {
                    directives: {
                        property: number | boolean | string;
                    };
                    version: {
                        version: string;
                        opcache_product_name: string;
                    };
                    blacklist: Array&lt;(string)&gt;;
                };
                /**
                 * Unauthenticated
                 */
                401: {
                    /**
                     * Error overview.
                     */
                    message: string;
                };
            };
        };
    };
    &apos;/api/opcache/clear&apos;: {
        post: {
            res: {
                200: {
                    success: boolean;
                };
                /**
                 * Unauthenticated
                 */
                401: {
                    /**
                     * Error overview.
                     */
                    message: string;
                };
            };
        };
    };
    &apos;/api/opcache/compile&apos;: {
        post: {
            req: PostApiOpcacheCompileData;
            res: {
                200: {
                    totalFiles: number;
                    compiled: number;
                };
                /**
                 * Unauthenticated
                 */
                401: {
                    /**
                     * Error overview.
                     */
                    message: string;
                };
            };
        };
    };
    &apos;/-/horizon/api/jobs/pending&apos;: {
        get: {
            req: GetHorizonApiJobsPendingData;
            res: {
                200: {
                    jobs: string;
                    total: string;
                };
            };
        };
    };
    &apos;/api/playlists&apos;: {
        get: {
            res: {
                /**
                 * Paginated set of `PlaylistResource`
                 */
                200: {
                    data: Array&lt;PlaylistResource&gt;;
                    meta: {
                        /**
                         * Total number of items being paginated.
                         */
                        total: number;
                        /**
                         * The number of items for the current page
                         */
                        count: number;
                        /**
                         * The number of items per page
                         */
                        limit: number;
                        /**
                         * The number of current page
                         */
                        currentPage: number;
                        /**
                         * The number of next page
                         */
                        nextPage: number;
                        /**
                         * The number of last page
                         */
                        lastPage: number;
                    };
                    links: {
                        first: string | null;
                        last: string | null;
                        prev: string | null;
                        next: string | null;
                    };
                };
                /**
                 * Unauthenticated
                 */
                401: {
                    /**
                     * Error overview.
                     */
                    message: string;
                };
            };
        };
        post: {
            req: PostApiPlaylistsData;
            res: {
                /**
                 * `PlaylistResource`
                 */
                200: PlaylistResource;
                /**
                 * Unauthenticated
                 */
                401: {
                    /**
                     * Error overview.
                     */
                    message: string;
                };
                /**
                 * Validation error
                 */
                422: {
                    /**
                     * Errors overview.
                     */
                    message: string;
                    /**
                     * A detailed description of each field that failed validation.
                     */
                    errors: {
                        [key: string]: Array&lt;(string)&gt;;
                    };
                };
            };
        };
    };
    &apos;/api/playlists/{playlist}&apos;: {
        get: {
            req: GetApiPlaylistsByPlaylistData;
            res: {
                /**
                 * `PlaylistResource`
                 */
                200: PlaylistResource;
                /**
                 * Unauthenticated
                 */
                401: {
                    /**
                     * Error overview.
                     */
                    message: string;
                };
                /**
                 * Authorization error
                 */
                403: {
                    /**
                     * Error overview.
                     */
                    message: string;
                };
                /**
                 * Not found
                 */
                404: {
                    /**
                     * Error overview.
                     */
                    message: string;
                };
                /**
                 * Validation error
                 */
                422: {
                    /**
                     * Errors overview.
                     */
                    message: string;
                    /**
                     * A detailed description of each field that failed validation.
                     */
                    errors: {
                        [key: string]: Array&lt;(string)&gt;;
                    };
                };
            };
        };
        put: {
            req: PutApiPlaylistsByPlaylistData;
            res: {
                /**
                 * `PlaylistResource`
                 */
                200: PlaylistResource;
                /**
                 * Unauthenticated
                 */
                401: {
                    /**
                     * Error overview.
                     */
                    message: string;
                };
                /**
                 * Authorization error
                 */
                403: {
                    /**
                     * Error overview.
                     */
                    message: string;
                };
                /**
                 * Not found
                 */
                404: {
                    /**
                     * Error overview.
                     */
                    message: string;
                };
                /**
                 * Validation error
                 */
                422: {
                    /**
                     * Errors overview.
                     */
                    message: string;
                    /**
                     * A detailed description of each field that failed validation.
                     */
                    errors: {
                        [key: string]: Array&lt;(string)&gt;;
                    };
                };
            };
        };
        delete: {
            req: DeleteApiPlaylistsByPlaylistData;
            res: {
                /**
                 * No content
                 */
                204: void;
                /**
                 * Unauthenticated
                 */
                401: {
                    /**
                     * Error overview.
                     */
                    message: string;
                };
                /**
                 * Authorization error
                 */
                403: {
                    /**
                     * Error overview.
                     */
                    message: string;
                };
                /**
                 * Not found
                 */
                404: {
                    /**
                     * Error overview.
                     */
                    message: string;
                };
            };
        };
    };
    &apos;/api/playlists/{playlist}/songs/{song}&apos;: {
        post: {
            req: PostApiPlaylistsByPlaylistSongsBySongData;
            res: {
                200: {
                    message: &apos;Song added to playlist&apos;;
                };
                /**
                 * Unauthenticated
                 */
                401: {
                    /**
                     * Error overview.
                     */
                    message: string;
                };
                /**
                 * Authorization error
                 */
                403: {
                    /**
                     * Error overview.
                     */
                    message: string;
                };
                /**
                 * Not found
                 */
                404: {
                    /**
                     * Error overview.
                     */
                    message: string;
                };
            };
        };
        delete: {
            req: DeleteApiPlaylistsByPlaylistSongsBySongData;
            res: {
                200: {
                    message: &apos;Song removed from playlist&apos;;
                };
                /**
                 * Unauthenticated
                 */
                401: {
                    /**
                     * Error overview.
                     */
                    message: string;
                };
                /**
                 * Authorization error
                 */
                403: {
                    /**
                     * Error overview.
                     */
                    message: string;
                };
                /**
                 * Not found
                 */
                404: {
                    /**
                     * Error overview.
                     */
                    message: string;
                };
            };
        };
    };
    &apos;/api/playlists/{playlist}/reorder&apos;: {
        post: {
            req: PostApiPlaylistsByPlaylistReorderData;
            res: {
                200: {
                    message: &apos;Playlist reordered&apos;;
                };
                /**
                 * Unauthenticated
                 */
                401: {
                    /**
                     * Error overview.
                     */
                    message: string;
                };
                /**
                 * Authorization error
                 */
                403: {
                    /**
                     * Error overview.
                     */
                    message: string;
                };
                /**
                 * Not found
                 */
                404: {
                    /**
                     * Error overview.
                     */
                    message: string;
                };
                /**
                 * Validation error
                 */
                422: {
                    /**
                     * Errors overview.
                     */
                    message: string;
                    /**
                     * A detailed description of each field that failed validation.
                     */
                    errors: {
                        [key: string]: Array&lt;(string)&gt;;
                    };
                };
            };
        };
    };
    &apos;/api/playlists/{playlist}/collaborators&apos;: {
        post: {
            req: PostApiPlaylistsByPlaylistCollaboratorsData;
            res: {
                200: {
                    message: &apos;Collaborator added&apos;;
                };
                /**
                 * Unauthenticated
                 */
                401: {
                    /**
                     * Error overview.
                     */
                    message: string;
                };
                /**
                 * Authorization error
                 */
                403: {
                    /**
                     * Error overview.
                     */
                    message: string;
                };
                /**
                 * Not found
                 */
                404: {
                    /**
                     * Error overview.
                     */
                    message: string;
                };
                /**
                 * Validation error
                 */
                422: {
                    /**
                     * Errors overview.
                     */
                    message: string;
                    /**
                     * A detailed description of each field that failed validation.
                     */
                    errors: {
                        [key: string]: Array&lt;(string)&gt;;
                    };
                };
            };
        };
    };
    &apos;/api/playlists/{playlist}/collaborators/{user}&apos;: {
        delete: {
            req: DeleteApiPlaylistsByPlaylistCollaboratorsByUserData;
            res: {
                200: {
                    message: &apos;Collaborator removed&apos;;
                };
                /**
                 * Unauthenticated
                 */
                401: {
                    /**
                     * Error overview.
                     */
                    message: string;
                };
                /**
                 * Authorization error
                 */
                403: {
                    /**
                     * Error overview.
                     */
                    message: string;
                };
                /**
                 * Not found
                 */
                404: {
                    /**
                     * Error overview.
                     */
                    message: string;
                };
            };
        };
    };
    &apos;/api/playlists/{playlist}/clone&apos;: {
        post: {
            req: PostApiPlaylistsByPlaylistCloneData;
            res: {
                /**
                 * `PlaylistResource`
                 */
                200: PlaylistResource;
                /**
                 * Unauthenticated
                 */
                401: {
                    /**
                     * Error overview.
                     */
                    message: string;
                };
                /**
                 * Authorization error
                 */
                403: {
                    /**
                     * Error overview.
                     */
                    message: string;
                };
                /**
                 * Not found
                 */
                404: {
                    /**
                     * Error overview.
                     */
                    message: string;
                };
            };
        };
    };
    &apos;/api/playlists/{playlist}/statistics&apos;: {
        get: {
            req: GetApiPlaylistsByPlaylistStatisticsData;
            res: {
                /**
                 * `PlaylistStatistic`
                 */
                200: PlaylistStatistic;
                /**
                 * Unauthenticated
                 */
                401: {
                    /**
                     * Error overview.
                     */
                    message: string;
                };
                /**
                 * Authorization error
                 */
                403: {
                    /**
                     * Error overview.
                     */
                    message: string;
                };
                /**
                 * Not found
                 */
                404: {
                    /**
                     * Error overview.
                     */
                    message: string;
                };
            };
        };
    };
    &apos;/api/playlists/{playlist}/statistics/record/view&apos;: {
        post: {
            req: PostApiPlaylistsByPlaylistStatisticsRecordViewData;
            res: {
                200: {
                    message: &apos;View recorded&apos;;
                };
                /**
                 * Unauthenticated
                 */
                401: {
                    /**
                     * Error overview.
                     */
                    message: string;
                };
                /**
                 * Authorization error
                 */
                403: {
                    /**
                     * Error overview.
                     */
                    message: string;
                };
                /**
                 * Not found
                 */
                404: {
                    /**
                     * Error overview.
                     */
                    message: string;
                };
            };
        };
    };
    &apos;/api/playlists/{playlist}/statistics/record/play&apos;: {
        post: {
            req: PostApiPlaylistsByPlaylistStatisticsRecordPlayData;
            res: {
                200: {
                    message: &apos;Play recorded&apos;;
                };
                /**
                 * Unauthenticated
                 */
                401: {
                    /**
                     * Error overview.
                     */
                    message: string;
                };
                /**
                 * Authorization error
                 */
                403: {
                    /**
                     * Error overview.
                     */
                    message: string;
                };
                /**
                 * Not found
                 */
                404: {
                    /**
                     * Error overview.
                     */
                    message: string;
                };
            };
        };
    };
    &apos;/api/playlists/{playlist}/statistics/record/share&apos;: {
        post: {
            req: PostApiPlaylistsByPlaylistStatisticsRecordShareData;
            res: {
                200: {
                    message: &apos;Share recorded&apos;;
                };
                /**
                 * Unauthenticated
                 */
                401: {
                    /**
                     * Error overview.
                     */
                    message: string;
                };
                /**
                 * Authorization error
                 */
                403: {
                    /**
                     * Error overview.
                     */
                    message: string;
                };
                /**
                 * Not found
                 */
                404: {
                    /**
                     * Error overview.
                     */
                    message: string;
                };
            };
        };
    };
    &apos;/api/playlists/{playlist}/statistics/record/favorite&apos;: {
        post: {
            req: PostApiPlaylistsByPlaylistStatisticsRecordFavoriteData;
            res: {
                200: {
                    message: &apos;Favorite recorded&apos;;
                };
                /**
                 * Unauthenticated
                 */
                401: {
                    /**
                     * Error overview.
                     */
                    message: string;
                };
                /**
                 * Authorization error
                 */
                403: {
                    /**
                     * Error overview.
                     */
                    message: string;
                };
                /**
                 * Not found
                 */
                404: {
                    /**
                     * Error overview.
                     */
                    message: string;
                };
            };
        };
    };
    &apos;/api/playlists/smart&apos;: {
        post: {
            req: PostApiPlaylistsSmartData;
            res: {
                /**
                 * `PlaylistResource`
                 */
                200: PlaylistResource;
                /**
                 * Unauthenticated
                 */
                401: {
                    /**
                     * Error overview.
                     */
                    message: string;
                };
                /**
                 * Validation error
                 */
                422: {
                    /**
                     * Errors overview.
                     */
                    message: string;
                    /**
                     * A detailed description of each field that failed validation.
                     */
                    errors: {
                        [key: string]: Array&lt;(string)&gt;;
                    };
                };
            };
        };
    };
    &apos;/api/playlists/{playlist}/smart&apos;: {
        put: {
            req: PutApiPlaylistsByPlaylistSmartData;
            res: {
                /**
                 * `PlaylistResource`
                 */
                200: PlaylistResource;
                /**
                 * An error
                 */
                400: {
                    /**
                     * Error overview.
                     */
                    message: string;
                };
                /**
                 * Unauthenticated
                 */
                401: {
                    /**
                     * Error overview.
                     */
                    message: string;
                };
                /**
                 * Authorization error
                 */
                403: {
                    /**
                     * Error overview.
                     */
                    message: string;
                };
                /**
                 * Not found
                 */
                404: {
                    /**
                     * Error overview.
                     */
                    message: string;
                };
                /**
                 * Validation error
                 */
                422: {
                    /**
                     * Errors overview.
                     */
                    message: string;
                    /**
                     * A detailed description of each field that failed validation.
                     */
                    errors: {
                        [key: string]: Array&lt;(string)&gt;;
                    };
                };
            };
        };
    };
    &apos;/api/playlists/{playlist}/smart/sync&apos;: {
        post: {
            req: PostApiPlaylistsByPlaylistSmartSyncData;
            res: {
                200: {
                    message: &apos;Smart playlist synced&apos;;
                };
                /**
                 * An error
                 */
                400: {
                    /**
                     * Error overview.
                     */
                    message: string;
                };
                /**
                 * Unauthenticated
                 */
                401: {
                    /**
                     * Error overview.
                     */
                    message: string;
                };
                /**
                 * Authorization error
                 */
                403: {
                    /**
                     * Error overview.
                     */
                    message: string;
                };
                /**
                 * Not found
                 */
                404: {
                    /**
                     * Error overview.
                     */
                    message: string;
                };
            };
        };
    };
    &apos;/api/queue-metrics&apos;: {
        get: {
            req: GetApiQueueMetricsData;
            res: {
                /**
                 * Paginated set of `QueueMonitorResource`
                 */
                200: {
                    data: Array&lt;QueueMonitorResource&gt;;
                    meta: {
                        /**
                         * Total number of items being paginated.
                         */
                        total: number;
                        /**
                         * The number of items for the current page
                         */
                        count: number;
                        /**
                         * The number of items per page
                         */
                        limit: number;
                        /**
                         * The number of current page
                         */
                        currentPage: number;
                        /**
                         * The number of next page
                         */
                        nextPage: number;
                        /**
                         * The number of last page
                         */
                        lastPage: number;
                    };
                    links: {
                        first: string | null;
                        last: string | null;
                        prev: string | null;
                        next: string | null;
                    };
                };
                /**
                 * Unauthenticated
                 */
                401: {
                    /**
                     * Error overview.
                     */
                    message: string;
                };
                /**
                 * Validation error
                 */
                422: {
                    /**
                     * Errors overview.
                     */
                    message: string;
                    /**
                     * A detailed description of each field that failed validation.
                     */
                    errors: {
                        [key: string]: Array&lt;(string)&gt;;
                    };
                };
            };
        };
    };
    &apos;/api/queue-metrics/queues&apos;: {
        get: {
            res: {
                200: Array&lt;{
                    name: string;
                }&gt;;
                /**
                 * Unauthenticated
                 */
                401: {
                    /**
                     * Error overview.
                     */
                    message: string;
                };
            };
        };
    };
    &apos;/api/queue-metrics/metrics&apos;: {
        get: {
            req: GetApiQueueMetricsMetricsData;
            res: {
                200: Array&lt;{
                    title: string;
                    value: number;
                    previousValue: number | null;
                    format: string;
                    formattedValue: string;
                    formattedPreviousValue: string | null;
                }&gt;;
                /**
                 * Unauthenticated
                 */
                401: {
                    /**
                     * Error overview.
                     */
                    message: string;
                };
                /**
                 * Validation error
                 */
                422: {
                    /**
                     * Errors overview.
                     */
                    message: string;
                    /**
                     * A detailed description of each field that failed validation.
                     */
                    errors: {
                        [key: string]: Array&lt;(string)&gt;;
                    };
                };
            };
        };
    };
    &apos;/api/queue-metrics/retry/{id}&apos;: {
        post: {
            req: PostApiQueueMetricsRetryByIdData;
            res: {
                200: {
    status: &apos;success&apos;;
    message: &apos;Job has been successfully retried&apos;;
} | {
    status: &apos;failed&apos;;
    message: &apos;An error occurred while executing the job&apos;;
};
                /**
                 * An error
                 */
                400: {
                    /**
                     * Error overview.
                     */
                    message: string;
                };
                /**
                 * Unauthenticated
                 */
                401: {
                    /**
                     * Error overview.
                     */
                    message: string;
                };
                /**
                 * Validation error
                 */
                422: {
                    /**
                     * Errors overview.
                     */
                    message: string;
                    /**
                     * A detailed description of each field that failed validation.
                     */
                    errors: {
                        [key: string]: Array&lt;(string)&gt;;
                    };
                };
            };
        };
    };
    &apos;/api/queue-metrics/{id}&apos;: {
        delete: {
            req: DeleteApiQueueMetricsByIdData;
            res: {
                /**
                 * No content
                 */
                204: void;
                /**
                 * Unauthenticated
                 */
                401: {
                    /**
                     * Error overview.
                     */
                    message: string;
                };
            };
        };
    };
    &apos;/api/queue-metrics/purge&apos;: {
        delete: {
            res: {
                /**
                 * No content
                 */
                204: void;
                /**
                 * Unauthenticated
                 */
                401: {
                    /**
                     * Error overview.
                     */
                    message: string;
                };
            };
        };
    };
    &apos;/-/horizon/api/metrics/queues&apos;: {
        get: {
            res: {
                200: Array&lt;unknown&gt;;
            };
        };
    };
    &apos;/-/horizon/api/metrics/queues/{id}&apos;: {
        get: {
            req: GetHorizonApiMetricsQueuesByIdData;
            res: {
                200: {
                    [key: string]: unknown;
                };
            };
        };
    };
    &apos;/-/horizon/api/jobs/retry/{id}&apos;: {
        post: {
            req: PostHorizonApiJobsRetryByIdData;
            res: {
                200: {
                    [key: string]: unknown;
                };
            };
        };
    };
    &apos;/api/schemas/musicbrainz&apos;: {
        get: {
            res: {
                200: Array&lt;Array&lt;unknown&gt;&gt;;
            };
        };
    };
    &apos;/-/horizon/api/jobs/silenced&apos;: {
        get: {
            req: GetHorizonApiJobsSilencedData;
            res: {
                200: {
                    jobs: string;
                    total: string;
                };
            };
        };
    };
    &apos;/api/libraries/{library}/songs&apos;: {
        get: {
            req: GetApiLibrariesByLibrarySongsData;
            res: {
                /**
                 * Paginated set of `SongResource`
                 */
                200: {
                    data: Array&lt;SongResource&gt;;
                    meta: {
                        /**
                         * Total number of items being paginated.
                         */
                        total: number;
                        /**
                         * The number of items for the current page
                         */
                        count: number;
                        /**
                         * The number of items per page
                         */
                        limit: number;
                        /**
                         * The number of current page
                         */
                        currentPage: number;
                        /**
                         * The number of next page
                         */
                        nextPage: number;
                        /**
                         * The number of last page
                         */
                        lastPage: number;
                    };
                    links: {
                        first: string | null;
                        last: string | null;
                        prev: string | null;
                        next: string | null;
                    };
                };
                /**
                 * An error
                 */
                400: {
                    /**
                     * Error overview.
                     */
                    message: string;
                };
                /**
                 * Unauthenticated
                 */
                401: {
                    /**
                     * Error overview.
                     */
                    message: string;
                };
                /**
                 * Not found
                 */
                404: {
                    /**
                     * Error overview.
                     */
                    message: string;
                };
                /**
                 * Validation error
                 */
                422: {
                    /**
                     * Errors overview.
                     */
                    message: string;
                    /**
                     * A detailed description of each field that failed validation.
                     */
                    errors: {
                        [key: string]: Array&lt;(string)&gt;;
                    };
                };
            };
        };
    };
    &apos;/api/libraries/{library}/songs/{publicId}&apos;: {
        get: {
            req: GetApiLibrariesByLibrarySongsByPublicIdData;
            res: {
                /**
                 * `SongResource`
                 */
                200: SongResource;
                /**
                 * Unauthenticated
                 */
                401: {
                    /**
                     * Error overview.
                     */
                    message: string;
                };
                /**
                 * Not found
                 */
                404: {
                    /**
                     * Error overview.
                     */
                    message: string;
                };
                /**
                 * Validation error
                 */
                422: {
                    /**
                     * Errors overview.
                     */
                    message: string;
                    /**
                     * A detailed description of each field that failed validation.
                     */
                    errors: {
                        [key: string]: Array&lt;(string)&gt;;
                    };
                };
            };
        };
    };
    &apos;/api/stream/song/{song}/direct&apos;: {
        get: {
            req: GetApiStreamSongBySongDirectData;
            res: {
                200: {
                    [key: string]: unknown;
                };
                /**
                 * Unauthenticated
                 */
                401: {
                    /**
                     * Error overview.
                     */
                    message: string;
                };
                /**
                 * Not found
                 */
                404: {
                    /**
                     * Error overview.
                     */
                    message: string;
                };
            };
        };
    };
    &apos;/api/system-info&apos;: {
        get: {
            res: {
                200: Array&lt;{
                    section: string;
                    values: Array&lt;{
                        key: string;
                        value: string | number | boolean | null;
                    }&gt;;
                }&gt;;
                /**
                 * Unauthenticated
                 */
                401: {
                    /**
                     * Error overview.
                     */
                    message: string;
                };
            };
        };
    };
    &apos;/api/system-info/sys&apos;: {
        get: {
            res: {
                200: {
                    memoryUsage: number;
                    systemLoadAverage: Array&lt;(number)&gt;;
                    swooleVm: {
                        object_num: number;
                        resource_num: number;
                    };
                };
                /**
                 * Unauthenticated
                 */
                401: {
                    /**
                     * Error overview.
                     */
                    message: string;
                };
            };
        };
    };
    &apos;/api/users&apos;: {
        get: {
            req: GetApiUsersData;
            res: {
                /**
                 * Paginated set of `UserResource`
                 */
                200: {
                    data: Array&lt;UserResource&gt;;
                    meta: {
                        /**
                         * Total number of items being paginated.
                         */
                        total: number;
                        /**
                         * The number of items for the current page
                         */
                        count: number;
                        /**
                         * The number of items per page
                         */
                        limit: number;
                        /**
                         * The number of current page
                         */
                        currentPage: number;
                        /**
                         * The number of next page
                         */
                        nextPage: number;
                        /**
                         * The number of last page
                         */
                        lastPage: number;
                    };
                    links: {
                        first: string | null;
                        last: string | null;
                        prev: string | null;
                        next: string | null;
                    };
                };
                /**
                 * Unauthenticated
                 */
                401: {
                    /**
                     * Error overview.
                     */
                    message: string;
                };
                /**
                 * Validation error
                 */
                422: {
                    /**
                     * Errors overview.
                     */
                    message: string;
                    /**
                     * A detailed description of each field that failed validation.
                     */
                    errors: {
                        [key: string]: Array&lt;(string)&gt;;
                    };
                };
            };
        };
        post: {
            req: PostApiUsersData;
            res: {
                /**
                 * `UserResource`
                 */
                200: UserResource;
                /**
                 * Unauthenticated
                 */
                401: {
                    /**
                     * Error overview.
                     */
                    message: string;
                };
                /**
                 * Validation error
                 */
                422: {
                    /**
                     * Errors overview.
                     */
                    message: string;
                    /**
                     * A detailed description of each field that failed validation.
                     */
                    errors: {
                        [key: string]: Array&lt;(string)&gt;;
                    };
                };
            };
        };
    };
    &apos;/api/users/{user}&apos;: {
        patch: {
            req: PatchApiUsersByUserData;
            res: {
                /**
                 * `UserResource`
                 */
                200: UserResource;
                /**
                 * Unauthenticated
                 */
                401: {
                    /**
                     * Error overview.
                     */
                    message: string;
                };
                /**
                 * Not found
                 */
                404: {
                    /**
                     * Error overview.
                     */
                    message: string;
                };
                /**
                 * Validation error
                 */
                422: {
                    /**
                     * Errors overview.
                     */
                    message: string;
                    /**
                     * A detailed description of each field that failed validation.
                     */
                    errors: {
                        [key: string]: Array&lt;(string)&gt;;
                    };
                };
            };
        };
        get: {
            req: GetApiUsersByUserData;
            res: {
                /**
                 * `UserResource`
                 */
                200: UserResource;
                /**
                 * Unauthenticated
                 */
                401: {
                    /**
                     * Error overview.
                     */
                    message: string;
                };
                /**
                 * Not found
                 */
                404: {
                    /**
                     * Error overview.
                     */
                    message: string;
                };
            };
        };
        delete: {
            req: DeleteApiUsersByUserData;
            res: {
                /**
                 * No content
                 */
                204: void;
                /**
                 * Unauthenticated
                 */
                401: {
                    /**
                     * Error overview.
                     */
                    message: string;
                };
            };
        };
    };
    &apos;/api/users/me&apos;: {
        get: {
            res: {
                /**
                 * `UserResource`
                 */
                200: UserResource;
                /**
                 * Unauthenticated
                 */
                401: {
                    /**
                     * Error overview.
                     */
                    message: string;
                };
            };
        };
    };
    &apos;/api/users/tokens/{user}&apos;: {
        get: {
            req: GetApiUsersTokensByUserData;
            res: {
                /**
                 * Paginated set of `PersonalAccessTokenViewResource`
                 */
                200: {
                    data: Array&lt;PersonalAccessTokenViewResource&gt;;
                    meta: {
                        /**
                         * Total number of items being paginated.
                         */
                        total: number;
                        /**
                         * The number of items for the current page
                         */
                        count: number;
                        /**
                         * The number of items per page
                         */
                        limit: number;
                        /**
                         * The number of current page
                         */
                        currentPage: number;
                        /**
                         * The number of next page
                         */
                        nextPage: number;
                        /**
                         * The number of last page
                         */
                        lastPage: number;
                    };
                    links: {
                        first: string | null;
                        last: string | null;
                        prev: string | null;
                        next: string | null;
                    };
                };
                /**
                 * Unauthenticated
                 */
                401: {
                    /**
                     * Error overview.
                     */
                    message: string;
                };
                /**
                 * Validation error
                 */
                422: {
                    /**
                     * Errors overview.
                     */
                    message: string;
                    /**
                     * A detailed description of each field that failed validation.
                     */
                    errors: {
                        [key: string]: Array&lt;(string)&gt;;
                    };
                };
            };
        };
    };
    &apos;/api/users/tokens/{token}&apos;: {
        delete: {
            req: DeleteApiUsersTokensByTokenData;
            res: {
                /**
                 * No content
                 */
                204: void;
                /**
                 * Unauthenticated
                 */
                401: {
                    /**
                     * Error overview.
                     */
                    message: string;
                };
                /**
                 * Not found
                 */
                404: {
                    /**
                     * Error overview.
                     */
                    message: string;
                };
            };
        };
    };
    &apos;/-/horizon/api/workload&apos;: {
        get: {
            res: {
                200: Array&lt;unknown&gt;;
            };
        };
    };
};</file></files></repomix>