/**
 * Generated by orval v7.17.2 üç∫
 * Do not edit manually.
 * B√•nder api docs
 * B√•nder.App is a sophisticated media server developed with the primary goal to deliver high performance and seamless experience for users.
Being built on top of Laravel framework and PostgreSQL for database, it leverages the power of robust backend technologies, providing high security, reliability, and scalability.

The main focus of B√•nder.App is efficient media management and delivery.
This application is designed to handle large amounts of media files while ensuring quick and efficient access.
Implemented queuing functionality through Redis offers efficient job management and load handling.
The media information is organized and easily searchable, ensuring users can always find what they are looking for quickly and easily.
 * OpenAPI spec version: 0.0.1
 */
import {
  useInfiniteQuery,
  useQuery,
  useSuspenseInfiniteQuery,
  useSuspenseQuery,
} from "@tanstack/react-query";
import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseInfiniteQueryResult,
  DefinedUseQueryResult,
  InfiniteData,
  QueryClient,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseInfiniteQueryOptions,
  UseInfiniteQueryResult,
  UseQueryOptions,
  UseQueryResult,
  UseSuspenseInfiniteQueryOptions,
  UseSuspenseInfiniteQueryResult,
  UseSuspenseQueryOptions,
  UseSuspenseQueryResult,
} from "@tanstack/react-query";

import type {
  AuthenticationExceptionResponse,
  ModelNotFoundExceptionResponse,
  StreamSongDirect400,
  StreamSongDirect416,
  StreamSongDirect500,
} from "../../models";

import { customInstance } from "../../../axios-instance";
import type { ErrorType } from "../../../axios-instance";

type SecondParameter<T extends (...args: never) => unknown> = Parameters<T>[1];

/**
 * @summary Get an image asset
 */
export const imageServe = (
  image: string,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal
) => {
  return customInstance<Blob>(
    {
      url: `/api/images/${image}`,
      method: "GET",
      responseType: "blob",
      signal,
    },
    options
  );
};

export const getImageServeInfiniteQueryKey = (image?: string) => {
  return ["infinite", `/api/images/${image}`] as const;
};

export const getImageServeQueryKey = (image?: string) => {
  return [`/api/images/${image}`] as const;
};

export const getImageServeInfiniteQueryOptions = <
  TData = InfiniteData<Blob>,
  TError = ErrorType<ModelNotFoundExceptionResponse>
>(
  image: string,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Blob,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getImageServeInfiniteQueryKey(image);

  const queryFn: QueryFunction<Blob> = ({
    signal,
  }) => imageServe(image, requestOptions, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!image,
    ...queryOptions,
  } as UseInfiniteQueryOptions<
    Blob,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type ImageServeInfiniteQueryResult = NonNullable<
  Blob
>;
export type ImageServeInfiniteQueryError =
  ErrorType<ModelNotFoundExceptionResponse>;

export function useImageServeInfinite<
  TData = InfiniteData<Blob>,
  TError = ErrorType<ModelNotFoundExceptionResponse>
>(
  image: string,
  options: {
    query: Partial<
      UseInfiniteQueryOptions<
        Blob,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Blob,
          TError,
          Blob
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): DefinedUseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useImageServeInfinite<
  TData = InfiniteData<Blob>,
  TError = ErrorType<ModelNotFoundExceptionResponse>
>(
  image: string,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Blob,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Blob,
          TError,
          Blob
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useImageServeInfinite<
  TData = InfiniteData<Blob>,
  TError = ErrorType<ModelNotFoundExceptionResponse>
>(
  image: string,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Blob,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get an image asset
 */

export function useImageServeInfinite<
  TData = InfiniteData<Blob>,
  TError = ErrorType<ModelNotFoundExceptionResponse>
>(
  image: string,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Blob,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getImageServeInfiniteQueryOptions(image, options);

  const query = useInfiniteQuery(
    queryOptions,
    queryClient
  ) as UseInfiniteQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getImageServeQueryOptions = <
  TData = Blob,
  TError = ErrorType<ModelNotFoundExceptionResponse>
>(
  image: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Blob, TError, TData>
    >;
    request?: SecondParameter<typeof customInstance>;
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getImageServeQueryKey(image);

  const queryFn: QueryFunction<Blob> = ({
    signal,
  }) => imageServe(image, requestOptions, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!image,
    ...queryOptions,
  } as UseQueryOptions<
    Blob,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type ImageServeQueryResult = NonNullable<
  Blob
>;
export type ImageServeQueryError = ErrorType<ModelNotFoundExceptionResponse>;

export function useImageServe<
  TData = Blob,
  TError = ErrorType<ModelNotFoundExceptionResponse>
>(
  image: string,
  options: {
    query: Partial<
      UseQueryOptions<Blob, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Blob,
          TError,
          Blob
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useImageServe<
  TData = Blob,
  TError = ErrorType<ModelNotFoundExceptionResponse>
>(
  image: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Blob, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Blob,
          TError,
          Blob
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useImageServe<
  TData = Blob,
  TError = ErrorType<ModelNotFoundExceptionResponse>
>(
  image: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Blob, TError, TData>
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get an image asset
 */

export function useImageServe<
  TData = Blob,
  TError = ErrorType<ModelNotFoundExceptionResponse>
>(
  image: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Blob, TError, TData>
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getImageServeQueryOptions(image, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getImageServeSuspenseQueryOptions = <
  TData = Blob,
  TError = ErrorType<ModelNotFoundExceptionResponse>
>(
  image: string,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Blob,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getImageServeQueryKey(image);

  const queryFn: QueryFunction<Blob> = ({
    signal,
  }) => imageServe(image, requestOptions, signal);

  return { queryKey, queryFn, ...queryOptions } as UseSuspenseQueryOptions<
    Blob,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type ImageServeSuspenseQueryResult = NonNullable<
  Blob
>;
export type ImageServeSuspenseQueryError =
  ErrorType<ModelNotFoundExceptionResponse>;

export function useImageServeSuspense<
  TData = Blob,
  TError = ErrorType<ModelNotFoundExceptionResponse>
>(
  image: string,
  options: {
    query: Partial<
      UseSuspenseQueryOptions<
        Blob,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useImageServeSuspense<
  TData = Blob,
  TError = ErrorType<ModelNotFoundExceptionResponse>
>(
  image: string,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Blob,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useImageServeSuspense<
  TData = Blob,
  TError = ErrorType<ModelNotFoundExceptionResponse>
>(
  image: string,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Blob,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get an image asset
 */

export function useImageServeSuspense<
  TData = Blob,
  TError = ErrorType<ModelNotFoundExceptionResponse>
>(
  image: string,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Blob,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getImageServeSuspenseQueryOptions(image, options);

  const query = useSuspenseQuery(
    queryOptions,
    queryClient
  ) as UseSuspenseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getImageServeSuspenseInfiniteQueryOptions = <
  TData = InfiniteData<Blob>,
  TError = ErrorType<ModelNotFoundExceptionResponse>
>(
  image: string,
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Blob,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getImageServeInfiniteQueryKey(image);

  const queryFn: QueryFunction<Blob> = ({
    signal,
  }) => imageServe(image, requestOptions, signal);

  return {
    queryKey,
    queryFn,
    ...queryOptions,
  } as UseSuspenseInfiniteQueryOptions<
    Blob,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type ImageServeSuspenseInfiniteQueryResult = NonNullable<
  Blob
>;
export type ImageServeSuspenseInfiniteQueryError =
  ErrorType<ModelNotFoundExceptionResponse>;

export function useImageServeSuspenseInfinite<
  TData = InfiniteData<Blob>,
  TError = ErrorType<ModelNotFoundExceptionResponse>
>(
  image: string,
  options: {
    query: Partial<
      UseSuspenseInfiniteQueryOptions<
        Blob,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useImageServeSuspenseInfinite<
  TData = InfiniteData<Blob>,
  TError = ErrorType<ModelNotFoundExceptionResponse>
>(
  image: string,
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Blob,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useImageServeSuspenseInfinite<
  TData = InfiniteData<Blob>,
  TError = ErrorType<ModelNotFoundExceptionResponse>
>(
  image: string,
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Blob,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get an image asset
 */

export function useImageServeSuspenseInfinite<
  TData = InfiniteData<Blob>,
  TError = ErrorType<ModelNotFoundExceptionResponse>
>(
  image: string,
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Blob,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getImageServeSuspenseInfiniteQueryOptions(
    image,
    options
  );

  const query = useSuspenseInfiniteQuery(
    queryOptions,
    queryClient
  ) as UseSuspenseInfiniteQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Supports partial content requests for seeking and progressive download.
Returns 206 Partial Content when Range header is present, 200 otherwise.
 * @summary Stream a song file with HTTP Range request support
 */
export const streamSongDirect = (
  song: string,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal
) => {
  return customInstance<string | string>(
    { url: `/api/stream/song/${song}/direct`, method: "GET", signal },
    options
  );
};

export const getStreamSongDirectInfiniteQueryKey = (song?: string) => {
  return ["infinite", `/api/stream/song/${song}/direct`] as const;
};

export const getStreamSongDirectQueryKey = (song?: string) => {
  return [`/api/stream/song/${song}/direct`] as const;
};

export const getStreamSongDirectInfiniteQueryOptions = <
  TData = InfiniteData<Awaited<ReturnType<typeof streamSongDirect>>>,
  TError = ErrorType<
    | StreamSongDirect400
    | AuthenticationExceptionResponse
    | ModelNotFoundExceptionResponse
    | StreamSongDirect416
    | StreamSongDirect500
  >
>(
  song: string,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof streamSongDirect>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getStreamSongDirectInfiniteQueryKey(song);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof streamSongDirect>>
  > = ({ signal }) => streamSongDirect(song, requestOptions, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!song,
    ...queryOptions,
  } as UseInfiniteQueryOptions<
    Awaited<ReturnType<typeof streamSongDirect>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type StreamSongDirectInfiniteQueryResult = NonNullable<
  Awaited<ReturnType<typeof streamSongDirect>>
>;
export type StreamSongDirectInfiniteQueryError = ErrorType<
  | StreamSongDirect400
  | AuthenticationExceptionResponse
  | ModelNotFoundExceptionResponse
  | StreamSongDirect416
  | StreamSongDirect500
>;

export function useStreamSongDirectInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof streamSongDirect>>>,
  TError = ErrorType<
    | StreamSongDirect400
    | AuthenticationExceptionResponse
    | ModelNotFoundExceptionResponse
    | StreamSongDirect416
    | StreamSongDirect500
  >
>(
  song: string,
  options: {
    query: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof streamSongDirect>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof streamSongDirect>>,
          TError,
          Awaited<ReturnType<typeof streamSongDirect>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): DefinedUseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useStreamSongDirectInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof streamSongDirect>>>,
  TError = ErrorType<
    | StreamSongDirect400
    | AuthenticationExceptionResponse
    | ModelNotFoundExceptionResponse
    | StreamSongDirect416
    | StreamSongDirect500
  >
>(
  song: string,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof streamSongDirect>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof streamSongDirect>>,
          TError,
          Awaited<ReturnType<typeof streamSongDirect>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useStreamSongDirectInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof streamSongDirect>>>,
  TError = ErrorType<
    | StreamSongDirect400
    | AuthenticationExceptionResponse
    | ModelNotFoundExceptionResponse
    | StreamSongDirect416
    | StreamSongDirect500
  >
>(
  song: string,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof streamSongDirect>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Stream a song file with HTTP Range request support
 */

export function useStreamSongDirectInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof streamSongDirect>>>,
  TError = ErrorType<
    | StreamSongDirect400
    | AuthenticationExceptionResponse
    | ModelNotFoundExceptionResponse
    | StreamSongDirect416
    | StreamSongDirect500
  >
>(
  song: string,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof streamSongDirect>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getStreamSongDirectInfiniteQueryOptions(song, options);

  const query = useInfiniteQuery(
    queryOptions,
    queryClient
  ) as UseInfiniteQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getStreamSongDirectQueryOptions = <
  TData = Awaited<ReturnType<typeof streamSongDirect>>,
  TError = ErrorType<
    | StreamSongDirect400
    | AuthenticationExceptionResponse
    | ModelNotFoundExceptionResponse
    | StreamSongDirect416
    | StreamSongDirect500
  >
>(
  song: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof streamSongDirect>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getStreamSongDirectQueryKey(song);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof streamSongDirect>>
  > = ({ signal }) => streamSongDirect(song, requestOptions, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!song,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof streamSongDirect>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type StreamSongDirectQueryResult = NonNullable<
  Awaited<ReturnType<typeof streamSongDirect>>
>;
export type StreamSongDirectQueryError = ErrorType<
  | StreamSongDirect400
  | AuthenticationExceptionResponse
  | ModelNotFoundExceptionResponse
  | StreamSongDirect416
  | StreamSongDirect500
>;

export function useStreamSongDirect<
  TData = Awaited<ReturnType<typeof streamSongDirect>>,
  TError = ErrorType<
    | StreamSongDirect400
    | AuthenticationExceptionResponse
    | ModelNotFoundExceptionResponse
    | StreamSongDirect416
    | StreamSongDirect500
  >
>(
  song: string,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof streamSongDirect>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof streamSongDirect>>,
          TError,
          Awaited<ReturnType<typeof streamSongDirect>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useStreamSongDirect<
  TData = Awaited<ReturnType<typeof streamSongDirect>>,
  TError = ErrorType<
    | StreamSongDirect400
    | AuthenticationExceptionResponse
    | ModelNotFoundExceptionResponse
    | StreamSongDirect416
    | StreamSongDirect500
  >
>(
  song: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof streamSongDirect>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof streamSongDirect>>,
          TError,
          Awaited<ReturnType<typeof streamSongDirect>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useStreamSongDirect<
  TData = Awaited<ReturnType<typeof streamSongDirect>>,
  TError = ErrorType<
    | StreamSongDirect400
    | AuthenticationExceptionResponse
    | ModelNotFoundExceptionResponse
    | StreamSongDirect416
    | StreamSongDirect500
  >
>(
  song: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof streamSongDirect>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Stream a song file with HTTP Range request support
 */

export function useStreamSongDirect<
  TData = Awaited<ReturnType<typeof streamSongDirect>>,
  TError = ErrorType<
    | StreamSongDirect400
    | AuthenticationExceptionResponse
    | ModelNotFoundExceptionResponse
    | StreamSongDirect416
    | StreamSongDirect500
  >
>(
  song: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof streamSongDirect>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getStreamSongDirectQueryOptions(song, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getStreamSongDirectSuspenseQueryOptions = <
  TData = Awaited<ReturnType<typeof streamSongDirect>>,
  TError = ErrorType<
    | StreamSongDirect400
    | AuthenticationExceptionResponse
    | ModelNotFoundExceptionResponse
    | StreamSongDirect416
    | StreamSongDirect500
  >
>(
  song: string,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof streamSongDirect>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getStreamSongDirectQueryKey(song);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof streamSongDirect>>
  > = ({ signal }) => streamSongDirect(song, requestOptions, signal);

  return { queryKey, queryFn, ...queryOptions } as UseSuspenseQueryOptions<
    Awaited<ReturnType<typeof streamSongDirect>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type StreamSongDirectSuspenseQueryResult = NonNullable<
  Awaited<ReturnType<typeof streamSongDirect>>
>;
export type StreamSongDirectSuspenseQueryError = ErrorType<
  | StreamSongDirect400
  | AuthenticationExceptionResponse
  | ModelNotFoundExceptionResponse
  | StreamSongDirect416
  | StreamSongDirect500
>;

export function useStreamSongDirectSuspense<
  TData = Awaited<ReturnType<typeof streamSongDirect>>,
  TError = ErrorType<
    | StreamSongDirect400
    | AuthenticationExceptionResponse
    | ModelNotFoundExceptionResponse
    | StreamSongDirect416
    | StreamSongDirect500
  >
>(
  song: string,
  options: {
    query: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof streamSongDirect>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useStreamSongDirectSuspense<
  TData = Awaited<ReturnType<typeof streamSongDirect>>,
  TError = ErrorType<
    | StreamSongDirect400
    | AuthenticationExceptionResponse
    | ModelNotFoundExceptionResponse
    | StreamSongDirect416
    | StreamSongDirect500
  >
>(
  song: string,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof streamSongDirect>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useStreamSongDirectSuspense<
  TData = Awaited<ReturnType<typeof streamSongDirect>>,
  TError = ErrorType<
    | StreamSongDirect400
    | AuthenticationExceptionResponse
    | ModelNotFoundExceptionResponse
    | StreamSongDirect416
    | StreamSongDirect500
  >
>(
  song: string,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof streamSongDirect>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Stream a song file with HTTP Range request support
 */

export function useStreamSongDirectSuspense<
  TData = Awaited<ReturnType<typeof streamSongDirect>>,
  TError = ErrorType<
    | StreamSongDirect400
    | AuthenticationExceptionResponse
    | ModelNotFoundExceptionResponse
    | StreamSongDirect416
    | StreamSongDirect500
  >
>(
  song: string,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof streamSongDirect>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getStreamSongDirectSuspenseQueryOptions(song, options);

  const query = useSuspenseQuery(
    queryOptions,
    queryClient
  ) as UseSuspenseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getStreamSongDirectSuspenseInfiniteQueryOptions = <
  TData = InfiniteData<Awaited<ReturnType<typeof streamSongDirect>>>,
  TError = ErrorType<
    | StreamSongDirect400
    | AuthenticationExceptionResponse
    | ModelNotFoundExceptionResponse
    | StreamSongDirect416
    | StreamSongDirect500
  >
>(
  song: string,
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof streamSongDirect>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getStreamSongDirectInfiniteQueryKey(song);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof streamSongDirect>>
  > = ({ signal }) => streamSongDirect(song, requestOptions, signal);

  return {
    queryKey,
    queryFn,
    ...queryOptions,
  } as UseSuspenseInfiniteQueryOptions<
    Awaited<ReturnType<typeof streamSongDirect>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type StreamSongDirectSuspenseInfiniteQueryResult = NonNullable<
  Awaited<ReturnType<typeof streamSongDirect>>
>;
export type StreamSongDirectSuspenseInfiniteQueryError = ErrorType<
  | StreamSongDirect400
  | AuthenticationExceptionResponse
  | ModelNotFoundExceptionResponse
  | StreamSongDirect416
  | StreamSongDirect500
>;

export function useStreamSongDirectSuspenseInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof streamSongDirect>>>,
  TError = ErrorType<
    | StreamSongDirect400
    | AuthenticationExceptionResponse
    | ModelNotFoundExceptionResponse
    | StreamSongDirect416
    | StreamSongDirect500
  >
>(
  song: string,
  options: {
    query: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof streamSongDirect>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useStreamSongDirectSuspenseInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof streamSongDirect>>>,
  TError = ErrorType<
    | StreamSongDirect400
    | AuthenticationExceptionResponse
    | ModelNotFoundExceptionResponse
    | StreamSongDirect416
    | StreamSongDirect500
  >
>(
  song: string,
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof streamSongDirect>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useStreamSongDirectSuspenseInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof streamSongDirect>>>,
  TError = ErrorType<
    | StreamSongDirect400
    | AuthenticationExceptionResponse
    | ModelNotFoundExceptionResponse
    | StreamSongDirect416
    | StreamSongDirect500
  >
>(
  song: string,
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof streamSongDirect>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Stream a song file with HTTP Range request support
 */

export function useStreamSongDirectSuspenseInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof streamSongDirect>>>,
  TError = ErrorType<
    | StreamSongDirect400
    | AuthenticationExceptionResponse
    | ModelNotFoundExceptionResponse
    | StreamSongDirect416
    | StreamSongDirect500
  >
>(
  song: string,
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof streamSongDirect>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getStreamSongDirectSuspenseInfiniteQueryOptions(
    song,
    options
  );

  const query = useSuspenseInfiniteQuery(
    queryOptions,
    queryClient
  ) as UseSuspenseInfiniteQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}
