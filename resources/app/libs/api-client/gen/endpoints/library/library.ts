/**
 * Generated by orval v7.11.2 üç∫
 * Do not edit manually.
 * B√•nder api docs
 * B√•nder.App is a sophisticated media server developed with the primary goal to deliver high performance and seamless experience for users.
Being built on top of Laravel framework and PostgreSQL for database, it leverages the power of robust backend technologies, providing high security, reliability, and scalability.

The main focus of B√•nder.App is efficient media management and delivery.
This application is designed to handle large amounts of media files while ensuring quick and efficient access.
Implemented queuing functionality through Redis offers efficient job management and load handling.
The media information is organized and easily searchable, ensuring users can always find what they are looking for quickly and easily.
 * OpenAPI spec version: 0.0.1
 */
import {
  useInfiniteQuery,
  useMutation,
  useQuery,
  useSuspenseInfiniteQuery,
  useSuspenseQuery,
} from "@tanstack/react-query";
import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseInfiniteQueryResult,
  DefinedUseQueryResult,
  InfiniteData,
  MutationFunction,
  QueryClient,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseInfiniteQueryOptions,
  UseInfiniteQueryResult,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult,
  UseSuspenseInfiniteQueryOptions,
  UseSuspenseInfiniteQueryResult,
  UseSuspenseQueryOptions,
  UseSuspenseQueryResult,
} from "@tanstack/react-query";

import type {
  AuthenticationExceptionResponse,
  AuthorizationExceptionResponse,
  CreateLibraryRequest,
  LibrariesIndex200,
  LibrariesIndexParams,
  LibraryResource,
  UpdateLibraryRequest,
  ValidationExceptionResponse,
} from "../../models";

import { customInstance } from "../../../axios-instance";
import type { ErrorType, BodyType } from "../../../axios-instance";

type SecondParameter<T extends (...args: never) => unknown> = Parameters<T>[1];

/**
 * @summary Get a collection of media libraries
 */
export const librariesIndex = (
  params?: LibrariesIndexParams,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal
) => {
  return customInstance<LibrariesIndex200>(
    { url: `/api/libraries`, method: "GET", params, signal },
    options
  );
};

export const getLibrariesIndexQueryKey = (params?: LibrariesIndexParams) => {
  return [`/api/libraries`, ...(params ? [params] : [])] as const;
};

export const getLibrariesIndexInfiniteQueryOptions = <
  TData = InfiniteData<
    Awaited<ReturnType<typeof librariesIndex>>,
    LibrariesIndexParams["limit"]
  >,
  TError = ErrorType<
    AuthenticationExceptionResponse | ValidationExceptionResponse
  >
>(
  params?: LibrariesIndexParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof librariesIndex>>,
        TError,
        TData,
        QueryKey,
        LibrariesIndexParams["limit"]
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getLibrariesIndexQueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof librariesIndex>>,
    QueryKey,
    LibrariesIndexParams["limit"]
  > = ({ signal, pageParam }) =>
    librariesIndex(
      { ...params, limit: pageParam || params?.["limit"] },
      requestOptions,
      signal
    );

  return { queryKey, queryFn, ...queryOptions } as UseInfiniteQueryOptions<
    Awaited<ReturnType<typeof librariesIndex>>,
    TError,
    TData,
    QueryKey,
    LibrariesIndexParams["limit"]
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type LibrariesIndexInfiniteQueryResult = NonNullable<
  Awaited<ReturnType<typeof librariesIndex>>
>;
export type LibrariesIndexInfiniteQueryError = ErrorType<
  AuthenticationExceptionResponse | ValidationExceptionResponse
>;

export function useLibrariesIndexInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof librariesIndex>>,
    LibrariesIndexParams["limit"]
  >,
  TError = ErrorType<
    AuthenticationExceptionResponse | ValidationExceptionResponse
  >
>(
  params: undefined | LibrariesIndexParams,
  options: {
    query: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof librariesIndex>>,
        TError,
        TData,
        QueryKey,
        LibrariesIndexParams["limit"]
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof librariesIndex>>,
          TError,
          Awaited<ReturnType<typeof librariesIndex>>,
          QueryKey
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): DefinedUseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useLibrariesIndexInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof librariesIndex>>,
    LibrariesIndexParams["limit"]
  >,
  TError = ErrorType<
    AuthenticationExceptionResponse | ValidationExceptionResponse
  >
>(
  params?: LibrariesIndexParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof librariesIndex>>,
        TError,
        TData,
        QueryKey,
        LibrariesIndexParams["limit"]
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof librariesIndex>>,
          TError,
          Awaited<ReturnType<typeof librariesIndex>>,
          QueryKey
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useLibrariesIndexInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof librariesIndex>>,
    LibrariesIndexParams["limit"]
  >,
  TError = ErrorType<
    AuthenticationExceptionResponse | ValidationExceptionResponse
  >
>(
  params?: LibrariesIndexParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof librariesIndex>>,
        TError,
        TData,
        QueryKey,
        LibrariesIndexParams["limit"]
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get a collection of media libraries
 */

export function useLibrariesIndexInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof librariesIndex>>,
    LibrariesIndexParams["limit"]
  >,
  TError = ErrorType<
    AuthenticationExceptionResponse | ValidationExceptionResponse
  >
>(
  params?: LibrariesIndexParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof librariesIndex>>,
        TError,
        TData,
        QueryKey,
        LibrariesIndexParams["limit"]
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getLibrariesIndexInfiniteQueryOptions(params, options);

  const query = useInfiniteQuery(
    queryOptions,
    queryClient
  ) as UseInfiniteQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getLibrariesIndexQueryOptions = <
  TData = Awaited<ReturnType<typeof librariesIndex>>,
  TError = ErrorType<
    AuthenticationExceptionResponse | ValidationExceptionResponse
  >
>(
  params?: LibrariesIndexParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof librariesIndex>>, TError, TData>
    >;
    request?: SecondParameter<typeof customInstance>;
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getLibrariesIndexQueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof librariesIndex>>> = ({
    signal,
  }) => librariesIndex(params, requestOptions, signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof librariesIndex>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type LibrariesIndexQueryResult = NonNullable<
  Awaited<ReturnType<typeof librariesIndex>>
>;
export type LibrariesIndexQueryError = ErrorType<
  AuthenticationExceptionResponse | ValidationExceptionResponse
>;

export function useLibrariesIndex<
  TData = Awaited<ReturnType<typeof librariesIndex>>,
  TError = ErrorType<
    AuthenticationExceptionResponse | ValidationExceptionResponse
  >
>(
  params: undefined | LibrariesIndexParams,
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof librariesIndex>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof librariesIndex>>,
          TError,
          Awaited<ReturnType<typeof librariesIndex>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useLibrariesIndex<
  TData = Awaited<ReturnType<typeof librariesIndex>>,
  TError = ErrorType<
    AuthenticationExceptionResponse | ValidationExceptionResponse
  >
>(
  params?: LibrariesIndexParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof librariesIndex>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof librariesIndex>>,
          TError,
          Awaited<ReturnType<typeof librariesIndex>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useLibrariesIndex<
  TData = Awaited<ReturnType<typeof librariesIndex>>,
  TError = ErrorType<
    AuthenticationExceptionResponse | ValidationExceptionResponse
  >
>(
  params?: LibrariesIndexParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof librariesIndex>>, TError, TData>
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get a collection of media libraries
 */

export function useLibrariesIndex<
  TData = Awaited<ReturnType<typeof librariesIndex>>,
  TError = ErrorType<
    AuthenticationExceptionResponse | ValidationExceptionResponse
  >
>(
  params?: LibrariesIndexParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof librariesIndex>>, TError, TData>
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getLibrariesIndexQueryOptions(params, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getLibrariesIndexSuspenseQueryOptions = <
  TData = Awaited<ReturnType<typeof librariesIndex>>,
  TError = ErrorType<
    AuthenticationExceptionResponse | ValidationExceptionResponse
  >
>(
  params?: LibrariesIndexParams,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof librariesIndex>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getLibrariesIndexQueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof librariesIndex>>> = ({
    signal,
  }) => librariesIndex(params, requestOptions, signal);

  return { queryKey, queryFn, ...queryOptions } as UseSuspenseQueryOptions<
    Awaited<ReturnType<typeof librariesIndex>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type LibrariesIndexSuspenseQueryResult = NonNullable<
  Awaited<ReturnType<typeof librariesIndex>>
>;
export type LibrariesIndexSuspenseQueryError = ErrorType<
  AuthenticationExceptionResponse | ValidationExceptionResponse
>;

export function useLibrariesIndexSuspense<
  TData = Awaited<ReturnType<typeof librariesIndex>>,
  TError = ErrorType<
    AuthenticationExceptionResponse | ValidationExceptionResponse
  >
>(
  params: undefined | LibrariesIndexParams,
  options: {
    query: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof librariesIndex>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useLibrariesIndexSuspense<
  TData = Awaited<ReturnType<typeof librariesIndex>>,
  TError = ErrorType<
    AuthenticationExceptionResponse | ValidationExceptionResponse
  >
>(
  params?: LibrariesIndexParams,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof librariesIndex>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useLibrariesIndexSuspense<
  TData = Awaited<ReturnType<typeof librariesIndex>>,
  TError = ErrorType<
    AuthenticationExceptionResponse | ValidationExceptionResponse
  >
>(
  params?: LibrariesIndexParams,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof librariesIndex>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get a collection of media libraries
 */

export function useLibrariesIndexSuspense<
  TData = Awaited<ReturnType<typeof librariesIndex>>,
  TError = ErrorType<
    AuthenticationExceptionResponse | ValidationExceptionResponse
  >
>(
  params?: LibrariesIndexParams,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof librariesIndex>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getLibrariesIndexSuspenseQueryOptions(params, options);

  const query = useSuspenseQuery(
    queryOptions,
    queryClient
  ) as UseSuspenseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getLibrariesIndexSuspenseInfiniteQueryOptions = <
  TData = InfiniteData<
    Awaited<ReturnType<typeof librariesIndex>>,
    LibrariesIndexParams["limit"]
  >,
  TError = ErrorType<
    AuthenticationExceptionResponse | ValidationExceptionResponse
  >
>(
  params?: LibrariesIndexParams,
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof librariesIndex>>,
        TError,
        TData,
        QueryKey,
        LibrariesIndexParams["limit"]
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getLibrariesIndexQueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof librariesIndex>>,
    QueryKey,
    LibrariesIndexParams["limit"]
  > = ({ signal, pageParam }) =>
    librariesIndex(
      { ...params, limit: pageParam || params?.["limit"] },
      requestOptions,
      signal
    );

  return {
    queryKey,
    queryFn,
    ...queryOptions,
  } as UseSuspenseInfiniteQueryOptions<
    Awaited<ReturnType<typeof librariesIndex>>,
    TError,
    TData,
    QueryKey,
    LibrariesIndexParams["limit"]
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type LibrariesIndexSuspenseInfiniteQueryResult = NonNullable<
  Awaited<ReturnType<typeof librariesIndex>>
>;
export type LibrariesIndexSuspenseInfiniteQueryError = ErrorType<
  AuthenticationExceptionResponse | ValidationExceptionResponse
>;

export function useLibrariesIndexSuspenseInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof librariesIndex>>,
    LibrariesIndexParams["limit"]
  >,
  TError = ErrorType<
    AuthenticationExceptionResponse | ValidationExceptionResponse
  >
>(
  params: undefined | LibrariesIndexParams,
  options: {
    query: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof librariesIndex>>,
        TError,
        TData,
        QueryKey,
        LibrariesIndexParams["limit"]
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useLibrariesIndexSuspenseInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof librariesIndex>>,
    LibrariesIndexParams["limit"]
  >,
  TError = ErrorType<
    AuthenticationExceptionResponse | ValidationExceptionResponse
  >
>(
  params?: LibrariesIndexParams,
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof librariesIndex>>,
        TError,
        TData,
        QueryKey,
        LibrariesIndexParams["limit"]
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useLibrariesIndexSuspenseInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof librariesIndex>>,
    LibrariesIndexParams["limit"]
  >,
  TError = ErrorType<
    AuthenticationExceptionResponse | ValidationExceptionResponse
  >
>(
  params?: LibrariesIndexParams,
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof librariesIndex>>,
        TError,
        TData,
        QueryKey,
        LibrariesIndexParams["limit"]
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get a collection of media libraries
 */

export function useLibrariesIndexSuspenseInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof librariesIndex>>,
    LibrariesIndexParams["limit"]
  >,
  TError = ErrorType<
    AuthenticationExceptionResponse | ValidationExceptionResponse
  >
>(
  params?: LibrariesIndexParams,
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof librariesIndex>>,
        TError,
        TData,
        QueryKey,
        LibrariesIndexParams["limit"]
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getLibrariesIndexSuspenseInfiniteQueryOptions(
    params,
    options
  );

  const query = useSuspenseInfiniteQuery(
    queryOptions,
    queryClient
  ) as UseSuspenseInfiniteQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Create a library
 */
export const libraryCreate = (
  createLibraryRequest: BodyType<CreateLibraryRequest>,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal
) => {
  return customInstance<LibraryResource>(
    {
      url: `/api/libraries`,
      method: "POST",
      headers: { "Content-Type": "application/json" },
      data: createLibraryRequest,
      signal,
    },
    options
  );
};

export const getLibraryCreateMutationOptions = <
  TError = ErrorType<
    AuthenticationExceptionResponse | ValidationExceptionResponse
  >,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof libraryCreate>>,
    TError,
    { data: BodyType<CreateLibraryRequest> },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof libraryCreate>>,
  TError,
  { data: BodyType<CreateLibraryRequest> },
  TContext
> => {
  const mutationKey = ["libraryCreate"];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof libraryCreate>>,
    { data: BodyType<CreateLibraryRequest> }
  > = (props) => {
    const { data } = props ?? {};

    return libraryCreate(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type LibraryCreateMutationResult = NonNullable<
  Awaited<ReturnType<typeof libraryCreate>>
>;
export type LibraryCreateMutationBody = BodyType<CreateLibraryRequest>;
export type LibraryCreateMutationError = ErrorType<
  AuthenticationExceptionResponse | ValidationExceptionResponse
>;

/**
 * @summary Create a library
 */
export const useLibraryCreate = <
  TError = ErrorType<
    AuthenticationExceptionResponse | ValidationExceptionResponse
  >,
  TContext = unknown
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof libraryCreate>>,
      TError,
      { data: BodyType<CreateLibraryRequest> },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof libraryCreate>>,
  TError,
  { data: BodyType<CreateLibraryRequest> },
  TContext
> => {
  const mutationOptions = getLibraryCreateMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
/**
 * @summary Show library
 */
export const libraryShow = (
  slug: string,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal
) => {
  return customInstance<LibraryResource>(
    { url: `/api/libraries/${slug}`, method: "GET", signal },
    options
  );
};

export const getLibraryShowQueryKey = (slug?: string) => {
  return [`/api/libraries/${slug}`] as const;
};

export const getLibraryShowInfiniteQueryOptions = <
  TData = InfiniteData<Awaited<ReturnType<typeof libraryShow>>>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(
  slug: string,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof libraryShow>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getLibraryShowQueryKey(slug);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof libraryShow>>> = ({
    signal,
  }) => libraryShow(slug, requestOptions, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!slug,
    ...queryOptions,
  } as UseInfiniteQueryOptions<
    Awaited<ReturnType<typeof libraryShow>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type LibraryShowInfiniteQueryResult = NonNullable<
  Awaited<ReturnType<typeof libraryShow>>
>;
export type LibraryShowInfiniteQueryError =
  ErrorType<AuthenticationExceptionResponse>;

export function useLibraryShowInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof libraryShow>>>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(
  slug: string,
  options: {
    query: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof libraryShow>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof libraryShow>>,
          TError,
          Awaited<ReturnType<typeof libraryShow>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): DefinedUseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useLibraryShowInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof libraryShow>>>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(
  slug: string,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof libraryShow>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof libraryShow>>,
          TError,
          Awaited<ReturnType<typeof libraryShow>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useLibraryShowInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof libraryShow>>>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(
  slug: string,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof libraryShow>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Show library
 */

export function useLibraryShowInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof libraryShow>>>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(
  slug: string,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof libraryShow>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getLibraryShowInfiniteQueryOptions(slug, options);

  const query = useInfiniteQuery(
    queryOptions,
    queryClient
  ) as UseInfiniteQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getLibraryShowQueryOptions = <
  TData = Awaited<ReturnType<typeof libraryShow>>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(
  slug: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof libraryShow>>, TError, TData>
    >;
    request?: SecondParameter<typeof customInstance>;
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getLibraryShowQueryKey(slug);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof libraryShow>>> = ({
    signal,
  }) => libraryShow(slug, requestOptions, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!slug,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof libraryShow>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type LibraryShowQueryResult = NonNullable<
  Awaited<ReturnType<typeof libraryShow>>
>;
export type LibraryShowQueryError = ErrorType<AuthenticationExceptionResponse>;

export function useLibraryShow<
  TData = Awaited<ReturnType<typeof libraryShow>>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(
  slug: string,
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof libraryShow>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof libraryShow>>,
          TError,
          Awaited<ReturnType<typeof libraryShow>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useLibraryShow<
  TData = Awaited<ReturnType<typeof libraryShow>>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(
  slug: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof libraryShow>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof libraryShow>>,
          TError,
          Awaited<ReturnType<typeof libraryShow>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useLibraryShow<
  TData = Awaited<ReturnType<typeof libraryShow>>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(
  slug: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof libraryShow>>, TError, TData>
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Show library
 */

export function useLibraryShow<
  TData = Awaited<ReturnType<typeof libraryShow>>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(
  slug: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof libraryShow>>, TError, TData>
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getLibraryShowQueryOptions(slug, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getLibraryShowSuspenseQueryOptions = <
  TData = Awaited<ReturnType<typeof libraryShow>>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(
  slug: string,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof libraryShow>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getLibraryShowQueryKey(slug);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof libraryShow>>> = ({
    signal,
  }) => libraryShow(slug, requestOptions, signal);

  return { queryKey, queryFn, ...queryOptions } as UseSuspenseQueryOptions<
    Awaited<ReturnType<typeof libraryShow>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type LibraryShowSuspenseQueryResult = NonNullable<
  Awaited<ReturnType<typeof libraryShow>>
>;
export type LibraryShowSuspenseQueryError =
  ErrorType<AuthenticationExceptionResponse>;

export function useLibraryShowSuspense<
  TData = Awaited<ReturnType<typeof libraryShow>>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(
  slug: string,
  options: {
    query: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof libraryShow>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useLibraryShowSuspense<
  TData = Awaited<ReturnType<typeof libraryShow>>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(
  slug: string,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof libraryShow>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useLibraryShowSuspense<
  TData = Awaited<ReturnType<typeof libraryShow>>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(
  slug: string,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof libraryShow>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Show library
 */

export function useLibraryShowSuspense<
  TData = Awaited<ReturnType<typeof libraryShow>>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(
  slug: string,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof libraryShow>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getLibraryShowSuspenseQueryOptions(slug, options);

  const query = useSuspenseQuery(
    queryOptions,
    queryClient
  ) as UseSuspenseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getLibraryShowSuspenseInfiniteQueryOptions = <
  TData = InfiniteData<Awaited<ReturnType<typeof libraryShow>>>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(
  slug: string,
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof libraryShow>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getLibraryShowQueryKey(slug);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof libraryShow>>> = ({
    signal,
  }) => libraryShow(slug, requestOptions, signal);

  return {
    queryKey,
    queryFn,
    ...queryOptions,
  } as UseSuspenseInfiniteQueryOptions<
    Awaited<ReturnType<typeof libraryShow>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type LibraryShowSuspenseInfiniteQueryResult = NonNullable<
  Awaited<ReturnType<typeof libraryShow>>
>;
export type LibraryShowSuspenseInfiniteQueryError =
  ErrorType<AuthenticationExceptionResponse>;

export function useLibraryShowSuspenseInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof libraryShow>>>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(
  slug: string,
  options: {
    query: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof libraryShow>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useLibraryShowSuspenseInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof libraryShow>>>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(
  slug: string,
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof libraryShow>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useLibraryShowSuspenseInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof libraryShow>>>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(
  slug: string,
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof libraryShow>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Show library
 */

export function useLibraryShowSuspenseInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof libraryShow>>>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(
  slug: string,
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof libraryShow>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getLibraryShowSuspenseInfiniteQueryOptions(
    slug,
    options
  );

  const query = useSuspenseInfiniteQuery(
    queryOptions,
    queryClient
  ) as UseSuspenseInfiniteQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Update a library specified by the provided slug
 */
export const libraryUpdate = (
  slug: string,
  updateLibraryRequest: BodyType<UpdateLibraryRequest>,
  options?: SecondParameter<typeof customInstance>
) => {
  return customInstance<LibraryResource>(
    {
      url: `/api/libraries/${slug}`,
      method: "PATCH",
      headers: { "Content-Type": "application/json" },
      data: updateLibraryRequest,
    },
    options
  );
};

export const getLibraryUpdateMutationOptions = <
  TError = ErrorType<
    | AuthenticationExceptionResponse
    | AuthorizationExceptionResponse
    | ValidationExceptionResponse
  >,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof libraryUpdate>>,
    TError,
    { slug: string; data: BodyType<UpdateLibraryRequest> },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof libraryUpdate>>,
  TError,
  { slug: string; data: BodyType<UpdateLibraryRequest> },
  TContext
> => {
  const mutationKey = ["libraryUpdate"];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof libraryUpdate>>,
    { slug: string; data: BodyType<UpdateLibraryRequest> }
  > = (props) => {
    const { slug, data } = props ?? {};

    return libraryUpdate(slug, data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type LibraryUpdateMutationResult = NonNullable<
  Awaited<ReturnType<typeof libraryUpdate>>
>;
export type LibraryUpdateMutationBody = BodyType<UpdateLibraryRequest>;
export type LibraryUpdateMutationError = ErrorType<
  | AuthenticationExceptionResponse
  | AuthorizationExceptionResponse
  | ValidationExceptionResponse
>;

/**
 * @summary Update a library specified by the provided slug
 */
export const useLibraryUpdate = <
  TError = ErrorType<
    | AuthenticationExceptionResponse
    | AuthorizationExceptionResponse
    | ValidationExceptionResponse
  >,
  TContext = unknown
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof libraryUpdate>>,
      TError,
      { slug: string; data: BodyType<UpdateLibraryRequest> },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof libraryUpdate>>,
  TError,
  { slug: string; data: BodyType<UpdateLibraryRequest> },
  TContext
> => {
  const mutationOptions = getLibraryUpdateMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
/**
 * @summary Delete a library
 */
export const libraryDelete = (
  slug: string,
  options?: SecondParameter<typeof customInstance>
) => {
  return customInstance<null>(
    { url: `/api/libraries/${slug}`, method: "DELETE" },
    options
  );
};

export const getLibraryDeleteMutationOptions = <
  TError = ErrorType<AuthenticationExceptionResponse>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof libraryDelete>>,
    TError,
    { slug: string },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof libraryDelete>>,
  TError,
  { slug: string },
  TContext
> => {
  const mutationKey = ["libraryDelete"];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof libraryDelete>>,
    { slug: string }
  > = (props) => {
    const { slug } = props ?? {};

    return libraryDelete(slug, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type LibraryDeleteMutationResult = NonNullable<
  Awaited<ReturnType<typeof libraryDelete>>
>;

export type LibraryDeleteMutationError =
  ErrorType<AuthenticationExceptionResponse>;

/**
 * @summary Delete a library
 */
export const useLibraryDelete = <
  TError = ErrorType<AuthenticationExceptionResponse>,
  TContext = unknown
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof libraryDelete>>,
      TError,
      { slug: string },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof libraryDelete>>,
  TError,
  { slug: string },
  TContext
> => {
  const mutationOptions = getLibraryDeleteMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
