/**
 * Generated by orval v7.11.2 üç∫
 * Do not edit manually.
 * B√•nder api docs
 * B√•nder.App is a sophisticated media server developed with the primary goal to deliver high performance and seamless experience for users.
Being built on top of Laravel framework and PostgreSQL for database, it leverages the power of robust backend technologies, providing high security, reliability, and scalability.

The main focus of B√•nder.App is efficient media management and delivery.
This application is designed to handle large amounts of media files while ensuring quick and efficient access.
Implemented queuing functionality through Redis offers efficient job management and load handling.
The media information is organized and easily searchable, ensuring users can always find what they are looking for quickly and easily.
 * OpenAPI spec version: 0.0.1
 */
import {
  useInfiniteQuery,
  useQuery,
  useSuspenseInfiniteQuery,
  useSuspenseQuery,
} from "@tanstack/react-query";
import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseInfiniteQueryResult,
  DefinedUseQueryResult,
  InfiniteData,
  QueryClient,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseInfiniteQueryOptions,
  UseInfiniteQueryResult,
  UseQueryOptions,
  UseQueryResult,
  UseSuspenseInfiniteQueryOptions,
  UseSuspenseInfiniteQueryResult,
  UseSuspenseQueryOptions,
  UseSuspenseQueryResult,
} from "@tanstack/react-query";

import { customInstance } from "../../../axios-instance";
import type { ErrorType } from "../../../axios-instance";

type SecondParameter<T extends (...args: never) => unknown> = Parameters<T>[1];

export const schemaFetchSchema = (
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal
) => {
  return customInstance<unknown[][]>(
    { url: `/api/schemas/musicbrainz`, method: "GET", signal },
    options
  );
};

export const getSchemaFetchSchemaQueryKey = () => {
  return [`/api/schemas/musicbrainz`] as const;
};

export const getSchemaFetchSchemaInfiniteQueryOptions = <
  TData = InfiniteData<Awaited<ReturnType<typeof schemaFetchSchema>>>,
  TError = ErrorType<unknown>
>(options?: {
  query?: Partial<
    UseInfiniteQueryOptions<
      Awaited<ReturnType<typeof schemaFetchSchema>>,
      TError,
      TData
    >
  >;
  request?: SecondParameter<typeof customInstance>;
}) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getSchemaFetchSchemaQueryKey();

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof schemaFetchSchema>>
  > = ({ signal }) => schemaFetchSchema(requestOptions, signal);

  return { queryKey, queryFn, ...queryOptions } as UseInfiniteQueryOptions<
    Awaited<ReturnType<typeof schemaFetchSchema>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type SchemaFetchSchemaInfiniteQueryResult = NonNullable<
  Awaited<ReturnType<typeof schemaFetchSchema>>
>;
export type SchemaFetchSchemaInfiniteQueryError = ErrorType<unknown>;

export function useSchemaFetchSchemaInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof schemaFetchSchema>>>,
  TError = ErrorType<unknown>
>(
  options: {
    query: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof schemaFetchSchema>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof schemaFetchSchema>>,
          TError,
          Awaited<ReturnType<typeof schemaFetchSchema>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): DefinedUseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useSchemaFetchSchemaInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof schemaFetchSchema>>>,
  TError = ErrorType<unknown>
>(
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof schemaFetchSchema>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof schemaFetchSchema>>,
          TError,
          Awaited<ReturnType<typeof schemaFetchSchema>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useSchemaFetchSchemaInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof schemaFetchSchema>>>,
  TError = ErrorType<unknown>
>(
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof schemaFetchSchema>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};

export function useSchemaFetchSchemaInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof schemaFetchSchema>>>,
  TError = ErrorType<unknown>
>(
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof schemaFetchSchema>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getSchemaFetchSchemaInfiniteQueryOptions(options);

  const query = useInfiniteQuery(
    queryOptions,
    queryClient
  ) as UseInfiniteQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getSchemaFetchSchemaQueryOptions = <
  TData = Awaited<ReturnType<typeof schemaFetchSchema>>,
  TError = ErrorType<unknown>
>(options?: {
  query?: Partial<
    UseQueryOptions<
      Awaited<ReturnType<typeof schemaFetchSchema>>,
      TError,
      TData
    >
  >;
  request?: SecondParameter<typeof customInstance>;
}) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getSchemaFetchSchemaQueryKey();

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof schemaFetchSchema>>
  > = ({ signal }) => schemaFetchSchema(requestOptions, signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof schemaFetchSchema>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type SchemaFetchSchemaQueryResult = NonNullable<
  Awaited<ReturnType<typeof schemaFetchSchema>>
>;
export type SchemaFetchSchemaQueryError = ErrorType<unknown>;

export function useSchemaFetchSchema<
  TData = Awaited<ReturnType<typeof schemaFetchSchema>>,
  TError = ErrorType<unknown>
>(
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof schemaFetchSchema>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof schemaFetchSchema>>,
          TError,
          Awaited<ReturnType<typeof schemaFetchSchema>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useSchemaFetchSchema<
  TData = Awaited<ReturnType<typeof schemaFetchSchema>>,
  TError = ErrorType<unknown>
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof schemaFetchSchema>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof schemaFetchSchema>>,
          TError,
          Awaited<ReturnType<typeof schemaFetchSchema>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useSchemaFetchSchema<
  TData = Awaited<ReturnType<typeof schemaFetchSchema>>,
  TError = ErrorType<unknown>
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof schemaFetchSchema>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};

export function useSchemaFetchSchema<
  TData = Awaited<ReturnType<typeof schemaFetchSchema>>,
  TError = ErrorType<unknown>
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof schemaFetchSchema>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getSchemaFetchSchemaQueryOptions(options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getSchemaFetchSchemaSuspenseQueryOptions = <
  TData = Awaited<ReturnType<typeof schemaFetchSchema>>,
  TError = ErrorType<unknown>
>(options?: {
  query?: Partial<
    UseSuspenseQueryOptions<
      Awaited<ReturnType<typeof schemaFetchSchema>>,
      TError,
      TData
    >
  >;
  request?: SecondParameter<typeof customInstance>;
}) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getSchemaFetchSchemaQueryKey();

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof schemaFetchSchema>>
  > = ({ signal }) => schemaFetchSchema(requestOptions, signal);

  return { queryKey, queryFn, ...queryOptions } as UseSuspenseQueryOptions<
    Awaited<ReturnType<typeof schemaFetchSchema>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type SchemaFetchSchemaSuspenseQueryResult = NonNullable<
  Awaited<ReturnType<typeof schemaFetchSchema>>
>;
export type SchemaFetchSchemaSuspenseQueryError = ErrorType<unknown>;

export function useSchemaFetchSchemaSuspense<
  TData = Awaited<ReturnType<typeof schemaFetchSchema>>,
  TError = ErrorType<unknown>
>(
  options: {
    query: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof schemaFetchSchema>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useSchemaFetchSchemaSuspense<
  TData = Awaited<ReturnType<typeof schemaFetchSchema>>,
  TError = ErrorType<unknown>
>(
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof schemaFetchSchema>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useSchemaFetchSchemaSuspense<
  TData = Awaited<ReturnType<typeof schemaFetchSchema>>,
  TError = ErrorType<unknown>
>(
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof schemaFetchSchema>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};

export function useSchemaFetchSchemaSuspense<
  TData = Awaited<ReturnType<typeof schemaFetchSchema>>,
  TError = ErrorType<unknown>
>(
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof schemaFetchSchema>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getSchemaFetchSchemaSuspenseQueryOptions(options);

  const query = useSuspenseQuery(
    queryOptions,
    queryClient
  ) as UseSuspenseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getSchemaFetchSchemaSuspenseInfiniteQueryOptions = <
  TData = InfiniteData<Awaited<ReturnType<typeof schemaFetchSchema>>>,
  TError = ErrorType<unknown>
>(options?: {
  query?: Partial<
    UseSuspenseInfiniteQueryOptions<
      Awaited<ReturnType<typeof schemaFetchSchema>>,
      TError,
      TData
    >
  >;
  request?: SecondParameter<typeof customInstance>;
}) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getSchemaFetchSchemaQueryKey();

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof schemaFetchSchema>>
  > = ({ signal }) => schemaFetchSchema(requestOptions, signal);

  return {
    queryKey,
    queryFn,
    ...queryOptions,
  } as UseSuspenseInfiniteQueryOptions<
    Awaited<ReturnType<typeof schemaFetchSchema>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type SchemaFetchSchemaSuspenseInfiniteQueryResult = NonNullable<
  Awaited<ReturnType<typeof schemaFetchSchema>>
>;
export type SchemaFetchSchemaSuspenseInfiniteQueryError = ErrorType<unknown>;

export function useSchemaFetchSchemaSuspenseInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof schemaFetchSchema>>>,
  TError = ErrorType<unknown>
>(
  options: {
    query: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof schemaFetchSchema>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useSchemaFetchSchemaSuspenseInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof schemaFetchSchema>>>,
  TError = ErrorType<unknown>
>(
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof schemaFetchSchema>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useSchemaFetchSchemaSuspenseInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof schemaFetchSchema>>>,
  TError = ErrorType<unknown>
>(
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof schemaFetchSchema>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};

export function useSchemaFetchSchemaSuspenseInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof schemaFetchSchema>>>,
  TError = ErrorType<unknown>
>(
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof schemaFetchSchema>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions =
    getSchemaFetchSchemaSuspenseInfiniteQueryOptions(options);

  const query = useSuspenseInfiniteQuery(
    queryOptions,
    queryClient
  ) as UseSuspenseInfiniteQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}
