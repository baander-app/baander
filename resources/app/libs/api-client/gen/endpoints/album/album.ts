/**
 * Generated by orval v7.11.2 üç∫
 * Do not edit manually.
 * B√•nder api docs
 * B√•nder.App is a sophisticated media server developed with the primary goal to deliver high performance and seamless experience for users.
Being built on top of Laravel framework and PostgreSQL for database, it leverages the power of robust backend technologies, providing high security, reliability, and scalability.

The main focus of B√•nder.App is efficient media management and delivery.
This application is designed to handle large amounts of media files while ensuring quick and efficient access.
Implemented queuing functionality through Redis offers efficient job management and load handling.
The media information is organized and easily searchable, ensuring users can always find what they are looking for quickly and easily.
 * OpenAPI spec version: 0.0.1
 */
import {
  useInfiniteQuery,
  useMutation,
  useQuery,
  useSuspenseInfiniteQuery,
  useSuspenseQuery,
} from "@tanstack/react-query";
import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseInfiniteQueryResult,
  DefinedUseQueryResult,
  InfiniteData,
  MutationFunction,
  QueryClient,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseInfiniteQueryOptions,
  UseInfiniteQueryResult,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult,
  UseSuspenseInfiniteQueryOptions,
  UseSuspenseInfiniteQueryResult,
  UseSuspenseQueryOptions,
  UseSuspenseQueryResult,
} from "@tanstack/react-query";

import type {
  AlbumResource,
  AlbumUpdateRequest,
  AlbumsIndex200,
  AlbumsIndexParams,
  AuthenticationExceptionResponse,
  ModelNotFoundExceptionResponse,
  ValidationExceptionResponse,
} from "../../models";

import { customInstance } from "../../../axios-instance";
import type { ErrorType, BodyType } from "../../../axios-instance";

type SecondParameter<T extends (...args: never) => unknown> = Parameters<T>[1];

/**
 * @summary Get a collection of albums
 */
export const albumsIndex = (
  library: string,
  params?: AlbumsIndexParams,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal
) => {
  return customInstance<AlbumsIndex200>(
    { url: `/api/libraries/${library}/albums`, method: "GET", params, signal },
    options
  );
};

export const getAlbumsIndexQueryKey = (
  library?: string,
  params?: AlbumsIndexParams
) => {
  return [
    `/api/libraries/${library}/albums`,
    ...(params ? [params] : []),
  ] as const;
};

export const getAlbumsIndexInfiniteQueryOptions = <
  TData = InfiniteData<
    Awaited<ReturnType<typeof albumsIndex>>,
    AlbumsIndexParams["page"]
  >,
  TError = ErrorType<
    | AuthenticationExceptionResponse
    | ModelNotFoundExceptionResponse
    | ValidationExceptionResponse
  >
>(
  library: string,
  params?: AlbumsIndexParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof albumsIndex>>,
        TError,
        TData,
        QueryKey,
        AlbumsIndexParams["page"]
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getAlbumsIndexQueryKey(library, params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof albumsIndex>>,
    QueryKey,
    AlbumsIndexParams["page"]
  > = ({ signal, pageParam }) =>
    albumsIndex(
      library,
      { ...params, page: pageParam || params?.["page"] },
      requestOptions,
      signal
    );

  return {
    queryKey,
    queryFn,
    enabled: !!library,
    ...queryOptions,
  } as UseInfiniteQueryOptions<
    Awaited<ReturnType<typeof albumsIndex>>,
    TError,
    TData,
    QueryKey,
    AlbumsIndexParams["page"]
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type AlbumsIndexInfiniteQueryResult = NonNullable<
  Awaited<ReturnType<typeof albumsIndex>>
>;
export type AlbumsIndexInfiniteQueryError = ErrorType<
  | AuthenticationExceptionResponse
  | ModelNotFoundExceptionResponse
  | ValidationExceptionResponse
>;

export function useAlbumsIndexInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof albumsIndex>>,
    AlbumsIndexParams["page"]
  >,
  TError = ErrorType<
    | AuthenticationExceptionResponse
    | ModelNotFoundExceptionResponse
    | ValidationExceptionResponse
  >
>(
  library: string,
  params: undefined | AlbumsIndexParams,
  options: {
    query: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof albumsIndex>>,
        TError,
        TData,
        QueryKey,
        AlbumsIndexParams["page"]
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof albumsIndex>>,
          TError,
          Awaited<ReturnType<typeof albumsIndex>>,
          QueryKey
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): DefinedUseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useAlbumsIndexInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof albumsIndex>>,
    AlbumsIndexParams["page"]
  >,
  TError = ErrorType<
    | AuthenticationExceptionResponse
    | ModelNotFoundExceptionResponse
    | ValidationExceptionResponse
  >
>(
  library: string,
  params?: AlbumsIndexParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof albumsIndex>>,
        TError,
        TData,
        QueryKey,
        AlbumsIndexParams["page"]
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof albumsIndex>>,
          TError,
          Awaited<ReturnType<typeof albumsIndex>>,
          QueryKey
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useAlbumsIndexInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof albumsIndex>>,
    AlbumsIndexParams["page"]
  >,
  TError = ErrorType<
    | AuthenticationExceptionResponse
    | ModelNotFoundExceptionResponse
    | ValidationExceptionResponse
  >
>(
  library: string,
  params?: AlbumsIndexParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof albumsIndex>>,
        TError,
        TData,
        QueryKey,
        AlbumsIndexParams["page"]
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get a collection of albums
 */

export function useAlbumsIndexInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof albumsIndex>>,
    AlbumsIndexParams["page"]
  >,
  TError = ErrorType<
    | AuthenticationExceptionResponse
    | ModelNotFoundExceptionResponse
    | ValidationExceptionResponse
  >
>(
  library: string,
  params?: AlbumsIndexParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof albumsIndex>>,
        TError,
        TData,
        QueryKey,
        AlbumsIndexParams["page"]
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getAlbumsIndexInfiniteQueryOptions(
    library,
    params,
    options
  );

  const query = useInfiniteQuery(
    queryOptions,
    queryClient
  ) as UseInfiniteQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getAlbumsIndexQueryOptions = <
  TData = Awaited<ReturnType<typeof albumsIndex>>,
  TError = ErrorType<
    | AuthenticationExceptionResponse
    | ModelNotFoundExceptionResponse
    | ValidationExceptionResponse
  >
>(
  library: string,
  params?: AlbumsIndexParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof albumsIndex>>, TError, TData>
    >;
    request?: SecondParameter<typeof customInstance>;
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getAlbumsIndexQueryKey(library, params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof albumsIndex>>> = ({
    signal,
  }) => albumsIndex(library, params, requestOptions, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!library,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof albumsIndex>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type AlbumsIndexQueryResult = NonNullable<
  Awaited<ReturnType<typeof albumsIndex>>
>;
export type AlbumsIndexQueryError = ErrorType<
  | AuthenticationExceptionResponse
  | ModelNotFoundExceptionResponse
  | ValidationExceptionResponse
>;

export function useAlbumsIndex<
  TData = Awaited<ReturnType<typeof albumsIndex>>,
  TError = ErrorType<
    | AuthenticationExceptionResponse
    | ModelNotFoundExceptionResponse
    | ValidationExceptionResponse
  >
>(
  library: string,
  params: undefined | AlbumsIndexParams,
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof albumsIndex>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof albumsIndex>>,
          TError,
          Awaited<ReturnType<typeof albumsIndex>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useAlbumsIndex<
  TData = Awaited<ReturnType<typeof albumsIndex>>,
  TError = ErrorType<
    | AuthenticationExceptionResponse
    | ModelNotFoundExceptionResponse
    | ValidationExceptionResponse
  >
>(
  library: string,
  params?: AlbumsIndexParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof albumsIndex>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof albumsIndex>>,
          TError,
          Awaited<ReturnType<typeof albumsIndex>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useAlbumsIndex<
  TData = Awaited<ReturnType<typeof albumsIndex>>,
  TError = ErrorType<
    | AuthenticationExceptionResponse
    | ModelNotFoundExceptionResponse
    | ValidationExceptionResponse
  >
>(
  library: string,
  params?: AlbumsIndexParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof albumsIndex>>, TError, TData>
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get a collection of albums
 */

export function useAlbumsIndex<
  TData = Awaited<ReturnType<typeof albumsIndex>>,
  TError = ErrorType<
    | AuthenticationExceptionResponse
    | ModelNotFoundExceptionResponse
    | ValidationExceptionResponse
  >
>(
  library: string,
  params?: AlbumsIndexParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof albumsIndex>>, TError, TData>
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getAlbumsIndexQueryOptions(library, params, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getAlbumsIndexSuspenseQueryOptions = <
  TData = Awaited<ReturnType<typeof albumsIndex>>,
  TError = ErrorType<
    | AuthenticationExceptionResponse
    | ModelNotFoundExceptionResponse
    | ValidationExceptionResponse
  >
>(
  library: string,
  params?: AlbumsIndexParams,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof albumsIndex>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getAlbumsIndexQueryKey(library, params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof albumsIndex>>> = ({
    signal,
  }) => albumsIndex(library, params, requestOptions, signal);

  return { queryKey, queryFn, ...queryOptions } as UseSuspenseQueryOptions<
    Awaited<ReturnType<typeof albumsIndex>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type AlbumsIndexSuspenseQueryResult = NonNullable<
  Awaited<ReturnType<typeof albumsIndex>>
>;
export type AlbumsIndexSuspenseQueryError = ErrorType<
  | AuthenticationExceptionResponse
  | ModelNotFoundExceptionResponse
  | ValidationExceptionResponse
>;

export function useAlbumsIndexSuspense<
  TData = Awaited<ReturnType<typeof albumsIndex>>,
  TError = ErrorType<
    | AuthenticationExceptionResponse
    | ModelNotFoundExceptionResponse
    | ValidationExceptionResponse
  >
>(
  library: string,
  params: undefined | AlbumsIndexParams,
  options: {
    query: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof albumsIndex>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useAlbumsIndexSuspense<
  TData = Awaited<ReturnType<typeof albumsIndex>>,
  TError = ErrorType<
    | AuthenticationExceptionResponse
    | ModelNotFoundExceptionResponse
    | ValidationExceptionResponse
  >
>(
  library: string,
  params?: AlbumsIndexParams,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof albumsIndex>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useAlbumsIndexSuspense<
  TData = Awaited<ReturnType<typeof albumsIndex>>,
  TError = ErrorType<
    | AuthenticationExceptionResponse
    | ModelNotFoundExceptionResponse
    | ValidationExceptionResponse
  >
>(
  library: string,
  params?: AlbumsIndexParams,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof albumsIndex>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get a collection of albums
 */

export function useAlbumsIndexSuspense<
  TData = Awaited<ReturnType<typeof albumsIndex>>,
  TError = ErrorType<
    | AuthenticationExceptionResponse
    | ModelNotFoundExceptionResponse
    | ValidationExceptionResponse
  >
>(
  library: string,
  params?: AlbumsIndexParams,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof albumsIndex>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getAlbumsIndexSuspenseQueryOptions(
    library,
    params,
    options
  );

  const query = useSuspenseQuery(
    queryOptions,
    queryClient
  ) as UseSuspenseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getAlbumsIndexSuspenseInfiniteQueryOptions = <
  TData = InfiniteData<
    Awaited<ReturnType<typeof albumsIndex>>,
    AlbumsIndexParams["page"]
  >,
  TError = ErrorType<
    | AuthenticationExceptionResponse
    | ModelNotFoundExceptionResponse
    | ValidationExceptionResponse
  >
>(
  library: string,
  params?: AlbumsIndexParams,
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof albumsIndex>>,
        TError,
        TData,
        QueryKey,
        AlbumsIndexParams["page"]
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getAlbumsIndexQueryKey(library, params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof albumsIndex>>,
    QueryKey,
    AlbumsIndexParams["page"]
  > = ({ signal, pageParam }) =>
    albumsIndex(
      library,
      { ...params, page: pageParam || params?.["page"] },
      requestOptions,
      signal
    );

  return {
    queryKey,
    queryFn,
    ...queryOptions,
  } as UseSuspenseInfiniteQueryOptions<
    Awaited<ReturnType<typeof albumsIndex>>,
    TError,
    TData,
    QueryKey,
    AlbumsIndexParams["page"]
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type AlbumsIndexSuspenseInfiniteQueryResult = NonNullable<
  Awaited<ReturnType<typeof albumsIndex>>
>;
export type AlbumsIndexSuspenseInfiniteQueryError = ErrorType<
  | AuthenticationExceptionResponse
  | ModelNotFoundExceptionResponse
  | ValidationExceptionResponse
>;

export function useAlbumsIndexSuspenseInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof albumsIndex>>,
    AlbumsIndexParams["page"]
  >,
  TError = ErrorType<
    | AuthenticationExceptionResponse
    | ModelNotFoundExceptionResponse
    | ValidationExceptionResponse
  >
>(
  library: string,
  params: undefined | AlbumsIndexParams,
  options: {
    query: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof albumsIndex>>,
        TError,
        TData,
        QueryKey,
        AlbumsIndexParams["page"]
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useAlbumsIndexSuspenseInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof albumsIndex>>,
    AlbumsIndexParams["page"]
  >,
  TError = ErrorType<
    | AuthenticationExceptionResponse
    | ModelNotFoundExceptionResponse
    | ValidationExceptionResponse
  >
>(
  library: string,
  params?: AlbumsIndexParams,
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof albumsIndex>>,
        TError,
        TData,
        QueryKey,
        AlbumsIndexParams["page"]
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useAlbumsIndexSuspenseInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof albumsIndex>>,
    AlbumsIndexParams["page"]
  >,
  TError = ErrorType<
    | AuthenticationExceptionResponse
    | ModelNotFoundExceptionResponse
    | ValidationExceptionResponse
  >
>(
  library: string,
  params?: AlbumsIndexParams,
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof albumsIndex>>,
        TError,
        TData,
        QueryKey,
        AlbumsIndexParams["page"]
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get a collection of albums
 */

export function useAlbumsIndexSuspenseInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof albumsIndex>>,
    AlbumsIndexParams["page"]
  >,
  TError = ErrorType<
    | AuthenticationExceptionResponse
    | ModelNotFoundExceptionResponse
    | ValidationExceptionResponse
  >
>(
  library: string,
  params?: AlbumsIndexParams,
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof albumsIndex>>,
        TError,
        TData,
        QueryKey,
        AlbumsIndexParams["page"]
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getAlbumsIndexSuspenseInfiniteQueryOptions(
    library,
    params,
    options
  );

  const query = useSuspenseInfiniteQuery(
    queryOptions,
    queryClient
  ) as UseSuspenseInfiniteQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Get an album
 */
export const albumsShow = (
  library: string,
  album: string,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal
) => {
  return customInstance<AlbumResource>(
    { url: `/api/libraries/${library}/albums/${album}`, method: "GET", signal },
    options
  );
};

export const getAlbumsShowQueryKey = (library?: string, album?: string) => {
  return [`/api/libraries/${library}/albums/${album}`] as const;
};

export const getAlbumsShowInfiniteQueryOptions = <
  TData = InfiniteData<Awaited<ReturnType<typeof albumsShow>>>,
  TError = ErrorType<
    AuthenticationExceptionResponse | ModelNotFoundExceptionResponse
  >
>(
  library: string,
  album: string,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof albumsShow>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getAlbumsShowQueryKey(library, album);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof albumsShow>>> = ({
    signal,
  }) => albumsShow(library, album, requestOptions, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!(library && album),
    ...queryOptions,
  } as UseInfiniteQueryOptions<
    Awaited<ReturnType<typeof albumsShow>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type AlbumsShowInfiniteQueryResult = NonNullable<
  Awaited<ReturnType<typeof albumsShow>>
>;
export type AlbumsShowInfiniteQueryError = ErrorType<
  AuthenticationExceptionResponse | ModelNotFoundExceptionResponse
>;

export function useAlbumsShowInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof albumsShow>>>,
  TError = ErrorType<
    AuthenticationExceptionResponse | ModelNotFoundExceptionResponse
  >
>(
  library: string,
  album: string,
  options: {
    query: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof albumsShow>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof albumsShow>>,
          TError,
          Awaited<ReturnType<typeof albumsShow>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): DefinedUseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useAlbumsShowInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof albumsShow>>>,
  TError = ErrorType<
    AuthenticationExceptionResponse | ModelNotFoundExceptionResponse
  >
>(
  library: string,
  album: string,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof albumsShow>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof albumsShow>>,
          TError,
          Awaited<ReturnType<typeof albumsShow>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useAlbumsShowInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof albumsShow>>>,
  TError = ErrorType<
    AuthenticationExceptionResponse | ModelNotFoundExceptionResponse
  >
>(
  library: string,
  album: string,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof albumsShow>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get an album
 */

export function useAlbumsShowInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof albumsShow>>>,
  TError = ErrorType<
    AuthenticationExceptionResponse | ModelNotFoundExceptionResponse
  >
>(
  library: string,
  album: string,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof albumsShow>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getAlbumsShowInfiniteQueryOptions(
    library,
    album,
    options
  );

  const query = useInfiniteQuery(
    queryOptions,
    queryClient
  ) as UseInfiniteQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getAlbumsShowQueryOptions = <
  TData = Awaited<ReturnType<typeof albumsShow>>,
  TError = ErrorType<
    AuthenticationExceptionResponse | ModelNotFoundExceptionResponse
  >
>(
  library: string,
  album: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof albumsShow>>, TError, TData>
    >;
    request?: SecondParameter<typeof customInstance>;
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getAlbumsShowQueryKey(library, album);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof albumsShow>>> = ({
    signal,
  }) => albumsShow(library, album, requestOptions, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!(library && album),
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof albumsShow>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type AlbumsShowQueryResult = NonNullable<
  Awaited<ReturnType<typeof albumsShow>>
>;
export type AlbumsShowQueryError = ErrorType<
  AuthenticationExceptionResponse | ModelNotFoundExceptionResponse
>;

export function useAlbumsShow<
  TData = Awaited<ReturnType<typeof albumsShow>>,
  TError = ErrorType<
    AuthenticationExceptionResponse | ModelNotFoundExceptionResponse
  >
>(
  library: string,
  album: string,
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof albumsShow>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof albumsShow>>,
          TError,
          Awaited<ReturnType<typeof albumsShow>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useAlbumsShow<
  TData = Awaited<ReturnType<typeof albumsShow>>,
  TError = ErrorType<
    AuthenticationExceptionResponse | ModelNotFoundExceptionResponse
  >
>(
  library: string,
  album: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof albumsShow>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof albumsShow>>,
          TError,
          Awaited<ReturnType<typeof albumsShow>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useAlbumsShow<
  TData = Awaited<ReturnType<typeof albumsShow>>,
  TError = ErrorType<
    AuthenticationExceptionResponse | ModelNotFoundExceptionResponse
  >
>(
  library: string,
  album: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof albumsShow>>, TError, TData>
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get an album
 */

export function useAlbumsShow<
  TData = Awaited<ReturnType<typeof albumsShow>>,
  TError = ErrorType<
    AuthenticationExceptionResponse | ModelNotFoundExceptionResponse
  >
>(
  library: string,
  album: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof albumsShow>>, TError, TData>
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getAlbumsShowQueryOptions(library, album, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getAlbumsShowSuspenseQueryOptions = <
  TData = Awaited<ReturnType<typeof albumsShow>>,
  TError = ErrorType<
    AuthenticationExceptionResponse | ModelNotFoundExceptionResponse
  >
>(
  library: string,
  album: string,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof albumsShow>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getAlbumsShowQueryKey(library, album);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof albumsShow>>> = ({
    signal,
  }) => albumsShow(library, album, requestOptions, signal);

  return { queryKey, queryFn, ...queryOptions } as UseSuspenseQueryOptions<
    Awaited<ReturnType<typeof albumsShow>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type AlbumsShowSuspenseQueryResult = NonNullable<
  Awaited<ReturnType<typeof albumsShow>>
>;
export type AlbumsShowSuspenseQueryError = ErrorType<
  AuthenticationExceptionResponse | ModelNotFoundExceptionResponse
>;

export function useAlbumsShowSuspense<
  TData = Awaited<ReturnType<typeof albumsShow>>,
  TError = ErrorType<
    AuthenticationExceptionResponse | ModelNotFoundExceptionResponse
  >
>(
  library: string,
  album: string,
  options: {
    query: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof albumsShow>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useAlbumsShowSuspense<
  TData = Awaited<ReturnType<typeof albumsShow>>,
  TError = ErrorType<
    AuthenticationExceptionResponse | ModelNotFoundExceptionResponse
  >
>(
  library: string,
  album: string,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof albumsShow>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useAlbumsShowSuspense<
  TData = Awaited<ReturnType<typeof albumsShow>>,
  TError = ErrorType<
    AuthenticationExceptionResponse | ModelNotFoundExceptionResponse
  >
>(
  library: string,
  album: string,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof albumsShow>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get an album
 */

export function useAlbumsShowSuspense<
  TData = Awaited<ReturnType<typeof albumsShow>>,
  TError = ErrorType<
    AuthenticationExceptionResponse | ModelNotFoundExceptionResponse
  >
>(
  library: string,
  album: string,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof albumsShow>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getAlbumsShowSuspenseQueryOptions(
    library,
    album,
    options
  );

  const query = useSuspenseQuery(
    queryOptions,
    queryClient
  ) as UseSuspenseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getAlbumsShowSuspenseInfiniteQueryOptions = <
  TData = InfiniteData<Awaited<ReturnType<typeof albumsShow>>>,
  TError = ErrorType<
    AuthenticationExceptionResponse | ModelNotFoundExceptionResponse
  >
>(
  library: string,
  album: string,
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof albumsShow>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getAlbumsShowQueryKey(library, album);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof albumsShow>>> = ({
    signal,
  }) => albumsShow(library, album, requestOptions, signal);

  return {
    queryKey,
    queryFn,
    ...queryOptions,
  } as UseSuspenseInfiniteQueryOptions<
    Awaited<ReturnType<typeof albumsShow>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type AlbumsShowSuspenseInfiniteQueryResult = NonNullable<
  Awaited<ReturnType<typeof albumsShow>>
>;
export type AlbumsShowSuspenseInfiniteQueryError = ErrorType<
  AuthenticationExceptionResponse | ModelNotFoundExceptionResponse
>;

export function useAlbumsShowSuspenseInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof albumsShow>>>,
  TError = ErrorType<
    AuthenticationExceptionResponse | ModelNotFoundExceptionResponse
  >
>(
  library: string,
  album: string,
  options: {
    query: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof albumsShow>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useAlbumsShowSuspenseInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof albumsShow>>>,
  TError = ErrorType<
    AuthenticationExceptionResponse | ModelNotFoundExceptionResponse
  >
>(
  library: string,
  album: string,
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof albumsShow>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useAlbumsShowSuspenseInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof albumsShow>>>,
  TError = ErrorType<
    AuthenticationExceptionResponse | ModelNotFoundExceptionResponse
  >
>(
  library: string,
  album: string,
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof albumsShow>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get an album
 */

export function useAlbumsShowSuspenseInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof albumsShow>>>,
  TError = ErrorType<
    AuthenticationExceptionResponse | ModelNotFoundExceptionResponse
  >
>(
  library: string,
  album: string,
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof albumsShow>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getAlbumsShowSuspenseInfiniteQueryOptions(
    library,
    album,
    options
  );

  const query = useSuspenseInfiniteQuery(
    queryOptions,
    queryClient
  ) as UseSuspenseInfiniteQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const albumsUpdate = (
  library: string,
  album: string,
  albumUpdateRequest: BodyType<AlbumUpdateRequest>,
  options?: SecondParameter<typeof customInstance>
) => {
  return customInstance<AlbumResource>(
    {
      url: `/api/libraries/${library}/albums/${album}`,
      method: "PUT",
      headers: { "Content-Type": "application/json" },
      data: albumUpdateRequest,
    },
    options
  );
};

export const getAlbumsUpdateMutationOptions = <
  TError = ErrorType<
    | AuthenticationExceptionResponse
    | ModelNotFoundExceptionResponse
    | ValidationExceptionResponse
  >,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof albumsUpdate>>,
    TError,
    { library: string; album: string; data: BodyType<AlbumUpdateRequest> },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof albumsUpdate>>,
  TError,
  { library: string; album: string; data: BodyType<AlbumUpdateRequest> },
  TContext
> => {
  const mutationKey = ["albumsUpdate"];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof albumsUpdate>>,
    { library: string; album: string; data: BodyType<AlbumUpdateRequest> }
  > = (props) => {
    const { library, album, data } = props ?? {};

    return albumsUpdate(library, album, data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type AlbumsUpdateMutationResult = NonNullable<
  Awaited<ReturnType<typeof albumsUpdate>>
>;
export type AlbumsUpdateMutationBody = BodyType<AlbumUpdateRequest>;
export type AlbumsUpdateMutationError = ErrorType<
  | AuthenticationExceptionResponse
  | ModelNotFoundExceptionResponse
  | ValidationExceptionResponse
>;

export const useAlbumsUpdate = <
  TError = ErrorType<
    | AuthenticationExceptionResponse
    | ModelNotFoundExceptionResponse
    | ValidationExceptionResponse
  >,
  TContext = unknown
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof albumsUpdate>>,
      TError,
      { library: string; album: string; data: BodyType<AlbumUpdateRequest> },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof albumsUpdate>>,
  TError,
  { library: string; album: string; data: BodyType<AlbumUpdateRequest> },
  TContext
> => {
  const mutationOptions = getAlbumsUpdateMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
