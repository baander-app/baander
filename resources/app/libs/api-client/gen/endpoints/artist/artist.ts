/**
 * Generated by orval v7.17.2 üç∫
 * Do not edit manually.
 * B√•nder api docs
 * B√•nder.App is a sophisticated media server developed with the primary goal to deliver high performance and seamless experience for users.
Being built on top of Laravel framework and PostgreSQL for database, it leverages the power of robust backend technologies, providing high security, reliability, and scalability.

The main focus of B√•nder.App is efficient media management and delivery.
This application is designed to handle large amounts of media files while ensuring quick and efficient access.
Implemented queuing functionality through Redis offers efficient job management and load handling.
The media information is organized and easily searchable, ensuring users can always find what they are looking for quickly and easily.
 * OpenAPI spec version: 0.0.1
 */
import {
  useInfiniteQuery,
  useMutation,
  useQuery,
  useSuspenseInfiniteQuery,
  useSuspenseQuery,
} from "@tanstack/react-query";
import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseInfiniteQueryResult,
  DefinedUseQueryResult,
  InfiniteData,
  MutationFunction,
  QueryClient,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseInfiniteQueryOptions,
  UseInfiniteQueryResult,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult,
  UseSuspenseInfiniteQueryOptions,
  UseSuspenseInfiniteQueryResult,
  UseSuspenseQueryOptions,
  UseSuspenseQueryResult,
} from "@tanstack/react-query";

import type {
  ArtistResource,
  ArtistUpdateRequest,
  ArtistsIndex200,
  ArtistsIndexParams,
  AuthenticationExceptionResponse,
  ModelNotFoundExceptionResponse,
  ValidationExceptionResponse,
} from "../../models";

import { customInstance } from "../../../axios-instance";
import type { ErrorType, BodyType } from "../../../axios-instance";

type SecondParameter<T extends (...args: never) => unknown> = Parameters<T>[1];

/**
 * Returns a filtered and paginated list of artists from the specified library.
Supports field selection and relation inclusion for optimized queries.
 * @summary Get a paginated collection of artists from a specific library
 */
export const artistsIndex = (
  library: string,
  params?: ArtistsIndexParams,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal
) => {
  return customInstance<ArtistsIndex200>(
    { url: `/api/libraries/${library}/artists`, method: "GET", params, signal },
    options
  );
};

export const getArtistsIndexInfiniteQueryKey = (
  library?: string,
  params?: ArtistsIndexParams
) => {
  return [
    "infinite",
    `/api/libraries/${library}/artists`,
    ...(params ? [params] : []),
  ] as const;
};

export const getArtistsIndexQueryKey = (
  library?: string,
  params?: ArtistsIndexParams
) => {
  return [
    `/api/libraries/${library}/artists`,
    ...(params ? [params] : []),
  ] as const;
};

export const getArtistsIndexInfiniteQueryOptions = <
  TData = InfiniteData<
    ArtistsIndex200,
    ArtistsIndexParams["page"]
  >,
  TError = ErrorType<
    | AuthenticationExceptionResponse
    | ModelNotFoundExceptionResponse
    | ValidationExceptionResponse
  >
>(
  library: string,
  params?: ArtistsIndexParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        ArtistsIndex200,
        TError,
        TData,
        QueryKey,
        ArtistsIndexParams["page"]
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getArtistsIndexInfiniteQueryKey(library, params);

  const queryFn: QueryFunction<
    ArtistsIndex200,
    QueryKey,
    ArtistsIndexParams["page"]
  > = ({ signal, pageParam }) =>
    artistsIndex(
      library,
      { ...params, page: pageParam || params?.["page"] },
      requestOptions,
      signal
    );

  return {
    queryKey,
    queryFn,
    enabled: !!library,
    ...queryOptions,
  } as UseInfiniteQueryOptions<
    ArtistsIndex200,
    TError,
    TData,
    QueryKey,
    ArtistsIndexParams["page"]
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type ArtistsIndexInfiniteQueryResult = NonNullable<
  ArtistsIndex200
>;
export type ArtistsIndexInfiniteQueryError = ErrorType<
  | AuthenticationExceptionResponse
  | ModelNotFoundExceptionResponse
  | ValidationExceptionResponse
>;

export function useArtistsIndexInfinite<
  TData = InfiniteData<
    ArtistsIndex200,
    ArtistsIndexParams["page"]
  >,
  TError = ErrorType<
    | AuthenticationExceptionResponse
    | ModelNotFoundExceptionResponse
    | ValidationExceptionResponse
  >
>(
  library: string,
  params: undefined | ArtistsIndexParams,
  options: {
    query: Partial<
      UseInfiniteQueryOptions<
        ArtistsIndex200,
        TError,
        TData,
        QueryKey,
        ArtistsIndexParams["page"]
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          ArtistsIndex200,
          TError,
          ArtistsIndex200,
          QueryKey
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): DefinedUseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useArtistsIndexInfinite<
  TData = InfiniteData<
    ArtistsIndex200,
    ArtistsIndexParams["page"]
  >,
  TError = ErrorType<
    | AuthenticationExceptionResponse
    | ModelNotFoundExceptionResponse
    | ValidationExceptionResponse
  >
>(
  library: string,
  params?: ArtistsIndexParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        ArtistsIndex200,
        TError,
        TData,
        QueryKey,
        ArtistsIndexParams["page"]
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          ArtistsIndex200,
          TError,
          ArtistsIndex200,
          QueryKey
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useArtistsIndexInfinite<
  TData = InfiniteData<
    ArtistsIndex200,
    ArtistsIndexParams["page"]
  >,
  TError = ErrorType<
    | AuthenticationExceptionResponse
    | ModelNotFoundExceptionResponse
    | ValidationExceptionResponse
  >
>(
  library: string,
  params?: ArtistsIndexParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        ArtistsIndex200,
        TError,
        TData,
        QueryKey,
        ArtistsIndexParams["page"]
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get a paginated collection of artists from a specific library
 */

export function useArtistsIndexInfinite<
  TData = InfiniteData<
    ArtistsIndex200,
    ArtistsIndexParams["page"]
  >,
  TError = ErrorType<
    | AuthenticationExceptionResponse
    | ModelNotFoundExceptionResponse
    | ValidationExceptionResponse
  >
>(
  library: string,
  params?: ArtistsIndexParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        ArtistsIndex200,
        TError,
        TData,
        QueryKey,
        ArtistsIndexParams["page"]
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getArtistsIndexInfiniteQueryOptions(
    library,
    params,
    options
  );

  const query = useInfiniteQuery(
    queryOptions,
    queryClient
  ) as UseInfiniteQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getArtistsIndexQueryOptions = <
  TData = ArtistsIndex200,
  TError = ErrorType<
    | AuthenticationExceptionResponse
    | ModelNotFoundExceptionResponse
    | ValidationExceptionResponse
  >
>(
  library: string,
  params?: ArtistsIndexParams,
  options?: {
    query?: Partial<
      UseQueryOptions<ArtistsIndex200, TError, TData>
    >;
    request?: SecondParameter<typeof customInstance>;
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getArtistsIndexQueryKey(library, params);

  const queryFn: QueryFunction<ArtistsIndex200> = ({
    signal,
  }) => artistsIndex(library, params, requestOptions, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!library,
    ...queryOptions,
  } as UseQueryOptions<
    ArtistsIndex200,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type ArtistsIndexQueryResult = NonNullable<
  ArtistsIndex200
>;
export type ArtistsIndexQueryError = ErrorType<
  | AuthenticationExceptionResponse
  | ModelNotFoundExceptionResponse
  | ValidationExceptionResponse
>;

export function useArtistsIndex<
  TData = ArtistsIndex200,
  TError = ErrorType<
    | AuthenticationExceptionResponse
    | ModelNotFoundExceptionResponse
    | ValidationExceptionResponse
  >
>(
  library: string,
  params: undefined | ArtistsIndexParams,
  options: {
    query: Partial<
      UseQueryOptions<ArtistsIndex200, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          ArtistsIndex200,
          TError,
          ArtistsIndex200
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useArtistsIndex<
  TData = ArtistsIndex200,
  TError = ErrorType<
    | AuthenticationExceptionResponse
    | ModelNotFoundExceptionResponse
    | ValidationExceptionResponse
  >
>(
  library: string,
  params?: ArtistsIndexParams,
  options?: {
    query?: Partial<
      UseQueryOptions<ArtistsIndex200, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          ArtistsIndex200,
          TError,
          ArtistsIndex200
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useArtistsIndex<
  TData = ArtistsIndex200,
  TError = ErrorType<
    | AuthenticationExceptionResponse
    | ModelNotFoundExceptionResponse
    | ValidationExceptionResponse
  >
>(
  library: string,
  params?: ArtistsIndexParams,
  options?: {
    query?: Partial<
      UseQueryOptions<ArtistsIndex200, TError, TData>
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get a paginated collection of artists from a specific library
 */

export function useArtistsIndex<
  TData = ArtistsIndex200,
  TError = ErrorType<
    | AuthenticationExceptionResponse
    | ModelNotFoundExceptionResponse
    | ValidationExceptionResponse
  >
>(
  library: string,
  params?: ArtistsIndexParams,
  options?: {
    query?: Partial<
      UseQueryOptions<ArtistsIndex200, TError, TData>
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getArtistsIndexQueryOptions(library, params, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getArtistsIndexSuspenseQueryOptions = <
  TData = ArtistsIndex200,
  TError = ErrorType<
    | AuthenticationExceptionResponse
    | ModelNotFoundExceptionResponse
    | ValidationExceptionResponse
  >
>(
  library: string,
  params?: ArtistsIndexParams,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        ArtistsIndex200,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getArtistsIndexQueryKey(library, params);

  const queryFn: QueryFunction<ArtistsIndex200> = ({
    signal,
  }) => artistsIndex(library, params, requestOptions, signal);

  return { queryKey, queryFn, ...queryOptions } as UseSuspenseQueryOptions<
    ArtistsIndex200,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type ArtistsIndexSuspenseQueryResult = NonNullable<
  ArtistsIndex200
>;
export type ArtistsIndexSuspenseQueryError = ErrorType<
  | AuthenticationExceptionResponse
  | ModelNotFoundExceptionResponse
  | ValidationExceptionResponse
>;

export function useArtistsIndexSuspense<
  TData = ArtistsIndex200,
  TError = ErrorType<
    | AuthenticationExceptionResponse
    | ModelNotFoundExceptionResponse
    | ValidationExceptionResponse
  >
>(
  library: string,
  params: undefined | ArtistsIndexParams,
  options: {
    query: Partial<
      UseSuspenseQueryOptions<
        ArtistsIndex200,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useArtistsIndexSuspense<
  TData = ArtistsIndex200,
  TError = ErrorType<
    | AuthenticationExceptionResponse
    | ModelNotFoundExceptionResponse
    | ValidationExceptionResponse
  >
>(
  library: string,
  params?: ArtistsIndexParams,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        ArtistsIndex200,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useArtistsIndexSuspense<
  TData = ArtistsIndex200,
  TError = ErrorType<
    | AuthenticationExceptionResponse
    | ModelNotFoundExceptionResponse
    | ValidationExceptionResponse
  >
>(
  library: string,
  params?: ArtistsIndexParams,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        ArtistsIndex200,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get a paginated collection of artists from a specific library
 */

export function useArtistsIndexSuspense<
  TData = ArtistsIndex200,
  TError = ErrorType<
    | AuthenticationExceptionResponse
    | ModelNotFoundExceptionResponse
    | ValidationExceptionResponse
  >
>(
  library: string,
  params?: ArtistsIndexParams,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        ArtistsIndex200,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getArtistsIndexSuspenseQueryOptions(
    library,
    params,
    options
  );

  const query = useSuspenseQuery(
    queryOptions,
    queryClient
  ) as UseSuspenseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getArtistsIndexSuspenseInfiniteQueryOptions = <
  TData = InfiniteData<
    ArtistsIndex200,
    ArtistsIndexParams["page"]
  >,
  TError = ErrorType<
    | AuthenticationExceptionResponse
    | ModelNotFoundExceptionResponse
    | ValidationExceptionResponse
  >
>(
  library: string,
  params?: ArtistsIndexParams,
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        ArtistsIndex200,
        TError,
        TData,
        QueryKey,
        ArtistsIndexParams["page"]
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getArtistsIndexInfiniteQueryKey(library, params);

  const queryFn: QueryFunction<
    ArtistsIndex200,
    QueryKey,
    ArtistsIndexParams["page"]
  > = ({ signal, pageParam }) =>
    artistsIndex(
      library,
      { ...params, page: pageParam || params?.["page"] },
      requestOptions,
      signal
    );

  return {
    queryKey,
    queryFn,
    ...queryOptions,
  } as UseSuspenseInfiniteQueryOptions<
    ArtistsIndex200,
    TError,
    TData,
    QueryKey,
    ArtistsIndexParams["page"]
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type ArtistsIndexSuspenseInfiniteQueryResult = NonNullable<
  ArtistsIndex200
>;
export type ArtistsIndexSuspenseInfiniteQueryError = ErrorType<
  | AuthenticationExceptionResponse
  | ModelNotFoundExceptionResponse
  | ValidationExceptionResponse
>;

export function useArtistsIndexSuspenseInfinite<
  TData = InfiniteData<
    ArtistsIndex200,
    ArtistsIndexParams["page"]
  >,
  TError = ErrorType<
    | AuthenticationExceptionResponse
    | ModelNotFoundExceptionResponse
    | ValidationExceptionResponse
  >
>(
  library: string,
  params: undefined | ArtistsIndexParams,
  options: {
    query: Partial<
      UseSuspenseInfiniteQueryOptions<
        ArtistsIndex200,
        TError,
        TData,
        QueryKey,
        ArtistsIndexParams["page"]
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useArtistsIndexSuspenseInfinite<
  TData = InfiniteData<
    ArtistsIndex200,
    ArtistsIndexParams["page"]
  >,
  TError = ErrorType<
    | AuthenticationExceptionResponse
    | ModelNotFoundExceptionResponse
    | ValidationExceptionResponse
  >
>(
  library: string,
  params?: ArtistsIndexParams,
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        ArtistsIndex200,
        TError,
        TData,
        QueryKey,
        ArtistsIndexParams["page"]
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useArtistsIndexSuspenseInfinite<
  TData = InfiniteData<
    ArtistsIndex200,
    ArtistsIndexParams["page"]
  >,
  TError = ErrorType<
    | AuthenticationExceptionResponse
    | ModelNotFoundExceptionResponse
    | ValidationExceptionResponse
  >
>(
  library: string,
  params?: ArtistsIndexParams,
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        ArtistsIndex200,
        TError,
        TData,
        QueryKey,
        ArtistsIndexParams["page"]
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get a paginated collection of artists from a specific library
 */

export function useArtistsIndexSuspenseInfinite<
  TData = InfiniteData<
    ArtistsIndex200,
    ArtistsIndexParams["page"]
  >,
  TError = ErrorType<
    | AuthenticationExceptionResponse
    | ModelNotFoundExceptionResponse
    | ValidationExceptionResponse
  >
>(
  library: string,
  params?: ArtistsIndexParams,
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        ArtistsIndex200,
        TError,
        TData,
        QueryKey,
        ArtistsIndexParams["page"]
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getArtistsIndexSuspenseInfiniteQueryOptions(
    library,
    params,
    options
  );

  const query = useSuspenseInfiniteQuery(
    queryOptions,
    queryClient
  ) as UseSuspenseInfiniteQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Retrieves a single artist from the specified library with comprehensive
information including albums, songs, and other related data.
 * @summary Get a specific artist with detailed information
 */
export const artistsShow = (
  library: string,
  artist: string,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal
) => {
  return customInstance<ArtistResource>(
    {
      url: `/api/libraries/${library}/artists/${artist}`,
      method: "GET",
      signal,
    },
    options
  );
};

export const getArtistsShowInfiniteQueryKey = (
  library?: string,
  artist?: string
) => {
  return ["infinite", `/api/libraries/${library}/artists/${artist}`] as const;
};

export const getArtistsShowQueryKey = (library?: string, artist?: string) => {
  return [`/api/libraries/${library}/artists/${artist}`] as const;
};

export const getArtistsShowInfiniteQueryOptions = <
  TData = InfiniteData<Awaited<ReturnType<typeof artistsShow>>>,
  TError = ErrorType<
    AuthenticationExceptionResponse | ModelNotFoundExceptionResponse
  >
>(
  library: string,
  artist: string,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof artistsShow>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getArtistsShowInfiniteQueryKey(library, artist);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof artistsShow>>> = ({
    signal,
  }) => artistsShow(library, artist, requestOptions, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!(library && artist),
    ...queryOptions,
  } as UseInfiniteQueryOptions<
    Awaited<ReturnType<typeof artistsShow>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type ArtistsShowInfiniteQueryResult = NonNullable<
  Awaited<ReturnType<typeof artistsShow>>
>;
export type ArtistsShowInfiniteQueryError = ErrorType<
  AuthenticationExceptionResponse | ModelNotFoundExceptionResponse
>;

export function useArtistsShowInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof artistsShow>>>,
  TError = ErrorType<
    AuthenticationExceptionResponse | ModelNotFoundExceptionResponse
  >
>(
  library: string,
  artist: string,
  options: {
    query: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof artistsShow>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof artistsShow>>,
          TError,
          Awaited<ReturnType<typeof artistsShow>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): DefinedUseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useArtistsShowInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof artistsShow>>>,
  TError = ErrorType<
    AuthenticationExceptionResponse | ModelNotFoundExceptionResponse
  >
>(
  library: string,
  artist: string,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof artistsShow>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof artistsShow>>,
          TError,
          Awaited<ReturnType<typeof artistsShow>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useArtistsShowInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof artistsShow>>>,
  TError = ErrorType<
    AuthenticationExceptionResponse | ModelNotFoundExceptionResponse
  >
>(
  library: string,
  artist: string,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof artistsShow>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get a specific artist with detailed information
 */

export function useArtistsShowInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof artistsShow>>>,
  TError = ErrorType<
    AuthenticationExceptionResponse | ModelNotFoundExceptionResponse
  >
>(
  library: string,
  artist: string,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof artistsShow>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getArtistsShowInfiniteQueryOptions(
    library,
    artist,
    options
  );

  const query = useInfiniteQuery(
    queryOptions,
    queryClient
  ) as UseInfiniteQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getArtistsShowQueryOptions = <
  TData = Awaited<ReturnType<typeof artistsShow>>,
  TError = ErrorType<
    AuthenticationExceptionResponse | ModelNotFoundExceptionResponse
  >
>(
  library: string,
  artist: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof artistsShow>>, TError, TData>
    >;
    request?: SecondParameter<typeof customInstance>;
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getArtistsShowQueryKey(library, artist);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof artistsShow>>> = ({
    signal,
  }) => artistsShow(library, artist, requestOptions, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!(library && artist),
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof artistsShow>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type ArtistsShowQueryResult = NonNullable<
  Awaited<ReturnType<typeof artistsShow>>
>;
export type ArtistsShowQueryError = ErrorType<
  AuthenticationExceptionResponse | ModelNotFoundExceptionResponse
>;

export function useArtistsShow<
  TData = Awaited<ReturnType<typeof artistsShow>>,
  TError = ErrorType<
    AuthenticationExceptionResponse | ModelNotFoundExceptionResponse
  >
>(
  library: string,
  artist: string,
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof artistsShow>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof artistsShow>>,
          TError,
          Awaited<ReturnType<typeof artistsShow>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useArtistsShow<
  TData = Awaited<ReturnType<typeof artistsShow>>,
  TError = ErrorType<
    AuthenticationExceptionResponse | ModelNotFoundExceptionResponse
  >
>(
  library: string,
  artist: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof artistsShow>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof artistsShow>>,
          TError,
          Awaited<ReturnType<typeof artistsShow>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useArtistsShow<
  TData = Awaited<ReturnType<typeof artistsShow>>,
  TError = ErrorType<
    AuthenticationExceptionResponse | ModelNotFoundExceptionResponse
  >
>(
  library: string,
  artist: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof artistsShow>>, TError, TData>
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get a specific artist with detailed information
 */

export function useArtistsShow<
  TData = Awaited<ReturnType<typeof artistsShow>>,
  TError = ErrorType<
    AuthenticationExceptionResponse | ModelNotFoundExceptionResponse
  >
>(
  library: string,
  artist: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof artistsShow>>, TError, TData>
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getArtistsShowQueryOptions(library, artist, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getArtistsShowSuspenseQueryOptions = <
  TData = Awaited<ReturnType<typeof artistsShow>>,
  TError = ErrorType<
    AuthenticationExceptionResponse | ModelNotFoundExceptionResponse
  >
>(
  library: string,
  artist: string,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof artistsShow>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getArtistsShowQueryKey(library, artist);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof artistsShow>>> = ({
    signal,
  }) => artistsShow(library, artist, requestOptions, signal);

  return { queryKey, queryFn, ...queryOptions } as UseSuspenseQueryOptions<
    Awaited<ReturnType<typeof artistsShow>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type ArtistsShowSuspenseQueryResult = NonNullable<
  Awaited<ReturnType<typeof artistsShow>>
>;
export type ArtistsShowSuspenseQueryError = ErrorType<
  AuthenticationExceptionResponse | ModelNotFoundExceptionResponse
>;

export function useArtistsShowSuspense<
  TData = Awaited<ReturnType<typeof artistsShow>>,
  TError = ErrorType<
    AuthenticationExceptionResponse | ModelNotFoundExceptionResponse
  >
>(
  library: string,
  artist: string,
  options: {
    query: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof artistsShow>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useArtistsShowSuspense<
  TData = Awaited<ReturnType<typeof artistsShow>>,
  TError = ErrorType<
    AuthenticationExceptionResponse | ModelNotFoundExceptionResponse
  >
>(
  library: string,
  artist: string,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof artistsShow>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useArtistsShowSuspense<
  TData = Awaited<ReturnType<typeof artistsShow>>,
  TError = ErrorType<
    AuthenticationExceptionResponse | ModelNotFoundExceptionResponse
  >
>(
  library: string,
  artist: string,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof artistsShow>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get a specific artist with detailed information
 */

export function useArtistsShowSuspense<
  TData = Awaited<ReturnType<typeof artistsShow>>,
  TError = ErrorType<
    AuthenticationExceptionResponse | ModelNotFoundExceptionResponse
  >
>(
  library: string,
  artist: string,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof artistsShow>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getArtistsShowSuspenseQueryOptions(
    library,
    artist,
    options
  );

  const query = useSuspenseQuery(
    queryOptions,
    queryClient
  ) as UseSuspenseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getArtistsShowSuspenseInfiniteQueryOptions = <
  TData = InfiniteData<Awaited<ReturnType<typeof artistsShow>>>,
  TError = ErrorType<
    AuthenticationExceptionResponse | ModelNotFoundExceptionResponse
  >
>(
  library: string,
  artist: string,
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof artistsShow>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getArtistsShowInfiniteQueryKey(library, artist);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof artistsShow>>> = ({
    signal,
  }) => artistsShow(library, artist, requestOptions, signal);

  return {
    queryKey,
    queryFn,
    ...queryOptions,
  } as UseSuspenseInfiniteQueryOptions<
    Awaited<ReturnType<typeof artistsShow>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type ArtistsShowSuspenseInfiniteQueryResult = NonNullable<
  Awaited<ReturnType<typeof artistsShow>>
>;
export type ArtistsShowSuspenseInfiniteQueryError = ErrorType<
  AuthenticationExceptionResponse | ModelNotFoundExceptionResponse
>;

export function useArtistsShowSuspenseInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof artistsShow>>>,
  TError = ErrorType<
    AuthenticationExceptionResponse | ModelNotFoundExceptionResponse
  >
>(
  library: string,
  artist: string,
  options: {
    query: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof artistsShow>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useArtistsShowSuspenseInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof artistsShow>>>,
  TError = ErrorType<
    AuthenticationExceptionResponse | ModelNotFoundExceptionResponse
  >
>(
  library: string,
  artist: string,
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof artistsShow>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useArtistsShowSuspenseInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof artistsShow>>>,
  TError = ErrorType<
    AuthenticationExceptionResponse | ModelNotFoundExceptionResponse
  >
>(
  library: string,
  artist: string,
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof artistsShow>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get a specific artist with detailed information
 */

export function useArtistsShowSuspenseInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof artistsShow>>>,
  TError = ErrorType<
    AuthenticationExceptionResponse | ModelNotFoundExceptionResponse
  >
>(
  library: string,
  artist: string,
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof artistsShow>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getArtistsShowSuspenseInfiniteQueryOptions(
    library,
    artist,
    options
  );

  const query = useSuspenseInfiniteQuery(
    queryOptions,
    queryClient
  ) as UseSuspenseInfiniteQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Updates artist metadata and information using the provided data.
Only the fields included in the request will be modified.
 * @summary Update an existing artist
 */
export const artistsUpdate = (
  library: string,
  artist: string,
  artistUpdateRequest: BodyType<ArtistUpdateRequest>,
  options?: SecondParameter<typeof customInstance>
) => {
  return customInstance<ArtistResource>(
    {
      url: `/api/libraries/${library}/artists/${artist}`,
      method: "PUT",
      headers: { "Content-Type": "application/json" },
      data: artistUpdateRequest,
    },
    options
  );
};

export const getArtistsUpdateMutationOptions = <
  TError = ErrorType<
    | AuthenticationExceptionResponse
    | ModelNotFoundExceptionResponse
    | ValidationExceptionResponse
  >,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof artistsUpdate>>,
    TError,
    { library: string; artist: string; data: BodyType<ArtistUpdateRequest> },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof artistsUpdate>>,
  TError,
  { library: string; artist: string; data: BodyType<ArtistUpdateRequest> },
  TContext
> => {
  const mutationKey = ["artistsUpdate"];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof artistsUpdate>>,
    { library: string; artist: string; data: BodyType<ArtistUpdateRequest> }
  > = (props) => {
    const { library, artist, data } = props ?? {};

    return artistsUpdate(library, artist, data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type ArtistsUpdateMutationResult = NonNullable<
  Awaited<ReturnType<typeof artistsUpdate>>
>;
export type ArtistsUpdateMutationBody = BodyType<ArtistUpdateRequest>;
export type ArtistsUpdateMutationError = ErrorType<
  | AuthenticationExceptionResponse
  | ModelNotFoundExceptionResponse
  | ValidationExceptionResponse
>;

/**
 * @summary Update an existing artist
 */
export const useArtistsUpdate = <
  TError = ErrorType<
    | AuthenticationExceptionResponse
    | ModelNotFoundExceptionResponse
    | ValidationExceptionResponse
  >,
  TContext = unknown
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof artistsUpdate>>,
      TError,
      { library: string; artist: string; data: BodyType<ArtistUpdateRequest> },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof artistsUpdate>>,
  TError,
  { library: string; artist: string; data: BodyType<ArtistUpdateRequest> },
  TContext
> => {
  const mutationOptions = getArtistsUpdateMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
