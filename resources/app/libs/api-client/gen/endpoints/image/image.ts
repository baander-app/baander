/**
 * Generated by orval v7.11.2 üç∫
 * Do not edit manually.
 * B√•nder api docs
 * B√•nder.App is a sophisticated media server developed with the primary goal to deliver high performance and seamless experience for users.
Being built on top of Laravel framework and PostgreSQL for database, it leverages the power of robust backend technologies, providing high security, reliability, and scalability.

The main focus of B√•nder.App is efficient media management and delivery.
This application is designed to handle large amounts of media files while ensuring quick and efficient access.
Implemented queuing functionality through Redis offers efficient job management and load handling.
The media information is organized and easily searchable, ensuring users can always find what they are looking for quickly and easily.
 * OpenAPI spec version: 0.0.1
 */
import {
  useInfiniteQuery,
  useQuery,
  useSuspenseInfiniteQuery,
  useSuspenseQuery,
} from "@tanstack/react-query";
import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseInfiniteQueryResult,
  DefinedUseQueryResult,
  InfiniteData,
  QueryClient,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseInfiniteQueryOptions,
  UseInfiniteQueryResult,
  UseQueryOptions,
  UseQueryResult,
  UseSuspenseInfiniteQueryOptions,
  UseSuspenseInfiniteQueryResult,
  UseSuspenseQueryOptions,
  UseSuspenseQueryResult,
} from "@tanstack/react-query";

import type { ModelNotFoundExceptionResponse } from "../../models";

import { customInstance } from "../../../axios-instance";
import type { ErrorType } from "../../../axios-instance";

type SecondParameter<T extends (...args: never) => unknown> = Parameters<T>[1];

/**
 * @summary Get an image asset
 */
export const imageServe = (
  image: string,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal
) => {
  return customInstance<Blob>(
    {
      url: `/api/images/${image}`,
      method: "GET",
      responseType: "blob",
      signal,
    },
    options
  );
};

export const getImageServeQueryKey = (image?: string) => {
  return [`/api/images/${image}`] as const;
};

export const getImageServeInfiniteQueryOptions = <
  TData = InfiniteData<Awaited<ReturnType<typeof imageServe>>>,
  TError = ErrorType<ModelNotFoundExceptionResponse>
>(
  image: string,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof imageServe>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getImageServeQueryKey(image);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof imageServe>>> = ({
    signal,
  }) => imageServe(image, requestOptions, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!image,
    ...queryOptions,
  } as UseInfiniteQueryOptions<
    Awaited<ReturnType<typeof imageServe>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type ImageServeInfiniteQueryResult = NonNullable<
  Awaited<ReturnType<typeof imageServe>>
>;
export type ImageServeInfiniteQueryError =
  ErrorType<ModelNotFoundExceptionResponse>;

export function useImageServeInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof imageServe>>>,
  TError = ErrorType<ModelNotFoundExceptionResponse>
>(
  image: string,
  options: {
    query: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof imageServe>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof imageServe>>,
          TError,
          Awaited<ReturnType<typeof imageServe>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): DefinedUseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useImageServeInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof imageServe>>>,
  TError = ErrorType<ModelNotFoundExceptionResponse>
>(
  image: string,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof imageServe>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof imageServe>>,
          TError,
          Awaited<ReturnType<typeof imageServe>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useImageServeInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof imageServe>>>,
  TError = ErrorType<ModelNotFoundExceptionResponse>
>(
  image: string,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof imageServe>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get an image asset
 */

export function useImageServeInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof imageServe>>>,
  TError = ErrorType<ModelNotFoundExceptionResponse>
>(
  image: string,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof imageServe>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getImageServeInfiniteQueryOptions(image, options);

  const query = useInfiniteQuery(
    queryOptions,
    queryClient
  ) as UseInfiniteQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getImageServeQueryOptions = <
  TData = Awaited<ReturnType<typeof imageServe>>,
  TError = ErrorType<ModelNotFoundExceptionResponse>
>(
  image: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof imageServe>>, TError, TData>
    >;
    request?: SecondParameter<typeof customInstance>;
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getImageServeQueryKey(image);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof imageServe>>> = ({
    signal,
  }) => imageServe(image, requestOptions, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!image,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof imageServe>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type ImageServeQueryResult = NonNullable<
  Awaited<ReturnType<typeof imageServe>>
>;
export type ImageServeQueryError = ErrorType<ModelNotFoundExceptionResponse>;

export function useImageServe<
  TData = Awaited<ReturnType<typeof imageServe>>,
  TError = ErrorType<ModelNotFoundExceptionResponse>
>(
  image: string,
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof imageServe>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof imageServe>>,
          TError,
          Awaited<ReturnType<typeof imageServe>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useImageServe<
  TData = Awaited<ReturnType<typeof imageServe>>,
  TError = ErrorType<ModelNotFoundExceptionResponse>
>(
  image: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof imageServe>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof imageServe>>,
          TError,
          Awaited<ReturnType<typeof imageServe>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useImageServe<
  TData = Awaited<ReturnType<typeof imageServe>>,
  TError = ErrorType<ModelNotFoundExceptionResponse>
>(
  image: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof imageServe>>, TError, TData>
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get an image asset
 */

export function useImageServe<
  TData = Awaited<ReturnType<typeof imageServe>>,
  TError = ErrorType<ModelNotFoundExceptionResponse>
>(
  image: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof imageServe>>, TError, TData>
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getImageServeQueryOptions(image, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getImageServeSuspenseQueryOptions = <
  TData = Awaited<ReturnType<typeof imageServe>>,
  TError = ErrorType<ModelNotFoundExceptionResponse>
>(
  image: string,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof imageServe>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getImageServeQueryKey(image);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof imageServe>>> = ({
    signal,
  }) => imageServe(image, requestOptions, signal);

  return { queryKey, queryFn, ...queryOptions } as UseSuspenseQueryOptions<
    Awaited<ReturnType<typeof imageServe>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type ImageServeSuspenseQueryResult = NonNullable<
  Awaited<ReturnType<typeof imageServe>>
>;
export type ImageServeSuspenseQueryError =
  ErrorType<ModelNotFoundExceptionResponse>;

export function useImageServeSuspense<
  TData = Awaited<ReturnType<typeof imageServe>>,
  TError = ErrorType<ModelNotFoundExceptionResponse>
>(
  image: string,
  options: {
    query: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof imageServe>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useImageServeSuspense<
  TData = Awaited<ReturnType<typeof imageServe>>,
  TError = ErrorType<ModelNotFoundExceptionResponse>
>(
  image: string,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof imageServe>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useImageServeSuspense<
  TData = Awaited<ReturnType<typeof imageServe>>,
  TError = ErrorType<ModelNotFoundExceptionResponse>
>(
  image: string,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof imageServe>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get an image asset
 */

export function useImageServeSuspense<
  TData = Awaited<ReturnType<typeof imageServe>>,
  TError = ErrorType<ModelNotFoundExceptionResponse>
>(
  image: string,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof imageServe>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getImageServeSuspenseQueryOptions(image, options);

  const query = useSuspenseQuery(
    queryOptions,
    queryClient
  ) as UseSuspenseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getImageServeSuspenseInfiniteQueryOptions = <
  TData = InfiniteData<Awaited<ReturnType<typeof imageServe>>>,
  TError = ErrorType<ModelNotFoundExceptionResponse>
>(
  image: string,
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof imageServe>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getImageServeQueryKey(image);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof imageServe>>> = ({
    signal,
  }) => imageServe(image, requestOptions, signal);

  return {
    queryKey,
    queryFn,
    ...queryOptions,
  } as UseSuspenseInfiniteQueryOptions<
    Awaited<ReturnType<typeof imageServe>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type ImageServeSuspenseInfiniteQueryResult = NonNullable<
  Awaited<ReturnType<typeof imageServe>>
>;
export type ImageServeSuspenseInfiniteQueryError =
  ErrorType<ModelNotFoundExceptionResponse>;

export function useImageServeSuspenseInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof imageServe>>>,
  TError = ErrorType<ModelNotFoundExceptionResponse>
>(
  image: string,
  options: {
    query: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof imageServe>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useImageServeSuspenseInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof imageServe>>>,
  TError = ErrorType<ModelNotFoundExceptionResponse>
>(
  image: string,
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof imageServe>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useImageServeSuspenseInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof imageServe>>>,
  TError = ErrorType<ModelNotFoundExceptionResponse>
>(
  image: string,
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof imageServe>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get an image asset
 */

export function useImageServeSuspenseInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof imageServe>>>,
  TError = ErrorType<ModelNotFoundExceptionResponse>
>(
  image: string,
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof imageServe>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getImageServeSuspenseInfiniteQueryOptions(
    image,
    options
  );

  const query = useSuspenseInfiniteQuery(
    queryOptions,
    queryClient
  ) as UseSuspenseInfiniteQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}
