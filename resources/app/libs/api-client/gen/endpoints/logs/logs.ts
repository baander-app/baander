/**
 * Generated by orval v7.11.2 üç∫
 * Do not edit manually.
 * B√•nder api docs
 * B√•nder.App is a sophisticated media server developed with the primary goal to deliver high performance and seamless experience for users.
Being built on top of Laravel framework and PostgreSQL for database, it leverages the power of robust backend technologies, providing high security, reliability, and scalability.

The main focus of B√•nder.App is efficient media management and delivery.
This application is designed to handle large amounts of media files while ensuring quick and efficient access.
Implemented queuing functionality through Redis offers efficient job management and load handling.
The media information is organized and easily searchable, ensuring users can always find what they are looking for quickly and easily.
 * OpenAPI spec version: 0.0.1
 */
import {
  useInfiniteQuery,
  useQuery,
  useSuspenseInfiniteQuery,
  useSuspenseQuery,
} from "@tanstack/react-query";
import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseInfiniteQueryResult,
  DefinedUseQueryResult,
  InfiniteData,
  QueryClient,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseInfiniteQueryOptions,
  UseInfiniteQueryResult,
  UseQueryOptions,
  UseQueryResult,
  UseSuspenseInfiniteQueryOptions,
  UseSuspenseInfiniteQueryResult,
  UseSuspenseQueryOptions,
  UseSuspenseQueryResult,
} from "@tanstack/react-query";

import type {
  AuthenticationExceptionResponse,
  LogFile,
  LogsContent200,
  LogsContent404,
  LogsContent500,
  LogsContentParams,
  LogsDownload404,
  LogsHead200,
  LogsHead404,
  LogsHead500,
  LogsHeadParams,
  LogsLines200,
  LogsLines404,
  LogsLines500,
  LogsSearch200,
  LogsSearch404,
  LogsSearch500,
  LogsSearchAll200,
  LogsSearchAll500,
  LogsSearchAllParams,
  LogsSearchParams,
  LogsShow200,
  LogsShow404,
  LogsShow500,
  LogsStats200,
  LogsStats404,
  LogsStats500,
  LogsTail200,
  LogsTail404,
  LogsTail500,
  LogsTailParams,
  ValidationExceptionResponse,
} from "../../models";

import { customInstance } from "../../../axios-instance";
import type { ErrorType } from "../../../axios-instance";

type SecondParameter<T extends (...args: never) => unknown> = Parameters<T>[1];

/**
 * @summary Get a collection of log files
 */
export const logsIndex = (
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal
) => {
  return customInstance<LogFile[]>(
    { url: `/api/logs`, method: "GET", signal },
    options
  );
};

export const getLogsIndexQueryKey = () => {
  return [`/api/logs`] as const;
};

export const getLogsIndexInfiniteQueryOptions = <
  TData = InfiniteData<Awaited<ReturnType<typeof logsIndex>>>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(options?: {
  query?: Partial<
    UseInfiniteQueryOptions<
      Awaited<ReturnType<typeof logsIndex>>,
      TError,
      TData
    >
  >;
  request?: SecondParameter<typeof customInstance>;
}) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getLogsIndexQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof logsIndex>>> = ({
    signal,
  }) => logsIndex(requestOptions, signal);

  return { queryKey, queryFn, ...queryOptions } as UseInfiniteQueryOptions<
    Awaited<ReturnType<typeof logsIndex>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type LogsIndexInfiniteQueryResult = NonNullable<
  Awaited<ReturnType<typeof logsIndex>>
>;
export type LogsIndexInfiniteQueryError =
  ErrorType<AuthenticationExceptionResponse>;

export function useLogsIndexInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof logsIndex>>>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(
  options: {
    query: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof logsIndex>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof logsIndex>>,
          TError,
          Awaited<ReturnType<typeof logsIndex>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): DefinedUseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useLogsIndexInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof logsIndex>>>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof logsIndex>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof logsIndex>>,
          TError,
          Awaited<ReturnType<typeof logsIndex>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useLogsIndexInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof logsIndex>>>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof logsIndex>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get a collection of log files
 */

export function useLogsIndexInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof logsIndex>>>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof logsIndex>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getLogsIndexInfiniteQueryOptions(options);

  const query = useInfiniteQuery(
    queryOptions,
    queryClient
  ) as UseInfiniteQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getLogsIndexQueryOptions = <
  TData = Awaited<ReturnType<typeof logsIndex>>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof logsIndex>>, TError, TData>
  >;
  request?: SecondParameter<typeof customInstance>;
}) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getLogsIndexQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof logsIndex>>> = ({
    signal,
  }) => logsIndex(requestOptions, signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof logsIndex>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type LogsIndexQueryResult = NonNullable<
  Awaited<ReturnType<typeof logsIndex>>
>;
export type LogsIndexQueryError = ErrorType<AuthenticationExceptionResponse>;

export function useLogsIndex<
  TData = Awaited<ReturnType<typeof logsIndex>>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof logsIndex>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof logsIndex>>,
          TError,
          Awaited<ReturnType<typeof logsIndex>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useLogsIndex<
  TData = Awaited<ReturnType<typeof logsIndex>>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof logsIndex>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof logsIndex>>,
          TError,
          Awaited<ReturnType<typeof logsIndex>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useLogsIndex<
  TData = Awaited<ReturnType<typeof logsIndex>>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof logsIndex>>, TError, TData>
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get a collection of log files
 */

export function useLogsIndex<
  TData = Awaited<ReturnType<typeof logsIndex>>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof logsIndex>>, TError, TData>
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getLogsIndexQueryOptions(options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getLogsIndexSuspenseQueryOptions = <
  TData = Awaited<ReturnType<typeof logsIndex>>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(options?: {
  query?: Partial<
    UseSuspenseQueryOptions<
      Awaited<ReturnType<typeof logsIndex>>,
      TError,
      TData
    >
  >;
  request?: SecondParameter<typeof customInstance>;
}) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getLogsIndexQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof logsIndex>>> = ({
    signal,
  }) => logsIndex(requestOptions, signal);

  return { queryKey, queryFn, ...queryOptions } as UseSuspenseQueryOptions<
    Awaited<ReturnType<typeof logsIndex>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type LogsIndexSuspenseQueryResult = NonNullable<
  Awaited<ReturnType<typeof logsIndex>>
>;
export type LogsIndexSuspenseQueryError =
  ErrorType<AuthenticationExceptionResponse>;

export function useLogsIndexSuspense<
  TData = Awaited<ReturnType<typeof logsIndex>>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(
  options: {
    query: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof logsIndex>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useLogsIndexSuspense<
  TData = Awaited<ReturnType<typeof logsIndex>>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof logsIndex>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useLogsIndexSuspense<
  TData = Awaited<ReturnType<typeof logsIndex>>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof logsIndex>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get a collection of log files
 */

export function useLogsIndexSuspense<
  TData = Awaited<ReturnType<typeof logsIndex>>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof logsIndex>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getLogsIndexSuspenseQueryOptions(options);

  const query = useSuspenseQuery(
    queryOptions,
    queryClient
  ) as UseSuspenseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getLogsIndexSuspenseInfiniteQueryOptions = <
  TData = InfiniteData<Awaited<ReturnType<typeof logsIndex>>>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(options?: {
  query?: Partial<
    UseSuspenseInfiniteQueryOptions<
      Awaited<ReturnType<typeof logsIndex>>,
      TError,
      TData
    >
  >;
  request?: SecondParameter<typeof customInstance>;
}) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getLogsIndexQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof logsIndex>>> = ({
    signal,
  }) => logsIndex(requestOptions, signal);

  return {
    queryKey,
    queryFn,
    ...queryOptions,
  } as UseSuspenseInfiniteQueryOptions<
    Awaited<ReturnType<typeof logsIndex>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type LogsIndexSuspenseInfiniteQueryResult = NonNullable<
  Awaited<ReturnType<typeof logsIndex>>
>;
export type LogsIndexSuspenseInfiniteQueryError =
  ErrorType<AuthenticationExceptionResponse>;

export function useLogsIndexSuspenseInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof logsIndex>>>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(
  options: {
    query: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof logsIndex>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useLogsIndexSuspenseInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof logsIndex>>>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof logsIndex>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useLogsIndexSuspenseInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof logsIndex>>>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof logsIndex>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get a collection of log files
 */

export function useLogsIndexSuspenseInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof logsIndex>>>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof logsIndex>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getLogsIndexSuspenseInfiniteQueryOptions(options);

  const query = useSuspenseInfiniteQuery(
    queryOptions,
    queryClient
  ) as UseSuspenseInfiniteQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Show a log file
 */
export const logsShow = (
  logFile: string,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal
) => {
  return customInstance<LogsShow200>(
    { url: `/api/logs/${logFile}`, method: "GET", signal },
    options
  );
};

export const getLogsShowQueryKey = (logFile?: string) => {
  return [`/api/logs/${logFile}`] as const;
};

export const getLogsShowInfiniteQueryOptions = <
  TData = InfiniteData<Awaited<ReturnType<typeof logsShow>>>,
  TError = ErrorType<
    AuthenticationExceptionResponse | LogsShow404 | LogsShow500
  >
>(
  logFile: string,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof logsShow>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getLogsShowQueryKey(logFile);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof logsShow>>> = ({
    signal,
  }) => logsShow(logFile, requestOptions, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!logFile,
    ...queryOptions,
  } as UseInfiniteQueryOptions<
    Awaited<ReturnType<typeof logsShow>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type LogsShowInfiniteQueryResult = NonNullable<
  Awaited<ReturnType<typeof logsShow>>
>;
export type LogsShowInfiniteQueryError = ErrorType<
  AuthenticationExceptionResponse | LogsShow404 | LogsShow500
>;

export function useLogsShowInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof logsShow>>>,
  TError = ErrorType<
    AuthenticationExceptionResponse | LogsShow404 | LogsShow500
  >
>(
  logFile: string,
  options: {
    query: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof logsShow>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof logsShow>>,
          TError,
          Awaited<ReturnType<typeof logsShow>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): DefinedUseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useLogsShowInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof logsShow>>>,
  TError = ErrorType<
    AuthenticationExceptionResponse | LogsShow404 | LogsShow500
  >
>(
  logFile: string,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof logsShow>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof logsShow>>,
          TError,
          Awaited<ReturnType<typeof logsShow>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useLogsShowInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof logsShow>>>,
  TError = ErrorType<
    AuthenticationExceptionResponse | LogsShow404 | LogsShow500
  >
>(
  logFile: string,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof logsShow>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Show a log file
 */

export function useLogsShowInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof logsShow>>>,
  TError = ErrorType<
    AuthenticationExceptionResponse | LogsShow404 | LogsShow500
  >
>(
  logFile: string,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof logsShow>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getLogsShowInfiniteQueryOptions(logFile, options);

  const query = useInfiniteQuery(
    queryOptions,
    queryClient
  ) as UseInfiniteQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getLogsShowQueryOptions = <
  TData = Awaited<ReturnType<typeof logsShow>>,
  TError = ErrorType<
    AuthenticationExceptionResponse | LogsShow404 | LogsShow500
  >
>(
  logFile: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof logsShow>>, TError, TData>
    >;
    request?: SecondParameter<typeof customInstance>;
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getLogsShowQueryKey(logFile);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof logsShow>>> = ({
    signal,
  }) => logsShow(logFile, requestOptions, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!logFile,
    ...queryOptions,
  } as UseQueryOptions<Awaited<ReturnType<typeof logsShow>>, TError, TData> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };
};

export type LogsShowQueryResult = NonNullable<
  Awaited<ReturnType<typeof logsShow>>
>;
export type LogsShowQueryError = ErrorType<
  AuthenticationExceptionResponse | LogsShow404 | LogsShow500
>;

export function useLogsShow<
  TData = Awaited<ReturnType<typeof logsShow>>,
  TError = ErrorType<
    AuthenticationExceptionResponse | LogsShow404 | LogsShow500
  >
>(
  logFile: string,
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof logsShow>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof logsShow>>,
          TError,
          Awaited<ReturnType<typeof logsShow>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useLogsShow<
  TData = Awaited<ReturnType<typeof logsShow>>,
  TError = ErrorType<
    AuthenticationExceptionResponse | LogsShow404 | LogsShow500
  >
>(
  logFile: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof logsShow>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof logsShow>>,
          TError,
          Awaited<ReturnType<typeof logsShow>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useLogsShow<
  TData = Awaited<ReturnType<typeof logsShow>>,
  TError = ErrorType<
    AuthenticationExceptionResponse | LogsShow404 | LogsShow500
  >
>(
  logFile: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof logsShow>>, TError, TData>
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Show a log file
 */

export function useLogsShow<
  TData = Awaited<ReturnType<typeof logsShow>>,
  TError = ErrorType<
    AuthenticationExceptionResponse | LogsShow404 | LogsShow500
  >
>(
  logFile: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof logsShow>>, TError, TData>
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getLogsShowQueryOptions(logFile, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getLogsShowSuspenseQueryOptions = <
  TData = Awaited<ReturnType<typeof logsShow>>,
  TError = ErrorType<
    AuthenticationExceptionResponse | LogsShow404 | LogsShow500
  >
>(
  logFile: string,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof logsShow>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getLogsShowQueryKey(logFile);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof logsShow>>> = ({
    signal,
  }) => logsShow(logFile, requestOptions, signal);

  return { queryKey, queryFn, ...queryOptions } as UseSuspenseQueryOptions<
    Awaited<ReturnType<typeof logsShow>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type LogsShowSuspenseQueryResult = NonNullable<
  Awaited<ReturnType<typeof logsShow>>
>;
export type LogsShowSuspenseQueryError = ErrorType<
  AuthenticationExceptionResponse | LogsShow404 | LogsShow500
>;

export function useLogsShowSuspense<
  TData = Awaited<ReturnType<typeof logsShow>>,
  TError = ErrorType<
    AuthenticationExceptionResponse | LogsShow404 | LogsShow500
  >
>(
  logFile: string,
  options: {
    query: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof logsShow>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useLogsShowSuspense<
  TData = Awaited<ReturnType<typeof logsShow>>,
  TError = ErrorType<
    AuthenticationExceptionResponse | LogsShow404 | LogsShow500
  >
>(
  logFile: string,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof logsShow>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useLogsShowSuspense<
  TData = Awaited<ReturnType<typeof logsShow>>,
  TError = ErrorType<
    AuthenticationExceptionResponse | LogsShow404 | LogsShow500
  >
>(
  logFile: string,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof logsShow>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Show a log file
 */

export function useLogsShowSuspense<
  TData = Awaited<ReturnType<typeof logsShow>>,
  TError = ErrorType<
    AuthenticationExceptionResponse | LogsShow404 | LogsShow500
  >
>(
  logFile: string,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof logsShow>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getLogsShowSuspenseQueryOptions(logFile, options);

  const query = useSuspenseQuery(
    queryOptions,
    queryClient
  ) as UseSuspenseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getLogsShowSuspenseInfiniteQueryOptions = <
  TData = InfiniteData<Awaited<ReturnType<typeof logsShow>>>,
  TError = ErrorType<
    AuthenticationExceptionResponse | LogsShow404 | LogsShow500
  >
>(
  logFile: string,
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof logsShow>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getLogsShowQueryKey(logFile);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof logsShow>>> = ({
    signal,
  }) => logsShow(logFile, requestOptions, signal);

  return {
    queryKey,
    queryFn,
    ...queryOptions,
  } as UseSuspenseInfiniteQueryOptions<
    Awaited<ReturnType<typeof logsShow>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type LogsShowSuspenseInfiniteQueryResult = NonNullable<
  Awaited<ReturnType<typeof logsShow>>
>;
export type LogsShowSuspenseInfiniteQueryError = ErrorType<
  AuthenticationExceptionResponse | LogsShow404 | LogsShow500
>;

export function useLogsShowSuspenseInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof logsShow>>>,
  TError = ErrorType<
    AuthenticationExceptionResponse | LogsShow404 | LogsShow500
  >
>(
  logFile: string,
  options: {
    query: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof logsShow>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useLogsShowSuspenseInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof logsShow>>>,
  TError = ErrorType<
    AuthenticationExceptionResponse | LogsShow404 | LogsShow500
  >
>(
  logFile: string,
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof logsShow>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useLogsShowSuspenseInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof logsShow>>>,
  TError = ErrorType<
    AuthenticationExceptionResponse | LogsShow404 | LogsShow500
  >
>(
  logFile: string,
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof logsShow>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Show a log file
 */

export function useLogsShowSuspenseInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof logsShow>>>,
  TError = ErrorType<
    AuthenticationExceptionResponse | LogsShow404 | LogsShow500
  >
>(
  logFile: string,
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof logsShow>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getLogsShowSuspenseInfiniteQueryOptions(
    logFile,
    options
  );

  const query = useSuspenseInfiniteQuery(
    queryOptions,
    queryClient
  ) as UseSuspenseInfiniteQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Get log file content
 */
export const logsContent = (
  logFile: string,
  params?: LogsContentParams,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal
) => {
  return customInstance<LogsContent200>(
    { url: `/api/logs/${logFile}/content`, method: "GET", params, signal },
    options
  );
};

export const getLogsContentQueryKey = (
  logFile?: string,
  params?: LogsContentParams
) => {
  return [`/api/logs/${logFile}/content`, ...(params ? [params] : [])] as const;
};

export const getLogsContentInfiniteQueryOptions = <
  TData = InfiniteData<
    Awaited<ReturnType<typeof logsContent>>,
    LogsContentParams["limit"]
  >,
  TError = ErrorType<
    | AuthenticationExceptionResponse
    | LogsContent404
    | ValidationExceptionResponse
    | LogsContent500
  >
>(
  logFile: string,
  params?: LogsContentParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof logsContent>>,
        TError,
        TData,
        QueryKey,
        LogsContentParams["limit"]
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getLogsContentQueryKey(logFile, params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof logsContent>>,
    QueryKey,
    LogsContentParams["limit"]
  > = ({ signal, pageParam }) =>
    logsContent(
      logFile,
      { ...params, limit: pageParam || params?.["limit"] },
      requestOptions,
      signal
    );

  return {
    queryKey,
    queryFn,
    enabled: !!logFile,
    ...queryOptions,
  } as UseInfiniteQueryOptions<
    Awaited<ReturnType<typeof logsContent>>,
    TError,
    TData,
    QueryKey,
    LogsContentParams["limit"]
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type LogsContentInfiniteQueryResult = NonNullable<
  Awaited<ReturnType<typeof logsContent>>
>;
export type LogsContentInfiniteQueryError = ErrorType<
  | AuthenticationExceptionResponse
  | LogsContent404
  | ValidationExceptionResponse
  | LogsContent500
>;

export function useLogsContentInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof logsContent>>,
    LogsContentParams["limit"]
  >,
  TError = ErrorType<
    | AuthenticationExceptionResponse
    | LogsContent404
    | ValidationExceptionResponse
    | LogsContent500
  >
>(
  logFile: string,
  params: undefined | LogsContentParams,
  options: {
    query: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof logsContent>>,
        TError,
        TData,
        QueryKey,
        LogsContentParams["limit"]
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof logsContent>>,
          TError,
          Awaited<ReturnType<typeof logsContent>>,
          QueryKey
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): DefinedUseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useLogsContentInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof logsContent>>,
    LogsContentParams["limit"]
  >,
  TError = ErrorType<
    | AuthenticationExceptionResponse
    | LogsContent404
    | ValidationExceptionResponse
    | LogsContent500
  >
>(
  logFile: string,
  params?: LogsContentParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof logsContent>>,
        TError,
        TData,
        QueryKey,
        LogsContentParams["limit"]
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof logsContent>>,
          TError,
          Awaited<ReturnType<typeof logsContent>>,
          QueryKey
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useLogsContentInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof logsContent>>,
    LogsContentParams["limit"]
  >,
  TError = ErrorType<
    | AuthenticationExceptionResponse
    | LogsContent404
    | ValidationExceptionResponse
    | LogsContent500
  >
>(
  logFile: string,
  params?: LogsContentParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof logsContent>>,
        TError,
        TData,
        QueryKey,
        LogsContentParams["limit"]
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get log file content
 */

export function useLogsContentInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof logsContent>>,
    LogsContentParams["limit"]
  >,
  TError = ErrorType<
    | AuthenticationExceptionResponse
    | LogsContent404
    | ValidationExceptionResponse
    | LogsContent500
  >
>(
  logFile: string,
  params?: LogsContentParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof logsContent>>,
        TError,
        TData,
        QueryKey,
        LogsContentParams["limit"]
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getLogsContentInfiniteQueryOptions(
    logFile,
    params,
    options
  );

  const query = useInfiniteQuery(
    queryOptions,
    queryClient
  ) as UseInfiniteQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getLogsContentQueryOptions = <
  TData = Awaited<ReturnType<typeof logsContent>>,
  TError = ErrorType<
    | AuthenticationExceptionResponse
    | LogsContent404
    | ValidationExceptionResponse
    | LogsContent500
  >
>(
  logFile: string,
  params?: LogsContentParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof logsContent>>, TError, TData>
    >;
    request?: SecondParameter<typeof customInstance>;
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getLogsContentQueryKey(logFile, params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof logsContent>>> = ({
    signal,
  }) => logsContent(logFile, params, requestOptions, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!logFile,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof logsContent>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type LogsContentQueryResult = NonNullable<
  Awaited<ReturnType<typeof logsContent>>
>;
export type LogsContentQueryError = ErrorType<
  | AuthenticationExceptionResponse
  | LogsContent404
  | ValidationExceptionResponse
  | LogsContent500
>;

export function useLogsContent<
  TData = Awaited<ReturnType<typeof logsContent>>,
  TError = ErrorType<
    | AuthenticationExceptionResponse
    | LogsContent404
    | ValidationExceptionResponse
    | LogsContent500
  >
>(
  logFile: string,
  params: undefined | LogsContentParams,
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof logsContent>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof logsContent>>,
          TError,
          Awaited<ReturnType<typeof logsContent>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useLogsContent<
  TData = Awaited<ReturnType<typeof logsContent>>,
  TError = ErrorType<
    | AuthenticationExceptionResponse
    | LogsContent404
    | ValidationExceptionResponse
    | LogsContent500
  >
>(
  logFile: string,
  params?: LogsContentParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof logsContent>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof logsContent>>,
          TError,
          Awaited<ReturnType<typeof logsContent>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useLogsContent<
  TData = Awaited<ReturnType<typeof logsContent>>,
  TError = ErrorType<
    | AuthenticationExceptionResponse
    | LogsContent404
    | ValidationExceptionResponse
    | LogsContent500
  >
>(
  logFile: string,
  params?: LogsContentParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof logsContent>>, TError, TData>
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get log file content
 */

export function useLogsContent<
  TData = Awaited<ReturnType<typeof logsContent>>,
  TError = ErrorType<
    | AuthenticationExceptionResponse
    | LogsContent404
    | ValidationExceptionResponse
    | LogsContent500
  >
>(
  logFile: string,
  params?: LogsContentParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof logsContent>>, TError, TData>
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getLogsContentQueryOptions(logFile, params, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getLogsContentSuspenseQueryOptions = <
  TData = Awaited<ReturnType<typeof logsContent>>,
  TError = ErrorType<
    | AuthenticationExceptionResponse
    | LogsContent404
    | ValidationExceptionResponse
    | LogsContent500
  >
>(
  logFile: string,
  params?: LogsContentParams,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof logsContent>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getLogsContentQueryKey(logFile, params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof logsContent>>> = ({
    signal,
  }) => logsContent(logFile, params, requestOptions, signal);

  return { queryKey, queryFn, ...queryOptions } as UseSuspenseQueryOptions<
    Awaited<ReturnType<typeof logsContent>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type LogsContentSuspenseQueryResult = NonNullable<
  Awaited<ReturnType<typeof logsContent>>
>;
export type LogsContentSuspenseQueryError = ErrorType<
  | AuthenticationExceptionResponse
  | LogsContent404
  | ValidationExceptionResponse
  | LogsContent500
>;

export function useLogsContentSuspense<
  TData = Awaited<ReturnType<typeof logsContent>>,
  TError = ErrorType<
    | AuthenticationExceptionResponse
    | LogsContent404
    | ValidationExceptionResponse
    | LogsContent500
  >
>(
  logFile: string,
  params: undefined | LogsContentParams,
  options: {
    query: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof logsContent>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useLogsContentSuspense<
  TData = Awaited<ReturnType<typeof logsContent>>,
  TError = ErrorType<
    | AuthenticationExceptionResponse
    | LogsContent404
    | ValidationExceptionResponse
    | LogsContent500
  >
>(
  logFile: string,
  params?: LogsContentParams,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof logsContent>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useLogsContentSuspense<
  TData = Awaited<ReturnType<typeof logsContent>>,
  TError = ErrorType<
    | AuthenticationExceptionResponse
    | LogsContent404
    | ValidationExceptionResponse
    | LogsContent500
  >
>(
  logFile: string,
  params?: LogsContentParams,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof logsContent>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get log file content
 */

export function useLogsContentSuspense<
  TData = Awaited<ReturnType<typeof logsContent>>,
  TError = ErrorType<
    | AuthenticationExceptionResponse
    | LogsContent404
    | ValidationExceptionResponse
    | LogsContent500
  >
>(
  logFile: string,
  params?: LogsContentParams,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof logsContent>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getLogsContentSuspenseQueryOptions(
    logFile,
    params,
    options
  );

  const query = useSuspenseQuery(
    queryOptions,
    queryClient
  ) as UseSuspenseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getLogsContentSuspenseInfiniteQueryOptions = <
  TData = InfiniteData<
    Awaited<ReturnType<typeof logsContent>>,
    LogsContentParams["limit"]
  >,
  TError = ErrorType<
    | AuthenticationExceptionResponse
    | LogsContent404
    | ValidationExceptionResponse
    | LogsContent500
  >
>(
  logFile: string,
  params?: LogsContentParams,
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof logsContent>>,
        TError,
        TData,
        QueryKey,
        LogsContentParams["limit"]
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getLogsContentQueryKey(logFile, params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof logsContent>>,
    QueryKey,
    LogsContentParams["limit"]
  > = ({ signal, pageParam }) =>
    logsContent(
      logFile,
      { ...params, limit: pageParam || params?.["limit"] },
      requestOptions,
      signal
    );

  return {
    queryKey,
    queryFn,
    ...queryOptions,
  } as UseSuspenseInfiniteQueryOptions<
    Awaited<ReturnType<typeof logsContent>>,
    TError,
    TData,
    QueryKey,
    LogsContentParams["limit"]
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type LogsContentSuspenseInfiniteQueryResult = NonNullable<
  Awaited<ReturnType<typeof logsContent>>
>;
export type LogsContentSuspenseInfiniteQueryError = ErrorType<
  | AuthenticationExceptionResponse
  | LogsContent404
  | ValidationExceptionResponse
  | LogsContent500
>;

export function useLogsContentSuspenseInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof logsContent>>,
    LogsContentParams["limit"]
  >,
  TError = ErrorType<
    | AuthenticationExceptionResponse
    | LogsContent404
    | ValidationExceptionResponse
    | LogsContent500
  >
>(
  logFile: string,
  params: undefined | LogsContentParams,
  options: {
    query: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof logsContent>>,
        TError,
        TData,
        QueryKey,
        LogsContentParams["limit"]
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useLogsContentSuspenseInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof logsContent>>,
    LogsContentParams["limit"]
  >,
  TError = ErrorType<
    | AuthenticationExceptionResponse
    | LogsContent404
    | ValidationExceptionResponse
    | LogsContent500
  >
>(
  logFile: string,
  params?: LogsContentParams,
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof logsContent>>,
        TError,
        TData,
        QueryKey,
        LogsContentParams["limit"]
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useLogsContentSuspenseInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof logsContent>>,
    LogsContentParams["limit"]
  >,
  TError = ErrorType<
    | AuthenticationExceptionResponse
    | LogsContent404
    | ValidationExceptionResponse
    | LogsContent500
  >
>(
  logFile: string,
  params?: LogsContentParams,
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof logsContent>>,
        TError,
        TData,
        QueryKey,
        LogsContentParams["limit"]
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get log file content
 */

export function useLogsContentSuspenseInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof logsContent>>,
    LogsContentParams["limit"]
  >,
  TError = ErrorType<
    | AuthenticationExceptionResponse
    | LogsContent404
    | ValidationExceptionResponse
    | LogsContent500
  >
>(
  logFile: string,
  params?: LogsContentParams,
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof logsContent>>,
        TError,
        TData,
        QueryKey,
        LogsContentParams["limit"]
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getLogsContentSuspenseInfiniteQueryOptions(
    logFile,
    params,
    options
  );

  const query = useSuspenseInfiniteQuery(
    queryOptions,
    queryClient
  ) as UseSuspenseInfiniteQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Count log file lines
 */
export const logsLines = (
  logFile: string,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal
) => {
  return customInstance<LogsLines200>(
    { url: `/api/logs/${logFile}/lines`, method: "GET", signal },
    options
  );
};

export const getLogsLinesQueryKey = (logFile?: string) => {
  return [`/api/logs/${logFile}/lines`] as const;
};

export const getLogsLinesInfiniteQueryOptions = <
  TData = InfiniteData<Awaited<ReturnType<typeof logsLines>>>,
  TError = ErrorType<
    AuthenticationExceptionResponse | LogsLines404 | LogsLines500
  >
>(
  logFile: string,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof logsLines>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getLogsLinesQueryKey(logFile);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof logsLines>>> = ({
    signal,
  }) => logsLines(logFile, requestOptions, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!logFile,
    ...queryOptions,
  } as UseInfiniteQueryOptions<
    Awaited<ReturnType<typeof logsLines>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type LogsLinesInfiniteQueryResult = NonNullable<
  Awaited<ReturnType<typeof logsLines>>
>;
export type LogsLinesInfiniteQueryError = ErrorType<
  AuthenticationExceptionResponse | LogsLines404 | LogsLines500
>;

export function useLogsLinesInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof logsLines>>>,
  TError = ErrorType<
    AuthenticationExceptionResponse | LogsLines404 | LogsLines500
  >
>(
  logFile: string,
  options: {
    query: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof logsLines>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof logsLines>>,
          TError,
          Awaited<ReturnType<typeof logsLines>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): DefinedUseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useLogsLinesInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof logsLines>>>,
  TError = ErrorType<
    AuthenticationExceptionResponse | LogsLines404 | LogsLines500
  >
>(
  logFile: string,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof logsLines>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof logsLines>>,
          TError,
          Awaited<ReturnType<typeof logsLines>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useLogsLinesInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof logsLines>>>,
  TError = ErrorType<
    AuthenticationExceptionResponse | LogsLines404 | LogsLines500
  >
>(
  logFile: string,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof logsLines>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Count log file lines
 */

export function useLogsLinesInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof logsLines>>>,
  TError = ErrorType<
    AuthenticationExceptionResponse | LogsLines404 | LogsLines500
  >
>(
  logFile: string,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof logsLines>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getLogsLinesInfiniteQueryOptions(logFile, options);

  const query = useInfiniteQuery(
    queryOptions,
    queryClient
  ) as UseInfiniteQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getLogsLinesQueryOptions = <
  TData = Awaited<ReturnType<typeof logsLines>>,
  TError = ErrorType<
    AuthenticationExceptionResponse | LogsLines404 | LogsLines500
  >
>(
  logFile: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof logsLines>>, TError, TData>
    >;
    request?: SecondParameter<typeof customInstance>;
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getLogsLinesQueryKey(logFile);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof logsLines>>> = ({
    signal,
  }) => logsLines(logFile, requestOptions, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!logFile,
    ...queryOptions,
  } as UseQueryOptions<Awaited<ReturnType<typeof logsLines>>, TError, TData> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };
};

export type LogsLinesQueryResult = NonNullable<
  Awaited<ReturnType<typeof logsLines>>
>;
export type LogsLinesQueryError = ErrorType<
  AuthenticationExceptionResponse | LogsLines404 | LogsLines500
>;

export function useLogsLines<
  TData = Awaited<ReturnType<typeof logsLines>>,
  TError = ErrorType<
    AuthenticationExceptionResponse | LogsLines404 | LogsLines500
  >
>(
  logFile: string,
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof logsLines>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof logsLines>>,
          TError,
          Awaited<ReturnType<typeof logsLines>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useLogsLines<
  TData = Awaited<ReturnType<typeof logsLines>>,
  TError = ErrorType<
    AuthenticationExceptionResponse | LogsLines404 | LogsLines500
  >
>(
  logFile: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof logsLines>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof logsLines>>,
          TError,
          Awaited<ReturnType<typeof logsLines>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useLogsLines<
  TData = Awaited<ReturnType<typeof logsLines>>,
  TError = ErrorType<
    AuthenticationExceptionResponse | LogsLines404 | LogsLines500
  >
>(
  logFile: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof logsLines>>, TError, TData>
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Count log file lines
 */

export function useLogsLines<
  TData = Awaited<ReturnType<typeof logsLines>>,
  TError = ErrorType<
    AuthenticationExceptionResponse | LogsLines404 | LogsLines500
  >
>(
  logFile: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof logsLines>>, TError, TData>
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getLogsLinesQueryOptions(logFile, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getLogsLinesSuspenseQueryOptions = <
  TData = Awaited<ReturnType<typeof logsLines>>,
  TError = ErrorType<
    AuthenticationExceptionResponse | LogsLines404 | LogsLines500
  >
>(
  logFile: string,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof logsLines>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getLogsLinesQueryKey(logFile);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof logsLines>>> = ({
    signal,
  }) => logsLines(logFile, requestOptions, signal);

  return { queryKey, queryFn, ...queryOptions } as UseSuspenseQueryOptions<
    Awaited<ReturnType<typeof logsLines>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type LogsLinesSuspenseQueryResult = NonNullable<
  Awaited<ReturnType<typeof logsLines>>
>;
export type LogsLinesSuspenseQueryError = ErrorType<
  AuthenticationExceptionResponse | LogsLines404 | LogsLines500
>;

export function useLogsLinesSuspense<
  TData = Awaited<ReturnType<typeof logsLines>>,
  TError = ErrorType<
    AuthenticationExceptionResponse | LogsLines404 | LogsLines500
  >
>(
  logFile: string,
  options: {
    query: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof logsLines>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useLogsLinesSuspense<
  TData = Awaited<ReturnType<typeof logsLines>>,
  TError = ErrorType<
    AuthenticationExceptionResponse | LogsLines404 | LogsLines500
  >
>(
  logFile: string,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof logsLines>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useLogsLinesSuspense<
  TData = Awaited<ReturnType<typeof logsLines>>,
  TError = ErrorType<
    AuthenticationExceptionResponse | LogsLines404 | LogsLines500
  >
>(
  logFile: string,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof logsLines>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Count log file lines
 */

export function useLogsLinesSuspense<
  TData = Awaited<ReturnType<typeof logsLines>>,
  TError = ErrorType<
    AuthenticationExceptionResponse | LogsLines404 | LogsLines500
  >
>(
  logFile: string,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof logsLines>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getLogsLinesSuspenseQueryOptions(logFile, options);

  const query = useSuspenseQuery(
    queryOptions,
    queryClient
  ) as UseSuspenseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getLogsLinesSuspenseInfiniteQueryOptions = <
  TData = InfiniteData<Awaited<ReturnType<typeof logsLines>>>,
  TError = ErrorType<
    AuthenticationExceptionResponse | LogsLines404 | LogsLines500
  >
>(
  logFile: string,
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof logsLines>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getLogsLinesQueryKey(logFile);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof logsLines>>> = ({
    signal,
  }) => logsLines(logFile, requestOptions, signal);

  return {
    queryKey,
    queryFn,
    ...queryOptions,
  } as UseSuspenseInfiniteQueryOptions<
    Awaited<ReturnType<typeof logsLines>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type LogsLinesSuspenseInfiniteQueryResult = NonNullable<
  Awaited<ReturnType<typeof logsLines>>
>;
export type LogsLinesSuspenseInfiniteQueryError = ErrorType<
  AuthenticationExceptionResponse | LogsLines404 | LogsLines500
>;

export function useLogsLinesSuspenseInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof logsLines>>>,
  TError = ErrorType<
    AuthenticationExceptionResponse | LogsLines404 | LogsLines500
  >
>(
  logFile: string,
  options: {
    query: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof logsLines>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useLogsLinesSuspenseInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof logsLines>>>,
  TError = ErrorType<
    AuthenticationExceptionResponse | LogsLines404 | LogsLines500
  >
>(
  logFile: string,
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof logsLines>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useLogsLinesSuspenseInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof logsLines>>>,
  TError = ErrorType<
    AuthenticationExceptionResponse | LogsLines404 | LogsLines500
  >
>(
  logFile: string,
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof logsLines>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Count log file lines
 */

export function useLogsLinesSuspenseInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof logsLines>>>,
  TError = ErrorType<
    AuthenticationExceptionResponse | LogsLines404 | LogsLines500
  >
>(
  logFile: string,
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof logsLines>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getLogsLinesSuspenseInfiniteQueryOptions(
    logFile,
    options
  );

  const query = useSuspenseInfiniteQuery(
    queryOptions,
    queryClient
  ) as UseSuspenseInfiniteQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Search log file content
 */
export const logsSearch = (
  logFile: string,
  params: LogsSearchParams,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal
) => {
  return customInstance<LogsSearch200>(
    { url: `/api/logs/${logFile}/search`, method: "GET", params, signal },
    options
  );
};

export const getLogsSearchQueryKey = (
  logFile?: string,
  params?: LogsSearchParams
) => {
  return [`/api/logs/${logFile}/search`, ...(params ? [params] : [])] as const;
};

export const getLogsSearchInfiniteQueryOptions = <
  TData = InfiniteData<
    Awaited<ReturnType<typeof logsSearch>>,
    LogsSearchParams["limit"]
  >,
  TError = ErrorType<
    | AuthenticationExceptionResponse
    | LogsSearch404
    | ValidationExceptionResponse
    | LogsSearch500
  >
>(
  logFile: string,
  params: LogsSearchParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof logsSearch>>,
        TError,
        TData,
        QueryKey,
        LogsSearchParams["limit"]
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getLogsSearchQueryKey(logFile, params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof logsSearch>>,
    QueryKey,
    LogsSearchParams["limit"]
  > = ({ signal, pageParam }) =>
    logsSearch(
      logFile,
      { ...params, limit: pageParam || params?.["limit"] },
      requestOptions,
      signal
    );

  return {
    queryKey,
    queryFn,
    enabled: !!logFile,
    ...queryOptions,
  } as UseInfiniteQueryOptions<
    Awaited<ReturnType<typeof logsSearch>>,
    TError,
    TData,
    QueryKey,
    LogsSearchParams["limit"]
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type LogsSearchInfiniteQueryResult = NonNullable<
  Awaited<ReturnType<typeof logsSearch>>
>;
export type LogsSearchInfiniteQueryError = ErrorType<
  | AuthenticationExceptionResponse
  | LogsSearch404
  | ValidationExceptionResponse
  | LogsSearch500
>;

export function useLogsSearchInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof logsSearch>>,
    LogsSearchParams["limit"]
  >,
  TError = ErrorType<
    | AuthenticationExceptionResponse
    | LogsSearch404
    | ValidationExceptionResponse
    | LogsSearch500
  >
>(
  logFile: string,
  params: LogsSearchParams,
  options: {
    query: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof logsSearch>>,
        TError,
        TData,
        QueryKey,
        LogsSearchParams["limit"]
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof logsSearch>>,
          TError,
          Awaited<ReturnType<typeof logsSearch>>,
          QueryKey
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): DefinedUseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useLogsSearchInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof logsSearch>>,
    LogsSearchParams["limit"]
  >,
  TError = ErrorType<
    | AuthenticationExceptionResponse
    | LogsSearch404
    | ValidationExceptionResponse
    | LogsSearch500
  >
>(
  logFile: string,
  params: LogsSearchParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof logsSearch>>,
        TError,
        TData,
        QueryKey,
        LogsSearchParams["limit"]
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof logsSearch>>,
          TError,
          Awaited<ReturnType<typeof logsSearch>>,
          QueryKey
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useLogsSearchInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof logsSearch>>,
    LogsSearchParams["limit"]
  >,
  TError = ErrorType<
    | AuthenticationExceptionResponse
    | LogsSearch404
    | ValidationExceptionResponse
    | LogsSearch500
  >
>(
  logFile: string,
  params: LogsSearchParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof logsSearch>>,
        TError,
        TData,
        QueryKey,
        LogsSearchParams["limit"]
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Search log file content
 */

export function useLogsSearchInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof logsSearch>>,
    LogsSearchParams["limit"]
  >,
  TError = ErrorType<
    | AuthenticationExceptionResponse
    | LogsSearch404
    | ValidationExceptionResponse
    | LogsSearch500
  >
>(
  logFile: string,
  params: LogsSearchParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof logsSearch>>,
        TError,
        TData,
        QueryKey,
        LogsSearchParams["limit"]
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getLogsSearchInfiniteQueryOptions(
    logFile,
    params,
    options
  );

  const query = useInfiniteQuery(
    queryOptions,
    queryClient
  ) as UseInfiniteQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getLogsSearchQueryOptions = <
  TData = Awaited<ReturnType<typeof logsSearch>>,
  TError = ErrorType<
    | AuthenticationExceptionResponse
    | LogsSearch404
    | ValidationExceptionResponse
    | LogsSearch500
  >
>(
  logFile: string,
  params: LogsSearchParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof logsSearch>>, TError, TData>
    >;
    request?: SecondParameter<typeof customInstance>;
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getLogsSearchQueryKey(logFile, params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof logsSearch>>> = ({
    signal,
  }) => logsSearch(logFile, params, requestOptions, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!logFile,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof logsSearch>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type LogsSearchQueryResult = NonNullable<
  Awaited<ReturnType<typeof logsSearch>>
>;
export type LogsSearchQueryError = ErrorType<
  | AuthenticationExceptionResponse
  | LogsSearch404
  | ValidationExceptionResponse
  | LogsSearch500
>;

export function useLogsSearch<
  TData = Awaited<ReturnType<typeof logsSearch>>,
  TError = ErrorType<
    | AuthenticationExceptionResponse
    | LogsSearch404
    | ValidationExceptionResponse
    | LogsSearch500
  >
>(
  logFile: string,
  params: LogsSearchParams,
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof logsSearch>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof logsSearch>>,
          TError,
          Awaited<ReturnType<typeof logsSearch>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useLogsSearch<
  TData = Awaited<ReturnType<typeof logsSearch>>,
  TError = ErrorType<
    | AuthenticationExceptionResponse
    | LogsSearch404
    | ValidationExceptionResponse
    | LogsSearch500
  >
>(
  logFile: string,
  params: LogsSearchParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof logsSearch>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof logsSearch>>,
          TError,
          Awaited<ReturnType<typeof logsSearch>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useLogsSearch<
  TData = Awaited<ReturnType<typeof logsSearch>>,
  TError = ErrorType<
    | AuthenticationExceptionResponse
    | LogsSearch404
    | ValidationExceptionResponse
    | LogsSearch500
  >
>(
  logFile: string,
  params: LogsSearchParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof logsSearch>>, TError, TData>
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Search log file content
 */

export function useLogsSearch<
  TData = Awaited<ReturnType<typeof logsSearch>>,
  TError = ErrorType<
    | AuthenticationExceptionResponse
    | LogsSearch404
    | ValidationExceptionResponse
    | LogsSearch500
  >
>(
  logFile: string,
  params: LogsSearchParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof logsSearch>>, TError, TData>
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getLogsSearchQueryOptions(logFile, params, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getLogsSearchSuspenseQueryOptions = <
  TData = Awaited<ReturnType<typeof logsSearch>>,
  TError = ErrorType<
    | AuthenticationExceptionResponse
    | LogsSearch404
    | ValidationExceptionResponse
    | LogsSearch500
  >
>(
  logFile: string,
  params: LogsSearchParams,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof logsSearch>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getLogsSearchQueryKey(logFile, params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof logsSearch>>> = ({
    signal,
  }) => logsSearch(logFile, params, requestOptions, signal);

  return { queryKey, queryFn, ...queryOptions } as UseSuspenseQueryOptions<
    Awaited<ReturnType<typeof logsSearch>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type LogsSearchSuspenseQueryResult = NonNullable<
  Awaited<ReturnType<typeof logsSearch>>
>;
export type LogsSearchSuspenseQueryError = ErrorType<
  | AuthenticationExceptionResponse
  | LogsSearch404
  | ValidationExceptionResponse
  | LogsSearch500
>;

export function useLogsSearchSuspense<
  TData = Awaited<ReturnType<typeof logsSearch>>,
  TError = ErrorType<
    | AuthenticationExceptionResponse
    | LogsSearch404
    | ValidationExceptionResponse
    | LogsSearch500
  >
>(
  logFile: string,
  params: LogsSearchParams,
  options: {
    query: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof logsSearch>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useLogsSearchSuspense<
  TData = Awaited<ReturnType<typeof logsSearch>>,
  TError = ErrorType<
    | AuthenticationExceptionResponse
    | LogsSearch404
    | ValidationExceptionResponse
    | LogsSearch500
  >
>(
  logFile: string,
  params: LogsSearchParams,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof logsSearch>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useLogsSearchSuspense<
  TData = Awaited<ReturnType<typeof logsSearch>>,
  TError = ErrorType<
    | AuthenticationExceptionResponse
    | LogsSearch404
    | ValidationExceptionResponse
    | LogsSearch500
  >
>(
  logFile: string,
  params: LogsSearchParams,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof logsSearch>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Search log file content
 */

export function useLogsSearchSuspense<
  TData = Awaited<ReturnType<typeof logsSearch>>,
  TError = ErrorType<
    | AuthenticationExceptionResponse
    | LogsSearch404
    | ValidationExceptionResponse
    | LogsSearch500
  >
>(
  logFile: string,
  params: LogsSearchParams,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof logsSearch>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getLogsSearchSuspenseQueryOptions(
    logFile,
    params,
    options
  );

  const query = useSuspenseQuery(
    queryOptions,
    queryClient
  ) as UseSuspenseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getLogsSearchSuspenseInfiniteQueryOptions = <
  TData = InfiniteData<
    Awaited<ReturnType<typeof logsSearch>>,
    LogsSearchParams["limit"]
  >,
  TError = ErrorType<
    | AuthenticationExceptionResponse
    | LogsSearch404
    | ValidationExceptionResponse
    | LogsSearch500
  >
>(
  logFile: string,
  params: LogsSearchParams,
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof logsSearch>>,
        TError,
        TData,
        QueryKey,
        LogsSearchParams["limit"]
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getLogsSearchQueryKey(logFile, params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof logsSearch>>,
    QueryKey,
    LogsSearchParams["limit"]
  > = ({ signal, pageParam }) =>
    logsSearch(
      logFile,
      { ...params, limit: pageParam || params?.["limit"] },
      requestOptions,
      signal
    );

  return {
    queryKey,
    queryFn,
    ...queryOptions,
  } as UseSuspenseInfiniteQueryOptions<
    Awaited<ReturnType<typeof logsSearch>>,
    TError,
    TData,
    QueryKey,
    LogsSearchParams["limit"]
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type LogsSearchSuspenseInfiniteQueryResult = NonNullable<
  Awaited<ReturnType<typeof logsSearch>>
>;
export type LogsSearchSuspenseInfiniteQueryError = ErrorType<
  | AuthenticationExceptionResponse
  | LogsSearch404
  | ValidationExceptionResponse
  | LogsSearch500
>;

export function useLogsSearchSuspenseInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof logsSearch>>,
    LogsSearchParams["limit"]
  >,
  TError = ErrorType<
    | AuthenticationExceptionResponse
    | LogsSearch404
    | ValidationExceptionResponse
    | LogsSearch500
  >
>(
  logFile: string,
  params: LogsSearchParams,
  options: {
    query: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof logsSearch>>,
        TError,
        TData,
        QueryKey,
        LogsSearchParams["limit"]
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useLogsSearchSuspenseInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof logsSearch>>,
    LogsSearchParams["limit"]
  >,
  TError = ErrorType<
    | AuthenticationExceptionResponse
    | LogsSearch404
    | ValidationExceptionResponse
    | LogsSearch500
  >
>(
  logFile: string,
  params: LogsSearchParams,
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof logsSearch>>,
        TError,
        TData,
        QueryKey,
        LogsSearchParams["limit"]
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useLogsSearchSuspenseInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof logsSearch>>,
    LogsSearchParams["limit"]
  >,
  TError = ErrorType<
    | AuthenticationExceptionResponse
    | LogsSearch404
    | ValidationExceptionResponse
    | LogsSearch500
  >
>(
  logFile: string,
  params: LogsSearchParams,
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof logsSearch>>,
        TError,
        TData,
        QueryKey,
        LogsSearchParams["limit"]
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Search log file content
 */

export function useLogsSearchSuspenseInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof logsSearch>>,
    LogsSearchParams["limit"]
  >,
  TError = ErrorType<
    | AuthenticationExceptionResponse
    | LogsSearch404
    | ValidationExceptionResponse
    | LogsSearch500
  >
>(
  logFile: string,
  params: LogsSearchParams,
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof logsSearch>>,
        TError,
        TData,
        QueryKey,
        LogsSearchParams["limit"]
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getLogsSearchSuspenseInfiniteQueryOptions(
    logFile,
    params,
    options
  );

  const query = useSuspenseInfiniteQuery(
    queryOptions,
    queryClient
  ) as UseSuspenseInfiniteQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Get log file tail
 */
export const logsTail = (
  logFile: string,
  params?: LogsTailParams,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal
) => {
  return customInstance<LogsTail200>(
    { url: `/api/logs/${logFile}/tail`, method: "GET", params, signal },
    options
  );
};

export const getLogsTailQueryKey = (
  logFile?: string,
  params?: LogsTailParams
) => {
  return [`/api/logs/${logFile}/tail`, ...(params ? [params] : [])] as const;
};

export const getLogsTailInfiniteQueryOptions = <
  TData = InfiniteData<
    Awaited<ReturnType<typeof logsTail>>,
    LogsTailParams["limit"]
  >,
  TError = ErrorType<
    | AuthenticationExceptionResponse
    | LogsTail404
    | ValidationExceptionResponse
    | LogsTail500
  >
>(
  logFile: string,
  params?: LogsTailParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof logsTail>>,
        TError,
        TData,
        QueryKey,
        LogsTailParams["limit"]
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getLogsTailQueryKey(logFile, params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof logsTail>>,
    QueryKey,
    LogsTailParams["limit"]
  > = ({ signal, pageParam }) =>
    logsTail(
      logFile,
      { ...params, limit: pageParam || params?.["limit"] },
      requestOptions,
      signal
    );

  return {
    queryKey,
    queryFn,
    enabled: !!logFile,
    ...queryOptions,
  } as UseInfiniteQueryOptions<
    Awaited<ReturnType<typeof logsTail>>,
    TError,
    TData,
    QueryKey,
    LogsTailParams["limit"]
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type LogsTailInfiniteQueryResult = NonNullable<
  Awaited<ReturnType<typeof logsTail>>
>;
export type LogsTailInfiniteQueryError = ErrorType<
  | AuthenticationExceptionResponse
  | LogsTail404
  | ValidationExceptionResponse
  | LogsTail500
>;

export function useLogsTailInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof logsTail>>,
    LogsTailParams["limit"]
  >,
  TError = ErrorType<
    | AuthenticationExceptionResponse
    | LogsTail404
    | ValidationExceptionResponse
    | LogsTail500
  >
>(
  logFile: string,
  params: undefined | LogsTailParams,
  options: {
    query: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof logsTail>>,
        TError,
        TData,
        QueryKey,
        LogsTailParams["limit"]
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof logsTail>>,
          TError,
          Awaited<ReturnType<typeof logsTail>>,
          QueryKey
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): DefinedUseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useLogsTailInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof logsTail>>,
    LogsTailParams["limit"]
  >,
  TError = ErrorType<
    | AuthenticationExceptionResponse
    | LogsTail404
    | ValidationExceptionResponse
    | LogsTail500
  >
>(
  logFile: string,
  params?: LogsTailParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof logsTail>>,
        TError,
        TData,
        QueryKey,
        LogsTailParams["limit"]
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof logsTail>>,
          TError,
          Awaited<ReturnType<typeof logsTail>>,
          QueryKey
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useLogsTailInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof logsTail>>,
    LogsTailParams["limit"]
  >,
  TError = ErrorType<
    | AuthenticationExceptionResponse
    | LogsTail404
    | ValidationExceptionResponse
    | LogsTail500
  >
>(
  logFile: string,
  params?: LogsTailParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof logsTail>>,
        TError,
        TData,
        QueryKey,
        LogsTailParams["limit"]
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get log file tail
 */

export function useLogsTailInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof logsTail>>,
    LogsTailParams["limit"]
  >,
  TError = ErrorType<
    | AuthenticationExceptionResponse
    | LogsTail404
    | ValidationExceptionResponse
    | LogsTail500
  >
>(
  logFile: string,
  params?: LogsTailParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof logsTail>>,
        TError,
        TData,
        QueryKey,
        LogsTailParams["limit"]
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getLogsTailInfiniteQueryOptions(
    logFile,
    params,
    options
  );

  const query = useInfiniteQuery(
    queryOptions,
    queryClient
  ) as UseInfiniteQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getLogsTailQueryOptions = <
  TData = Awaited<ReturnType<typeof logsTail>>,
  TError = ErrorType<
    | AuthenticationExceptionResponse
    | LogsTail404
    | ValidationExceptionResponse
    | LogsTail500
  >
>(
  logFile: string,
  params?: LogsTailParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof logsTail>>, TError, TData>
    >;
    request?: SecondParameter<typeof customInstance>;
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getLogsTailQueryKey(logFile, params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof logsTail>>> = ({
    signal,
  }) => logsTail(logFile, params, requestOptions, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!logFile,
    ...queryOptions,
  } as UseQueryOptions<Awaited<ReturnType<typeof logsTail>>, TError, TData> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };
};

export type LogsTailQueryResult = NonNullable<
  Awaited<ReturnType<typeof logsTail>>
>;
export type LogsTailQueryError = ErrorType<
  | AuthenticationExceptionResponse
  | LogsTail404
  | ValidationExceptionResponse
  | LogsTail500
>;

export function useLogsTail<
  TData = Awaited<ReturnType<typeof logsTail>>,
  TError = ErrorType<
    | AuthenticationExceptionResponse
    | LogsTail404
    | ValidationExceptionResponse
    | LogsTail500
  >
>(
  logFile: string,
  params: undefined | LogsTailParams,
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof logsTail>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof logsTail>>,
          TError,
          Awaited<ReturnType<typeof logsTail>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useLogsTail<
  TData = Awaited<ReturnType<typeof logsTail>>,
  TError = ErrorType<
    | AuthenticationExceptionResponse
    | LogsTail404
    | ValidationExceptionResponse
    | LogsTail500
  >
>(
  logFile: string,
  params?: LogsTailParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof logsTail>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof logsTail>>,
          TError,
          Awaited<ReturnType<typeof logsTail>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useLogsTail<
  TData = Awaited<ReturnType<typeof logsTail>>,
  TError = ErrorType<
    | AuthenticationExceptionResponse
    | LogsTail404
    | ValidationExceptionResponse
    | LogsTail500
  >
>(
  logFile: string,
  params?: LogsTailParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof logsTail>>, TError, TData>
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get log file tail
 */

export function useLogsTail<
  TData = Awaited<ReturnType<typeof logsTail>>,
  TError = ErrorType<
    | AuthenticationExceptionResponse
    | LogsTail404
    | ValidationExceptionResponse
    | LogsTail500
  >
>(
  logFile: string,
  params?: LogsTailParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof logsTail>>, TError, TData>
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getLogsTailQueryOptions(logFile, params, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getLogsTailSuspenseQueryOptions = <
  TData = Awaited<ReturnType<typeof logsTail>>,
  TError = ErrorType<
    | AuthenticationExceptionResponse
    | LogsTail404
    | ValidationExceptionResponse
    | LogsTail500
  >
>(
  logFile: string,
  params?: LogsTailParams,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof logsTail>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getLogsTailQueryKey(logFile, params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof logsTail>>> = ({
    signal,
  }) => logsTail(logFile, params, requestOptions, signal);

  return { queryKey, queryFn, ...queryOptions } as UseSuspenseQueryOptions<
    Awaited<ReturnType<typeof logsTail>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type LogsTailSuspenseQueryResult = NonNullable<
  Awaited<ReturnType<typeof logsTail>>
>;
export type LogsTailSuspenseQueryError = ErrorType<
  | AuthenticationExceptionResponse
  | LogsTail404
  | ValidationExceptionResponse
  | LogsTail500
>;

export function useLogsTailSuspense<
  TData = Awaited<ReturnType<typeof logsTail>>,
  TError = ErrorType<
    | AuthenticationExceptionResponse
    | LogsTail404
    | ValidationExceptionResponse
    | LogsTail500
  >
>(
  logFile: string,
  params: undefined | LogsTailParams,
  options: {
    query: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof logsTail>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useLogsTailSuspense<
  TData = Awaited<ReturnType<typeof logsTail>>,
  TError = ErrorType<
    | AuthenticationExceptionResponse
    | LogsTail404
    | ValidationExceptionResponse
    | LogsTail500
  >
>(
  logFile: string,
  params?: LogsTailParams,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof logsTail>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useLogsTailSuspense<
  TData = Awaited<ReturnType<typeof logsTail>>,
  TError = ErrorType<
    | AuthenticationExceptionResponse
    | LogsTail404
    | ValidationExceptionResponse
    | LogsTail500
  >
>(
  logFile: string,
  params?: LogsTailParams,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof logsTail>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get log file tail
 */

export function useLogsTailSuspense<
  TData = Awaited<ReturnType<typeof logsTail>>,
  TError = ErrorType<
    | AuthenticationExceptionResponse
    | LogsTail404
    | ValidationExceptionResponse
    | LogsTail500
  >
>(
  logFile: string,
  params?: LogsTailParams,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof logsTail>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getLogsTailSuspenseQueryOptions(
    logFile,
    params,
    options
  );

  const query = useSuspenseQuery(
    queryOptions,
    queryClient
  ) as UseSuspenseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getLogsTailSuspenseInfiniteQueryOptions = <
  TData = InfiniteData<
    Awaited<ReturnType<typeof logsTail>>,
    LogsTailParams["limit"]
  >,
  TError = ErrorType<
    | AuthenticationExceptionResponse
    | LogsTail404
    | ValidationExceptionResponse
    | LogsTail500
  >
>(
  logFile: string,
  params?: LogsTailParams,
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof logsTail>>,
        TError,
        TData,
        QueryKey,
        LogsTailParams["limit"]
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getLogsTailQueryKey(logFile, params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof logsTail>>,
    QueryKey,
    LogsTailParams["limit"]
  > = ({ signal, pageParam }) =>
    logsTail(
      logFile,
      { ...params, limit: pageParam || params?.["limit"] },
      requestOptions,
      signal
    );

  return {
    queryKey,
    queryFn,
    ...queryOptions,
  } as UseSuspenseInfiniteQueryOptions<
    Awaited<ReturnType<typeof logsTail>>,
    TError,
    TData,
    QueryKey,
    LogsTailParams["limit"]
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type LogsTailSuspenseInfiniteQueryResult = NonNullable<
  Awaited<ReturnType<typeof logsTail>>
>;
export type LogsTailSuspenseInfiniteQueryError = ErrorType<
  | AuthenticationExceptionResponse
  | LogsTail404
  | ValidationExceptionResponse
  | LogsTail500
>;

export function useLogsTailSuspenseInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof logsTail>>,
    LogsTailParams["limit"]
  >,
  TError = ErrorType<
    | AuthenticationExceptionResponse
    | LogsTail404
    | ValidationExceptionResponse
    | LogsTail500
  >
>(
  logFile: string,
  params: undefined | LogsTailParams,
  options: {
    query: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof logsTail>>,
        TError,
        TData,
        QueryKey,
        LogsTailParams["limit"]
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useLogsTailSuspenseInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof logsTail>>,
    LogsTailParams["limit"]
  >,
  TError = ErrorType<
    | AuthenticationExceptionResponse
    | LogsTail404
    | ValidationExceptionResponse
    | LogsTail500
  >
>(
  logFile: string,
  params?: LogsTailParams,
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof logsTail>>,
        TError,
        TData,
        QueryKey,
        LogsTailParams["limit"]
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useLogsTailSuspenseInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof logsTail>>,
    LogsTailParams["limit"]
  >,
  TError = ErrorType<
    | AuthenticationExceptionResponse
    | LogsTail404
    | ValidationExceptionResponse
    | LogsTail500
  >
>(
  logFile: string,
  params?: LogsTailParams,
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof logsTail>>,
        TError,
        TData,
        QueryKey,
        LogsTailParams["limit"]
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get log file tail
 */

export function useLogsTailSuspenseInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof logsTail>>,
    LogsTailParams["limit"]
  >,
  TError = ErrorType<
    | AuthenticationExceptionResponse
    | LogsTail404
    | ValidationExceptionResponse
    | LogsTail500
  >
>(
  logFile: string,
  params?: LogsTailParams,
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof logsTail>>,
        TError,
        TData,
        QueryKey,
        LogsTailParams["limit"]
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getLogsTailSuspenseInfiniteQueryOptions(
    logFile,
    params,
    options
  );

  const query = useSuspenseInfiniteQuery(
    queryOptions,
    queryClient
  ) as UseSuspenseInfiniteQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Get log file head
 */
export const logsHead = (
  logFile: string,
  params?: LogsHeadParams,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal
) => {
  return customInstance<LogsHead200>(
    { url: `/api/logs/${logFile}/head`, method: "GET", params, signal },
    options
  );
};

export const getLogsHeadQueryKey = (
  logFile?: string,
  params?: LogsHeadParams
) => {
  return [`/api/logs/${logFile}/head`, ...(params ? [params] : [])] as const;
};

export const getLogsHeadInfiniteQueryOptions = <
  TData = InfiniteData<
    Awaited<ReturnType<typeof logsHead>>,
    LogsHeadParams["limit"]
  >,
  TError = ErrorType<
    | AuthenticationExceptionResponse
    | LogsHead404
    | ValidationExceptionResponse
    | LogsHead500
  >
>(
  logFile: string,
  params?: LogsHeadParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof logsHead>>,
        TError,
        TData,
        QueryKey,
        LogsHeadParams["limit"]
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getLogsHeadQueryKey(logFile, params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof logsHead>>,
    QueryKey,
    LogsHeadParams["limit"]
  > = ({ signal, pageParam }) =>
    logsHead(
      logFile,
      { ...params, limit: pageParam || params?.["limit"] },
      requestOptions,
      signal
    );

  return {
    queryKey,
    queryFn,
    enabled: !!logFile,
    ...queryOptions,
  } as UseInfiniteQueryOptions<
    Awaited<ReturnType<typeof logsHead>>,
    TError,
    TData,
    QueryKey,
    LogsHeadParams["limit"]
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type LogsHeadInfiniteQueryResult = NonNullable<
  Awaited<ReturnType<typeof logsHead>>
>;
export type LogsHeadInfiniteQueryError = ErrorType<
  | AuthenticationExceptionResponse
  | LogsHead404
  | ValidationExceptionResponse
  | LogsHead500
>;

export function useLogsHeadInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof logsHead>>,
    LogsHeadParams["limit"]
  >,
  TError = ErrorType<
    | AuthenticationExceptionResponse
    | LogsHead404
    | ValidationExceptionResponse
    | LogsHead500
  >
>(
  logFile: string,
  params: undefined | LogsHeadParams,
  options: {
    query: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof logsHead>>,
        TError,
        TData,
        QueryKey,
        LogsHeadParams["limit"]
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof logsHead>>,
          TError,
          Awaited<ReturnType<typeof logsHead>>,
          QueryKey
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): DefinedUseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useLogsHeadInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof logsHead>>,
    LogsHeadParams["limit"]
  >,
  TError = ErrorType<
    | AuthenticationExceptionResponse
    | LogsHead404
    | ValidationExceptionResponse
    | LogsHead500
  >
>(
  logFile: string,
  params?: LogsHeadParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof logsHead>>,
        TError,
        TData,
        QueryKey,
        LogsHeadParams["limit"]
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof logsHead>>,
          TError,
          Awaited<ReturnType<typeof logsHead>>,
          QueryKey
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useLogsHeadInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof logsHead>>,
    LogsHeadParams["limit"]
  >,
  TError = ErrorType<
    | AuthenticationExceptionResponse
    | LogsHead404
    | ValidationExceptionResponse
    | LogsHead500
  >
>(
  logFile: string,
  params?: LogsHeadParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof logsHead>>,
        TError,
        TData,
        QueryKey,
        LogsHeadParams["limit"]
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get log file head
 */

export function useLogsHeadInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof logsHead>>,
    LogsHeadParams["limit"]
  >,
  TError = ErrorType<
    | AuthenticationExceptionResponse
    | LogsHead404
    | ValidationExceptionResponse
    | LogsHead500
  >
>(
  logFile: string,
  params?: LogsHeadParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof logsHead>>,
        TError,
        TData,
        QueryKey,
        LogsHeadParams["limit"]
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getLogsHeadInfiniteQueryOptions(
    logFile,
    params,
    options
  );

  const query = useInfiniteQuery(
    queryOptions,
    queryClient
  ) as UseInfiniteQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getLogsHeadQueryOptions = <
  TData = Awaited<ReturnType<typeof logsHead>>,
  TError = ErrorType<
    | AuthenticationExceptionResponse
    | LogsHead404
    | ValidationExceptionResponse
    | LogsHead500
  >
>(
  logFile: string,
  params?: LogsHeadParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof logsHead>>, TError, TData>
    >;
    request?: SecondParameter<typeof customInstance>;
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getLogsHeadQueryKey(logFile, params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof logsHead>>> = ({
    signal,
  }) => logsHead(logFile, params, requestOptions, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!logFile,
    ...queryOptions,
  } as UseQueryOptions<Awaited<ReturnType<typeof logsHead>>, TError, TData> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };
};

export type LogsHeadQueryResult = NonNullable<
  Awaited<ReturnType<typeof logsHead>>
>;
export type LogsHeadQueryError = ErrorType<
  | AuthenticationExceptionResponse
  | LogsHead404
  | ValidationExceptionResponse
  | LogsHead500
>;

export function useLogsHead<
  TData = Awaited<ReturnType<typeof logsHead>>,
  TError = ErrorType<
    | AuthenticationExceptionResponse
    | LogsHead404
    | ValidationExceptionResponse
    | LogsHead500
  >
>(
  logFile: string,
  params: undefined | LogsHeadParams,
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof logsHead>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof logsHead>>,
          TError,
          Awaited<ReturnType<typeof logsHead>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useLogsHead<
  TData = Awaited<ReturnType<typeof logsHead>>,
  TError = ErrorType<
    | AuthenticationExceptionResponse
    | LogsHead404
    | ValidationExceptionResponse
    | LogsHead500
  >
>(
  logFile: string,
  params?: LogsHeadParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof logsHead>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof logsHead>>,
          TError,
          Awaited<ReturnType<typeof logsHead>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useLogsHead<
  TData = Awaited<ReturnType<typeof logsHead>>,
  TError = ErrorType<
    | AuthenticationExceptionResponse
    | LogsHead404
    | ValidationExceptionResponse
    | LogsHead500
  >
>(
  logFile: string,
  params?: LogsHeadParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof logsHead>>, TError, TData>
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get log file head
 */

export function useLogsHead<
  TData = Awaited<ReturnType<typeof logsHead>>,
  TError = ErrorType<
    | AuthenticationExceptionResponse
    | LogsHead404
    | ValidationExceptionResponse
    | LogsHead500
  >
>(
  logFile: string,
  params?: LogsHeadParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof logsHead>>, TError, TData>
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getLogsHeadQueryOptions(logFile, params, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getLogsHeadSuspenseQueryOptions = <
  TData = Awaited<ReturnType<typeof logsHead>>,
  TError = ErrorType<
    | AuthenticationExceptionResponse
    | LogsHead404
    | ValidationExceptionResponse
    | LogsHead500
  >
>(
  logFile: string,
  params?: LogsHeadParams,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof logsHead>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getLogsHeadQueryKey(logFile, params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof logsHead>>> = ({
    signal,
  }) => logsHead(logFile, params, requestOptions, signal);

  return { queryKey, queryFn, ...queryOptions } as UseSuspenseQueryOptions<
    Awaited<ReturnType<typeof logsHead>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type LogsHeadSuspenseQueryResult = NonNullable<
  Awaited<ReturnType<typeof logsHead>>
>;
export type LogsHeadSuspenseQueryError = ErrorType<
  | AuthenticationExceptionResponse
  | LogsHead404
  | ValidationExceptionResponse
  | LogsHead500
>;

export function useLogsHeadSuspense<
  TData = Awaited<ReturnType<typeof logsHead>>,
  TError = ErrorType<
    | AuthenticationExceptionResponse
    | LogsHead404
    | ValidationExceptionResponse
    | LogsHead500
  >
>(
  logFile: string,
  params: undefined | LogsHeadParams,
  options: {
    query: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof logsHead>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useLogsHeadSuspense<
  TData = Awaited<ReturnType<typeof logsHead>>,
  TError = ErrorType<
    | AuthenticationExceptionResponse
    | LogsHead404
    | ValidationExceptionResponse
    | LogsHead500
  >
>(
  logFile: string,
  params?: LogsHeadParams,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof logsHead>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useLogsHeadSuspense<
  TData = Awaited<ReturnType<typeof logsHead>>,
  TError = ErrorType<
    | AuthenticationExceptionResponse
    | LogsHead404
    | ValidationExceptionResponse
    | LogsHead500
  >
>(
  logFile: string,
  params?: LogsHeadParams,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof logsHead>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get log file head
 */

export function useLogsHeadSuspense<
  TData = Awaited<ReturnType<typeof logsHead>>,
  TError = ErrorType<
    | AuthenticationExceptionResponse
    | LogsHead404
    | ValidationExceptionResponse
    | LogsHead500
  >
>(
  logFile: string,
  params?: LogsHeadParams,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof logsHead>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getLogsHeadSuspenseQueryOptions(
    logFile,
    params,
    options
  );

  const query = useSuspenseQuery(
    queryOptions,
    queryClient
  ) as UseSuspenseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getLogsHeadSuspenseInfiniteQueryOptions = <
  TData = InfiniteData<
    Awaited<ReturnType<typeof logsHead>>,
    LogsHeadParams["limit"]
  >,
  TError = ErrorType<
    | AuthenticationExceptionResponse
    | LogsHead404
    | ValidationExceptionResponse
    | LogsHead500
  >
>(
  logFile: string,
  params?: LogsHeadParams,
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof logsHead>>,
        TError,
        TData,
        QueryKey,
        LogsHeadParams["limit"]
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getLogsHeadQueryKey(logFile, params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof logsHead>>,
    QueryKey,
    LogsHeadParams["limit"]
  > = ({ signal, pageParam }) =>
    logsHead(
      logFile,
      { ...params, limit: pageParam || params?.["limit"] },
      requestOptions,
      signal
    );

  return {
    queryKey,
    queryFn,
    ...queryOptions,
  } as UseSuspenseInfiniteQueryOptions<
    Awaited<ReturnType<typeof logsHead>>,
    TError,
    TData,
    QueryKey,
    LogsHeadParams["limit"]
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type LogsHeadSuspenseInfiniteQueryResult = NonNullable<
  Awaited<ReturnType<typeof logsHead>>
>;
export type LogsHeadSuspenseInfiniteQueryError = ErrorType<
  | AuthenticationExceptionResponse
  | LogsHead404
  | ValidationExceptionResponse
  | LogsHead500
>;

export function useLogsHeadSuspenseInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof logsHead>>,
    LogsHeadParams["limit"]
  >,
  TError = ErrorType<
    | AuthenticationExceptionResponse
    | LogsHead404
    | ValidationExceptionResponse
    | LogsHead500
  >
>(
  logFile: string,
  params: undefined | LogsHeadParams,
  options: {
    query: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof logsHead>>,
        TError,
        TData,
        QueryKey,
        LogsHeadParams["limit"]
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useLogsHeadSuspenseInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof logsHead>>,
    LogsHeadParams["limit"]
  >,
  TError = ErrorType<
    | AuthenticationExceptionResponse
    | LogsHead404
    | ValidationExceptionResponse
    | LogsHead500
  >
>(
  logFile: string,
  params?: LogsHeadParams,
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof logsHead>>,
        TError,
        TData,
        QueryKey,
        LogsHeadParams["limit"]
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useLogsHeadSuspenseInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof logsHead>>,
    LogsHeadParams["limit"]
  >,
  TError = ErrorType<
    | AuthenticationExceptionResponse
    | LogsHead404
    | ValidationExceptionResponse
    | LogsHead500
  >
>(
  logFile: string,
  params?: LogsHeadParams,
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof logsHead>>,
        TError,
        TData,
        QueryKey,
        LogsHeadParams["limit"]
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get log file head
 */

export function useLogsHeadSuspenseInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof logsHead>>,
    LogsHeadParams["limit"]
  >,
  TError = ErrorType<
    | AuthenticationExceptionResponse
    | LogsHead404
    | ValidationExceptionResponse
    | LogsHead500
  >
>(
  logFile: string,
  params?: LogsHeadParams,
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof logsHead>>,
        TError,
        TData,
        QueryKey,
        LogsHeadParams["limit"]
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getLogsHeadSuspenseInfiniteQueryOptions(
    logFile,
    params,
    options
  );

  const query = useSuspenseInfiniteQuery(
    queryOptions,
    queryClient
  ) as UseSuspenseInfiniteQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Get log file statistics
 */
export const logsStats = (
  logFile: string,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal
) => {
  return customInstance<LogsStats200>(
    { url: `/api/logs/${logFile}/stats`, method: "GET", signal },
    options
  );
};

export const getLogsStatsQueryKey = (logFile?: string) => {
  return [`/api/logs/${logFile}/stats`] as const;
};

export const getLogsStatsInfiniteQueryOptions = <
  TData = InfiniteData<Awaited<ReturnType<typeof logsStats>>>,
  TError = ErrorType<
    AuthenticationExceptionResponse | LogsStats404 | LogsStats500
  >
>(
  logFile: string,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof logsStats>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getLogsStatsQueryKey(logFile);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof logsStats>>> = ({
    signal,
  }) => logsStats(logFile, requestOptions, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!logFile,
    ...queryOptions,
  } as UseInfiniteQueryOptions<
    Awaited<ReturnType<typeof logsStats>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type LogsStatsInfiniteQueryResult = NonNullable<
  Awaited<ReturnType<typeof logsStats>>
>;
export type LogsStatsInfiniteQueryError = ErrorType<
  AuthenticationExceptionResponse | LogsStats404 | LogsStats500
>;

export function useLogsStatsInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof logsStats>>>,
  TError = ErrorType<
    AuthenticationExceptionResponse | LogsStats404 | LogsStats500
  >
>(
  logFile: string,
  options: {
    query: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof logsStats>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof logsStats>>,
          TError,
          Awaited<ReturnType<typeof logsStats>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): DefinedUseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useLogsStatsInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof logsStats>>>,
  TError = ErrorType<
    AuthenticationExceptionResponse | LogsStats404 | LogsStats500
  >
>(
  logFile: string,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof logsStats>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof logsStats>>,
          TError,
          Awaited<ReturnType<typeof logsStats>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useLogsStatsInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof logsStats>>>,
  TError = ErrorType<
    AuthenticationExceptionResponse | LogsStats404 | LogsStats500
  >
>(
  logFile: string,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof logsStats>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get log file statistics
 */

export function useLogsStatsInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof logsStats>>>,
  TError = ErrorType<
    AuthenticationExceptionResponse | LogsStats404 | LogsStats500
  >
>(
  logFile: string,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof logsStats>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getLogsStatsInfiniteQueryOptions(logFile, options);

  const query = useInfiniteQuery(
    queryOptions,
    queryClient
  ) as UseInfiniteQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getLogsStatsQueryOptions = <
  TData = Awaited<ReturnType<typeof logsStats>>,
  TError = ErrorType<
    AuthenticationExceptionResponse | LogsStats404 | LogsStats500
  >
>(
  logFile: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof logsStats>>, TError, TData>
    >;
    request?: SecondParameter<typeof customInstance>;
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getLogsStatsQueryKey(logFile);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof logsStats>>> = ({
    signal,
  }) => logsStats(logFile, requestOptions, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!logFile,
    ...queryOptions,
  } as UseQueryOptions<Awaited<ReturnType<typeof logsStats>>, TError, TData> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };
};

export type LogsStatsQueryResult = NonNullable<
  Awaited<ReturnType<typeof logsStats>>
>;
export type LogsStatsQueryError = ErrorType<
  AuthenticationExceptionResponse | LogsStats404 | LogsStats500
>;

export function useLogsStats<
  TData = Awaited<ReturnType<typeof logsStats>>,
  TError = ErrorType<
    AuthenticationExceptionResponse | LogsStats404 | LogsStats500
  >
>(
  logFile: string,
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof logsStats>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof logsStats>>,
          TError,
          Awaited<ReturnType<typeof logsStats>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useLogsStats<
  TData = Awaited<ReturnType<typeof logsStats>>,
  TError = ErrorType<
    AuthenticationExceptionResponse | LogsStats404 | LogsStats500
  >
>(
  logFile: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof logsStats>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof logsStats>>,
          TError,
          Awaited<ReturnType<typeof logsStats>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useLogsStats<
  TData = Awaited<ReturnType<typeof logsStats>>,
  TError = ErrorType<
    AuthenticationExceptionResponse | LogsStats404 | LogsStats500
  >
>(
  logFile: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof logsStats>>, TError, TData>
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get log file statistics
 */

export function useLogsStats<
  TData = Awaited<ReturnType<typeof logsStats>>,
  TError = ErrorType<
    AuthenticationExceptionResponse | LogsStats404 | LogsStats500
  >
>(
  logFile: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof logsStats>>, TError, TData>
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getLogsStatsQueryOptions(logFile, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getLogsStatsSuspenseQueryOptions = <
  TData = Awaited<ReturnType<typeof logsStats>>,
  TError = ErrorType<
    AuthenticationExceptionResponse | LogsStats404 | LogsStats500
  >
>(
  logFile: string,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof logsStats>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getLogsStatsQueryKey(logFile);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof logsStats>>> = ({
    signal,
  }) => logsStats(logFile, requestOptions, signal);

  return { queryKey, queryFn, ...queryOptions } as UseSuspenseQueryOptions<
    Awaited<ReturnType<typeof logsStats>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type LogsStatsSuspenseQueryResult = NonNullable<
  Awaited<ReturnType<typeof logsStats>>
>;
export type LogsStatsSuspenseQueryError = ErrorType<
  AuthenticationExceptionResponse | LogsStats404 | LogsStats500
>;

export function useLogsStatsSuspense<
  TData = Awaited<ReturnType<typeof logsStats>>,
  TError = ErrorType<
    AuthenticationExceptionResponse | LogsStats404 | LogsStats500
  >
>(
  logFile: string,
  options: {
    query: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof logsStats>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useLogsStatsSuspense<
  TData = Awaited<ReturnType<typeof logsStats>>,
  TError = ErrorType<
    AuthenticationExceptionResponse | LogsStats404 | LogsStats500
  >
>(
  logFile: string,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof logsStats>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useLogsStatsSuspense<
  TData = Awaited<ReturnType<typeof logsStats>>,
  TError = ErrorType<
    AuthenticationExceptionResponse | LogsStats404 | LogsStats500
  >
>(
  logFile: string,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof logsStats>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get log file statistics
 */

export function useLogsStatsSuspense<
  TData = Awaited<ReturnType<typeof logsStats>>,
  TError = ErrorType<
    AuthenticationExceptionResponse | LogsStats404 | LogsStats500
  >
>(
  logFile: string,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof logsStats>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getLogsStatsSuspenseQueryOptions(logFile, options);

  const query = useSuspenseQuery(
    queryOptions,
    queryClient
  ) as UseSuspenseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getLogsStatsSuspenseInfiniteQueryOptions = <
  TData = InfiniteData<Awaited<ReturnType<typeof logsStats>>>,
  TError = ErrorType<
    AuthenticationExceptionResponse | LogsStats404 | LogsStats500
  >
>(
  logFile: string,
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof logsStats>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getLogsStatsQueryKey(logFile);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof logsStats>>> = ({
    signal,
  }) => logsStats(logFile, requestOptions, signal);

  return {
    queryKey,
    queryFn,
    ...queryOptions,
  } as UseSuspenseInfiniteQueryOptions<
    Awaited<ReturnType<typeof logsStats>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type LogsStatsSuspenseInfiniteQueryResult = NonNullable<
  Awaited<ReturnType<typeof logsStats>>
>;
export type LogsStatsSuspenseInfiniteQueryError = ErrorType<
  AuthenticationExceptionResponse | LogsStats404 | LogsStats500
>;

export function useLogsStatsSuspenseInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof logsStats>>>,
  TError = ErrorType<
    AuthenticationExceptionResponse | LogsStats404 | LogsStats500
  >
>(
  logFile: string,
  options: {
    query: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof logsStats>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useLogsStatsSuspenseInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof logsStats>>>,
  TError = ErrorType<
    AuthenticationExceptionResponse | LogsStats404 | LogsStats500
  >
>(
  logFile: string,
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof logsStats>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useLogsStatsSuspenseInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof logsStats>>>,
  TError = ErrorType<
    AuthenticationExceptionResponse | LogsStats404 | LogsStats500
  >
>(
  logFile: string,
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof logsStats>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get log file statistics
 */

export function useLogsStatsSuspenseInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof logsStats>>>,
  TError = ErrorType<
    AuthenticationExceptionResponse | LogsStats404 | LogsStats500
  >
>(
  logFile: string,
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof logsStats>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getLogsStatsSuspenseInfiniteQueryOptions(
    logFile,
    options
  );

  const query = useSuspenseInfiniteQuery(
    queryOptions,
    queryClient
  ) as UseSuspenseInfiniteQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Download log file
 */
export const logsDownload = (
  logFile: string,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal
) => {
  return customInstance<string>(
    { url: `/api/logs/${logFile}/download`, method: "GET", signal },
    options
  );
};

export const getLogsDownloadQueryKey = (logFile?: string) => {
  return [`/api/logs/${logFile}/download`] as const;
};

export const getLogsDownloadInfiniteQueryOptions = <
  TData = InfiniteData<Awaited<ReturnType<typeof logsDownload>>>,
  TError = ErrorType<AuthenticationExceptionResponse | LogsDownload404>
>(
  logFile: string,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof logsDownload>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getLogsDownloadQueryKey(logFile);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof logsDownload>>> = ({
    signal,
  }) => logsDownload(logFile, requestOptions, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!logFile,
    ...queryOptions,
  } as UseInfiniteQueryOptions<
    Awaited<ReturnType<typeof logsDownload>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type LogsDownloadInfiniteQueryResult = NonNullable<
  Awaited<ReturnType<typeof logsDownload>>
>;
export type LogsDownloadInfiniteQueryError = ErrorType<
  AuthenticationExceptionResponse | LogsDownload404
>;

export function useLogsDownloadInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof logsDownload>>>,
  TError = ErrorType<AuthenticationExceptionResponse | LogsDownload404>
>(
  logFile: string,
  options: {
    query: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof logsDownload>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof logsDownload>>,
          TError,
          Awaited<ReturnType<typeof logsDownload>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): DefinedUseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useLogsDownloadInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof logsDownload>>>,
  TError = ErrorType<AuthenticationExceptionResponse | LogsDownload404>
>(
  logFile: string,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof logsDownload>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof logsDownload>>,
          TError,
          Awaited<ReturnType<typeof logsDownload>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useLogsDownloadInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof logsDownload>>>,
  TError = ErrorType<AuthenticationExceptionResponse | LogsDownload404>
>(
  logFile: string,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof logsDownload>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Download log file
 */

export function useLogsDownloadInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof logsDownload>>>,
  TError = ErrorType<AuthenticationExceptionResponse | LogsDownload404>
>(
  logFile: string,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof logsDownload>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getLogsDownloadInfiniteQueryOptions(logFile, options);

  const query = useInfiniteQuery(
    queryOptions,
    queryClient
  ) as UseInfiniteQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getLogsDownloadQueryOptions = <
  TData = Awaited<ReturnType<typeof logsDownload>>,
  TError = ErrorType<AuthenticationExceptionResponse | LogsDownload404>
>(
  logFile: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof logsDownload>>, TError, TData>
    >;
    request?: SecondParameter<typeof customInstance>;
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getLogsDownloadQueryKey(logFile);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof logsDownload>>> = ({
    signal,
  }) => logsDownload(logFile, requestOptions, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!logFile,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof logsDownload>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type LogsDownloadQueryResult = NonNullable<
  Awaited<ReturnType<typeof logsDownload>>
>;
export type LogsDownloadQueryError = ErrorType<
  AuthenticationExceptionResponse | LogsDownload404
>;

export function useLogsDownload<
  TData = Awaited<ReturnType<typeof logsDownload>>,
  TError = ErrorType<AuthenticationExceptionResponse | LogsDownload404>
>(
  logFile: string,
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof logsDownload>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof logsDownload>>,
          TError,
          Awaited<ReturnType<typeof logsDownload>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useLogsDownload<
  TData = Awaited<ReturnType<typeof logsDownload>>,
  TError = ErrorType<AuthenticationExceptionResponse | LogsDownload404>
>(
  logFile: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof logsDownload>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof logsDownload>>,
          TError,
          Awaited<ReturnType<typeof logsDownload>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useLogsDownload<
  TData = Awaited<ReturnType<typeof logsDownload>>,
  TError = ErrorType<AuthenticationExceptionResponse | LogsDownload404>
>(
  logFile: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof logsDownload>>, TError, TData>
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Download log file
 */

export function useLogsDownload<
  TData = Awaited<ReturnType<typeof logsDownload>>,
  TError = ErrorType<AuthenticationExceptionResponse | LogsDownload404>
>(
  logFile: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof logsDownload>>, TError, TData>
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getLogsDownloadQueryOptions(logFile, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getLogsDownloadSuspenseQueryOptions = <
  TData = Awaited<ReturnType<typeof logsDownload>>,
  TError = ErrorType<AuthenticationExceptionResponse | LogsDownload404>
>(
  logFile: string,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof logsDownload>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getLogsDownloadQueryKey(logFile);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof logsDownload>>> = ({
    signal,
  }) => logsDownload(logFile, requestOptions, signal);

  return { queryKey, queryFn, ...queryOptions } as UseSuspenseQueryOptions<
    Awaited<ReturnType<typeof logsDownload>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type LogsDownloadSuspenseQueryResult = NonNullable<
  Awaited<ReturnType<typeof logsDownload>>
>;
export type LogsDownloadSuspenseQueryError = ErrorType<
  AuthenticationExceptionResponse | LogsDownload404
>;

export function useLogsDownloadSuspense<
  TData = Awaited<ReturnType<typeof logsDownload>>,
  TError = ErrorType<AuthenticationExceptionResponse | LogsDownload404>
>(
  logFile: string,
  options: {
    query: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof logsDownload>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useLogsDownloadSuspense<
  TData = Awaited<ReturnType<typeof logsDownload>>,
  TError = ErrorType<AuthenticationExceptionResponse | LogsDownload404>
>(
  logFile: string,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof logsDownload>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useLogsDownloadSuspense<
  TData = Awaited<ReturnType<typeof logsDownload>>,
  TError = ErrorType<AuthenticationExceptionResponse | LogsDownload404>
>(
  logFile: string,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof logsDownload>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Download log file
 */

export function useLogsDownloadSuspense<
  TData = Awaited<ReturnType<typeof logsDownload>>,
  TError = ErrorType<AuthenticationExceptionResponse | LogsDownload404>
>(
  logFile: string,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof logsDownload>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getLogsDownloadSuspenseQueryOptions(logFile, options);

  const query = useSuspenseQuery(
    queryOptions,
    queryClient
  ) as UseSuspenseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getLogsDownloadSuspenseInfiniteQueryOptions = <
  TData = InfiniteData<Awaited<ReturnType<typeof logsDownload>>>,
  TError = ErrorType<AuthenticationExceptionResponse | LogsDownload404>
>(
  logFile: string,
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof logsDownload>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getLogsDownloadQueryKey(logFile);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof logsDownload>>> = ({
    signal,
  }) => logsDownload(logFile, requestOptions, signal);

  return {
    queryKey,
    queryFn,
    ...queryOptions,
  } as UseSuspenseInfiniteQueryOptions<
    Awaited<ReturnType<typeof logsDownload>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type LogsDownloadSuspenseInfiniteQueryResult = NonNullable<
  Awaited<ReturnType<typeof logsDownload>>
>;
export type LogsDownloadSuspenseInfiniteQueryError = ErrorType<
  AuthenticationExceptionResponse | LogsDownload404
>;

export function useLogsDownloadSuspenseInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof logsDownload>>>,
  TError = ErrorType<AuthenticationExceptionResponse | LogsDownload404>
>(
  logFile: string,
  options: {
    query: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof logsDownload>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useLogsDownloadSuspenseInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof logsDownload>>>,
  TError = ErrorType<AuthenticationExceptionResponse | LogsDownload404>
>(
  logFile: string,
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof logsDownload>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useLogsDownloadSuspenseInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof logsDownload>>>,
  TError = ErrorType<AuthenticationExceptionResponse | LogsDownload404>
>(
  logFile: string,
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof logsDownload>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Download log file
 */

export function useLogsDownloadSuspenseInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof logsDownload>>>,
  TError = ErrorType<AuthenticationExceptionResponse | LogsDownload404>
>(
  logFile: string,
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof logsDownload>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getLogsDownloadSuspenseInfiniteQueryOptions(
    logFile,
    options
  );

  const query = useSuspenseInfiniteQuery(
    queryOptions,
    queryClient
  ) as UseSuspenseInfiniteQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Search across all log files
 */
export const logsSearchAll = (
  params: LogsSearchAllParams,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal
) => {
  return customInstance<LogsSearchAll200>(
    { url: `/api/logs/search/all`, method: "GET", params, signal },
    options
  );
};

export const getLogsSearchAllQueryKey = (params?: LogsSearchAllParams) => {
  return [`/api/logs/search/all`, ...(params ? [params] : [])] as const;
};

export const getLogsSearchAllInfiniteQueryOptions = <
  TData = InfiniteData<
    Awaited<ReturnType<typeof logsSearchAll>>,
    LogsSearchAllParams["limit"]
  >,
  TError = ErrorType<
    | AuthenticationExceptionResponse
    | ValidationExceptionResponse
    | LogsSearchAll500
  >
>(
  params: LogsSearchAllParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof logsSearchAll>>,
        TError,
        TData,
        QueryKey,
        LogsSearchAllParams["limit"]
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getLogsSearchAllQueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof logsSearchAll>>,
    QueryKey,
    LogsSearchAllParams["limit"]
  > = ({ signal, pageParam }) =>
    logsSearchAll(
      { ...params, limit: pageParam || params?.["limit"] },
      requestOptions,
      signal
    );

  return { queryKey, queryFn, ...queryOptions } as UseInfiniteQueryOptions<
    Awaited<ReturnType<typeof logsSearchAll>>,
    TError,
    TData,
    QueryKey,
    LogsSearchAllParams["limit"]
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type LogsSearchAllInfiniteQueryResult = NonNullable<
  Awaited<ReturnType<typeof logsSearchAll>>
>;
export type LogsSearchAllInfiniteQueryError = ErrorType<
  | AuthenticationExceptionResponse
  | ValidationExceptionResponse
  | LogsSearchAll500
>;

export function useLogsSearchAllInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof logsSearchAll>>,
    LogsSearchAllParams["limit"]
  >,
  TError = ErrorType<
    | AuthenticationExceptionResponse
    | ValidationExceptionResponse
    | LogsSearchAll500
  >
>(
  params: LogsSearchAllParams,
  options: {
    query: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof logsSearchAll>>,
        TError,
        TData,
        QueryKey,
        LogsSearchAllParams["limit"]
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof logsSearchAll>>,
          TError,
          Awaited<ReturnType<typeof logsSearchAll>>,
          QueryKey
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): DefinedUseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useLogsSearchAllInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof logsSearchAll>>,
    LogsSearchAllParams["limit"]
  >,
  TError = ErrorType<
    | AuthenticationExceptionResponse
    | ValidationExceptionResponse
    | LogsSearchAll500
  >
>(
  params: LogsSearchAllParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof logsSearchAll>>,
        TError,
        TData,
        QueryKey,
        LogsSearchAllParams["limit"]
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof logsSearchAll>>,
          TError,
          Awaited<ReturnType<typeof logsSearchAll>>,
          QueryKey
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useLogsSearchAllInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof logsSearchAll>>,
    LogsSearchAllParams["limit"]
  >,
  TError = ErrorType<
    | AuthenticationExceptionResponse
    | ValidationExceptionResponse
    | LogsSearchAll500
  >
>(
  params: LogsSearchAllParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof logsSearchAll>>,
        TError,
        TData,
        QueryKey,
        LogsSearchAllParams["limit"]
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Search across all log files
 */

export function useLogsSearchAllInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof logsSearchAll>>,
    LogsSearchAllParams["limit"]
  >,
  TError = ErrorType<
    | AuthenticationExceptionResponse
    | ValidationExceptionResponse
    | LogsSearchAll500
  >
>(
  params: LogsSearchAllParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof logsSearchAll>>,
        TError,
        TData,
        QueryKey,
        LogsSearchAllParams["limit"]
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getLogsSearchAllInfiniteQueryOptions(params, options);

  const query = useInfiniteQuery(
    queryOptions,
    queryClient
  ) as UseInfiniteQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getLogsSearchAllQueryOptions = <
  TData = Awaited<ReturnType<typeof logsSearchAll>>,
  TError = ErrorType<
    | AuthenticationExceptionResponse
    | ValidationExceptionResponse
    | LogsSearchAll500
  >
>(
  params: LogsSearchAllParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof logsSearchAll>>, TError, TData>
    >;
    request?: SecondParameter<typeof customInstance>;
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getLogsSearchAllQueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof logsSearchAll>>> = ({
    signal,
  }) => logsSearchAll(params, requestOptions, signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof logsSearchAll>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type LogsSearchAllQueryResult = NonNullable<
  Awaited<ReturnType<typeof logsSearchAll>>
>;
export type LogsSearchAllQueryError = ErrorType<
  | AuthenticationExceptionResponse
  | ValidationExceptionResponse
  | LogsSearchAll500
>;

export function useLogsSearchAll<
  TData = Awaited<ReturnType<typeof logsSearchAll>>,
  TError = ErrorType<
    | AuthenticationExceptionResponse
    | ValidationExceptionResponse
    | LogsSearchAll500
  >
>(
  params: LogsSearchAllParams,
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof logsSearchAll>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof logsSearchAll>>,
          TError,
          Awaited<ReturnType<typeof logsSearchAll>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useLogsSearchAll<
  TData = Awaited<ReturnType<typeof logsSearchAll>>,
  TError = ErrorType<
    | AuthenticationExceptionResponse
    | ValidationExceptionResponse
    | LogsSearchAll500
  >
>(
  params: LogsSearchAllParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof logsSearchAll>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof logsSearchAll>>,
          TError,
          Awaited<ReturnType<typeof logsSearchAll>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useLogsSearchAll<
  TData = Awaited<ReturnType<typeof logsSearchAll>>,
  TError = ErrorType<
    | AuthenticationExceptionResponse
    | ValidationExceptionResponse
    | LogsSearchAll500
  >
>(
  params: LogsSearchAllParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof logsSearchAll>>, TError, TData>
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Search across all log files
 */

export function useLogsSearchAll<
  TData = Awaited<ReturnType<typeof logsSearchAll>>,
  TError = ErrorType<
    | AuthenticationExceptionResponse
    | ValidationExceptionResponse
    | LogsSearchAll500
  >
>(
  params: LogsSearchAllParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof logsSearchAll>>, TError, TData>
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getLogsSearchAllQueryOptions(params, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getLogsSearchAllSuspenseQueryOptions = <
  TData = Awaited<ReturnType<typeof logsSearchAll>>,
  TError = ErrorType<
    | AuthenticationExceptionResponse
    | ValidationExceptionResponse
    | LogsSearchAll500
  >
>(
  params: LogsSearchAllParams,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof logsSearchAll>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getLogsSearchAllQueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof logsSearchAll>>> = ({
    signal,
  }) => logsSearchAll(params, requestOptions, signal);

  return { queryKey, queryFn, ...queryOptions } as UseSuspenseQueryOptions<
    Awaited<ReturnType<typeof logsSearchAll>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type LogsSearchAllSuspenseQueryResult = NonNullable<
  Awaited<ReturnType<typeof logsSearchAll>>
>;
export type LogsSearchAllSuspenseQueryError = ErrorType<
  | AuthenticationExceptionResponse
  | ValidationExceptionResponse
  | LogsSearchAll500
>;

export function useLogsSearchAllSuspense<
  TData = Awaited<ReturnType<typeof logsSearchAll>>,
  TError = ErrorType<
    | AuthenticationExceptionResponse
    | ValidationExceptionResponse
    | LogsSearchAll500
  >
>(
  params: LogsSearchAllParams,
  options: {
    query: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof logsSearchAll>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useLogsSearchAllSuspense<
  TData = Awaited<ReturnType<typeof logsSearchAll>>,
  TError = ErrorType<
    | AuthenticationExceptionResponse
    | ValidationExceptionResponse
    | LogsSearchAll500
  >
>(
  params: LogsSearchAllParams,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof logsSearchAll>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useLogsSearchAllSuspense<
  TData = Awaited<ReturnType<typeof logsSearchAll>>,
  TError = ErrorType<
    | AuthenticationExceptionResponse
    | ValidationExceptionResponse
    | LogsSearchAll500
  >
>(
  params: LogsSearchAllParams,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof logsSearchAll>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Search across all log files
 */

export function useLogsSearchAllSuspense<
  TData = Awaited<ReturnType<typeof logsSearchAll>>,
  TError = ErrorType<
    | AuthenticationExceptionResponse
    | ValidationExceptionResponse
    | LogsSearchAll500
  >
>(
  params: LogsSearchAllParams,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof logsSearchAll>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getLogsSearchAllSuspenseQueryOptions(params, options);

  const query = useSuspenseQuery(
    queryOptions,
    queryClient
  ) as UseSuspenseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getLogsSearchAllSuspenseInfiniteQueryOptions = <
  TData = InfiniteData<
    Awaited<ReturnType<typeof logsSearchAll>>,
    LogsSearchAllParams["limit"]
  >,
  TError = ErrorType<
    | AuthenticationExceptionResponse
    | ValidationExceptionResponse
    | LogsSearchAll500
  >
>(
  params: LogsSearchAllParams,
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof logsSearchAll>>,
        TError,
        TData,
        QueryKey,
        LogsSearchAllParams["limit"]
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getLogsSearchAllQueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof logsSearchAll>>,
    QueryKey,
    LogsSearchAllParams["limit"]
  > = ({ signal, pageParam }) =>
    logsSearchAll(
      { ...params, limit: pageParam || params?.["limit"] },
      requestOptions,
      signal
    );

  return {
    queryKey,
    queryFn,
    ...queryOptions,
  } as UseSuspenseInfiniteQueryOptions<
    Awaited<ReturnType<typeof logsSearchAll>>,
    TError,
    TData,
    QueryKey,
    LogsSearchAllParams["limit"]
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type LogsSearchAllSuspenseInfiniteQueryResult = NonNullable<
  Awaited<ReturnType<typeof logsSearchAll>>
>;
export type LogsSearchAllSuspenseInfiniteQueryError = ErrorType<
  | AuthenticationExceptionResponse
  | ValidationExceptionResponse
  | LogsSearchAll500
>;

export function useLogsSearchAllSuspenseInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof logsSearchAll>>,
    LogsSearchAllParams["limit"]
  >,
  TError = ErrorType<
    | AuthenticationExceptionResponse
    | ValidationExceptionResponse
    | LogsSearchAll500
  >
>(
  params: LogsSearchAllParams,
  options: {
    query: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof logsSearchAll>>,
        TError,
        TData,
        QueryKey,
        LogsSearchAllParams["limit"]
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useLogsSearchAllSuspenseInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof logsSearchAll>>,
    LogsSearchAllParams["limit"]
  >,
  TError = ErrorType<
    | AuthenticationExceptionResponse
    | ValidationExceptionResponse
    | LogsSearchAll500
  >
>(
  params: LogsSearchAllParams,
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof logsSearchAll>>,
        TError,
        TData,
        QueryKey,
        LogsSearchAllParams["limit"]
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useLogsSearchAllSuspenseInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof logsSearchAll>>,
    LogsSearchAllParams["limit"]
  >,
  TError = ErrorType<
    | AuthenticationExceptionResponse
    | ValidationExceptionResponse
    | LogsSearchAll500
  >
>(
  params: LogsSearchAllParams,
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof logsSearchAll>>,
        TError,
        TData,
        QueryKey,
        LogsSearchAllParams["limit"]
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Search across all log files
 */

export function useLogsSearchAllSuspenseInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof logsSearchAll>>,
    LogsSearchAllParams["limit"]
  >,
  TError = ErrorType<
    | AuthenticationExceptionResponse
    | ValidationExceptionResponse
    | LogsSearchAll500
  >
>(
  params: LogsSearchAllParams,
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof logsSearchAll>>,
        TError,
        TData,
        QueryKey,
        LogsSearchAllParams["limit"]
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getLogsSearchAllSuspenseInfiniteQueryOptions(
    params,
    options
  );

  const query = useSuspenseInfiniteQuery(
    queryOptions,
    queryClient
  ) as UseSuspenseInfiniteQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}
