/**
 * Generated by orval v7.11.2 üç∫
 * Do not edit manually.
 * B√•nder api docs
 * B√•nder.App is a sophisticated media server developed with the primary goal to deliver high performance and seamless experience for users.
Being built on top of Laravel framework and PostgreSQL for database, it leverages the power of robust backend technologies, providing high security, reliability, and scalability.

The main focus of B√•nder.App is efficient media management and delivery.
This application is designed to handle large amounts of media files while ensuring quick and efficient access.
Implemented queuing functionality through Redis offers efficient job management and load handling.
The media information is organized and easily searchable, ensuring users can always find what they are looking for quickly and easily.
 * OpenAPI spec version: 0.0.1
 */
import {
  useInfiniteQuery,
  useQuery,
  useSuspenseInfiniteQuery,
  useSuspenseQuery,
} from "@tanstack/react-query";
import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseInfiniteQueryResult,
  DefinedUseQueryResult,
  InfiniteData,
  QueryClient,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseInfiniteQueryOptions,
  UseInfiniteQueryResult,
  UseQueryOptions,
  UseQueryResult,
  UseSuspenseInfiniteQueryOptions,
  UseSuspenseInfiniteQueryResult,
  UseSuspenseQueryOptions,
  UseSuspenseQueryResult,
} from "@tanstack/react-query";

import type {
  AuthenticationExceptionResponse,
  LogFile,
  LogsContent200,
  LogsContentParams,
  LogsDownload200,
  LogsHead200,
  LogsHeadParams,
  LogsLines200,
  LogsSearch200,
  LogsSearchAll200,
  LogsSearchAllParams,
  LogsSearchParams,
  LogsShow200,
  LogsStats200,
  LogsTail200,
  LogsTailParams,
  ModelNotFoundExceptionResponse,
  ValidationExceptionResponse,
} from "../../models";

import { customInstance } from "../../../axios-instance";
import type { ErrorType } from "../../../axios-instance";

type SecondParameter<T extends (...args: never) => unknown> = Parameters<T>[1];

/**
 * Returns a sorted list of all available log files in the system
with metadata including file sizes, modification dates, and identifiers.
 * @summary Get a collection of available log files
 */
export const logsIndex = (
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal
) => {
  return customInstance<LogFile[]>(
    { url: `/api/logs`, method: "GET", signal },
    options
  );
};

export const getLogsIndexQueryKey = () => {
  return [`/api/logs`] as const;
};

export const getLogsIndexInfiniteQueryOptions = <
  TData = InfiniteData<Awaited<ReturnType<typeof logsIndex>>>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(options?: {
  query?: Partial<
    UseInfiniteQueryOptions<
      Awaited<ReturnType<typeof logsIndex>>,
      TError,
      TData
    >
  >;
  request?: SecondParameter<typeof customInstance>;
}) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getLogsIndexQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof logsIndex>>> = ({
    signal,
  }) => logsIndex(requestOptions, signal);

  return { queryKey, queryFn, ...queryOptions } as UseInfiniteQueryOptions<
    Awaited<ReturnType<typeof logsIndex>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type LogsIndexInfiniteQueryResult = NonNullable<
  Awaited<ReturnType<typeof logsIndex>>
>;
export type LogsIndexInfiniteQueryError =
  ErrorType<AuthenticationExceptionResponse>;

export function useLogsIndexInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof logsIndex>>>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(
  options: {
    query: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof logsIndex>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof logsIndex>>,
          TError,
          Awaited<ReturnType<typeof logsIndex>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): DefinedUseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useLogsIndexInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof logsIndex>>>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof logsIndex>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof logsIndex>>,
          TError,
          Awaited<ReturnType<typeof logsIndex>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useLogsIndexInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof logsIndex>>>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof logsIndex>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get a collection of available log files
 */

export function useLogsIndexInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof logsIndex>>>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof logsIndex>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getLogsIndexInfiniteQueryOptions(options);

  const query = useInfiniteQuery(
    queryOptions,
    queryClient
  ) as UseInfiniteQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getLogsIndexQueryOptions = <
  TData = Awaited<ReturnType<typeof logsIndex>>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof logsIndex>>, TError, TData>
  >;
  request?: SecondParameter<typeof customInstance>;
}) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getLogsIndexQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof logsIndex>>> = ({
    signal,
  }) => logsIndex(requestOptions, signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof logsIndex>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type LogsIndexQueryResult = NonNullable<
  Awaited<ReturnType<typeof logsIndex>>
>;
export type LogsIndexQueryError = ErrorType<AuthenticationExceptionResponse>;

export function useLogsIndex<
  TData = Awaited<ReturnType<typeof logsIndex>>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof logsIndex>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof logsIndex>>,
          TError,
          Awaited<ReturnType<typeof logsIndex>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useLogsIndex<
  TData = Awaited<ReturnType<typeof logsIndex>>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof logsIndex>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof logsIndex>>,
          TError,
          Awaited<ReturnType<typeof logsIndex>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useLogsIndex<
  TData = Awaited<ReturnType<typeof logsIndex>>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof logsIndex>>, TError, TData>
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get a collection of available log files
 */

export function useLogsIndex<
  TData = Awaited<ReturnType<typeof logsIndex>>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof logsIndex>>, TError, TData>
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getLogsIndexQueryOptions(options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getLogsIndexSuspenseQueryOptions = <
  TData = Awaited<ReturnType<typeof logsIndex>>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(options?: {
  query?: Partial<
    UseSuspenseQueryOptions<
      Awaited<ReturnType<typeof logsIndex>>,
      TError,
      TData
    >
  >;
  request?: SecondParameter<typeof customInstance>;
}) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getLogsIndexQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof logsIndex>>> = ({
    signal,
  }) => logsIndex(requestOptions, signal);

  return { queryKey, queryFn, ...queryOptions } as UseSuspenseQueryOptions<
    Awaited<ReturnType<typeof logsIndex>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type LogsIndexSuspenseQueryResult = NonNullable<
  Awaited<ReturnType<typeof logsIndex>>
>;
export type LogsIndexSuspenseQueryError =
  ErrorType<AuthenticationExceptionResponse>;

export function useLogsIndexSuspense<
  TData = Awaited<ReturnType<typeof logsIndex>>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(
  options: {
    query: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof logsIndex>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useLogsIndexSuspense<
  TData = Awaited<ReturnType<typeof logsIndex>>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof logsIndex>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useLogsIndexSuspense<
  TData = Awaited<ReturnType<typeof logsIndex>>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof logsIndex>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get a collection of available log files
 */

export function useLogsIndexSuspense<
  TData = Awaited<ReturnType<typeof logsIndex>>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof logsIndex>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getLogsIndexSuspenseQueryOptions(options);

  const query = useSuspenseQuery(
    queryOptions,
    queryClient
  ) as UseSuspenseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getLogsIndexSuspenseInfiniteQueryOptions = <
  TData = InfiniteData<Awaited<ReturnType<typeof logsIndex>>>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(options?: {
  query?: Partial<
    UseSuspenseInfiniteQueryOptions<
      Awaited<ReturnType<typeof logsIndex>>,
      TError,
      TData
    >
  >;
  request?: SecondParameter<typeof customInstance>;
}) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getLogsIndexQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof logsIndex>>> = ({
    signal,
  }) => logsIndex(requestOptions, signal);

  return {
    queryKey,
    queryFn,
    ...queryOptions,
  } as UseSuspenseInfiniteQueryOptions<
    Awaited<ReturnType<typeof logsIndex>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type LogsIndexSuspenseInfiniteQueryResult = NonNullable<
  Awaited<ReturnType<typeof logsIndex>>
>;
export type LogsIndexSuspenseInfiniteQueryError =
  ErrorType<AuthenticationExceptionResponse>;

export function useLogsIndexSuspenseInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof logsIndex>>>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(
  options: {
    query: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof logsIndex>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useLogsIndexSuspenseInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof logsIndex>>>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof logsIndex>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useLogsIndexSuspenseInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof logsIndex>>>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof logsIndex>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get a collection of available log files
 */

export function useLogsIndexSuspenseInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof logsIndex>>>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof logsIndex>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getLogsIndexSuspenseInfiniteQueryOptions(options);

  const query = useSuspenseInfiniteQuery(
    queryOptions,
    queryClient
  ) as UseSuspenseInfiniteQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Returns comprehensive metadata about a log file including file statistics,
line counts, size information, and performance characteristics.
 * @summary Get detailed information about a specific log file
 */
export const logsShow = (
  logFile: string,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal
) => {
  return customInstance<LogsShow200>(
    { url: `/api/logs/${logFile}`, method: "GET", signal },
    options
  );
};

export const getLogsShowQueryKey = (logFile?: string) => {
  return [`/api/logs/${logFile}`] as const;
};

export const getLogsShowInfiniteQueryOptions = <
  TData = InfiniteData<Awaited<ReturnType<typeof logsShow>>>,
  TError = ErrorType<
    AuthenticationExceptionResponse | ModelNotFoundExceptionResponse
  >
>(
  logFile: string,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof logsShow>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getLogsShowQueryKey(logFile);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof logsShow>>> = ({
    signal,
  }) => logsShow(logFile, requestOptions, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!logFile,
    ...queryOptions,
  } as UseInfiniteQueryOptions<
    Awaited<ReturnType<typeof logsShow>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type LogsShowInfiniteQueryResult = NonNullable<
  Awaited<ReturnType<typeof logsShow>>
>;
export type LogsShowInfiniteQueryError = ErrorType<
  AuthenticationExceptionResponse | ModelNotFoundExceptionResponse
>;

export function useLogsShowInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof logsShow>>>,
  TError = ErrorType<
    AuthenticationExceptionResponse | ModelNotFoundExceptionResponse
  >
>(
  logFile: string,
  options: {
    query: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof logsShow>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof logsShow>>,
          TError,
          Awaited<ReturnType<typeof logsShow>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): DefinedUseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useLogsShowInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof logsShow>>>,
  TError = ErrorType<
    AuthenticationExceptionResponse | ModelNotFoundExceptionResponse
  >
>(
  logFile: string,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof logsShow>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof logsShow>>,
          TError,
          Awaited<ReturnType<typeof logsShow>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useLogsShowInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof logsShow>>>,
  TError = ErrorType<
    AuthenticationExceptionResponse | ModelNotFoundExceptionResponse
  >
>(
  logFile: string,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof logsShow>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get detailed information about a specific log file
 */

export function useLogsShowInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof logsShow>>>,
  TError = ErrorType<
    AuthenticationExceptionResponse | ModelNotFoundExceptionResponse
  >
>(
  logFile: string,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof logsShow>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getLogsShowInfiniteQueryOptions(logFile, options);

  const query = useInfiniteQuery(
    queryOptions,
    queryClient
  ) as UseInfiniteQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getLogsShowQueryOptions = <
  TData = Awaited<ReturnType<typeof logsShow>>,
  TError = ErrorType<
    AuthenticationExceptionResponse | ModelNotFoundExceptionResponse
  >
>(
  logFile: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof logsShow>>, TError, TData>
    >;
    request?: SecondParameter<typeof customInstance>;
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getLogsShowQueryKey(logFile);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof logsShow>>> = ({
    signal,
  }) => logsShow(logFile, requestOptions, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!logFile,
    ...queryOptions,
  } as UseQueryOptions<Awaited<ReturnType<typeof logsShow>>, TError, TData> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };
};

export type LogsShowQueryResult = NonNullable<
  Awaited<ReturnType<typeof logsShow>>
>;
export type LogsShowQueryError = ErrorType<
  AuthenticationExceptionResponse | ModelNotFoundExceptionResponse
>;

export function useLogsShow<
  TData = Awaited<ReturnType<typeof logsShow>>,
  TError = ErrorType<
    AuthenticationExceptionResponse | ModelNotFoundExceptionResponse
  >
>(
  logFile: string,
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof logsShow>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof logsShow>>,
          TError,
          Awaited<ReturnType<typeof logsShow>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useLogsShow<
  TData = Awaited<ReturnType<typeof logsShow>>,
  TError = ErrorType<
    AuthenticationExceptionResponse | ModelNotFoundExceptionResponse
  >
>(
  logFile: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof logsShow>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof logsShow>>,
          TError,
          Awaited<ReturnType<typeof logsShow>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useLogsShow<
  TData = Awaited<ReturnType<typeof logsShow>>,
  TError = ErrorType<
    AuthenticationExceptionResponse | ModelNotFoundExceptionResponse
  >
>(
  logFile: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof logsShow>>, TError, TData>
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get detailed information about a specific log file
 */

export function useLogsShow<
  TData = Awaited<ReturnType<typeof logsShow>>,
  TError = ErrorType<
    AuthenticationExceptionResponse | ModelNotFoundExceptionResponse
  >
>(
  logFile: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof logsShow>>, TError, TData>
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getLogsShowQueryOptions(logFile, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getLogsShowSuspenseQueryOptions = <
  TData = Awaited<ReturnType<typeof logsShow>>,
  TError = ErrorType<
    AuthenticationExceptionResponse | ModelNotFoundExceptionResponse
  >
>(
  logFile: string,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof logsShow>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getLogsShowQueryKey(logFile);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof logsShow>>> = ({
    signal,
  }) => logsShow(logFile, requestOptions, signal);

  return { queryKey, queryFn, ...queryOptions } as UseSuspenseQueryOptions<
    Awaited<ReturnType<typeof logsShow>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type LogsShowSuspenseQueryResult = NonNullable<
  Awaited<ReturnType<typeof logsShow>>
>;
export type LogsShowSuspenseQueryError = ErrorType<
  AuthenticationExceptionResponse | ModelNotFoundExceptionResponse
>;

export function useLogsShowSuspense<
  TData = Awaited<ReturnType<typeof logsShow>>,
  TError = ErrorType<
    AuthenticationExceptionResponse | ModelNotFoundExceptionResponse
  >
>(
  logFile: string,
  options: {
    query: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof logsShow>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useLogsShowSuspense<
  TData = Awaited<ReturnType<typeof logsShow>>,
  TError = ErrorType<
    AuthenticationExceptionResponse | ModelNotFoundExceptionResponse
  >
>(
  logFile: string,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof logsShow>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useLogsShowSuspense<
  TData = Awaited<ReturnType<typeof logsShow>>,
  TError = ErrorType<
    AuthenticationExceptionResponse | ModelNotFoundExceptionResponse
  >
>(
  logFile: string,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof logsShow>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get detailed information about a specific log file
 */

export function useLogsShowSuspense<
  TData = Awaited<ReturnType<typeof logsShow>>,
  TError = ErrorType<
    AuthenticationExceptionResponse | ModelNotFoundExceptionResponse
  >
>(
  logFile: string,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof logsShow>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getLogsShowSuspenseQueryOptions(logFile, options);

  const query = useSuspenseQuery(
    queryOptions,
    queryClient
  ) as UseSuspenseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getLogsShowSuspenseInfiniteQueryOptions = <
  TData = InfiniteData<Awaited<ReturnType<typeof logsShow>>>,
  TError = ErrorType<
    AuthenticationExceptionResponse | ModelNotFoundExceptionResponse
  >
>(
  logFile: string,
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof logsShow>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getLogsShowQueryKey(logFile);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof logsShow>>> = ({
    signal,
  }) => logsShow(logFile, requestOptions, signal);

  return {
    queryKey,
    queryFn,
    ...queryOptions,
  } as UseSuspenseInfiniteQueryOptions<
    Awaited<ReturnType<typeof logsShow>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type LogsShowSuspenseInfiniteQueryResult = NonNullable<
  Awaited<ReturnType<typeof logsShow>>
>;
export type LogsShowSuspenseInfiniteQueryError = ErrorType<
  AuthenticationExceptionResponse | ModelNotFoundExceptionResponse
>;

export function useLogsShowSuspenseInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof logsShow>>>,
  TError = ErrorType<
    AuthenticationExceptionResponse | ModelNotFoundExceptionResponse
  >
>(
  logFile: string,
  options: {
    query: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof logsShow>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useLogsShowSuspenseInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof logsShow>>>,
  TError = ErrorType<
    AuthenticationExceptionResponse | ModelNotFoundExceptionResponse
  >
>(
  logFile: string,
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof logsShow>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useLogsShowSuspenseInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof logsShow>>>,
  TError = ErrorType<
    AuthenticationExceptionResponse | ModelNotFoundExceptionResponse
  >
>(
  logFile: string,
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof logsShow>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get detailed information about a specific log file
 */

export function useLogsShowSuspenseInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof logsShow>>>,
  TError = ErrorType<
    AuthenticationExceptionResponse | ModelNotFoundExceptionResponse
  >
>(
  logFile: string,
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof logsShow>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getLogsShowSuspenseInfiniteQueryOptions(
    logFile,
    options
  );

  const query = useSuspenseInfiniteQuery(
    queryOptions,
    queryClient
  ) as UseSuspenseInfiniteQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Retrieves log file content starting from a specific line number
with configurable line limits for efficient pagination through large files.
 * @summary Get paginated content from a log file
 */
export const logsContent = (
  logFile: string,
  params?: LogsContentParams,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal
) => {
  return customInstance<LogsContent200>(
    { url: `/api/logs/${logFile}/content`, method: "GET", params, signal },
    options
  );
};

export const getLogsContentQueryKey = (
  logFile?: string,
  params?: LogsContentParams
) => {
  return [`/api/logs/${logFile}/content`, ...(params ? [params] : [])] as const;
};

export const getLogsContentInfiniteQueryOptions = <
  TData = InfiniteData<
    Awaited<ReturnType<typeof logsContent>>,
    LogsContentParams["page"]
  >,
  TError = ErrorType<
    AuthenticationExceptionResponse | ValidationExceptionResponse
  >
>(
  logFile: string,
  params?: LogsContentParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof logsContent>>,
        TError,
        TData,
        QueryKey,
        LogsContentParams["page"]
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getLogsContentQueryKey(logFile, params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof logsContent>>,
    QueryKey,
    LogsContentParams["page"]
  > = ({ signal, pageParam }) =>
    logsContent(
      logFile,
      { ...params, page: pageParam || params?.["page"] },
      requestOptions,
      signal
    );

  return {
    queryKey,
    queryFn,
    enabled: !!logFile,
    ...queryOptions,
  } as UseInfiniteQueryOptions<
    Awaited<ReturnType<typeof logsContent>>,
    TError,
    TData,
    QueryKey,
    LogsContentParams["page"]
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type LogsContentInfiniteQueryResult = NonNullable<
  Awaited<ReturnType<typeof logsContent>>
>;
export type LogsContentInfiniteQueryError = ErrorType<
  AuthenticationExceptionResponse | ValidationExceptionResponse
>;

export function useLogsContentInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof logsContent>>,
    LogsContentParams["page"]
  >,
  TError = ErrorType<
    AuthenticationExceptionResponse | ValidationExceptionResponse
  >
>(
  logFile: string,
  params: undefined | LogsContentParams,
  options: {
    query: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof logsContent>>,
        TError,
        TData,
        QueryKey,
        LogsContentParams["page"]
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof logsContent>>,
          TError,
          Awaited<ReturnType<typeof logsContent>>,
          QueryKey
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): DefinedUseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useLogsContentInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof logsContent>>,
    LogsContentParams["page"]
  >,
  TError = ErrorType<
    AuthenticationExceptionResponse | ValidationExceptionResponse
  >
>(
  logFile: string,
  params?: LogsContentParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof logsContent>>,
        TError,
        TData,
        QueryKey,
        LogsContentParams["page"]
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof logsContent>>,
          TError,
          Awaited<ReturnType<typeof logsContent>>,
          QueryKey
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useLogsContentInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof logsContent>>,
    LogsContentParams["page"]
  >,
  TError = ErrorType<
    AuthenticationExceptionResponse | ValidationExceptionResponse
  >
>(
  logFile: string,
  params?: LogsContentParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof logsContent>>,
        TError,
        TData,
        QueryKey,
        LogsContentParams["page"]
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get paginated content from a log file
 */

export function useLogsContentInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof logsContent>>,
    LogsContentParams["page"]
  >,
  TError = ErrorType<
    AuthenticationExceptionResponse | ValidationExceptionResponse
  >
>(
  logFile: string,
  params?: LogsContentParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof logsContent>>,
        TError,
        TData,
        QueryKey,
        LogsContentParams["page"]
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getLogsContentInfiniteQueryOptions(
    logFile,
    params,
    options
  );

  const query = useInfiniteQuery(
    queryOptions,
    queryClient
  ) as UseInfiniteQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getLogsContentQueryOptions = <
  TData = Awaited<ReturnType<typeof logsContent>>,
  TError = ErrorType<
    AuthenticationExceptionResponse | ValidationExceptionResponse
  >
>(
  logFile: string,
  params?: LogsContentParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof logsContent>>, TError, TData>
    >;
    request?: SecondParameter<typeof customInstance>;
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getLogsContentQueryKey(logFile, params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof logsContent>>> = ({
    signal,
  }) => logsContent(logFile, params, requestOptions, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!logFile,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof logsContent>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type LogsContentQueryResult = NonNullable<
  Awaited<ReturnType<typeof logsContent>>
>;
export type LogsContentQueryError = ErrorType<
  AuthenticationExceptionResponse | ValidationExceptionResponse
>;

export function useLogsContent<
  TData = Awaited<ReturnType<typeof logsContent>>,
  TError = ErrorType<
    AuthenticationExceptionResponse | ValidationExceptionResponse
  >
>(
  logFile: string,
  params: undefined | LogsContentParams,
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof logsContent>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof logsContent>>,
          TError,
          Awaited<ReturnType<typeof logsContent>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useLogsContent<
  TData = Awaited<ReturnType<typeof logsContent>>,
  TError = ErrorType<
    AuthenticationExceptionResponse | ValidationExceptionResponse
  >
>(
  logFile: string,
  params?: LogsContentParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof logsContent>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof logsContent>>,
          TError,
          Awaited<ReturnType<typeof logsContent>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useLogsContent<
  TData = Awaited<ReturnType<typeof logsContent>>,
  TError = ErrorType<
    AuthenticationExceptionResponse | ValidationExceptionResponse
  >
>(
  logFile: string,
  params?: LogsContentParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof logsContent>>, TError, TData>
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get paginated content from a log file
 */

export function useLogsContent<
  TData = Awaited<ReturnType<typeof logsContent>>,
  TError = ErrorType<
    AuthenticationExceptionResponse | ValidationExceptionResponse
  >
>(
  logFile: string,
  params?: LogsContentParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof logsContent>>, TError, TData>
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getLogsContentQueryOptions(logFile, params, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getLogsContentSuspenseQueryOptions = <
  TData = Awaited<ReturnType<typeof logsContent>>,
  TError = ErrorType<
    AuthenticationExceptionResponse | ValidationExceptionResponse
  >
>(
  logFile: string,
  params?: LogsContentParams,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof logsContent>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getLogsContentQueryKey(logFile, params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof logsContent>>> = ({
    signal,
  }) => logsContent(logFile, params, requestOptions, signal);

  return { queryKey, queryFn, ...queryOptions } as UseSuspenseQueryOptions<
    Awaited<ReturnType<typeof logsContent>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type LogsContentSuspenseQueryResult = NonNullable<
  Awaited<ReturnType<typeof logsContent>>
>;
export type LogsContentSuspenseQueryError = ErrorType<
  AuthenticationExceptionResponse | ValidationExceptionResponse
>;

export function useLogsContentSuspense<
  TData = Awaited<ReturnType<typeof logsContent>>,
  TError = ErrorType<
    AuthenticationExceptionResponse | ValidationExceptionResponse
  >
>(
  logFile: string,
  params: undefined | LogsContentParams,
  options: {
    query: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof logsContent>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useLogsContentSuspense<
  TData = Awaited<ReturnType<typeof logsContent>>,
  TError = ErrorType<
    AuthenticationExceptionResponse | ValidationExceptionResponse
  >
>(
  logFile: string,
  params?: LogsContentParams,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof logsContent>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useLogsContentSuspense<
  TData = Awaited<ReturnType<typeof logsContent>>,
  TError = ErrorType<
    AuthenticationExceptionResponse | ValidationExceptionResponse
  >
>(
  logFile: string,
  params?: LogsContentParams,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof logsContent>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get paginated content from a log file
 */

export function useLogsContentSuspense<
  TData = Awaited<ReturnType<typeof logsContent>>,
  TError = ErrorType<
    AuthenticationExceptionResponse | ValidationExceptionResponse
  >
>(
  logFile: string,
  params?: LogsContentParams,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof logsContent>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getLogsContentSuspenseQueryOptions(
    logFile,
    params,
    options
  );

  const query = useSuspenseQuery(
    queryOptions,
    queryClient
  ) as UseSuspenseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getLogsContentSuspenseInfiniteQueryOptions = <
  TData = InfiniteData<
    Awaited<ReturnType<typeof logsContent>>,
    LogsContentParams["page"]
  >,
  TError = ErrorType<
    AuthenticationExceptionResponse | ValidationExceptionResponse
  >
>(
  logFile: string,
  params?: LogsContentParams,
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof logsContent>>,
        TError,
        TData,
        QueryKey,
        LogsContentParams["page"]
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getLogsContentQueryKey(logFile, params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof logsContent>>,
    QueryKey,
    LogsContentParams["page"]
  > = ({ signal, pageParam }) =>
    logsContent(
      logFile,
      { ...params, page: pageParam || params?.["page"] },
      requestOptions,
      signal
    );

  return {
    queryKey,
    queryFn,
    ...queryOptions,
  } as UseSuspenseInfiniteQueryOptions<
    Awaited<ReturnType<typeof logsContent>>,
    TError,
    TData,
    QueryKey,
    LogsContentParams["page"]
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type LogsContentSuspenseInfiniteQueryResult = NonNullable<
  Awaited<ReturnType<typeof logsContent>>
>;
export type LogsContentSuspenseInfiniteQueryError = ErrorType<
  AuthenticationExceptionResponse | ValidationExceptionResponse
>;

export function useLogsContentSuspenseInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof logsContent>>,
    LogsContentParams["page"]
  >,
  TError = ErrorType<
    AuthenticationExceptionResponse | ValidationExceptionResponse
  >
>(
  logFile: string,
  params: undefined | LogsContentParams,
  options: {
    query: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof logsContent>>,
        TError,
        TData,
        QueryKey,
        LogsContentParams["page"]
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useLogsContentSuspenseInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof logsContent>>,
    LogsContentParams["page"]
  >,
  TError = ErrorType<
    AuthenticationExceptionResponse | ValidationExceptionResponse
  >
>(
  logFile: string,
  params?: LogsContentParams,
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof logsContent>>,
        TError,
        TData,
        QueryKey,
        LogsContentParams["page"]
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useLogsContentSuspenseInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof logsContent>>,
    LogsContentParams["page"]
  >,
  TError = ErrorType<
    AuthenticationExceptionResponse | ValidationExceptionResponse
  >
>(
  logFile: string,
  params?: LogsContentParams,
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof logsContent>>,
        TError,
        TData,
        QueryKey,
        LogsContentParams["page"]
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get paginated content from a log file
 */

export function useLogsContentSuspenseInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof logsContent>>,
    LogsContentParams["page"]
  >,
  TError = ErrorType<
    AuthenticationExceptionResponse | ValidationExceptionResponse
  >
>(
  logFile: string,
  params?: LogsContentParams,
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof logsContent>>,
        TError,
        TData,
        QueryKey,
        LogsContentParams["page"]
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getLogsContentSuspenseInfiniteQueryOptions(
    logFile,
    params,
    options
  );

  const query = useSuspenseInfiniteQuery(
    queryOptions,
    queryClient
  ) as UseSuspenseInfiniteQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Returns the total line count for a log file using optimized counting
algorithms that can handle very large files efficiently.
 * @summary Count total lines in a log file
 */
export const logsLines = (
  logFile: string,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal
) => {
  return customInstance<LogsLines200>(
    { url: `/api/logs/${logFile}/lines`, method: "GET", signal },
    options
  );
};

export const getLogsLinesQueryKey = (logFile?: string) => {
  return [`/api/logs/${logFile}/lines`] as const;
};

export const getLogsLinesInfiniteQueryOptions = <
  TData = InfiniteData<Awaited<ReturnType<typeof logsLines>>>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(
  logFile: string,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof logsLines>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getLogsLinesQueryKey(logFile);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof logsLines>>> = ({
    signal,
  }) => logsLines(logFile, requestOptions, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!logFile,
    ...queryOptions,
  } as UseInfiniteQueryOptions<
    Awaited<ReturnType<typeof logsLines>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type LogsLinesInfiniteQueryResult = NonNullable<
  Awaited<ReturnType<typeof logsLines>>
>;
export type LogsLinesInfiniteQueryError =
  ErrorType<AuthenticationExceptionResponse>;

export function useLogsLinesInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof logsLines>>>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(
  logFile: string,
  options: {
    query: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof logsLines>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof logsLines>>,
          TError,
          Awaited<ReturnType<typeof logsLines>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): DefinedUseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useLogsLinesInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof logsLines>>>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(
  logFile: string,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof logsLines>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof logsLines>>,
          TError,
          Awaited<ReturnType<typeof logsLines>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useLogsLinesInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof logsLines>>>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(
  logFile: string,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof logsLines>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Count total lines in a log file
 */

export function useLogsLinesInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof logsLines>>>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(
  logFile: string,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof logsLines>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getLogsLinesInfiniteQueryOptions(logFile, options);

  const query = useInfiniteQuery(
    queryOptions,
    queryClient
  ) as UseInfiniteQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getLogsLinesQueryOptions = <
  TData = Awaited<ReturnType<typeof logsLines>>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(
  logFile: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof logsLines>>, TError, TData>
    >;
    request?: SecondParameter<typeof customInstance>;
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getLogsLinesQueryKey(logFile);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof logsLines>>> = ({
    signal,
  }) => logsLines(logFile, requestOptions, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!logFile,
    ...queryOptions,
  } as UseQueryOptions<Awaited<ReturnType<typeof logsLines>>, TError, TData> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };
};

export type LogsLinesQueryResult = NonNullable<
  Awaited<ReturnType<typeof logsLines>>
>;
export type LogsLinesQueryError = ErrorType<AuthenticationExceptionResponse>;

export function useLogsLines<
  TData = Awaited<ReturnType<typeof logsLines>>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(
  logFile: string,
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof logsLines>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof logsLines>>,
          TError,
          Awaited<ReturnType<typeof logsLines>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useLogsLines<
  TData = Awaited<ReturnType<typeof logsLines>>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(
  logFile: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof logsLines>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof logsLines>>,
          TError,
          Awaited<ReturnType<typeof logsLines>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useLogsLines<
  TData = Awaited<ReturnType<typeof logsLines>>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(
  logFile: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof logsLines>>, TError, TData>
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Count total lines in a log file
 */

export function useLogsLines<
  TData = Awaited<ReturnType<typeof logsLines>>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(
  logFile: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof logsLines>>, TError, TData>
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getLogsLinesQueryOptions(logFile, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getLogsLinesSuspenseQueryOptions = <
  TData = Awaited<ReturnType<typeof logsLines>>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(
  logFile: string,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof logsLines>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getLogsLinesQueryKey(logFile);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof logsLines>>> = ({
    signal,
  }) => logsLines(logFile, requestOptions, signal);

  return { queryKey, queryFn, ...queryOptions } as UseSuspenseQueryOptions<
    Awaited<ReturnType<typeof logsLines>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type LogsLinesSuspenseQueryResult = NonNullable<
  Awaited<ReturnType<typeof logsLines>>
>;
export type LogsLinesSuspenseQueryError =
  ErrorType<AuthenticationExceptionResponse>;

export function useLogsLinesSuspense<
  TData = Awaited<ReturnType<typeof logsLines>>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(
  logFile: string,
  options: {
    query: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof logsLines>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useLogsLinesSuspense<
  TData = Awaited<ReturnType<typeof logsLines>>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(
  logFile: string,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof logsLines>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useLogsLinesSuspense<
  TData = Awaited<ReturnType<typeof logsLines>>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(
  logFile: string,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof logsLines>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Count total lines in a log file
 */

export function useLogsLinesSuspense<
  TData = Awaited<ReturnType<typeof logsLines>>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(
  logFile: string,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof logsLines>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getLogsLinesSuspenseQueryOptions(logFile, options);

  const query = useSuspenseQuery(
    queryOptions,
    queryClient
  ) as UseSuspenseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getLogsLinesSuspenseInfiniteQueryOptions = <
  TData = InfiniteData<Awaited<ReturnType<typeof logsLines>>>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(
  logFile: string,
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof logsLines>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getLogsLinesQueryKey(logFile);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof logsLines>>> = ({
    signal,
  }) => logsLines(logFile, requestOptions, signal);

  return {
    queryKey,
    queryFn,
    ...queryOptions,
  } as UseSuspenseInfiniteQueryOptions<
    Awaited<ReturnType<typeof logsLines>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type LogsLinesSuspenseInfiniteQueryResult = NonNullable<
  Awaited<ReturnType<typeof logsLines>>
>;
export type LogsLinesSuspenseInfiniteQueryError =
  ErrorType<AuthenticationExceptionResponse>;

export function useLogsLinesSuspenseInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof logsLines>>>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(
  logFile: string,
  options: {
    query: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof logsLines>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useLogsLinesSuspenseInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof logsLines>>>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(
  logFile: string,
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof logsLines>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useLogsLinesSuspenseInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof logsLines>>>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(
  logFile: string,
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof logsLines>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Count total lines in a log file
 */

export function useLogsLinesSuspenseInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof logsLines>>>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(
  logFile: string,
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof logsLines>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getLogsLinesSuspenseInfiniteQueryOptions(
    logFile,
    options
  );

  const query = useSuspenseInfiniteQuery(
    queryOptions,
    queryClient
  ) as UseSuspenseInfiniteQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Returns the most recent lines from a log file, similar to the Unix tail command.
Useful for monitoring recent activity and debugging current issues.
 * @summary Get the last N lines from a log file (tail functionality)
 */
export const logsTail = (
  logFile: string,
  params?: LogsTailParams,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal
) => {
  return customInstance<LogsTail200>(
    { url: `/api/logs/${logFile}/tail`, method: "GET", params, signal },
    options
  );
};

export const getLogsTailQueryKey = (
  logFile?: string,
  params?: LogsTailParams
) => {
  return [`/api/logs/${logFile}/tail`, ...(params ? [params] : [])] as const;
};

export const getLogsTailInfiniteQueryOptions = <
  TData = InfiniteData<
    Awaited<ReturnType<typeof logsTail>>,
    LogsTailParams["page"]
  >,
  TError = ErrorType<
    AuthenticationExceptionResponse | ValidationExceptionResponse
  >
>(
  logFile: string,
  params?: LogsTailParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof logsTail>>,
        TError,
        TData,
        QueryKey,
        LogsTailParams["page"]
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getLogsTailQueryKey(logFile, params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof logsTail>>,
    QueryKey,
    LogsTailParams["page"]
  > = ({ signal, pageParam }) =>
    logsTail(
      logFile,
      { ...params, page: pageParam || params?.["page"] },
      requestOptions,
      signal
    );

  return {
    queryKey,
    queryFn,
    enabled: !!logFile,
    ...queryOptions,
  } as UseInfiniteQueryOptions<
    Awaited<ReturnType<typeof logsTail>>,
    TError,
    TData,
    QueryKey,
    LogsTailParams["page"]
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type LogsTailInfiniteQueryResult = NonNullable<
  Awaited<ReturnType<typeof logsTail>>
>;
export type LogsTailInfiniteQueryError = ErrorType<
  AuthenticationExceptionResponse | ValidationExceptionResponse
>;

export function useLogsTailInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof logsTail>>,
    LogsTailParams["page"]
  >,
  TError = ErrorType<
    AuthenticationExceptionResponse | ValidationExceptionResponse
  >
>(
  logFile: string,
  params: undefined | LogsTailParams,
  options: {
    query: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof logsTail>>,
        TError,
        TData,
        QueryKey,
        LogsTailParams["page"]
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof logsTail>>,
          TError,
          Awaited<ReturnType<typeof logsTail>>,
          QueryKey
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): DefinedUseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useLogsTailInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof logsTail>>,
    LogsTailParams["page"]
  >,
  TError = ErrorType<
    AuthenticationExceptionResponse | ValidationExceptionResponse
  >
>(
  logFile: string,
  params?: LogsTailParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof logsTail>>,
        TError,
        TData,
        QueryKey,
        LogsTailParams["page"]
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof logsTail>>,
          TError,
          Awaited<ReturnType<typeof logsTail>>,
          QueryKey
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useLogsTailInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof logsTail>>,
    LogsTailParams["page"]
  >,
  TError = ErrorType<
    AuthenticationExceptionResponse | ValidationExceptionResponse
  >
>(
  logFile: string,
  params?: LogsTailParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof logsTail>>,
        TError,
        TData,
        QueryKey,
        LogsTailParams["page"]
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get the last N lines from a log file (tail functionality)
 */

export function useLogsTailInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof logsTail>>,
    LogsTailParams["page"]
  >,
  TError = ErrorType<
    AuthenticationExceptionResponse | ValidationExceptionResponse
  >
>(
  logFile: string,
  params?: LogsTailParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof logsTail>>,
        TError,
        TData,
        QueryKey,
        LogsTailParams["page"]
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getLogsTailInfiniteQueryOptions(
    logFile,
    params,
    options
  );

  const query = useInfiniteQuery(
    queryOptions,
    queryClient
  ) as UseInfiniteQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getLogsTailQueryOptions = <
  TData = Awaited<ReturnType<typeof logsTail>>,
  TError = ErrorType<
    AuthenticationExceptionResponse | ValidationExceptionResponse
  >
>(
  logFile: string,
  params?: LogsTailParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof logsTail>>, TError, TData>
    >;
    request?: SecondParameter<typeof customInstance>;
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getLogsTailQueryKey(logFile, params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof logsTail>>> = ({
    signal,
  }) => logsTail(logFile, params, requestOptions, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!logFile,
    ...queryOptions,
  } as UseQueryOptions<Awaited<ReturnType<typeof logsTail>>, TError, TData> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };
};

export type LogsTailQueryResult = NonNullable<
  Awaited<ReturnType<typeof logsTail>>
>;
export type LogsTailQueryError = ErrorType<
  AuthenticationExceptionResponse | ValidationExceptionResponse
>;

export function useLogsTail<
  TData = Awaited<ReturnType<typeof logsTail>>,
  TError = ErrorType<
    AuthenticationExceptionResponse | ValidationExceptionResponse
  >
>(
  logFile: string,
  params: undefined | LogsTailParams,
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof logsTail>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof logsTail>>,
          TError,
          Awaited<ReturnType<typeof logsTail>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useLogsTail<
  TData = Awaited<ReturnType<typeof logsTail>>,
  TError = ErrorType<
    AuthenticationExceptionResponse | ValidationExceptionResponse
  >
>(
  logFile: string,
  params?: LogsTailParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof logsTail>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof logsTail>>,
          TError,
          Awaited<ReturnType<typeof logsTail>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useLogsTail<
  TData = Awaited<ReturnType<typeof logsTail>>,
  TError = ErrorType<
    AuthenticationExceptionResponse | ValidationExceptionResponse
  >
>(
  logFile: string,
  params?: LogsTailParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof logsTail>>, TError, TData>
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get the last N lines from a log file (tail functionality)
 */

export function useLogsTail<
  TData = Awaited<ReturnType<typeof logsTail>>,
  TError = ErrorType<
    AuthenticationExceptionResponse | ValidationExceptionResponse
  >
>(
  logFile: string,
  params?: LogsTailParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof logsTail>>, TError, TData>
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getLogsTailQueryOptions(logFile, params, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getLogsTailSuspenseQueryOptions = <
  TData = Awaited<ReturnType<typeof logsTail>>,
  TError = ErrorType<
    AuthenticationExceptionResponse | ValidationExceptionResponse
  >
>(
  logFile: string,
  params?: LogsTailParams,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof logsTail>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getLogsTailQueryKey(logFile, params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof logsTail>>> = ({
    signal,
  }) => logsTail(logFile, params, requestOptions, signal);

  return { queryKey, queryFn, ...queryOptions } as UseSuspenseQueryOptions<
    Awaited<ReturnType<typeof logsTail>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type LogsTailSuspenseQueryResult = NonNullable<
  Awaited<ReturnType<typeof logsTail>>
>;
export type LogsTailSuspenseQueryError = ErrorType<
  AuthenticationExceptionResponse | ValidationExceptionResponse
>;

export function useLogsTailSuspense<
  TData = Awaited<ReturnType<typeof logsTail>>,
  TError = ErrorType<
    AuthenticationExceptionResponse | ValidationExceptionResponse
  >
>(
  logFile: string,
  params: undefined | LogsTailParams,
  options: {
    query: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof logsTail>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useLogsTailSuspense<
  TData = Awaited<ReturnType<typeof logsTail>>,
  TError = ErrorType<
    AuthenticationExceptionResponse | ValidationExceptionResponse
  >
>(
  logFile: string,
  params?: LogsTailParams,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof logsTail>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useLogsTailSuspense<
  TData = Awaited<ReturnType<typeof logsTail>>,
  TError = ErrorType<
    AuthenticationExceptionResponse | ValidationExceptionResponse
  >
>(
  logFile: string,
  params?: LogsTailParams,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof logsTail>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get the last N lines from a log file (tail functionality)
 */

export function useLogsTailSuspense<
  TData = Awaited<ReturnType<typeof logsTail>>,
  TError = ErrorType<
    AuthenticationExceptionResponse | ValidationExceptionResponse
  >
>(
  logFile: string,
  params?: LogsTailParams,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof logsTail>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getLogsTailSuspenseQueryOptions(
    logFile,
    params,
    options
  );

  const query = useSuspenseQuery(
    queryOptions,
    queryClient
  ) as UseSuspenseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getLogsTailSuspenseInfiniteQueryOptions = <
  TData = InfiniteData<
    Awaited<ReturnType<typeof logsTail>>,
    LogsTailParams["page"]
  >,
  TError = ErrorType<
    AuthenticationExceptionResponse | ValidationExceptionResponse
  >
>(
  logFile: string,
  params?: LogsTailParams,
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof logsTail>>,
        TError,
        TData,
        QueryKey,
        LogsTailParams["page"]
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getLogsTailQueryKey(logFile, params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof logsTail>>,
    QueryKey,
    LogsTailParams["page"]
  > = ({ signal, pageParam }) =>
    logsTail(
      logFile,
      { ...params, page: pageParam || params?.["page"] },
      requestOptions,
      signal
    );

  return {
    queryKey,
    queryFn,
    ...queryOptions,
  } as UseSuspenseInfiniteQueryOptions<
    Awaited<ReturnType<typeof logsTail>>,
    TError,
    TData,
    QueryKey,
    LogsTailParams["page"]
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type LogsTailSuspenseInfiniteQueryResult = NonNullable<
  Awaited<ReturnType<typeof logsTail>>
>;
export type LogsTailSuspenseInfiniteQueryError = ErrorType<
  AuthenticationExceptionResponse | ValidationExceptionResponse
>;

export function useLogsTailSuspenseInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof logsTail>>,
    LogsTailParams["page"]
  >,
  TError = ErrorType<
    AuthenticationExceptionResponse | ValidationExceptionResponse
  >
>(
  logFile: string,
  params: undefined | LogsTailParams,
  options: {
    query: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof logsTail>>,
        TError,
        TData,
        QueryKey,
        LogsTailParams["page"]
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useLogsTailSuspenseInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof logsTail>>,
    LogsTailParams["page"]
  >,
  TError = ErrorType<
    AuthenticationExceptionResponse | ValidationExceptionResponse
  >
>(
  logFile: string,
  params?: LogsTailParams,
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof logsTail>>,
        TError,
        TData,
        QueryKey,
        LogsTailParams["page"]
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useLogsTailSuspenseInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof logsTail>>,
    LogsTailParams["page"]
  >,
  TError = ErrorType<
    AuthenticationExceptionResponse | ValidationExceptionResponse
  >
>(
  logFile: string,
  params?: LogsTailParams,
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof logsTail>>,
        TError,
        TData,
        QueryKey,
        LogsTailParams["page"]
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get the last N lines from a log file (tail functionality)
 */

export function useLogsTailSuspenseInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof logsTail>>,
    LogsTailParams["page"]
  >,
  TError = ErrorType<
    AuthenticationExceptionResponse | ValidationExceptionResponse
  >
>(
  logFile: string,
  params?: LogsTailParams,
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof logsTail>>,
        TError,
        TData,
        QueryKey,
        LogsTailParams["page"]
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getLogsTailSuspenseInfiniteQueryOptions(
    logFile,
    params,
    options
  );

  const query = useSuspenseInfiniteQuery(
    queryOptions,
    queryClient
  ) as UseSuspenseInfiniteQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Returns the first lines from a log file, similar to the Unix head command.
Useful for examining log file structure and initial entries.
 * @summary Get the first N lines from a log file (head functionality)
 */
export const logsHead = (
  logFile: string,
  params?: LogsHeadParams,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal
) => {
  return customInstance<LogsHead200>(
    { url: `/api/logs/${logFile}/head`, method: "GET", params, signal },
    options
  );
};

export const getLogsHeadQueryKey = (
  logFile?: string,
  params?: LogsHeadParams
) => {
  return [`/api/logs/${logFile}/head`, ...(params ? [params] : [])] as const;
};

export const getLogsHeadInfiniteQueryOptions = <
  TData = InfiniteData<
    Awaited<ReturnType<typeof logsHead>>,
    LogsHeadParams["page"]
  >,
  TError = ErrorType<
    AuthenticationExceptionResponse | ValidationExceptionResponse
  >
>(
  logFile: string,
  params?: LogsHeadParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof logsHead>>,
        TError,
        TData,
        QueryKey,
        LogsHeadParams["page"]
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getLogsHeadQueryKey(logFile, params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof logsHead>>,
    QueryKey,
    LogsHeadParams["page"]
  > = ({ signal, pageParam }) =>
    logsHead(
      logFile,
      { ...params, page: pageParam || params?.["page"] },
      requestOptions,
      signal
    );

  return {
    queryKey,
    queryFn,
    enabled: !!logFile,
    ...queryOptions,
  } as UseInfiniteQueryOptions<
    Awaited<ReturnType<typeof logsHead>>,
    TError,
    TData,
    QueryKey,
    LogsHeadParams["page"]
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type LogsHeadInfiniteQueryResult = NonNullable<
  Awaited<ReturnType<typeof logsHead>>
>;
export type LogsHeadInfiniteQueryError = ErrorType<
  AuthenticationExceptionResponse | ValidationExceptionResponse
>;

export function useLogsHeadInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof logsHead>>,
    LogsHeadParams["page"]
  >,
  TError = ErrorType<
    AuthenticationExceptionResponse | ValidationExceptionResponse
  >
>(
  logFile: string,
  params: undefined | LogsHeadParams,
  options: {
    query: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof logsHead>>,
        TError,
        TData,
        QueryKey,
        LogsHeadParams["page"]
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof logsHead>>,
          TError,
          Awaited<ReturnType<typeof logsHead>>,
          QueryKey
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): DefinedUseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useLogsHeadInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof logsHead>>,
    LogsHeadParams["page"]
  >,
  TError = ErrorType<
    AuthenticationExceptionResponse | ValidationExceptionResponse
  >
>(
  logFile: string,
  params?: LogsHeadParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof logsHead>>,
        TError,
        TData,
        QueryKey,
        LogsHeadParams["page"]
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof logsHead>>,
          TError,
          Awaited<ReturnType<typeof logsHead>>,
          QueryKey
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useLogsHeadInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof logsHead>>,
    LogsHeadParams["page"]
  >,
  TError = ErrorType<
    AuthenticationExceptionResponse | ValidationExceptionResponse
  >
>(
  logFile: string,
  params?: LogsHeadParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof logsHead>>,
        TError,
        TData,
        QueryKey,
        LogsHeadParams["page"]
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get the first N lines from a log file (head functionality)
 */

export function useLogsHeadInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof logsHead>>,
    LogsHeadParams["page"]
  >,
  TError = ErrorType<
    AuthenticationExceptionResponse | ValidationExceptionResponse
  >
>(
  logFile: string,
  params?: LogsHeadParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof logsHead>>,
        TError,
        TData,
        QueryKey,
        LogsHeadParams["page"]
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getLogsHeadInfiniteQueryOptions(
    logFile,
    params,
    options
  );

  const query = useInfiniteQuery(
    queryOptions,
    queryClient
  ) as UseInfiniteQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getLogsHeadQueryOptions = <
  TData = Awaited<ReturnType<typeof logsHead>>,
  TError = ErrorType<
    AuthenticationExceptionResponse | ValidationExceptionResponse
  >
>(
  logFile: string,
  params?: LogsHeadParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof logsHead>>, TError, TData>
    >;
    request?: SecondParameter<typeof customInstance>;
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getLogsHeadQueryKey(logFile, params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof logsHead>>> = ({
    signal,
  }) => logsHead(logFile, params, requestOptions, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!logFile,
    ...queryOptions,
  } as UseQueryOptions<Awaited<ReturnType<typeof logsHead>>, TError, TData> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };
};

export type LogsHeadQueryResult = NonNullable<
  Awaited<ReturnType<typeof logsHead>>
>;
export type LogsHeadQueryError = ErrorType<
  AuthenticationExceptionResponse | ValidationExceptionResponse
>;

export function useLogsHead<
  TData = Awaited<ReturnType<typeof logsHead>>,
  TError = ErrorType<
    AuthenticationExceptionResponse | ValidationExceptionResponse
  >
>(
  logFile: string,
  params: undefined | LogsHeadParams,
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof logsHead>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof logsHead>>,
          TError,
          Awaited<ReturnType<typeof logsHead>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useLogsHead<
  TData = Awaited<ReturnType<typeof logsHead>>,
  TError = ErrorType<
    AuthenticationExceptionResponse | ValidationExceptionResponse
  >
>(
  logFile: string,
  params?: LogsHeadParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof logsHead>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof logsHead>>,
          TError,
          Awaited<ReturnType<typeof logsHead>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useLogsHead<
  TData = Awaited<ReturnType<typeof logsHead>>,
  TError = ErrorType<
    AuthenticationExceptionResponse | ValidationExceptionResponse
  >
>(
  logFile: string,
  params?: LogsHeadParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof logsHead>>, TError, TData>
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get the first N lines from a log file (head functionality)
 */

export function useLogsHead<
  TData = Awaited<ReturnType<typeof logsHead>>,
  TError = ErrorType<
    AuthenticationExceptionResponse | ValidationExceptionResponse
  >
>(
  logFile: string,
  params?: LogsHeadParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof logsHead>>, TError, TData>
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getLogsHeadQueryOptions(logFile, params, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getLogsHeadSuspenseQueryOptions = <
  TData = Awaited<ReturnType<typeof logsHead>>,
  TError = ErrorType<
    AuthenticationExceptionResponse | ValidationExceptionResponse
  >
>(
  logFile: string,
  params?: LogsHeadParams,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof logsHead>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getLogsHeadQueryKey(logFile, params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof logsHead>>> = ({
    signal,
  }) => logsHead(logFile, params, requestOptions, signal);

  return { queryKey, queryFn, ...queryOptions } as UseSuspenseQueryOptions<
    Awaited<ReturnType<typeof logsHead>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type LogsHeadSuspenseQueryResult = NonNullable<
  Awaited<ReturnType<typeof logsHead>>
>;
export type LogsHeadSuspenseQueryError = ErrorType<
  AuthenticationExceptionResponse | ValidationExceptionResponse
>;

export function useLogsHeadSuspense<
  TData = Awaited<ReturnType<typeof logsHead>>,
  TError = ErrorType<
    AuthenticationExceptionResponse | ValidationExceptionResponse
  >
>(
  logFile: string,
  params: undefined | LogsHeadParams,
  options: {
    query: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof logsHead>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useLogsHeadSuspense<
  TData = Awaited<ReturnType<typeof logsHead>>,
  TError = ErrorType<
    AuthenticationExceptionResponse | ValidationExceptionResponse
  >
>(
  logFile: string,
  params?: LogsHeadParams,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof logsHead>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useLogsHeadSuspense<
  TData = Awaited<ReturnType<typeof logsHead>>,
  TError = ErrorType<
    AuthenticationExceptionResponse | ValidationExceptionResponse
  >
>(
  logFile: string,
  params?: LogsHeadParams,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof logsHead>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get the first N lines from a log file (head functionality)
 */

export function useLogsHeadSuspense<
  TData = Awaited<ReturnType<typeof logsHead>>,
  TError = ErrorType<
    AuthenticationExceptionResponse | ValidationExceptionResponse
  >
>(
  logFile: string,
  params?: LogsHeadParams,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof logsHead>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getLogsHeadSuspenseQueryOptions(
    logFile,
    params,
    options
  );

  const query = useSuspenseQuery(
    queryOptions,
    queryClient
  ) as UseSuspenseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getLogsHeadSuspenseInfiniteQueryOptions = <
  TData = InfiniteData<
    Awaited<ReturnType<typeof logsHead>>,
    LogsHeadParams["page"]
  >,
  TError = ErrorType<
    AuthenticationExceptionResponse | ValidationExceptionResponse
  >
>(
  logFile: string,
  params?: LogsHeadParams,
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof logsHead>>,
        TError,
        TData,
        QueryKey,
        LogsHeadParams["page"]
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getLogsHeadQueryKey(logFile, params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof logsHead>>,
    QueryKey,
    LogsHeadParams["page"]
  > = ({ signal, pageParam }) =>
    logsHead(
      logFile,
      { ...params, page: pageParam || params?.["page"] },
      requestOptions,
      signal
    );

  return {
    queryKey,
    queryFn,
    ...queryOptions,
  } as UseSuspenseInfiniteQueryOptions<
    Awaited<ReturnType<typeof logsHead>>,
    TError,
    TData,
    QueryKey,
    LogsHeadParams["page"]
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type LogsHeadSuspenseInfiniteQueryResult = NonNullable<
  Awaited<ReturnType<typeof logsHead>>
>;
export type LogsHeadSuspenseInfiniteQueryError = ErrorType<
  AuthenticationExceptionResponse | ValidationExceptionResponse
>;

export function useLogsHeadSuspenseInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof logsHead>>,
    LogsHeadParams["page"]
  >,
  TError = ErrorType<
    AuthenticationExceptionResponse | ValidationExceptionResponse
  >
>(
  logFile: string,
  params: undefined | LogsHeadParams,
  options: {
    query: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof logsHead>>,
        TError,
        TData,
        QueryKey,
        LogsHeadParams["page"]
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useLogsHeadSuspenseInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof logsHead>>,
    LogsHeadParams["page"]
  >,
  TError = ErrorType<
    AuthenticationExceptionResponse | ValidationExceptionResponse
  >
>(
  logFile: string,
  params?: LogsHeadParams,
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof logsHead>>,
        TError,
        TData,
        QueryKey,
        LogsHeadParams["page"]
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useLogsHeadSuspenseInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof logsHead>>,
    LogsHeadParams["page"]
  >,
  TError = ErrorType<
    AuthenticationExceptionResponse | ValidationExceptionResponse
  >
>(
  logFile: string,
  params?: LogsHeadParams,
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof logsHead>>,
        TError,
        TData,
        QueryKey,
        LogsHeadParams["page"]
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get the first N lines from a log file (head functionality)
 */

export function useLogsHeadSuspenseInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof logsHead>>,
    LogsHeadParams["page"]
  >,
  TError = ErrorType<
    AuthenticationExceptionResponse | ValidationExceptionResponse
  >
>(
  logFile: string,
  params?: LogsHeadParams,
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof logsHead>>,
        TError,
        TData,
        QueryKey,
        LogsHeadParams["page"]
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getLogsHeadSuspenseInfiniteQueryOptions(
    logFile,
    params,
    options
  );

  const query = useSuspenseInfiniteQuery(
    queryOptions,
    queryClient
  ) as UseSuspenseInfiniteQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Analyzes log file content to provide detailed statistics including
log level counts, performance metrics, and optimization recommendations.
 * @summary Get comprehensive statistics for a log file
 */
export const logsStats = (
  logFile: string,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal
) => {
  return customInstance<LogsStats200>(
    { url: `/api/logs/${logFile}/stats`, method: "GET", signal },
    options
  );
};

export const getLogsStatsQueryKey = (logFile?: string) => {
  return [`/api/logs/${logFile}/stats`] as const;
};

export const getLogsStatsInfiniteQueryOptions = <
  TData = InfiniteData<Awaited<ReturnType<typeof logsStats>>>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(
  logFile: string,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof logsStats>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getLogsStatsQueryKey(logFile);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof logsStats>>> = ({
    signal,
  }) => logsStats(logFile, requestOptions, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!logFile,
    ...queryOptions,
  } as UseInfiniteQueryOptions<
    Awaited<ReturnType<typeof logsStats>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type LogsStatsInfiniteQueryResult = NonNullable<
  Awaited<ReturnType<typeof logsStats>>
>;
export type LogsStatsInfiniteQueryError =
  ErrorType<AuthenticationExceptionResponse>;

export function useLogsStatsInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof logsStats>>>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(
  logFile: string,
  options: {
    query: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof logsStats>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof logsStats>>,
          TError,
          Awaited<ReturnType<typeof logsStats>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): DefinedUseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useLogsStatsInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof logsStats>>>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(
  logFile: string,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof logsStats>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof logsStats>>,
          TError,
          Awaited<ReturnType<typeof logsStats>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useLogsStatsInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof logsStats>>>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(
  logFile: string,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof logsStats>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get comprehensive statistics for a log file
 */

export function useLogsStatsInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof logsStats>>>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(
  logFile: string,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof logsStats>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getLogsStatsInfiniteQueryOptions(logFile, options);

  const query = useInfiniteQuery(
    queryOptions,
    queryClient
  ) as UseInfiniteQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getLogsStatsQueryOptions = <
  TData = Awaited<ReturnType<typeof logsStats>>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(
  logFile: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof logsStats>>, TError, TData>
    >;
    request?: SecondParameter<typeof customInstance>;
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getLogsStatsQueryKey(logFile);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof logsStats>>> = ({
    signal,
  }) => logsStats(logFile, requestOptions, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!logFile,
    ...queryOptions,
  } as UseQueryOptions<Awaited<ReturnType<typeof logsStats>>, TError, TData> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };
};

export type LogsStatsQueryResult = NonNullable<
  Awaited<ReturnType<typeof logsStats>>
>;
export type LogsStatsQueryError = ErrorType<AuthenticationExceptionResponse>;

export function useLogsStats<
  TData = Awaited<ReturnType<typeof logsStats>>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(
  logFile: string,
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof logsStats>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof logsStats>>,
          TError,
          Awaited<ReturnType<typeof logsStats>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useLogsStats<
  TData = Awaited<ReturnType<typeof logsStats>>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(
  logFile: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof logsStats>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof logsStats>>,
          TError,
          Awaited<ReturnType<typeof logsStats>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useLogsStats<
  TData = Awaited<ReturnType<typeof logsStats>>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(
  logFile: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof logsStats>>, TError, TData>
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get comprehensive statistics for a log file
 */

export function useLogsStats<
  TData = Awaited<ReturnType<typeof logsStats>>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(
  logFile: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof logsStats>>, TError, TData>
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getLogsStatsQueryOptions(logFile, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getLogsStatsSuspenseQueryOptions = <
  TData = Awaited<ReturnType<typeof logsStats>>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(
  logFile: string,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof logsStats>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getLogsStatsQueryKey(logFile);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof logsStats>>> = ({
    signal,
  }) => logsStats(logFile, requestOptions, signal);

  return { queryKey, queryFn, ...queryOptions } as UseSuspenseQueryOptions<
    Awaited<ReturnType<typeof logsStats>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type LogsStatsSuspenseQueryResult = NonNullable<
  Awaited<ReturnType<typeof logsStats>>
>;
export type LogsStatsSuspenseQueryError =
  ErrorType<AuthenticationExceptionResponse>;

export function useLogsStatsSuspense<
  TData = Awaited<ReturnType<typeof logsStats>>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(
  logFile: string,
  options: {
    query: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof logsStats>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useLogsStatsSuspense<
  TData = Awaited<ReturnType<typeof logsStats>>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(
  logFile: string,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof logsStats>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useLogsStatsSuspense<
  TData = Awaited<ReturnType<typeof logsStats>>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(
  logFile: string,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof logsStats>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get comprehensive statistics for a log file
 */

export function useLogsStatsSuspense<
  TData = Awaited<ReturnType<typeof logsStats>>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(
  logFile: string,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof logsStats>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getLogsStatsSuspenseQueryOptions(logFile, options);

  const query = useSuspenseQuery(
    queryOptions,
    queryClient
  ) as UseSuspenseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getLogsStatsSuspenseInfiniteQueryOptions = <
  TData = InfiniteData<Awaited<ReturnType<typeof logsStats>>>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(
  logFile: string,
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof logsStats>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getLogsStatsQueryKey(logFile);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof logsStats>>> = ({
    signal,
  }) => logsStats(logFile, requestOptions, signal);

  return {
    queryKey,
    queryFn,
    ...queryOptions,
  } as UseSuspenseInfiniteQueryOptions<
    Awaited<ReturnType<typeof logsStats>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type LogsStatsSuspenseInfiniteQueryResult = NonNullable<
  Awaited<ReturnType<typeof logsStats>>
>;
export type LogsStatsSuspenseInfiniteQueryError =
  ErrorType<AuthenticationExceptionResponse>;

export function useLogsStatsSuspenseInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof logsStats>>>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(
  logFile: string,
  options: {
    query: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof logsStats>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useLogsStatsSuspenseInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof logsStats>>>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(
  logFile: string,
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof logsStats>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useLogsStatsSuspenseInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof logsStats>>>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(
  logFile: string,
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof logsStats>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get comprehensive statistics for a log file
 */

export function useLogsStatsSuspenseInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof logsStats>>>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(
  logFile: string,
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof logsStats>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getLogsStatsSuspenseInfiniteQueryOptions(
    logFile,
    options
  );

  const query = useSuspenseInfiniteQuery(
    queryOptions,
    queryClient
  ) as UseSuspenseInfiniteQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Performs high-performance pattern matching within log files with support
for case-sensitive/insensitive searches and configurable result limits.
 * @summary Search for patterns within a log file
 */
export const logsSearch = (
  logFile: string,
  params: LogsSearchParams,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal
) => {
  return customInstance<LogsSearch200>(
    { url: `/api/logs/${logFile}/search`, method: "GET", params, signal },
    options
  );
};

export const getLogsSearchQueryKey = (
  logFile?: string,
  params?: LogsSearchParams
) => {
  return [`/api/logs/${logFile}/search`, ...(params ? [params] : [])] as const;
};

export const getLogsSearchInfiniteQueryOptions = <
  TData = InfiniteData<
    Awaited<ReturnType<typeof logsSearch>>,
    LogsSearchParams["page"]
  >,
  TError = ErrorType<
    AuthenticationExceptionResponse | ValidationExceptionResponse
  >
>(
  logFile: string,
  params: LogsSearchParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof logsSearch>>,
        TError,
        TData,
        QueryKey,
        LogsSearchParams["page"]
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getLogsSearchQueryKey(logFile, params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof logsSearch>>,
    QueryKey,
    LogsSearchParams["page"]
  > = ({ signal, pageParam }) =>
    logsSearch(
      logFile,
      { ...params, page: pageParam || params?.["page"] },
      requestOptions,
      signal
    );

  return {
    queryKey,
    queryFn,
    enabled: !!logFile,
    ...queryOptions,
  } as UseInfiniteQueryOptions<
    Awaited<ReturnType<typeof logsSearch>>,
    TError,
    TData,
    QueryKey,
    LogsSearchParams["page"]
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type LogsSearchInfiniteQueryResult = NonNullable<
  Awaited<ReturnType<typeof logsSearch>>
>;
export type LogsSearchInfiniteQueryError = ErrorType<
  AuthenticationExceptionResponse | ValidationExceptionResponse
>;

export function useLogsSearchInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof logsSearch>>,
    LogsSearchParams["page"]
  >,
  TError = ErrorType<
    AuthenticationExceptionResponse | ValidationExceptionResponse
  >
>(
  logFile: string,
  params: LogsSearchParams,
  options: {
    query: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof logsSearch>>,
        TError,
        TData,
        QueryKey,
        LogsSearchParams["page"]
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof logsSearch>>,
          TError,
          Awaited<ReturnType<typeof logsSearch>>,
          QueryKey
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): DefinedUseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useLogsSearchInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof logsSearch>>,
    LogsSearchParams["page"]
  >,
  TError = ErrorType<
    AuthenticationExceptionResponse | ValidationExceptionResponse
  >
>(
  logFile: string,
  params: LogsSearchParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof logsSearch>>,
        TError,
        TData,
        QueryKey,
        LogsSearchParams["page"]
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof logsSearch>>,
          TError,
          Awaited<ReturnType<typeof logsSearch>>,
          QueryKey
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useLogsSearchInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof logsSearch>>,
    LogsSearchParams["page"]
  >,
  TError = ErrorType<
    AuthenticationExceptionResponse | ValidationExceptionResponse
  >
>(
  logFile: string,
  params: LogsSearchParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof logsSearch>>,
        TError,
        TData,
        QueryKey,
        LogsSearchParams["page"]
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Search for patterns within a log file
 */

export function useLogsSearchInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof logsSearch>>,
    LogsSearchParams["page"]
  >,
  TError = ErrorType<
    AuthenticationExceptionResponse | ValidationExceptionResponse
  >
>(
  logFile: string,
  params: LogsSearchParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof logsSearch>>,
        TError,
        TData,
        QueryKey,
        LogsSearchParams["page"]
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getLogsSearchInfiniteQueryOptions(
    logFile,
    params,
    options
  );

  const query = useInfiniteQuery(
    queryOptions,
    queryClient
  ) as UseInfiniteQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getLogsSearchQueryOptions = <
  TData = Awaited<ReturnType<typeof logsSearch>>,
  TError = ErrorType<
    AuthenticationExceptionResponse | ValidationExceptionResponse
  >
>(
  logFile: string,
  params: LogsSearchParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof logsSearch>>, TError, TData>
    >;
    request?: SecondParameter<typeof customInstance>;
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getLogsSearchQueryKey(logFile, params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof logsSearch>>> = ({
    signal,
  }) => logsSearch(logFile, params, requestOptions, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!logFile,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof logsSearch>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type LogsSearchQueryResult = NonNullable<
  Awaited<ReturnType<typeof logsSearch>>
>;
export type LogsSearchQueryError = ErrorType<
  AuthenticationExceptionResponse | ValidationExceptionResponse
>;

export function useLogsSearch<
  TData = Awaited<ReturnType<typeof logsSearch>>,
  TError = ErrorType<
    AuthenticationExceptionResponse | ValidationExceptionResponse
  >
>(
  logFile: string,
  params: LogsSearchParams,
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof logsSearch>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof logsSearch>>,
          TError,
          Awaited<ReturnType<typeof logsSearch>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useLogsSearch<
  TData = Awaited<ReturnType<typeof logsSearch>>,
  TError = ErrorType<
    AuthenticationExceptionResponse | ValidationExceptionResponse
  >
>(
  logFile: string,
  params: LogsSearchParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof logsSearch>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof logsSearch>>,
          TError,
          Awaited<ReturnType<typeof logsSearch>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useLogsSearch<
  TData = Awaited<ReturnType<typeof logsSearch>>,
  TError = ErrorType<
    AuthenticationExceptionResponse | ValidationExceptionResponse
  >
>(
  logFile: string,
  params: LogsSearchParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof logsSearch>>, TError, TData>
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Search for patterns within a log file
 */

export function useLogsSearch<
  TData = Awaited<ReturnType<typeof logsSearch>>,
  TError = ErrorType<
    AuthenticationExceptionResponse | ValidationExceptionResponse
  >
>(
  logFile: string,
  params: LogsSearchParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof logsSearch>>, TError, TData>
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getLogsSearchQueryOptions(logFile, params, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getLogsSearchSuspenseQueryOptions = <
  TData = Awaited<ReturnType<typeof logsSearch>>,
  TError = ErrorType<
    AuthenticationExceptionResponse | ValidationExceptionResponse
  >
>(
  logFile: string,
  params: LogsSearchParams,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof logsSearch>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getLogsSearchQueryKey(logFile, params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof logsSearch>>> = ({
    signal,
  }) => logsSearch(logFile, params, requestOptions, signal);

  return { queryKey, queryFn, ...queryOptions } as UseSuspenseQueryOptions<
    Awaited<ReturnType<typeof logsSearch>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type LogsSearchSuspenseQueryResult = NonNullable<
  Awaited<ReturnType<typeof logsSearch>>
>;
export type LogsSearchSuspenseQueryError = ErrorType<
  AuthenticationExceptionResponse | ValidationExceptionResponse
>;

export function useLogsSearchSuspense<
  TData = Awaited<ReturnType<typeof logsSearch>>,
  TError = ErrorType<
    AuthenticationExceptionResponse | ValidationExceptionResponse
  >
>(
  logFile: string,
  params: LogsSearchParams,
  options: {
    query: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof logsSearch>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useLogsSearchSuspense<
  TData = Awaited<ReturnType<typeof logsSearch>>,
  TError = ErrorType<
    AuthenticationExceptionResponse | ValidationExceptionResponse
  >
>(
  logFile: string,
  params: LogsSearchParams,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof logsSearch>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useLogsSearchSuspense<
  TData = Awaited<ReturnType<typeof logsSearch>>,
  TError = ErrorType<
    AuthenticationExceptionResponse | ValidationExceptionResponse
  >
>(
  logFile: string,
  params: LogsSearchParams,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof logsSearch>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Search for patterns within a log file
 */

export function useLogsSearchSuspense<
  TData = Awaited<ReturnType<typeof logsSearch>>,
  TError = ErrorType<
    AuthenticationExceptionResponse | ValidationExceptionResponse
  >
>(
  logFile: string,
  params: LogsSearchParams,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof logsSearch>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getLogsSearchSuspenseQueryOptions(
    logFile,
    params,
    options
  );

  const query = useSuspenseQuery(
    queryOptions,
    queryClient
  ) as UseSuspenseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getLogsSearchSuspenseInfiniteQueryOptions = <
  TData = InfiniteData<
    Awaited<ReturnType<typeof logsSearch>>,
    LogsSearchParams["page"]
  >,
  TError = ErrorType<
    AuthenticationExceptionResponse | ValidationExceptionResponse
  >
>(
  logFile: string,
  params: LogsSearchParams,
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof logsSearch>>,
        TError,
        TData,
        QueryKey,
        LogsSearchParams["page"]
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getLogsSearchQueryKey(logFile, params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof logsSearch>>,
    QueryKey,
    LogsSearchParams["page"]
  > = ({ signal, pageParam }) =>
    logsSearch(
      logFile,
      { ...params, page: pageParam || params?.["page"] },
      requestOptions,
      signal
    );

  return {
    queryKey,
    queryFn,
    ...queryOptions,
  } as UseSuspenseInfiniteQueryOptions<
    Awaited<ReturnType<typeof logsSearch>>,
    TError,
    TData,
    QueryKey,
    LogsSearchParams["page"]
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type LogsSearchSuspenseInfiniteQueryResult = NonNullable<
  Awaited<ReturnType<typeof logsSearch>>
>;
export type LogsSearchSuspenseInfiniteQueryError = ErrorType<
  AuthenticationExceptionResponse | ValidationExceptionResponse
>;

export function useLogsSearchSuspenseInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof logsSearch>>,
    LogsSearchParams["page"]
  >,
  TError = ErrorType<
    AuthenticationExceptionResponse | ValidationExceptionResponse
  >
>(
  logFile: string,
  params: LogsSearchParams,
  options: {
    query: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof logsSearch>>,
        TError,
        TData,
        QueryKey,
        LogsSearchParams["page"]
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useLogsSearchSuspenseInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof logsSearch>>,
    LogsSearchParams["page"]
  >,
  TError = ErrorType<
    AuthenticationExceptionResponse | ValidationExceptionResponse
  >
>(
  logFile: string,
  params: LogsSearchParams,
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof logsSearch>>,
        TError,
        TData,
        QueryKey,
        LogsSearchParams["page"]
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useLogsSearchSuspenseInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof logsSearch>>,
    LogsSearchParams["page"]
  >,
  TError = ErrorType<
    AuthenticationExceptionResponse | ValidationExceptionResponse
  >
>(
  logFile: string,
  params: LogsSearchParams,
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof logsSearch>>,
        TError,
        TData,
        QueryKey,
        LogsSearchParams["page"]
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Search for patterns within a log file
 */

export function useLogsSearchSuspenseInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof logsSearch>>,
    LogsSearchParams["page"]
  >,
  TError = ErrorType<
    AuthenticationExceptionResponse | ValidationExceptionResponse
  >
>(
  logFile: string,
  params: LogsSearchParams,
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof logsSearch>>,
        TError,
        TData,
        QueryKey,
        LogsSearchParams["page"]
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getLogsSearchSuspenseInfiniteQueryOptions(
    logFile,
    params,
    options
  );

  const query = useSuspenseInfiniteQuery(
    queryOptions,
    queryClient
  ) as UseSuspenseInfiniteQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Provides direct download access to log files for offline analysis
or archival purposes. Returns the file as a plain text download.
 * @summary Download a log file
 */
export const logsDownload = (
  logFile: string,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal
) => {
  return customInstance<LogsDownload200>(
    { url: `/api/logs/${logFile}/download`, method: "GET", signal },
    options
  );
};

export const getLogsDownloadQueryKey = (logFile?: string) => {
  return [`/api/logs/${logFile}/download`] as const;
};

export const getLogsDownloadInfiniteQueryOptions = <
  TData = InfiniteData<Awaited<ReturnType<typeof logsDownload>>>,
  TError = ErrorType<
    AuthenticationExceptionResponse | ModelNotFoundExceptionResponse
  >
>(
  logFile: string,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof logsDownload>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getLogsDownloadQueryKey(logFile);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof logsDownload>>> = ({
    signal,
  }) => logsDownload(logFile, requestOptions, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!logFile,
    ...queryOptions,
  } as UseInfiniteQueryOptions<
    Awaited<ReturnType<typeof logsDownload>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type LogsDownloadInfiniteQueryResult = NonNullable<
  Awaited<ReturnType<typeof logsDownload>>
>;
export type LogsDownloadInfiniteQueryError = ErrorType<
  AuthenticationExceptionResponse | ModelNotFoundExceptionResponse
>;

export function useLogsDownloadInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof logsDownload>>>,
  TError = ErrorType<
    AuthenticationExceptionResponse | ModelNotFoundExceptionResponse
  >
>(
  logFile: string,
  options: {
    query: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof logsDownload>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof logsDownload>>,
          TError,
          Awaited<ReturnType<typeof logsDownload>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): DefinedUseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useLogsDownloadInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof logsDownload>>>,
  TError = ErrorType<
    AuthenticationExceptionResponse | ModelNotFoundExceptionResponse
  >
>(
  logFile: string,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof logsDownload>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof logsDownload>>,
          TError,
          Awaited<ReturnType<typeof logsDownload>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useLogsDownloadInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof logsDownload>>>,
  TError = ErrorType<
    AuthenticationExceptionResponse | ModelNotFoundExceptionResponse
  >
>(
  logFile: string,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof logsDownload>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Download a log file
 */

export function useLogsDownloadInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof logsDownload>>>,
  TError = ErrorType<
    AuthenticationExceptionResponse | ModelNotFoundExceptionResponse
  >
>(
  logFile: string,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof logsDownload>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getLogsDownloadInfiniteQueryOptions(logFile, options);

  const query = useInfiniteQuery(
    queryOptions,
    queryClient
  ) as UseInfiniteQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getLogsDownloadQueryOptions = <
  TData = Awaited<ReturnType<typeof logsDownload>>,
  TError = ErrorType<
    AuthenticationExceptionResponse | ModelNotFoundExceptionResponse
  >
>(
  logFile: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof logsDownload>>, TError, TData>
    >;
    request?: SecondParameter<typeof customInstance>;
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getLogsDownloadQueryKey(logFile);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof logsDownload>>> = ({
    signal,
  }) => logsDownload(logFile, requestOptions, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!logFile,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof logsDownload>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type LogsDownloadQueryResult = NonNullable<
  Awaited<ReturnType<typeof logsDownload>>
>;
export type LogsDownloadQueryError = ErrorType<
  AuthenticationExceptionResponse | ModelNotFoundExceptionResponse
>;

export function useLogsDownload<
  TData = Awaited<ReturnType<typeof logsDownload>>,
  TError = ErrorType<
    AuthenticationExceptionResponse | ModelNotFoundExceptionResponse
  >
>(
  logFile: string,
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof logsDownload>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof logsDownload>>,
          TError,
          Awaited<ReturnType<typeof logsDownload>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useLogsDownload<
  TData = Awaited<ReturnType<typeof logsDownload>>,
  TError = ErrorType<
    AuthenticationExceptionResponse | ModelNotFoundExceptionResponse
  >
>(
  logFile: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof logsDownload>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof logsDownload>>,
          TError,
          Awaited<ReturnType<typeof logsDownload>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useLogsDownload<
  TData = Awaited<ReturnType<typeof logsDownload>>,
  TError = ErrorType<
    AuthenticationExceptionResponse | ModelNotFoundExceptionResponse
  >
>(
  logFile: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof logsDownload>>, TError, TData>
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Download a log file
 */

export function useLogsDownload<
  TData = Awaited<ReturnType<typeof logsDownload>>,
  TError = ErrorType<
    AuthenticationExceptionResponse | ModelNotFoundExceptionResponse
  >
>(
  logFile: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof logsDownload>>, TError, TData>
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getLogsDownloadQueryOptions(logFile, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getLogsDownloadSuspenseQueryOptions = <
  TData = Awaited<ReturnType<typeof logsDownload>>,
  TError = ErrorType<
    AuthenticationExceptionResponse | ModelNotFoundExceptionResponse
  >
>(
  logFile: string,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof logsDownload>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getLogsDownloadQueryKey(logFile);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof logsDownload>>> = ({
    signal,
  }) => logsDownload(logFile, requestOptions, signal);

  return { queryKey, queryFn, ...queryOptions } as UseSuspenseQueryOptions<
    Awaited<ReturnType<typeof logsDownload>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type LogsDownloadSuspenseQueryResult = NonNullable<
  Awaited<ReturnType<typeof logsDownload>>
>;
export type LogsDownloadSuspenseQueryError = ErrorType<
  AuthenticationExceptionResponse | ModelNotFoundExceptionResponse
>;

export function useLogsDownloadSuspense<
  TData = Awaited<ReturnType<typeof logsDownload>>,
  TError = ErrorType<
    AuthenticationExceptionResponse | ModelNotFoundExceptionResponse
  >
>(
  logFile: string,
  options: {
    query: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof logsDownload>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useLogsDownloadSuspense<
  TData = Awaited<ReturnType<typeof logsDownload>>,
  TError = ErrorType<
    AuthenticationExceptionResponse | ModelNotFoundExceptionResponse
  >
>(
  logFile: string,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof logsDownload>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useLogsDownloadSuspense<
  TData = Awaited<ReturnType<typeof logsDownload>>,
  TError = ErrorType<
    AuthenticationExceptionResponse | ModelNotFoundExceptionResponse
  >
>(
  logFile: string,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof logsDownload>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Download a log file
 */

export function useLogsDownloadSuspense<
  TData = Awaited<ReturnType<typeof logsDownload>>,
  TError = ErrorType<
    AuthenticationExceptionResponse | ModelNotFoundExceptionResponse
  >
>(
  logFile: string,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof logsDownload>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getLogsDownloadSuspenseQueryOptions(logFile, options);

  const query = useSuspenseQuery(
    queryOptions,
    queryClient
  ) as UseSuspenseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getLogsDownloadSuspenseInfiniteQueryOptions = <
  TData = InfiniteData<Awaited<ReturnType<typeof logsDownload>>>,
  TError = ErrorType<
    AuthenticationExceptionResponse | ModelNotFoundExceptionResponse
  >
>(
  logFile: string,
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof logsDownload>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getLogsDownloadQueryKey(logFile);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof logsDownload>>> = ({
    signal,
  }) => logsDownload(logFile, requestOptions, signal);

  return {
    queryKey,
    queryFn,
    ...queryOptions,
  } as UseSuspenseInfiniteQueryOptions<
    Awaited<ReturnType<typeof logsDownload>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type LogsDownloadSuspenseInfiniteQueryResult = NonNullable<
  Awaited<ReturnType<typeof logsDownload>>
>;
export type LogsDownloadSuspenseInfiniteQueryError = ErrorType<
  AuthenticationExceptionResponse | ModelNotFoundExceptionResponse
>;

export function useLogsDownloadSuspenseInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof logsDownload>>>,
  TError = ErrorType<
    AuthenticationExceptionResponse | ModelNotFoundExceptionResponse
  >
>(
  logFile: string,
  options: {
    query: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof logsDownload>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useLogsDownloadSuspenseInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof logsDownload>>>,
  TError = ErrorType<
    AuthenticationExceptionResponse | ModelNotFoundExceptionResponse
  >
>(
  logFile: string,
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof logsDownload>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useLogsDownloadSuspenseInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof logsDownload>>>,
  TError = ErrorType<
    AuthenticationExceptionResponse | ModelNotFoundExceptionResponse
  >
>(
  logFile: string,
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof logsDownload>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Download a log file
 */

export function useLogsDownloadSuspenseInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof logsDownload>>>,
  TError = ErrorType<
    AuthenticationExceptionResponse | ModelNotFoundExceptionResponse
  >
>(
  logFile: string,
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof logsDownload>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getLogsDownloadSuspenseInfiniteQueryOptions(
    logFile,
    options
  );

  const query = useSuspenseInfiniteQuery(
    queryOptions,
    queryClient
  ) as UseSuspenseInfiniteQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Performs pattern matching across multiple log files in parallel,
providing consolidated search results with performance metrics
and per-file result breakdowns.
 * @summary Search across multiple log files simultaneously
 */
export const logsSearchAll = (
  params: LogsSearchAllParams,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal
) => {
  return customInstance<LogsSearchAll200>(
    { url: `/api/logs/search/all`, method: "GET", params, signal },
    options
  );
};

export const getLogsSearchAllQueryKey = (params?: LogsSearchAllParams) => {
  return [`/api/logs/search/all`, ...(params ? [params] : [])] as const;
};

export const getLogsSearchAllInfiniteQueryOptions = <
  TData = InfiniteData<
    Awaited<ReturnType<typeof logsSearchAll>>,
    LogsSearchAllParams["page"]
  >,
  TError = ErrorType<
    AuthenticationExceptionResponse | ValidationExceptionResponse
  >
>(
  params: LogsSearchAllParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof logsSearchAll>>,
        TError,
        TData,
        QueryKey,
        LogsSearchAllParams["page"]
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getLogsSearchAllQueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof logsSearchAll>>,
    QueryKey,
    LogsSearchAllParams["page"]
  > = ({ signal, pageParam }) =>
    logsSearchAll(
      { ...params, page: pageParam || params?.["page"] },
      requestOptions,
      signal
    );

  return { queryKey, queryFn, ...queryOptions } as UseInfiniteQueryOptions<
    Awaited<ReturnType<typeof logsSearchAll>>,
    TError,
    TData,
    QueryKey,
    LogsSearchAllParams["page"]
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type LogsSearchAllInfiniteQueryResult = NonNullable<
  Awaited<ReturnType<typeof logsSearchAll>>
>;
export type LogsSearchAllInfiniteQueryError = ErrorType<
  AuthenticationExceptionResponse | ValidationExceptionResponse
>;

export function useLogsSearchAllInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof logsSearchAll>>,
    LogsSearchAllParams["page"]
  >,
  TError = ErrorType<
    AuthenticationExceptionResponse | ValidationExceptionResponse
  >
>(
  params: LogsSearchAllParams,
  options: {
    query: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof logsSearchAll>>,
        TError,
        TData,
        QueryKey,
        LogsSearchAllParams["page"]
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof logsSearchAll>>,
          TError,
          Awaited<ReturnType<typeof logsSearchAll>>,
          QueryKey
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): DefinedUseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useLogsSearchAllInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof logsSearchAll>>,
    LogsSearchAllParams["page"]
  >,
  TError = ErrorType<
    AuthenticationExceptionResponse | ValidationExceptionResponse
  >
>(
  params: LogsSearchAllParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof logsSearchAll>>,
        TError,
        TData,
        QueryKey,
        LogsSearchAllParams["page"]
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof logsSearchAll>>,
          TError,
          Awaited<ReturnType<typeof logsSearchAll>>,
          QueryKey
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useLogsSearchAllInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof logsSearchAll>>,
    LogsSearchAllParams["page"]
  >,
  TError = ErrorType<
    AuthenticationExceptionResponse | ValidationExceptionResponse
  >
>(
  params: LogsSearchAllParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof logsSearchAll>>,
        TError,
        TData,
        QueryKey,
        LogsSearchAllParams["page"]
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Search across multiple log files simultaneously
 */

export function useLogsSearchAllInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof logsSearchAll>>,
    LogsSearchAllParams["page"]
  >,
  TError = ErrorType<
    AuthenticationExceptionResponse | ValidationExceptionResponse
  >
>(
  params: LogsSearchAllParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof logsSearchAll>>,
        TError,
        TData,
        QueryKey,
        LogsSearchAllParams["page"]
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getLogsSearchAllInfiniteQueryOptions(params, options);

  const query = useInfiniteQuery(
    queryOptions,
    queryClient
  ) as UseInfiniteQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getLogsSearchAllQueryOptions = <
  TData = Awaited<ReturnType<typeof logsSearchAll>>,
  TError = ErrorType<
    AuthenticationExceptionResponse | ValidationExceptionResponse
  >
>(
  params: LogsSearchAllParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof logsSearchAll>>, TError, TData>
    >;
    request?: SecondParameter<typeof customInstance>;
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getLogsSearchAllQueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof logsSearchAll>>> = ({
    signal,
  }) => logsSearchAll(params, requestOptions, signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof logsSearchAll>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type LogsSearchAllQueryResult = NonNullable<
  Awaited<ReturnType<typeof logsSearchAll>>
>;
export type LogsSearchAllQueryError = ErrorType<
  AuthenticationExceptionResponse | ValidationExceptionResponse
>;

export function useLogsSearchAll<
  TData = Awaited<ReturnType<typeof logsSearchAll>>,
  TError = ErrorType<
    AuthenticationExceptionResponse | ValidationExceptionResponse
  >
>(
  params: LogsSearchAllParams,
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof logsSearchAll>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof logsSearchAll>>,
          TError,
          Awaited<ReturnType<typeof logsSearchAll>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useLogsSearchAll<
  TData = Awaited<ReturnType<typeof logsSearchAll>>,
  TError = ErrorType<
    AuthenticationExceptionResponse | ValidationExceptionResponse
  >
>(
  params: LogsSearchAllParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof logsSearchAll>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof logsSearchAll>>,
          TError,
          Awaited<ReturnType<typeof logsSearchAll>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useLogsSearchAll<
  TData = Awaited<ReturnType<typeof logsSearchAll>>,
  TError = ErrorType<
    AuthenticationExceptionResponse | ValidationExceptionResponse
  >
>(
  params: LogsSearchAllParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof logsSearchAll>>, TError, TData>
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Search across multiple log files simultaneously
 */

export function useLogsSearchAll<
  TData = Awaited<ReturnType<typeof logsSearchAll>>,
  TError = ErrorType<
    AuthenticationExceptionResponse | ValidationExceptionResponse
  >
>(
  params: LogsSearchAllParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof logsSearchAll>>, TError, TData>
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getLogsSearchAllQueryOptions(params, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getLogsSearchAllSuspenseQueryOptions = <
  TData = Awaited<ReturnType<typeof logsSearchAll>>,
  TError = ErrorType<
    AuthenticationExceptionResponse | ValidationExceptionResponse
  >
>(
  params: LogsSearchAllParams,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof logsSearchAll>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getLogsSearchAllQueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof logsSearchAll>>> = ({
    signal,
  }) => logsSearchAll(params, requestOptions, signal);

  return { queryKey, queryFn, ...queryOptions } as UseSuspenseQueryOptions<
    Awaited<ReturnType<typeof logsSearchAll>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type LogsSearchAllSuspenseQueryResult = NonNullable<
  Awaited<ReturnType<typeof logsSearchAll>>
>;
export type LogsSearchAllSuspenseQueryError = ErrorType<
  AuthenticationExceptionResponse | ValidationExceptionResponse
>;

export function useLogsSearchAllSuspense<
  TData = Awaited<ReturnType<typeof logsSearchAll>>,
  TError = ErrorType<
    AuthenticationExceptionResponse | ValidationExceptionResponse
  >
>(
  params: LogsSearchAllParams,
  options: {
    query: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof logsSearchAll>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useLogsSearchAllSuspense<
  TData = Awaited<ReturnType<typeof logsSearchAll>>,
  TError = ErrorType<
    AuthenticationExceptionResponse | ValidationExceptionResponse
  >
>(
  params: LogsSearchAllParams,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof logsSearchAll>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useLogsSearchAllSuspense<
  TData = Awaited<ReturnType<typeof logsSearchAll>>,
  TError = ErrorType<
    AuthenticationExceptionResponse | ValidationExceptionResponse
  >
>(
  params: LogsSearchAllParams,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof logsSearchAll>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Search across multiple log files simultaneously
 */

export function useLogsSearchAllSuspense<
  TData = Awaited<ReturnType<typeof logsSearchAll>>,
  TError = ErrorType<
    AuthenticationExceptionResponse | ValidationExceptionResponse
  >
>(
  params: LogsSearchAllParams,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof logsSearchAll>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getLogsSearchAllSuspenseQueryOptions(params, options);

  const query = useSuspenseQuery(
    queryOptions,
    queryClient
  ) as UseSuspenseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getLogsSearchAllSuspenseInfiniteQueryOptions = <
  TData = InfiniteData<
    Awaited<ReturnType<typeof logsSearchAll>>,
    LogsSearchAllParams["page"]
  >,
  TError = ErrorType<
    AuthenticationExceptionResponse | ValidationExceptionResponse
  >
>(
  params: LogsSearchAllParams,
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof logsSearchAll>>,
        TError,
        TData,
        QueryKey,
        LogsSearchAllParams["page"]
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getLogsSearchAllQueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof logsSearchAll>>,
    QueryKey,
    LogsSearchAllParams["page"]
  > = ({ signal, pageParam }) =>
    logsSearchAll(
      { ...params, page: pageParam || params?.["page"] },
      requestOptions,
      signal
    );

  return {
    queryKey,
    queryFn,
    ...queryOptions,
  } as UseSuspenseInfiniteQueryOptions<
    Awaited<ReturnType<typeof logsSearchAll>>,
    TError,
    TData,
    QueryKey,
    LogsSearchAllParams["page"]
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type LogsSearchAllSuspenseInfiniteQueryResult = NonNullable<
  Awaited<ReturnType<typeof logsSearchAll>>
>;
export type LogsSearchAllSuspenseInfiniteQueryError = ErrorType<
  AuthenticationExceptionResponse | ValidationExceptionResponse
>;

export function useLogsSearchAllSuspenseInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof logsSearchAll>>,
    LogsSearchAllParams["page"]
  >,
  TError = ErrorType<
    AuthenticationExceptionResponse | ValidationExceptionResponse
  >
>(
  params: LogsSearchAllParams,
  options: {
    query: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof logsSearchAll>>,
        TError,
        TData,
        QueryKey,
        LogsSearchAllParams["page"]
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useLogsSearchAllSuspenseInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof logsSearchAll>>,
    LogsSearchAllParams["page"]
  >,
  TError = ErrorType<
    AuthenticationExceptionResponse | ValidationExceptionResponse
  >
>(
  params: LogsSearchAllParams,
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof logsSearchAll>>,
        TError,
        TData,
        QueryKey,
        LogsSearchAllParams["page"]
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useLogsSearchAllSuspenseInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof logsSearchAll>>,
    LogsSearchAllParams["page"]
  >,
  TError = ErrorType<
    AuthenticationExceptionResponse | ValidationExceptionResponse
  >
>(
  params: LogsSearchAllParams,
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof logsSearchAll>>,
        TError,
        TData,
        QueryKey,
        LogsSearchAllParams["page"]
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Search across multiple log files simultaneously
 */

export function useLogsSearchAllSuspenseInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof logsSearchAll>>,
    LogsSearchAllParams["page"]
  >,
  TError = ErrorType<
    AuthenticationExceptionResponse | ValidationExceptionResponse
  >
>(
  params: LogsSearchAllParams,
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof logsSearchAll>>,
        TError,
        TData,
        QueryKey,
        LogsSearchAllParams["page"]
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getLogsSearchAllSuspenseInfiniteQueryOptions(
    params,
    options
  );

  const query = useSuspenseInfiniteQuery(
    queryOptions,
    queryClient
  ) as UseSuspenseInfiniteQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}
