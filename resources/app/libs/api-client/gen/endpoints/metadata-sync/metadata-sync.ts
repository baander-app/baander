/**
 * Generated by orval v7.17.2 üç∫
 * Do not edit manually.
 * B√•nder api docs
 * B√•nder.App is a sophisticated media server developed with the primary goal to deliver high performance and seamless experience for users.
Being built on top of Laravel framework and PostgreSQL for database, it leverages the power of robust backend technologies, providing high security, reliability, and scalability.

The main focus of B√•nder.App is efficient media management and delivery.
This application is designed to handle large amounts of media files while ensuring quick and efficient access.
Implemented queuing functionality through Redis offers efficient job management and load handling.
The media information is organized and easily searchable, ensuring users can always find what they are looking for quickly and easily.
 * OpenAPI spec version: 0.0.1
 */
import {
  useInfiniteQuery,
  useMutation,
  useQuery,
  useSuspenseInfiniteQuery,
  useSuspenseQuery,
} from "@tanstack/react-query";
import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseInfiniteQueryResult,
  DefinedUseQueryResult,
  InfiniteData,
  MutationFunction,
  QueryClient,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseInfiniteQueryOptions,
  UseInfiniteQueryResult,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult,
  UseSuspenseInfiniteQueryOptions,
  UseSuspenseInfiniteQueryResult,
  UseSuspenseQueryOptions,
  UseSuspenseQueryResult,
} from "@tanstack/react-query";

import type {
  AuthenticationExceptionResponse,
  MetadataStats200,
  MetadataSync200,
  MetadataSyncBody,
  MetadataValidate200,
  MetadataValidateBody,
  ValidationExceptionResponse,
} from "../../models";

import { customInstance } from "../../../axios-instance";
import type { ErrorType, BodyType } from "../../../axios-instance";

type SecondParameter<T extends (...args: never) => unknown> = Parameters<T>[1];

export const metadataSync = (
  metadataSyncBody: BodyType<MetadataSyncBody>,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal
) => {
  return customInstance<MetadataSync200>(
    {
      url: `/api/metadata/sync`,
      method: "POST",
      headers: { "Content-Type": "application/json" },
      data: metadataSyncBody,
      signal,
    },
    options
  );
};

export const getMetadataSyncMutationOptions = <
  TError = ErrorType<
    AuthenticationExceptionResponse | ValidationExceptionResponse
  >,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    MetadataSync200,
    TError,
    { data: BodyType<MetadataSyncBody> },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  MetadataSync200,
  TError,
  { data: BodyType<MetadataSyncBody> },
  TContext
> => {
  const mutationKey = ["metadataSync"];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    MetadataSync200,
    { data: BodyType<MetadataSyncBody> }
  > = (props) => {
    const { data } = props ?? {};

    return metadataSync(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type MetadataSyncMutationResult = NonNullable<
  MetadataSync200
>;
export type MetadataSyncMutationBody = BodyType<MetadataSyncBody>;
export type MetadataSyncMutationError = ErrorType<
  AuthenticationExceptionResponse | ValidationExceptionResponse
>;

export const useMetadataSync = <
  TError = ErrorType<
    AuthenticationExceptionResponse | ValidationExceptionResponse
  >,
  TContext = unknown
>(
  options?: {
    mutation?: UseMutationOptions<
      MetadataSync200,
      TError,
      { data: BodyType<MetadataSyncBody> },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseMutationResult<
  MetadataSync200,
  TError,
  { data: BodyType<MetadataSyncBody> },
  TContext
> => {
  const mutationOptions = getMetadataSyncMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
export const metadataStats = (
  libraryId: number,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal
) => {
  return customInstance<MetadataStats200>(
    { url: `/api/metadata/stats/${libraryId}`, method: "GET", signal },
    options
  );
};

export const getMetadataStatsInfiniteQueryKey = (libraryId?: number) => {
  return ["infinite", `/api/metadata/stats/${libraryId}`] as const;
};

export const getMetadataStatsQueryKey = (libraryId?: number) => {
  return [`/api/metadata/stats/${libraryId}`] as const;
};

export const getMetadataStatsInfiniteQueryOptions = <
  TData = InfiniteData<Awaited<ReturnType<typeof metadataStats>>>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(
  libraryId: number,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof metadataStats>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getMetadataStatsInfiniteQueryKey(libraryId);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof metadataStats>>> = ({
    signal,
  }) => metadataStats(libraryId, requestOptions, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!libraryId,
    ...queryOptions,
  } as UseInfiniteQueryOptions<
    Awaited<ReturnType<typeof metadataStats>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type MetadataStatsInfiniteQueryResult = NonNullable<
  Awaited<ReturnType<typeof metadataStats>>
>;
export type MetadataStatsInfiniteQueryError =
  ErrorType<AuthenticationExceptionResponse>;

export function useMetadataStatsInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof metadataStats>>>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(
  libraryId: number,
  options: {
    query: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof metadataStats>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof metadataStats>>,
          TError,
          Awaited<ReturnType<typeof metadataStats>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): DefinedUseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useMetadataStatsInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof metadataStats>>>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(
  libraryId: number,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof metadataStats>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof metadataStats>>,
          TError,
          Awaited<ReturnType<typeof metadataStats>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useMetadataStatsInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof metadataStats>>>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(
  libraryId: number,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof metadataStats>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};

export function useMetadataStatsInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof metadataStats>>>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(
  libraryId: number,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof metadataStats>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getMetadataStatsInfiniteQueryOptions(libraryId, options);

  const query = useInfiniteQuery(
    queryOptions,
    queryClient
  ) as UseInfiniteQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getMetadataStatsQueryOptions = <
  TData = Awaited<ReturnType<typeof metadataStats>>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(
  libraryId: number,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof metadataStats>>, TError, TData>
    >;
    request?: SecondParameter<typeof customInstance>;
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getMetadataStatsQueryKey(libraryId);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof metadataStats>>> = ({
    signal,
  }) => metadataStats(libraryId, requestOptions, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!libraryId,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof metadataStats>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type MetadataStatsQueryResult = NonNullable<
  Awaited<ReturnType<typeof metadataStats>>
>;
export type MetadataStatsQueryError =
  ErrorType<AuthenticationExceptionResponse>;

export function useMetadataStats<
  TData = Awaited<ReturnType<typeof metadataStats>>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(
  libraryId: number,
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof metadataStats>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof metadataStats>>,
          TError,
          Awaited<ReturnType<typeof metadataStats>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useMetadataStats<
  TData = Awaited<ReturnType<typeof metadataStats>>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(
  libraryId: number,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof metadataStats>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof metadataStats>>,
          TError,
          Awaited<ReturnType<typeof metadataStats>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useMetadataStats<
  TData = Awaited<ReturnType<typeof metadataStats>>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(
  libraryId: number,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof metadataStats>>, TError, TData>
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};

export function useMetadataStats<
  TData = Awaited<ReturnType<typeof metadataStats>>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(
  libraryId: number,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof metadataStats>>, TError, TData>
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getMetadataStatsQueryOptions(libraryId, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getMetadataStatsSuspenseQueryOptions = <
  TData = Awaited<ReturnType<typeof metadataStats>>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(
  libraryId: number,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof metadataStats>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getMetadataStatsQueryKey(libraryId);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof metadataStats>>> = ({
    signal,
  }) => metadataStats(libraryId, requestOptions, signal);

  return { queryKey, queryFn, ...queryOptions } as UseSuspenseQueryOptions<
    Awaited<ReturnType<typeof metadataStats>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type MetadataStatsSuspenseQueryResult = NonNullable<
  Awaited<ReturnType<typeof metadataStats>>
>;
export type MetadataStatsSuspenseQueryError =
  ErrorType<AuthenticationExceptionResponse>;

export function useMetadataStatsSuspense<
  TData = Awaited<ReturnType<typeof metadataStats>>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(
  libraryId: number,
  options: {
    query: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof metadataStats>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useMetadataStatsSuspense<
  TData = Awaited<ReturnType<typeof metadataStats>>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(
  libraryId: number,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof metadataStats>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useMetadataStatsSuspense<
  TData = Awaited<ReturnType<typeof metadataStats>>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(
  libraryId: number,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof metadataStats>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};

export function useMetadataStatsSuspense<
  TData = Awaited<ReturnType<typeof metadataStats>>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(
  libraryId: number,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof metadataStats>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getMetadataStatsSuspenseQueryOptions(libraryId, options);

  const query = useSuspenseQuery(
    queryOptions,
    queryClient
  ) as UseSuspenseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getMetadataStatsSuspenseInfiniteQueryOptions = <
  TData = InfiniteData<Awaited<ReturnType<typeof metadataStats>>>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(
  libraryId: number,
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof metadataStats>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getMetadataStatsInfiniteQueryKey(libraryId);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof metadataStats>>> = ({
    signal,
  }) => metadataStats(libraryId, requestOptions, signal);

  return {
    queryKey,
    queryFn,
    ...queryOptions,
  } as UseSuspenseInfiniteQueryOptions<
    Awaited<ReturnType<typeof metadataStats>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type MetadataStatsSuspenseInfiniteQueryResult = NonNullable<
  Awaited<ReturnType<typeof metadataStats>>
>;
export type MetadataStatsSuspenseInfiniteQueryError =
  ErrorType<AuthenticationExceptionResponse>;

export function useMetadataStatsSuspenseInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof metadataStats>>>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(
  libraryId: number,
  options: {
    query: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof metadataStats>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useMetadataStatsSuspenseInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof metadataStats>>>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(
  libraryId: number,
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof metadataStats>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useMetadataStatsSuspenseInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof metadataStats>>>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(
  libraryId: number,
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof metadataStats>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};

export function useMetadataStatsSuspenseInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof metadataStats>>>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(
  libraryId: number,
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof metadataStats>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getMetadataStatsSuspenseInfiniteQueryOptions(
    libraryId,
    options
  );

  const query = useSuspenseInfiniteQuery(
    queryOptions,
    queryClient
  ) as UseSuspenseInfiniteQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const metadataValidate = (
  metadataValidateBody: BodyType<MetadataValidateBody>,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal
) => {
  return customInstance<MetadataValidate200>(
    {
      url: `/api/metadata/validate`,
      method: "POST",
      headers: { "Content-Type": "application/json" },
      data: metadataValidateBody,
      signal,
    },
    options
  );
};

export const getMetadataValidateMutationOptions = <
  TError = ErrorType<
    AuthenticationExceptionResponse | ValidationExceptionResponse
  >,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof metadataValidate>>,
    TError,
    { data: BodyType<MetadataValidateBody> },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof metadataValidate>>,
  TError,
  { data: BodyType<MetadataValidateBody> },
  TContext
> => {
  const mutationKey = ["metadataValidate"];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof metadataValidate>>,
    { data: BodyType<MetadataValidateBody> }
  > = (props) => {
    const { data } = props ?? {};

    return metadataValidate(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type MetadataValidateMutationResult = NonNullable<
  Awaited<ReturnType<typeof metadataValidate>>
>;
export type MetadataValidateMutationBody = BodyType<MetadataValidateBody>;
export type MetadataValidateMutationError = ErrorType<
  AuthenticationExceptionResponse | ValidationExceptionResponse
>;

export const useMetadataValidate = <
  TError = ErrorType<
    AuthenticationExceptionResponse | ValidationExceptionResponse
  >,
  TContext = unknown
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof metadataValidate>>,
      TError,
      { data: BodyType<MetadataValidateBody> },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof metadataValidate>>,
  TError,
  { data: BodyType<MetadataValidateBody> },
  TContext
> => {
  const mutationOptions = getMetadataValidateMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
