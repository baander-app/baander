/**
 * Generated by orval v7.11.2 üç∫
 * Do not edit manually.
 * B√•nder api docs
 * B√•nder.App is a sophisticated media server developed with the primary goal to deliver high performance and seamless experience for users.
Being built on top of Laravel framework and PostgreSQL for database, it leverages the power of robust backend technologies, providing high security, reliability, and scalability.

The main focus of B√•nder.App is efficient media management and delivery.
This application is designed to handle large amounts of media files while ensuring quick and efficient access.
Implemented queuing functionality through Redis offers efficient job management and load handling.
The media information is organized and easily searchable, ensuring users can always find what they are looking for quickly and easily.
 * OpenAPI spec version: 0.0.1
 */
import {
  useInfiniteQuery,
  useMutation,
  useQuery,
  useSuspenseInfiniteQuery,
  useSuspenseQuery,
} from "@tanstack/react-query";
import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseInfiniteQueryResult,
  DefinedUseQueryResult,
  InfiniteData,
  MutationFunction,
  QueryClient,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseInfiniteQueryOptions,
  UseInfiniteQueryResult,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult,
  UseSuspenseInfiniteQueryOptions,
  UseSuspenseInfiniteQueryResult,
  UseSuspenseQueryOptions,
  UseSuspenseQueryResult,
} from "@tanstack/react-query";

import type {
  AuthForgotPassword200,
  AuthLogin200,
  AuthLogin401,
  AuthPasskeyLogin200,
  AuthPasskeyLogin401,
  AuthPasskeyOptions200,
  AuthPasskeyRegister200,
  AuthPasskeyRegister500,
  AuthPasskeyRegisterOption200,
  AuthRefreshToken200,
  AuthRegister200,
  AuthResetPassword200,
  AuthResetPassword400,
  AuthStreamToken200,
  AuthTokensRevoke200,
  AuthTokensRevoke400,
  AuthTokensRevokeAll200,
  AuthenticateUsingPasskeyRequest,
  AuthenticationExceptionResponse,
  ForgotPasswordRequest,
  LoginRequest,
  LogoutRequest,
  ModelNotFoundExceptionResponse,
  RegisterRequest,
  ResetPasswordRequest,
  StorePasskeyRequest,
  UserResource,
  ValidationExceptionResponse,
} from "../../models";

import { customInstance } from "../../../axios-instance";
import type { ErrorType, BodyType } from "../../../axios-instance";

type SecondParameter<T extends (...args: never) => unknown> = Parameters<T>[1];

/**
 * @summary Login
 */
export const authLogin = (
  loginRequest: BodyType<LoginRequest>,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal
) => {
  return customInstance<AuthLogin200>(
    {
      url: `/api/auth/login`,
      method: "POST",
      headers: { "Content-Type": "application/json" },
      data: loginRequest,
      signal,
    },
    options
  );
};

export const getAuthLoginMutationOptions = <
  TError = ErrorType<AuthLogin401 | ValidationExceptionResponse>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof authLogin>>,
    TError,
    { data: BodyType<LoginRequest> },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof authLogin>>,
  TError,
  { data: BodyType<LoginRequest> },
  TContext
> => {
  const mutationKey = ["authLogin"];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof authLogin>>,
    { data: BodyType<LoginRequest> }
  > = (props) => {
    const { data } = props ?? {};

    return authLogin(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type AuthLoginMutationResult = NonNullable<
  Awaited<ReturnType<typeof authLogin>>
>;
export type AuthLoginMutationBody = BodyType<LoginRequest>;
export type AuthLoginMutationError = ErrorType<
  AuthLogin401 | ValidationExceptionResponse
>;

/**
 * @summary Login
 */
export const useAuthLogin = <
  TError = ErrorType<AuthLogin401 | ValidationExceptionResponse>,
  TContext = unknown
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof authLogin>>,
      TError,
      { data: BodyType<LoginRequest> },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof authLogin>>,
  TError,
  { data: BodyType<LoginRequest> },
  TContext
> => {
  const mutationOptions = getAuthLoginMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
/**
 * Needs refresh token with ability "issue-access-token"
 * @summary Refresh token
 */
export const authRefreshToken = (
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal
) => {
  return customInstance<AuthRefreshToken200>(
    { url: `/api/auth/refreshToken`, method: "POST", signal },
    options
  );
};

export const getAuthRefreshTokenMutationOptions = <
  TError = ErrorType<AuthenticationExceptionResponse>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof authRefreshToken>>,
    TError,
    void,
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof authRefreshToken>>,
  TError,
  void,
  TContext
> => {
  const mutationKey = ["authRefreshToken"];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof authRefreshToken>>,
    void
  > = () => {
    return authRefreshToken(requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type AuthRefreshTokenMutationResult = NonNullable<
  Awaited<ReturnType<typeof authRefreshToken>>
>;

export type AuthRefreshTokenMutationError =
  ErrorType<AuthenticationExceptionResponse>;

/**
 * @summary Refresh token
 */
export const useAuthRefreshToken = <
  TError = ErrorType<AuthenticationExceptionResponse>,
  TContext = unknown
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof authRefreshToken>>,
      TError,
      void,
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof authRefreshToken>>,
  TError,
  void,
  TContext
> => {
  const mutationOptions = getAuthRefreshTokenMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
/**
 * Needs refresh token with ability "issue-access-token"
 * @summary Get a stream token
 */
export const authStreamToken = (
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal
) => {
  return customInstance<AuthStreamToken200>(
    { url: `/api/auth/streamToken`, method: "POST", signal },
    options
  );
};

export const getAuthStreamTokenMutationOptions = <
  TError = ErrorType<AuthenticationExceptionResponse>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof authStreamToken>>,
    TError,
    void,
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof authStreamToken>>,
  TError,
  void,
  TContext
> => {
  const mutationKey = ["authStreamToken"];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof authStreamToken>>,
    void
  > = () => {
    return authStreamToken(requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type AuthStreamTokenMutationResult = NonNullable<
  Awaited<ReturnType<typeof authStreamToken>>
>;

export type AuthStreamTokenMutationError =
  ErrorType<AuthenticationExceptionResponse>;

/**
 * @summary Get a stream token
 */
export const useAuthStreamToken = <
  TError = ErrorType<AuthenticationExceptionResponse>,
  TContext = unknown
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof authStreamToken>>,
      TError,
      void,
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof authStreamToken>>,
  TError,
  void,
  TContext
> => {
  const mutationOptions = getAuthStreamTokenMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
/**
 * @summary Register
 */
export const authRegister = (
  registerRequest: BodyType<RegisterRequest>,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal
) => {
  return customInstance<AuthRegister200>(
    {
      url: `/api/auth/register`,
      method: "POST",
      headers: { "Content-Type": "application/json" },
      data: registerRequest,
      signal,
    },
    options
  );
};

export const getAuthRegisterMutationOptions = <
  TError = ErrorType<ValidationExceptionResponse>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof authRegister>>,
    TError,
    { data: BodyType<RegisterRequest> },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof authRegister>>,
  TError,
  { data: BodyType<RegisterRequest> },
  TContext
> => {
  const mutationKey = ["authRegister"];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof authRegister>>,
    { data: BodyType<RegisterRequest> }
  > = (props) => {
    const { data } = props ?? {};

    return authRegister(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type AuthRegisterMutationResult = NonNullable<
  Awaited<ReturnType<typeof authRegister>>
>;
export type AuthRegisterMutationBody = BodyType<RegisterRequest>;
export type AuthRegisterMutationError = ErrorType<ValidationExceptionResponse>;

/**
 * @summary Register
 */
export const useAuthRegister = <
  TError = ErrorType<ValidationExceptionResponse>,
  TContext = unknown
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof authRegister>>,
      TError,
      { data: BodyType<RegisterRequest> },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof authRegister>>,
  TError,
  { data: BodyType<RegisterRequest> },
  TContext
> => {
  const mutationOptions = getAuthRegisterMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
/**
 * Returns information about all active tokens including IP history
 * @summary Get user's active tokens/sessions
 */
export const authTokens = (
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal
) => {
  return customInstance<string>(
    { url: `/api/auth/tokens`, method: "GET", signal },
    options
  );
};

export const getAuthTokensQueryKey = () => {
  return [`/api/auth/tokens`] as const;
};

export const getAuthTokensInfiniteQueryOptions = <
  TData = InfiniteData<Awaited<ReturnType<typeof authTokens>>>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(options?: {
  query?: Partial<
    UseInfiniteQueryOptions<
      Awaited<ReturnType<typeof authTokens>>,
      TError,
      TData
    >
  >;
  request?: SecondParameter<typeof customInstance>;
}) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getAuthTokensQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof authTokens>>> = ({
    signal,
  }) => authTokens(requestOptions, signal);

  return { queryKey, queryFn, ...queryOptions } as UseInfiniteQueryOptions<
    Awaited<ReturnType<typeof authTokens>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type AuthTokensInfiniteQueryResult = NonNullable<
  Awaited<ReturnType<typeof authTokens>>
>;
export type AuthTokensInfiniteQueryError =
  ErrorType<AuthenticationExceptionResponse>;

export function useAuthTokensInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof authTokens>>>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(
  options: {
    query: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof authTokens>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof authTokens>>,
          TError,
          Awaited<ReturnType<typeof authTokens>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): DefinedUseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useAuthTokensInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof authTokens>>>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof authTokens>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof authTokens>>,
          TError,
          Awaited<ReturnType<typeof authTokens>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useAuthTokensInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof authTokens>>>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof authTokens>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get user's active tokens/sessions
 */

export function useAuthTokensInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof authTokens>>>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof authTokens>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getAuthTokensInfiniteQueryOptions(options);

  const query = useInfiniteQuery(
    queryOptions,
    queryClient
  ) as UseInfiniteQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getAuthTokensQueryOptions = <
  TData = Awaited<ReturnType<typeof authTokens>>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof authTokens>>, TError, TData>
  >;
  request?: SecondParameter<typeof customInstance>;
}) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getAuthTokensQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof authTokens>>> = ({
    signal,
  }) => authTokens(requestOptions, signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof authTokens>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type AuthTokensQueryResult = NonNullable<
  Awaited<ReturnType<typeof authTokens>>
>;
export type AuthTokensQueryError = ErrorType<AuthenticationExceptionResponse>;

export function useAuthTokens<
  TData = Awaited<ReturnType<typeof authTokens>>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof authTokens>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof authTokens>>,
          TError,
          Awaited<ReturnType<typeof authTokens>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useAuthTokens<
  TData = Awaited<ReturnType<typeof authTokens>>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof authTokens>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof authTokens>>,
          TError,
          Awaited<ReturnType<typeof authTokens>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useAuthTokens<
  TData = Awaited<ReturnType<typeof authTokens>>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof authTokens>>, TError, TData>
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get user's active tokens/sessions
 */

export function useAuthTokens<
  TData = Awaited<ReturnType<typeof authTokens>>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof authTokens>>, TError, TData>
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getAuthTokensQueryOptions(options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getAuthTokensSuspenseQueryOptions = <
  TData = Awaited<ReturnType<typeof authTokens>>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(options?: {
  query?: Partial<
    UseSuspenseQueryOptions<
      Awaited<ReturnType<typeof authTokens>>,
      TError,
      TData
    >
  >;
  request?: SecondParameter<typeof customInstance>;
}) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getAuthTokensQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof authTokens>>> = ({
    signal,
  }) => authTokens(requestOptions, signal);

  return { queryKey, queryFn, ...queryOptions } as UseSuspenseQueryOptions<
    Awaited<ReturnType<typeof authTokens>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type AuthTokensSuspenseQueryResult = NonNullable<
  Awaited<ReturnType<typeof authTokens>>
>;
export type AuthTokensSuspenseQueryError =
  ErrorType<AuthenticationExceptionResponse>;

export function useAuthTokensSuspense<
  TData = Awaited<ReturnType<typeof authTokens>>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(
  options: {
    query: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof authTokens>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useAuthTokensSuspense<
  TData = Awaited<ReturnType<typeof authTokens>>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof authTokens>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useAuthTokensSuspense<
  TData = Awaited<ReturnType<typeof authTokens>>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof authTokens>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get user's active tokens/sessions
 */

export function useAuthTokensSuspense<
  TData = Awaited<ReturnType<typeof authTokens>>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof authTokens>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getAuthTokensSuspenseQueryOptions(options);

  const query = useSuspenseQuery(
    queryOptions,
    queryClient
  ) as UseSuspenseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getAuthTokensSuspenseInfiniteQueryOptions = <
  TData = InfiniteData<Awaited<ReturnType<typeof authTokens>>>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(options?: {
  query?: Partial<
    UseSuspenseInfiniteQueryOptions<
      Awaited<ReturnType<typeof authTokens>>,
      TError,
      TData
    >
  >;
  request?: SecondParameter<typeof customInstance>;
}) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getAuthTokensQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof authTokens>>> = ({
    signal,
  }) => authTokens(requestOptions, signal);

  return {
    queryKey,
    queryFn,
    ...queryOptions,
  } as UseSuspenseInfiniteQueryOptions<
    Awaited<ReturnType<typeof authTokens>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type AuthTokensSuspenseInfiniteQueryResult = NonNullable<
  Awaited<ReturnType<typeof authTokens>>
>;
export type AuthTokensSuspenseInfiniteQueryError =
  ErrorType<AuthenticationExceptionResponse>;

export function useAuthTokensSuspenseInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof authTokens>>>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(
  options: {
    query: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof authTokens>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useAuthTokensSuspenseInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof authTokens>>>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof authTokens>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useAuthTokensSuspenseInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof authTokens>>>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof authTokens>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get user's active tokens/sessions
 */

export function useAuthTokensSuspenseInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof authTokens>>>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof authTokens>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getAuthTokensSuspenseInfiniteQueryOptions(options);

  const query = useSuspenseInfiniteQuery(
    queryOptions,
    queryClient
  ) as UseSuspenseInfiniteQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Revoke all tokens except current
 */
export const authTokensRevokeAll = (
  options?: SecondParameter<typeof customInstance>
) => {
  return customInstance<AuthTokensRevokeAll200>(
    { url: `/api/auth/tokens`, method: "DELETE" },
    options
  );
};

export const getAuthTokensRevokeAllMutationOptions = <
  TError = ErrorType<AuthenticationExceptionResponse>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof authTokensRevokeAll>>,
    TError,
    void,
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof authTokensRevokeAll>>,
  TError,
  void,
  TContext
> => {
  const mutationKey = ["authTokensRevokeAll"];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof authTokensRevokeAll>>,
    void
  > = () => {
    return authTokensRevokeAll(requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type AuthTokensRevokeAllMutationResult = NonNullable<
  Awaited<ReturnType<typeof authTokensRevokeAll>>
>;

export type AuthTokensRevokeAllMutationError =
  ErrorType<AuthenticationExceptionResponse>;

/**
 * @summary Revoke all tokens except current
 */
export const useAuthTokensRevokeAll = <
  TError = ErrorType<AuthenticationExceptionResponse>,
  TContext = unknown
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof authTokensRevokeAll>>,
      TError,
      void,
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof authTokensRevokeAll>>,
  TError,
  void,
  TContext
> => {
  const mutationOptions = getAuthTokensRevokeAllMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
/**
 * @summary Revoke a specific token
 */
export const authTokensRevoke = (
  tokenId: string,
  options?: SecondParameter<typeof customInstance>
) => {
  return customInstance<AuthTokensRevoke200>(
    { url: `/api/auth/tokens/${tokenId}`, method: "DELETE" },
    options
  );
};

export const getAuthTokensRevokeMutationOptions = <
  TError = ErrorType<AuthTokensRevoke400 | AuthenticationExceptionResponse>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof authTokensRevoke>>,
    TError,
    { tokenId: string },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof authTokensRevoke>>,
  TError,
  { tokenId: string },
  TContext
> => {
  const mutationKey = ["authTokensRevoke"];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof authTokensRevoke>>,
    { tokenId: string }
  > = (props) => {
    const { tokenId } = props ?? {};

    return authTokensRevoke(tokenId, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type AuthTokensRevokeMutationResult = NonNullable<
  Awaited<ReturnType<typeof authTokensRevoke>>
>;

export type AuthTokensRevokeMutationError = ErrorType<
  AuthTokensRevoke400 | AuthenticationExceptionResponse
>;

/**
 * @summary Revoke a specific token
 */
export const useAuthTokensRevoke = <
  TError = ErrorType<AuthTokensRevoke400 | AuthenticationExceptionResponse>,
  TContext = unknown
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof authTokensRevoke>>,
      TError,
      { tokenId: string },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof authTokensRevoke>>,
  TError,
  { tokenId: string },
  TContext
> => {
  const mutationOptions = getAuthTokensRevokeMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
/**
 * @summary Request reset password link
 */
export const authForgotPassword = (
  forgotPasswordRequest: BodyType<ForgotPasswordRequest>,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal
) => {
  return customInstance<AuthForgotPassword200>(
    {
      url: `/api/auth/forgotPassword`,
      method: "POST",
      headers: { "Content-Type": "application/json" },
      data: forgotPasswordRequest,
      signal,
    },
    options
  );
};

export const getAuthForgotPasswordMutationOptions = <
  TError = ErrorType<ValidationExceptionResponse>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof authForgotPassword>>,
    TError,
    { data: BodyType<ForgotPasswordRequest> },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof authForgotPassword>>,
  TError,
  { data: BodyType<ForgotPasswordRequest> },
  TContext
> => {
  const mutationKey = ["authForgotPassword"];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof authForgotPassword>>,
    { data: BodyType<ForgotPasswordRequest> }
  > = (props) => {
    const { data } = props ?? {};

    return authForgotPassword(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type AuthForgotPasswordMutationResult = NonNullable<
  Awaited<ReturnType<typeof authForgotPassword>>
>;
export type AuthForgotPasswordMutationBody = BodyType<ForgotPasswordRequest>;
export type AuthForgotPasswordMutationError =
  ErrorType<ValidationExceptionResponse>;

/**
 * @summary Request reset password link
 */
export const useAuthForgotPassword = <
  TError = ErrorType<ValidationExceptionResponse>,
  TContext = unknown
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof authForgotPassword>>,
      TError,
      { data: BodyType<ForgotPasswordRequest> },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof authForgotPassword>>,
  TError,
  { data: BodyType<ForgotPasswordRequest> },
  TContext
> => {
  const mutationOptions = getAuthForgotPasswordMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
/**
 * @summary Reset password
 */
export const authResetPassword = (
  resetPasswordRequest: BodyType<ResetPasswordRequest>,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal
) => {
  return customInstance<AuthResetPassword200>(
    {
      url: `/api/auth/resetPassword`,
      method: "POST",
      headers: { "Content-Type": "application/json" },
      data: resetPasswordRequest,
      signal,
    },
    options
  );
};

export const getAuthResetPasswordMutationOptions = <
  TError = ErrorType<AuthResetPassword400 | ValidationExceptionResponse>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof authResetPassword>>,
    TError,
    { data: BodyType<ResetPasswordRequest> },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof authResetPassword>>,
  TError,
  { data: BodyType<ResetPasswordRequest> },
  TContext
> => {
  const mutationKey = ["authResetPassword"];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof authResetPassword>>,
    { data: BodyType<ResetPasswordRequest> }
  > = (props) => {
    const { data } = props ?? {};

    return authResetPassword(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type AuthResetPasswordMutationResult = NonNullable<
  Awaited<ReturnType<typeof authResetPassword>>
>;
export type AuthResetPasswordMutationBody = BodyType<ResetPasswordRequest>;
export type AuthResetPasswordMutationError = ErrorType<
  AuthResetPassword400 | ValidationExceptionResponse
>;

/**
 * @summary Reset password
 */
export const useAuthResetPassword = <
  TError = ErrorType<AuthResetPassword400 | ValidationExceptionResponse>,
  TContext = unknown
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof authResetPassword>>,
      TError,
      { data: BodyType<ResetPasswordRequest> },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof authResetPassword>>,
  TError,
  { data: BodyType<ResetPasswordRequest> },
  TContext
> => {
  const mutationOptions = getAuthResetPasswordMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
/**
 * @summary Verify email
 */
export const authVerifyEmail = (
  id: number,
  hash: string,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal
) => {
  return customInstance<UserResource>(
    { url: `/api/auth/verify/${id}/${hash}`, method: "POST", signal },
    options
  );
};

export const getAuthVerifyEmailMutationOptions = <
  TError = ErrorType<ModelNotFoundExceptionResponse>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof authVerifyEmail>>,
    TError,
    { id: number; hash: string },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof authVerifyEmail>>,
  TError,
  { id: number; hash: string },
  TContext
> => {
  const mutationKey = ["authVerifyEmail"];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof authVerifyEmail>>,
    { id: number; hash: string }
  > = (props) => {
    const { id, hash } = props ?? {};

    return authVerifyEmail(id, hash, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type AuthVerifyEmailMutationResult = NonNullable<
  Awaited<ReturnType<typeof authVerifyEmail>>
>;

export type AuthVerifyEmailMutationError =
  ErrorType<ModelNotFoundExceptionResponse>;

/**
 * @summary Verify email
 */
export const useAuthVerifyEmail = <
  TError = ErrorType<ModelNotFoundExceptionResponse>,
  TContext = unknown
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof authVerifyEmail>>,
      TError,
      { id: number; hash: string },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof authVerifyEmail>>,
  TError,
  { id: number; hash: string },
  TContext
> => {
  const mutationOptions = getAuthVerifyEmailMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
/**
 * Invalidates the current session
 * @summary Logout
 */
export const authLogout = (
  logoutRequest: BodyType<LogoutRequest>,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal
) => {
  return customInstance<null>(
    {
      url: `/api/auth/logout`,
      method: "POST",
      headers: { "Content-Type": "application/json" },
      data: logoutRequest,
      signal,
    },
    options
  );
};

export const getAuthLogoutMutationOptions = <
  TError = ErrorType<
    AuthenticationExceptionResponse | ValidationExceptionResponse
  >,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof authLogout>>,
    TError,
    { data: BodyType<LogoutRequest> },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof authLogout>>,
  TError,
  { data: BodyType<LogoutRequest> },
  TContext
> => {
  const mutationKey = ["authLogout"];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof authLogout>>,
    { data: BodyType<LogoutRequest> }
  > = (props) => {
    const { data } = props ?? {};

    return authLogout(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type AuthLogoutMutationResult = NonNullable<
  Awaited<ReturnType<typeof authLogout>>
>;
export type AuthLogoutMutationBody = BodyType<LogoutRequest>;
export type AuthLogoutMutationError = ErrorType<
  AuthenticationExceptionResponse | ValidationExceptionResponse
>;

/**
 * @summary Logout
 */
export const useAuthLogout = <
  TError = ErrorType<
    AuthenticationExceptionResponse | ValidationExceptionResponse
  >,
  TContext = unknown
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof authLogout>>,
      TError,
      { data: BodyType<LogoutRequest> },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof authLogout>>,
  TError,
  { data: BodyType<LogoutRequest> },
  TContext
> => {
  const mutationOptions = getAuthLogoutMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
/**
 * @summary Get a passkey challenge
 */
export const authPasskeyOptions = (
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal
) => {
  return customInstance<AuthPasskeyOptions200>(
    { url: `/webauthn/passkey`, method: "GET", signal },
    options
  );
};

export const getAuthPasskeyOptionsQueryKey = () => {
  return [`/webauthn/passkey`] as const;
};

export const getAuthPasskeyOptionsInfiniteQueryOptions = <
  TData = InfiniteData<Awaited<ReturnType<typeof authPasskeyOptions>>>,
  TError = ErrorType<unknown>
>(options?: {
  query?: Partial<
    UseInfiniteQueryOptions<
      Awaited<ReturnType<typeof authPasskeyOptions>>,
      TError,
      TData
    >
  >;
  request?: SecondParameter<typeof customInstance>;
}) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getAuthPasskeyOptionsQueryKey();

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof authPasskeyOptions>>
  > = ({ signal }) => authPasskeyOptions(requestOptions, signal);

  return { queryKey, queryFn, ...queryOptions } as UseInfiniteQueryOptions<
    Awaited<ReturnType<typeof authPasskeyOptions>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type AuthPasskeyOptionsInfiniteQueryResult = NonNullable<
  Awaited<ReturnType<typeof authPasskeyOptions>>
>;
export type AuthPasskeyOptionsInfiniteQueryError = ErrorType<unknown>;

export function useAuthPasskeyOptionsInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof authPasskeyOptions>>>,
  TError = ErrorType<unknown>
>(
  options: {
    query: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof authPasskeyOptions>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof authPasskeyOptions>>,
          TError,
          Awaited<ReturnType<typeof authPasskeyOptions>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): DefinedUseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useAuthPasskeyOptionsInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof authPasskeyOptions>>>,
  TError = ErrorType<unknown>
>(
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof authPasskeyOptions>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof authPasskeyOptions>>,
          TError,
          Awaited<ReturnType<typeof authPasskeyOptions>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useAuthPasskeyOptionsInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof authPasskeyOptions>>>,
  TError = ErrorType<unknown>
>(
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof authPasskeyOptions>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get a passkey challenge
 */

export function useAuthPasskeyOptionsInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof authPasskeyOptions>>>,
  TError = ErrorType<unknown>
>(
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof authPasskeyOptions>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getAuthPasskeyOptionsInfiniteQueryOptions(options);

  const query = useInfiniteQuery(
    queryOptions,
    queryClient
  ) as UseInfiniteQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getAuthPasskeyOptionsQueryOptions = <
  TData = Awaited<ReturnType<typeof authPasskeyOptions>>,
  TError = ErrorType<unknown>
>(options?: {
  query?: Partial<
    UseQueryOptions<
      Awaited<ReturnType<typeof authPasskeyOptions>>,
      TError,
      TData
    >
  >;
  request?: SecondParameter<typeof customInstance>;
}) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getAuthPasskeyOptionsQueryKey();

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof authPasskeyOptions>>
  > = ({ signal }) => authPasskeyOptions(requestOptions, signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof authPasskeyOptions>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type AuthPasskeyOptionsQueryResult = NonNullable<
  Awaited<ReturnType<typeof authPasskeyOptions>>
>;
export type AuthPasskeyOptionsQueryError = ErrorType<unknown>;

export function useAuthPasskeyOptions<
  TData = Awaited<ReturnType<typeof authPasskeyOptions>>,
  TError = ErrorType<unknown>
>(
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof authPasskeyOptions>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof authPasskeyOptions>>,
          TError,
          Awaited<ReturnType<typeof authPasskeyOptions>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useAuthPasskeyOptions<
  TData = Awaited<ReturnType<typeof authPasskeyOptions>>,
  TError = ErrorType<unknown>
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof authPasskeyOptions>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof authPasskeyOptions>>,
          TError,
          Awaited<ReturnType<typeof authPasskeyOptions>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useAuthPasskeyOptions<
  TData = Awaited<ReturnType<typeof authPasskeyOptions>>,
  TError = ErrorType<unknown>
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof authPasskeyOptions>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get a passkey challenge
 */

export function useAuthPasskeyOptions<
  TData = Awaited<ReturnType<typeof authPasskeyOptions>>,
  TError = ErrorType<unknown>
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof authPasskeyOptions>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getAuthPasskeyOptionsQueryOptions(options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getAuthPasskeyOptionsSuspenseQueryOptions = <
  TData = Awaited<ReturnType<typeof authPasskeyOptions>>,
  TError = ErrorType<unknown>
>(options?: {
  query?: Partial<
    UseSuspenseQueryOptions<
      Awaited<ReturnType<typeof authPasskeyOptions>>,
      TError,
      TData
    >
  >;
  request?: SecondParameter<typeof customInstance>;
}) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getAuthPasskeyOptionsQueryKey();

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof authPasskeyOptions>>
  > = ({ signal }) => authPasskeyOptions(requestOptions, signal);

  return { queryKey, queryFn, ...queryOptions } as UseSuspenseQueryOptions<
    Awaited<ReturnType<typeof authPasskeyOptions>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type AuthPasskeyOptionsSuspenseQueryResult = NonNullable<
  Awaited<ReturnType<typeof authPasskeyOptions>>
>;
export type AuthPasskeyOptionsSuspenseQueryError = ErrorType<unknown>;

export function useAuthPasskeyOptionsSuspense<
  TData = Awaited<ReturnType<typeof authPasskeyOptions>>,
  TError = ErrorType<unknown>
>(
  options: {
    query: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof authPasskeyOptions>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useAuthPasskeyOptionsSuspense<
  TData = Awaited<ReturnType<typeof authPasskeyOptions>>,
  TError = ErrorType<unknown>
>(
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof authPasskeyOptions>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useAuthPasskeyOptionsSuspense<
  TData = Awaited<ReturnType<typeof authPasskeyOptions>>,
  TError = ErrorType<unknown>
>(
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof authPasskeyOptions>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get a passkey challenge
 */

export function useAuthPasskeyOptionsSuspense<
  TData = Awaited<ReturnType<typeof authPasskeyOptions>>,
  TError = ErrorType<unknown>
>(
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof authPasskeyOptions>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getAuthPasskeyOptionsSuspenseQueryOptions(options);

  const query = useSuspenseQuery(
    queryOptions,
    queryClient
  ) as UseSuspenseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getAuthPasskeyOptionsSuspenseInfiniteQueryOptions = <
  TData = InfiniteData<Awaited<ReturnType<typeof authPasskeyOptions>>>,
  TError = ErrorType<unknown>
>(options?: {
  query?: Partial<
    UseSuspenseInfiniteQueryOptions<
      Awaited<ReturnType<typeof authPasskeyOptions>>,
      TError,
      TData
    >
  >;
  request?: SecondParameter<typeof customInstance>;
}) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getAuthPasskeyOptionsQueryKey();

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof authPasskeyOptions>>
  > = ({ signal }) => authPasskeyOptions(requestOptions, signal);

  return {
    queryKey,
    queryFn,
    ...queryOptions,
  } as UseSuspenseInfiniteQueryOptions<
    Awaited<ReturnType<typeof authPasskeyOptions>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type AuthPasskeyOptionsSuspenseInfiniteQueryResult = NonNullable<
  Awaited<ReturnType<typeof authPasskeyOptions>>
>;
export type AuthPasskeyOptionsSuspenseInfiniteQueryError = ErrorType<unknown>;

export function useAuthPasskeyOptionsSuspenseInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof authPasskeyOptions>>>,
  TError = ErrorType<unknown>
>(
  options: {
    query: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof authPasskeyOptions>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useAuthPasskeyOptionsSuspenseInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof authPasskeyOptions>>>,
  TError = ErrorType<unknown>
>(
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof authPasskeyOptions>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useAuthPasskeyOptionsSuspenseInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof authPasskeyOptions>>>,
  TError = ErrorType<unknown>
>(
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof authPasskeyOptions>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get a passkey challenge
 */

export function useAuthPasskeyOptionsSuspenseInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof authPasskeyOptions>>>,
  TError = ErrorType<unknown>
>(
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof authPasskeyOptions>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions =
    getAuthPasskeyOptionsSuspenseInfiniteQueryOptions(options);

  const query = useSuspenseInfiniteQuery(
    queryOptions,
    queryClient
  ) as UseSuspenseInfiniteQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Login with a passkey
 */
export const authPasskeyLogin = (
  authenticateUsingPasskeyRequest: BodyType<AuthenticateUsingPasskeyRequest>,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal
) => {
  return customInstance<AuthPasskeyLogin200>(
    {
      url: `/webauthn/passkey`,
      method: "POST",
      headers: { "Content-Type": "application/json" },
      data: authenticateUsingPasskeyRequest,
      signal,
    },
    options
  );
};

export const getAuthPasskeyLoginMutationOptions = <
  TError = ErrorType<AuthPasskeyLogin401 | ValidationExceptionResponse>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof authPasskeyLogin>>,
    TError,
    { data: BodyType<AuthenticateUsingPasskeyRequest> },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof authPasskeyLogin>>,
  TError,
  { data: BodyType<AuthenticateUsingPasskeyRequest> },
  TContext
> => {
  const mutationKey = ["authPasskeyLogin"];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof authPasskeyLogin>>,
    { data: BodyType<AuthenticateUsingPasskeyRequest> }
  > = (props) => {
    const { data } = props ?? {};

    return authPasskeyLogin(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type AuthPasskeyLoginMutationResult = NonNullable<
  Awaited<ReturnType<typeof authPasskeyLogin>>
>;
export type AuthPasskeyLoginMutationBody =
  BodyType<AuthenticateUsingPasskeyRequest>;
export type AuthPasskeyLoginMutationError = ErrorType<
  AuthPasskeyLogin401 | ValidationExceptionResponse
>;

/**
 * @summary Login with a passkey
 */
export const useAuthPasskeyLogin = <
  TError = ErrorType<AuthPasskeyLogin401 | ValidationExceptionResponse>,
  TContext = unknown
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof authPasskeyLogin>>,
      TError,
      { data: BodyType<AuthenticateUsingPasskeyRequest> },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof authPasskeyLogin>>,
  TError,
  { data: BodyType<AuthenticateUsingPasskeyRequest> },
  TContext
> => {
  const mutationOptions = getAuthPasskeyLoginMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
/**
 * @summary Get passkey registration options
 */
export const authPasskeyRegisterOption = (
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal
) => {
  return customInstance<AuthPasskeyRegisterOption200>(
    { url: `/webauthn/passkey/register`, method: "GET", signal },
    options
  );
};

export const getAuthPasskeyRegisterOptionQueryKey = () => {
  return [`/webauthn/passkey/register`] as const;
};

export const getAuthPasskeyRegisterOptionInfiniteQueryOptions = <
  TData = InfiniteData<Awaited<ReturnType<typeof authPasskeyRegisterOption>>>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(options?: {
  query?: Partial<
    UseInfiniteQueryOptions<
      Awaited<ReturnType<typeof authPasskeyRegisterOption>>,
      TError,
      TData
    >
  >;
  request?: SecondParameter<typeof customInstance>;
}) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getAuthPasskeyRegisterOptionQueryKey();

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof authPasskeyRegisterOption>>
  > = ({ signal }) => authPasskeyRegisterOption(requestOptions, signal);

  return { queryKey, queryFn, ...queryOptions } as UseInfiniteQueryOptions<
    Awaited<ReturnType<typeof authPasskeyRegisterOption>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type AuthPasskeyRegisterOptionInfiniteQueryResult = NonNullable<
  Awaited<ReturnType<typeof authPasskeyRegisterOption>>
>;
export type AuthPasskeyRegisterOptionInfiniteQueryError =
  ErrorType<AuthenticationExceptionResponse>;

export function useAuthPasskeyRegisterOptionInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof authPasskeyRegisterOption>>>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(
  options: {
    query: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof authPasskeyRegisterOption>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof authPasskeyRegisterOption>>,
          TError,
          Awaited<ReturnType<typeof authPasskeyRegisterOption>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): DefinedUseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useAuthPasskeyRegisterOptionInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof authPasskeyRegisterOption>>>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof authPasskeyRegisterOption>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof authPasskeyRegisterOption>>,
          TError,
          Awaited<ReturnType<typeof authPasskeyRegisterOption>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useAuthPasskeyRegisterOptionInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof authPasskeyRegisterOption>>>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof authPasskeyRegisterOption>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get passkey registration options
 */

export function useAuthPasskeyRegisterOptionInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof authPasskeyRegisterOption>>>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof authPasskeyRegisterOption>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions =
    getAuthPasskeyRegisterOptionInfiniteQueryOptions(options);

  const query = useInfiniteQuery(
    queryOptions,
    queryClient
  ) as UseInfiniteQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getAuthPasskeyRegisterOptionQueryOptions = <
  TData = Awaited<ReturnType<typeof authPasskeyRegisterOption>>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(options?: {
  query?: Partial<
    UseQueryOptions<
      Awaited<ReturnType<typeof authPasskeyRegisterOption>>,
      TError,
      TData
    >
  >;
  request?: SecondParameter<typeof customInstance>;
}) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getAuthPasskeyRegisterOptionQueryKey();

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof authPasskeyRegisterOption>>
  > = ({ signal }) => authPasskeyRegisterOption(requestOptions, signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof authPasskeyRegisterOption>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type AuthPasskeyRegisterOptionQueryResult = NonNullable<
  Awaited<ReturnType<typeof authPasskeyRegisterOption>>
>;
export type AuthPasskeyRegisterOptionQueryError =
  ErrorType<AuthenticationExceptionResponse>;

export function useAuthPasskeyRegisterOption<
  TData = Awaited<ReturnType<typeof authPasskeyRegisterOption>>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof authPasskeyRegisterOption>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof authPasskeyRegisterOption>>,
          TError,
          Awaited<ReturnType<typeof authPasskeyRegisterOption>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useAuthPasskeyRegisterOption<
  TData = Awaited<ReturnType<typeof authPasskeyRegisterOption>>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof authPasskeyRegisterOption>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof authPasskeyRegisterOption>>,
          TError,
          Awaited<ReturnType<typeof authPasskeyRegisterOption>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useAuthPasskeyRegisterOption<
  TData = Awaited<ReturnType<typeof authPasskeyRegisterOption>>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof authPasskeyRegisterOption>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get passkey registration options
 */

export function useAuthPasskeyRegisterOption<
  TData = Awaited<ReturnType<typeof authPasskeyRegisterOption>>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof authPasskeyRegisterOption>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getAuthPasskeyRegisterOptionQueryOptions(options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getAuthPasskeyRegisterOptionSuspenseQueryOptions = <
  TData = Awaited<ReturnType<typeof authPasskeyRegisterOption>>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(options?: {
  query?: Partial<
    UseSuspenseQueryOptions<
      Awaited<ReturnType<typeof authPasskeyRegisterOption>>,
      TError,
      TData
    >
  >;
  request?: SecondParameter<typeof customInstance>;
}) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getAuthPasskeyRegisterOptionQueryKey();

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof authPasskeyRegisterOption>>
  > = ({ signal }) => authPasskeyRegisterOption(requestOptions, signal);

  return { queryKey, queryFn, ...queryOptions } as UseSuspenseQueryOptions<
    Awaited<ReturnType<typeof authPasskeyRegisterOption>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type AuthPasskeyRegisterOptionSuspenseQueryResult = NonNullable<
  Awaited<ReturnType<typeof authPasskeyRegisterOption>>
>;
export type AuthPasskeyRegisterOptionSuspenseQueryError =
  ErrorType<AuthenticationExceptionResponse>;

export function useAuthPasskeyRegisterOptionSuspense<
  TData = Awaited<ReturnType<typeof authPasskeyRegisterOption>>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(
  options: {
    query: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof authPasskeyRegisterOption>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useAuthPasskeyRegisterOptionSuspense<
  TData = Awaited<ReturnType<typeof authPasskeyRegisterOption>>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof authPasskeyRegisterOption>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useAuthPasskeyRegisterOptionSuspense<
  TData = Awaited<ReturnType<typeof authPasskeyRegisterOption>>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof authPasskeyRegisterOption>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get passkey registration options
 */

export function useAuthPasskeyRegisterOptionSuspense<
  TData = Awaited<ReturnType<typeof authPasskeyRegisterOption>>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof authPasskeyRegisterOption>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions =
    getAuthPasskeyRegisterOptionSuspenseQueryOptions(options);

  const query = useSuspenseQuery(
    queryOptions,
    queryClient
  ) as UseSuspenseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getAuthPasskeyRegisterOptionSuspenseInfiniteQueryOptions = <
  TData = InfiniteData<Awaited<ReturnType<typeof authPasskeyRegisterOption>>>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(options?: {
  query?: Partial<
    UseSuspenseInfiniteQueryOptions<
      Awaited<ReturnType<typeof authPasskeyRegisterOption>>,
      TError,
      TData
    >
  >;
  request?: SecondParameter<typeof customInstance>;
}) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getAuthPasskeyRegisterOptionQueryKey();

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof authPasskeyRegisterOption>>
  > = ({ signal }) => authPasskeyRegisterOption(requestOptions, signal);

  return {
    queryKey,
    queryFn,
    ...queryOptions,
  } as UseSuspenseInfiniteQueryOptions<
    Awaited<ReturnType<typeof authPasskeyRegisterOption>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type AuthPasskeyRegisterOptionSuspenseInfiniteQueryResult = NonNullable<
  Awaited<ReturnType<typeof authPasskeyRegisterOption>>
>;
export type AuthPasskeyRegisterOptionSuspenseInfiniteQueryError =
  ErrorType<AuthenticationExceptionResponse>;

export function useAuthPasskeyRegisterOptionSuspenseInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof authPasskeyRegisterOption>>>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(
  options: {
    query: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof authPasskeyRegisterOption>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useAuthPasskeyRegisterOptionSuspenseInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof authPasskeyRegisterOption>>>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof authPasskeyRegisterOption>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useAuthPasskeyRegisterOptionSuspenseInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof authPasskeyRegisterOption>>>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof authPasskeyRegisterOption>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get passkey registration options
 */

export function useAuthPasskeyRegisterOptionSuspenseInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof authPasskeyRegisterOption>>>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof authPasskeyRegisterOption>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions =
    getAuthPasskeyRegisterOptionSuspenseInfiniteQueryOptions(options);

  const query = useSuspenseInfiniteQuery(
    queryOptions,
    queryClient
  ) as UseSuspenseInfiniteQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Register passkey
 */
export const authPasskeyRegister = (
  storePasskeyRequest: BodyType<StorePasskeyRequest>,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal
) => {
  return customInstance<AuthPasskeyRegister200>(
    {
      url: `/webauthn/passkey/register`,
      method: "POST",
      headers: { "Content-Type": "application/json" },
      data: storePasskeyRequest,
      signal,
    },
    options
  );
};

export const getAuthPasskeyRegisterMutationOptions = <
  TError = ErrorType<
    | AuthenticationExceptionResponse
    | ValidationExceptionResponse
    | AuthPasskeyRegister500
  >,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof authPasskeyRegister>>,
    TError,
    { data: BodyType<StorePasskeyRequest> },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof authPasskeyRegister>>,
  TError,
  { data: BodyType<StorePasskeyRequest> },
  TContext
> => {
  const mutationKey = ["authPasskeyRegister"];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof authPasskeyRegister>>,
    { data: BodyType<StorePasskeyRequest> }
  > = (props) => {
    const { data } = props ?? {};

    return authPasskeyRegister(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type AuthPasskeyRegisterMutationResult = NonNullable<
  Awaited<ReturnType<typeof authPasskeyRegister>>
>;
export type AuthPasskeyRegisterMutationBody = BodyType<StorePasskeyRequest>;
export type AuthPasskeyRegisterMutationError = ErrorType<
  | AuthenticationExceptionResponse
  | ValidationExceptionResponse
  | AuthPasskeyRegister500
>;

/**
 * @summary Register passkey
 */
export const useAuthPasskeyRegister = <
  TError = ErrorType<
    | AuthenticationExceptionResponse
    | ValidationExceptionResponse
    | AuthPasskeyRegister500
  >,
  TContext = unknown
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof authPasskeyRegister>>,
      TError,
      { data: BodyType<StorePasskeyRequest> },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof authPasskeyRegister>>,
  TError,
  { data: BodyType<StorePasskeyRequest> },
  TContext
> => {
  const mutationOptions = getAuthPasskeyRegisterMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
