/**
 * Generated by orval v7.17.2 üç∫
 * Do not edit manually.
 * B√•nder api docs
 * B√•nder.App is a sophisticated media server developed with the primary goal to deliver high performance and seamless experience for users.
Being built on top of Laravel framework and PostgreSQL for database, it leverages the power of robust backend technologies, providing high security, reliability, and scalability.

The main focus of B√•nder.App is efficient media management and delivery.
This application is designed to handle large amounts of media files while ensuring quick and efficient access.
Implemented queuing functionality through Redis offers efficient job management and load handling.
The media information is organized and easily searchable, ensuring users can always find what they are looking for quickly and easily.
 * OpenAPI spec version: 0.0.1
 */
import {
  useInfiniteQuery,
  useMutation,
  useQuery,
  useSuspenseInfiniteQuery,
  useSuspenseQuery,
} from "@tanstack/react-query";
import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseInfiniteQueryResult,
  DefinedUseQueryResult,
  InfiniteData,
  MutationFunction,
  QueryClient,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseInfiniteQueryOptions,
  UseInfiniteQueryResult,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult,
  UseSuspenseInfiniteQueryOptions,
  UseSuspenseInfiniteQueryResult,
  UseSuspenseQueryOptions,
  UseSuspenseQueryResult,
} from "@tanstack/react-query";

import type {
  AuthForgotPassword200,
  AuthLogin200,
  AuthPasskeyLogin200,
  AuthPasskeyOptions200,
  AuthPasskeyRegister200,
  AuthPasskeyRegisterOption200,
  AuthRefreshToken200,
  AuthRefreshToken400,
  AuthRefreshTokenBody,
  AuthRegister200,
  AuthResetPassword200,
  AuthResetPassword400,
  AuthTokens200Item,
  AuthTokensRevoke200,
  AuthTokensRevokeAll200,
  AuthVerifyEmail403,
  AuthenticateUsingPasskeyRequest,
  AuthenticationExceptionResponse,
  AuthorizationExceptionResponse,
  ForgotPasswordRequest,
  LoginRequest,
  LogoutRequest,
  ModelNotFoundExceptionResponse,
  OauthAuthorize200,
  OauthClientsDestroy200,
  OauthClientsIndex200Item,
  OauthClientsRegenerateSecret200,
  OauthClientsShow200,
  OauthClientsStore200,
  OauthClientsStoreBody,
  OauthClientsUpdate200,
  OauthClientsUpdateBody,
  OauthDeviceApprove200,
  OauthDeviceApproveBody,
  OauthDeviceAuthorize200,
  OauthDeviceAuthorizeBody,
  OauthDeviceVerify200,
  OauthDeviceVerifyParams,
  OauthIntrospect200,
  OauthIntrospectBody,
  OauthToken200,
  RegisterRequest,
  ResetPasswordRequest,
  StorePasskeyRequest,
  UserResource,
  ValidationExceptionResponse,
} from "../../models";

import { customInstance } from "../../../axios-instance";
import type { ErrorType, BodyType } from "../../../axios-instance";

type SecondParameter<T extends (...args: never) => unknown> = Parameters<T>[1];

/**
 * Authenticates a user with email and password, creates access and refresh tokens
with device binding and location tracking for security purposes.
 * @summary Authenticate user and create session
 */
export const authLogin = (
  loginRequest: BodyType<LoginRequest>,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal
) => {
  return customInstance<AuthLogin200>(
    {
      url: `/api/auth/login`,
      method: "POST",
      headers: { "Content-Type": "application/json" },
      data: loginRequest,
      signal,
    },
    options
  );
};

export const getAuthLoginMutationOptions = <
  TError = ErrorType<ValidationExceptionResponse>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    AuthLogin200,
    TError,
    { data: BodyType<LoginRequest> },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  AuthLogin200,
  TError,
  { data: BodyType<LoginRequest> },
  TContext
> => {
  const mutationKey = ["authLogin"];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    AuthLogin200,
    { data: BodyType<LoginRequest> }
  > = (props) => {
    const { data } = props ?? {};

    return authLogin(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type AuthLoginMutationResult = NonNullable<
  AuthLogin200
>;
export type AuthLoginMutationBody = BodyType<LoginRequest>;
export type AuthLoginMutationError = ErrorType<ValidationExceptionResponse>;

/**
 * @summary Authenticate user and create session
 */
export const useAuthLogin = <
  TError = ErrorType<ValidationExceptionResponse>,
  TContext = unknown
>(
  options?: {
    mutation?: UseMutationOptions<
      AuthLogin200,
      TError,
      { data: BodyType<LoginRequest> },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseMutationResult<
  AuthLogin200,
  TError,
  { data: BodyType<LoginRequest> },
  TContext
> => {
  const mutationOptions = getAuthLoginMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
/**
 * Creates a new access token using a valid refresh token.
 * @summary Refresh access token using refresh token
 */
export const authRefreshToken = (
  authRefreshTokenBody: BodyType<AuthRefreshTokenBody>,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal
) => {
  return customInstance<AuthRefreshToken200>(
    {
      url: `/api/auth/refreshToken`,
      method: "POST",
      headers: { "Content-Type": "application/json" },
      data: authRefreshTokenBody,
      signal,
    },
    options
  );
};

export const getAuthRefreshTokenMutationOptions = <
  TError = ErrorType<AuthRefreshToken400 | AuthenticationExceptionResponse>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof authRefreshToken>>,
    TError,
    { data: BodyType<AuthRefreshTokenBody> },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof authRefreshToken>>,
  TError,
  { data: BodyType<AuthRefreshTokenBody> },
  TContext
> => {
  const mutationKey = ["authRefreshToken"];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof authRefreshToken>>,
    { data: BodyType<AuthRefreshTokenBody> }
  > = (props) => {
    const { data } = props ?? {};

    return authRefreshToken(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type AuthRefreshTokenMutationResult = NonNullable<
  Awaited<ReturnType<typeof authRefreshToken>>
>;
export type AuthRefreshTokenMutationBody = BodyType<AuthRefreshTokenBody>;
export type AuthRefreshTokenMutationError = ErrorType<
  AuthRefreshToken400 | AuthenticationExceptionResponse
>;

/**
 * @summary Refresh access token using refresh token
 */
export const useAuthRefreshToken = <
  TError = ErrorType<AuthRefreshToken400 | AuthenticationExceptionResponse>,
  TContext = unknown
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof authRefreshToken>>,
      TError,
      { data: BodyType<AuthRefreshTokenBody> },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof authRefreshToken>>,
  TError,
  { data: BodyType<AuthRefreshTokenBody> },
  TContext
> => {
  const mutationOptions = getAuthRefreshTokenMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
/**
 * Creates a new user account with the provided information and automatically
logs them in with access and refresh tokens.
 * @summary Register a new user account
 */
export const authRegister = (
  registerRequest: BodyType<RegisterRequest>,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal
) => {
  return customInstance<AuthRegister200>(
    {
      url: `/api/auth/register`,
      method: "POST",
      headers: { "Content-Type": "application/json" },
      data: registerRequest,
      signal,
    },
    options
  );
};

export const getAuthRegisterMutationOptions = <
  TError = ErrorType<ValidationExceptionResponse>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof authRegister>>,
    TError,
    { data: BodyType<RegisterRequest> },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof authRegister>>,
  TError,
  { data: BodyType<RegisterRequest> },
  TContext
> => {
  const mutationKey = ["authRegister"];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof authRegister>>,
    { data: BodyType<RegisterRequest> }
  > = (props) => {
    const { data } = props ?? {};

    return authRegister(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type AuthRegisterMutationResult = NonNullable<
  Awaited<ReturnType<typeof authRegister>>
>;
export type AuthRegisterMutationBody = BodyType<RegisterRequest>;
export type AuthRegisterMutationError = ErrorType<ValidationExceptionResponse>;

/**
 * @summary Register a new user account
 */
export const useAuthRegister = <
  TError = ErrorType<ValidationExceptionResponse>,
  TContext = unknown
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof authRegister>>,
      TError,
      { data: BodyType<RegisterRequest> },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof authRegister>>,
  TError,
  { data: BodyType<RegisterRequest> },
  TContext
> => {
  const mutationOptions = getAuthRegisterMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
/**
 * Returns detailed information about all active tokens/sessions including
IP history, location data, and device information for security management.
 * @summary Get user's active sessions and tokens
 */
export const authTokens = (
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal
) => {
  return customInstance<AuthTokens200Item[]>(
    { url: `/api/auth/tokens`, method: "GET", signal },
    options
  );
};

export const getAuthTokensInfiniteQueryKey = () => {
  return ["infinite", `/api/auth/tokens`] as const;
};

export const getAuthTokensQueryKey = () => {
  return [`/api/auth/tokens`] as const;
};

export const getAuthTokensInfiniteQueryOptions = <
  TData = InfiniteData<Awaited<ReturnType<typeof authTokens>>>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(options?: {
  query?: Partial<
    UseInfiniteQueryOptions<
      Awaited<ReturnType<typeof authTokens>>,
      TError,
      TData
    >
  >;
  request?: SecondParameter<typeof customInstance>;
}) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getAuthTokensInfiniteQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof authTokens>>> = ({
    signal,
  }) => authTokens(requestOptions, signal);

  return { queryKey, queryFn, ...queryOptions } as UseInfiniteQueryOptions<
    Awaited<ReturnType<typeof authTokens>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type AuthTokensInfiniteQueryResult = NonNullable<
  Awaited<ReturnType<typeof authTokens>>
>;
export type AuthTokensInfiniteQueryError =
  ErrorType<AuthenticationExceptionResponse>;

export function useAuthTokensInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof authTokens>>>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(
  options: {
    query: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof authTokens>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof authTokens>>,
          TError,
          Awaited<ReturnType<typeof authTokens>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): DefinedUseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useAuthTokensInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof authTokens>>>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof authTokens>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof authTokens>>,
          TError,
          Awaited<ReturnType<typeof authTokens>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useAuthTokensInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof authTokens>>>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof authTokens>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get user's active sessions and tokens
 */

export function useAuthTokensInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof authTokens>>>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof authTokens>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getAuthTokensInfiniteQueryOptions(options);

  const query = useInfiniteQuery(
    queryOptions,
    queryClient
  ) as UseInfiniteQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getAuthTokensQueryOptions = <
  TData = Awaited<ReturnType<typeof authTokens>>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof authTokens>>, TError, TData>
  >;
  request?: SecondParameter<typeof customInstance>;
}) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getAuthTokensQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof authTokens>>> = ({
    signal,
  }) => authTokens(requestOptions, signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof authTokens>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type AuthTokensQueryResult = NonNullable<
  Awaited<ReturnType<typeof authTokens>>
>;
export type AuthTokensQueryError = ErrorType<AuthenticationExceptionResponse>;

export function useAuthTokens<
  TData = Awaited<ReturnType<typeof authTokens>>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof authTokens>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof authTokens>>,
          TError,
          Awaited<ReturnType<typeof authTokens>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useAuthTokens<
  TData = Awaited<ReturnType<typeof authTokens>>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof authTokens>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof authTokens>>,
          TError,
          Awaited<ReturnType<typeof authTokens>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useAuthTokens<
  TData = Awaited<ReturnType<typeof authTokens>>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof authTokens>>, TError, TData>
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get user's active sessions and tokens
 */

export function useAuthTokens<
  TData = Awaited<ReturnType<typeof authTokens>>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof authTokens>>, TError, TData>
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getAuthTokensQueryOptions(options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getAuthTokensSuspenseQueryOptions = <
  TData = Awaited<ReturnType<typeof authTokens>>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(options?: {
  query?: Partial<
    UseSuspenseQueryOptions<
      Awaited<ReturnType<typeof authTokens>>,
      TError,
      TData
    >
  >;
  request?: SecondParameter<typeof customInstance>;
}) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getAuthTokensQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof authTokens>>> = ({
    signal,
  }) => authTokens(requestOptions, signal);

  return { queryKey, queryFn, ...queryOptions } as UseSuspenseQueryOptions<
    Awaited<ReturnType<typeof authTokens>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type AuthTokensSuspenseQueryResult = NonNullable<
  Awaited<ReturnType<typeof authTokens>>
>;
export type AuthTokensSuspenseQueryError =
  ErrorType<AuthenticationExceptionResponse>;

export function useAuthTokensSuspense<
  TData = Awaited<ReturnType<typeof authTokens>>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(
  options: {
    query: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof authTokens>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useAuthTokensSuspense<
  TData = Awaited<ReturnType<typeof authTokens>>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof authTokens>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useAuthTokensSuspense<
  TData = Awaited<ReturnType<typeof authTokens>>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof authTokens>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get user's active sessions and tokens
 */

export function useAuthTokensSuspense<
  TData = Awaited<ReturnType<typeof authTokens>>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof authTokens>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getAuthTokensSuspenseQueryOptions(options);

  const query = useSuspenseQuery(
    queryOptions,
    queryClient
  ) as UseSuspenseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getAuthTokensSuspenseInfiniteQueryOptions = <
  TData = InfiniteData<Awaited<ReturnType<typeof authTokens>>>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(options?: {
  query?: Partial<
    UseSuspenseInfiniteQueryOptions<
      Awaited<ReturnType<typeof authTokens>>,
      TError,
      TData
    >
  >;
  request?: SecondParameter<typeof customInstance>;
}) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getAuthTokensInfiniteQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof authTokens>>> = ({
    signal,
  }) => authTokens(requestOptions, signal);

  return {
    queryKey,
    queryFn,
    ...queryOptions,
  } as UseSuspenseInfiniteQueryOptions<
    Awaited<ReturnType<typeof authTokens>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type AuthTokensSuspenseInfiniteQueryResult = NonNullable<
  Awaited<ReturnType<typeof authTokens>>
>;
export type AuthTokensSuspenseInfiniteQueryError =
  ErrorType<AuthenticationExceptionResponse>;

export function useAuthTokensSuspenseInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof authTokens>>>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(
  options: {
    query: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof authTokens>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useAuthTokensSuspenseInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof authTokens>>>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof authTokens>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useAuthTokensSuspenseInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof authTokens>>>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof authTokens>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get user's active sessions and tokens
 */

export function useAuthTokensSuspenseInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof authTokens>>>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof authTokens>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getAuthTokensSuspenseInfiniteQueryOptions(options);

  const query = useSuspenseInfiniteQuery(
    queryOptions,
    queryClient
  ) as UseSuspenseInfiniteQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Revokes all active tokens except the current session.
 * @summary Revoke all sessions except current
 */
export const authTokensRevokeAll = (
  options?: SecondParameter<typeof customInstance>
) => {
  return customInstance<AuthTokensRevokeAll200>(
    { url: `/api/auth/tokens`, method: "DELETE" },
    options
  );
};

export const getAuthTokensRevokeAllMutationOptions = <
  TError = ErrorType<AuthenticationExceptionResponse>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof authTokensRevokeAll>>,
    TError,
    void,
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof authTokensRevokeAll>>,
  TError,
  void,
  TContext
> => {
  const mutationKey = ["authTokensRevokeAll"];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof authTokensRevokeAll>>,
    void
  > = () => {
    return authTokensRevokeAll(requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type AuthTokensRevokeAllMutationResult = NonNullable<
  Awaited<ReturnType<typeof authTokensRevokeAll>>
>;

export type AuthTokensRevokeAllMutationError =
  ErrorType<AuthenticationExceptionResponse>;

/**
 * @summary Revoke all sessions except current
 */
export const useAuthTokensRevokeAll = <
  TError = ErrorType<AuthenticationExceptionResponse>,
  TContext = unknown
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof authTokensRevokeAll>>,
      TError,
      void,
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof authTokensRevokeAll>>,
  TError,
  void,
  TContext
> => {
  const mutationOptions = getAuthTokensRevokeAllMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
/**
 * Permanently revokes a specific token, ending that session.
 * @summary Revoke a specific token/session
 */
export const authTokensRevoke = (
  tokenId: string,
  options?: SecondParameter<typeof customInstance>
) => {
  return customInstance<AuthTokensRevoke200>(
    { url: `/api/auth/tokens/${tokenId}`, method: "DELETE" },
    options
  );
};

export const getAuthTokensRevokeMutationOptions = <
  TError = ErrorType<AuthenticationExceptionResponse>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof authTokensRevoke>>,
    TError,
    { tokenId: string },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof authTokensRevoke>>,
  TError,
  { tokenId: string },
  TContext
> => {
  const mutationKey = ["authTokensRevoke"];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof authTokensRevoke>>,
    { tokenId: string }
  > = (props) => {
    const { tokenId } = props ?? {};

    return authTokensRevoke(tokenId, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type AuthTokensRevokeMutationResult = NonNullable<
  Awaited<ReturnType<typeof authTokensRevoke>>
>;

export type AuthTokensRevokeMutationError =
  ErrorType<AuthenticationExceptionResponse>;

/**
 * @summary Revoke a specific token/session
 */
export const useAuthTokensRevoke = <
  TError = ErrorType<AuthenticationExceptionResponse>,
  TContext = unknown
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof authTokensRevoke>>,
      TError,
      { tokenId: string },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof authTokensRevoke>>,
  TError,
  { tokenId: string },
  TContext
> => {
  const mutationOptions = getAuthTokensRevokeMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
/**
 * Sends a password reset link to the specified email address if a user
account exists.
 * @summary Request a password-reset link
 */
export const authForgotPassword = (
  forgotPasswordRequest: BodyType<ForgotPasswordRequest>,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal
) => {
  return customInstance<AuthForgotPassword200>(
    {
      url: `/api/auth/forgotPassword`,
      method: "POST",
      headers: { "Content-Type": "application/json" },
      data: forgotPasswordRequest,
      signal,
    },
    options
  );
};

export const getAuthForgotPasswordMutationOptions = <
  TError = ErrorType<ValidationExceptionResponse>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof authForgotPassword>>,
    TError,
    { data: BodyType<ForgotPasswordRequest> },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof authForgotPassword>>,
  TError,
  { data: BodyType<ForgotPasswordRequest> },
  TContext
> => {
  const mutationKey = ["authForgotPassword"];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof authForgotPassword>>,
    { data: BodyType<ForgotPasswordRequest> }
  > = (props) => {
    const { data } = props ?? {};

    return authForgotPassword(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type AuthForgotPasswordMutationResult = NonNullable<
  Awaited<ReturnType<typeof authForgotPassword>>
>;
export type AuthForgotPasswordMutationBody = BodyType<ForgotPasswordRequest>;
export type AuthForgotPasswordMutationError =
  ErrorType<ValidationExceptionResponse>;

/**
 * @summary Request a password-reset link
 */
export const useAuthForgotPassword = <
  TError = ErrorType<ValidationExceptionResponse>,
  TContext = unknown
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof authForgotPassword>>,
      TError,
      { data: BodyType<ForgotPasswordRequest> },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof authForgotPassword>>,
  TError,
  { data: BodyType<ForgotPasswordRequest> },
  TContext
> => {
  const mutationOptions = getAuthForgotPasswordMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
/**
 * Resets the user's password using a valid reset token. All existing
tokens are revoked for security after a password change.
 * @summary Reset user password
 */
export const authResetPassword = (
  resetPasswordRequest: BodyType<ResetPasswordRequest>,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal
) => {
  return customInstance<AuthResetPassword200>(
    {
      url: `/api/auth/resetPassword`,
      method: "POST",
      headers: { "Content-Type": "application/json" },
      data: resetPasswordRequest,
      signal,
    },
    options
  );
};

export const getAuthResetPasswordMutationOptions = <
  TError = ErrorType<AuthResetPassword400 | ValidationExceptionResponse>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof authResetPassword>>,
    TError,
    { data: BodyType<ResetPasswordRequest> },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof authResetPassword>>,
  TError,
  { data: BodyType<ResetPasswordRequest> },
  TContext
> => {
  const mutationKey = ["authResetPassword"];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof authResetPassword>>,
    { data: BodyType<ResetPasswordRequest> }
  > = (props) => {
    const { data } = props ?? {};

    return authResetPassword(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type AuthResetPasswordMutationResult = NonNullable<
  Awaited<ReturnType<typeof authResetPassword>>
>;
export type AuthResetPasswordMutationBody = BodyType<ResetPasswordRequest>;
export type AuthResetPasswordMutationError = ErrorType<
  AuthResetPassword400 | ValidationExceptionResponse
>;

/**
 * @summary Reset user password
 */
export const useAuthResetPassword = <
  TError = ErrorType<AuthResetPassword400 | ValidationExceptionResponse>,
  TContext = unknown
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof authResetPassword>>,
      TError,
      { data: BodyType<ResetPasswordRequest> },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof authResetPassword>>,
  TError,
  { data: BodyType<ResetPasswordRequest> },
  TContext
> => {
  const mutationOptions = getAuthResetPasswordMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
/**
 * Verifies a user's email address using the verification link sent during
registration or email change.
 * @summary Verify the user email address
 */
export const authVerifyEmail = (
  id: number,
  hash: string,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal
) => {
  return customInstance<UserResource>(
    { url: `/api/auth/verify/${id}/${hash}`, method: "POST", signal },
    options
  );
};

export const getAuthVerifyEmailMutationOptions = <
  TError = ErrorType<AuthVerifyEmail403 | ModelNotFoundExceptionResponse>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof authVerifyEmail>>,
    TError,
    { id: number; hash: string },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof authVerifyEmail>>,
  TError,
  { id: number; hash: string },
  TContext
> => {
  const mutationKey = ["authVerifyEmail"];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof authVerifyEmail>>,
    { id: number; hash: string }
  > = (props) => {
    const { id, hash } = props ?? {};

    return authVerifyEmail(id, hash, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type AuthVerifyEmailMutationResult = NonNullable<
  Awaited<ReturnType<typeof authVerifyEmail>>
>;

export type AuthVerifyEmailMutationError = ErrorType<
  AuthVerifyEmail403 | ModelNotFoundExceptionResponse
>;

/**
 * @summary Verify the user email address
 */
export const useAuthVerifyEmail = <
  TError = ErrorType<AuthVerifyEmail403 | ModelNotFoundExceptionResponse>,
  TContext = unknown
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof authVerifyEmail>>,
      TError,
      { id: number; hash: string },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof authVerifyEmail>>,
  TError,
  { id: number; hash: string },
  TContext
> => {
  const mutationOptions = getAuthVerifyEmailMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
/**
 * Revokes the current access token, effectively logging out the user.
 * @summary Log out the current session
 */
export const authLogout = (
  logoutRequest: BodyType<LogoutRequest>,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal
) => {
  return customInstance<void>(
    {
      url: `/api/auth/logout`,
      method: "POST",
      headers: { "Content-Type": "application/json" },
      data: logoutRequest,
      signal,
    },
    options
  );
};

export const getAuthLogoutMutationOptions = <
  TError = ErrorType<
    AuthenticationExceptionResponse | ValidationExceptionResponse
  >,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof authLogout>>,
    TError,
    { data: BodyType<LogoutRequest> },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof authLogout>>,
  TError,
  { data: BodyType<LogoutRequest> },
  TContext
> => {
  const mutationKey = ["authLogout"];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof authLogout>>,
    { data: BodyType<LogoutRequest> }
  > = (props) => {
    const { data } = props ?? {};

    return authLogout(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type AuthLogoutMutationResult = NonNullable<
  Awaited<ReturnType<typeof authLogout>>
>;
export type AuthLogoutMutationBody = BodyType<LogoutRequest>;
export type AuthLogoutMutationError = ErrorType<
  AuthenticationExceptionResponse | ValidationExceptionResponse
>;

/**
 * @summary Log out the current session
 */
export const useAuthLogout = <
  TError = ErrorType<
    AuthenticationExceptionResponse | ValidationExceptionResponse
  >,
  TContext = unknown
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof authLogout>>,
      TError,
      { data: BodyType<LogoutRequest> },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof authLogout>>,
  TError,
  { data: BodyType<LogoutRequest> },
  TContext
> => {
  const mutationOptions = getAuthLogoutMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
/**
 * Returns all OAuth clients for the current user or system.
 * @summary List all OAuth clients
 */
export const oauthClientsIndex = (
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal
) => {
  return customInstance<OauthClientsIndex200Item[]>(
    { url: `/api/oauth/clients`, method: "GET", signal },
    options
  );
};

export const getOauthClientsIndexInfiniteQueryKey = () => {
  return ["infinite", `/api/oauth/clients`] as const;
};

export const getOauthClientsIndexQueryKey = () => {
  return [`/api/oauth/clients`] as const;
};

export const getOauthClientsIndexInfiniteQueryOptions = <
  TData = InfiniteData<Awaited<ReturnType<typeof oauthClientsIndex>>>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(options?: {
  query?: Partial<
    UseInfiniteQueryOptions<
      Awaited<ReturnType<typeof oauthClientsIndex>>,
      TError,
      TData
    >
  >;
  request?: SecondParameter<typeof customInstance>;
}) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getOauthClientsIndexInfiniteQueryKey();

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof oauthClientsIndex>>
  > = ({ signal }) => oauthClientsIndex(requestOptions, signal);

  return { queryKey, queryFn, ...queryOptions } as UseInfiniteQueryOptions<
    Awaited<ReturnType<typeof oauthClientsIndex>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type OauthClientsIndexInfiniteQueryResult = NonNullable<
  Awaited<ReturnType<typeof oauthClientsIndex>>
>;
export type OauthClientsIndexInfiniteQueryError =
  ErrorType<AuthenticationExceptionResponse>;

export function useOauthClientsIndexInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof oauthClientsIndex>>>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(
  options: {
    query: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof oauthClientsIndex>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof oauthClientsIndex>>,
          TError,
          Awaited<ReturnType<typeof oauthClientsIndex>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): DefinedUseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useOauthClientsIndexInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof oauthClientsIndex>>>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof oauthClientsIndex>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof oauthClientsIndex>>,
          TError,
          Awaited<ReturnType<typeof oauthClientsIndex>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useOauthClientsIndexInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof oauthClientsIndex>>>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof oauthClientsIndex>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary List all OAuth clients
 */

export function useOauthClientsIndexInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof oauthClientsIndex>>>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof oauthClientsIndex>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getOauthClientsIndexInfiniteQueryOptions(options);

  const query = useInfiniteQuery(
    queryOptions,
    queryClient
  ) as UseInfiniteQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getOauthClientsIndexQueryOptions = <
  TData = Awaited<ReturnType<typeof oauthClientsIndex>>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(options?: {
  query?: Partial<
    UseQueryOptions<
      Awaited<ReturnType<typeof oauthClientsIndex>>,
      TError,
      TData
    >
  >;
  request?: SecondParameter<typeof customInstance>;
}) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getOauthClientsIndexQueryKey();

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof oauthClientsIndex>>
  > = ({ signal }) => oauthClientsIndex(requestOptions, signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof oauthClientsIndex>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type OauthClientsIndexQueryResult = NonNullable<
  Awaited<ReturnType<typeof oauthClientsIndex>>
>;
export type OauthClientsIndexQueryError =
  ErrorType<AuthenticationExceptionResponse>;

export function useOauthClientsIndex<
  TData = Awaited<ReturnType<typeof oauthClientsIndex>>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof oauthClientsIndex>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof oauthClientsIndex>>,
          TError,
          Awaited<ReturnType<typeof oauthClientsIndex>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useOauthClientsIndex<
  TData = Awaited<ReturnType<typeof oauthClientsIndex>>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof oauthClientsIndex>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof oauthClientsIndex>>,
          TError,
          Awaited<ReturnType<typeof oauthClientsIndex>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useOauthClientsIndex<
  TData = Awaited<ReturnType<typeof oauthClientsIndex>>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof oauthClientsIndex>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary List all OAuth clients
 */

export function useOauthClientsIndex<
  TData = Awaited<ReturnType<typeof oauthClientsIndex>>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof oauthClientsIndex>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getOauthClientsIndexQueryOptions(options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getOauthClientsIndexSuspenseQueryOptions = <
  TData = Awaited<ReturnType<typeof oauthClientsIndex>>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(options?: {
  query?: Partial<
    UseSuspenseQueryOptions<
      Awaited<ReturnType<typeof oauthClientsIndex>>,
      TError,
      TData
    >
  >;
  request?: SecondParameter<typeof customInstance>;
}) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getOauthClientsIndexQueryKey();

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof oauthClientsIndex>>
  > = ({ signal }) => oauthClientsIndex(requestOptions, signal);

  return { queryKey, queryFn, ...queryOptions } as UseSuspenseQueryOptions<
    Awaited<ReturnType<typeof oauthClientsIndex>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type OauthClientsIndexSuspenseQueryResult = NonNullable<
  Awaited<ReturnType<typeof oauthClientsIndex>>
>;
export type OauthClientsIndexSuspenseQueryError =
  ErrorType<AuthenticationExceptionResponse>;

export function useOauthClientsIndexSuspense<
  TData = Awaited<ReturnType<typeof oauthClientsIndex>>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(
  options: {
    query: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof oauthClientsIndex>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useOauthClientsIndexSuspense<
  TData = Awaited<ReturnType<typeof oauthClientsIndex>>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof oauthClientsIndex>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useOauthClientsIndexSuspense<
  TData = Awaited<ReturnType<typeof oauthClientsIndex>>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof oauthClientsIndex>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary List all OAuth clients
 */

export function useOauthClientsIndexSuspense<
  TData = Awaited<ReturnType<typeof oauthClientsIndex>>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof oauthClientsIndex>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getOauthClientsIndexSuspenseQueryOptions(options);

  const query = useSuspenseQuery(
    queryOptions,
    queryClient
  ) as UseSuspenseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getOauthClientsIndexSuspenseInfiniteQueryOptions = <
  TData = InfiniteData<Awaited<ReturnType<typeof oauthClientsIndex>>>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(options?: {
  query?: Partial<
    UseSuspenseInfiniteQueryOptions<
      Awaited<ReturnType<typeof oauthClientsIndex>>,
      TError,
      TData
    >
  >;
  request?: SecondParameter<typeof customInstance>;
}) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getOauthClientsIndexInfiniteQueryKey();

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof oauthClientsIndex>>
  > = ({ signal }) => oauthClientsIndex(requestOptions, signal);

  return {
    queryKey,
    queryFn,
    ...queryOptions,
  } as UseSuspenseInfiniteQueryOptions<
    Awaited<ReturnType<typeof oauthClientsIndex>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type OauthClientsIndexSuspenseInfiniteQueryResult = NonNullable<
  Awaited<ReturnType<typeof oauthClientsIndex>>
>;
export type OauthClientsIndexSuspenseInfiniteQueryError =
  ErrorType<AuthenticationExceptionResponse>;

export function useOauthClientsIndexSuspenseInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof oauthClientsIndex>>>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(
  options: {
    query: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof oauthClientsIndex>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useOauthClientsIndexSuspenseInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof oauthClientsIndex>>>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof oauthClientsIndex>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useOauthClientsIndexSuspenseInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof oauthClientsIndex>>>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof oauthClientsIndex>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary List all OAuth clients
 */

export function useOauthClientsIndexSuspenseInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof oauthClientsIndex>>>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof oauthClientsIndex>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions =
    getOauthClientsIndexSuspenseInfiniteQueryOptions(options);

  const query = useSuspenseInfiniteQuery(
    queryOptions,
    queryClient
  ) as UseSuspenseInfiniteQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Creates a new OAuth 2.0 client with the specified configuration.
 * @summary Create a new OAuth client
 */
export const oauthClientsStore = (
  oauthClientsStoreBody: BodyType<OauthClientsStoreBody>,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal
) => {
  return customInstance<OauthClientsStore200>(
    {
      url: `/api/oauth/clients`,
      method: "POST",
      headers: { "Content-Type": "application/json" },
      data: oauthClientsStoreBody,
      signal,
    },
    options
  );
};

export const getOauthClientsStoreMutationOptions = <
  TError = ErrorType<
    AuthenticationExceptionResponse | ValidationExceptionResponse
  >,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof oauthClientsStore>>,
    TError,
    { data: BodyType<OauthClientsStoreBody> },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof oauthClientsStore>>,
  TError,
  { data: BodyType<OauthClientsStoreBody> },
  TContext
> => {
  const mutationKey = ["oauthClientsStore"];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof oauthClientsStore>>,
    { data: BodyType<OauthClientsStoreBody> }
  > = (props) => {
    const { data } = props ?? {};

    return oauthClientsStore(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type OauthClientsStoreMutationResult = NonNullable<
  Awaited<ReturnType<typeof oauthClientsStore>>
>;
export type OauthClientsStoreMutationBody = BodyType<OauthClientsStoreBody>;
export type OauthClientsStoreMutationError = ErrorType<
  AuthenticationExceptionResponse | ValidationExceptionResponse
>;

/**
 * @summary Create a new OAuth client
 */
export const useOauthClientsStore = <
  TError = ErrorType<
    AuthenticationExceptionResponse | ValidationExceptionResponse
  >,
  TContext = unknown
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof oauthClientsStore>>,
      TError,
      { data: BodyType<OauthClientsStoreBody> },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof oauthClientsStore>>,
  TError,
  { data: BodyType<OauthClientsStoreBody> },
  TContext
> => {
  const mutationOptions = getOauthClientsStoreMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
/**
 * Returns details for a specific OAuth client.
 * @summary Get a specific OAuth client
 */
export const oauthClientsShow = (
  client: number,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal
) => {
  return customInstance<OauthClientsShow200>(
    { url: `/api/oauth/clients/${client}`, method: "GET", signal },
    options
  );
};

export const getOauthClientsShowInfiniteQueryKey = (client?: number) => {
  return ["infinite", `/api/oauth/clients/${client}`] as const;
};

export const getOauthClientsShowQueryKey = (client?: number) => {
  return [`/api/oauth/clients/${client}`] as const;
};

export const getOauthClientsShowInfiniteQueryOptions = <
  TData = InfiniteData<Awaited<ReturnType<typeof oauthClientsShow>>>,
  TError = ErrorType<
    AuthenticationExceptionResponse | ModelNotFoundExceptionResponse
  >
>(
  client: number,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof oauthClientsShow>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getOauthClientsShowInfiniteQueryKey(client);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof oauthClientsShow>>
  > = ({ signal }) => oauthClientsShow(client, requestOptions, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!client,
    ...queryOptions,
  } as UseInfiniteQueryOptions<
    Awaited<ReturnType<typeof oauthClientsShow>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type OauthClientsShowInfiniteQueryResult = NonNullable<
  Awaited<ReturnType<typeof oauthClientsShow>>
>;
export type OauthClientsShowInfiniteQueryError = ErrorType<
  AuthenticationExceptionResponse | ModelNotFoundExceptionResponse
>;

export function useOauthClientsShowInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof oauthClientsShow>>>,
  TError = ErrorType<
    AuthenticationExceptionResponse | ModelNotFoundExceptionResponse
  >
>(
  client: number,
  options: {
    query: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof oauthClientsShow>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof oauthClientsShow>>,
          TError,
          Awaited<ReturnType<typeof oauthClientsShow>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): DefinedUseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useOauthClientsShowInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof oauthClientsShow>>>,
  TError = ErrorType<
    AuthenticationExceptionResponse | ModelNotFoundExceptionResponse
  >
>(
  client: number,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof oauthClientsShow>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof oauthClientsShow>>,
          TError,
          Awaited<ReturnType<typeof oauthClientsShow>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useOauthClientsShowInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof oauthClientsShow>>>,
  TError = ErrorType<
    AuthenticationExceptionResponse | ModelNotFoundExceptionResponse
  >
>(
  client: number,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof oauthClientsShow>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get a specific OAuth client
 */

export function useOauthClientsShowInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof oauthClientsShow>>>,
  TError = ErrorType<
    AuthenticationExceptionResponse | ModelNotFoundExceptionResponse
  >
>(
  client: number,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof oauthClientsShow>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getOauthClientsShowInfiniteQueryOptions(client, options);

  const query = useInfiniteQuery(
    queryOptions,
    queryClient
  ) as UseInfiniteQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getOauthClientsShowQueryOptions = <
  TData = Awaited<ReturnType<typeof oauthClientsShow>>,
  TError = ErrorType<
    AuthenticationExceptionResponse | ModelNotFoundExceptionResponse
  >
>(
  client: number,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof oauthClientsShow>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getOauthClientsShowQueryKey(client);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof oauthClientsShow>>
  > = ({ signal }) => oauthClientsShow(client, requestOptions, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!client,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof oauthClientsShow>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type OauthClientsShowQueryResult = NonNullable<
  Awaited<ReturnType<typeof oauthClientsShow>>
>;
export type OauthClientsShowQueryError = ErrorType<
  AuthenticationExceptionResponse | ModelNotFoundExceptionResponse
>;

export function useOauthClientsShow<
  TData = Awaited<ReturnType<typeof oauthClientsShow>>,
  TError = ErrorType<
    AuthenticationExceptionResponse | ModelNotFoundExceptionResponse
  >
>(
  client: number,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof oauthClientsShow>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof oauthClientsShow>>,
          TError,
          Awaited<ReturnType<typeof oauthClientsShow>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useOauthClientsShow<
  TData = Awaited<ReturnType<typeof oauthClientsShow>>,
  TError = ErrorType<
    AuthenticationExceptionResponse | ModelNotFoundExceptionResponse
  >
>(
  client: number,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof oauthClientsShow>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof oauthClientsShow>>,
          TError,
          Awaited<ReturnType<typeof oauthClientsShow>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useOauthClientsShow<
  TData = Awaited<ReturnType<typeof oauthClientsShow>>,
  TError = ErrorType<
    AuthenticationExceptionResponse | ModelNotFoundExceptionResponse
  >
>(
  client: number,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof oauthClientsShow>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get a specific OAuth client
 */

export function useOauthClientsShow<
  TData = Awaited<ReturnType<typeof oauthClientsShow>>,
  TError = ErrorType<
    AuthenticationExceptionResponse | ModelNotFoundExceptionResponse
  >
>(
  client: number,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof oauthClientsShow>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getOauthClientsShowQueryOptions(client, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getOauthClientsShowSuspenseQueryOptions = <
  TData = Awaited<ReturnType<typeof oauthClientsShow>>,
  TError = ErrorType<
    AuthenticationExceptionResponse | ModelNotFoundExceptionResponse
  >
>(
  client: number,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof oauthClientsShow>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getOauthClientsShowQueryKey(client);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof oauthClientsShow>>
  > = ({ signal }) => oauthClientsShow(client, requestOptions, signal);

  return { queryKey, queryFn, ...queryOptions } as UseSuspenseQueryOptions<
    Awaited<ReturnType<typeof oauthClientsShow>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type OauthClientsShowSuspenseQueryResult = NonNullable<
  Awaited<ReturnType<typeof oauthClientsShow>>
>;
export type OauthClientsShowSuspenseQueryError = ErrorType<
  AuthenticationExceptionResponse | ModelNotFoundExceptionResponse
>;

export function useOauthClientsShowSuspense<
  TData = Awaited<ReturnType<typeof oauthClientsShow>>,
  TError = ErrorType<
    AuthenticationExceptionResponse | ModelNotFoundExceptionResponse
  >
>(
  client: number,
  options: {
    query: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof oauthClientsShow>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useOauthClientsShowSuspense<
  TData = Awaited<ReturnType<typeof oauthClientsShow>>,
  TError = ErrorType<
    AuthenticationExceptionResponse | ModelNotFoundExceptionResponse
  >
>(
  client: number,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof oauthClientsShow>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useOauthClientsShowSuspense<
  TData = Awaited<ReturnType<typeof oauthClientsShow>>,
  TError = ErrorType<
    AuthenticationExceptionResponse | ModelNotFoundExceptionResponse
  >
>(
  client: number,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof oauthClientsShow>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get a specific OAuth client
 */

export function useOauthClientsShowSuspense<
  TData = Awaited<ReturnType<typeof oauthClientsShow>>,
  TError = ErrorType<
    AuthenticationExceptionResponse | ModelNotFoundExceptionResponse
  >
>(
  client: number,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof oauthClientsShow>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getOauthClientsShowSuspenseQueryOptions(client, options);

  const query = useSuspenseQuery(
    queryOptions,
    queryClient
  ) as UseSuspenseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getOauthClientsShowSuspenseInfiniteQueryOptions = <
  TData = InfiniteData<Awaited<ReturnType<typeof oauthClientsShow>>>,
  TError = ErrorType<
    AuthenticationExceptionResponse | ModelNotFoundExceptionResponse
  >
>(
  client: number,
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof oauthClientsShow>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getOauthClientsShowInfiniteQueryKey(client);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof oauthClientsShow>>
  > = ({ signal }) => oauthClientsShow(client, requestOptions, signal);

  return {
    queryKey,
    queryFn,
    ...queryOptions,
  } as UseSuspenseInfiniteQueryOptions<
    Awaited<ReturnType<typeof oauthClientsShow>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type OauthClientsShowSuspenseInfiniteQueryResult = NonNullable<
  Awaited<ReturnType<typeof oauthClientsShow>>
>;
export type OauthClientsShowSuspenseInfiniteQueryError = ErrorType<
  AuthenticationExceptionResponse | ModelNotFoundExceptionResponse
>;

export function useOauthClientsShowSuspenseInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof oauthClientsShow>>>,
  TError = ErrorType<
    AuthenticationExceptionResponse | ModelNotFoundExceptionResponse
  >
>(
  client: number,
  options: {
    query: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof oauthClientsShow>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useOauthClientsShowSuspenseInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof oauthClientsShow>>>,
  TError = ErrorType<
    AuthenticationExceptionResponse | ModelNotFoundExceptionResponse
  >
>(
  client: number,
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof oauthClientsShow>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useOauthClientsShowSuspenseInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof oauthClientsShow>>>,
  TError = ErrorType<
    AuthenticationExceptionResponse | ModelNotFoundExceptionResponse
  >
>(
  client: number,
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof oauthClientsShow>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get a specific OAuth client
 */

export function useOauthClientsShowSuspenseInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof oauthClientsShow>>>,
  TError = ErrorType<
    AuthenticationExceptionResponse | ModelNotFoundExceptionResponse
  >
>(
  client: number,
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof oauthClientsShow>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getOauthClientsShowSuspenseInfiniteQueryOptions(
    client,
    options
  );

  const query = useSuspenseInfiniteQuery(
    queryOptions,
    queryClient
  ) as UseSuspenseInfiniteQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Updates an existing OAuth client configuration.
 * @summary Update an OAuth client
 */
export const oauthClientsUpdate = (
  client: number,
  oauthClientsUpdateBody: BodyType<OauthClientsUpdateBody>,
  options?: SecondParameter<typeof customInstance>
) => {
  return customInstance<OauthClientsUpdate200>(
    {
      url: `/api/oauth/clients/${client}`,
      method: "PUT",
      headers: { "Content-Type": "application/json" },
      data: oauthClientsUpdateBody,
    },
    options
  );
};

export const getOauthClientsUpdateMutationOptions = <
  TError = ErrorType<
    | AuthenticationExceptionResponse
    | ModelNotFoundExceptionResponse
    | ValidationExceptionResponse
  >,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof oauthClientsUpdate>>,
    TError,
    { client: number; data: BodyType<OauthClientsUpdateBody> },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof oauthClientsUpdate>>,
  TError,
  { client: number; data: BodyType<OauthClientsUpdateBody> },
  TContext
> => {
  const mutationKey = ["oauthClientsUpdate"];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof oauthClientsUpdate>>,
    { client: number; data: BodyType<OauthClientsUpdateBody> }
  > = (props) => {
    const { client, data } = props ?? {};

    return oauthClientsUpdate(client, data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type OauthClientsUpdateMutationResult = NonNullable<
  Awaited<ReturnType<typeof oauthClientsUpdate>>
>;
export type OauthClientsUpdateMutationBody = BodyType<OauthClientsUpdateBody>;
export type OauthClientsUpdateMutationError = ErrorType<
  | AuthenticationExceptionResponse
  | ModelNotFoundExceptionResponse
  | ValidationExceptionResponse
>;

/**
 * @summary Update an OAuth client
 */
export const useOauthClientsUpdate = <
  TError = ErrorType<
    | AuthenticationExceptionResponse
    | ModelNotFoundExceptionResponse
    | ValidationExceptionResponse
  >,
  TContext = unknown
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof oauthClientsUpdate>>,
      TError,
      { client: number; data: BodyType<OauthClientsUpdateBody> },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof oauthClientsUpdate>>,
  TError,
  { client: number; data: BodyType<OauthClientsUpdateBody> },
  TContext
> => {
  const mutationOptions = getOauthClientsUpdateMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
/**
 * Revokes an OAuth client, preventing it from being used for new requests.
 * @summary Delete an OAuth client
 */
export const oauthClientsDestroy = (
  client: number,
  options?: SecondParameter<typeof customInstance>
) => {
  return customInstance<OauthClientsDestroy200>(
    { url: `/api/oauth/clients/${client}`, method: "DELETE" },
    options
  );
};

export const getOauthClientsDestroyMutationOptions = <
  TError = ErrorType<
    AuthenticationExceptionResponse | ModelNotFoundExceptionResponse
  >,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof oauthClientsDestroy>>,
    TError,
    { client: number },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof oauthClientsDestroy>>,
  TError,
  { client: number },
  TContext
> => {
  const mutationKey = ["oauthClientsDestroy"];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof oauthClientsDestroy>>,
    { client: number }
  > = (props) => {
    const { client } = props ?? {};

    return oauthClientsDestroy(client, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type OauthClientsDestroyMutationResult = NonNullable<
  Awaited<ReturnType<typeof oauthClientsDestroy>>
>;

export type OauthClientsDestroyMutationError = ErrorType<
  AuthenticationExceptionResponse | ModelNotFoundExceptionResponse
>;

/**
 * @summary Delete an OAuth client
 */
export const useOauthClientsDestroy = <
  TError = ErrorType<
    AuthenticationExceptionResponse | ModelNotFoundExceptionResponse
  >,
  TContext = unknown
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof oauthClientsDestroy>>,
      TError,
      { client: number },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof oauthClientsDestroy>>,
  TError,
  { client: number },
  TContext
> => {
  const mutationOptions = getOauthClientsDestroyMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
/**
 * Generates a new secret for a confidential OAuth client.
 * @summary Regenerate client secret
 */
export const oauthClientsRegenerateSecret = (
  client: number,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal
) => {
  return customInstance<OauthClientsRegenerateSecret200>(
    {
      url: `/api/oauth/clients/${client}/regenerate-secret`,
      method: "POST",
      signal,
    },
    options
  );
};

export const getOauthClientsRegenerateSecretMutationOptions = <
  TError = ErrorType<
    AuthenticationExceptionResponse | ModelNotFoundExceptionResponse
  >,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof oauthClientsRegenerateSecret>>,
    TError,
    { client: number },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof oauthClientsRegenerateSecret>>,
  TError,
  { client: number },
  TContext
> => {
  const mutationKey = ["oauthClientsRegenerateSecret"];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof oauthClientsRegenerateSecret>>,
    { client: number }
  > = (props) => {
    const { client } = props ?? {};

    return oauthClientsRegenerateSecret(client, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type OauthClientsRegenerateSecretMutationResult = NonNullable<
  Awaited<ReturnType<typeof oauthClientsRegenerateSecret>>
>;

export type OauthClientsRegenerateSecretMutationError = ErrorType<
  AuthenticationExceptionResponse | ModelNotFoundExceptionResponse
>;

/**
 * @summary Regenerate client secret
 */
export const useOauthClientsRegenerateSecret = <
  TError = ErrorType<
    AuthenticationExceptionResponse | ModelNotFoundExceptionResponse
  >,
  TContext = unknown
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof oauthClientsRegenerateSecret>>,
      TError,
      { client: number },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof oauthClientsRegenerateSecret>>,
  TError,
  { client: number },
  TContext
> => {
  const mutationOptions =
    getOauthClientsRegenerateSecretMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
/**
 * Handles the authorization code flow authorization endpoint.
Redirects users to consent screen and generates authorization codes.
 * @summary OAuth 2.0 Authorization Endpoint
 */
export const oauthAuthorize = (
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal
) => {
  return customInstance<OauthAuthorize200>(
    { url: `/api/oauth/authorize`, method: "GET", signal },
    options
  );
};

export const getOauthAuthorizeInfiniteQueryKey = () => {
  return ["infinite", `/api/oauth/authorize`] as const;
};

export const getOauthAuthorizeQueryKey = () => {
  return [`/api/oauth/authorize`] as const;
};

export const getOauthAuthorizeInfiniteQueryOptions = <
  TData = InfiniteData<Awaited<ReturnType<typeof oauthAuthorize>>>,
  TError = ErrorType<unknown>
>(options?: {
  query?: Partial<
    UseInfiniteQueryOptions<
      Awaited<ReturnType<typeof oauthAuthorize>>,
      TError,
      TData
    >
  >;
  request?: SecondParameter<typeof customInstance>;
}) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getOauthAuthorizeInfiniteQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof oauthAuthorize>>> = ({
    signal,
  }) => oauthAuthorize(requestOptions, signal);

  return { queryKey, queryFn, ...queryOptions } as UseInfiniteQueryOptions<
    Awaited<ReturnType<typeof oauthAuthorize>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type OauthAuthorizeInfiniteQueryResult = NonNullable<
  Awaited<ReturnType<typeof oauthAuthorize>>
>;
export type OauthAuthorizeInfiniteQueryError = ErrorType<unknown>;

export function useOauthAuthorizeInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof oauthAuthorize>>>,
  TError = ErrorType<unknown>
>(
  options: {
    query: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof oauthAuthorize>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof oauthAuthorize>>,
          TError,
          Awaited<ReturnType<typeof oauthAuthorize>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): DefinedUseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useOauthAuthorizeInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof oauthAuthorize>>>,
  TError = ErrorType<unknown>
>(
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof oauthAuthorize>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof oauthAuthorize>>,
          TError,
          Awaited<ReturnType<typeof oauthAuthorize>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useOauthAuthorizeInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof oauthAuthorize>>>,
  TError = ErrorType<unknown>
>(
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof oauthAuthorize>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary OAuth 2.0 Authorization Endpoint
 */

export function useOauthAuthorizeInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof oauthAuthorize>>>,
  TError = ErrorType<unknown>
>(
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof oauthAuthorize>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getOauthAuthorizeInfiniteQueryOptions(options);

  const query = useInfiniteQuery(
    queryOptions,
    queryClient
  ) as UseInfiniteQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getOauthAuthorizeQueryOptions = <
  TData = Awaited<ReturnType<typeof oauthAuthorize>>,
  TError = ErrorType<unknown>
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof oauthAuthorize>>, TError, TData>
  >;
  request?: SecondParameter<typeof customInstance>;
}) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getOauthAuthorizeQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof oauthAuthorize>>> = ({
    signal,
  }) => oauthAuthorize(requestOptions, signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof oauthAuthorize>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type OauthAuthorizeQueryResult = NonNullable<
  Awaited<ReturnType<typeof oauthAuthorize>>
>;
export type OauthAuthorizeQueryError = ErrorType<unknown>;

export function useOauthAuthorize<
  TData = Awaited<ReturnType<typeof oauthAuthorize>>,
  TError = ErrorType<unknown>
>(
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof oauthAuthorize>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof oauthAuthorize>>,
          TError,
          Awaited<ReturnType<typeof oauthAuthorize>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useOauthAuthorize<
  TData = Awaited<ReturnType<typeof oauthAuthorize>>,
  TError = ErrorType<unknown>
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof oauthAuthorize>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof oauthAuthorize>>,
          TError,
          Awaited<ReturnType<typeof oauthAuthorize>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useOauthAuthorize<
  TData = Awaited<ReturnType<typeof oauthAuthorize>>,
  TError = ErrorType<unknown>
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof oauthAuthorize>>, TError, TData>
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary OAuth 2.0 Authorization Endpoint
 */

export function useOauthAuthorize<
  TData = Awaited<ReturnType<typeof oauthAuthorize>>,
  TError = ErrorType<unknown>
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof oauthAuthorize>>, TError, TData>
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getOauthAuthorizeQueryOptions(options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getOauthAuthorizeSuspenseQueryOptions = <
  TData = Awaited<ReturnType<typeof oauthAuthorize>>,
  TError = ErrorType<unknown>
>(options?: {
  query?: Partial<
    UseSuspenseQueryOptions<
      Awaited<ReturnType<typeof oauthAuthorize>>,
      TError,
      TData
    >
  >;
  request?: SecondParameter<typeof customInstance>;
}) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getOauthAuthorizeQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof oauthAuthorize>>> = ({
    signal,
  }) => oauthAuthorize(requestOptions, signal);

  return { queryKey, queryFn, ...queryOptions } as UseSuspenseQueryOptions<
    Awaited<ReturnType<typeof oauthAuthorize>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type OauthAuthorizeSuspenseQueryResult = NonNullable<
  Awaited<ReturnType<typeof oauthAuthorize>>
>;
export type OauthAuthorizeSuspenseQueryError = ErrorType<unknown>;

export function useOauthAuthorizeSuspense<
  TData = Awaited<ReturnType<typeof oauthAuthorize>>,
  TError = ErrorType<unknown>
>(
  options: {
    query: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof oauthAuthorize>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useOauthAuthorizeSuspense<
  TData = Awaited<ReturnType<typeof oauthAuthorize>>,
  TError = ErrorType<unknown>
>(
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof oauthAuthorize>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useOauthAuthorizeSuspense<
  TData = Awaited<ReturnType<typeof oauthAuthorize>>,
  TError = ErrorType<unknown>
>(
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof oauthAuthorize>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary OAuth 2.0 Authorization Endpoint
 */

export function useOauthAuthorizeSuspense<
  TData = Awaited<ReturnType<typeof oauthAuthorize>>,
  TError = ErrorType<unknown>
>(
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof oauthAuthorize>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getOauthAuthorizeSuspenseQueryOptions(options);

  const query = useSuspenseQuery(
    queryOptions,
    queryClient
  ) as UseSuspenseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getOauthAuthorizeSuspenseInfiniteQueryOptions = <
  TData = InfiniteData<Awaited<ReturnType<typeof oauthAuthorize>>>,
  TError = ErrorType<unknown>
>(options?: {
  query?: Partial<
    UseSuspenseInfiniteQueryOptions<
      Awaited<ReturnType<typeof oauthAuthorize>>,
      TError,
      TData
    >
  >;
  request?: SecondParameter<typeof customInstance>;
}) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getOauthAuthorizeInfiniteQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof oauthAuthorize>>> = ({
    signal,
  }) => oauthAuthorize(requestOptions, signal);

  return {
    queryKey,
    queryFn,
    ...queryOptions,
  } as UseSuspenseInfiniteQueryOptions<
    Awaited<ReturnType<typeof oauthAuthorize>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type OauthAuthorizeSuspenseInfiniteQueryResult = NonNullable<
  Awaited<ReturnType<typeof oauthAuthorize>>
>;
export type OauthAuthorizeSuspenseInfiniteQueryError = ErrorType<unknown>;

export function useOauthAuthorizeSuspenseInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof oauthAuthorize>>>,
  TError = ErrorType<unknown>
>(
  options: {
    query: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof oauthAuthorize>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useOauthAuthorizeSuspenseInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof oauthAuthorize>>>,
  TError = ErrorType<unknown>
>(
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof oauthAuthorize>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useOauthAuthorizeSuspenseInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof oauthAuthorize>>>,
  TError = ErrorType<unknown>
>(
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof oauthAuthorize>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary OAuth 2.0 Authorization Endpoint
 */

export function useOauthAuthorizeSuspenseInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof oauthAuthorize>>>,
  TError = ErrorType<unknown>
>(
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof oauthAuthorize>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getOauthAuthorizeSuspenseInfiniteQueryOptions(options);

  const query = useSuspenseInfiniteQuery(
    queryOptions,
    queryClient
  ) as UseSuspenseInfiniteQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Handles all OAuth 2.0 grant types including:
- authorization_code
- client_credentials
- password
- refresh_token
- urn:ietf:params:oauth:grant-type:device_code
 * @summary OAuth 2.0 Token Endpoint
 */
export const oauthToken = (
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal
) => {
  return customInstance<OauthToken200>(
    { url: `/api/oauth/token`, method: "POST", signal },
    options
  );
};

export const getOauthTokenMutationOptions = <
  TError = ErrorType<unknown>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof oauthToken>>,
    TError,
    void,
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof oauthToken>>,
  TError,
  void,
  TContext
> => {
  const mutationKey = ["oauthToken"];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof oauthToken>>,
    void
  > = () => {
    return oauthToken(requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type OauthTokenMutationResult = NonNullable<
  Awaited<ReturnType<typeof oauthToken>>
>;

export type OauthTokenMutationError = ErrorType<unknown>;

/**
 * @summary OAuth 2.0 Token Endpoint
 */
export const useOauthToken = <TError = ErrorType<unknown>, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof oauthToken>>,
      TError,
      void,
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof oauthToken>>,
  TError,
  void,
  TContext
> => {
  const mutationOptions = getOauthTokenMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
/**
 * Initiates the device code flow by generating device and user codes.
Used for devices with limited input capabilities (smart TVs, etc).
 * @summary Device Authorization Endpoint (RFC 8628)
 */
export const oauthDeviceAuthorize = (
  oauthDeviceAuthorizeBody: BodyType<OauthDeviceAuthorizeBody>,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal
) => {
  return customInstance<OauthDeviceAuthorize200>(
    {
      url: `/api/oauth/device/authorize`,
      method: "POST",
      headers: { "Content-Type": "application/json" },
      data: oauthDeviceAuthorizeBody,
      signal,
    },
    options
  );
};

export const getOauthDeviceAuthorizeMutationOptions = <
  TError = ErrorType<ValidationExceptionResponse>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof oauthDeviceAuthorize>>,
    TError,
    { data: BodyType<OauthDeviceAuthorizeBody> },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof oauthDeviceAuthorize>>,
  TError,
  { data: BodyType<OauthDeviceAuthorizeBody> },
  TContext
> => {
  const mutationKey = ["oauthDeviceAuthorize"];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof oauthDeviceAuthorize>>,
    { data: BodyType<OauthDeviceAuthorizeBody> }
  > = (props) => {
    const { data } = props ?? {};

    return oauthDeviceAuthorize(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type OauthDeviceAuthorizeMutationResult = NonNullable<
  Awaited<ReturnType<typeof oauthDeviceAuthorize>>
>;
export type OauthDeviceAuthorizeMutationBody =
  BodyType<OauthDeviceAuthorizeBody>;
export type OauthDeviceAuthorizeMutationError =
  ErrorType<ValidationExceptionResponse>;

/**
 * @summary Device Authorization Endpoint (RFC 8628)
 */
export const useOauthDeviceAuthorize = <
  TError = ErrorType<ValidationExceptionResponse>,
  TContext = unknown
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof oauthDeviceAuthorize>>,
      TError,
      { data: BodyType<OauthDeviceAuthorizeBody> },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof oauthDeviceAuthorize>>,
  TError,
  { data: BodyType<OauthDeviceAuthorizeBody> },
  TContext
> => {
  const mutationOptions = getOauthDeviceAuthorizeMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
/**
 * Allows users to enter their user code and approve device access.
This is the endpoint users visit on their phone/computer to authorize devices.
 * @summary Device Verification Endpoint
 */
export const oauthDeviceVerify = (
  params?: OauthDeviceVerifyParams,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal
) => {
  return customInstance<OauthDeviceVerify200>(
    { url: `/api/oauth/device/verify`, method: "GET", params, signal },
    options
  );
};

export const getOauthDeviceVerifyInfiniteQueryKey = (
  params?: OauthDeviceVerifyParams
) => {
  return [
    "infinite",
    `/api/oauth/device/verify`,
    ...(params ? [params] : []),
  ] as const;
};

export const getOauthDeviceVerifyQueryKey = (
  params?: OauthDeviceVerifyParams
) => {
  return [`/api/oauth/device/verify`, ...(params ? [params] : [])] as const;
};

export const getOauthDeviceVerifyInfiniteQueryOptions = <
  TData = InfiniteData<
    Awaited<ReturnType<typeof oauthDeviceVerify>>,
    OauthDeviceVerifyParams["page"]
  >,
  TError = ErrorType<unknown>
>(
  params?: OauthDeviceVerifyParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof oauthDeviceVerify>>,
        TError,
        TData,
        QueryKey,
        OauthDeviceVerifyParams["page"]
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getOauthDeviceVerifyInfiniteQueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof oauthDeviceVerify>>,
    QueryKey,
    OauthDeviceVerifyParams["page"]
  > = ({ signal, pageParam }) =>
    oauthDeviceVerify(
      { ...params, page: pageParam || params?.["page"] },
      requestOptions,
      signal
    );

  return { queryKey, queryFn, ...queryOptions } as UseInfiniteQueryOptions<
    Awaited<ReturnType<typeof oauthDeviceVerify>>,
    TError,
    TData,
    QueryKey,
    OauthDeviceVerifyParams["page"]
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type OauthDeviceVerifyInfiniteQueryResult = NonNullable<
  Awaited<ReturnType<typeof oauthDeviceVerify>>
>;
export type OauthDeviceVerifyInfiniteQueryError = ErrorType<unknown>;

export function useOauthDeviceVerifyInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof oauthDeviceVerify>>,
    OauthDeviceVerifyParams["page"]
  >,
  TError = ErrorType<unknown>
>(
  params: undefined | OauthDeviceVerifyParams,
  options: {
    query: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof oauthDeviceVerify>>,
        TError,
        TData,
        QueryKey,
        OauthDeviceVerifyParams["page"]
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof oauthDeviceVerify>>,
          TError,
          Awaited<ReturnType<typeof oauthDeviceVerify>>,
          QueryKey
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): DefinedUseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useOauthDeviceVerifyInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof oauthDeviceVerify>>,
    OauthDeviceVerifyParams["page"]
  >,
  TError = ErrorType<unknown>
>(
  params?: OauthDeviceVerifyParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof oauthDeviceVerify>>,
        TError,
        TData,
        QueryKey,
        OauthDeviceVerifyParams["page"]
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof oauthDeviceVerify>>,
          TError,
          Awaited<ReturnType<typeof oauthDeviceVerify>>,
          QueryKey
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useOauthDeviceVerifyInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof oauthDeviceVerify>>,
    OauthDeviceVerifyParams["page"]
  >,
  TError = ErrorType<unknown>
>(
  params?: OauthDeviceVerifyParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof oauthDeviceVerify>>,
        TError,
        TData,
        QueryKey,
        OauthDeviceVerifyParams["page"]
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Device Verification Endpoint
 */

export function useOauthDeviceVerifyInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof oauthDeviceVerify>>,
    OauthDeviceVerifyParams["page"]
  >,
  TError = ErrorType<unknown>
>(
  params?: OauthDeviceVerifyParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof oauthDeviceVerify>>,
        TError,
        TData,
        QueryKey,
        OauthDeviceVerifyParams["page"]
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getOauthDeviceVerifyInfiniteQueryOptions(
    params,
    options
  );

  const query = useInfiniteQuery(
    queryOptions,
    queryClient
  ) as UseInfiniteQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getOauthDeviceVerifyQueryOptions = <
  TData = Awaited<ReturnType<typeof oauthDeviceVerify>>,
  TError = ErrorType<unknown>
>(
  params?: OauthDeviceVerifyParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof oauthDeviceVerify>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getOauthDeviceVerifyQueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof oauthDeviceVerify>>
  > = ({ signal }) => oauthDeviceVerify(params, requestOptions, signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof oauthDeviceVerify>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type OauthDeviceVerifyQueryResult = NonNullable<
  Awaited<ReturnType<typeof oauthDeviceVerify>>
>;
export type OauthDeviceVerifyQueryError = ErrorType<unknown>;

export function useOauthDeviceVerify<
  TData = Awaited<ReturnType<typeof oauthDeviceVerify>>,
  TError = ErrorType<unknown>
>(
  params: undefined | OauthDeviceVerifyParams,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof oauthDeviceVerify>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof oauthDeviceVerify>>,
          TError,
          Awaited<ReturnType<typeof oauthDeviceVerify>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useOauthDeviceVerify<
  TData = Awaited<ReturnType<typeof oauthDeviceVerify>>,
  TError = ErrorType<unknown>
>(
  params?: OauthDeviceVerifyParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof oauthDeviceVerify>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof oauthDeviceVerify>>,
          TError,
          Awaited<ReturnType<typeof oauthDeviceVerify>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useOauthDeviceVerify<
  TData = Awaited<ReturnType<typeof oauthDeviceVerify>>,
  TError = ErrorType<unknown>
>(
  params?: OauthDeviceVerifyParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof oauthDeviceVerify>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Device Verification Endpoint
 */

export function useOauthDeviceVerify<
  TData = Awaited<ReturnType<typeof oauthDeviceVerify>>,
  TError = ErrorType<unknown>
>(
  params?: OauthDeviceVerifyParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof oauthDeviceVerify>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getOauthDeviceVerifyQueryOptions(params, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getOauthDeviceVerifySuspenseQueryOptions = <
  TData = Awaited<ReturnType<typeof oauthDeviceVerify>>,
  TError = ErrorType<unknown>
>(
  params?: OauthDeviceVerifyParams,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof oauthDeviceVerify>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getOauthDeviceVerifyQueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof oauthDeviceVerify>>
  > = ({ signal }) => oauthDeviceVerify(params, requestOptions, signal);

  return { queryKey, queryFn, ...queryOptions } as UseSuspenseQueryOptions<
    Awaited<ReturnType<typeof oauthDeviceVerify>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type OauthDeviceVerifySuspenseQueryResult = NonNullable<
  Awaited<ReturnType<typeof oauthDeviceVerify>>
>;
export type OauthDeviceVerifySuspenseQueryError = ErrorType<unknown>;

export function useOauthDeviceVerifySuspense<
  TData = Awaited<ReturnType<typeof oauthDeviceVerify>>,
  TError = ErrorType<unknown>
>(
  params: undefined | OauthDeviceVerifyParams,
  options: {
    query: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof oauthDeviceVerify>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useOauthDeviceVerifySuspense<
  TData = Awaited<ReturnType<typeof oauthDeviceVerify>>,
  TError = ErrorType<unknown>
>(
  params?: OauthDeviceVerifyParams,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof oauthDeviceVerify>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useOauthDeviceVerifySuspense<
  TData = Awaited<ReturnType<typeof oauthDeviceVerify>>,
  TError = ErrorType<unknown>
>(
  params?: OauthDeviceVerifyParams,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof oauthDeviceVerify>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Device Verification Endpoint
 */

export function useOauthDeviceVerifySuspense<
  TData = Awaited<ReturnType<typeof oauthDeviceVerify>>,
  TError = ErrorType<unknown>
>(
  params?: OauthDeviceVerifyParams,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof oauthDeviceVerify>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getOauthDeviceVerifySuspenseQueryOptions(
    params,
    options
  );

  const query = useSuspenseQuery(
    queryOptions,
    queryClient
  ) as UseSuspenseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getOauthDeviceVerifySuspenseInfiniteQueryOptions = <
  TData = InfiniteData<
    Awaited<ReturnType<typeof oauthDeviceVerify>>,
    OauthDeviceVerifyParams["page"]
  >,
  TError = ErrorType<unknown>
>(
  params?: OauthDeviceVerifyParams,
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof oauthDeviceVerify>>,
        TError,
        TData,
        QueryKey,
        OauthDeviceVerifyParams["page"]
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getOauthDeviceVerifyInfiniteQueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof oauthDeviceVerify>>,
    QueryKey,
    OauthDeviceVerifyParams["page"]
  > = ({ signal, pageParam }) =>
    oauthDeviceVerify(
      { ...params, page: pageParam || params?.["page"] },
      requestOptions,
      signal
    );

  return {
    queryKey,
    queryFn,
    ...queryOptions,
  } as UseSuspenseInfiniteQueryOptions<
    Awaited<ReturnType<typeof oauthDeviceVerify>>,
    TError,
    TData,
    QueryKey,
    OauthDeviceVerifyParams["page"]
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type OauthDeviceVerifySuspenseInfiniteQueryResult = NonNullable<
  Awaited<ReturnType<typeof oauthDeviceVerify>>
>;
export type OauthDeviceVerifySuspenseInfiniteQueryError = ErrorType<unknown>;

export function useOauthDeviceVerifySuspenseInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof oauthDeviceVerify>>,
    OauthDeviceVerifyParams["page"]
  >,
  TError = ErrorType<unknown>
>(
  params: undefined | OauthDeviceVerifyParams,
  options: {
    query: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof oauthDeviceVerify>>,
        TError,
        TData,
        QueryKey,
        OauthDeviceVerifyParams["page"]
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useOauthDeviceVerifySuspenseInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof oauthDeviceVerify>>,
    OauthDeviceVerifyParams["page"]
  >,
  TError = ErrorType<unknown>
>(
  params?: OauthDeviceVerifyParams,
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof oauthDeviceVerify>>,
        TError,
        TData,
        QueryKey,
        OauthDeviceVerifyParams["page"]
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useOauthDeviceVerifySuspenseInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof oauthDeviceVerify>>,
    OauthDeviceVerifyParams["page"]
  >,
  TError = ErrorType<unknown>
>(
  params?: OauthDeviceVerifyParams,
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof oauthDeviceVerify>>,
        TError,
        TData,
        QueryKey,
        OauthDeviceVerifyParams["page"]
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Device Verification Endpoint
 */

export function useOauthDeviceVerifySuspenseInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof oauthDeviceVerify>>,
    OauthDeviceVerifyParams["page"]
  >,
  TError = ErrorType<unknown>
>(
  params?: OauthDeviceVerifyParams,
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof oauthDeviceVerify>>,
        TError,
        TData,
        QueryKey,
        OauthDeviceVerifyParams["page"]
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getOauthDeviceVerifySuspenseInfiniteQueryOptions(
    params,
    options
  );

  const query = useSuspenseInfiniteQuery(
    queryOptions,
    queryClient
  ) as UseSuspenseInfiniteQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Approves or denies device access after user authentication and consent.
 * @summary Device Approval Endpoint
 */
export const oauthDeviceApprove = (
  oauthDeviceApproveBody: BodyType<OauthDeviceApproveBody>,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal
) => {
  return customInstance<OauthDeviceApprove200>(
    {
      url: `/api/oauth/device/approve`,
      method: "POST",
      headers: { "Content-Type": "application/json" },
      data: oauthDeviceApproveBody,
      signal,
    },
    options
  );
};

export const getOauthDeviceApproveMutationOptions = <
  TError = ErrorType<
    AuthenticationExceptionResponse | ValidationExceptionResponse
  >,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof oauthDeviceApprove>>,
    TError,
    { data: BodyType<OauthDeviceApproveBody> },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof oauthDeviceApprove>>,
  TError,
  { data: BodyType<OauthDeviceApproveBody> },
  TContext
> => {
  const mutationKey = ["oauthDeviceApprove"];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof oauthDeviceApprove>>,
    { data: BodyType<OauthDeviceApproveBody> }
  > = (props) => {
    const { data } = props ?? {};

    return oauthDeviceApprove(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type OauthDeviceApproveMutationResult = NonNullable<
  Awaited<ReturnType<typeof oauthDeviceApprove>>
>;
export type OauthDeviceApproveMutationBody = BodyType<OauthDeviceApproveBody>;
export type OauthDeviceApproveMutationError = ErrorType<
  AuthenticationExceptionResponse | ValidationExceptionResponse
>;

/**
 * @summary Device Approval Endpoint
 */
export const useOauthDeviceApprove = <
  TError = ErrorType<
    AuthenticationExceptionResponse | ValidationExceptionResponse
  >,
  TContext = unknown
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof oauthDeviceApprove>>,
      TError,
      { data: BodyType<OauthDeviceApproveBody> },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof oauthDeviceApprove>>,
  TError,
  { data: BodyType<OauthDeviceApproveBody> },
  TContext
> => {
  const mutationOptions = getOauthDeviceApproveMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
/**
 * Allows resource servers to query the authorization server about
the current state of an access token.
 * @summary Token Introspection Endpoint (RFC 7662)
 */
export const oauthIntrospect = (
  oauthIntrospectBody: BodyType<OauthIntrospectBody>,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal
) => {
  return customInstance<OauthIntrospect200>(
    {
      url: `/api/oauth/introspect`,
      method: "POST",
      headers: { "Content-Type": "application/json" },
      data: oauthIntrospectBody,
      signal,
    },
    options
  );
};

export const getOauthIntrospectMutationOptions = <
  TError = ErrorType<unknown>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof oauthIntrospect>>,
    TError,
    { data: BodyType<OauthIntrospectBody> },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof oauthIntrospect>>,
  TError,
  { data: BodyType<OauthIntrospectBody> },
  TContext
> => {
  const mutationKey = ["oauthIntrospect"];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof oauthIntrospect>>,
    { data: BodyType<OauthIntrospectBody> }
  > = (props) => {
    const { data } = props ?? {};

    return oauthIntrospect(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type OauthIntrospectMutationResult = NonNullable<
  Awaited<ReturnType<typeof oauthIntrospect>>
>;
export type OauthIntrospectMutationBody = BodyType<OauthIntrospectBody>;
export type OauthIntrospectMutationError = ErrorType<unknown>;

/**
 * @summary Token Introspection Endpoint (RFC 7662)
 */
export const useOauthIntrospect = <
  TError = ErrorType<unknown>,
  TContext = unknown
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof oauthIntrospect>>,
      TError,
      { data: BodyType<OauthIntrospectBody> },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof oauthIntrospect>>,
  TError,
  { data: BodyType<OauthIntrospectBody> },
  TContext
> => {
  const mutationOptions = getOauthIntrospectMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
/**
 * Creates a cryptographic challenge for passkey authentication including
allowed credentials and relying party information. This challenge must
be used with the WebAuthn JavaScript API for authentication.
 * @summary Generate WebAuthn authentication challenge
 */
export const authPasskeyOptions = (
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal
) => {
  return customInstance<AuthPasskeyOptions200>(
    { url: `/webauthn/passkey`, method: "GET", signal },
    options
  );
};

export const getAuthPasskeyOptionsInfiniteQueryKey = () => {
  return ["infinite", `/webauthn/passkey`] as const;
};

export const getAuthPasskeyOptionsQueryKey = () => {
  return [`/webauthn/passkey`] as const;
};

export const getAuthPasskeyOptionsInfiniteQueryOptions = <
  TData = InfiniteData<Awaited<ReturnType<typeof authPasskeyOptions>>>,
  TError = ErrorType<unknown>
>(options?: {
  query?: Partial<
    UseInfiniteQueryOptions<
      Awaited<ReturnType<typeof authPasskeyOptions>>,
      TError,
      TData
    >
  >;
  request?: SecondParameter<typeof customInstance>;
}) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getAuthPasskeyOptionsInfiniteQueryKey();

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof authPasskeyOptions>>
  > = ({ signal }) => authPasskeyOptions(requestOptions, signal);

  return { queryKey, queryFn, ...queryOptions } as UseInfiniteQueryOptions<
    Awaited<ReturnType<typeof authPasskeyOptions>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type AuthPasskeyOptionsInfiniteQueryResult = NonNullable<
  Awaited<ReturnType<typeof authPasskeyOptions>>
>;
export type AuthPasskeyOptionsInfiniteQueryError = ErrorType<unknown>;

export function useAuthPasskeyOptionsInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof authPasskeyOptions>>>,
  TError = ErrorType<unknown>
>(
  options: {
    query: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof authPasskeyOptions>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof authPasskeyOptions>>,
          TError,
          Awaited<ReturnType<typeof authPasskeyOptions>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): DefinedUseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useAuthPasskeyOptionsInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof authPasskeyOptions>>>,
  TError = ErrorType<unknown>
>(
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof authPasskeyOptions>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof authPasskeyOptions>>,
          TError,
          Awaited<ReturnType<typeof authPasskeyOptions>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useAuthPasskeyOptionsInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof authPasskeyOptions>>>,
  TError = ErrorType<unknown>
>(
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof authPasskeyOptions>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Generate WebAuthn authentication challenge
 */

export function useAuthPasskeyOptionsInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof authPasskeyOptions>>>,
  TError = ErrorType<unknown>
>(
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof authPasskeyOptions>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getAuthPasskeyOptionsInfiniteQueryOptions(options);

  const query = useInfiniteQuery(
    queryOptions,
    queryClient
  ) as UseInfiniteQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getAuthPasskeyOptionsQueryOptions = <
  TData = Awaited<ReturnType<typeof authPasskeyOptions>>,
  TError = ErrorType<unknown>
>(options?: {
  query?: Partial<
    UseQueryOptions<
      Awaited<ReturnType<typeof authPasskeyOptions>>,
      TError,
      TData
    >
  >;
  request?: SecondParameter<typeof customInstance>;
}) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getAuthPasskeyOptionsQueryKey();

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof authPasskeyOptions>>
  > = ({ signal }) => authPasskeyOptions(requestOptions, signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof authPasskeyOptions>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type AuthPasskeyOptionsQueryResult = NonNullable<
  Awaited<ReturnType<typeof authPasskeyOptions>>
>;
export type AuthPasskeyOptionsQueryError = ErrorType<unknown>;

export function useAuthPasskeyOptions<
  TData = Awaited<ReturnType<typeof authPasskeyOptions>>,
  TError = ErrorType<unknown>
>(
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof authPasskeyOptions>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof authPasskeyOptions>>,
          TError,
          Awaited<ReturnType<typeof authPasskeyOptions>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useAuthPasskeyOptions<
  TData = Awaited<ReturnType<typeof authPasskeyOptions>>,
  TError = ErrorType<unknown>
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof authPasskeyOptions>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof authPasskeyOptions>>,
          TError,
          Awaited<ReturnType<typeof authPasskeyOptions>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useAuthPasskeyOptions<
  TData = Awaited<ReturnType<typeof authPasskeyOptions>>,
  TError = ErrorType<unknown>
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof authPasskeyOptions>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Generate WebAuthn authentication challenge
 */

export function useAuthPasskeyOptions<
  TData = Awaited<ReturnType<typeof authPasskeyOptions>>,
  TError = ErrorType<unknown>
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof authPasskeyOptions>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getAuthPasskeyOptionsQueryOptions(options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getAuthPasskeyOptionsSuspenseQueryOptions = <
  TData = Awaited<ReturnType<typeof authPasskeyOptions>>,
  TError = ErrorType<unknown>
>(options?: {
  query?: Partial<
    UseSuspenseQueryOptions<
      Awaited<ReturnType<typeof authPasskeyOptions>>,
      TError,
      TData
    >
  >;
  request?: SecondParameter<typeof customInstance>;
}) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getAuthPasskeyOptionsQueryKey();

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof authPasskeyOptions>>
  > = ({ signal }) => authPasskeyOptions(requestOptions, signal);

  return { queryKey, queryFn, ...queryOptions } as UseSuspenseQueryOptions<
    Awaited<ReturnType<typeof authPasskeyOptions>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type AuthPasskeyOptionsSuspenseQueryResult = NonNullable<
  Awaited<ReturnType<typeof authPasskeyOptions>>
>;
export type AuthPasskeyOptionsSuspenseQueryError = ErrorType<unknown>;

export function useAuthPasskeyOptionsSuspense<
  TData = Awaited<ReturnType<typeof authPasskeyOptions>>,
  TError = ErrorType<unknown>
>(
  options: {
    query: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof authPasskeyOptions>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useAuthPasskeyOptionsSuspense<
  TData = Awaited<ReturnType<typeof authPasskeyOptions>>,
  TError = ErrorType<unknown>
>(
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof authPasskeyOptions>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useAuthPasskeyOptionsSuspense<
  TData = Awaited<ReturnType<typeof authPasskeyOptions>>,
  TError = ErrorType<unknown>
>(
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof authPasskeyOptions>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Generate WebAuthn authentication challenge
 */

export function useAuthPasskeyOptionsSuspense<
  TData = Awaited<ReturnType<typeof authPasskeyOptions>>,
  TError = ErrorType<unknown>
>(
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof authPasskeyOptions>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getAuthPasskeyOptionsSuspenseQueryOptions(options);

  const query = useSuspenseQuery(
    queryOptions,
    queryClient
  ) as UseSuspenseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getAuthPasskeyOptionsSuspenseInfiniteQueryOptions = <
  TData = InfiniteData<Awaited<ReturnType<typeof authPasskeyOptions>>>,
  TError = ErrorType<unknown>
>(options?: {
  query?: Partial<
    UseSuspenseInfiniteQueryOptions<
      Awaited<ReturnType<typeof authPasskeyOptions>>,
      TError,
      TData
    >
  >;
  request?: SecondParameter<typeof customInstance>;
}) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getAuthPasskeyOptionsInfiniteQueryKey();

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof authPasskeyOptions>>
  > = ({ signal }) => authPasskeyOptions(requestOptions, signal);

  return {
    queryKey,
    queryFn,
    ...queryOptions,
  } as UseSuspenseInfiniteQueryOptions<
    Awaited<ReturnType<typeof authPasskeyOptions>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type AuthPasskeyOptionsSuspenseInfiniteQueryResult = NonNullable<
  Awaited<ReturnType<typeof authPasskeyOptions>>
>;
export type AuthPasskeyOptionsSuspenseInfiniteQueryError = ErrorType<unknown>;

export function useAuthPasskeyOptionsSuspenseInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof authPasskeyOptions>>>,
  TError = ErrorType<unknown>
>(
  options: {
    query: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof authPasskeyOptions>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useAuthPasskeyOptionsSuspenseInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof authPasskeyOptions>>>,
  TError = ErrorType<unknown>
>(
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof authPasskeyOptions>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useAuthPasskeyOptionsSuspenseInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof authPasskeyOptions>>>,
  TError = ErrorType<unknown>
>(
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof authPasskeyOptions>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Generate WebAuthn authentication challenge
 */

export function useAuthPasskeyOptionsSuspenseInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof authPasskeyOptions>>>,
  TError = ErrorType<unknown>
>(
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof authPasskeyOptions>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions =
    getAuthPasskeyOptionsSuspenseInfiniteQueryOptions(options);

  const query = useSuspenseInfiniteQuery(
    queryOptions,
    queryClient
  ) as UseSuspenseInfiniteQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Verifies the WebAuthn assertion from the user's authenticator and logs them in
if successful. Creates session tokens and handles redirect logic for seamless
authentication experience.
 * @summary Authenticate using WebAuthn passkey
 */
export const authPasskeyLogin = (
  authenticateUsingPasskeyRequest: BodyType<AuthenticateUsingPasskeyRequest>,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal
) => {
  return customInstance<AuthPasskeyLogin200>(
    {
      url: `/webauthn/passkey`,
      method: "POST",
      headers: { "Content-Type": "application/json" },
      data: authenticateUsingPasskeyRequest,
      signal,
    },
    options
  );
};

export const getAuthPasskeyLoginMutationOptions = <
  TError = ErrorType<ValidationExceptionResponse>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof authPasskeyLogin>>,
    TError,
    { data: BodyType<AuthenticateUsingPasskeyRequest> },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof authPasskeyLogin>>,
  TError,
  { data: BodyType<AuthenticateUsingPasskeyRequest> },
  TContext
> => {
  const mutationKey = ["authPasskeyLogin"];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof authPasskeyLogin>>,
    { data: BodyType<AuthenticateUsingPasskeyRequest> }
  > = (props) => {
    const { data } = props ?? {};

    return authPasskeyLogin(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type AuthPasskeyLoginMutationResult = NonNullable<
  Awaited<ReturnType<typeof authPasskeyLogin>>
>;
export type AuthPasskeyLoginMutationBody =
  BodyType<AuthenticateUsingPasskeyRequest>;
export type AuthPasskeyLoginMutationError =
  ErrorType<ValidationExceptionResponse>;

/**
 * @summary Authenticate using WebAuthn passkey
 */
export const useAuthPasskeyLogin = <
  TError = ErrorType<ValidationExceptionResponse>,
  TContext = unknown
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof authPasskeyLogin>>,
      TError,
      { data: BodyType<AuthenticateUsingPasskeyRequest> },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof authPasskeyLogin>>,
  TError,
  { data: BodyType<AuthenticateUsingPasskeyRequest> },
  TContext
> => {
  const mutationOptions = getAuthPasskeyLoginMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
/**
 * Creates a cryptographic challenge for registering a new passkey to the
authenticated user's account. The challenge includes user information
and credential creation parameters.
 * @summary Generate WebAuthn registration challenge for new passkey
 */
export const authPasskeyRegisterOption = (
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal
) => {
  return customInstance<AuthPasskeyRegisterOption200>(
    { url: `/webauthn/passkey/register`, method: "GET", signal },
    options
  );
};

export const getAuthPasskeyRegisterOptionInfiniteQueryKey = () => {
  return ["infinite", `/webauthn/passkey/register`] as const;
};

export const getAuthPasskeyRegisterOptionQueryKey = () => {
  return [`/webauthn/passkey/register`] as const;
};

export const getAuthPasskeyRegisterOptionInfiniteQueryOptions = <
  TData = InfiniteData<Awaited<ReturnType<typeof authPasskeyRegisterOption>>>,
  TError = ErrorType<
    AuthenticationExceptionResponse | AuthorizationExceptionResponse
  >
>(options?: {
  query?: Partial<
    UseInfiniteQueryOptions<
      Awaited<ReturnType<typeof authPasskeyRegisterOption>>,
      TError,
      TData
    >
  >;
  request?: SecondParameter<typeof customInstance>;
}) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getAuthPasskeyRegisterOptionInfiniteQueryKey();

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof authPasskeyRegisterOption>>
  > = ({ signal }) => authPasskeyRegisterOption(requestOptions, signal);

  return { queryKey, queryFn, ...queryOptions } as UseInfiniteQueryOptions<
    Awaited<ReturnType<typeof authPasskeyRegisterOption>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type AuthPasskeyRegisterOptionInfiniteQueryResult = NonNullable<
  Awaited<ReturnType<typeof authPasskeyRegisterOption>>
>;
export type AuthPasskeyRegisterOptionInfiniteQueryError = ErrorType<
  AuthenticationExceptionResponse | AuthorizationExceptionResponse
>;

export function useAuthPasskeyRegisterOptionInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof authPasskeyRegisterOption>>>,
  TError = ErrorType<
    AuthenticationExceptionResponse | AuthorizationExceptionResponse
  >
>(
  options: {
    query: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof authPasskeyRegisterOption>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof authPasskeyRegisterOption>>,
          TError,
          Awaited<ReturnType<typeof authPasskeyRegisterOption>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): DefinedUseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useAuthPasskeyRegisterOptionInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof authPasskeyRegisterOption>>>,
  TError = ErrorType<
    AuthenticationExceptionResponse | AuthorizationExceptionResponse
  >
>(
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof authPasskeyRegisterOption>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof authPasskeyRegisterOption>>,
          TError,
          Awaited<ReturnType<typeof authPasskeyRegisterOption>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useAuthPasskeyRegisterOptionInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof authPasskeyRegisterOption>>>,
  TError = ErrorType<
    AuthenticationExceptionResponse | AuthorizationExceptionResponse
  >
>(
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof authPasskeyRegisterOption>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Generate WebAuthn registration challenge for new passkey
 */

export function useAuthPasskeyRegisterOptionInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof authPasskeyRegisterOption>>>,
  TError = ErrorType<
    AuthenticationExceptionResponse | AuthorizationExceptionResponse
  >
>(
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof authPasskeyRegisterOption>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions =
    getAuthPasskeyRegisterOptionInfiniteQueryOptions(options);

  const query = useInfiniteQuery(
    queryOptions,
    queryClient
  ) as UseInfiniteQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getAuthPasskeyRegisterOptionQueryOptions = <
  TData = Awaited<ReturnType<typeof authPasskeyRegisterOption>>,
  TError = ErrorType<
    AuthenticationExceptionResponse | AuthorizationExceptionResponse
  >
>(options?: {
  query?: Partial<
    UseQueryOptions<
      Awaited<ReturnType<typeof authPasskeyRegisterOption>>,
      TError,
      TData
    >
  >;
  request?: SecondParameter<typeof customInstance>;
}) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getAuthPasskeyRegisterOptionQueryKey();

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof authPasskeyRegisterOption>>
  > = ({ signal }) => authPasskeyRegisterOption(requestOptions, signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof authPasskeyRegisterOption>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type AuthPasskeyRegisterOptionQueryResult = NonNullable<
  Awaited<ReturnType<typeof authPasskeyRegisterOption>>
>;
export type AuthPasskeyRegisterOptionQueryError = ErrorType<
  AuthenticationExceptionResponse | AuthorizationExceptionResponse
>;

export function useAuthPasskeyRegisterOption<
  TData = Awaited<ReturnType<typeof authPasskeyRegisterOption>>,
  TError = ErrorType<
    AuthenticationExceptionResponse | AuthorizationExceptionResponse
  >
>(
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof authPasskeyRegisterOption>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof authPasskeyRegisterOption>>,
          TError,
          Awaited<ReturnType<typeof authPasskeyRegisterOption>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useAuthPasskeyRegisterOption<
  TData = Awaited<ReturnType<typeof authPasskeyRegisterOption>>,
  TError = ErrorType<
    AuthenticationExceptionResponse | AuthorizationExceptionResponse
  >
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof authPasskeyRegisterOption>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof authPasskeyRegisterOption>>,
          TError,
          Awaited<ReturnType<typeof authPasskeyRegisterOption>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useAuthPasskeyRegisterOption<
  TData = Awaited<ReturnType<typeof authPasskeyRegisterOption>>,
  TError = ErrorType<
    AuthenticationExceptionResponse | AuthorizationExceptionResponse
  >
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof authPasskeyRegisterOption>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Generate WebAuthn registration challenge for new passkey
 */

export function useAuthPasskeyRegisterOption<
  TData = Awaited<ReturnType<typeof authPasskeyRegisterOption>>,
  TError = ErrorType<
    AuthenticationExceptionResponse | AuthorizationExceptionResponse
  >
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof authPasskeyRegisterOption>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getAuthPasskeyRegisterOptionQueryOptions(options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getAuthPasskeyRegisterOptionSuspenseQueryOptions = <
  TData = Awaited<ReturnType<typeof authPasskeyRegisterOption>>,
  TError = ErrorType<
    AuthenticationExceptionResponse | AuthorizationExceptionResponse
  >
>(options?: {
  query?: Partial<
    UseSuspenseQueryOptions<
      Awaited<ReturnType<typeof authPasskeyRegisterOption>>,
      TError,
      TData
    >
  >;
  request?: SecondParameter<typeof customInstance>;
}) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getAuthPasskeyRegisterOptionQueryKey();

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof authPasskeyRegisterOption>>
  > = ({ signal }) => authPasskeyRegisterOption(requestOptions, signal);

  return { queryKey, queryFn, ...queryOptions } as UseSuspenseQueryOptions<
    Awaited<ReturnType<typeof authPasskeyRegisterOption>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type AuthPasskeyRegisterOptionSuspenseQueryResult = NonNullable<
  Awaited<ReturnType<typeof authPasskeyRegisterOption>>
>;
export type AuthPasskeyRegisterOptionSuspenseQueryError = ErrorType<
  AuthenticationExceptionResponse | AuthorizationExceptionResponse
>;

export function useAuthPasskeyRegisterOptionSuspense<
  TData = Awaited<ReturnType<typeof authPasskeyRegisterOption>>,
  TError = ErrorType<
    AuthenticationExceptionResponse | AuthorizationExceptionResponse
  >
>(
  options: {
    query: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof authPasskeyRegisterOption>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useAuthPasskeyRegisterOptionSuspense<
  TData = Awaited<ReturnType<typeof authPasskeyRegisterOption>>,
  TError = ErrorType<
    AuthenticationExceptionResponse | AuthorizationExceptionResponse
  >
>(
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof authPasskeyRegisterOption>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useAuthPasskeyRegisterOptionSuspense<
  TData = Awaited<ReturnType<typeof authPasskeyRegisterOption>>,
  TError = ErrorType<
    AuthenticationExceptionResponse | AuthorizationExceptionResponse
  >
>(
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof authPasskeyRegisterOption>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Generate WebAuthn registration challenge for new passkey
 */

export function useAuthPasskeyRegisterOptionSuspense<
  TData = Awaited<ReturnType<typeof authPasskeyRegisterOption>>,
  TError = ErrorType<
    AuthenticationExceptionResponse | AuthorizationExceptionResponse
  >
>(
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof authPasskeyRegisterOption>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions =
    getAuthPasskeyRegisterOptionSuspenseQueryOptions(options);

  const query = useSuspenseQuery(
    queryOptions,
    queryClient
  ) as UseSuspenseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getAuthPasskeyRegisterOptionSuspenseInfiniteQueryOptions = <
  TData = InfiniteData<Awaited<ReturnType<typeof authPasskeyRegisterOption>>>,
  TError = ErrorType<
    AuthenticationExceptionResponse | AuthorizationExceptionResponse
  >
>(options?: {
  query?: Partial<
    UseSuspenseInfiniteQueryOptions<
      Awaited<ReturnType<typeof authPasskeyRegisterOption>>,
      TError,
      TData
    >
  >;
  request?: SecondParameter<typeof customInstance>;
}) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getAuthPasskeyRegisterOptionInfiniteQueryKey();

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof authPasskeyRegisterOption>>
  > = ({ signal }) => authPasskeyRegisterOption(requestOptions, signal);

  return {
    queryKey,
    queryFn,
    ...queryOptions,
  } as UseSuspenseInfiniteQueryOptions<
    Awaited<ReturnType<typeof authPasskeyRegisterOption>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type AuthPasskeyRegisterOptionSuspenseInfiniteQueryResult = NonNullable<
  Awaited<ReturnType<typeof authPasskeyRegisterOption>>
>;
export type AuthPasskeyRegisterOptionSuspenseInfiniteQueryError = ErrorType<
  AuthenticationExceptionResponse | AuthorizationExceptionResponse
>;

export function useAuthPasskeyRegisterOptionSuspenseInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof authPasskeyRegisterOption>>>,
  TError = ErrorType<
    AuthenticationExceptionResponse | AuthorizationExceptionResponse
  >
>(
  options: {
    query: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof authPasskeyRegisterOption>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useAuthPasskeyRegisterOptionSuspenseInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof authPasskeyRegisterOption>>>,
  TError = ErrorType<
    AuthenticationExceptionResponse | AuthorizationExceptionResponse
  >
>(
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof authPasskeyRegisterOption>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useAuthPasskeyRegisterOptionSuspenseInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof authPasskeyRegisterOption>>>,
  TError = ErrorType<
    AuthenticationExceptionResponse | AuthorizationExceptionResponse
  >
>(
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof authPasskeyRegisterOption>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Generate WebAuthn registration challenge for new passkey
 */

export function useAuthPasskeyRegisterOptionSuspenseInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof authPasskeyRegisterOption>>>,
  TError = ErrorType<
    AuthenticationExceptionResponse | AuthorizationExceptionResponse
  >
>(
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof authPasskeyRegisterOption>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions =
    getAuthPasskeyRegisterOptionSuspenseInfiniteQueryOptions(options);

  const query = useSuspenseInfiniteQuery(
    queryOptions,
    queryClient
  ) as UseSuspenseInfiniteQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Processes the WebAuthn attestation response to register a new passkey
credential for the user's account. Includes validation and secure storage
of the credential with optional naming.
 * @summary Register a new passkey for the authenticated user
 */
export const authPasskeyRegister = (
  storePasskeyRequest: BodyType<StorePasskeyRequest>,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal
) => {
  return customInstance<AuthPasskeyRegister200>(
    {
      url: `/webauthn/passkey/register`,
      method: "POST",
      headers: { "Content-Type": "application/json" },
      data: storePasskeyRequest,
      signal,
    },
    options
  );
};

export const getAuthPasskeyRegisterMutationOptions = <
  TError = ErrorType<
    | AuthenticationExceptionResponse
    | AuthorizationExceptionResponse
    | ValidationExceptionResponse
  >,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof authPasskeyRegister>>,
    TError,
    { data: BodyType<StorePasskeyRequest> },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof authPasskeyRegister>>,
  TError,
  { data: BodyType<StorePasskeyRequest> },
  TContext
> => {
  const mutationKey = ["authPasskeyRegister"];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof authPasskeyRegister>>,
    { data: BodyType<StorePasskeyRequest> }
  > = (props) => {
    const { data } = props ?? {};

    return authPasskeyRegister(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type AuthPasskeyRegisterMutationResult = NonNullable<
  Awaited<ReturnType<typeof authPasskeyRegister>>
>;
export type AuthPasskeyRegisterMutationBody = BodyType<StorePasskeyRequest>;
export type AuthPasskeyRegisterMutationError = ErrorType<
  | AuthenticationExceptionResponse
  | AuthorizationExceptionResponse
  | ValidationExceptionResponse
>;

/**
 * @summary Register a new passkey for the authenticated user
 */
export const useAuthPasskeyRegister = <
  TError = ErrorType<
    | AuthenticationExceptionResponse
    | AuthorizationExceptionResponse
    | ValidationExceptionResponse
  >,
  TContext = unknown
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof authPasskeyRegister>>,
      TError,
      { data: BodyType<StorePasskeyRequest> },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof authPasskeyRegister>>,
  TError,
  { data: BodyType<StorePasskeyRequest> },
  TContext
> => {
  const mutationOptions = getAuthPasskeyRegisterMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
