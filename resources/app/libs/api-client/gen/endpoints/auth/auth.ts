/**
 * Generated by orval v7.11.2 üç∫
 * Do not edit manually.
 * B√•nder api docs
 * B√•nder.App is a sophisticated media server developed with the primary goal to deliver high performance and seamless experience for users.
Being built on top of Laravel framework and PostgreSQL for database, it leverages the power of robust backend technologies, providing high security, reliability, and scalability.

The main focus of B√•nder.App is efficient media management and delivery.
This application is designed to handle large amounts of media files while ensuring quick and efficient access.
Implemented queuing functionality through Redis offers efficient job management and load handling.
The media information is organized and easily searchable, ensuring users can always find what they are looking for quickly and easily.
 * OpenAPI spec version: 0.0.1
 */
import {
  useInfiniteQuery,
  useMutation,
  useQuery,
  useSuspenseInfiniteQuery,
  useSuspenseQuery,
} from "@tanstack/react-query";
import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseInfiniteQueryResult,
  DefinedUseQueryResult,
  InfiniteData,
  MutationFunction,
  QueryClient,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseInfiniteQueryOptions,
  UseInfiniteQueryResult,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult,
  UseSuspenseInfiniteQueryOptions,
  UseSuspenseInfiniteQueryResult,
  UseSuspenseQueryOptions,
  UseSuspenseQueryResult,
} from "@tanstack/react-query";

import type {
  AuthForgotPassword200,
  AuthLogin200,
  AuthLogin401,
  AuthPasskeyLogin200,
  AuthPasskeyOptions200,
  AuthPasskeyRegister200,
  AuthPasskeyRegisterOption200,
  AuthRefreshToken200,
  AuthRegister200,
  AuthResetPassword200,
  AuthResetPassword400,
  AuthStreamToken200,
  AuthTokens200Item,
  AuthTokensRevoke200,
  AuthTokensRevokeAll200,
  AuthenticateUsingPasskeyRequest,
  AuthenticationExceptionResponse,
  AuthorizationExceptionResponse,
  ForgotPasswordRequest,
  LoginRequest,
  LogoutRequest,
  ModelNotFoundExceptionResponse,
  RegisterRequest,
  ResetPasswordRequest,
  StorePasskeyRequest,
  UserResource,
  ValidationExceptionResponse,
} from "../../models";

import { customInstance } from "../../../axios-instance";
import type { ErrorType, BodyType } from "../../../axios-instance";

type SecondParameter<T extends (...args: never) => unknown> = Parameters<T>[1];

/**
 * Authenticates a user with email and password, creates access and refresh tokens
with device binding and location tracking for security purposes.
 * @summary Authenticate user and create session
 */
export const authLogin = (
  loginRequest: BodyType<LoginRequest>,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal
) => {
  return customInstance<AuthLogin200>(
    {
      url: `/api/auth/login`,
      method: "POST",
      headers: { "Content-Type": "application/json" },
      data: loginRequest,
      signal,
    },
    options
  );
};

export const getAuthLoginMutationOptions = <
  TError = ErrorType<AuthLogin401 | ValidationExceptionResponse>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof authLogin>>,
    TError,
    { data: BodyType<LoginRequest> },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof authLogin>>,
  TError,
  { data: BodyType<LoginRequest> },
  TContext
> => {
  const mutationKey = ["authLogin"];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof authLogin>>,
    { data: BodyType<LoginRequest> }
  > = (props) => {
    const { data } = props ?? {};

    return authLogin(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type AuthLoginMutationResult = NonNullable<
  Awaited<ReturnType<typeof authLogin>>
>;
export type AuthLoginMutationBody = BodyType<LoginRequest>;
export type AuthLoginMutationError = ErrorType<
  AuthLogin401 | ValidationExceptionResponse
>;

/**
 * @summary Authenticate user and create session
 */
export const useAuthLogin = <
  TError = ErrorType<AuthLogin401 | ValidationExceptionResponse>,
  TContext = unknown
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof authLogin>>,
      TError,
      { data: BodyType<LoginRequest> },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof authLogin>>,
  TError,
  { data: BodyType<LoginRequest> },
  TContext
> => {
  const mutationOptions = getAuthLoginMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
/**
 * Creates a new access token using a valid refresh token. Updates device
binding information and maintains session continuity.
 * @summary Refresh access token using refresh token
 */
export const authRefreshToken = (
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal
) => {
  return customInstance<AuthRefreshToken200>(
    { url: `/api/auth/refreshToken`, method: "POST", signal },
    options
  );
};

export const getAuthRefreshTokenMutationOptions = <
  TError = ErrorType<
    AuthenticationExceptionResponse | AuthorizationExceptionResponse
  >,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof authRefreshToken>>,
    TError,
    void,
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof authRefreshToken>>,
  TError,
  void,
  TContext
> => {
  const mutationKey = ["authRefreshToken"];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof authRefreshToken>>,
    void
  > = () => {
    return authRefreshToken(requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type AuthRefreshTokenMutationResult = NonNullable<
  Awaited<ReturnType<typeof authRefreshToken>>
>;

export type AuthRefreshTokenMutationError = ErrorType<
  AuthenticationExceptionResponse | AuthorizationExceptionResponse
>;

/**
 * @summary Refresh access token using refresh token
 */
export const useAuthRefreshToken = <
  TError = ErrorType<
    AuthenticationExceptionResponse | AuthorizationExceptionResponse
  >,
  TContext = unknown
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof authRefreshToken>>,
      TError,
      void,
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof authRefreshToken>>,
  TError,
  void,
  TContext
> => {
  const mutationOptions = getAuthRefreshTokenMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
/**
 * Generates a short-lived token specifically for media streaming operations.
These tokens have limited scope and shorter expiration for enhanced security.
 * @summary Create a stream-specific access token
 */
export const authStreamToken = (
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal
) => {
  return customInstance<AuthStreamToken200>(
    { url: `/api/auth/streamToken`, method: "POST", signal },
    options
  );
};

export const getAuthStreamTokenMutationOptions = <
  TError = ErrorType<
    AuthenticationExceptionResponse | AuthorizationExceptionResponse
  >,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof authStreamToken>>,
    TError,
    void,
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof authStreamToken>>,
  TError,
  void,
  TContext
> => {
  const mutationKey = ["authStreamToken"];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof authStreamToken>>,
    void
  > = () => {
    return authStreamToken(requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type AuthStreamTokenMutationResult = NonNullable<
  Awaited<ReturnType<typeof authStreamToken>>
>;

export type AuthStreamTokenMutationError = ErrorType<
  AuthenticationExceptionResponse | AuthorizationExceptionResponse
>;

/**
 * @summary Create a stream-specific access token
 */
export const useAuthStreamToken = <
  TError = ErrorType<
    AuthenticationExceptionResponse | AuthorizationExceptionResponse
  >,
  TContext = unknown
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof authStreamToken>>,
      TError,
      void,
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof authStreamToken>>,
  TError,
  void,
  TContext
> => {
  const mutationOptions = getAuthStreamTokenMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
/**
 * Creates a new user account with the provided information and automatically
logs them in with access and refresh tokens.
 * @summary Register a new user account
 */
export const authRegister = (
  registerRequest: BodyType<RegisterRequest>,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal
) => {
  return customInstance<AuthRegister200>(
    {
      url: `/api/auth/register`,
      method: "POST",
      headers: { "Content-Type": "application/json" },
      data: registerRequest,
      signal,
    },
    options
  );
};

export const getAuthRegisterMutationOptions = <
  TError = ErrorType<ValidationExceptionResponse>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof authRegister>>,
    TError,
    { data: BodyType<RegisterRequest> },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof authRegister>>,
  TError,
  { data: BodyType<RegisterRequest> },
  TContext
> => {
  const mutationKey = ["authRegister"];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof authRegister>>,
    { data: BodyType<RegisterRequest> }
  > = (props) => {
    const { data } = props ?? {};

    return authRegister(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type AuthRegisterMutationResult = NonNullable<
  Awaited<ReturnType<typeof authRegister>>
>;
export type AuthRegisterMutationBody = BodyType<RegisterRequest>;
export type AuthRegisterMutationError = ErrorType<ValidationExceptionResponse>;

/**
 * @summary Register a new user account
 */
export const useAuthRegister = <
  TError = ErrorType<ValidationExceptionResponse>,
  TContext = unknown
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof authRegister>>,
      TError,
      { data: BodyType<RegisterRequest> },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof authRegister>>,
  TError,
  { data: BodyType<RegisterRequest> },
  TContext
> => {
  const mutationOptions = getAuthRegisterMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
/**
 * Returns detailed information about all active tokens/sessions including
IP history, location data, and device information for security management.
 * @summary Get user's active sessions and tokens
 */
export const authTokens = (
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal
) => {
  return customInstance<AuthTokens200Item[]>(
    { url: `/api/auth/tokens`, method: "GET", signal },
    options
  );
};

export const getAuthTokensQueryKey = () => {
  return [`/api/auth/tokens`] as const;
};

export const getAuthTokensInfiniteQueryOptions = <
  TData = InfiniteData<Awaited<ReturnType<typeof authTokens>>>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(options?: {
  query?: Partial<
    UseInfiniteQueryOptions<
      Awaited<ReturnType<typeof authTokens>>,
      TError,
      TData
    >
  >;
  request?: SecondParameter<typeof customInstance>;
}) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getAuthTokensQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof authTokens>>> = ({
    signal,
  }) => authTokens(requestOptions, signal);

  return { queryKey, queryFn, ...queryOptions } as UseInfiniteQueryOptions<
    Awaited<ReturnType<typeof authTokens>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type AuthTokensInfiniteQueryResult = NonNullable<
  Awaited<ReturnType<typeof authTokens>>
>;
export type AuthTokensInfiniteQueryError =
  ErrorType<AuthenticationExceptionResponse>;

export function useAuthTokensInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof authTokens>>>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(
  options: {
    query: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof authTokens>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof authTokens>>,
          TError,
          Awaited<ReturnType<typeof authTokens>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): DefinedUseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useAuthTokensInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof authTokens>>>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof authTokens>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof authTokens>>,
          TError,
          Awaited<ReturnType<typeof authTokens>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useAuthTokensInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof authTokens>>>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof authTokens>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get user's active sessions and tokens
 */

export function useAuthTokensInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof authTokens>>>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof authTokens>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getAuthTokensInfiniteQueryOptions(options);

  const query = useInfiniteQuery(
    queryOptions,
    queryClient
  ) as UseInfiniteQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getAuthTokensQueryOptions = <
  TData = Awaited<ReturnType<typeof authTokens>>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof authTokens>>, TError, TData>
  >;
  request?: SecondParameter<typeof customInstance>;
}) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getAuthTokensQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof authTokens>>> = ({
    signal,
  }) => authTokens(requestOptions, signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof authTokens>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type AuthTokensQueryResult = NonNullable<
  Awaited<ReturnType<typeof authTokens>>
>;
export type AuthTokensQueryError = ErrorType<AuthenticationExceptionResponse>;

export function useAuthTokens<
  TData = Awaited<ReturnType<typeof authTokens>>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof authTokens>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof authTokens>>,
          TError,
          Awaited<ReturnType<typeof authTokens>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useAuthTokens<
  TData = Awaited<ReturnType<typeof authTokens>>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof authTokens>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof authTokens>>,
          TError,
          Awaited<ReturnType<typeof authTokens>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useAuthTokens<
  TData = Awaited<ReturnType<typeof authTokens>>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof authTokens>>, TError, TData>
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get user's active sessions and tokens
 */

export function useAuthTokens<
  TData = Awaited<ReturnType<typeof authTokens>>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof authTokens>>, TError, TData>
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getAuthTokensQueryOptions(options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getAuthTokensSuspenseQueryOptions = <
  TData = Awaited<ReturnType<typeof authTokens>>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(options?: {
  query?: Partial<
    UseSuspenseQueryOptions<
      Awaited<ReturnType<typeof authTokens>>,
      TError,
      TData
    >
  >;
  request?: SecondParameter<typeof customInstance>;
}) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getAuthTokensQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof authTokens>>> = ({
    signal,
  }) => authTokens(requestOptions, signal);

  return { queryKey, queryFn, ...queryOptions } as UseSuspenseQueryOptions<
    Awaited<ReturnType<typeof authTokens>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type AuthTokensSuspenseQueryResult = NonNullable<
  Awaited<ReturnType<typeof authTokens>>
>;
export type AuthTokensSuspenseQueryError =
  ErrorType<AuthenticationExceptionResponse>;

export function useAuthTokensSuspense<
  TData = Awaited<ReturnType<typeof authTokens>>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(
  options: {
    query: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof authTokens>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useAuthTokensSuspense<
  TData = Awaited<ReturnType<typeof authTokens>>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof authTokens>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useAuthTokensSuspense<
  TData = Awaited<ReturnType<typeof authTokens>>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof authTokens>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get user's active sessions and tokens
 */

export function useAuthTokensSuspense<
  TData = Awaited<ReturnType<typeof authTokens>>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof authTokens>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getAuthTokensSuspenseQueryOptions(options);

  const query = useSuspenseQuery(
    queryOptions,
    queryClient
  ) as UseSuspenseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getAuthTokensSuspenseInfiniteQueryOptions = <
  TData = InfiniteData<Awaited<ReturnType<typeof authTokens>>>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(options?: {
  query?: Partial<
    UseSuspenseInfiniteQueryOptions<
      Awaited<ReturnType<typeof authTokens>>,
      TError,
      TData
    >
  >;
  request?: SecondParameter<typeof customInstance>;
}) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getAuthTokensQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof authTokens>>> = ({
    signal,
  }) => authTokens(requestOptions, signal);

  return {
    queryKey,
    queryFn,
    ...queryOptions,
  } as UseSuspenseInfiniteQueryOptions<
    Awaited<ReturnType<typeof authTokens>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type AuthTokensSuspenseInfiniteQueryResult = NonNullable<
  Awaited<ReturnType<typeof authTokens>>
>;
export type AuthTokensSuspenseInfiniteQueryError =
  ErrorType<AuthenticationExceptionResponse>;

export function useAuthTokensSuspenseInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof authTokens>>>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(
  options: {
    query: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof authTokens>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useAuthTokensSuspenseInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof authTokens>>>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof authTokens>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useAuthTokensSuspenseInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof authTokens>>>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof authTokens>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get user's active sessions and tokens
 */

export function useAuthTokensSuspenseInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof authTokens>>>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof authTokens>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getAuthTokensSuspenseInfiniteQueryOptions(options);

  const query = useSuspenseInfiniteQuery(
    queryOptions,
    queryClient
  ) as UseSuspenseInfiniteQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Revokes all active tokens except the current session. Useful for security
purposes when user wants to log out all other devices.
 * @summary Revoke all sessions except current
 */
export const authTokensRevokeAll = (
  options?: SecondParameter<typeof customInstance>
) => {
  return customInstance<AuthTokensRevokeAll200>(
    { url: `/api/auth/tokens`, method: "DELETE" },
    options
  );
};

export const getAuthTokensRevokeAllMutationOptions = <
  TError = ErrorType<AuthenticationExceptionResponse>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof authTokensRevokeAll>>,
    TError,
    void,
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof authTokensRevokeAll>>,
  TError,
  void,
  TContext
> => {
  const mutationKey = ["authTokensRevokeAll"];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof authTokensRevokeAll>>,
    void
  > = () => {
    return authTokensRevokeAll(requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type AuthTokensRevokeAllMutationResult = NonNullable<
  Awaited<ReturnType<typeof authTokensRevokeAll>>
>;

export type AuthTokensRevokeAllMutationError =
  ErrorType<AuthenticationExceptionResponse>;

/**
 * @summary Revoke all sessions except current
 */
export const useAuthTokensRevokeAll = <
  TError = ErrorType<AuthenticationExceptionResponse>,
  TContext = unknown
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof authTokensRevokeAll>>,
      TError,
      void,
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof authTokensRevokeAll>>,
  TError,
  void,
  TContext
> => {
  const mutationOptions = getAuthTokensRevokeAllMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
/**
 * Permanently revokes a specific token, ending that session. Cannot be used
to revoke the current session - use logout endpoint instead.
 * @summary Revoke a specific token/session
 */
export const authTokensRevoke = (
  tokenId: string,
  options?: SecondParameter<typeof customInstance>
) => {
  return customInstance<AuthTokensRevoke200>(
    { url: `/api/auth/tokens/${tokenId}`, method: "DELETE" },
    options
  );
};

export const getAuthTokensRevokeMutationOptions = <
  TError = ErrorType<
    | AuthenticationExceptionResponse
    | ModelNotFoundExceptionResponse
    | ValidationExceptionResponse
  >,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof authTokensRevoke>>,
    TError,
    { tokenId: string },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof authTokensRevoke>>,
  TError,
  { tokenId: string },
  TContext
> => {
  const mutationKey = ["authTokensRevoke"];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof authTokensRevoke>>,
    { tokenId: string }
  > = (props) => {
    const { tokenId } = props ?? {};

    return authTokensRevoke(tokenId, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type AuthTokensRevokeMutationResult = NonNullable<
  Awaited<ReturnType<typeof authTokensRevoke>>
>;

export type AuthTokensRevokeMutationError = ErrorType<
  | AuthenticationExceptionResponse
  | ModelNotFoundExceptionResponse
  | ValidationExceptionResponse
>;

/**
 * @summary Revoke a specific token/session
 */
export const useAuthTokensRevoke = <
  TError = ErrorType<
    | AuthenticationExceptionResponse
    | ModelNotFoundExceptionResponse
    | ValidationExceptionResponse
  >,
  TContext = unknown
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof authTokensRevoke>>,
      TError,
      { tokenId: string },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof authTokensRevoke>>,
  TError,
  { tokenId: string },
  TContext
> => {
  const mutationOptions = getAuthTokensRevokeMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
/**
 * Sends a password reset link to the specified email address if a user
account exists. The link contains a secure token for verification.
 * @summary Request a password-reset link
 */
export const authForgotPassword = (
  forgotPasswordRequest: BodyType<ForgotPasswordRequest>,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal
) => {
  return customInstance<AuthForgotPassword200>(
    {
      url: `/api/auth/forgotPassword`,
      method: "POST",
      headers: { "Content-Type": "application/json" },
      data: forgotPasswordRequest,
      signal,
    },
    options
  );
};

export const getAuthForgotPasswordMutationOptions = <
  TError = ErrorType<
    ModelNotFoundExceptionResponse | ValidationExceptionResponse
  >,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof authForgotPassword>>,
    TError,
    { data: BodyType<ForgotPasswordRequest> },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof authForgotPassword>>,
  TError,
  { data: BodyType<ForgotPasswordRequest> },
  TContext
> => {
  const mutationKey = ["authForgotPassword"];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof authForgotPassword>>,
    { data: BodyType<ForgotPasswordRequest> }
  > = (props) => {
    const { data } = props ?? {};

    return authForgotPassword(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type AuthForgotPasswordMutationResult = NonNullable<
  Awaited<ReturnType<typeof authForgotPassword>>
>;
export type AuthForgotPasswordMutationBody = BodyType<ForgotPasswordRequest>;
export type AuthForgotPasswordMutationError = ErrorType<
  ModelNotFoundExceptionResponse | ValidationExceptionResponse
>;

/**
 * @summary Request a password-reset link
 */
export const useAuthForgotPassword = <
  TError = ErrorType<
    ModelNotFoundExceptionResponse | ValidationExceptionResponse
  >,
  TContext = unknown
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof authForgotPassword>>,
      TError,
      { data: BodyType<ForgotPasswordRequest> },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof authForgotPassword>>,
  TError,
  { data: BodyType<ForgotPasswordRequest> },
  TContext
> => {
  const mutationOptions = getAuthForgotPasswordMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
/**
 * Resets the user's password using a valid reset token. All existing
tokens are revoked for security after a password change.
 * @summary Reset user password
 */
export const authResetPassword = (
  resetPasswordRequest: BodyType<ResetPasswordRequest>,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal
) => {
  return customInstance<AuthResetPassword200>(
    {
      url: `/api/auth/resetPassword`,
      method: "POST",
      headers: { "Content-Type": "application/json" },
      data: resetPasswordRequest,
      signal,
    },
    options
  );
};

export const getAuthResetPasswordMutationOptions = <
  TError = ErrorType<
    | AuthResetPassword400
    | ModelNotFoundExceptionResponse
    | ValidationExceptionResponse
  >,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof authResetPassword>>,
    TError,
    { data: BodyType<ResetPasswordRequest> },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof authResetPassword>>,
  TError,
  { data: BodyType<ResetPasswordRequest> },
  TContext
> => {
  const mutationKey = ["authResetPassword"];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof authResetPassword>>,
    { data: BodyType<ResetPasswordRequest> }
  > = (props) => {
    const { data } = props ?? {};

    return authResetPassword(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type AuthResetPasswordMutationResult = NonNullable<
  Awaited<ReturnType<typeof authResetPassword>>
>;
export type AuthResetPasswordMutationBody = BodyType<ResetPasswordRequest>;
export type AuthResetPasswordMutationError = ErrorType<
  | AuthResetPassword400
  | ModelNotFoundExceptionResponse
  | ValidationExceptionResponse
>;

/**
 * @summary Reset user password
 */
export const useAuthResetPassword = <
  TError = ErrorType<
    | AuthResetPassword400
    | ModelNotFoundExceptionResponse
    | ValidationExceptionResponse
  >,
  TContext = unknown
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof authResetPassword>>,
      TError,
      { data: BodyType<ResetPasswordRequest> },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof authResetPassword>>,
  TError,
  { data: BodyType<ResetPasswordRequest> },
  TContext
> => {
  const mutationOptions = getAuthResetPasswordMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
/**
 * Verifies a user's email address using the verification link sent during
registration or email change. Marks the email as verified.
 * @summary Verify the user email address
 */
export const authVerifyEmail = (
  id: number,
  hash: string,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal
) => {
  return customInstance<UserResource>(
    { url: `/api/auth/verify/${id}/${hash}`, method: "POST", signal },
    options
  );
};

export const getAuthVerifyEmailMutationOptions = <
  TError = ErrorType<ModelNotFoundExceptionResponse>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof authVerifyEmail>>,
    TError,
    { id: number; hash: string },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof authVerifyEmail>>,
  TError,
  { id: number; hash: string },
  TContext
> => {
  const mutationKey = ["authVerifyEmail"];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof authVerifyEmail>>,
    { id: number; hash: string }
  > = (props) => {
    const { id, hash } = props ?? {};

    return authVerifyEmail(id, hash, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type AuthVerifyEmailMutationResult = NonNullable<
  Awaited<ReturnType<typeof authVerifyEmail>>
>;

export type AuthVerifyEmailMutationError =
  ErrorType<ModelNotFoundExceptionResponse>;

/**
 * @summary Verify the user email address
 */
export const useAuthVerifyEmail = <
  TError = ErrorType<ModelNotFoundExceptionResponse>,
  TContext = unknown
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof authVerifyEmail>>,
      TError,
      { id: number; hash: string },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof authVerifyEmail>>,
  TError,
  { id: number; hash: string },
  TContext
> => {
  const mutationOptions = getAuthVerifyEmailMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
/**
 * Revokes the current access and refresh tokens, effectively logging out
the user from the current session/device.
 * @summary Log out the current session
 */
export const authLogout = (
  logoutRequest: BodyType<LogoutRequest>,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal
) => {
  return customInstance<null>(
    {
      url: `/api/auth/logout`,
      method: "POST",
      headers: { "Content-Type": "application/json" },
      data: logoutRequest,
      signal,
    },
    options
  );
};

export const getAuthLogoutMutationOptions = <
  TError = ErrorType<
    AuthenticationExceptionResponse | ValidationExceptionResponse
  >,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof authLogout>>,
    TError,
    { data: BodyType<LogoutRequest> },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof authLogout>>,
  TError,
  { data: BodyType<LogoutRequest> },
  TContext
> => {
  const mutationKey = ["authLogout"];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof authLogout>>,
    { data: BodyType<LogoutRequest> }
  > = (props) => {
    const { data } = props ?? {};

    return authLogout(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type AuthLogoutMutationResult = NonNullable<
  Awaited<ReturnType<typeof authLogout>>
>;
export type AuthLogoutMutationBody = BodyType<LogoutRequest>;
export type AuthLogoutMutationError = ErrorType<
  AuthenticationExceptionResponse | ValidationExceptionResponse
>;

/**
 * @summary Log out the current session
 */
export const useAuthLogout = <
  TError = ErrorType<
    AuthenticationExceptionResponse | ValidationExceptionResponse
  >,
  TContext = unknown
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof authLogout>>,
      TError,
      { data: BodyType<LogoutRequest> },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof authLogout>>,
  TError,
  { data: BodyType<LogoutRequest> },
  TContext
> => {
  const mutationOptions = getAuthLogoutMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
/**
 * Creates a cryptographic challenge for passkey authentication including
allowed credentials and relying party information. This challenge must
be used with the WebAuthn JavaScript API for authentication.
 * @summary Generate WebAuthn authentication challenge
 */
export const authPasskeyOptions = (
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal
) => {
  return customInstance<AuthPasskeyOptions200>(
    { url: `/webauthn/passkey`, method: "GET", signal },
    options
  );
};

export const getAuthPasskeyOptionsQueryKey = () => {
  return [`/webauthn/passkey`] as const;
};

export const getAuthPasskeyOptionsInfiniteQueryOptions = <
  TData = InfiniteData<Awaited<ReturnType<typeof authPasskeyOptions>>>,
  TError = ErrorType<unknown>
>(options?: {
  query?: Partial<
    UseInfiniteQueryOptions<
      Awaited<ReturnType<typeof authPasskeyOptions>>,
      TError,
      TData
    >
  >;
  request?: SecondParameter<typeof customInstance>;
}) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getAuthPasskeyOptionsQueryKey();

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof authPasskeyOptions>>
  > = ({ signal }) => authPasskeyOptions(requestOptions, signal);

  return { queryKey, queryFn, ...queryOptions } as UseInfiniteQueryOptions<
    Awaited<ReturnType<typeof authPasskeyOptions>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type AuthPasskeyOptionsInfiniteQueryResult = NonNullable<
  Awaited<ReturnType<typeof authPasskeyOptions>>
>;
export type AuthPasskeyOptionsInfiniteQueryError = ErrorType<unknown>;

export function useAuthPasskeyOptionsInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof authPasskeyOptions>>>,
  TError = ErrorType<unknown>
>(
  options: {
    query: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof authPasskeyOptions>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof authPasskeyOptions>>,
          TError,
          Awaited<ReturnType<typeof authPasskeyOptions>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): DefinedUseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useAuthPasskeyOptionsInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof authPasskeyOptions>>>,
  TError = ErrorType<unknown>
>(
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof authPasskeyOptions>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof authPasskeyOptions>>,
          TError,
          Awaited<ReturnType<typeof authPasskeyOptions>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useAuthPasskeyOptionsInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof authPasskeyOptions>>>,
  TError = ErrorType<unknown>
>(
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof authPasskeyOptions>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Generate WebAuthn authentication challenge
 */

export function useAuthPasskeyOptionsInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof authPasskeyOptions>>>,
  TError = ErrorType<unknown>
>(
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof authPasskeyOptions>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getAuthPasskeyOptionsInfiniteQueryOptions(options);

  const query = useInfiniteQuery(
    queryOptions,
    queryClient
  ) as UseInfiniteQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getAuthPasskeyOptionsQueryOptions = <
  TData = Awaited<ReturnType<typeof authPasskeyOptions>>,
  TError = ErrorType<unknown>
>(options?: {
  query?: Partial<
    UseQueryOptions<
      Awaited<ReturnType<typeof authPasskeyOptions>>,
      TError,
      TData
    >
  >;
  request?: SecondParameter<typeof customInstance>;
}) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getAuthPasskeyOptionsQueryKey();

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof authPasskeyOptions>>
  > = ({ signal }) => authPasskeyOptions(requestOptions, signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof authPasskeyOptions>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type AuthPasskeyOptionsQueryResult = NonNullable<
  Awaited<ReturnType<typeof authPasskeyOptions>>
>;
export type AuthPasskeyOptionsQueryError = ErrorType<unknown>;

export function useAuthPasskeyOptions<
  TData = Awaited<ReturnType<typeof authPasskeyOptions>>,
  TError = ErrorType<unknown>
>(
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof authPasskeyOptions>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof authPasskeyOptions>>,
          TError,
          Awaited<ReturnType<typeof authPasskeyOptions>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useAuthPasskeyOptions<
  TData = Awaited<ReturnType<typeof authPasskeyOptions>>,
  TError = ErrorType<unknown>
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof authPasskeyOptions>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof authPasskeyOptions>>,
          TError,
          Awaited<ReturnType<typeof authPasskeyOptions>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useAuthPasskeyOptions<
  TData = Awaited<ReturnType<typeof authPasskeyOptions>>,
  TError = ErrorType<unknown>
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof authPasskeyOptions>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Generate WebAuthn authentication challenge
 */

export function useAuthPasskeyOptions<
  TData = Awaited<ReturnType<typeof authPasskeyOptions>>,
  TError = ErrorType<unknown>
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof authPasskeyOptions>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getAuthPasskeyOptionsQueryOptions(options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getAuthPasskeyOptionsSuspenseQueryOptions = <
  TData = Awaited<ReturnType<typeof authPasskeyOptions>>,
  TError = ErrorType<unknown>
>(options?: {
  query?: Partial<
    UseSuspenseQueryOptions<
      Awaited<ReturnType<typeof authPasskeyOptions>>,
      TError,
      TData
    >
  >;
  request?: SecondParameter<typeof customInstance>;
}) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getAuthPasskeyOptionsQueryKey();

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof authPasskeyOptions>>
  > = ({ signal }) => authPasskeyOptions(requestOptions, signal);

  return { queryKey, queryFn, ...queryOptions } as UseSuspenseQueryOptions<
    Awaited<ReturnType<typeof authPasskeyOptions>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type AuthPasskeyOptionsSuspenseQueryResult = NonNullable<
  Awaited<ReturnType<typeof authPasskeyOptions>>
>;
export type AuthPasskeyOptionsSuspenseQueryError = ErrorType<unknown>;

export function useAuthPasskeyOptionsSuspense<
  TData = Awaited<ReturnType<typeof authPasskeyOptions>>,
  TError = ErrorType<unknown>
>(
  options: {
    query: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof authPasskeyOptions>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useAuthPasskeyOptionsSuspense<
  TData = Awaited<ReturnType<typeof authPasskeyOptions>>,
  TError = ErrorType<unknown>
>(
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof authPasskeyOptions>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useAuthPasskeyOptionsSuspense<
  TData = Awaited<ReturnType<typeof authPasskeyOptions>>,
  TError = ErrorType<unknown>
>(
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof authPasskeyOptions>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Generate WebAuthn authentication challenge
 */

export function useAuthPasskeyOptionsSuspense<
  TData = Awaited<ReturnType<typeof authPasskeyOptions>>,
  TError = ErrorType<unknown>
>(
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof authPasskeyOptions>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getAuthPasskeyOptionsSuspenseQueryOptions(options);

  const query = useSuspenseQuery(
    queryOptions,
    queryClient
  ) as UseSuspenseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getAuthPasskeyOptionsSuspenseInfiniteQueryOptions = <
  TData = InfiniteData<Awaited<ReturnType<typeof authPasskeyOptions>>>,
  TError = ErrorType<unknown>
>(options?: {
  query?: Partial<
    UseSuspenseInfiniteQueryOptions<
      Awaited<ReturnType<typeof authPasskeyOptions>>,
      TError,
      TData
    >
  >;
  request?: SecondParameter<typeof customInstance>;
}) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getAuthPasskeyOptionsQueryKey();

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof authPasskeyOptions>>
  > = ({ signal }) => authPasskeyOptions(requestOptions, signal);

  return {
    queryKey,
    queryFn,
    ...queryOptions,
  } as UseSuspenseInfiniteQueryOptions<
    Awaited<ReturnType<typeof authPasskeyOptions>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type AuthPasskeyOptionsSuspenseInfiniteQueryResult = NonNullable<
  Awaited<ReturnType<typeof authPasskeyOptions>>
>;
export type AuthPasskeyOptionsSuspenseInfiniteQueryError = ErrorType<unknown>;

export function useAuthPasskeyOptionsSuspenseInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof authPasskeyOptions>>>,
  TError = ErrorType<unknown>
>(
  options: {
    query: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof authPasskeyOptions>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useAuthPasskeyOptionsSuspenseInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof authPasskeyOptions>>>,
  TError = ErrorType<unknown>
>(
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof authPasskeyOptions>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useAuthPasskeyOptionsSuspenseInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof authPasskeyOptions>>>,
  TError = ErrorType<unknown>
>(
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof authPasskeyOptions>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Generate WebAuthn authentication challenge
 */

export function useAuthPasskeyOptionsSuspenseInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof authPasskeyOptions>>>,
  TError = ErrorType<unknown>
>(
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof authPasskeyOptions>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions =
    getAuthPasskeyOptionsSuspenseInfiniteQueryOptions(options);

  const query = useSuspenseInfiniteQuery(
    queryOptions,
    queryClient
  ) as UseSuspenseInfiniteQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Verifies the WebAuthn assertion from the user's authenticator and logs them in
if successful. Creates session tokens and handles redirect logic for seamless
authentication experience.
 * @summary Authenticate using WebAuthn passkey
 */
export const authPasskeyLogin = (
  authenticateUsingPasskeyRequest: BodyType<AuthenticateUsingPasskeyRequest>,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal
) => {
  return customInstance<AuthPasskeyLogin200>(
    {
      url: `/webauthn/passkey`,
      method: "POST",
      headers: { "Content-Type": "application/json" },
      data: authenticateUsingPasskeyRequest,
      signal,
    },
    options
  );
};

export const getAuthPasskeyLoginMutationOptions = <
  TError = ErrorType<ValidationExceptionResponse>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof authPasskeyLogin>>,
    TError,
    { data: BodyType<AuthenticateUsingPasskeyRequest> },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof authPasskeyLogin>>,
  TError,
  { data: BodyType<AuthenticateUsingPasskeyRequest> },
  TContext
> => {
  const mutationKey = ["authPasskeyLogin"];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof authPasskeyLogin>>,
    { data: BodyType<AuthenticateUsingPasskeyRequest> }
  > = (props) => {
    const { data } = props ?? {};

    return authPasskeyLogin(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type AuthPasskeyLoginMutationResult = NonNullable<
  Awaited<ReturnType<typeof authPasskeyLogin>>
>;
export type AuthPasskeyLoginMutationBody =
  BodyType<AuthenticateUsingPasskeyRequest>;
export type AuthPasskeyLoginMutationError =
  ErrorType<ValidationExceptionResponse>;

/**
 * @summary Authenticate using WebAuthn passkey
 */
export const useAuthPasskeyLogin = <
  TError = ErrorType<ValidationExceptionResponse>,
  TContext = unknown
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof authPasskeyLogin>>,
      TError,
      { data: BodyType<AuthenticateUsingPasskeyRequest> },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof authPasskeyLogin>>,
  TError,
  { data: BodyType<AuthenticateUsingPasskeyRequest> },
  TContext
> => {
  const mutationOptions = getAuthPasskeyLoginMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
/**
 * Creates a cryptographic challenge for registering a new passkey to the
authenticated user's account. The challenge includes user information
and credential creation parameters.
 * @summary Generate WebAuthn registration challenge for new passkey
 */
export const authPasskeyRegisterOption = (
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal
) => {
  return customInstance<AuthPasskeyRegisterOption200>(
    { url: `/webauthn/passkey/register`, method: "GET", signal },
    options
  );
};

export const getAuthPasskeyRegisterOptionQueryKey = () => {
  return [`/webauthn/passkey/register`] as const;
};

export const getAuthPasskeyRegisterOptionInfiniteQueryOptions = <
  TData = InfiniteData<Awaited<ReturnType<typeof authPasskeyRegisterOption>>>,
  TError = ErrorType<
    AuthenticationExceptionResponse | AuthorizationExceptionResponse
  >
>(options?: {
  query?: Partial<
    UseInfiniteQueryOptions<
      Awaited<ReturnType<typeof authPasskeyRegisterOption>>,
      TError,
      TData
    >
  >;
  request?: SecondParameter<typeof customInstance>;
}) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getAuthPasskeyRegisterOptionQueryKey();

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof authPasskeyRegisterOption>>
  > = ({ signal }) => authPasskeyRegisterOption(requestOptions, signal);

  return { queryKey, queryFn, ...queryOptions } as UseInfiniteQueryOptions<
    Awaited<ReturnType<typeof authPasskeyRegisterOption>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type AuthPasskeyRegisterOptionInfiniteQueryResult = NonNullable<
  Awaited<ReturnType<typeof authPasskeyRegisterOption>>
>;
export type AuthPasskeyRegisterOptionInfiniteQueryError = ErrorType<
  AuthenticationExceptionResponse | AuthorizationExceptionResponse
>;

export function useAuthPasskeyRegisterOptionInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof authPasskeyRegisterOption>>>,
  TError = ErrorType<
    AuthenticationExceptionResponse | AuthorizationExceptionResponse
  >
>(
  options: {
    query: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof authPasskeyRegisterOption>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof authPasskeyRegisterOption>>,
          TError,
          Awaited<ReturnType<typeof authPasskeyRegisterOption>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): DefinedUseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useAuthPasskeyRegisterOptionInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof authPasskeyRegisterOption>>>,
  TError = ErrorType<
    AuthenticationExceptionResponse | AuthorizationExceptionResponse
  >
>(
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof authPasskeyRegisterOption>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof authPasskeyRegisterOption>>,
          TError,
          Awaited<ReturnType<typeof authPasskeyRegisterOption>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useAuthPasskeyRegisterOptionInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof authPasskeyRegisterOption>>>,
  TError = ErrorType<
    AuthenticationExceptionResponse | AuthorizationExceptionResponse
  >
>(
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof authPasskeyRegisterOption>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Generate WebAuthn registration challenge for new passkey
 */

export function useAuthPasskeyRegisterOptionInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof authPasskeyRegisterOption>>>,
  TError = ErrorType<
    AuthenticationExceptionResponse | AuthorizationExceptionResponse
  >
>(
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof authPasskeyRegisterOption>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions =
    getAuthPasskeyRegisterOptionInfiniteQueryOptions(options);

  const query = useInfiniteQuery(
    queryOptions,
    queryClient
  ) as UseInfiniteQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getAuthPasskeyRegisterOptionQueryOptions = <
  TData = Awaited<ReturnType<typeof authPasskeyRegisterOption>>,
  TError = ErrorType<
    AuthenticationExceptionResponse | AuthorizationExceptionResponse
  >
>(options?: {
  query?: Partial<
    UseQueryOptions<
      Awaited<ReturnType<typeof authPasskeyRegisterOption>>,
      TError,
      TData
    >
  >;
  request?: SecondParameter<typeof customInstance>;
}) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getAuthPasskeyRegisterOptionQueryKey();

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof authPasskeyRegisterOption>>
  > = ({ signal }) => authPasskeyRegisterOption(requestOptions, signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof authPasskeyRegisterOption>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type AuthPasskeyRegisterOptionQueryResult = NonNullable<
  Awaited<ReturnType<typeof authPasskeyRegisterOption>>
>;
export type AuthPasskeyRegisterOptionQueryError = ErrorType<
  AuthenticationExceptionResponse | AuthorizationExceptionResponse
>;

export function useAuthPasskeyRegisterOption<
  TData = Awaited<ReturnType<typeof authPasskeyRegisterOption>>,
  TError = ErrorType<
    AuthenticationExceptionResponse | AuthorizationExceptionResponse
  >
>(
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof authPasskeyRegisterOption>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof authPasskeyRegisterOption>>,
          TError,
          Awaited<ReturnType<typeof authPasskeyRegisterOption>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useAuthPasskeyRegisterOption<
  TData = Awaited<ReturnType<typeof authPasskeyRegisterOption>>,
  TError = ErrorType<
    AuthenticationExceptionResponse | AuthorizationExceptionResponse
  >
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof authPasskeyRegisterOption>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof authPasskeyRegisterOption>>,
          TError,
          Awaited<ReturnType<typeof authPasskeyRegisterOption>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useAuthPasskeyRegisterOption<
  TData = Awaited<ReturnType<typeof authPasskeyRegisterOption>>,
  TError = ErrorType<
    AuthenticationExceptionResponse | AuthorizationExceptionResponse
  >
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof authPasskeyRegisterOption>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Generate WebAuthn registration challenge for new passkey
 */

export function useAuthPasskeyRegisterOption<
  TData = Awaited<ReturnType<typeof authPasskeyRegisterOption>>,
  TError = ErrorType<
    AuthenticationExceptionResponse | AuthorizationExceptionResponse
  >
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof authPasskeyRegisterOption>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getAuthPasskeyRegisterOptionQueryOptions(options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getAuthPasskeyRegisterOptionSuspenseQueryOptions = <
  TData = Awaited<ReturnType<typeof authPasskeyRegisterOption>>,
  TError = ErrorType<
    AuthenticationExceptionResponse | AuthorizationExceptionResponse
  >
>(options?: {
  query?: Partial<
    UseSuspenseQueryOptions<
      Awaited<ReturnType<typeof authPasskeyRegisterOption>>,
      TError,
      TData
    >
  >;
  request?: SecondParameter<typeof customInstance>;
}) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getAuthPasskeyRegisterOptionQueryKey();

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof authPasskeyRegisterOption>>
  > = ({ signal }) => authPasskeyRegisterOption(requestOptions, signal);

  return { queryKey, queryFn, ...queryOptions } as UseSuspenseQueryOptions<
    Awaited<ReturnType<typeof authPasskeyRegisterOption>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type AuthPasskeyRegisterOptionSuspenseQueryResult = NonNullable<
  Awaited<ReturnType<typeof authPasskeyRegisterOption>>
>;
export type AuthPasskeyRegisterOptionSuspenseQueryError = ErrorType<
  AuthenticationExceptionResponse | AuthorizationExceptionResponse
>;

export function useAuthPasskeyRegisterOptionSuspense<
  TData = Awaited<ReturnType<typeof authPasskeyRegisterOption>>,
  TError = ErrorType<
    AuthenticationExceptionResponse | AuthorizationExceptionResponse
  >
>(
  options: {
    query: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof authPasskeyRegisterOption>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useAuthPasskeyRegisterOptionSuspense<
  TData = Awaited<ReturnType<typeof authPasskeyRegisterOption>>,
  TError = ErrorType<
    AuthenticationExceptionResponse | AuthorizationExceptionResponse
  >
>(
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof authPasskeyRegisterOption>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useAuthPasskeyRegisterOptionSuspense<
  TData = Awaited<ReturnType<typeof authPasskeyRegisterOption>>,
  TError = ErrorType<
    AuthenticationExceptionResponse | AuthorizationExceptionResponse
  >
>(
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof authPasskeyRegisterOption>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Generate WebAuthn registration challenge for new passkey
 */

export function useAuthPasskeyRegisterOptionSuspense<
  TData = Awaited<ReturnType<typeof authPasskeyRegisterOption>>,
  TError = ErrorType<
    AuthenticationExceptionResponse | AuthorizationExceptionResponse
  >
>(
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof authPasskeyRegisterOption>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions =
    getAuthPasskeyRegisterOptionSuspenseQueryOptions(options);

  const query = useSuspenseQuery(
    queryOptions,
    queryClient
  ) as UseSuspenseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getAuthPasskeyRegisterOptionSuspenseInfiniteQueryOptions = <
  TData = InfiniteData<Awaited<ReturnType<typeof authPasskeyRegisterOption>>>,
  TError = ErrorType<
    AuthenticationExceptionResponse | AuthorizationExceptionResponse
  >
>(options?: {
  query?: Partial<
    UseSuspenseInfiniteQueryOptions<
      Awaited<ReturnType<typeof authPasskeyRegisterOption>>,
      TError,
      TData
    >
  >;
  request?: SecondParameter<typeof customInstance>;
}) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getAuthPasskeyRegisterOptionQueryKey();

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof authPasskeyRegisterOption>>
  > = ({ signal }) => authPasskeyRegisterOption(requestOptions, signal);

  return {
    queryKey,
    queryFn,
    ...queryOptions,
  } as UseSuspenseInfiniteQueryOptions<
    Awaited<ReturnType<typeof authPasskeyRegisterOption>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type AuthPasskeyRegisterOptionSuspenseInfiniteQueryResult = NonNullable<
  Awaited<ReturnType<typeof authPasskeyRegisterOption>>
>;
export type AuthPasskeyRegisterOptionSuspenseInfiniteQueryError = ErrorType<
  AuthenticationExceptionResponse | AuthorizationExceptionResponse
>;

export function useAuthPasskeyRegisterOptionSuspenseInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof authPasskeyRegisterOption>>>,
  TError = ErrorType<
    AuthenticationExceptionResponse | AuthorizationExceptionResponse
  >
>(
  options: {
    query: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof authPasskeyRegisterOption>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useAuthPasskeyRegisterOptionSuspenseInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof authPasskeyRegisterOption>>>,
  TError = ErrorType<
    AuthenticationExceptionResponse | AuthorizationExceptionResponse
  >
>(
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof authPasskeyRegisterOption>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useAuthPasskeyRegisterOptionSuspenseInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof authPasskeyRegisterOption>>>,
  TError = ErrorType<
    AuthenticationExceptionResponse | AuthorizationExceptionResponse
  >
>(
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof authPasskeyRegisterOption>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Generate WebAuthn registration challenge for new passkey
 */

export function useAuthPasskeyRegisterOptionSuspenseInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof authPasskeyRegisterOption>>>,
  TError = ErrorType<
    AuthenticationExceptionResponse | AuthorizationExceptionResponse
  >
>(
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof authPasskeyRegisterOption>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions =
    getAuthPasskeyRegisterOptionSuspenseInfiniteQueryOptions(options);

  const query = useSuspenseInfiniteQuery(
    queryOptions,
    queryClient
  ) as UseSuspenseInfiniteQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Processes the WebAuthn attestation response to register a new passkey
credential for the user's account. Includes validation and secure storage
of the credential with optional naming.
 * @summary Register a new passkey for the authenticated user
 */
export const authPasskeyRegister = (
  storePasskeyRequest: BodyType<StorePasskeyRequest>,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal
) => {
  return customInstance<AuthPasskeyRegister200>(
    {
      url: `/webauthn/passkey/register`,
      method: "POST",
      headers: { "Content-Type": "application/json" },
      data: storePasskeyRequest,
      signal,
    },
    options
  );
};

export const getAuthPasskeyRegisterMutationOptions = <
  TError = ErrorType<
    | AuthenticationExceptionResponse
    | AuthorizationExceptionResponse
    | ValidationExceptionResponse
  >,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof authPasskeyRegister>>,
    TError,
    { data: BodyType<StorePasskeyRequest> },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof authPasskeyRegister>>,
  TError,
  { data: BodyType<StorePasskeyRequest> },
  TContext
> => {
  const mutationKey = ["authPasskeyRegister"];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof authPasskeyRegister>>,
    { data: BodyType<StorePasskeyRequest> }
  > = (props) => {
    const { data } = props ?? {};

    return authPasskeyRegister(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type AuthPasskeyRegisterMutationResult = NonNullable<
  Awaited<ReturnType<typeof authPasskeyRegister>>
>;
export type AuthPasskeyRegisterMutationBody = BodyType<StorePasskeyRequest>;
export type AuthPasskeyRegisterMutationError = ErrorType<
  | AuthenticationExceptionResponse
  | AuthorizationExceptionResponse
  | ValidationExceptionResponse
>;

/**
 * @summary Register a new passkey for the authenticated user
 */
export const useAuthPasskeyRegister = <
  TError = ErrorType<
    | AuthenticationExceptionResponse
    | AuthorizationExceptionResponse
    | ValidationExceptionResponse
  >,
  TContext = unknown
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof authPasskeyRegister>>,
      TError,
      { data: BodyType<StorePasskeyRequest> },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof authPasskeyRegister>>,
  TError,
  { data: BodyType<StorePasskeyRequest> },
  TContext
> => {
  const mutationOptions = getAuthPasskeyRegisterMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
