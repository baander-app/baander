/**
 * Generated by orval v7.11.2 üç∫
 * Do not edit manually.
 * B√•nder api docs
 * B√•nder.App is a sophisticated media server developed with the primary goal to deliver high performance and seamless experience for users.
Being built on top of Laravel framework and PostgreSQL for database, it leverages the power of robust backend technologies, providing high security, reliability, and scalability.

The main focus of B√•nder.App is efficient media management and delivery.
This application is designed to handle large amounts of media files while ensuring quick and efficient access.
Implemented queuing functionality through Redis offers efficient job management and load handling.
The media information is organized and easily searchable, ensuring users can always find what they are looking for quickly and easily.
 * OpenAPI spec version: 0.0.1
 */
import {
  useInfiniteQuery,
  useMutation,
  useQuery,
  useSuspenseInfiniteQuery,
  useSuspenseQuery,
} from "@tanstack/react-query";
import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseInfiniteQueryResult,
  DefinedUseQueryResult,
  InfiniteData,
  MutationFunction,
  QueryClient,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseInfiniteQueryOptions,
  UseInfiniteQueryResult,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult,
  UseSuspenseInfiniteQueryOptions,
  UseSuspenseInfiniteQueryResult,
  UseSuspenseQueryOptions,
  UseSuspenseQueryResult,
} from "@tanstack/react-query";

import type {
  AuthenticationExceptionResponse,
  LastfmAuthorize200,
  LastfmAuthorize500,
  LastfmCallback200,
  LastfmCallback400,
  LastfmCallback500,
  LastfmCallbackParams,
  LastfmDisconnect200,
  LastfmStatus200,
} from "../../models";

import { customInstance } from "../../../axios-instance";
import type { ErrorType } from "../../../axios-instance";

type SecondParameter<T extends (...args: never) => unknown> = Parameters<T>[1];

export const lastfmAuthorize = (
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal
) => {
  return customInstance<LastfmAuthorize200>(
    { url: `/api/services/lastfm/authorize`, method: "GET", signal },
    options
  );
};

export const getLastfmAuthorizeQueryKey = () => {
  return [`/api/services/lastfm/authorize`] as const;
};

export const getLastfmAuthorizeInfiniteQueryOptions = <
  TData = InfiniteData<Awaited<ReturnType<typeof lastfmAuthorize>>>,
  TError = ErrorType<AuthenticationExceptionResponse | LastfmAuthorize500>
>(options?: {
  query?: Partial<
    UseInfiniteQueryOptions<
      Awaited<ReturnType<typeof lastfmAuthorize>>,
      TError,
      TData
    >
  >;
  request?: SecondParameter<typeof customInstance>;
}) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getLastfmAuthorizeQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof lastfmAuthorize>>> = ({
    signal,
  }) => lastfmAuthorize(requestOptions, signal);

  return { queryKey, queryFn, ...queryOptions } as UseInfiniteQueryOptions<
    Awaited<ReturnType<typeof lastfmAuthorize>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type LastfmAuthorizeInfiniteQueryResult = NonNullable<
  Awaited<ReturnType<typeof lastfmAuthorize>>
>;
export type LastfmAuthorizeInfiniteQueryError = ErrorType<
  AuthenticationExceptionResponse | LastfmAuthorize500
>;

export function useLastfmAuthorizeInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof lastfmAuthorize>>>,
  TError = ErrorType<AuthenticationExceptionResponse | LastfmAuthorize500>
>(
  options: {
    query: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof lastfmAuthorize>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof lastfmAuthorize>>,
          TError,
          Awaited<ReturnType<typeof lastfmAuthorize>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): DefinedUseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useLastfmAuthorizeInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof lastfmAuthorize>>>,
  TError = ErrorType<AuthenticationExceptionResponse | LastfmAuthorize500>
>(
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof lastfmAuthorize>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof lastfmAuthorize>>,
          TError,
          Awaited<ReturnType<typeof lastfmAuthorize>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useLastfmAuthorizeInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof lastfmAuthorize>>>,
  TError = ErrorType<AuthenticationExceptionResponse | LastfmAuthorize500>
>(
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof lastfmAuthorize>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};

export function useLastfmAuthorizeInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof lastfmAuthorize>>>,
  TError = ErrorType<AuthenticationExceptionResponse | LastfmAuthorize500>
>(
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof lastfmAuthorize>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getLastfmAuthorizeInfiniteQueryOptions(options);

  const query = useInfiniteQuery(
    queryOptions,
    queryClient
  ) as UseInfiniteQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getLastfmAuthorizeQueryOptions = <
  TData = Awaited<ReturnType<typeof lastfmAuthorize>>,
  TError = ErrorType<AuthenticationExceptionResponse | LastfmAuthorize500>
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof lastfmAuthorize>>, TError, TData>
  >;
  request?: SecondParameter<typeof customInstance>;
}) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getLastfmAuthorizeQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof lastfmAuthorize>>> = ({
    signal,
  }) => lastfmAuthorize(requestOptions, signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof lastfmAuthorize>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type LastfmAuthorizeQueryResult = NonNullable<
  Awaited<ReturnType<typeof lastfmAuthorize>>
>;
export type LastfmAuthorizeQueryError = ErrorType<
  AuthenticationExceptionResponse | LastfmAuthorize500
>;

export function useLastfmAuthorize<
  TData = Awaited<ReturnType<typeof lastfmAuthorize>>,
  TError = ErrorType<AuthenticationExceptionResponse | LastfmAuthorize500>
>(
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof lastfmAuthorize>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof lastfmAuthorize>>,
          TError,
          Awaited<ReturnType<typeof lastfmAuthorize>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useLastfmAuthorize<
  TData = Awaited<ReturnType<typeof lastfmAuthorize>>,
  TError = ErrorType<AuthenticationExceptionResponse | LastfmAuthorize500>
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof lastfmAuthorize>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof lastfmAuthorize>>,
          TError,
          Awaited<ReturnType<typeof lastfmAuthorize>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useLastfmAuthorize<
  TData = Awaited<ReturnType<typeof lastfmAuthorize>>,
  TError = ErrorType<AuthenticationExceptionResponse | LastfmAuthorize500>
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof lastfmAuthorize>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};

export function useLastfmAuthorize<
  TData = Awaited<ReturnType<typeof lastfmAuthorize>>,
  TError = ErrorType<AuthenticationExceptionResponse | LastfmAuthorize500>
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof lastfmAuthorize>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getLastfmAuthorizeQueryOptions(options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getLastfmAuthorizeSuspenseQueryOptions = <
  TData = Awaited<ReturnType<typeof lastfmAuthorize>>,
  TError = ErrorType<AuthenticationExceptionResponse | LastfmAuthorize500>
>(options?: {
  query?: Partial<
    UseSuspenseQueryOptions<
      Awaited<ReturnType<typeof lastfmAuthorize>>,
      TError,
      TData
    >
  >;
  request?: SecondParameter<typeof customInstance>;
}) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getLastfmAuthorizeQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof lastfmAuthorize>>> = ({
    signal,
  }) => lastfmAuthorize(requestOptions, signal);

  return { queryKey, queryFn, ...queryOptions } as UseSuspenseQueryOptions<
    Awaited<ReturnType<typeof lastfmAuthorize>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type LastfmAuthorizeSuspenseQueryResult = NonNullable<
  Awaited<ReturnType<typeof lastfmAuthorize>>
>;
export type LastfmAuthorizeSuspenseQueryError = ErrorType<
  AuthenticationExceptionResponse | LastfmAuthorize500
>;

export function useLastfmAuthorizeSuspense<
  TData = Awaited<ReturnType<typeof lastfmAuthorize>>,
  TError = ErrorType<AuthenticationExceptionResponse | LastfmAuthorize500>
>(
  options: {
    query: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof lastfmAuthorize>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useLastfmAuthorizeSuspense<
  TData = Awaited<ReturnType<typeof lastfmAuthorize>>,
  TError = ErrorType<AuthenticationExceptionResponse | LastfmAuthorize500>
>(
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof lastfmAuthorize>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useLastfmAuthorizeSuspense<
  TData = Awaited<ReturnType<typeof lastfmAuthorize>>,
  TError = ErrorType<AuthenticationExceptionResponse | LastfmAuthorize500>
>(
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof lastfmAuthorize>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};

export function useLastfmAuthorizeSuspense<
  TData = Awaited<ReturnType<typeof lastfmAuthorize>>,
  TError = ErrorType<AuthenticationExceptionResponse | LastfmAuthorize500>
>(
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof lastfmAuthorize>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getLastfmAuthorizeSuspenseQueryOptions(options);

  const query = useSuspenseQuery(
    queryOptions,
    queryClient
  ) as UseSuspenseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getLastfmAuthorizeSuspenseInfiniteQueryOptions = <
  TData = InfiniteData<Awaited<ReturnType<typeof lastfmAuthorize>>>,
  TError = ErrorType<AuthenticationExceptionResponse | LastfmAuthorize500>
>(options?: {
  query?: Partial<
    UseSuspenseInfiniteQueryOptions<
      Awaited<ReturnType<typeof lastfmAuthorize>>,
      TError,
      TData
    >
  >;
  request?: SecondParameter<typeof customInstance>;
}) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getLastfmAuthorizeQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof lastfmAuthorize>>> = ({
    signal,
  }) => lastfmAuthorize(requestOptions, signal);

  return {
    queryKey,
    queryFn,
    ...queryOptions,
  } as UseSuspenseInfiniteQueryOptions<
    Awaited<ReturnType<typeof lastfmAuthorize>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type LastfmAuthorizeSuspenseInfiniteQueryResult = NonNullable<
  Awaited<ReturnType<typeof lastfmAuthorize>>
>;
export type LastfmAuthorizeSuspenseInfiniteQueryError = ErrorType<
  AuthenticationExceptionResponse | LastfmAuthorize500
>;

export function useLastfmAuthorizeSuspenseInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof lastfmAuthorize>>>,
  TError = ErrorType<AuthenticationExceptionResponse | LastfmAuthorize500>
>(
  options: {
    query: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof lastfmAuthorize>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useLastfmAuthorizeSuspenseInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof lastfmAuthorize>>>,
  TError = ErrorType<AuthenticationExceptionResponse | LastfmAuthorize500>
>(
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof lastfmAuthorize>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useLastfmAuthorizeSuspenseInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof lastfmAuthorize>>>,
  TError = ErrorType<AuthenticationExceptionResponse | LastfmAuthorize500>
>(
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof lastfmAuthorize>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};

export function useLastfmAuthorizeSuspenseInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof lastfmAuthorize>>>,
  TError = ErrorType<AuthenticationExceptionResponse | LastfmAuthorize500>
>(
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof lastfmAuthorize>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getLastfmAuthorizeSuspenseInfiniteQueryOptions(options);

  const query = useSuspenseInfiniteQuery(
    queryOptions,
    queryClient
  ) as UseSuspenseInfiniteQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const lastfmCallback = (
  params?: LastfmCallbackParams,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal
) => {
  return customInstance<LastfmCallback200>(
    { url: `/api/services/lastfm/callback`, method: "GET", params, signal },
    options
  );
};

export const getLastfmCallbackQueryKey = (params?: LastfmCallbackParams) => {
  return [
    `/api/services/lastfm/callback`,
    ...(params ? [params] : []),
  ] as const;
};

export const getLastfmCallbackInfiniteQueryOptions = <
  TData = InfiniteData<
    Awaited<ReturnType<typeof lastfmCallback>>,
    LastfmCallbackParams["page"]
  >,
  TError = ErrorType<LastfmCallback400 | LastfmCallback500>
>(
  params?: LastfmCallbackParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof lastfmCallback>>,
        TError,
        TData,
        QueryKey,
        LastfmCallbackParams["page"]
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getLastfmCallbackQueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof lastfmCallback>>,
    QueryKey,
    LastfmCallbackParams["page"]
  > = ({ signal, pageParam }) =>
    lastfmCallback(
      { ...params, page: pageParam || params?.["page"] },
      requestOptions,
      signal
    );

  return { queryKey, queryFn, ...queryOptions } as UseInfiniteQueryOptions<
    Awaited<ReturnType<typeof lastfmCallback>>,
    TError,
    TData,
    QueryKey,
    LastfmCallbackParams["page"]
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type LastfmCallbackInfiniteQueryResult = NonNullable<
  Awaited<ReturnType<typeof lastfmCallback>>
>;
export type LastfmCallbackInfiniteQueryError = ErrorType<
  LastfmCallback400 | LastfmCallback500
>;

export function useLastfmCallbackInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof lastfmCallback>>,
    LastfmCallbackParams["page"]
  >,
  TError = ErrorType<LastfmCallback400 | LastfmCallback500>
>(
  params: undefined | LastfmCallbackParams,
  options: {
    query: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof lastfmCallback>>,
        TError,
        TData,
        QueryKey,
        LastfmCallbackParams["page"]
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof lastfmCallback>>,
          TError,
          Awaited<ReturnType<typeof lastfmCallback>>,
          QueryKey
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): DefinedUseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useLastfmCallbackInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof lastfmCallback>>,
    LastfmCallbackParams["page"]
  >,
  TError = ErrorType<LastfmCallback400 | LastfmCallback500>
>(
  params?: LastfmCallbackParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof lastfmCallback>>,
        TError,
        TData,
        QueryKey,
        LastfmCallbackParams["page"]
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof lastfmCallback>>,
          TError,
          Awaited<ReturnType<typeof lastfmCallback>>,
          QueryKey
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useLastfmCallbackInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof lastfmCallback>>,
    LastfmCallbackParams["page"]
  >,
  TError = ErrorType<LastfmCallback400 | LastfmCallback500>
>(
  params?: LastfmCallbackParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof lastfmCallback>>,
        TError,
        TData,
        QueryKey,
        LastfmCallbackParams["page"]
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};

export function useLastfmCallbackInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof lastfmCallback>>,
    LastfmCallbackParams["page"]
  >,
  TError = ErrorType<LastfmCallback400 | LastfmCallback500>
>(
  params?: LastfmCallbackParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof lastfmCallback>>,
        TError,
        TData,
        QueryKey,
        LastfmCallbackParams["page"]
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getLastfmCallbackInfiniteQueryOptions(params, options);

  const query = useInfiniteQuery(
    queryOptions,
    queryClient
  ) as UseInfiniteQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getLastfmCallbackQueryOptions = <
  TData = Awaited<ReturnType<typeof lastfmCallback>>,
  TError = ErrorType<LastfmCallback400 | LastfmCallback500>
>(
  params?: LastfmCallbackParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof lastfmCallback>>, TError, TData>
    >;
    request?: SecondParameter<typeof customInstance>;
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getLastfmCallbackQueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof lastfmCallback>>> = ({
    signal,
  }) => lastfmCallback(params, requestOptions, signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof lastfmCallback>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type LastfmCallbackQueryResult = NonNullable<
  Awaited<ReturnType<typeof lastfmCallback>>
>;
export type LastfmCallbackQueryError = ErrorType<
  LastfmCallback400 | LastfmCallback500
>;

export function useLastfmCallback<
  TData = Awaited<ReturnType<typeof lastfmCallback>>,
  TError = ErrorType<LastfmCallback400 | LastfmCallback500>
>(
  params: undefined | LastfmCallbackParams,
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof lastfmCallback>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof lastfmCallback>>,
          TError,
          Awaited<ReturnType<typeof lastfmCallback>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useLastfmCallback<
  TData = Awaited<ReturnType<typeof lastfmCallback>>,
  TError = ErrorType<LastfmCallback400 | LastfmCallback500>
>(
  params?: LastfmCallbackParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof lastfmCallback>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof lastfmCallback>>,
          TError,
          Awaited<ReturnType<typeof lastfmCallback>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useLastfmCallback<
  TData = Awaited<ReturnType<typeof lastfmCallback>>,
  TError = ErrorType<LastfmCallback400 | LastfmCallback500>
>(
  params?: LastfmCallbackParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof lastfmCallback>>, TError, TData>
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};

export function useLastfmCallback<
  TData = Awaited<ReturnType<typeof lastfmCallback>>,
  TError = ErrorType<LastfmCallback400 | LastfmCallback500>
>(
  params?: LastfmCallbackParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof lastfmCallback>>, TError, TData>
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getLastfmCallbackQueryOptions(params, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getLastfmCallbackSuspenseQueryOptions = <
  TData = Awaited<ReturnType<typeof lastfmCallback>>,
  TError = ErrorType<LastfmCallback400 | LastfmCallback500>
>(
  params?: LastfmCallbackParams,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof lastfmCallback>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getLastfmCallbackQueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof lastfmCallback>>> = ({
    signal,
  }) => lastfmCallback(params, requestOptions, signal);

  return { queryKey, queryFn, ...queryOptions } as UseSuspenseQueryOptions<
    Awaited<ReturnType<typeof lastfmCallback>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type LastfmCallbackSuspenseQueryResult = NonNullable<
  Awaited<ReturnType<typeof lastfmCallback>>
>;
export type LastfmCallbackSuspenseQueryError = ErrorType<
  LastfmCallback400 | LastfmCallback500
>;

export function useLastfmCallbackSuspense<
  TData = Awaited<ReturnType<typeof lastfmCallback>>,
  TError = ErrorType<LastfmCallback400 | LastfmCallback500>
>(
  params: undefined | LastfmCallbackParams,
  options: {
    query: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof lastfmCallback>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useLastfmCallbackSuspense<
  TData = Awaited<ReturnType<typeof lastfmCallback>>,
  TError = ErrorType<LastfmCallback400 | LastfmCallback500>
>(
  params?: LastfmCallbackParams,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof lastfmCallback>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useLastfmCallbackSuspense<
  TData = Awaited<ReturnType<typeof lastfmCallback>>,
  TError = ErrorType<LastfmCallback400 | LastfmCallback500>
>(
  params?: LastfmCallbackParams,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof lastfmCallback>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};

export function useLastfmCallbackSuspense<
  TData = Awaited<ReturnType<typeof lastfmCallback>>,
  TError = ErrorType<LastfmCallback400 | LastfmCallback500>
>(
  params?: LastfmCallbackParams,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof lastfmCallback>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getLastfmCallbackSuspenseQueryOptions(params, options);

  const query = useSuspenseQuery(
    queryOptions,
    queryClient
  ) as UseSuspenseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getLastfmCallbackSuspenseInfiniteQueryOptions = <
  TData = InfiniteData<
    Awaited<ReturnType<typeof lastfmCallback>>,
    LastfmCallbackParams["page"]
  >,
  TError = ErrorType<LastfmCallback400 | LastfmCallback500>
>(
  params?: LastfmCallbackParams,
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof lastfmCallback>>,
        TError,
        TData,
        QueryKey,
        LastfmCallbackParams["page"]
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getLastfmCallbackQueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof lastfmCallback>>,
    QueryKey,
    LastfmCallbackParams["page"]
  > = ({ signal, pageParam }) =>
    lastfmCallback(
      { ...params, page: pageParam || params?.["page"] },
      requestOptions,
      signal
    );

  return {
    queryKey,
    queryFn,
    ...queryOptions,
  } as UseSuspenseInfiniteQueryOptions<
    Awaited<ReturnType<typeof lastfmCallback>>,
    TError,
    TData,
    QueryKey,
    LastfmCallbackParams["page"]
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type LastfmCallbackSuspenseInfiniteQueryResult = NonNullable<
  Awaited<ReturnType<typeof lastfmCallback>>
>;
export type LastfmCallbackSuspenseInfiniteQueryError = ErrorType<
  LastfmCallback400 | LastfmCallback500
>;

export function useLastfmCallbackSuspenseInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof lastfmCallback>>,
    LastfmCallbackParams["page"]
  >,
  TError = ErrorType<LastfmCallback400 | LastfmCallback500>
>(
  params: undefined | LastfmCallbackParams,
  options: {
    query: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof lastfmCallback>>,
        TError,
        TData,
        QueryKey,
        LastfmCallbackParams["page"]
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useLastfmCallbackSuspenseInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof lastfmCallback>>,
    LastfmCallbackParams["page"]
  >,
  TError = ErrorType<LastfmCallback400 | LastfmCallback500>
>(
  params?: LastfmCallbackParams,
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof lastfmCallback>>,
        TError,
        TData,
        QueryKey,
        LastfmCallbackParams["page"]
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useLastfmCallbackSuspenseInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof lastfmCallback>>,
    LastfmCallbackParams["page"]
  >,
  TError = ErrorType<LastfmCallback400 | LastfmCallback500>
>(
  params?: LastfmCallbackParams,
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof lastfmCallback>>,
        TError,
        TData,
        QueryKey,
        LastfmCallbackParams["page"]
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};

export function useLastfmCallbackSuspenseInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof lastfmCallback>>,
    LastfmCallbackParams["page"]
  >,
  TError = ErrorType<LastfmCallback400 | LastfmCallback500>
>(
  params?: LastfmCallbackParams,
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof lastfmCallback>>,
        TError,
        TData,
        QueryKey,
        LastfmCallbackParams["page"]
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getLastfmCallbackSuspenseInfiniteQueryOptions(
    params,
    options
  );

  const query = useSuspenseInfiniteQuery(
    queryOptions,
    queryClient
  ) as UseSuspenseInfiniteQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const lastfmDisconnect = (
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal
) => {
  return customInstance<LastfmDisconnect200>(
    { url: `/api/services/lastfm/disconnect`, method: "POST", signal },
    options
  );
};

export const getLastfmDisconnectMutationOptions = <
  TError = ErrorType<AuthenticationExceptionResponse>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof lastfmDisconnect>>,
    TError,
    void,
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof lastfmDisconnect>>,
  TError,
  void,
  TContext
> => {
  const mutationKey = ["lastfmDisconnect"];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof lastfmDisconnect>>,
    void
  > = () => {
    return lastfmDisconnect(requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type LastfmDisconnectMutationResult = NonNullable<
  Awaited<ReturnType<typeof lastfmDisconnect>>
>;

export type LastfmDisconnectMutationError =
  ErrorType<AuthenticationExceptionResponse>;

export const useLastfmDisconnect = <
  TError = ErrorType<AuthenticationExceptionResponse>,
  TContext = unknown
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof lastfmDisconnect>>,
      TError,
      void,
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof lastfmDisconnect>>,
  TError,
  void,
  TContext
> => {
  const mutationOptions = getLastfmDisconnectMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
export const lastfmStatus = (
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal
) => {
  return customInstance<LastfmStatus200>(
    { url: `/api/services/lastfm/status`, method: "GET", signal },
    options
  );
};

export const getLastfmStatusQueryKey = () => {
  return [`/api/services/lastfm/status`] as const;
};

export const getLastfmStatusInfiniteQueryOptions = <
  TData = InfiniteData<Awaited<ReturnType<typeof lastfmStatus>>>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(options?: {
  query?: Partial<
    UseInfiniteQueryOptions<
      Awaited<ReturnType<typeof lastfmStatus>>,
      TError,
      TData
    >
  >;
  request?: SecondParameter<typeof customInstance>;
}) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getLastfmStatusQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof lastfmStatus>>> = ({
    signal,
  }) => lastfmStatus(requestOptions, signal);

  return { queryKey, queryFn, ...queryOptions } as UseInfiniteQueryOptions<
    Awaited<ReturnType<typeof lastfmStatus>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type LastfmStatusInfiniteQueryResult = NonNullable<
  Awaited<ReturnType<typeof lastfmStatus>>
>;
export type LastfmStatusInfiniteQueryError =
  ErrorType<AuthenticationExceptionResponse>;

export function useLastfmStatusInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof lastfmStatus>>>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(
  options: {
    query: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof lastfmStatus>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof lastfmStatus>>,
          TError,
          Awaited<ReturnType<typeof lastfmStatus>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): DefinedUseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useLastfmStatusInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof lastfmStatus>>>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof lastfmStatus>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof lastfmStatus>>,
          TError,
          Awaited<ReturnType<typeof lastfmStatus>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useLastfmStatusInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof lastfmStatus>>>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof lastfmStatus>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};

export function useLastfmStatusInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof lastfmStatus>>>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof lastfmStatus>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getLastfmStatusInfiniteQueryOptions(options);

  const query = useInfiniteQuery(
    queryOptions,
    queryClient
  ) as UseInfiniteQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getLastfmStatusQueryOptions = <
  TData = Awaited<ReturnType<typeof lastfmStatus>>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof lastfmStatus>>, TError, TData>
  >;
  request?: SecondParameter<typeof customInstance>;
}) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getLastfmStatusQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof lastfmStatus>>> = ({
    signal,
  }) => lastfmStatus(requestOptions, signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof lastfmStatus>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type LastfmStatusQueryResult = NonNullable<
  Awaited<ReturnType<typeof lastfmStatus>>
>;
export type LastfmStatusQueryError = ErrorType<AuthenticationExceptionResponse>;

export function useLastfmStatus<
  TData = Awaited<ReturnType<typeof lastfmStatus>>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof lastfmStatus>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof lastfmStatus>>,
          TError,
          Awaited<ReturnType<typeof lastfmStatus>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useLastfmStatus<
  TData = Awaited<ReturnType<typeof lastfmStatus>>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof lastfmStatus>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof lastfmStatus>>,
          TError,
          Awaited<ReturnType<typeof lastfmStatus>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useLastfmStatus<
  TData = Awaited<ReturnType<typeof lastfmStatus>>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof lastfmStatus>>, TError, TData>
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};

export function useLastfmStatus<
  TData = Awaited<ReturnType<typeof lastfmStatus>>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof lastfmStatus>>, TError, TData>
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getLastfmStatusQueryOptions(options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getLastfmStatusSuspenseQueryOptions = <
  TData = Awaited<ReturnType<typeof lastfmStatus>>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(options?: {
  query?: Partial<
    UseSuspenseQueryOptions<
      Awaited<ReturnType<typeof lastfmStatus>>,
      TError,
      TData
    >
  >;
  request?: SecondParameter<typeof customInstance>;
}) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getLastfmStatusQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof lastfmStatus>>> = ({
    signal,
  }) => lastfmStatus(requestOptions, signal);

  return { queryKey, queryFn, ...queryOptions } as UseSuspenseQueryOptions<
    Awaited<ReturnType<typeof lastfmStatus>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type LastfmStatusSuspenseQueryResult = NonNullable<
  Awaited<ReturnType<typeof lastfmStatus>>
>;
export type LastfmStatusSuspenseQueryError =
  ErrorType<AuthenticationExceptionResponse>;

export function useLastfmStatusSuspense<
  TData = Awaited<ReturnType<typeof lastfmStatus>>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(
  options: {
    query: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof lastfmStatus>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useLastfmStatusSuspense<
  TData = Awaited<ReturnType<typeof lastfmStatus>>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof lastfmStatus>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useLastfmStatusSuspense<
  TData = Awaited<ReturnType<typeof lastfmStatus>>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof lastfmStatus>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};

export function useLastfmStatusSuspense<
  TData = Awaited<ReturnType<typeof lastfmStatus>>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof lastfmStatus>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getLastfmStatusSuspenseQueryOptions(options);

  const query = useSuspenseQuery(
    queryOptions,
    queryClient
  ) as UseSuspenseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getLastfmStatusSuspenseInfiniteQueryOptions = <
  TData = InfiniteData<Awaited<ReturnType<typeof lastfmStatus>>>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(options?: {
  query?: Partial<
    UseSuspenseInfiniteQueryOptions<
      Awaited<ReturnType<typeof lastfmStatus>>,
      TError,
      TData
    >
  >;
  request?: SecondParameter<typeof customInstance>;
}) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getLastfmStatusQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof lastfmStatus>>> = ({
    signal,
  }) => lastfmStatus(requestOptions, signal);

  return {
    queryKey,
    queryFn,
    ...queryOptions,
  } as UseSuspenseInfiniteQueryOptions<
    Awaited<ReturnType<typeof lastfmStatus>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type LastfmStatusSuspenseInfiniteQueryResult = NonNullable<
  Awaited<ReturnType<typeof lastfmStatus>>
>;
export type LastfmStatusSuspenseInfiniteQueryError =
  ErrorType<AuthenticationExceptionResponse>;

export function useLastfmStatusSuspenseInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof lastfmStatus>>>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(
  options: {
    query: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof lastfmStatus>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useLastfmStatusSuspenseInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof lastfmStatus>>>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof lastfmStatus>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useLastfmStatusSuspenseInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof lastfmStatus>>>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof lastfmStatus>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};

export function useLastfmStatusSuspenseInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof lastfmStatus>>>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof lastfmStatus>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getLastfmStatusSuspenseInfiniteQueryOptions(options);

  const query = useSuspenseInfiniteQuery(
    queryOptions,
    queryClient
  ) as UseSuspenseInfiniteQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}
