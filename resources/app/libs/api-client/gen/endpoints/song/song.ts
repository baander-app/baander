/**
 * Generated by orval v7.11.2 üç∫
 * Do not edit manually.
 * B√•nder api docs
 * B√•nder.App is a sophisticated media server developed with the primary goal to deliver high performance and seamless experience for users.
Being built on top of Laravel framework and PostgreSQL for database, it leverages the power of robust backend technologies, providing high security, reliability, and scalability.

The main focus of B√•nder.App is efficient media management and delivery.
This application is designed to handle large amounts of media files while ensuring quick and efficient access.
Implemented queuing functionality through Redis offers efficient job management and load handling.
The media information is organized and easily searchable, ensuring users can always find what they are looking for quickly and easily.
 * OpenAPI spec version: 0.0.1
 */
import {
  useInfiniteQuery,
  useQuery,
  useSuspenseInfiniteQuery,
  useSuspenseQuery,
} from "@tanstack/react-query";
import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseInfiniteQueryResult,
  DefinedUseQueryResult,
  InfiniteData,
  QueryClient,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseInfiniteQueryOptions,
  UseInfiniteQueryResult,
  UseQueryOptions,
  UseQueryResult,
  UseSuspenseInfiniteQueryOptions,
  UseSuspenseInfiniteQueryResult,
  UseSuspenseQueryOptions,
  UseSuspenseQueryResult,
} from "@tanstack/react-query";

import type {
  AuthenticationExceptionResponse,
  ModelNotFoundExceptionResponse,
  SongResource,
  SongsIndex200,
  SongsIndex400,
  SongsIndexParams,
  SongsShowParams,
  ValidationExceptionResponse,
} from "../../models";

import { customInstance } from "../../../axios-instance";
import type { ErrorType } from "../../../axios-instance";

type SecondParameter<T extends (...args: never) => unknown> = Parameters<T>[1];

/**
 * @summary Get a collection of songs
 */
export const songsIndex = (
  library: string,
  params?: SongsIndexParams,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal
) => {
  return customInstance<SongsIndex200>(
    { url: `/api/libraries/${library}/songs`, method: "GET", params, signal },
    options
  );
};

export const getSongsIndexQueryKey = (
  library?: string,
  params?: SongsIndexParams
) => {
  return [
    `/api/libraries/${library}/songs`,
    ...(params ? [params] : []),
  ] as const;
};

export const getSongsIndexInfiniteQueryOptions = <
  TData = InfiniteData<
    Awaited<ReturnType<typeof songsIndex>>,
    SongsIndexParams["limit"]
  >,
  TError = ErrorType<
    | SongsIndex400
    | AuthenticationExceptionResponse
    | ModelNotFoundExceptionResponse
    | ValidationExceptionResponse
  >
>(
  library: string,
  params?: SongsIndexParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof songsIndex>>,
        TError,
        TData,
        QueryKey,
        SongsIndexParams["limit"]
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getSongsIndexQueryKey(library, params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof songsIndex>>,
    QueryKey,
    SongsIndexParams["limit"]
  > = ({ signal, pageParam }) =>
    songsIndex(
      library,
      { ...params, limit: pageParam || params?.["limit"] },
      requestOptions,
      signal
    );

  return {
    queryKey,
    queryFn,
    enabled: !!library,
    ...queryOptions,
  } as UseInfiniteQueryOptions<
    Awaited<ReturnType<typeof songsIndex>>,
    TError,
    TData,
    QueryKey,
    SongsIndexParams["limit"]
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type SongsIndexInfiniteQueryResult = NonNullable<
  Awaited<ReturnType<typeof songsIndex>>
>;
export type SongsIndexInfiniteQueryError = ErrorType<
  | SongsIndex400
  | AuthenticationExceptionResponse
  | ModelNotFoundExceptionResponse
  | ValidationExceptionResponse
>;

export function useSongsIndexInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof songsIndex>>,
    SongsIndexParams["limit"]
  >,
  TError = ErrorType<
    | SongsIndex400
    | AuthenticationExceptionResponse
    | ModelNotFoundExceptionResponse
    | ValidationExceptionResponse
  >
>(
  library: string,
  params: undefined | SongsIndexParams,
  options: {
    query: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof songsIndex>>,
        TError,
        TData,
        QueryKey,
        SongsIndexParams["limit"]
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof songsIndex>>,
          TError,
          Awaited<ReturnType<typeof songsIndex>>,
          QueryKey
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): DefinedUseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useSongsIndexInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof songsIndex>>,
    SongsIndexParams["limit"]
  >,
  TError = ErrorType<
    | SongsIndex400
    | AuthenticationExceptionResponse
    | ModelNotFoundExceptionResponse
    | ValidationExceptionResponse
  >
>(
  library: string,
  params?: SongsIndexParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof songsIndex>>,
        TError,
        TData,
        QueryKey,
        SongsIndexParams["limit"]
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof songsIndex>>,
          TError,
          Awaited<ReturnType<typeof songsIndex>>,
          QueryKey
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useSongsIndexInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof songsIndex>>,
    SongsIndexParams["limit"]
  >,
  TError = ErrorType<
    | SongsIndex400
    | AuthenticationExceptionResponse
    | ModelNotFoundExceptionResponse
    | ValidationExceptionResponse
  >
>(
  library: string,
  params?: SongsIndexParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof songsIndex>>,
        TError,
        TData,
        QueryKey,
        SongsIndexParams["limit"]
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get a collection of songs
 */

export function useSongsIndexInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof songsIndex>>,
    SongsIndexParams["limit"]
  >,
  TError = ErrorType<
    | SongsIndex400
    | AuthenticationExceptionResponse
    | ModelNotFoundExceptionResponse
    | ValidationExceptionResponse
  >
>(
  library: string,
  params?: SongsIndexParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof songsIndex>>,
        TError,
        TData,
        QueryKey,
        SongsIndexParams["limit"]
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getSongsIndexInfiniteQueryOptions(
    library,
    params,
    options
  );

  const query = useInfiniteQuery(
    queryOptions,
    queryClient
  ) as UseInfiniteQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getSongsIndexQueryOptions = <
  TData = Awaited<ReturnType<typeof songsIndex>>,
  TError = ErrorType<
    | SongsIndex400
    | AuthenticationExceptionResponse
    | ModelNotFoundExceptionResponse
    | ValidationExceptionResponse
  >
>(
  library: string,
  params?: SongsIndexParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof songsIndex>>, TError, TData>
    >;
    request?: SecondParameter<typeof customInstance>;
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getSongsIndexQueryKey(library, params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof songsIndex>>> = ({
    signal,
  }) => songsIndex(library, params, requestOptions, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!library,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof songsIndex>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type SongsIndexQueryResult = NonNullable<
  Awaited<ReturnType<typeof songsIndex>>
>;
export type SongsIndexQueryError = ErrorType<
  | SongsIndex400
  | AuthenticationExceptionResponse
  | ModelNotFoundExceptionResponse
  | ValidationExceptionResponse
>;

export function useSongsIndex<
  TData = Awaited<ReturnType<typeof songsIndex>>,
  TError = ErrorType<
    | SongsIndex400
    | AuthenticationExceptionResponse
    | ModelNotFoundExceptionResponse
    | ValidationExceptionResponse
  >
>(
  library: string,
  params: undefined | SongsIndexParams,
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof songsIndex>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof songsIndex>>,
          TError,
          Awaited<ReturnType<typeof songsIndex>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useSongsIndex<
  TData = Awaited<ReturnType<typeof songsIndex>>,
  TError = ErrorType<
    | SongsIndex400
    | AuthenticationExceptionResponse
    | ModelNotFoundExceptionResponse
    | ValidationExceptionResponse
  >
>(
  library: string,
  params?: SongsIndexParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof songsIndex>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof songsIndex>>,
          TError,
          Awaited<ReturnType<typeof songsIndex>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useSongsIndex<
  TData = Awaited<ReturnType<typeof songsIndex>>,
  TError = ErrorType<
    | SongsIndex400
    | AuthenticationExceptionResponse
    | ModelNotFoundExceptionResponse
    | ValidationExceptionResponse
  >
>(
  library: string,
  params?: SongsIndexParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof songsIndex>>, TError, TData>
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get a collection of songs
 */

export function useSongsIndex<
  TData = Awaited<ReturnType<typeof songsIndex>>,
  TError = ErrorType<
    | SongsIndex400
    | AuthenticationExceptionResponse
    | ModelNotFoundExceptionResponse
    | ValidationExceptionResponse
  >
>(
  library: string,
  params?: SongsIndexParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof songsIndex>>, TError, TData>
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getSongsIndexQueryOptions(library, params, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getSongsIndexSuspenseQueryOptions = <
  TData = Awaited<ReturnType<typeof songsIndex>>,
  TError = ErrorType<
    | SongsIndex400
    | AuthenticationExceptionResponse
    | ModelNotFoundExceptionResponse
    | ValidationExceptionResponse
  >
>(
  library: string,
  params?: SongsIndexParams,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof songsIndex>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getSongsIndexQueryKey(library, params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof songsIndex>>> = ({
    signal,
  }) => songsIndex(library, params, requestOptions, signal);

  return { queryKey, queryFn, ...queryOptions } as UseSuspenseQueryOptions<
    Awaited<ReturnType<typeof songsIndex>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type SongsIndexSuspenseQueryResult = NonNullable<
  Awaited<ReturnType<typeof songsIndex>>
>;
export type SongsIndexSuspenseQueryError = ErrorType<
  | SongsIndex400
  | AuthenticationExceptionResponse
  | ModelNotFoundExceptionResponse
  | ValidationExceptionResponse
>;

export function useSongsIndexSuspense<
  TData = Awaited<ReturnType<typeof songsIndex>>,
  TError = ErrorType<
    | SongsIndex400
    | AuthenticationExceptionResponse
    | ModelNotFoundExceptionResponse
    | ValidationExceptionResponse
  >
>(
  library: string,
  params: undefined | SongsIndexParams,
  options: {
    query: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof songsIndex>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useSongsIndexSuspense<
  TData = Awaited<ReturnType<typeof songsIndex>>,
  TError = ErrorType<
    | SongsIndex400
    | AuthenticationExceptionResponse
    | ModelNotFoundExceptionResponse
    | ValidationExceptionResponse
  >
>(
  library: string,
  params?: SongsIndexParams,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof songsIndex>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useSongsIndexSuspense<
  TData = Awaited<ReturnType<typeof songsIndex>>,
  TError = ErrorType<
    | SongsIndex400
    | AuthenticationExceptionResponse
    | ModelNotFoundExceptionResponse
    | ValidationExceptionResponse
  >
>(
  library: string,
  params?: SongsIndexParams,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof songsIndex>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get a collection of songs
 */

export function useSongsIndexSuspense<
  TData = Awaited<ReturnType<typeof songsIndex>>,
  TError = ErrorType<
    | SongsIndex400
    | AuthenticationExceptionResponse
    | ModelNotFoundExceptionResponse
    | ValidationExceptionResponse
  >
>(
  library: string,
  params?: SongsIndexParams,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof songsIndex>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getSongsIndexSuspenseQueryOptions(
    library,
    params,
    options
  );

  const query = useSuspenseQuery(
    queryOptions,
    queryClient
  ) as UseSuspenseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getSongsIndexSuspenseInfiniteQueryOptions = <
  TData = InfiniteData<
    Awaited<ReturnType<typeof songsIndex>>,
    SongsIndexParams["limit"]
  >,
  TError = ErrorType<
    | SongsIndex400
    | AuthenticationExceptionResponse
    | ModelNotFoundExceptionResponse
    | ValidationExceptionResponse
  >
>(
  library: string,
  params?: SongsIndexParams,
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof songsIndex>>,
        TError,
        TData,
        QueryKey,
        SongsIndexParams["limit"]
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getSongsIndexQueryKey(library, params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof songsIndex>>,
    QueryKey,
    SongsIndexParams["limit"]
  > = ({ signal, pageParam }) =>
    songsIndex(
      library,
      { ...params, limit: pageParam || params?.["limit"] },
      requestOptions,
      signal
    );

  return {
    queryKey,
    queryFn,
    ...queryOptions,
  } as UseSuspenseInfiniteQueryOptions<
    Awaited<ReturnType<typeof songsIndex>>,
    TError,
    TData,
    QueryKey,
    SongsIndexParams["limit"]
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type SongsIndexSuspenseInfiniteQueryResult = NonNullable<
  Awaited<ReturnType<typeof songsIndex>>
>;
export type SongsIndexSuspenseInfiniteQueryError = ErrorType<
  | SongsIndex400
  | AuthenticationExceptionResponse
  | ModelNotFoundExceptionResponse
  | ValidationExceptionResponse
>;

export function useSongsIndexSuspenseInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof songsIndex>>,
    SongsIndexParams["limit"]
  >,
  TError = ErrorType<
    | SongsIndex400
    | AuthenticationExceptionResponse
    | ModelNotFoundExceptionResponse
    | ValidationExceptionResponse
  >
>(
  library: string,
  params: undefined | SongsIndexParams,
  options: {
    query: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof songsIndex>>,
        TError,
        TData,
        QueryKey,
        SongsIndexParams["limit"]
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useSongsIndexSuspenseInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof songsIndex>>,
    SongsIndexParams["limit"]
  >,
  TError = ErrorType<
    | SongsIndex400
    | AuthenticationExceptionResponse
    | ModelNotFoundExceptionResponse
    | ValidationExceptionResponse
  >
>(
  library: string,
  params?: SongsIndexParams,
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof songsIndex>>,
        TError,
        TData,
        QueryKey,
        SongsIndexParams["limit"]
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useSongsIndexSuspenseInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof songsIndex>>,
    SongsIndexParams["limit"]
  >,
  TError = ErrorType<
    | SongsIndex400
    | AuthenticationExceptionResponse
    | ModelNotFoundExceptionResponse
    | ValidationExceptionResponse
  >
>(
  library: string,
  params?: SongsIndexParams,
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof songsIndex>>,
        TError,
        TData,
        QueryKey,
        SongsIndexParams["limit"]
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get a collection of songs
 */

export function useSongsIndexSuspenseInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof songsIndex>>,
    SongsIndexParams["limit"]
  >,
  TError = ErrorType<
    | SongsIndex400
    | AuthenticationExceptionResponse
    | ModelNotFoundExceptionResponse
    | ValidationExceptionResponse
  >
>(
  library: string,
  params?: SongsIndexParams,
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof songsIndex>>,
        TError,
        TData,
        QueryKey,
        SongsIndexParams["limit"]
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getSongsIndexSuspenseInfiniteQueryOptions(
    library,
    params,
    options
  );

  const query = useSuspenseInfiniteQuery(
    queryOptions,
    queryClient
  ) as UseSuspenseInfiniteQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Get a song by public id
 */
export const songsShow = (
  library: string,
  publicId: string,
  params?: SongsShowParams,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal
) => {
  return customInstance<SongResource>(
    {
      url: `/api/libraries/${library}/songs/${publicId}`,
      method: "GET",
      params,
      signal,
    },
    options
  );
};

export const getSongsShowQueryKey = (
  library?: string,
  publicId?: string,
  params?: SongsShowParams
) => {
  return [
    `/api/libraries/${library}/songs/${publicId}`,
    ...(params ? [params] : []),
  ] as const;
};

export const getSongsShowInfiniteQueryOptions = <
  TData = InfiniteData<
    Awaited<ReturnType<typeof songsShow>>,
    SongsShowParams["limit"]
  >,
  TError = ErrorType<
    | AuthenticationExceptionResponse
    | ModelNotFoundExceptionResponse
    | ValidationExceptionResponse
  >
>(
  library: string,
  publicId: string,
  params?: SongsShowParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof songsShow>>,
        TError,
        TData,
        QueryKey,
        SongsShowParams["limit"]
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getSongsShowQueryKey(library, publicId, params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof songsShow>>,
    QueryKey,
    SongsShowParams["limit"]
  > = ({ signal, pageParam }) =>
    songsShow(
      library,
      publicId,
      { ...params, limit: pageParam || params?.["limit"] },
      requestOptions,
      signal
    );

  return {
    queryKey,
    queryFn,
    enabled: !!(library && publicId),
    ...queryOptions,
  } as UseInfiniteQueryOptions<
    Awaited<ReturnType<typeof songsShow>>,
    TError,
    TData,
    QueryKey,
    SongsShowParams["limit"]
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type SongsShowInfiniteQueryResult = NonNullable<
  Awaited<ReturnType<typeof songsShow>>
>;
export type SongsShowInfiniteQueryError = ErrorType<
  | AuthenticationExceptionResponse
  | ModelNotFoundExceptionResponse
  | ValidationExceptionResponse
>;

export function useSongsShowInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof songsShow>>,
    SongsShowParams["limit"]
  >,
  TError = ErrorType<
    | AuthenticationExceptionResponse
    | ModelNotFoundExceptionResponse
    | ValidationExceptionResponse
  >
>(
  library: string,
  publicId: string,
  params: undefined | SongsShowParams,
  options: {
    query: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof songsShow>>,
        TError,
        TData,
        QueryKey,
        SongsShowParams["limit"]
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof songsShow>>,
          TError,
          Awaited<ReturnType<typeof songsShow>>,
          QueryKey
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): DefinedUseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useSongsShowInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof songsShow>>,
    SongsShowParams["limit"]
  >,
  TError = ErrorType<
    | AuthenticationExceptionResponse
    | ModelNotFoundExceptionResponse
    | ValidationExceptionResponse
  >
>(
  library: string,
  publicId: string,
  params?: SongsShowParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof songsShow>>,
        TError,
        TData,
        QueryKey,
        SongsShowParams["limit"]
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof songsShow>>,
          TError,
          Awaited<ReturnType<typeof songsShow>>,
          QueryKey
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useSongsShowInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof songsShow>>,
    SongsShowParams["limit"]
  >,
  TError = ErrorType<
    | AuthenticationExceptionResponse
    | ModelNotFoundExceptionResponse
    | ValidationExceptionResponse
  >
>(
  library: string,
  publicId: string,
  params?: SongsShowParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof songsShow>>,
        TError,
        TData,
        QueryKey,
        SongsShowParams["limit"]
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get a song by public id
 */

export function useSongsShowInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof songsShow>>,
    SongsShowParams["limit"]
  >,
  TError = ErrorType<
    | AuthenticationExceptionResponse
    | ModelNotFoundExceptionResponse
    | ValidationExceptionResponse
  >
>(
  library: string,
  publicId: string,
  params?: SongsShowParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof songsShow>>,
        TError,
        TData,
        QueryKey,
        SongsShowParams["limit"]
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getSongsShowInfiniteQueryOptions(
    library,
    publicId,
    params,
    options
  );

  const query = useInfiniteQuery(
    queryOptions,
    queryClient
  ) as UseInfiniteQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getSongsShowQueryOptions = <
  TData = Awaited<ReturnType<typeof songsShow>>,
  TError = ErrorType<
    | AuthenticationExceptionResponse
    | ModelNotFoundExceptionResponse
    | ValidationExceptionResponse
  >
>(
  library: string,
  publicId: string,
  params?: SongsShowParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof songsShow>>, TError, TData>
    >;
    request?: SecondParameter<typeof customInstance>;
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getSongsShowQueryKey(library, publicId, params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof songsShow>>> = ({
    signal,
  }) => songsShow(library, publicId, params, requestOptions, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!(library && publicId),
    ...queryOptions,
  } as UseQueryOptions<Awaited<ReturnType<typeof songsShow>>, TError, TData> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };
};

export type SongsShowQueryResult = NonNullable<
  Awaited<ReturnType<typeof songsShow>>
>;
export type SongsShowQueryError = ErrorType<
  | AuthenticationExceptionResponse
  | ModelNotFoundExceptionResponse
  | ValidationExceptionResponse
>;

export function useSongsShow<
  TData = Awaited<ReturnType<typeof songsShow>>,
  TError = ErrorType<
    | AuthenticationExceptionResponse
    | ModelNotFoundExceptionResponse
    | ValidationExceptionResponse
  >
>(
  library: string,
  publicId: string,
  params: undefined | SongsShowParams,
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof songsShow>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof songsShow>>,
          TError,
          Awaited<ReturnType<typeof songsShow>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useSongsShow<
  TData = Awaited<ReturnType<typeof songsShow>>,
  TError = ErrorType<
    | AuthenticationExceptionResponse
    | ModelNotFoundExceptionResponse
    | ValidationExceptionResponse
  >
>(
  library: string,
  publicId: string,
  params?: SongsShowParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof songsShow>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof songsShow>>,
          TError,
          Awaited<ReturnType<typeof songsShow>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useSongsShow<
  TData = Awaited<ReturnType<typeof songsShow>>,
  TError = ErrorType<
    | AuthenticationExceptionResponse
    | ModelNotFoundExceptionResponse
    | ValidationExceptionResponse
  >
>(
  library: string,
  publicId: string,
  params?: SongsShowParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof songsShow>>, TError, TData>
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get a song by public id
 */

export function useSongsShow<
  TData = Awaited<ReturnType<typeof songsShow>>,
  TError = ErrorType<
    | AuthenticationExceptionResponse
    | ModelNotFoundExceptionResponse
    | ValidationExceptionResponse
  >
>(
  library: string,
  publicId: string,
  params?: SongsShowParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof songsShow>>, TError, TData>
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getSongsShowQueryOptions(
    library,
    publicId,
    params,
    options
  );

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getSongsShowSuspenseQueryOptions = <
  TData = Awaited<ReturnType<typeof songsShow>>,
  TError = ErrorType<
    | AuthenticationExceptionResponse
    | ModelNotFoundExceptionResponse
    | ValidationExceptionResponse
  >
>(
  library: string,
  publicId: string,
  params?: SongsShowParams,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof songsShow>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getSongsShowQueryKey(library, publicId, params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof songsShow>>> = ({
    signal,
  }) => songsShow(library, publicId, params, requestOptions, signal);

  return { queryKey, queryFn, ...queryOptions } as UseSuspenseQueryOptions<
    Awaited<ReturnType<typeof songsShow>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type SongsShowSuspenseQueryResult = NonNullable<
  Awaited<ReturnType<typeof songsShow>>
>;
export type SongsShowSuspenseQueryError = ErrorType<
  | AuthenticationExceptionResponse
  | ModelNotFoundExceptionResponse
  | ValidationExceptionResponse
>;

export function useSongsShowSuspense<
  TData = Awaited<ReturnType<typeof songsShow>>,
  TError = ErrorType<
    | AuthenticationExceptionResponse
    | ModelNotFoundExceptionResponse
    | ValidationExceptionResponse
  >
>(
  library: string,
  publicId: string,
  params: undefined | SongsShowParams,
  options: {
    query: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof songsShow>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useSongsShowSuspense<
  TData = Awaited<ReturnType<typeof songsShow>>,
  TError = ErrorType<
    | AuthenticationExceptionResponse
    | ModelNotFoundExceptionResponse
    | ValidationExceptionResponse
  >
>(
  library: string,
  publicId: string,
  params?: SongsShowParams,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof songsShow>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useSongsShowSuspense<
  TData = Awaited<ReturnType<typeof songsShow>>,
  TError = ErrorType<
    | AuthenticationExceptionResponse
    | ModelNotFoundExceptionResponse
    | ValidationExceptionResponse
  >
>(
  library: string,
  publicId: string,
  params?: SongsShowParams,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof songsShow>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get a song by public id
 */

export function useSongsShowSuspense<
  TData = Awaited<ReturnType<typeof songsShow>>,
  TError = ErrorType<
    | AuthenticationExceptionResponse
    | ModelNotFoundExceptionResponse
    | ValidationExceptionResponse
  >
>(
  library: string,
  publicId: string,
  params?: SongsShowParams,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof songsShow>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getSongsShowSuspenseQueryOptions(
    library,
    publicId,
    params,
    options
  );

  const query = useSuspenseQuery(
    queryOptions,
    queryClient
  ) as UseSuspenseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getSongsShowSuspenseInfiniteQueryOptions = <
  TData = InfiniteData<
    Awaited<ReturnType<typeof songsShow>>,
    SongsShowParams["limit"]
  >,
  TError = ErrorType<
    | AuthenticationExceptionResponse
    | ModelNotFoundExceptionResponse
    | ValidationExceptionResponse
  >
>(
  library: string,
  publicId: string,
  params?: SongsShowParams,
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof songsShow>>,
        TError,
        TData,
        QueryKey,
        SongsShowParams["limit"]
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getSongsShowQueryKey(library, publicId, params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof songsShow>>,
    QueryKey,
    SongsShowParams["limit"]
  > = ({ signal, pageParam }) =>
    songsShow(
      library,
      publicId,
      { ...params, limit: pageParam || params?.["limit"] },
      requestOptions,
      signal
    );

  return {
    queryKey,
    queryFn,
    ...queryOptions,
  } as UseSuspenseInfiniteQueryOptions<
    Awaited<ReturnType<typeof songsShow>>,
    TError,
    TData,
    QueryKey,
    SongsShowParams["limit"]
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type SongsShowSuspenseInfiniteQueryResult = NonNullable<
  Awaited<ReturnType<typeof songsShow>>
>;
export type SongsShowSuspenseInfiniteQueryError = ErrorType<
  | AuthenticationExceptionResponse
  | ModelNotFoundExceptionResponse
  | ValidationExceptionResponse
>;

export function useSongsShowSuspenseInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof songsShow>>,
    SongsShowParams["limit"]
  >,
  TError = ErrorType<
    | AuthenticationExceptionResponse
    | ModelNotFoundExceptionResponse
    | ValidationExceptionResponse
  >
>(
  library: string,
  publicId: string,
  params: undefined | SongsShowParams,
  options: {
    query: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof songsShow>>,
        TError,
        TData,
        QueryKey,
        SongsShowParams["limit"]
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useSongsShowSuspenseInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof songsShow>>,
    SongsShowParams["limit"]
  >,
  TError = ErrorType<
    | AuthenticationExceptionResponse
    | ModelNotFoundExceptionResponse
    | ValidationExceptionResponse
  >
>(
  library: string,
  publicId: string,
  params?: SongsShowParams,
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof songsShow>>,
        TError,
        TData,
        QueryKey,
        SongsShowParams["limit"]
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useSongsShowSuspenseInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof songsShow>>,
    SongsShowParams["limit"]
  >,
  TError = ErrorType<
    | AuthenticationExceptionResponse
    | ModelNotFoundExceptionResponse
    | ValidationExceptionResponse
  >
>(
  library: string,
  publicId: string,
  params?: SongsShowParams,
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof songsShow>>,
        TError,
        TData,
        QueryKey,
        SongsShowParams["limit"]
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get a song by public id
 */

export function useSongsShowSuspenseInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof songsShow>>,
    SongsShowParams["limit"]
  >,
  TError = ErrorType<
    | AuthenticationExceptionResponse
    | ModelNotFoundExceptionResponse
    | ValidationExceptionResponse
  >
>(
  library: string,
  publicId: string,
  params?: SongsShowParams,
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof songsShow>>,
        TError,
        TData,
        QueryKey,
        SongsShowParams["limit"]
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getSongsShowSuspenseInfiniteQueryOptions(
    library,
    publicId,
    params,
    options
  );

  const query = useSuspenseInfiniteQuery(
    queryOptions,
    queryClient
  ) as UseSuspenseInfiniteQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}
