/**
 * Generated by orval v7.17.2 üç∫
 * Do not edit manually.
 * B√•nder api docs
 * B√•nder.App is a sophisticated media server developed with the primary goal to deliver high performance and seamless experience for users.
Being built on top of Laravel framework and PostgreSQL for database, it leverages the power of robust backend technologies, providing high security, reliability, and scalability.

The main focus of B√•nder.App is efficient media management and delivery.
This application is designed to handle large amounts of media files while ensuring quick and efficient access.
Implemented queuing functionality through Redis offers efficient job management and load handling.
The media information is organized and easily searchable, ensuring users can always find what they are looking for quickly and easily.
 * OpenAPI spec version: 0.0.1
 */
import {
  useInfiniteQuery,
  useMutation,
  useQuery,
  useSuspenseInfiniteQuery,
  useSuspenseQuery,
} from "@tanstack/react-query";
import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseInfiniteQueryResult,
  DefinedUseQueryResult,
  InfiniteData,
  MutationFunction,
  QueryClient,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseInfiniteQueryOptions,
  UseInfiniteQueryResult,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult,
  UseSuspenseInfiniteQueryOptions,
  UseSuspenseInfiniteQueryResult,
  UseSuspenseQueryOptions,
  UseSuspenseQueryResult,
} from "@tanstack/react-query";

import type {
  AuthenticationExceptionResponse,
  ModelNotFoundExceptionResponse,
  SongResource,
  SongUpdateRequest,
  SongsIndex200,
  SongsIndex400,
  SongsIndexParams,
  SongsShowParams,
  ValidationExceptionResponse,
} from "../../models";

import { customInstance } from "../../../axios-instance";
import type { ErrorType, BodyType } from "../../../axios-instance";

type SecondParameter<T extends (...args: never) => unknown> = Parameters<T>[1];

/**
 * Returns a filtered and paginated list of songs from the specified library.
Supports relation inclusion and genre filtering. Songs are ordered by album title
and track number for a consistent browsing experience.
 * @summary Get a paginated collection of songs from a specific library
 */
export const songsIndex = (
  library: string,
  params?: SongsIndexParams,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal
) => {
  return customInstance<SongsIndex200>(
    { url: `/api/libraries/${library}/songs`, method: "GET", params, signal },
    options
  );
};

export const getSongsIndexInfiniteQueryKey = (
  library?: string,
  params?: SongsIndexParams
) => {
  return [
    "infinite",
    `/api/libraries/${library}/songs`,
    ...(params ? [params] : []),
  ] as const;
};

export const getSongsIndexQueryKey = (
  library?: string,
  params?: SongsIndexParams
) => {
  return [
    `/api/libraries/${library}/songs`,
    ...(params ? [params] : []),
  ] as const;
};

export const getSongsIndexInfiniteQueryOptions = <
  TData = InfiniteData<
    SongsIndex200,
    SongsIndexParams["page"]
  >,
  TError = ErrorType<
    | SongsIndex400
    | AuthenticationExceptionResponse
    | ModelNotFoundExceptionResponse
    | ValidationExceptionResponse
  >
>(
  library: string,
  params?: SongsIndexParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        SongsIndex200,
        TError,
        TData,
        QueryKey,
        SongsIndexParams["page"]
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getSongsIndexInfiniteQueryKey(library, params);

  const queryFn: QueryFunction<
    SongsIndex200,
    QueryKey,
    SongsIndexParams["page"]
  > = ({ signal, pageParam }) =>
    songsIndex(
      library,
      { ...params, page: pageParam || params?.["page"] },
      requestOptions,
      signal
    );

  return {
    queryKey,
    queryFn,
    enabled: !!library,
    ...queryOptions,
  } as UseInfiniteQueryOptions<
    SongsIndex200,
    TError,
    TData,
    QueryKey,
    SongsIndexParams["page"]
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type SongsIndexInfiniteQueryResult = NonNullable<
  SongsIndex200
>;
export type SongsIndexInfiniteQueryError = ErrorType<
  | SongsIndex400
  | AuthenticationExceptionResponse
  | ModelNotFoundExceptionResponse
  | ValidationExceptionResponse
>;

export function useSongsIndexInfinite<
  TData = InfiniteData<
    SongsIndex200,
    SongsIndexParams["page"]
  >,
  TError = ErrorType<
    | SongsIndex400
    | AuthenticationExceptionResponse
    | ModelNotFoundExceptionResponse
    | ValidationExceptionResponse
  >
>(
  library: string,
  params: undefined | SongsIndexParams,
  options: {
    query: Partial<
      UseInfiniteQueryOptions<
        SongsIndex200,
        TError,
        TData,
        QueryKey,
        SongsIndexParams["page"]
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          SongsIndex200,
          TError,
          SongsIndex200,
          QueryKey
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): DefinedUseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useSongsIndexInfinite<
  TData = InfiniteData<
    SongsIndex200,
    SongsIndexParams["page"]
  >,
  TError = ErrorType<
    | SongsIndex400
    | AuthenticationExceptionResponse
    | ModelNotFoundExceptionResponse
    | ValidationExceptionResponse
  >
>(
  library: string,
  params?: SongsIndexParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        SongsIndex200,
        TError,
        TData,
        QueryKey,
        SongsIndexParams["page"]
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          SongsIndex200,
          TError,
          SongsIndex200,
          QueryKey
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useSongsIndexInfinite<
  TData = InfiniteData<
    SongsIndex200,
    SongsIndexParams["page"]
  >,
  TError = ErrorType<
    | SongsIndex400
    | AuthenticationExceptionResponse
    | ModelNotFoundExceptionResponse
    | ValidationExceptionResponse
  >
>(
  library: string,
  params?: SongsIndexParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        SongsIndex200,
        TError,
        TData,
        QueryKey,
        SongsIndexParams["page"]
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get a paginated collection of songs from a specific library
 */

export function useSongsIndexInfinite<
  TData = InfiniteData<
    SongsIndex200,
    SongsIndexParams["page"]
  >,
  TError = ErrorType<
    | SongsIndex400
    | AuthenticationExceptionResponse
    | ModelNotFoundExceptionResponse
    | ValidationExceptionResponse
  >
>(
  library: string,
  params?: SongsIndexParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        SongsIndex200,
        TError,
        TData,
        QueryKey,
        SongsIndexParams["page"]
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getSongsIndexInfiniteQueryOptions(
    library,
    params,
    options
  );

  const query = useInfiniteQuery(
    queryOptions,
    queryClient
  ) as UseInfiniteQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getSongsIndexQueryOptions = <
  TData = SongsIndex200,
  TError = ErrorType<
    | SongsIndex400
    | AuthenticationExceptionResponse
    | ModelNotFoundExceptionResponse
    | ValidationExceptionResponse
  >
>(
  library: string,
  params?: SongsIndexParams,
  options?: {
    query?: Partial<
      UseQueryOptions<SongsIndex200, TError, TData>
    >;
    request?: SecondParameter<typeof customInstance>;
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getSongsIndexQueryKey(library, params);

  const queryFn: QueryFunction<SongsIndex200> = ({
    signal,
  }) => songsIndex(library, params, requestOptions, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!library,
    ...queryOptions,
  } as UseQueryOptions<
    SongsIndex200,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type SongsIndexQueryResult = NonNullable<
  SongsIndex200
>;
export type SongsIndexQueryError = ErrorType<
  | SongsIndex400
  | AuthenticationExceptionResponse
  | ModelNotFoundExceptionResponse
  | ValidationExceptionResponse
>;

export function useSongsIndex<
  TData = SongsIndex200,
  TError = ErrorType<
    | SongsIndex400
    | AuthenticationExceptionResponse
    | ModelNotFoundExceptionResponse
    | ValidationExceptionResponse
  >
>(
  library: string,
  params: undefined | SongsIndexParams,
  options: {
    query: Partial<
      UseQueryOptions<SongsIndex200, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          SongsIndex200,
          TError,
          SongsIndex200
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useSongsIndex<
  TData = SongsIndex200,
  TError = ErrorType<
    | SongsIndex400
    | AuthenticationExceptionResponse
    | ModelNotFoundExceptionResponse
    | ValidationExceptionResponse
  >
>(
  library: string,
  params?: SongsIndexParams,
  options?: {
    query?: Partial<
      UseQueryOptions<SongsIndex200, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          SongsIndex200,
          TError,
          SongsIndex200
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useSongsIndex<
  TData = SongsIndex200,
  TError = ErrorType<
    | SongsIndex400
    | AuthenticationExceptionResponse
    | ModelNotFoundExceptionResponse
    | ValidationExceptionResponse
  >
>(
  library: string,
  params?: SongsIndexParams,
  options?: {
    query?: Partial<
      UseQueryOptions<SongsIndex200, TError, TData>
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get a paginated collection of songs from a specific library
 */

export function useSongsIndex<
  TData = SongsIndex200,
  TError = ErrorType<
    | SongsIndex400
    | AuthenticationExceptionResponse
    | ModelNotFoundExceptionResponse
    | ValidationExceptionResponse
  >
>(
  library: string,
  params?: SongsIndexParams,
  options?: {
    query?: Partial<
      UseQueryOptions<SongsIndex200, TError, TData>
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getSongsIndexQueryOptions(library, params, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getSongsIndexSuspenseQueryOptions = <
  TData = SongsIndex200,
  TError = ErrorType<
    | SongsIndex400
    | AuthenticationExceptionResponse
    | ModelNotFoundExceptionResponse
    | ValidationExceptionResponse
  >
>(
  library: string,
  params?: SongsIndexParams,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        SongsIndex200,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getSongsIndexQueryKey(library, params);

  const queryFn: QueryFunction<SongsIndex200> = ({
    signal,
  }) => songsIndex(library, params, requestOptions, signal);

  return { queryKey, queryFn, ...queryOptions } as UseSuspenseQueryOptions<
    SongsIndex200,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type SongsIndexSuspenseQueryResult = NonNullable<
  SongsIndex200
>;
export type SongsIndexSuspenseQueryError = ErrorType<
  | SongsIndex400
  | AuthenticationExceptionResponse
  | ModelNotFoundExceptionResponse
  | ValidationExceptionResponse
>;

export function useSongsIndexSuspense<
  TData = SongsIndex200,
  TError = ErrorType<
    | SongsIndex400
    | AuthenticationExceptionResponse
    | ModelNotFoundExceptionResponse
    | ValidationExceptionResponse
  >
>(
  library: string,
  params: undefined | SongsIndexParams,
  options: {
    query: Partial<
      UseSuspenseQueryOptions<
        SongsIndex200,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useSongsIndexSuspense<
  TData = SongsIndex200,
  TError = ErrorType<
    | SongsIndex400
    | AuthenticationExceptionResponse
    | ModelNotFoundExceptionResponse
    | ValidationExceptionResponse
  >
>(
  library: string,
  params?: SongsIndexParams,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        SongsIndex200,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useSongsIndexSuspense<
  TData = SongsIndex200,
  TError = ErrorType<
    | SongsIndex400
    | AuthenticationExceptionResponse
    | ModelNotFoundExceptionResponse
    | ValidationExceptionResponse
  >
>(
  library: string,
  params?: SongsIndexParams,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        SongsIndex200,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get a paginated collection of songs from a specific library
 */

export function useSongsIndexSuspense<
  TData = SongsIndex200,
  TError = ErrorType<
    | SongsIndex400
    | AuthenticationExceptionResponse
    | ModelNotFoundExceptionResponse
    | ValidationExceptionResponse
  >
>(
  library: string,
  params?: SongsIndexParams,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        SongsIndex200,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getSongsIndexSuspenseQueryOptions(
    library,
    params,
    options
  );

  const query = useSuspenseQuery(
    queryOptions,
    queryClient
  ) as UseSuspenseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getSongsIndexSuspenseInfiniteQueryOptions = <
  TData = InfiniteData<
    SongsIndex200,
    SongsIndexParams["page"]
  >,
  TError = ErrorType<
    | SongsIndex400
    | AuthenticationExceptionResponse
    | ModelNotFoundExceptionResponse
    | ValidationExceptionResponse
  >
>(
  library: string,
  params?: SongsIndexParams,
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        SongsIndex200,
        TError,
        TData,
        QueryKey,
        SongsIndexParams["page"]
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getSongsIndexInfiniteQueryKey(library, params);

  const queryFn: QueryFunction<
    SongsIndex200,
    QueryKey,
    SongsIndexParams["page"]
  > = ({ signal, pageParam }) =>
    songsIndex(
      library,
      { ...params, page: pageParam || params?.["page"] },
      requestOptions,
      signal
    );

  return {
    queryKey,
    queryFn,
    ...queryOptions,
  } as UseSuspenseInfiniteQueryOptions<
    SongsIndex200,
    TError,
    TData,
    QueryKey,
    SongsIndexParams["page"]
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type SongsIndexSuspenseInfiniteQueryResult = NonNullable<
  SongsIndex200
>;
export type SongsIndexSuspenseInfiniteQueryError = ErrorType<
  | SongsIndex400
  | AuthenticationExceptionResponse
  | ModelNotFoundExceptionResponse
  | ValidationExceptionResponse
>;

export function useSongsIndexSuspenseInfinite<
  TData = InfiniteData<
    SongsIndex200,
    SongsIndexParams["page"]
  >,
  TError = ErrorType<
    | SongsIndex400
    | AuthenticationExceptionResponse
    | ModelNotFoundExceptionResponse
    | ValidationExceptionResponse
  >
>(
  library: string,
  params: undefined | SongsIndexParams,
  options: {
    query: Partial<
      UseSuspenseInfiniteQueryOptions<
        SongsIndex200,
        TError,
        TData,
        QueryKey,
        SongsIndexParams["page"]
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useSongsIndexSuspenseInfinite<
  TData = InfiniteData<
    SongsIndex200,
    SongsIndexParams["page"]
  >,
  TError = ErrorType<
    | SongsIndex400
    | AuthenticationExceptionResponse
    | ModelNotFoundExceptionResponse
    | ValidationExceptionResponse
  >
>(
  library: string,
  params?: SongsIndexParams,
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        SongsIndex200,
        TError,
        TData,
        QueryKey,
        SongsIndexParams["page"]
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useSongsIndexSuspenseInfinite<
  TData = InfiniteData<
    SongsIndex200,
    SongsIndexParams["page"]
  >,
  TError = ErrorType<
    | SongsIndex400
    | AuthenticationExceptionResponse
    | ModelNotFoundExceptionResponse
    | ValidationExceptionResponse
  >
>(
  library: string,
  params?: SongsIndexParams,
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        SongsIndex200,
        TError,
        TData,
        QueryKey,
        SongsIndexParams["page"]
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get a paginated collection of songs from a specific library
 */

export function useSongsIndexSuspenseInfinite<
  TData = InfiniteData<
    SongsIndex200,
    SongsIndexParams["page"]
  >,
  TError = ErrorType<
    | SongsIndex400
    | AuthenticationExceptionResponse
    | ModelNotFoundExceptionResponse
    | ValidationExceptionResponse
  >
>(
  library: string,
  params?: SongsIndexParams,
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        SongsIndex200,
        TError,
        TData,
        QueryKey,
        SongsIndexParams["page"]
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getSongsIndexSuspenseInfiniteQueryOptions(
    library,
    params,
    options
  );

  const query = useSuspenseInfiniteQuery(
    queryOptions,
    queryClient
  ) as UseSuspenseInfiniteQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Retrieves a single song from the specified library using its public ID.
Supports relation inclusion for comprehensive song information including
artists, album data, genres, and audio metadata.
 * @summary Get a specific song by its public identifier
 */
export const songsShow = (
  library: string,
  publicId: string,
  params?: SongsShowParams,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal
) => {
  return customInstance<SongResource>(
    {
      url: `/api/libraries/${library}/songs/${publicId}`,
      method: "GET",
      params,
      signal,
    },
    options
  );
};

export const getSongsShowInfiniteQueryKey = (
  library?: string,
  publicId?: string,
  params?: SongsShowParams
) => {
  return [
    "infinite",
    `/api/libraries/${library}/songs/${publicId}`,
    ...(params ? [params] : []),
  ] as const;
};

export const getSongsShowQueryKey = (
  library?: string,
  publicId?: string,
  params?: SongsShowParams
) => {
  return [
    `/api/libraries/${library}/songs/${publicId}`,
    ...(params ? [params] : []),
  ] as const;
};

export const getSongsShowInfiniteQueryOptions = <
  TData = InfiniteData<
    Awaited<ReturnType<typeof songsShow>>,
    SongsShowParams["page"]
  >,
  TError = ErrorType<
    | AuthenticationExceptionResponse
    | ModelNotFoundExceptionResponse
    | ValidationExceptionResponse
  >
>(
  library: string,
  publicId: string,
  params?: SongsShowParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof songsShow>>,
        TError,
        TData,
        QueryKey,
        SongsShowParams["page"]
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getSongsShowInfiniteQueryKey(library, publicId, params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof songsShow>>,
    QueryKey,
    SongsShowParams["page"]
  > = ({ signal, pageParam }) =>
    songsShow(
      library,
      publicId,
      { ...params, page: pageParam || params?.["page"] },
      requestOptions,
      signal
    );

  return {
    queryKey,
    queryFn,
    enabled: !!(library && publicId),
    ...queryOptions,
  } as UseInfiniteQueryOptions<
    Awaited<ReturnType<typeof songsShow>>,
    TError,
    TData,
    QueryKey,
    SongsShowParams["page"]
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type SongsShowInfiniteQueryResult = NonNullable<
  Awaited<ReturnType<typeof songsShow>>
>;
export type SongsShowInfiniteQueryError = ErrorType<
  | AuthenticationExceptionResponse
  | ModelNotFoundExceptionResponse
  | ValidationExceptionResponse
>;

export function useSongsShowInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof songsShow>>,
    SongsShowParams["page"]
  >,
  TError = ErrorType<
    | AuthenticationExceptionResponse
    | ModelNotFoundExceptionResponse
    | ValidationExceptionResponse
  >
>(
  library: string,
  publicId: string,
  params: undefined | SongsShowParams,
  options: {
    query: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof songsShow>>,
        TError,
        TData,
        QueryKey,
        SongsShowParams["page"]
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof songsShow>>,
          TError,
          Awaited<ReturnType<typeof songsShow>>,
          QueryKey
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): DefinedUseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useSongsShowInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof songsShow>>,
    SongsShowParams["page"]
  >,
  TError = ErrorType<
    | AuthenticationExceptionResponse
    | ModelNotFoundExceptionResponse
    | ValidationExceptionResponse
  >
>(
  library: string,
  publicId: string,
  params?: SongsShowParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof songsShow>>,
        TError,
        TData,
        QueryKey,
        SongsShowParams["page"]
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof songsShow>>,
          TError,
          Awaited<ReturnType<typeof songsShow>>,
          QueryKey
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useSongsShowInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof songsShow>>,
    SongsShowParams["page"]
  >,
  TError = ErrorType<
    | AuthenticationExceptionResponse
    | ModelNotFoundExceptionResponse
    | ValidationExceptionResponse
  >
>(
  library: string,
  publicId: string,
  params?: SongsShowParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof songsShow>>,
        TError,
        TData,
        QueryKey,
        SongsShowParams["page"]
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get a specific song by its public identifier
 */

export function useSongsShowInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof songsShow>>,
    SongsShowParams["page"]
  >,
  TError = ErrorType<
    | AuthenticationExceptionResponse
    | ModelNotFoundExceptionResponse
    | ValidationExceptionResponse
  >
>(
  library: string,
  publicId: string,
  params?: SongsShowParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof songsShow>>,
        TError,
        TData,
        QueryKey,
        SongsShowParams["page"]
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getSongsShowInfiniteQueryOptions(
    library,
    publicId,
    params,
    options
  );

  const query = useInfiniteQuery(
    queryOptions,
    queryClient
  ) as UseInfiniteQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getSongsShowQueryOptions = <
  TData = Awaited<ReturnType<typeof songsShow>>,
  TError = ErrorType<
    | AuthenticationExceptionResponse
    | ModelNotFoundExceptionResponse
    | ValidationExceptionResponse
  >
>(
  library: string,
  publicId: string,
  params?: SongsShowParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof songsShow>>, TError, TData>
    >;
    request?: SecondParameter<typeof customInstance>;
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getSongsShowQueryKey(library, publicId, params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof songsShow>>> = ({
    signal,
  }) => songsShow(library, publicId, params, requestOptions, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!(library && publicId),
    ...queryOptions,
  } as UseQueryOptions<Awaited<ReturnType<typeof songsShow>>, TError, TData> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };
};

export type SongsShowQueryResult = NonNullable<
  Awaited<ReturnType<typeof songsShow>>
>;
export type SongsShowQueryError = ErrorType<
  | AuthenticationExceptionResponse
  | ModelNotFoundExceptionResponse
  | ValidationExceptionResponse
>;

export function useSongsShow<
  TData = Awaited<ReturnType<typeof songsShow>>,
  TError = ErrorType<
    | AuthenticationExceptionResponse
    | ModelNotFoundExceptionResponse
    | ValidationExceptionResponse
  >
>(
  library: string,
  publicId: string,
  params: undefined | SongsShowParams,
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof songsShow>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof songsShow>>,
          TError,
          Awaited<ReturnType<typeof songsShow>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useSongsShow<
  TData = Awaited<ReturnType<typeof songsShow>>,
  TError = ErrorType<
    | AuthenticationExceptionResponse
    | ModelNotFoundExceptionResponse
    | ValidationExceptionResponse
  >
>(
  library: string,
  publicId: string,
  params?: SongsShowParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof songsShow>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof songsShow>>,
          TError,
          Awaited<ReturnType<typeof songsShow>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useSongsShow<
  TData = Awaited<ReturnType<typeof songsShow>>,
  TError = ErrorType<
    | AuthenticationExceptionResponse
    | ModelNotFoundExceptionResponse
    | ValidationExceptionResponse
  >
>(
  library: string,
  publicId: string,
  params?: SongsShowParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof songsShow>>, TError, TData>
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get a specific song by its public identifier
 */

export function useSongsShow<
  TData = Awaited<ReturnType<typeof songsShow>>,
  TError = ErrorType<
    | AuthenticationExceptionResponse
    | ModelNotFoundExceptionResponse
    | ValidationExceptionResponse
  >
>(
  library: string,
  publicId: string,
  params?: SongsShowParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof songsShow>>, TError, TData>
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getSongsShowQueryOptions(
    library,
    publicId,
    params,
    options
  );

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getSongsShowSuspenseQueryOptions = <
  TData = Awaited<ReturnType<typeof songsShow>>,
  TError = ErrorType<
    | AuthenticationExceptionResponse
    | ModelNotFoundExceptionResponse
    | ValidationExceptionResponse
  >
>(
  library: string,
  publicId: string,
  params?: SongsShowParams,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof songsShow>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getSongsShowQueryKey(library, publicId, params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof songsShow>>> = ({
    signal,
  }) => songsShow(library, publicId, params, requestOptions, signal);

  return { queryKey, queryFn, ...queryOptions } as UseSuspenseQueryOptions<
    Awaited<ReturnType<typeof songsShow>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type SongsShowSuspenseQueryResult = NonNullable<
  Awaited<ReturnType<typeof songsShow>>
>;
export type SongsShowSuspenseQueryError = ErrorType<
  | AuthenticationExceptionResponse
  | ModelNotFoundExceptionResponse
  | ValidationExceptionResponse
>;

export function useSongsShowSuspense<
  TData = Awaited<ReturnType<typeof songsShow>>,
  TError = ErrorType<
    | AuthenticationExceptionResponse
    | ModelNotFoundExceptionResponse
    | ValidationExceptionResponse
  >
>(
  library: string,
  publicId: string,
  params: undefined | SongsShowParams,
  options: {
    query: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof songsShow>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useSongsShowSuspense<
  TData = Awaited<ReturnType<typeof songsShow>>,
  TError = ErrorType<
    | AuthenticationExceptionResponse
    | ModelNotFoundExceptionResponse
    | ValidationExceptionResponse
  >
>(
  library: string,
  publicId: string,
  params?: SongsShowParams,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof songsShow>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useSongsShowSuspense<
  TData = Awaited<ReturnType<typeof songsShow>>,
  TError = ErrorType<
    | AuthenticationExceptionResponse
    | ModelNotFoundExceptionResponse
    | ValidationExceptionResponse
  >
>(
  library: string,
  publicId: string,
  params?: SongsShowParams,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof songsShow>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get a specific song by its public identifier
 */

export function useSongsShowSuspense<
  TData = Awaited<ReturnType<typeof songsShow>>,
  TError = ErrorType<
    | AuthenticationExceptionResponse
    | ModelNotFoundExceptionResponse
    | ValidationExceptionResponse
  >
>(
  library: string,
  publicId: string,
  params?: SongsShowParams,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof songsShow>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getSongsShowSuspenseQueryOptions(
    library,
    publicId,
    params,
    options
  );

  const query = useSuspenseQuery(
    queryOptions,
    queryClient
  ) as UseSuspenseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getSongsShowSuspenseInfiniteQueryOptions = <
  TData = InfiniteData<
    Awaited<ReturnType<typeof songsShow>>,
    SongsShowParams["page"]
  >,
  TError = ErrorType<
    | AuthenticationExceptionResponse
    | ModelNotFoundExceptionResponse
    | ValidationExceptionResponse
  >
>(
  library: string,
  publicId: string,
  params?: SongsShowParams,
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof songsShow>>,
        TError,
        TData,
        QueryKey,
        SongsShowParams["page"]
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getSongsShowInfiniteQueryKey(library, publicId, params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof songsShow>>,
    QueryKey,
    SongsShowParams["page"]
  > = ({ signal, pageParam }) =>
    songsShow(
      library,
      publicId,
      { ...params, page: pageParam || params?.["page"] },
      requestOptions,
      signal
    );

  return {
    queryKey,
    queryFn,
    ...queryOptions,
  } as UseSuspenseInfiniteQueryOptions<
    Awaited<ReturnType<typeof songsShow>>,
    TError,
    TData,
    QueryKey,
    SongsShowParams["page"]
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type SongsShowSuspenseInfiniteQueryResult = NonNullable<
  Awaited<ReturnType<typeof songsShow>>
>;
export type SongsShowSuspenseInfiniteQueryError = ErrorType<
  | AuthenticationExceptionResponse
  | ModelNotFoundExceptionResponse
  | ValidationExceptionResponse
>;

export function useSongsShowSuspenseInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof songsShow>>,
    SongsShowParams["page"]
  >,
  TError = ErrorType<
    | AuthenticationExceptionResponse
    | ModelNotFoundExceptionResponse
    | ValidationExceptionResponse
  >
>(
  library: string,
  publicId: string,
  params: undefined | SongsShowParams,
  options: {
    query: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof songsShow>>,
        TError,
        TData,
        QueryKey,
        SongsShowParams["page"]
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useSongsShowSuspenseInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof songsShow>>,
    SongsShowParams["page"]
  >,
  TError = ErrorType<
    | AuthenticationExceptionResponse
    | ModelNotFoundExceptionResponse
    | ValidationExceptionResponse
  >
>(
  library: string,
  publicId: string,
  params?: SongsShowParams,
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof songsShow>>,
        TError,
        TData,
        QueryKey,
        SongsShowParams["page"]
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useSongsShowSuspenseInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof songsShow>>,
    SongsShowParams["page"]
  >,
  TError = ErrorType<
    | AuthenticationExceptionResponse
    | ModelNotFoundExceptionResponse
    | ValidationExceptionResponse
  >
>(
  library: string,
  publicId: string,
  params?: SongsShowParams,
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof songsShow>>,
        TError,
        TData,
        QueryKey,
        SongsShowParams["page"]
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get a specific song by its public identifier
 */

export function useSongsShowSuspenseInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof songsShow>>,
    SongsShowParams["page"]
  >,
  TError = ErrorType<
    | AuthenticationExceptionResponse
    | ModelNotFoundExceptionResponse
    | ValidationExceptionResponse
  >
>(
  library: string,
  publicId: string,
  params?: SongsShowParams,
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof songsShow>>,
        TError,
        TData,
        QueryKey,
        SongsShowParams["page"]
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getSongsShowSuspenseInfiniteQueryOptions(
    library,
    publicId,
    params,
    options
  );

  const query = useSuspenseInfiniteQuery(
    queryOptions,
    queryClient
  ) as UseSuspenseInfiniteQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Updates song metadata and information using the provided data.
Only the fields included in the request will be modified.
 * @summary Update an existing song
 */
export const songsUpdate = (
  library: string,
  song: string,
  songUpdateRequest: BodyType<SongUpdateRequest>,
  options?: SecondParameter<typeof customInstance>
) => {
  return customInstance<SongResource>(
    {
      url: `/api/libraries/${library}/songs/${song}`,
      method: "PUT",
      headers: { "Content-Type": "application/json" },
      data: songUpdateRequest,
    },
    options
  );
};

export const getSongsUpdateMutationOptions = <
  TError = ErrorType<
    | AuthenticationExceptionResponse
    | ModelNotFoundExceptionResponse
    | ValidationExceptionResponse
  >,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof songsUpdate>>,
    TError,
    { library: string; song: string; data: BodyType<SongUpdateRequest> },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof songsUpdate>>,
  TError,
  { library: string; song: string; data: BodyType<SongUpdateRequest> },
  TContext
> => {
  const mutationKey = ["songsUpdate"];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof songsUpdate>>,
    { library: string; song: string; data: BodyType<SongUpdateRequest> }
  > = (props) => {
    const { library, song, data } = props ?? {};

    return songsUpdate(library, song, data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type SongsUpdateMutationResult = NonNullable<
  Awaited<ReturnType<typeof songsUpdate>>
>;
export type SongsUpdateMutationBody = BodyType<SongUpdateRequest>;
export type SongsUpdateMutationError = ErrorType<
  | AuthenticationExceptionResponse
  | ModelNotFoundExceptionResponse
  | ValidationExceptionResponse
>;

/**
 * @summary Update an existing song
 */
export const useSongsUpdate = <
  TError = ErrorType<
    | AuthenticationExceptionResponse
    | ModelNotFoundExceptionResponse
    | ValidationExceptionResponse
  >,
  TContext = unknown
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof songsUpdate>>,
      TError,
      { library: string; song: string; data: BodyType<SongUpdateRequest> },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof songsUpdate>>,
  TError,
  { library: string; song: string; data: BodyType<SongUpdateRequest> },
  TContext
> => {
  const mutationOptions = getSongsUpdateMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
