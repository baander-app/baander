/**
 * Generated by orval v7.11.2 üç∫
 * Do not edit manually.
 * B√•nder api docs
 * B√•nder.App is a sophisticated media server developed with the primary goal to deliver high performance and seamless experience for users.
Being built on top of Laravel framework and PostgreSQL for database, it leverages the power of robust backend technologies, providing high security, reliability, and scalability.

The main focus of B√•nder.App is efficient media management and delivery.
This application is designed to handle large amounts of media files while ensuring quick and efficient access.
Implemented queuing functionality through Redis offers efficient job management and load handling.
The media information is organized and easily searchable, ensuring users can always find what they are looking for quickly and easily.
 * OpenAPI spec version: 0.0.1
 */
import {
  useInfiniteQuery,
  useQuery,
  useSuspenseInfiniteQuery,
  useSuspenseQuery,
} from "@tanstack/react-query";
import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseInfiniteQueryResult,
  DefinedUseQueryResult,
  InfiniteData,
  QueryClient,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseInfiniteQueryOptions,
  UseInfiniteQueryResult,
  UseQueryOptions,
  UseQueryResult,
  UseSuspenseInfiniteQueryOptions,
  UseSuspenseInfiniteQueryResult,
  UseSuspenseQueryOptions,
  UseSuspenseQueryResult,
} from "@tanstack/react-query";

import { customInstance } from "../../../axios-instance";
import type { ErrorType } from "../../../axios-instance";

type SecondParameter<T extends (...args: never) => unknown> = Parameters<T>[1];

/**
 * @summary Get the current queue workload for the application
 */
export const horizonWorkloadIndex = (
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal
) => {
  return customInstance<unknown[]>(
    { url: `/-/horizon/api/workload`, method: "GET", signal },
    options
  );
};

export const getHorizonWorkloadIndexQueryKey = () => {
  return [`/-/horizon/api/workload`] as const;
};

export const getHorizonWorkloadIndexInfiniteQueryOptions = <
  TData = InfiniteData<Awaited<ReturnType<typeof horizonWorkloadIndex>>>,
  TError = ErrorType<unknown>
>(options?: {
  query?: Partial<
    UseInfiniteQueryOptions<
      Awaited<ReturnType<typeof horizonWorkloadIndex>>,
      TError,
      TData
    >
  >;
  request?: SecondParameter<typeof customInstance>;
}) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getHorizonWorkloadIndexQueryKey();

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof horizonWorkloadIndex>>
  > = ({ signal }) => horizonWorkloadIndex(requestOptions, signal);

  return { queryKey, queryFn, ...queryOptions } as UseInfiniteQueryOptions<
    Awaited<ReturnType<typeof horizonWorkloadIndex>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type HorizonWorkloadIndexInfiniteQueryResult = NonNullable<
  Awaited<ReturnType<typeof horizonWorkloadIndex>>
>;
export type HorizonWorkloadIndexInfiniteQueryError = ErrorType<unknown>;

export function useHorizonWorkloadIndexInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof horizonWorkloadIndex>>>,
  TError = ErrorType<unknown>
>(
  options: {
    query: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof horizonWorkloadIndex>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof horizonWorkloadIndex>>,
          TError,
          Awaited<ReturnType<typeof horizonWorkloadIndex>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): DefinedUseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useHorizonWorkloadIndexInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof horizonWorkloadIndex>>>,
  TError = ErrorType<unknown>
>(
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof horizonWorkloadIndex>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof horizonWorkloadIndex>>,
          TError,
          Awaited<ReturnType<typeof horizonWorkloadIndex>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useHorizonWorkloadIndexInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof horizonWorkloadIndex>>>,
  TError = ErrorType<unknown>
>(
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof horizonWorkloadIndex>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get the current queue workload for the application
 */

export function useHorizonWorkloadIndexInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof horizonWorkloadIndex>>>,
  TError = ErrorType<unknown>
>(
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof horizonWorkloadIndex>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getHorizonWorkloadIndexInfiniteQueryOptions(options);

  const query = useInfiniteQuery(
    queryOptions,
    queryClient
  ) as UseInfiniteQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getHorizonWorkloadIndexQueryOptions = <
  TData = Awaited<ReturnType<typeof horizonWorkloadIndex>>,
  TError = ErrorType<unknown>
>(options?: {
  query?: Partial<
    UseQueryOptions<
      Awaited<ReturnType<typeof horizonWorkloadIndex>>,
      TError,
      TData
    >
  >;
  request?: SecondParameter<typeof customInstance>;
}) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getHorizonWorkloadIndexQueryKey();

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof horizonWorkloadIndex>>
  > = ({ signal }) => horizonWorkloadIndex(requestOptions, signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof horizonWorkloadIndex>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type HorizonWorkloadIndexQueryResult = NonNullable<
  Awaited<ReturnType<typeof horizonWorkloadIndex>>
>;
export type HorizonWorkloadIndexQueryError = ErrorType<unknown>;

export function useHorizonWorkloadIndex<
  TData = Awaited<ReturnType<typeof horizonWorkloadIndex>>,
  TError = ErrorType<unknown>
>(
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof horizonWorkloadIndex>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof horizonWorkloadIndex>>,
          TError,
          Awaited<ReturnType<typeof horizonWorkloadIndex>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useHorizonWorkloadIndex<
  TData = Awaited<ReturnType<typeof horizonWorkloadIndex>>,
  TError = ErrorType<unknown>
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof horizonWorkloadIndex>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof horizonWorkloadIndex>>,
          TError,
          Awaited<ReturnType<typeof horizonWorkloadIndex>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useHorizonWorkloadIndex<
  TData = Awaited<ReturnType<typeof horizonWorkloadIndex>>,
  TError = ErrorType<unknown>
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof horizonWorkloadIndex>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get the current queue workload for the application
 */

export function useHorizonWorkloadIndex<
  TData = Awaited<ReturnType<typeof horizonWorkloadIndex>>,
  TError = ErrorType<unknown>
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof horizonWorkloadIndex>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getHorizonWorkloadIndexQueryOptions(options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getHorizonWorkloadIndexSuspenseQueryOptions = <
  TData = Awaited<ReturnType<typeof horizonWorkloadIndex>>,
  TError = ErrorType<unknown>
>(options?: {
  query?: Partial<
    UseSuspenseQueryOptions<
      Awaited<ReturnType<typeof horizonWorkloadIndex>>,
      TError,
      TData
    >
  >;
  request?: SecondParameter<typeof customInstance>;
}) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getHorizonWorkloadIndexQueryKey();

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof horizonWorkloadIndex>>
  > = ({ signal }) => horizonWorkloadIndex(requestOptions, signal);

  return { queryKey, queryFn, ...queryOptions } as UseSuspenseQueryOptions<
    Awaited<ReturnType<typeof horizonWorkloadIndex>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type HorizonWorkloadIndexSuspenseQueryResult = NonNullable<
  Awaited<ReturnType<typeof horizonWorkloadIndex>>
>;
export type HorizonWorkloadIndexSuspenseQueryError = ErrorType<unknown>;

export function useHorizonWorkloadIndexSuspense<
  TData = Awaited<ReturnType<typeof horizonWorkloadIndex>>,
  TError = ErrorType<unknown>
>(
  options: {
    query: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof horizonWorkloadIndex>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useHorizonWorkloadIndexSuspense<
  TData = Awaited<ReturnType<typeof horizonWorkloadIndex>>,
  TError = ErrorType<unknown>
>(
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof horizonWorkloadIndex>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useHorizonWorkloadIndexSuspense<
  TData = Awaited<ReturnType<typeof horizonWorkloadIndex>>,
  TError = ErrorType<unknown>
>(
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof horizonWorkloadIndex>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get the current queue workload for the application
 */

export function useHorizonWorkloadIndexSuspense<
  TData = Awaited<ReturnType<typeof horizonWorkloadIndex>>,
  TError = ErrorType<unknown>
>(
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof horizonWorkloadIndex>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getHorizonWorkloadIndexSuspenseQueryOptions(options);

  const query = useSuspenseQuery(
    queryOptions,
    queryClient
  ) as UseSuspenseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getHorizonWorkloadIndexSuspenseInfiniteQueryOptions = <
  TData = InfiniteData<Awaited<ReturnType<typeof horizonWorkloadIndex>>>,
  TError = ErrorType<unknown>
>(options?: {
  query?: Partial<
    UseSuspenseInfiniteQueryOptions<
      Awaited<ReturnType<typeof horizonWorkloadIndex>>,
      TError,
      TData
    >
  >;
  request?: SecondParameter<typeof customInstance>;
}) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getHorizonWorkloadIndexQueryKey();

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof horizonWorkloadIndex>>
  > = ({ signal }) => horizonWorkloadIndex(requestOptions, signal);

  return {
    queryKey,
    queryFn,
    ...queryOptions,
  } as UseSuspenseInfiniteQueryOptions<
    Awaited<ReturnType<typeof horizonWorkloadIndex>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type HorizonWorkloadIndexSuspenseInfiniteQueryResult = NonNullable<
  Awaited<ReturnType<typeof horizonWorkloadIndex>>
>;
export type HorizonWorkloadIndexSuspenseInfiniteQueryError = ErrorType<unknown>;

export function useHorizonWorkloadIndexSuspenseInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof horizonWorkloadIndex>>>,
  TError = ErrorType<unknown>
>(
  options: {
    query: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof horizonWorkloadIndex>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useHorizonWorkloadIndexSuspenseInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof horizonWorkloadIndex>>>,
  TError = ErrorType<unknown>
>(
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof horizonWorkloadIndex>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useHorizonWorkloadIndexSuspenseInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof horizonWorkloadIndex>>>,
  TError = ErrorType<unknown>
>(
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof horizonWorkloadIndex>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get the current queue workload for the application
 */

export function useHorizonWorkloadIndexSuspenseInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof horizonWorkloadIndex>>>,
  TError = ErrorType<unknown>
>(
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof horizonWorkloadIndex>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions =
    getHorizonWorkloadIndexSuspenseInfiniteQueryOptions(options);

  const query = useSuspenseInfiniteQuery(
    queryOptions,
    queryClient
  ) as UseSuspenseInfiniteQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}
