/**
 * Generated by orval v7.11.2 üç∫
 * Do not edit manually.
 * B√•nder api docs
 * B√•nder.App is a sophisticated media server developed with the primary goal to deliver high performance and seamless experience for users.
Being built on top of Laravel framework and PostgreSQL for database, it leverages the power of robust backend technologies, providing high security, reliability, and scalability.

The main focus of B√•nder.App is efficient media management and delivery.
This application is designed to handle large amounts of media files while ensuring quick and efficient access.
Implemented queuing functionality through Redis offers efficient job management and load handling.
The media information is organized and easily searchable, ensuring users can always find what they are looking for quickly and easily.
 * OpenAPI spec version: 0.0.1
 */
import {
  useInfiniteQuery,
  useMutation,
  useQuery,
  useSuspenseInfiniteQuery,
  useSuspenseQuery,
} from "@tanstack/react-query";
import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseInfiniteQueryResult,
  DefinedUseQueryResult,
  InfiniteData,
  MutationFunction,
  QueryClient,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseInfiniteQueryOptions,
  UseInfiniteQueryResult,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult,
  UseSuspenseInfiniteQueryOptions,
  UseSuspenseInfiniteQueryResult,
  UseSuspenseQueryOptions,
  UseSuspenseQueryResult,
} from "@tanstack/react-query";

import type {
  AuthenticationExceptionResponse,
  AuthorizationExceptionResponse,
  CreatePlaylistRequest,
  CreateSmartPlaylistRequest,
  ModelNotFoundExceptionResponse,
  PlaylistAddSong200,
  PlaylistCollaboratorsDestroy200,
  PlaylistCollaboratorsStore200,
  PlaylistCollaboratorsStoreBody,
  PlaylistIndex200,
  PlaylistRemoveSong200,
  PlaylistReorder200,
  PlaylistReorderBody,
  PlaylistResource,
  PlaylistShowParams,
  PlaylistSmartSync200,
  PlaylistSmartSync400,
  PlaylistSmartUpdate400,
  PlaylistStatistic,
  PlaylistStatisticsRecordFavorite200,
  PlaylistStatisticsRecordPlay200,
  PlaylistStatisticsRecordShare200,
  PlaylistStatisticsRecordView200,
  UpdatePlaylistRequest,
  UpdateSmartPlaylistRulesRequest,
  ValidationExceptionResponse,
} from "../../models";

import { customInstance } from "../../../axios-instance";
import type { ErrorType, BodyType } from "../../../axios-instance";

type SecondParameter<T extends (...args: never) => unknown> = Parameters<T>[1];

/**
 * Returns playlists owned by the authenticated user and public playlists
that are visible to all users. Results are paginated for performance.
 * @summary Get a paginated collection of playlists
 */
export const playlistIndex = (
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal
) => {
  return customInstance<PlaylistIndex200>(
    { url: `/api/playlists`, method: "GET", signal },
    options
  );
};

export const getPlaylistIndexQueryKey = () => {
  return [`/api/playlists`] as const;
};

export const getPlaylistIndexInfiniteQueryOptions = <
  TData = InfiniteData<Awaited<ReturnType<typeof playlistIndex>>>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(options?: {
  query?: Partial<
    UseInfiniteQueryOptions<
      Awaited<ReturnType<typeof playlistIndex>>,
      TError,
      TData
    >
  >;
  request?: SecondParameter<typeof customInstance>;
}) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getPlaylistIndexQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof playlistIndex>>> = ({
    signal,
  }) => playlistIndex(requestOptions, signal);

  return { queryKey, queryFn, ...queryOptions } as UseInfiniteQueryOptions<
    Awaited<ReturnType<typeof playlistIndex>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type PlaylistIndexInfiniteQueryResult = NonNullable<
  Awaited<ReturnType<typeof playlistIndex>>
>;
export type PlaylistIndexInfiniteQueryError =
  ErrorType<AuthenticationExceptionResponse>;

export function usePlaylistIndexInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof playlistIndex>>>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(
  options: {
    query: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof playlistIndex>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof playlistIndex>>,
          TError,
          Awaited<ReturnType<typeof playlistIndex>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): DefinedUseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function usePlaylistIndexInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof playlistIndex>>>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof playlistIndex>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof playlistIndex>>,
          TError,
          Awaited<ReturnType<typeof playlistIndex>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function usePlaylistIndexInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof playlistIndex>>>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof playlistIndex>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get a paginated collection of playlists
 */

export function usePlaylistIndexInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof playlistIndex>>>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof playlistIndex>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getPlaylistIndexInfiniteQueryOptions(options);

  const query = useInfiniteQuery(
    queryOptions,
    queryClient
  ) as UseInfiniteQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getPlaylistIndexQueryOptions = <
  TData = Awaited<ReturnType<typeof playlistIndex>>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof playlistIndex>>, TError, TData>
  >;
  request?: SecondParameter<typeof customInstance>;
}) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getPlaylistIndexQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof playlistIndex>>> = ({
    signal,
  }) => playlistIndex(requestOptions, signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof playlistIndex>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type PlaylistIndexQueryResult = NonNullable<
  Awaited<ReturnType<typeof playlistIndex>>
>;
export type PlaylistIndexQueryError =
  ErrorType<AuthenticationExceptionResponse>;

export function usePlaylistIndex<
  TData = Awaited<ReturnType<typeof playlistIndex>>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof playlistIndex>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof playlistIndex>>,
          TError,
          Awaited<ReturnType<typeof playlistIndex>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function usePlaylistIndex<
  TData = Awaited<ReturnType<typeof playlistIndex>>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof playlistIndex>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof playlistIndex>>,
          TError,
          Awaited<ReturnType<typeof playlistIndex>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function usePlaylistIndex<
  TData = Awaited<ReturnType<typeof playlistIndex>>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof playlistIndex>>, TError, TData>
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get a paginated collection of playlists
 */

export function usePlaylistIndex<
  TData = Awaited<ReturnType<typeof playlistIndex>>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof playlistIndex>>, TError, TData>
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getPlaylistIndexQueryOptions(options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getPlaylistIndexSuspenseQueryOptions = <
  TData = Awaited<ReturnType<typeof playlistIndex>>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(options?: {
  query?: Partial<
    UseSuspenseQueryOptions<
      Awaited<ReturnType<typeof playlistIndex>>,
      TError,
      TData
    >
  >;
  request?: SecondParameter<typeof customInstance>;
}) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getPlaylistIndexQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof playlistIndex>>> = ({
    signal,
  }) => playlistIndex(requestOptions, signal);

  return { queryKey, queryFn, ...queryOptions } as UseSuspenseQueryOptions<
    Awaited<ReturnType<typeof playlistIndex>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type PlaylistIndexSuspenseQueryResult = NonNullable<
  Awaited<ReturnType<typeof playlistIndex>>
>;
export type PlaylistIndexSuspenseQueryError =
  ErrorType<AuthenticationExceptionResponse>;

export function usePlaylistIndexSuspense<
  TData = Awaited<ReturnType<typeof playlistIndex>>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(
  options: {
    query: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof playlistIndex>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function usePlaylistIndexSuspense<
  TData = Awaited<ReturnType<typeof playlistIndex>>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof playlistIndex>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function usePlaylistIndexSuspense<
  TData = Awaited<ReturnType<typeof playlistIndex>>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof playlistIndex>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get a paginated collection of playlists
 */

export function usePlaylistIndexSuspense<
  TData = Awaited<ReturnType<typeof playlistIndex>>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof playlistIndex>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getPlaylistIndexSuspenseQueryOptions(options);

  const query = useSuspenseQuery(
    queryOptions,
    queryClient
  ) as UseSuspenseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getPlaylistIndexSuspenseInfiniteQueryOptions = <
  TData = InfiniteData<Awaited<ReturnType<typeof playlistIndex>>>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(options?: {
  query?: Partial<
    UseSuspenseInfiniteQueryOptions<
      Awaited<ReturnType<typeof playlistIndex>>,
      TError,
      TData
    >
  >;
  request?: SecondParameter<typeof customInstance>;
}) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getPlaylistIndexQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof playlistIndex>>> = ({
    signal,
  }) => playlistIndex(requestOptions, signal);

  return {
    queryKey,
    queryFn,
    ...queryOptions,
  } as UseSuspenseInfiniteQueryOptions<
    Awaited<ReturnType<typeof playlistIndex>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type PlaylistIndexSuspenseInfiniteQueryResult = NonNullable<
  Awaited<ReturnType<typeof playlistIndex>>
>;
export type PlaylistIndexSuspenseInfiniteQueryError =
  ErrorType<AuthenticationExceptionResponse>;

export function usePlaylistIndexSuspenseInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof playlistIndex>>>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(
  options: {
    query: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof playlistIndex>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function usePlaylistIndexSuspenseInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof playlistIndex>>>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof playlistIndex>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function usePlaylistIndexSuspenseInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof playlistIndex>>>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof playlistIndex>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get a paginated collection of playlists
 */

export function usePlaylistIndexSuspenseInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof playlistIndex>>>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof playlistIndex>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getPlaylistIndexSuspenseInfiniteQueryOptions(options);

  const query = useSuspenseInfiniteQuery(
    queryOptions,
    queryClient
  ) as UseSuspenseInfiniteQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Creates a new playlist owned by the authenticated user with the provided
name, description, and visibility settings.
 * @summary Create a new playlist
 */
export const playlistStore = (
  createPlaylistRequest: BodyType<CreatePlaylistRequest>,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal
) => {
  return customInstance<PlaylistResource>(
    {
      url: `/api/playlists`,
      method: "POST",
      headers: { "Content-Type": "application/json" },
      data: createPlaylistRequest,
      signal,
    },
    options
  );
};

export const getPlaylistStoreMutationOptions = <
  TError = ErrorType<
    AuthenticationExceptionResponse | ValidationExceptionResponse
  >,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof playlistStore>>,
    TError,
    { data: BodyType<CreatePlaylistRequest> },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof playlistStore>>,
  TError,
  { data: BodyType<CreatePlaylistRequest> },
  TContext
> => {
  const mutationKey = ["playlistStore"];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof playlistStore>>,
    { data: BodyType<CreatePlaylistRequest> }
  > = (props) => {
    const { data } = props ?? {};

    return playlistStore(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type PlaylistStoreMutationResult = NonNullable<
  Awaited<ReturnType<typeof playlistStore>>
>;
export type PlaylistStoreMutationBody = BodyType<CreatePlaylistRequest>;
export type PlaylistStoreMutationError = ErrorType<
  AuthenticationExceptionResponse | ValidationExceptionResponse
>;

/**
 * @summary Create a new playlist
 */
export const usePlaylistStore = <
  TError = ErrorType<
    AuthenticationExceptionResponse | ValidationExceptionResponse
  >,
  TContext = unknown
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof playlistStore>>,
      TError,
      { data: BodyType<CreatePlaylistRequest> },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof playlistStore>>,
  TError,
  { data: BodyType<CreatePlaylistRequest> },
  TContext
> => {
  const mutationOptions = getPlaylistStoreMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
/**
 * Retrieves a single playlist with comprehensive information including
songs, artists, album data, and cover art. Authorization is enforced.
 * @summary Get a specific playlist with detailed information
 */
export const playlistShow = (
  playlist: string,
  params?: PlaylistShowParams,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal
) => {
  return customInstance<PlaylistResource>(
    { url: `/api/playlists/${playlist}`, method: "GET", params, signal },
    options
  );
};

export const getPlaylistShowQueryKey = (
  playlist?: string,
  params?: PlaylistShowParams
) => {
  return [`/api/playlists/${playlist}`, ...(params ? [params] : [])] as const;
};

export const getPlaylistShowInfiniteQueryOptions = <
  TData = InfiniteData<
    Awaited<ReturnType<typeof playlistShow>>,
    PlaylistShowParams["page"]
  >,
  TError = ErrorType<
    | AuthenticationExceptionResponse
    | AuthorizationExceptionResponse
    | ModelNotFoundExceptionResponse
    | ValidationExceptionResponse
  >
>(
  playlist: string,
  params?: PlaylistShowParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof playlistShow>>,
        TError,
        TData,
        QueryKey,
        PlaylistShowParams["page"]
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getPlaylistShowQueryKey(playlist, params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof playlistShow>>,
    QueryKey,
    PlaylistShowParams["page"]
  > = ({ signal, pageParam }) =>
    playlistShow(
      playlist,
      { ...params, page: pageParam || params?.["page"] },
      requestOptions,
      signal
    );

  return {
    queryKey,
    queryFn,
    enabled: !!playlist,
    ...queryOptions,
  } as UseInfiniteQueryOptions<
    Awaited<ReturnType<typeof playlistShow>>,
    TError,
    TData,
    QueryKey,
    PlaylistShowParams["page"]
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type PlaylistShowInfiniteQueryResult = NonNullable<
  Awaited<ReturnType<typeof playlistShow>>
>;
export type PlaylistShowInfiniteQueryError = ErrorType<
  | AuthenticationExceptionResponse
  | AuthorizationExceptionResponse
  | ModelNotFoundExceptionResponse
  | ValidationExceptionResponse
>;

export function usePlaylistShowInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof playlistShow>>,
    PlaylistShowParams["page"]
  >,
  TError = ErrorType<
    | AuthenticationExceptionResponse
    | AuthorizationExceptionResponse
    | ModelNotFoundExceptionResponse
    | ValidationExceptionResponse
  >
>(
  playlist: string,
  params: undefined | PlaylistShowParams,
  options: {
    query: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof playlistShow>>,
        TError,
        TData,
        QueryKey,
        PlaylistShowParams["page"]
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof playlistShow>>,
          TError,
          Awaited<ReturnType<typeof playlistShow>>,
          QueryKey
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): DefinedUseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function usePlaylistShowInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof playlistShow>>,
    PlaylistShowParams["page"]
  >,
  TError = ErrorType<
    | AuthenticationExceptionResponse
    | AuthorizationExceptionResponse
    | ModelNotFoundExceptionResponse
    | ValidationExceptionResponse
  >
>(
  playlist: string,
  params?: PlaylistShowParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof playlistShow>>,
        TError,
        TData,
        QueryKey,
        PlaylistShowParams["page"]
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof playlistShow>>,
          TError,
          Awaited<ReturnType<typeof playlistShow>>,
          QueryKey
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function usePlaylistShowInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof playlistShow>>,
    PlaylistShowParams["page"]
  >,
  TError = ErrorType<
    | AuthenticationExceptionResponse
    | AuthorizationExceptionResponse
    | ModelNotFoundExceptionResponse
    | ValidationExceptionResponse
  >
>(
  playlist: string,
  params?: PlaylistShowParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof playlistShow>>,
        TError,
        TData,
        QueryKey,
        PlaylistShowParams["page"]
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get a specific playlist with detailed information
 */

export function usePlaylistShowInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof playlistShow>>,
    PlaylistShowParams["page"]
  >,
  TError = ErrorType<
    | AuthenticationExceptionResponse
    | AuthorizationExceptionResponse
    | ModelNotFoundExceptionResponse
    | ValidationExceptionResponse
  >
>(
  playlist: string,
  params?: PlaylistShowParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof playlistShow>>,
        TError,
        TData,
        QueryKey,
        PlaylistShowParams["page"]
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getPlaylistShowInfiniteQueryOptions(
    playlist,
    params,
    options
  );

  const query = useInfiniteQuery(
    queryOptions,
    queryClient
  ) as UseInfiniteQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getPlaylistShowQueryOptions = <
  TData = Awaited<ReturnType<typeof playlistShow>>,
  TError = ErrorType<
    | AuthenticationExceptionResponse
    | AuthorizationExceptionResponse
    | ModelNotFoundExceptionResponse
    | ValidationExceptionResponse
  >
>(
  playlist: string,
  params?: PlaylistShowParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof playlistShow>>, TError, TData>
    >;
    request?: SecondParameter<typeof customInstance>;
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getPlaylistShowQueryKey(playlist, params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof playlistShow>>> = ({
    signal,
  }) => playlistShow(playlist, params, requestOptions, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!playlist,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof playlistShow>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type PlaylistShowQueryResult = NonNullable<
  Awaited<ReturnType<typeof playlistShow>>
>;
export type PlaylistShowQueryError = ErrorType<
  | AuthenticationExceptionResponse
  | AuthorizationExceptionResponse
  | ModelNotFoundExceptionResponse
  | ValidationExceptionResponse
>;

export function usePlaylistShow<
  TData = Awaited<ReturnType<typeof playlistShow>>,
  TError = ErrorType<
    | AuthenticationExceptionResponse
    | AuthorizationExceptionResponse
    | ModelNotFoundExceptionResponse
    | ValidationExceptionResponse
  >
>(
  playlist: string,
  params: undefined | PlaylistShowParams,
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof playlistShow>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof playlistShow>>,
          TError,
          Awaited<ReturnType<typeof playlistShow>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function usePlaylistShow<
  TData = Awaited<ReturnType<typeof playlistShow>>,
  TError = ErrorType<
    | AuthenticationExceptionResponse
    | AuthorizationExceptionResponse
    | ModelNotFoundExceptionResponse
    | ValidationExceptionResponse
  >
>(
  playlist: string,
  params?: PlaylistShowParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof playlistShow>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof playlistShow>>,
          TError,
          Awaited<ReturnType<typeof playlistShow>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function usePlaylistShow<
  TData = Awaited<ReturnType<typeof playlistShow>>,
  TError = ErrorType<
    | AuthenticationExceptionResponse
    | AuthorizationExceptionResponse
    | ModelNotFoundExceptionResponse
    | ValidationExceptionResponse
  >
>(
  playlist: string,
  params?: PlaylistShowParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof playlistShow>>, TError, TData>
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get a specific playlist with detailed information
 */

export function usePlaylistShow<
  TData = Awaited<ReturnType<typeof playlistShow>>,
  TError = ErrorType<
    | AuthenticationExceptionResponse
    | AuthorizationExceptionResponse
    | ModelNotFoundExceptionResponse
    | ValidationExceptionResponse
  >
>(
  playlist: string,
  params?: PlaylistShowParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof playlistShow>>, TError, TData>
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getPlaylistShowQueryOptions(playlist, params, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getPlaylistShowSuspenseQueryOptions = <
  TData = Awaited<ReturnType<typeof playlistShow>>,
  TError = ErrorType<
    | AuthenticationExceptionResponse
    | AuthorizationExceptionResponse
    | ModelNotFoundExceptionResponse
    | ValidationExceptionResponse
  >
>(
  playlist: string,
  params?: PlaylistShowParams,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof playlistShow>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getPlaylistShowQueryKey(playlist, params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof playlistShow>>> = ({
    signal,
  }) => playlistShow(playlist, params, requestOptions, signal);

  return { queryKey, queryFn, ...queryOptions } as UseSuspenseQueryOptions<
    Awaited<ReturnType<typeof playlistShow>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type PlaylistShowSuspenseQueryResult = NonNullable<
  Awaited<ReturnType<typeof playlistShow>>
>;
export type PlaylistShowSuspenseQueryError = ErrorType<
  | AuthenticationExceptionResponse
  | AuthorizationExceptionResponse
  | ModelNotFoundExceptionResponse
  | ValidationExceptionResponse
>;

export function usePlaylistShowSuspense<
  TData = Awaited<ReturnType<typeof playlistShow>>,
  TError = ErrorType<
    | AuthenticationExceptionResponse
    | AuthorizationExceptionResponse
    | ModelNotFoundExceptionResponse
    | ValidationExceptionResponse
  >
>(
  playlist: string,
  params: undefined | PlaylistShowParams,
  options: {
    query: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof playlistShow>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function usePlaylistShowSuspense<
  TData = Awaited<ReturnType<typeof playlistShow>>,
  TError = ErrorType<
    | AuthenticationExceptionResponse
    | AuthorizationExceptionResponse
    | ModelNotFoundExceptionResponse
    | ValidationExceptionResponse
  >
>(
  playlist: string,
  params?: PlaylistShowParams,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof playlistShow>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function usePlaylistShowSuspense<
  TData = Awaited<ReturnType<typeof playlistShow>>,
  TError = ErrorType<
    | AuthenticationExceptionResponse
    | AuthorizationExceptionResponse
    | ModelNotFoundExceptionResponse
    | ValidationExceptionResponse
  >
>(
  playlist: string,
  params?: PlaylistShowParams,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof playlistShow>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get a specific playlist with detailed information
 */

export function usePlaylistShowSuspense<
  TData = Awaited<ReturnType<typeof playlistShow>>,
  TError = ErrorType<
    | AuthenticationExceptionResponse
    | AuthorizationExceptionResponse
    | ModelNotFoundExceptionResponse
    | ValidationExceptionResponse
  >
>(
  playlist: string,
  params?: PlaylistShowParams,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof playlistShow>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getPlaylistShowSuspenseQueryOptions(
    playlist,
    params,
    options
  );

  const query = useSuspenseQuery(
    queryOptions,
    queryClient
  ) as UseSuspenseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getPlaylistShowSuspenseInfiniteQueryOptions = <
  TData = InfiniteData<
    Awaited<ReturnType<typeof playlistShow>>,
    PlaylistShowParams["page"]
  >,
  TError = ErrorType<
    | AuthenticationExceptionResponse
    | AuthorizationExceptionResponse
    | ModelNotFoundExceptionResponse
    | ValidationExceptionResponse
  >
>(
  playlist: string,
  params?: PlaylistShowParams,
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof playlistShow>>,
        TError,
        TData,
        QueryKey,
        PlaylistShowParams["page"]
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getPlaylistShowQueryKey(playlist, params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof playlistShow>>,
    QueryKey,
    PlaylistShowParams["page"]
  > = ({ signal, pageParam }) =>
    playlistShow(
      playlist,
      { ...params, page: pageParam || params?.["page"] },
      requestOptions,
      signal
    );

  return {
    queryKey,
    queryFn,
    ...queryOptions,
  } as UseSuspenseInfiniteQueryOptions<
    Awaited<ReturnType<typeof playlistShow>>,
    TError,
    TData,
    QueryKey,
    PlaylistShowParams["page"]
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type PlaylistShowSuspenseInfiniteQueryResult = NonNullable<
  Awaited<ReturnType<typeof playlistShow>>
>;
export type PlaylistShowSuspenseInfiniteQueryError = ErrorType<
  | AuthenticationExceptionResponse
  | AuthorizationExceptionResponse
  | ModelNotFoundExceptionResponse
  | ValidationExceptionResponse
>;

export function usePlaylistShowSuspenseInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof playlistShow>>,
    PlaylistShowParams["page"]
  >,
  TError = ErrorType<
    | AuthenticationExceptionResponse
    | AuthorizationExceptionResponse
    | ModelNotFoundExceptionResponse
    | ValidationExceptionResponse
  >
>(
  playlist: string,
  params: undefined | PlaylistShowParams,
  options: {
    query: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof playlistShow>>,
        TError,
        TData,
        QueryKey,
        PlaylistShowParams["page"]
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function usePlaylistShowSuspenseInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof playlistShow>>,
    PlaylistShowParams["page"]
  >,
  TError = ErrorType<
    | AuthenticationExceptionResponse
    | AuthorizationExceptionResponse
    | ModelNotFoundExceptionResponse
    | ValidationExceptionResponse
  >
>(
  playlist: string,
  params?: PlaylistShowParams,
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof playlistShow>>,
        TError,
        TData,
        QueryKey,
        PlaylistShowParams["page"]
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function usePlaylistShowSuspenseInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof playlistShow>>,
    PlaylistShowParams["page"]
  >,
  TError = ErrorType<
    | AuthenticationExceptionResponse
    | AuthorizationExceptionResponse
    | ModelNotFoundExceptionResponse
    | ValidationExceptionResponse
  >
>(
  playlist: string,
  params?: PlaylistShowParams,
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof playlistShow>>,
        TError,
        TData,
        QueryKey,
        PlaylistShowParams["page"]
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get a specific playlist with detailed information
 */

export function usePlaylistShowSuspenseInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof playlistShow>>,
    PlaylistShowParams["page"]
  >,
  TError = ErrorType<
    | AuthenticationExceptionResponse
    | AuthorizationExceptionResponse
    | ModelNotFoundExceptionResponse
    | ValidationExceptionResponse
  >
>(
  playlist: string,
  params?: PlaylistShowParams,
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof playlistShow>>,
        TError,
        TData,
        QueryKey,
        PlaylistShowParams["page"]
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getPlaylistShowSuspenseInfiniteQueryOptions(
    playlist,
    params,
    options
  );

  const query = useSuspenseInfiniteQuery(
    queryOptions,
    queryClient
  ) as UseSuspenseInfiniteQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Permanently removes a playlist and all its associated data including
song associations, statistics, and collaborator relationships.
 * @summary Delete a playlist
 */
export const playlistDestroy = (
  playlist: string,
  options?: SecondParameter<typeof customInstance>
) => {
  return customInstance<null>(
    { url: `/api/playlists/${playlist}`, method: "DELETE" },
    options
  );
};

export const getPlaylistDestroyMutationOptions = <
  TError = ErrorType<
    | AuthenticationExceptionResponse
    | AuthorizationExceptionResponse
    | ModelNotFoundExceptionResponse
  >,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof playlistDestroy>>,
    TError,
    { playlist: string },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof playlistDestroy>>,
  TError,
  { playlist: string },
  TContext
> => {
  const mutationKey = ["playlistDestroy"];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof playlistDestroy>>,
    { playlist: string }
  > = (props) => {
    const { playlist } = props ?? {};

    return playlistDestroy(playlist, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type PlaylistDestroyMutationResult = NonNullable<
  Awaited<ReturnType<typeof playlistDestroy>>
>;

export type PlaylistDestroyMutationError = ErrorType<
  | AuthenticationExceptionResponse
  | AuthorizationExceptionResponse
  | ModelNotFoundExceptionResponse
>;

/**
 * @summary Delete a playlist
 */
export const usePlaylistDestroy = <
  TError = ErrorType<
    | AuthenticationExceptionResponse
    | AuthorizationExceptionResponse
    | ModelNotFoundExceptionResponse
  >,
  TContext = unknown
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof playlistDestroy>>,
      TError,
      { playlist: string },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof playlistDestroy>>,
  TError,
  { playlist: string },
  TContext
> => {
  const mutationOptions = getPlaylistDestroyMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
/**
 * Updates playlist metadata including name, description, and visibility settings.
Only playlist owners and authorized collaborators can update playlists.
 * @summary Update an existing playlist
 */
export const playlistUpdate = (
  playlist: string,
  updatePlaylistRequest: BodyType<UpdatePlaylistRequest>,
  options?: SecondParameter<typeof customInstance>
) => {
  return customInstance<PlaylistResource>(
    {
      url: `/api/playlists/${playlist}`,
      method: "PUT",
      headers: { "Content-Type": "application/json" },
      data: updatePlaylistRequest,
    },
    options
  );
};

export const getPlaylistUpdateMutationOptions = <
  TError = ErrorType<
    | AuthenticationExceptionResponse
    | AuthorizationExceptionResponse
    | ModelNotFoundExceptionResponse
    | ValidationExceptionResponse
  >,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof playlistUpdate>>,
    TError,
    { playlist: string; data: BodyType<UpdatePlaylistRequest> },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof playlistUpdate>>,
  TError,
  { playlist: string; data: BodyType<UpdatePlaylistRequest> },
  TContext
> => {
  const mutationKey = ["playlistUpdate"];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof playlistUpdate>>,
    { playlist: string; data: BodyType<UpdatePlaylistRequest> }
  > = (props) => {
    const { playlist, data } = props ?? {};

    return playlistUpdate(playlist, data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type PlaylistUpdateMutationResult = NonNullable<
  Awaited<ReturnType<typeof playlistUpdate>>
>;
export type PlaylistUpdateMutationBody = BodyType<UpdatePlaylistRequest>;
export type PlaylistUpdateMutationError = ErrorType<
  | AuthenticationExceptionResponse
  | AuthorizationExceptionResponse
  | ModelNotFoundExceptionResponse
  | ValidationExceptionResponse
>;

/**
 * @summary Update an existing playlist
 */
export const usePlaylistUpdate = <
  TError = ErrorType<
    | AuthenticationExceptionResponse
    | AuthorizationExceptionResponse
    | ModelNotFoundExceptionResponse
    | ValidationExceptionResponse
  >,
  TContext = unknown
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof playlistUpdate>>,
      TError,
      { playlist: string; data: BodyType<UpdatePlaylistRequest> },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof playlistUpdate>>,
  TError,
  { playlist: string; data: BodyType<UpdatePlaylistRequest> },
  TContext
> => {
  const mutationOptions = getPlaylistUpdateMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
/**
 * Adds a song to the specified playlist at the next available position.
Prevents duplicate songs from being added to the same playlist.
 * @summary Add a song to a playlist
 */
export const playlistAddSong = (
  playlist: string,
  song: string,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal
) => {
  return customInstance<PlaylistAddSong200>(
    { url: `/api/playlists/${playlist}/songs/${song}`, method: "POST", signal },
    options
  );
};

export const getPlaylistAddSongMutationOptions = <
  TError = ErrorType<
    | AuthenticationExceptionResponse
    | AuthorizationExceptionResponse
    | ModelNotFoundExceptionResponse
  >,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof playlistAddSong>>,
    TError,
    { playlist: string; song: string },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof playlistAddSong>>,
  TError,
  { playlist: string; song: string },
  TContext
> => {
  const mutationKey = ["playlistAddSong"];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof playlistAddSong>>,
    { playlist: string; song: string }
  > = (props) => {
    const { playlist, song } = props ?? {};

    return playlistAddSong(playlist, song, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type PlaylistAddSongMutationResult = NonNullable<
  Awaited<ReturnType<typeof playlistAddSong>>
>;

export type PlaylistAddSongMutationError = ErrorType<
  | AuthenticationExceptionResponse
  | AuthorizationExceptionResponse
  | ModelNotFoundExceptionResponse
>;

/**
 * @summary Add a song to a playlist
 */
export const usePlaylistAddSong = <
  TError = ErrorType<
    | AuthenticationExceptionResponse
    | AuthorizationExceptionResponse
    | ModelNotFoundExceptionResponse
  >,
  TContext = unknown
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof playlistAddSong>>,
      TError,
      { playlist: string; song: string },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof playlistAddSong>>,
  TError,
  { playlist: string; song: string },
  TContext
> => {
  const mutationOptions = getPlaylistAddSongMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
/**
 * Removes a song from the playlist and automatically reorders remaining
songs to maintain consecutive positioning.
 * @summary Remove a song from a playlist
 */
export const playlistRemoveSong = (
  playlist: string,
  song: string,
  options?: SecondParameter<typeof customInstance>
) => {
  return customInstance<PlaylistRemoveSong200>(
    { url: `/api/playlists/${playlist}/songs/${song}`, method: "DELETE" },
    options
  );
};

export const getPlaylistRemoveSongMutationOptions = <
  TError = ErrorType<
    | AuthenticationExceptionResponse
    | AuthorizationExceptionResponse
    | ModelNotFoundExceptionResponse
  >,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof playlistRemoveSong>>,
    TError,
    { playlist: string; song: string },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof playlistRemoveSong>>,
  TError,
  { playlist: string; song: string },
  TContext
> => {
  const mutationKey = ["playlistRemoveSong"];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof playlistRemoveSong>>,
    { playlist: string; song: string }
  > = (props) => {
    const { playlist, song } = props ?? {};

    return playlistRemoveSong(playlist, song, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type PlaylistRemoveSongMutationResult = NonNullable<
  Awaited<ReturnType<typeof playlistRemoveSong>>
>;

export type PlaylistRemoveSongMutationError = ErrorType<
  | AuthenticationExceptionResponse
  | AuthorizationExceptionResponse
  | ModelNotFoundExceptionResponse
>;

/**
 * @summary Remove a song from a playlist
 */
export const usePlaylistRemoveSong = <
  TError = ErrorType<
    | AuthenticationExceptionResponse
    | AuthorizationExceptionResponse
    | ModelNotFoundExceptionResponse
  >,
  TContext = unknown
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof playlistRemoveSong>>,
      TError,
      { playlist: string; song: string },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof playlistRemoveSong>>,
  TError,
  { playlist: string; song: string },
  TContext
> => {
  const mutationOptions = getPlaylistRemoveSongMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
/**
 * Updates the position of songs in the playlist based on the provided
ordered array of song IDs. All song IDs must exist in the playlist.
 * @summary Reorder songs in a playlist
 */
export const playlistReorder = (
  playlist: string,
  playlistReorderBody: BodyType<PlaylistReorderBody>,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal
) => {
  return customInstance<PlaylistReorder200>(
    {
      url: `/api/playlists/${playlist}/reorder`,
      method: "POST",
      headers: { "Content-Type": "application/json" },
      data: playlistReorderBody,
      signal,
    },
    options
  );
};

export const getPlaylistReorderMutationOptions = <
  TError = ErrorType<
    | AuthenticationExceptionResponse
    | AuthorizationExceptionResponse
    | ModelNotFoundExceptionResponse
    | ValidationExceptionResponse
  >,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof playlistReorder>>,
    TError,
    { playlist: string; data: BodyType<PlaylistReorderBody> },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof playlistReorder>>,
  TError,
  { playlist: string; data: BodyType<PlaylistReorderBody> },
  TContext
> => {
  const mutationKey = ["playlistReorder"];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof playlistReorder>>,
    { playlist: string; data: BodyType<PlaylistReorderBody> }
  > = (props) => {
    const { playlist, data } = props ?? {};

    return playlistReorder(playlist, data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type PlaylistReorderMutationResult = NonNullable<
  Awaited<ReturnType<typeof playlistReorder>>
>;
export type PlaylistReorderMutationBody = BodyType<PlaylistReorderBody>;
export type PlaylistReorderMutationError = ErrorType<
  | AuthenticationExceptionResponse
  | AuthorizationExceptionResponse
  | ModelNotFoundExceptionResponse
  | ValidationExceptionResponse
>;

/**
 * @summary Reorder songs in a playlist
 */
export const usePlaylistReorder = <
  TError = ErrorType<
    | AuthenticationExceptionResponse
    | AuthorizationExceptionResponse
    | ModelNotFoundExceptionResponse
    | ValidationExceptionResponse
  >,
  TContext = unknown
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof playlistReorder>>,
      TError,
      { playlist: string; data: BodyType<PlaylistReorderBody> },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof playlistReorder>>,
  TError,
  { playlist: string; data: BodyType<PlaylistReorderBody> },
  TContext
> => {
  const mutationOptions = getPlaylistReorderMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
/**
 * Adds a user as a collaborator to the playlist with the specified role.
Collaborators can have 'editor' or 'contributor' permissions.
 * @summary Add a collaborator to a playlist
 */
export const playlistCollaboratorsStore = (
  playlist: string,
  playlistCollaboratorsStoreBody: BodyType<PlaylistCollaboratorsStoreBody>,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal
) => {
  return customInstance<PlaylistCollaboratorsStore200>(
    {
      url: `/api/playlists/${playlist}/collaborators`,
      method: "POST",
      headers: { "Content-Type": "application/json" },
      data: playlistCollaboratorsStoreBody,
      signal,
    },
    options
  );
};

export const getPlaylistCollaboratorsStoreMutationOptions = <
  TError = ErrorType<
    | AuthenticationExceptionResponse
    | AuthorizationExceptionResponse
    | ModelNotFoundExceptionResponse
    | ValidationExceptionResponse
  >,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof playlistCollaboratorsStore>>,
    TError,
    { playlist: string; data: BodyType<PlaylistCollaboratorsStoreBody> },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof playlistCollaboratorsStore>>,
  TError,
  { playlist: string; data: BodyType<PlaylistCollaboratorsStoreBody> },
  TContext
> => {
  const mutationKey = ["playlistCollaboratorsStore"];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof playlistCollaboratorsStore>>,
    { playlist: string; data: BodyType<PlaylistCollaboratorsStoreBody> }
  > = (props) => {
    const { playlist, data } = props ?? {};

    return playlistCollaboratorsStore(playlist, data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type PlaylistCollaboratorsStoreMutationResult = NonNullable<
  Awaited<ReturnType<typeof playlistCollaboratorsStore>>
>;
export type PlaylistCollaboratorsStoreMutationBody =
  BodyType<PlaylistCollaboratorsStoreBody>;
export type PlaylistCollaboratorsStoreMutationError = ErrorType<
  | AuthenticationExceptionResponse
  | AuthorizationExceptionResponse
  | ModelNotFoundExceptionResponse
  | ValidationExceptionResponse
>;

/**
 * @summary Add a collaborator to a playlist
 */
export const usePlaylistCollaboratorsStore = <
  TError = ErrorType<
    | AuthenticationExceptionResponse
    | AuthorizationExceptionResponse
    | ModelNotFoundExceptionResponse
    | ValidationExceptionResponse
  >,
  TContext = unknown
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof playlistCollaboratorsStore>>,
      TError,
      { playlist: string; data: BodyType<PlaylistCollaboratorsStoreBody> },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof playlistCollaboratorsStore>>,
  TError,
  { playlist: string; data: BodyType<PlaylistCollaboratorsStoreBody> },
  TContext
> => {
  const mutationOptions = getPlaylistCollaboratorsStoreMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
/**
 * Removes a user's collaborator access from the playlist.
Only playlist owners can remove collaborators.
 * @summary Remove a collaborator from a playlist
 */
export const playlistCollaboratorsDestroy = (
  playlist: string,
  user: string,
  options?: SecondParameter<typeof customInstance>
) => {
  return customInstance<PlaylistCollaboratorsDestroy200>(
    {
      url: `/api/playlists/${playlist}/collaborators/${user}`,
      method: "DELETE",
    },
    options
  );
};

export const getPlaylistCollaboratorsDestroyMutationOptions = <
  TError = ErrorType<
    | AuthenticationExceptionResponse
    | AuthorizationExceptionResponse
    | ModelNotFoundExceptionResponse
  >,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof playlistCollaboratorsDestroy>>,
    TError,
    { playlist: string; user: string },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof playlistCollaboratorsDestroy>>,
  TError,
  { playlist: string; user: string },
  TContext
> => {
  const mutationKey = ["playlistCollaboratorsDestroy"];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof playlistCollaboratorsDestroy>>,
    { playlist: string; user: string }
  > = (props) => {
    const { playlist, user } = props ?? {};

    return playlistCollaboratorsDestroy(playlist, user, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type PlaylistCollaboratorsDestroyMutationResult = NonNullable<
  Awaited<ReturnType<typeof playlistCollaboratorsDestroy>>
>;

export type PlaylistCollaboratorsDestroyMutationError = ErrorType<
  | AuthenticationExceptionResponse
  | AuthorizationExceptionResponse
  | ModelNotFoundExceptionResponse
>;

/**
 * @summary Remove a collaborator from a playlist
 */
export const usePlaylistCollaboratorsDestroy = <
  TError = ErrorType<
    | AuthenticationExceptionResponse
    | AuthorizationExceptionResponse
    | ModelNotFoundExceptionResponse
  >,
  TContext = unknown
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof playlistCollaboratorsDestroy>>,
      TError,
      { playlist: string; user: string },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof playlistCollaboratorsDestroy>>,
  TError,
  { playlist: string; user: string },
  TContext
> => {
  const mutationOptions =
    getPlaylistCollaboratorsDestroyMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
/**
 * Creates a copy of the playlist with all songs and their positions.
The cloned playlist is owned by the current user and is private by default.
 * @summary Clone an existing playlist
 */
export const playlistClone = (
  playlist: string,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal
) => {
  return customInstance<PlaylistResource>(
    { url: `/api/playlists/${playlist}/clone`, method: "POST", signal },
    options
  );
};

export const getPlaylistCloneMutationOptions = <
  TError = ErrorType<
    | AuthenticationExceptionResponse
    | AuthorizationExceptionResponse
    | ModelNotFoundExceptionResponse
  >,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof playlistClone>>,
    TError,
    { playlist: string },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof playlistClone>>,
  TError,
  { playlist: string },
  TContext
> => {
  const mutationKey = ["playlistClone"];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof playlistClone>>,
    { playlist: string }
  > = (props) => {
    const { playlist } = props ?? {};

    return playlistClone(playlist, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type PlaylistCloneMutationResult = NonNullable<
  Awaited<ReturnType<typeof playlistClone>>
>;

export type PlaylistCloneMutationError = ErrorType<
  | AuthenticationExceptionResponse
  | AuthorizationExceptionResponse
  | ModelNotFoundExceptionResponse
>;

/**
 * @summary Clone an existing playlist
 */
export const usePlaylistClone = <
  TError = ErrorType<
    | AuthenticationExceptionResponse
    | AuthorizationExceptionResponse
    | ModelNotFoundExceptionResponse
  >,
  TContext = unknown
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof playlistClone>>,
      TError,
      { playlist: string },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof playlistClone>>,
  TError,
  { playlist: string },
  TContext
> => {
  const mutationOptions = getPlaylistCloneMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
/**
 * Retrieves comprehensive statistics for the playlist including
view count, play count, shares, and favorites.
 * @summary Get playlist statistics
 */
export const playlistStatistics = (
  playlist: string,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal
) => {
  return customInstance<PlaylistStatistic>(
    { url: `/api/playlists/${playlist}/statistics`, method: "GET", signal },
    options
  );
};

export const getPlaylistStatisticsQueryKey = (playlist?: string) => {
  return [`/api/playlists/${playlist}/statistics`] as const;
};

export const getPlaylistStatisticsInfiniteQueryOptions = <
  TData = InfiniteData<Awaited<ReturnType<typeof playlistStatistics>>>,
  TError = ErrorType<
    | AuthenticationExceptionResponse
    | AuthorizationExceptionResponse
    | ModelNotFoundExceptionResponse
  >
>(
  playlist: string,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof playlistStatistics>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getPlaylistStatisticsQueryKey(playlist);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof playlistStatistics>>
  > = ({ signal }) => playlistStatistics(playlist, requestOptions, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!playlist,
    ...queryOptions,
  } as UseInfiniteQueryOptions<
    Awaited<ReturnType<typeof playlistStatistics>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type PlaylistStatisticsInfiniteQueryResult = NonNullable<
  Awaited<ReturnType<typeof playlistStatistics>>
>;
export type PlaylistStatisticsInfiniteQueryError = ErrorType<
  | AuthenticationExceptionResponse
  | AuthorizationExceptionResponse
  | ModelNotFoundExceptionResponse
>;

export function usePlaylistStatisticsInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof playlistStatistics>>>,
  TError = ErrorType<
    | AuthenticationExceptionResponse
    | AuthorizationExceptionResponse
    | ModelNotFoundExceptionResponse
  >
>(
  playlist: string,
  options: {
    query: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof playlistStatistics>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof playlistStatistics>>,
          TError,
          Awaited<ReturnType<typeof playlistStatistics>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): DefinedUseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function usePlaylistStatisticsInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof playlistStatistics>>>,
  TError = ErrorType<
    | AuthenticationExceptionResponse
    | AuthorizationExceptionResponse
    | ModelNotFoundExceptionResponse
  >
>(
  playlist: string,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof playlistStatistics>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof playlistStatistics>>,
          TError,
          Awaited<ReturnType<typeof playlistStatistics>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function usePlaylistStatisticsInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof playlistStatistics>>>,
  TError = ErrorType<
    | AuthenticationExceptionResponse
    | AuthorizationExceptionResponse
    | ModelNotFoundExceptionResponse
  >
>(
  playlist: string,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof playlistStatistics>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get playlist statistics
 */

export function usePlaylistStatisticsInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof playlistStatistics>>>,
  TError = ErrorType<
    | AuthenticationExceptionResponse
    | AuthorizationExceptionResponse
    | ModelNotFoundExceptionResponse
  >
>(
  playlist: string,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof playlistStatistics>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getPlaylistStatisticsInfiniteQueryOptions(
    playlist,
    options
  );

  const query = useInfiniteQuery(
    queryOptions,
    queryClient
  ) as UseInfiniteQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getPlaylistStatisticsQueryOptions = <
  TData = Awaited<ReturnType<typeof playlistStatistics>>,
  TError = ErrorType<
    | AuthenticationExceptionResponse
    | AuthorizationExceptionResponse
    | ModelNotFoundExceptionResponse
  >
>(
  playlist: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof playlistStatistics>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getPlaylistStatisticsQueryKey(playlist);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof playlistStatistics>>
  > = ({ signal }) => playlistStatistics(playlist, requestOptions, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!playlist,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof playlistStatistics>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type PlaylistStatisticsQueryResult = NonNullable<
  Awaited<ReturnType<typeof playlistStatistics>>
>;
export type PlaylistStatisticsQueryError = ErrorType<
  | AuthenticationExceptionResponse
  | AuthorizationExceptionResponse
  | ModelNotFoundExceptionResponse
>;

export function usePlaylistStatistics<
  TData = Awaited<ReturnType<typeof playlistStatistics>>,
  TError = ErrorType<
    | AuthenticationExceptionResponse
    | AuthorizationExceptionResponse
    | ModelNotFoundExceptionResponse
  >
>(
  playlist: string,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof playlistStatistics>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof playlistStatistics>>,
          TError,
          Awaited<ReturnType<typeof playlistStatistics>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function usePlaylistStatistics<
  TData = Awaited<ReturnType<typeof playlistStatistics>>,
  TError = ErrorType<
    | AuthenticationExceptionResponse
    | AuthorizationExceptionResponse
    | ModelNotFoundExceptionResponse
  >
>(
  playlist: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof playlistStatistics>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof playlistStatistics>>,
          TError,
          Awaited<ReturnType<typeof playlistStatistics>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function usePlaylistStatistics<
  TData = Awaited<ReturnType<typeof playlistStatistics>>,
  TError = ErrorType<
    | AuthenticationExceptionResponse
    | AuthorizationExceptionResponse
    | ModelNotFoundExceptionResponse
  >
>(
  playlist: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof playlistStatistics>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get playlist statistics
 */

export function usePlaylistStatistics<
  TData = Awaited<ReturnType<typeof playlistStatistics>>,
  TError = ErrorType<
    | AuthenticationExceptionResponse
    | AuthorizationExceptionResponse
    | ModelNotFoundExceptionResponse
  >
>(
  playlist: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof playlistStatistics>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getPlaylistStatisticsQueryOptions(playlist, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getPlaylistStatisticsSuspenseQueryOptions = <
  TData = Awaited<ReturnType<typeof playlistStatistics>>,
  TError = ErrorType<
    | AuthenticationExceptionResponse
    | AuthorizationExceptionResponse
    | ModelNotFoundExceptionResponse
  >
>(
  playlist: string,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof playlistStatistics>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getPlaylistStatisticsQueryKey(playlist);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof playlistStatistics>>
  > = ({ signal }) => playlistStatistics(playlist, requestOptions, signal);

  return { queryKey, queryFn, ...queryOptions } as UseSuspenseQueryOptions<
    Awaited<ReturnType<typeof playlistStatistics>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type PlaylistStatisticsSuspenseQueryResult = NonNullable<
  Awaited<ReturnType<typeof playlistStatistics>>
>;
export type PlaylistStatisticsSuspenseQueryError = ErrorType<
  | AuthenticationExceptionResponse
  | AuthorizationExceptionResponse
  | ModelNotFoundExceptionResponse
>;

export function usePlaylistStatisticsSuspense<
  TData = Awaited<ReturnType<typeof playlistStatistics>>,
  TError = ErrorType<
    | AuthenticationExceptionResponse
    | AuthorizationExceptionResponse
    | ModelNotFoundExceptionResponse
  >
>(
  playlist: string,
  options: {
    query: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof playlistStatistics>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function usePlaylistStatisticsSuspense<
  TData = Awaited<ReturnType<typeof playlistStatistics>>,
  TError = ErrorType<
    | AuthenticationExceptionResponse
    | AuthorizationExceptionResponse
    | ModelNotFoundExceptionResponse
  >
>(
  playlist: string,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof playlistStatistics>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function usePlaylistStatisticsSuspense<
  TData = Awaited<ReturnType<typeof playlistStatistics>>,
  TError = ErrorType<
    | AuthenticationExceptionResponse
    | AuthorizationExceptionResponse
    | ModelNotFoundExceptionResponse
  >
>(
  playlist: string,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof playlistStatistics>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get playlist statistics
 */

export function usePlaylistStatisticsSuspense<
  TData = Awaited<ReturnType<typeof playlistStatistics>>,
  TError = ErrorType<
    | AuthenticationExceptionResponse
    | AuthorizationExceptionResponse
    | ModelNotFoundExceptionResponse
  >
>(
  playlist: string,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof playlistStatistics>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getPlaylistStatisticsSuspenseQueryOptions(
    playlist,
    options
  );

  const query = useSuspenseQuery(
    queryOptions,
    queryClient
  ) as UseSuspenseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getPlaylistStatisticsSuspenseInfiniteQueryOptions = <
  TData = InfiniteData<Awaited<ReturnType<typeof playlistStatistics>>>,
  TError = ErrorType<
    | AuthenticationExceptionResponse
    | AuthorizationExceptionResponse
    | ModelNotFoundExceptionResponse
  >
>(
  playlist: string,
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof playlistStatistics>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getPlaylistStatisticsQueryKey(playlist);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof playlistStatistics>>
  > = ({ signal }) => playlistStatistics(playlist, requestOptions, signal);

  return {
    queryKey,
    queryFn,
    ...queryOptions,
  } as UseSuspenseInfiniteQueryOptions<
    Awaited<ReturnType<typeof playlistStatistics>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type PlaylistStatisticsSuspenseInfiniteQueryResult = NonNullable<
  Awaited<ReturnType<typeof playlistStatistics>>
>;
export type PlaylistStatisticsSuspenseInfiniteQueryError = ErrorType<
  | AuthenticationExceptionResponse
  | AuthorizationExceptionResponse
  | ModelNotFoundExceptionResponse
>;

export function usePlaylistStatisticsSuspenseInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof playlistStatistics>>>,
  TError = ErrorType<
    | AuthenticationExceptionResponse
    | AuthorizationExceptionResponse
    | ModelNotFoundExceptionResponse
  >
>(
  playlist: string,
  options: {
    query: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof playlistStatistics>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function usePlaylistStatisticsSuspenseInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof playlistStatistics>>>,
  TError = ErrorType<
    | AuthenticationExceptionResponse
    | AuthorizationExceptionResponse
    | ModelNotFoundExceptionResponse
  >
>(
  playlist: string,
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof playlistStatistics>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function usePlaylistStatisticsSuspenseInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof playlistStatistics>>>,
  TError = ErrorType<
    | AuthenticationExceptionResponse
    | AuthorizationExceptionResponse
    | ModelNotFoundExceptionResponse
  >
>(
  playlist: string,
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof playlistStatistics>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get playlist statistics
 */

export function usePlaylistStatisticsSuspenseInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof playlistStatistics>>>,
  TError = ErrorType<
    | AuthenticationExceptionResponse
    | AuthorizationExceptionResponse
    | ModelNotFoundExceptionResponse
  >
>(
  playlist: string,
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof playlistStatistics>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getPlaylistStatisticsSuspenseInfiniteQueryOptions(
    playlist,
    options
  );

  const query = useSuspenseInfiniteQuery(
    queryOptions,
    queryClient
  ) as UseSuspenseInfiniteQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Record a playlist view
 */
export const playlistStatisticsRecordView = (
  playlist: string,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal
) => {
  return customInstance<PlaylistStatisticsRecordView200>(
    {
      url: `/api/playlists/${playlist}/statistics/record/view`,
      method: "POST",
      signal,
    },
    options
  );
};

export const getPlaylistStatisticsRecordViewMutationOptions = <
  TError = ErrorType<
    | AuthenticationExceptionResponse
    | AuthorizationExceptionResponse
    | ModelNotFoundExceptionResponse
  >,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof playlistStatisticsRecordView>>,
    TError,
    { playlist: string },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof playlistStatisticsRecordView>>,
  TError,
  { playlist: string },
  TContext
> => {
  const mutationKey = ["playlistStatisticsRecordView"];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof playlistStatisticsRecordView>>,
    { playlist: string }
  > = (props) => {
    const { playlist } = props ?? {};

    return playlistStatisticsRecordView(playlist, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type PlaylistStatisticsRecordViewMutationResult = NonNullable<
  Awaited<ReturnType<typeof playlistStatisticsRecordView>>
>;

export type PlaylistStatisticsRecordViewMutationError = ErrorType<
  | AuthenticationExceptionResponse
  | AuthorizationExceptionResponse
  | ModelNotFoundExceptionResponse
>;

/**
 * @summary Record a playlist view
 */
export const usePlaylistStatisticsRecordView = <
  TError = ErrorType<
    | AuthenticationExceptionResponse
    | AuthorizationExceptionResponse
    | ModelNotFoundExceptionResponse
  >,
  TContext = unknown
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof playlistStatisticsRecordView>>,
      TError,
      { playlist: string },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof playlistStatisticsRecordView>>,
  TError,
  { playlist: string },
  TContext
> => {
  const mutationOptions =
    getPlaylistStatisticsRecordViewMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
/**
 * Increments the play counter when the playlist is played.
Used for tracking playlist engagement and popularity metrics.
 * @summary Record a playlist play
 */
export const playlistStatisticsRecordPlay = (
  playlist: string,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal
) => {
  return customInstance<PlaylistStatisticsRecordPlay200>(
    {
      url: `/api/playlists/${playlist}/statistics/record/play`,
      method: "POST",
      signal,
    },
    options
  );
};

export const getPlaylistStatisticsRecordPlayMutationOptions = <
  TError = ErrorType<
    | AuthenticationExceptionResponse
    | AuthorizationExceptionResponse
    | ModelNotFoundExceptionResponse
  >,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof playlistStatisticsRecordPlay>>,
    TError,
    { playlist: string },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof playlistStatisticsRecordPlay>>,
  TError,
  { playlist: string },
  TContext
> => {
  const mutationKey = ["playlistStatisticsRecordPlay"];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof playlistStatisticsRecordPlay>>,
    { playlist: string }
  > = (props) => {
    const { playlist } = props ?? {};

    return playlistStatisticsRecordPlay(playlist, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type PlaylistStatisticsRecordPlayMutationResult = NonNullable<
  Awaited<ReturnType<typeof playlistStatisticsRecordPlay>>
>;

export type PlaylistStatisticsRecordPlayMutationError = ErrorType<
  | AuthenticationExceptionResponse
  | AuthorizationExceptionResponse
  | ModelNotFoundExceptionResponse
>;

/**
 * @summary Record a playlist play
 */
export const usePlaylistStatisticsRecordPlay = <
  TError = ErrorType<
    | AuthenticationExceptionResponse
    | AuthorizationExceptionResponse
    | ModelNotFoundExceptionResponse
  >,
  TContext = unknown
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof playlistStatisticsRecordPlay>>,
      TError,
      { playlist: string },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof playlistStatisticsRecordPlay>>,
  TError,
  { playlist: string },
  TContext
> => {
  const mutationOptions =
    getPlaylistStatisticsRecordPlayMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
/**
 * Increments the share counter when the playlist is shared.
Used for tracking viral and social engagement metrics.
 * @summary Record a playlist share
 */
export const playlistStatisticsRecordShare = (
  playlist: string,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal
) => {
  return customInstance<PlaylistStatisticsRecordShare200>(
    {
      url: `/api/playlists/${playlist}/statistics/record/share`,
      method: "POST",
      signal,
    },
    options
  );
};

export const getPlaylistStatisticsRecordShareMutationOptions = <
  TError = ErrorType<
    | AuthenticationExceptionResponse
    | AuthorizationExceptionResponse
    | ModelNotFoundExceptionResponse
  >,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof playlistStatisticsRecordShare>>,
    TError,
    { playlist: string },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof playlistStatisticsRecordShare>>,
  TError,
  { playlist: string },
  TContext
> => {
  const mutationKey = ["playlistStatisticsRecordShare"];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof playlistStatisticsRecordShare>>,
    { playlist: string }
  > = (props) => {
    const { playlist } = props ?? {};

    return playlistStatisticsRecordShare(playlist, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type PlaylistStatisticsRecordShareMutationResult = NonNullable<
  Awaited<ReturnType<typeof playlistStatisticsRecordShare>>
>;

export type PlaylistStatisticsRecordShareMutationError = ErrorType<
  | AuthenticationExceptionResponse
  | AuthorizationExceptionResponse
  | ModelNotFoundExceptionResponse
>;

/**
 * @summary Record a playlist share
 */
export const usePlaylistStatisticsRecordShare = <
  TError = ErrorType<
    | AuthenticationExceptionResponse
    | AuthorizationExceptionResponse
    | ModelNotFoundExceptionResponse
  >,
  TContext = unknown
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof playlistStatisticsRecordShare>>,
      TError,
      { playlist: string },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof playlistStatisticsRecordShare>>,
  TError,
  { playlist: string },
  TContext
> => {
  const mutationOptions =
    getPlaylistStatisticsRecordShareMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
/**
 * Increments the favorite counter when users mark the playlist as favorite.
Used for tracking user engagement and playlist quality metrics.
 * @summary Record a playlist favorite
 */
export const playlistStatisticsRecordFavorite = (
  playlist: string,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal
) => {
  return customInstance<PlaylistStatisticsRecordFavorite200>(
    {
      url: `/api/playlists/${playlist}/statistics/record/favorite`,
      method: "POST",
      signal,
    },
    options
  );
};

export const getPlaylistStatisticsRecordFavoriteMutationOptions = <
  TError = ErrorType<
    | AuthenticationExceptionResponse
    | AuthorizationExceptionResponse
    | ModelNotFoundExceptionResponse
  >,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof playlistStatisticsRecordFavorite>>,
    TError,
    { playlist: string },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof playlistStatisticsRecordFavorite>>,
  TError,
  { playlist: string },
  TContext
> => {
  const mutationKey = ["playlistStatisticsRecordFavorite"];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof playlistStatisticsRecordFavorite>>,
    { playlist: string }
  > = (props) => {
    const { playlist } = props ?? {};

    return playlistStatisticsRecordFavorite(playlist, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type PlaylistStatisticsRecordFavoriteMutationResult = NonNullable<
  Awaited<ReturnType<typeof playlistStatisticsRecordFavorite>>
>;

export type PlaylistStatisticsRecordFavoriteMutationError = ErrorType<
  | AuthenticationExceptionResponse
  | AuthorizationExceptionResponse
  | ModelNotFoundExceptionResponse
>;

/**
 * @summary Record a playlist favorite
 */
export const usePlaylistStatisticsRecordFavorite = <
  TError = ErrorType<
    | AuthenticationExceptionResponse
    | AuthorizationExceptionResponse
    | ModelNotFoundExceptionResponse
  >,
  TContext = unknown
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof playlistStatisticsRecordFavorite>>,
      TError,
      { playlist: string },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof playlistStatisticsRecordFavorite>>,
  TError,
  { playlist: string },
  TContext
> => {
  const mutationOptions =
    getPlaylistStatisticsRecordFavoriteMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
/**
 * Creates a new smart playlist that automatically populates with songs
matching the specified rules and criteria.
 * @summary Create a smart playlist
 */
export const playlistSmartCreate = (
  createSmartPlaylistRequest: BodyType<CreateSmartPlaylistRequest>,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal
) => {
  return customInstance<PlaylistResource>(
    {
      url: `/api/playlists/smart`,
      method: "POST",
      headers: { "Content-Type": "application/json" },
      data: createSmartPlaylistRequest,
      signal,
    },
    options
  );
};

export const getPlaylistSmartCreateMutationOptions = <
  TError = ErrorType<
    AuthenticationExceptionResponse | ValidationExceptionResponse
  >,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof playlistSmartCreate>>,
    TError,
    { data: BodyType<CreateSmartPlaylistRequest> },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof playlistSmartCreate>>,
  TError,
  { data: BodyType<CreateSmartPlaylistRequest> },
  TContext
> => {
  const mutationKey = ["playlistSmartCreate"];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof playlistSmartCreate>>,
    { data: BodyType<CreateSmartPlaylistRequest> }
  > = (props) => {
    const { data } = props ?? {};

    return playlistSmartCreate(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type PlaylistSmartCreateMutationResult = NonNullable<
  Awaited<ReturnType<typeof playlistSmartCreate>>
>;
export type PlaylistSmartCreateMutationBody =
  BodyType<CreateSmartPlaylistRequest>;
export type PlaylistSmartCreateMutationError = ErrorType<
  AuthenticationExceptionResponse | ValidationExceptionResponse
>;

/**
 * @summary Create a smart playlist
 */
export const usePlaylistSmartCreate = <
  TError = ErrorType<
    AuthenticationExceptionResponse | ValidationExceptionResponse
  >,
  TContext = unknown
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof playlistSmartCreate>>,
      TError,
      { data: BodyType<CreateSmartPlaylistRequest> },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof playlistSmartCreate>>,
  TError,
  { data: BodyType<CreateSmartPlaylistRequest> },
  TContext
> => {
  const mutationOptions = getPlaylistSmartCreateMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
/**
 * Manually triggers a sync of the smart playlist to refresh the song list
based on the current rules and available songs in the library.
 * @summary Synchronize smart playlist
 */
export const playlistSmartUpdate = (
  playlist: string,
  updateSmartPlaylistRulesRequest: BodyType<UpdateSmartPlaylistRulesRequest>,
  options?: SecondParameter<typeof customInstance>
) => {
  return customInstance<PlaylistResource>(
    {
      url: `/api/playlists/${playlist}/smart`,
      method: "PUT",
      headers: { "Content-Type": "application/json" },
      data: updateSmartPlaylistRulesRequest,
    },
    options
  );
};

export const getPlaylistSmartUpdateMutationOptions = <
  TError = ErrorType<
    | PlaylistSmartUpdate400
    | AuthenticationExceptionResponse
    | AuthorizationExceptionResponse
    | ModelNotFoundExceptionResponse
    | ValidationExceptionResponse
  >,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof playlistSmartUpdate>>,
    TError,
    { playlist: string; data: BodyType<UpdateSmartPlaylistRulesRequest> },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof playlistSmartUpdate>>,
  TError,
  { playlist: string; data: BodyType<UpdateSmartPlaylistRulesRequest> },
  TContext
> => {
  const mutationKey = ["playlistSmartUpdate"];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof playlistSmartUpdate>>,
    { playlist: string; data: BodyType<UpdateSmartPlaylistRulesRequest> }
  > = (props) => {
    const { playlist, data } = props ?? {};

    return playlistSmartUpdate(playlist, data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type PlaylistSmartUpdateMutationResult = NonNullable<
  Awaited<ReturnType<typeof playlistSmartUpdate>>
>;
export type PlaylistSmartUpdateMutationBody =
  BodyType<UpdateSmartPlaylistRulesRequest>;
export type PlaylistSmartUpdateMutationError = ErrorType<
  | PlaylistSmartUpdate400
  | AuthenticationExceptionResponse
  | AuthorizationExceptionResponse
  | ModelNotFoundExceptionResponse
  | ValidationExceptionResponse
>;

/**
 * @summary Synchronize smart playlist
 */
export const usePlaylistSmartUpdate = <
  TError = ErrorType<
    | PlaylistSmartUpdate400
    | AuthenticationExceptionResponse
    | AuthorizationExceptionResponse
    | ModelNotFoundExceptionResponse
    | ValidationExceptionResponse
  >,
  TContext = unknown
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof playlistSmartUpdate>>,
      TError,
      { playlist: string; data: BodyType<UpdateSmartPlaylistRulesRequest> },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof playlistSmartUpdate>>,
  TError,
  { playlist: string; data: BodyType<UpdateSmartPlaylistRulesRequest> },
  TContext
> => {
  const mutationOptions = getPlaylistSmartUpdateMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
/**
 * Updates the rules for a smart playlist and re-syncs the song list
to match the new criteria.
 * @summary Update smart playlist rules
 */
export const playlistSmartSync = (
  playlist: string,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal
) => {
  return customInstance<PlaylistSmartSync200>(
    { url: `/api/playlists/${playlist}/smart/sync`, method: "POST", signal },
    options
  );
};

export const getPlaylistSmartSyncMutationOptions = <
  TError = ErrorType<
    | PlaylistSmartSync400
    | AuthenticationExceptionResponse
    | AuthorizationExceptionResponse
    | ModelNotFoundExceptionResponse
  >,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof playlistSmartSync>>,
    TError,
    { playlist: string },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof playlistSmartSync>>,
  TError,
  { playlist: string },
  TContext
> => {
  const mutationKey = ["playlistSmartSync"];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof playlistSmartSync>>,
    { playlist: string }
  > = (props) => {
    const { playlist } = props ?? {};

    return playlistSmartSync(playlist, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type PlaylistSmartSyncMutationResult = NonNullable<
  Awaited<ReturnType<typeof playlistSmartSync>>
>;

export type PlaylistSmartSyncMutationError = ErrorType<
  | PlaylistSmartSync400
  | AuthenticationExceptionResponse
  | AuthorizationExceptionResponse
  | ModelNotFoundExceptionResponse
>;

/**
 * @summary Update smart playlist rules
 */
export const usePlaylistSmartSync = <
  TError = ErrorType<
    | PlaylistSmartSync400
    | AuthenticationExceptionResponse
    | AuthorizationExceptionResponse
    | ModelNotFoundExceptionResponse
  >,
  TContext = unknown
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof playlistSmartSync>>,
      TError,
      { playlist: string },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof playlistSmartSync>>,
  TError,
  { playlist: string },
  TContext
> => {
  const mutationOptions = getPlaylistSmartSyncMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
