/**
 * Generated by orval v7.11.2 üç∫
 * Do not edit manually.
 * B√•nder api docs
 * B√•nder.App is a sophisticated media server developed with the primary goal to deliver high performance and seamless experience for users.
Being built on top of Laravel framework and PostgreSQL for database, it leverages the power of robust backend technologies, providing high security, reliability, and scalability.

The main focus of B√•nder.App is efficient media management and delivery.
This application is designed to handle large amounts of media files while ensuring quick and efficient access.
Implemented queuing functionality through Redis offers efficient job management and load handling.
The media information is organized and easily searchable, ensuring users can always find what they are looking for quickly and easily.
 * OpenAPI spec version: 0.0.1
 */
import {
  useInfiniteQuery,
  useMutation,
  useQuery,
  useSuspenseInfiniteQuery,
  useSuspenseQuery,
} from "@tanstack/react-query";
import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseInfiniteQueryResult,
  DefinedUseQueryResult,
  InfiniteData,
  MutationFunction,
  QueryClient,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseInfiniteQueryOptions,
  UseInfiniteQueryResult,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult,
  UseSuspenseInfiniteQueryOptions,
  UseSuspenseInfiniteQueryResult,
  UseSuspenseQueryOptions,
  UseSuspenseQueryResult,
} from "@tanstack/react-query";

import type {
  AuthenticationExceptionResponse,
  AuthorizationExceptionResponse,
  CreatePlaylistRequest,
  CreateSmartPlaylistRequest,
  ModelNotFoundExceptionResponse,
  PlaylistAddSong200,
  PlaylistCollaboratorsDestroy200,
  PlaylistCollaboratorsStore200,
  PlaylistCollaboratorsStoreBody,
  PlaylistIndex200,
  PlaylistRemoveSong200,
  PlaylistReorder200,
  PlaylistReorderBody,
  PlaylistResource,
  PlaylistShowParams,
  PlaylistSmartSync200,
  PlaylistSmartSync400,
  PlaylistSmartUpdate400,
  PlaylistStatistic,
  PlaylistStatisticsRecordFavorite200,
  PlaylistStatisticsRecordPlay200,
  PlaylistStatisticsRecordShare200,
  PlaylistStatisticsRecordView200,
  UpdatePlaylistRequest,
  UpdateSmartPlaylistRulesRequest,
  ValidationExceptionResponse,
} from "../../models";

import { customInstance } from "../../../axios-instance";
import type { ErrorType, BodyType } from "../../../axios-instance";

type SecondParameter<T extends (...args: never) => unknown> = Parameters<T>[1];

/**
 * @summary Get a collection of playlists
 */
export const playlistIndex = (
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal
) => {
  return customInstance<PlaylistIndex200>(
    { url: `/api/playlists`, method: "GET", signal },
    options
  );
};

export const getPlaylistIndexQueryKey = () => {
  return [`/api/playlists`] as const;
};

export const getPlaylistIndexInfiniteQueryOptions = <
  TData = InfiniteData<Awaited<ReturnType<typeof playlistIndex>>>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(options?: {
  query?: Partial<
    UseInfiniteQueryOptions<
      Awaited<ReturnType<typeof playlistIndex>>,
      TError,
      TData
    >
  >;
  request?: SecondParameter<typeof customInstance>;
}) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getPlaylistIndexQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof playlistIndex>>> = ({
    signal,
  }) => playlistIndex(requestOptions, signal);

  return { queryKey, queryFn, ...queryOptions } as UseInfiniteQueryOptions<
    Awaited<ReturnType<typeof playlistIndex>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type PlaylistIndexInfiniteQueryResult = NonNullable<
  Awaited<ReturnType<typeof playlistIndex>>
>;
export type PlaylistIndexInfiniteQueryError =
  ErrorType<AuthenticationExceptionResponse>;

export function usePlaylistIndexInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof playlistIndex>>>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(
  options: {
    query: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof playlistIndex>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof playlistIndex>>,
          TError,
          Awaited<ReturnType<typeof playlistIndex>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): DefinedUseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function usePlaylistIndexInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof playlistIndex>>>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof playlistIndex>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof playlistIndex>>,
          TError,
          Awaited<ReturnType<typeof playlistIndex>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function usePlaylistIndexInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof playlistIndex>>>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof playlistIndex>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get a collection of playlists
 */

export function usePlaylistIndexInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof playlistIndex>>>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof playlistIndex>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getPlaylistIndexInfiniteQueryOptions(options);

  const query = useInfiniteQuery(
    queryOptions,
    queryClient
  ) as UseInfiniteQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getPlaylistIndexQueryOptions = <
  TData = Awaited<ReturnType<typeof playlistIndex>>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof playlistIndex>>, TError, TData>
  >;
  request?: SecondParameter<typeof customInstance>;
}) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getPlaylistIndexQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof playlistIndex>>> = ({
    signal,
  }) => playlistIndex(requestOptions, signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof playlistIndex>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type PlaylistIndexQueryResult = NonNullable<
  Awaited<ReturnType<typeof playlistIndex>>
>;
export type PlaylistIndexQueryError =
  ErrorType<AuthenticationExceptionResponse>;

export function usePlaylistIndex<
  TData = Awaited<ReturnType<typeof playlistIndex>>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof playlistIndex>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof playlistIndex>>,
          TError,
          Awaited<ReturnType<typeof playlistIndex>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function usePlaylistIndex<
  TData = Awaited<ReturnType<typeof playlistIndex>>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof playlistIndex>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof playlistIndex>>,
          TError,
          Awaited<ReturnType<typeof playlistIndex>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function usePlaylistIndex<
  TData = Awaited<ReturnType<typeof playlistIndex>>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof playlistIndex>>, TError, TData>
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get a collection of playlists
 */

export function usePlaylistIndex<
  TData = Awaited<ReturnType<typeof playlistIndex>>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof playlistIndex>>, TError, TData>
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getPlaylistIndexQueryOptions(options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getPlaylistIndexSuspenseQueryOptions = <
  TData = Awaited<ReturnType<typeof playlistIndex>>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(options?: {
  query?: Partial<
    UseSuspenseQueryOptions<
      Awaited<ReturnType<typeof playlistIndex>>,
      TError,
      TData
    >
  >;
  request?: SecondParameter<typeof customInstance>;
}) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getPlaylistIndexQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof playlistIndex>>> = ({
    signal,
  }) => playlistIndex(requestOptions, signal);

  return { queryKey, queryFn, ...queryOptions } as UseSuspenseQueryOptions<
    Awaited<ReturnType<typeof playlistIndex>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type PlaylistIndexSuspenseQueryResult = NonNullable<
  Awaited<ReturnType<typeof playlistIndex>>
>;
export type PlaylistIndexSuspenseQueryError =
  ErrorType<AuthenticationExceptionResponse>;

export function usePlaylistIndexSuspense<
  TData = Awaited<ReturnType<typeof playlistIndex>>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(
  options: {
    query: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof playlistIndex>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function usePlaylistIndexSuspense<
  TData = Awaited<ReturnType<typeof playlistIndex>>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof playlistIndex>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function usePlaylistIndexSuspense<
  TData = Awaited<ReturnType<typeof playlistIndex>>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof playlistIndex>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get a collection of playlists
 */

export function usePlaylistIndexSuspense<
  TData = Awaited<ReturnType<typeof playlistIndex>>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof playlistIndex>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getPlaylistIndexSuspenseQueryOptions(options);

  const query = useSuspenseQuery(
    queryOptions,
    queryClient
  ) as UseSuspenseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getPlaylistIndexSuspenseInfiniteQueryOptions = <
  TData = InfiniteData<Awaited<ReturnType<typeof playlistIndex>>>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(options?: {
  query?: Partial<
    UseSuspenseInfiniteQueryOptions<
      Awaited<ReturnType<typeof playlistIndex>>,
      TError,
      TData
    >
  >;
  request?: SecondParameter<typeof customInstance>;
}) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getPlaylistIndexQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof playlistIndex>>> = ({
    signal,
  }) => playlistIndex(requestOptions, signal);

  return {
    queryKey,
    queryFn,
    ...queryOptions,
  } as UseSuspenseInfiniteQueryOptions<
    Awaited<ReturnType<typeof playlistIndex>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type PlaylistIndexSuspenseInfiniteQueryResult = NonNullable<
  Awaited<ReturnType<typeof playlistIndex>>
>;
export type PlaylistIndexSuspenseInfiniteQueryError =
  ErrorType<AuthenticationExceptionResponse>;

export function usePlaylistIndexSuspenseInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof playlistIndex>>>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(
  options: {
    query: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof playlistIndex>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function usePlaylistIndexSuspenseInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof playlistIndex>>>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof playlistIndex>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function usePlaylistIndexSuspenseInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof playlistIndex>>>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof playlistIndex>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get a collection of playlists
 */

export function usePlaylistIndexSuspenseInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof playlistIndex>>>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof playlistIndex>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getPlaylistIndexSuspenseInfiniteQueryOptions(options);

  const query = useSuspenseInfiniteQuery(
    queryOptions,
    queryClient
  ) as UseSuspenseInfiniteQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Create a playlist
 */
export const playlistStore = (
  createPlaylistRequest: BodyType<CreatePlaylistRequest>,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal
) => {
  return customInstance<PlaylistResource>(
    {
      url: `/api/playlists`,
      method: "POST",
      headers: { "Content-Type": "application/json" },
      data: createPlaylistRequest,
      signal,
    },
    options
  );
};

export const getPlaylistStoreMutationOptions = <
  TError = ErrorType<
    AuthenticationExceptionResponse | ValidationExceptionResponse
  >,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof playlistStore>>,
    TError,
    { data: BodyType<CreatePlaylistRequest> },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof playlistStore>>,
  TError,
  { data: BodyType<CreatePlaylistRequest> },
  TContext
> => {
  const mutationKey = ["playlistStore"];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof playlistStore>>,
    { data: BodyType<CreatePlaylistRequest> }
  > = (props) => {
    const { data } = props ?? {};

    return playlistStore(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type PlaylistStoreMutationResult = NonNullable<
  Awaited<ReturnType<typeof playlistStore>>
>;
export type PlaylistStoreMutationBody = BodyType<CreatePlaylistRequest>;
export type PlaylistStoreMutationError = ErrorType<
  AuthenticationExceptionResponse | ValidationExceptionResponse
>;

/**
 * @summary Create a playlist
 */
export const usePlaylistStore = <
  TError = ErrorType<
    AuthenticationExceptionResponse | ValidationExceptionResponse
  >,
  TContext = unknown
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof playlistStore>>,
      TError,
      { data: BodyType<CreatePlaylistRequest> },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof playlistStore>>,
  TError,
  { data: BodyType<CreatePlaylistRequest> },
  TContext
> => {
  const mutationOptions = getPlaylistStoreMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
/**
 * @summary Show a playlist
 */
export const playlistShow = (
  playlist: string,
  params?: PlaylistShowParams,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal
) => {
  return customInstance<PlaylistResource>(
    { url: `/api/playlists/${playlist}`, method: "GET", params, signal },
    options
  );
};

export const getPlaylistShowQueryKey = (
  playlist?: string,
  params?: PlaylistShowParams
) => {
  return [`/api/playlists/${playlist}`, ...(params ? [params] : [])] as const;
};

export const getPlaylistShowInfiniteQueryOptions = <
  TData = InfiniteData<
    Awaited<ReturnType<typeof playlistShow>>,
    PlaylistShowParams["limit"]
  >,
  TError = ErrorType<
    | AuthenticationExceptionResponse
    | AuthorizationExceptionResponse
    | ModelNotFoundExceptionResponse
    | ValidationExceptionResponse
  >
>(
  playlist: string,
  params?: PlaylistShowParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof playlistShow>>,
        TError,
        TData,
        QueryKey,
        PlaylistShowParams["limit"]
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getPlaylistShowQueryKey(playlist, params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof playlistShow>>,
    QueryKey,
    PlaylistShowParams["limit"]
  > = ({ signal, pageParam }) =>
    playlistShow(
      playlist,
      { ...params, limit: pageParam || params?.["limit"] },
      requestOptions,
      signal
    );

  return {
    queryKey,
    queryFn,
    enabled: !!playlist,
    ...queryOptions,
  } as UseInfiniteQueryOptions<
    Awaited<ReturnType<typeof playlistShow>>,
    TError,
    TData,
    QueryKey,
    PlaylistShowParams["limit"]
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type PlaylistShowInfiniteQueryResult = NonNullable<
  Awaited<ReturnType<typeof playlistShow>>
>;
export type PlaylistShowInfiniteQueryError = ErrorType<
  | AuthenticationExceptionResponse
  | AuthorizationExceptionResponse
  | ModelNotFoundExceptionResponse
  | ValidationExceptionResponse
>;

export function usePlaylistShowInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof playlistShow>>,
    PlaylistShowParams["limit"]
  >,
  TError = ErrorType<
    | AuthenticationExceptionResponse
    | AuthorizationExceptionResponse
    | ModelNotFoundExceptionResponse
    | ValidationExceptionResponse
  >
>(
  playlist: string,
  params: undefined | PlaylistShowParams,
  options: {
    query: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof playlistShow>>,
        TError,
        TData,
        QueryKey,
        PlaylistShowParams["limit"]
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof playlistShow>>,
          TError,
          Awaited<ReturnType<typeof playlistShow>>,
          QueryKey
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): DefinedUseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function usePlaylistShowInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof playlistShow>>,
    PlaylistShowParams["limit"]
  >,
  TError = ErrorType<
    | AuthenticationExceptionResponse
    | AuthorizationExceptionResponse
    | ModelNotFoundExceptionResponse
    | ValidationExceptionResponse
  >
>(
  playlist: string,
  params?: PlaylistShowParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof playlistShow>>,
        TError,
        TData,
        QueryKey,
        PlaylistShowParams["limit"]
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof playlistShow>>,
          TError,
          Awaited<ReturnType<typeof playlistShow>>,
          QueryKey
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function usePlaylistShowInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof playlistShow>>,
    PlaylistShowParams["limit"]
  >,
  TError = ErrorType<
    | AuthenticationExceptionResponse
    | AuthorizationExceptionResponse
    | ModelNotFoundExceptionResponse
    | ValidationExceptionResponse
  >
>(
  playlist: string,
  params?: PlaylistShowParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof playlistShow>>,
        TError,
        TData,
        QueryKey,
        PlaylistShowParams["limit"]
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Show a playlist
 */

export function usePlaylistShowInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof playlistShow>>,
    PlaylistShowParams["limit"]
  >,
  TError = ErrorType<
    | AuthenticationExceptionResponse
    | AuthorizationExceptionResponse
    | ModelNotFoundExceptionResponse
    | ValidationExceptionResponse
  >
>(
  playlist: string,
  params?: PlaylistShowParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof playlistShow>>,
        TError,
        TData,
        QueryKey,
        PlaylistShowParams["limit"]
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getPlaylistShowInfiniteQueryOptions(
    playlist,
    params,
    options
  );

  const query = useInfiniteQuery(
    queryOptions,
    queryClient
  ) as UseInfiniteQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getPlaylistShowQueryOptions = <
  TData = Awaited<ReturnType<typeof playlistShow>>,
  TError = ErrorType<
    | AuthenticationExceptionResponse
    | AuthorizationExceptionResponse
    | ModelNotFoundExceptionResponse
    | ValidationExceptionResponse
  >
>(
  playlist: string,
  params?: PlaylistShowParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof playlistShow>>, TError, TData>
    >;
    request?: SecondParameter<typeof customInstance>;
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getPlaylistShowQueryKey(playlist, params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof playlistShow>>> = ({
    signal,
  }) => playlistShow(playlist, params, requestOptions, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!playlist,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof playlistShow>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type PlaylistShowQueryResult = NonNullable<
  Awaited<ReturnType<typeof playlistShow>>
>;
export type PlaylistShowQueryError = ErrorType<
  | AuthenticationExceptionResponse
  | AuthorizationExceptionResponse
  | ModelNotFoundExceptionResponse
  | ValidationExceptionResponse
>;

export function usePlaylistShow<
  TData = Awaited<ReturnType<typeof playlistShow>>,
  TError = ErrorType<
    | AuthenticationExceptionResponse
    | AuthorizationExceptionResponse
    | ModelNotFoundExceptionResponse
    | ValidationExceptionResponse
  >
>(
  playlist: string,
  params: undefined | PlaylistShowParams,
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof playlistShow>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof playlistShow>>,
          TError,
          Awaited<ReturnType<typeof playlistShow>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function usePlaylistShow<
  TData = Awaited<ReturnType<typeof playlistShow>>,
  TError = ErrorType<
    | AuthenticationExceptionResponse
    | AuthorizationExceptionResponse
    | ModelNotFoundExceptionResponse
    | ValidationExceptionResponse
  >
>(
  playlist: string,
  params?: PlaylistShowParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof playlistShow>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof playlistShow>>,
          TError,
          Awaited<ReturnType<typeof playlistShow>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function usePlaylistShow<
  TData = Awaited<ReturnType<typeof playlistShow>>,
  TError = ErrorType<
    | AuthenticationExceptionResponse
    | AuthorizationExceptionResponse
    | ModelNotFoundExceptionResponse
    | ValidationExceptionResponse
  >
>(
  playlist: string,
  params?: PlaylistShowParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof playlistShow>>, TError, TData>
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Show a playlist
 */

export function usePlaylistShow<
  TData = Awaited<ReturnType<typeof playlistShow>>,
  TError = ErrorType<
    | AuthenticationExceptionResponse
    | AuthorizationExceptionResponse
    | ModelNotFoundExceptionResponse
    | ValidationExceptionResponse
  >
>(
  playlist: string,
  params?: PlaylistShowParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof playlistShow>>, TError, TData>
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getPlaylistShowQueryOptions(playlist, params, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getPlaylistShowSuspenseQueryOptions = <
  TData = Awaited<ReturnType<typeof playlistShow>>,
  TError = ErrorType<
    | AuthenticationExceptionResponse
    | AuthorizationExceptionResponse
    | ModelNotFoundExceptionResponse
    | ValidationExceptionResponse
  >
>(
  playlist: string,
  params?: PlaylistShowParams,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof playlistShow>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getPlaylistShowQueryKey(playlist, params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof playlistShow>>> = ({
    signal,
  }) => playlistShow(playlist, params, requestOptions, signal);

  return { queryKey, queryFn, ...queryOptions } as UseSuspenseQueryOptions<
    Awaited<ReturnType<typeof playlistShow>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type PlaylistShowSuspenseQueryResult = NonNullable<
  Awaited<ReturnType<typeof playlistShow>>
>;
export type PlaylistShowSuspenseQueryError = ErrorType<
  | AuthenticationExceptionResponse
  | AuthorizationExceptionResponse
  | ModelNotFoundExceptionResponse
  | ValidationExceptionResponse
>;

export function usePlaylistShowSuspense<
  TData = Awaited<ReturnType<typeof playlistShow>>,
  TError = ErrorType<
    | AuthenticationExceptionResponse
    | AuthorizationExceptionResponse
    | ModelNotFoundExceptionResponse
    | ValidationExceptionResponse
  >
>(
  playlist: string,
  params: undefined | PlaylistShowParams,
  options: {
    query: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof playlistShow>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function usePlaylistShowSuspense<
  TData = Awaited<ReturnType<typeof playlistShow>>,
  TError = ErrorType<
    | AuthenticationExceptionResponse
    | AuthorizationExceptionResponse
    | ModelNotFoundExceptionResponse
    | ValidationExceptionResponse
  >
>(
  playlist: string,
  params?: PlaylistShowParams,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof playlistShow>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function usePlaylistShowSuspense<
  TData = Awaited<ReturnType<typeof playlistShow>>,
  TError = ErrorType<
    | AuthenticationExceptionResponse
    | AuthorizationExceptionResponse
    | ModelNotFoundExceptionResponse
    | ValidationExceptionResponse
  >
>(
  playlist: string,
  params?: PlaylistShowParams,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof playlistShow>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Show a playlist
 */

export function usePlaylistShowSuspense<
  TData = Awaited<ReturnType<typeof playlistShow>>,
  TError = ErrorType<
    | AuthenticationExceptionResponse
    | AuthorizationExceptionResponse
    | ModelNotFoundExceptionResponse
    | ValidationExceptionResponse
  >
>(
  playlist: string,
  params?: PlaylistShowParams,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof playlistShow>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getPlaylistShowSuspenseQueryOptions(
    playlist,
    params,
    options
  );

  const query = useSuspenseQuery(
    queryOptions,
    queryClient
  ) as UseSuspenseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getPlaylistShowSuspenseInfiniteQueryOptions = <
  TData = InfiniteData<
    Awaited<ReturnType<typeof playlistShow>>,
    PlaylistShowParams["limit"]
  >,
  TError = ErrorType<
    | AuthenticationExceptionResponse
    | AuthorizationExceptionResponse
    | ModelNotFoundExceptionResponse
    | ValidationExceptionResponse
  >
>(
  playlist: string,
  params?: PlaylistShowParams,
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof playlistShow>>,
        TError,
        TData,
        QueryKey,
        PlaylistShowParams["limit"]
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getPlaylistShowQueryKey(playlist, params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof playlistShow>>,
    QueryKey,
    PlaylistShowParams["limit"]
  > = ({ signal, pageParam }) =>
    playlistShow(
      playlist,
      { ...params, limit: pageParam || params?.["limit"] },
      requestOptions,
      signal
    );

  return {
    queryKey,
    queryFn,
    ...queryOptions,
  } as UseSuspenseInfiniteQueryOptions<
    Awaited<ReturnType<typeof playlistShow>>,
    TError,
    TData,
    QueryKey,
    PlaylistShowParams["limit"]
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type PlaylistShowSuspenseInfiniteQueryResult = NonNullable<
  Awaited<ReturnType<typeof playlistShow>>
>;
export type PlaylistShowSuspenseInfiniteQueryError = ErrorType<
  | AuthenticationExceptionResponse
  | AuthorizationExceptionResponse
  | ModelNotFoundExceptionResponse
  | ValidationExceptionResponse
>;

export function usePlaylistShowSuspenseInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof playlistShow>>,
    PlaylistShowParams["limit"]
  >,
  TError = ErrorType<
    | AuthenticationExceptionResponse
    | AuthorizationExceptionResponse
    | ModelNotFoundExceptionResponse
    | ValidationExceptionResponse
  >
>(
  playlist: string,
  params: undefined | PlaylistShowParams,
  options: {
    query: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof playlistShow>>,
        TError,
        TData,
        QueryKey,
        PlaylistShowParams["limit"]
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function usePlaylistShowSuspenseInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof playlistShow>>,
    PlaylistShowParams["limit"]
  >,
  TError = ErrorType<
    | AuthenticationExceptionResponse
    | AuthorizationExceptionResponse
    | ModelNotFoundExceptionResponse
    | ValidationExceptionResponse
  >
>(
  playlist: string,
  params?: PlaylistShowParams,
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof playlistShow>>,
        TError,
        TData,
        QueryKey,
        PlaylistShowParams["limit"]
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function usePlaylistShowSuspenseInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof playlistShow>>,
    PlaylistShowParams["limit"]
  >,
  TError = ErrorType<
    | AuthenticationExceptionResponse
    | AuthorizationExceptionResponse
    | ModelNotFoundExceptionResponse
    | ValidationExceptionResponse
  >
>(
  playlist: string,
  params?: PlaylistShowParams,
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof playlistShow>>,
        TError,
        TData,
        QueryKey,
        PlaylistShowParams["limit"]
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Show a playlist
 */

export function usePlaylistShowSuspenseInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof playlistShow>>,
    PlaylistShowParams["limit"]
  >,
  TError = ErrorType<
    | AuthenticationExceptionResponse
    | AuthorizationExceptionResponse
    | ModelNotFoundExceptionResponse
    | ValidationExceptionResponse
  >
>(
  playlist: string,
  params?: PlaylistShowParams,
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof playlistShow>>,
        TError,
        TData,
        QueryKey,
        PlaylistShowParams["limit"]
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getPlaylistShowSuspenseInfiniteQueryOptions(
    playlist,
    params,
    options
  );

  const query = useSuspenseInfiniteQuery(
    queryOptions,
    queryClient
  ) as UseSuspenseInfiniteQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Update a playlist
 */
export const playlistUpdate = (
  playlist: string,
  updatePlaylistRequest: BodyType<UpdatePlaylistRequest>,
  options?: SecondParameter<typeof customInstance>
) => {
  return customInstance<PlaylistResource>(
    {
      url: `/api/playlists/${playlist}`,
      method: "PUT",
      headers: { "Content-Type": "application/json" },
      data: updatePlaylistRequest,
    },
    options
  );
};

export const getPlaylistUpdateMutationOptions = <
  TError = ErrorType<
    | AuthenticationExceptionResponse
    | AuthorizationExceptionResponse
    | ModelNotFoundExceptionResponse
    | ValidationExceptionResponse
  >,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof playlistUpdate>>,
    TError,
    { playlist: string; data: BodyType<UpdatePlaylistRequest> },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof playlistUpdate>>,
  TError,
  { playlist: string; data: BodyType<UpdatePlaylistRequest> },
  TContext
> => {
  const mutationKey = ["playlistUpdate"];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof playlistUpdate>>,
    { playlist: string; data: BodyType<UpdatePlaylistRequest> }
  > = (props) => {
    const { playlist, data } = props ?? {};

    return playlistUpdate(playlist, data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type PlaylistUpdateMutationResult = NonNullable<
  Awaited<ReturnType<typeof playlistUpdate>>
>;
export type PlaylistUpdateMutationBody = BodyType<UpdatePlaylistRequest>;
export type PlaylistUpdateMutationError = ErrorType<
  | AuthenticationExceptionResponse
  | AuthorizationExceptionResponse
  | ModelNotFoundExceptionResponse
  | ValidationExceptionResponse
>;

/**
 * @summary Update a playlist
 */
export const usePlaylistUpdate = <
  TError = ErrorType<
    | AuthenticationExceptionResponse
    | AuthorizationExceptionResponse
    | ModelNotFoundExceptionResponse
    | ValidationExceptionResponse
  >,
  TContext = unknown
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof playlistUpdate>>,
      TError,
      { playlist: string; data: BodyType<UpdatePlaylistRequest> },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof playlistUpdate>>,
  TError,
  { playlist: string; data: BodyType<UpdatePlaylistRequest> },
  TContext
> => {
  const mutationOptions = getPlaylistUpdateMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
/**
 * @summary Delete a playlist
 */
export const playlistDestroy = (
  playlist: string,
  options?: SecondParameter<typeof customInstance>
) => {
  return customInstance<null>(
    { url: `/api/playlists/${playlist}`, method: "DELETE" },
    options
  );
};

export const getPlaylistDestroyMutationOptions = <
  TError = ErrorType<
    | AuthenticationExceptionResponse
    | AuthorizationExceptionResponse
    | ModelNotFoundExceptionResponse
  >,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof playlistDestroy>>,
    TError,
    { playlist: string },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof playlistDestroy>>,
  TError,
  { playlist: string },
  TContext
> => {
  const mutationKey = ["playlistDestroy"];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof playlistDestroy>>,
    { playlist: string }
  > = (props) => {
    const { playlist } = props ?? {};

    return playlistDestroy(playlist, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type PlaylistDestroyMutationResult = NonNullable<
  Awaited<ReturnType<typeof playlistDestroy>>
>;

export type PlaylistDestroyMutationError = ErrorType<
  | AuthenticationExceptionResponse
  | AuthorizationExceptionResponse
  | ModelNotFoundExceptionResponse
>;

/**
 * @summary Delete a playlist
 */
export const usePlaylistDestroy = <
  TError = ErrorType<
    | AuthenticationExceptionResponse
    | AuthorizationExceptionResponse
    | ModelNotFoundExceptionResponse
  >,
  TContext = unknown
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof playlistDestroy>>,
      TError,
      { playlist: string },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof playlistDestroy>>,
  TError,
  { playlist: string },
  TContext
> => {
  const mutationOptions = getPlaylistDestroyMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
/**
 * @summary Add a song
 */
export const playlistAddSong = (
  playlist: string,
  song: string,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal
) => {
  return customInstance<PlaylistAddSong200>(
    { url: `/api/playlists/${playlist}/songs/${song}`, method: "POST", signal },
    options
  );
};

export const getPlaylistAddSongMutationOptions = <
  TError = ErrorType<
    | AuthenticationExceptionResponse
    | AuthorizationExceptionResponse
    | ModelNotFoundExceptionResponse
  >,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof playlistAddSong>>,
    TError,
    { playlist: string; song: string },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof playlistAddSong>>,
  TError,
  { playlist: string; song: string },
  TContext
> => {
  const mutationKey = ["playlistAddSong"];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof playlistAddSong>>,
    { playlist: string; song: string }
  > = (props) => {
    const { playlist, song } = props ?? {};

    return playlistAddSong(playlist, song, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type PlaylistAddSongMutationResult = NonNullable<
  Awaited<ReturnType<typeof playlistAddSong>>
>;

export type PlaylistAddSongMutationError = ErrorType<
  | AuthenticationExceptionResponse
  | AuthorizationExceptionResponse
  | ModelNotFoundExceptionResponse
>;

/**
 * @summary Add a song
 */
export const usePlaylistAddSong = <
  TError = ErrorType<
    | AuthenticationExceptionResponse
    | AuthorizationExceptionResponse
    | ModelNotFoundExceptionResponse
  >,
  TContext = unknown
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof playlistAddSong>>,
      TError,
      { playlist: string; song: string },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof playlistAddSong>>,
  TError,
  { playlist: string; song: string },
  TContext
> => {
  const mutationOptions = getPlaylistAddSongMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
/**
 * @summary Remove a song
 */
export const playlistRemoveSong = (
  playlist: string,
  song: string,
  options?: SecondParameter<typeof customInstance>
) => {
  return customInstance<PlaylistRemoveSong200>(
    { url: `/api/playlists/${playlist}/songs/${song}`, method: "DELETE" },
    options
  );
};

export const getPlaylistRemoveSongMutationOptions = <
  TError = ErrorType<
    | AuthenticationExceptionResponse
    | AuthorizationExceptionResponse
    | ModelNotFoundExceptionResponse
  >,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof playlistRemoveSong>>,
    TError,
    { playlist: string; song: string },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof playlistRemoveSong>>,
  TError,
  { playlist: string; song: string },
  TContext
> => {
  const mutationKey = ["playlistRemoveSong"];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof playlistRemoveSong>>,
    { playlist: string; song: string }
  > = (props) => {
    const { playlist, song } = props ?? {};

    return playlistRemoveSong(playlist, song, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type PlaylistRemoveSongMutationResult = NonNullable<
  Awaited<ReturnType<typeof playlistRemoveSong>>
>;

export type PlaylistRemoveSongMutationError = ErrorType<
  | AuthenticationExceptionResponse
  | AuthorizationExceptionResponse
  | ModelNotFoundExceptionResponse
>;

/**
 * @summary Remove a song
 */
export const usePlaylistRemoveSong = <
  TError = ErrorType<
    | AuthenticationExceptionResponse
    | AuthorizationExceptionResponse
    | ModelNotFoundExceptionResponse
  >,
  TContext = unknown
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof playlistRemoveSong>>,
      TError,
      { playlist: string; song: string },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof playlistRemoveSong>>,
  TError,
  { playlist: string; song: string },
  TContext
> => {
  const mutationOptions = getPlaylistRemoveSongMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
/**
 * @summary Reorder songs
 */
export const playlistReorder = (
  playlist: string,
  playlistReorderBody: BodyType<PlaylistReorderBody>,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal
) => {
  return customInstance<PlaylistReorder200>(
    {
      url: `/api/playlists/${playlist}/reorder`,
      method: "POST",
      headers: { "Content-Type": "application/json" },
      data: playlistReorderBody,
      signal,
    },
    options
  );
};

export const getPlaylistReorderMutationOptions = <
  TError = ErrorType<
    | AuthenticationExceptionResponse
    | AuthorizationExceptionResponse
    | ModelNotFoundExceptionResponse
    | ValidationExceptionResponse
  >,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof playlistReorder>>,
    TError,
    { playlist: string; data: BodyType<PlaylistReorderBody> },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof playlistReorder>>,
  TError,
  { playlist: string; data: BodyType<PlaylistReorderBody> },
  TContext
> => {
  const mutationKey = ["playlistReorder"];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof playlistReorder>>,
    { playlist: string; data: BodyType<PlaylistReorderBody> }
  > = (props) => {
    const { playlist, data } = props ?? {};

    return playlistReorder(playlist, data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type PlaylistReorderMutationResult = NonNullable<
  Awaited<ReturnType<typeof playlistReorder>>
>;
export type PlaylistReorderMutationBody = BodyType<PlaylistReorderBody>;
export type PlaylistReorderMutationError = ErrorType<
  | AuthenticationExceptionResponse
  | AuthorizationExceptionResponse
  | ModelNotFoundExceptionResponse
  | ValidationExceptionResponse
>;

/**
 * @summary Reorder songs
 */
export const usePlaylistReorder = <
  TError = ErrorType<
    | AuthenticationExceptionResponse
    | AuthorizationExceptionResponse
    | ModelNotFoundExceptionResponse
    | ValidationExceptionResponse
  >,
  TContext = unknown
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof playlistReorder>>,
      TError,
      { playlist: string; data: BodyType<PlaylistReorderBody> },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof playlistReorder>>,
  TError,
  { playlist: string; data: BodyType<PlaylistReorderBody> },
  TContext
> => {
  const mutationOptions = getPlaylistReorderMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
/**
 * @summary Add collaborator
 */
export const playlistCollaboratorsStore = (
  playlist: string,
  playlistCollaboratorsStoreBody: BodyType<PlaylistCollaboratorsStoreBody>,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal
) => {
  return customInstance<PlaylistCollaboratorsStore200>(
    {
      url: `/api/playlists/${playlist}/collaborators`,
      method: "POST",
      headers: { "Content-Type": "application/json" },
      data: playlistCollaboratorsStoreBody,
      signal,
    },
    options
  );
};

export const getPlaylistCollaboratorsStoreMutationOptions = <
  TError = ErrorType<
    | AuthenticationExceptionResponse
    | AuthorizationExceptionResponse
    | ModelNotFoundExceptionResponse
    | ValidationExceptionResponse
  >,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof playlistCollaboratorsStore>>,
    TError,
    { playlist: string; data: BodyType<PlaylistCollaboratorsStoreBody> },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof playlistCollaboratorsStore>>,
  TError,
  { playlist: string; data: BodyType<PlaylistCollaboratorsStoreBody> },
  TContext
> => {
  const mutationKey = ["playlistCollaboratorsStore"];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof playlistCollaboratorsStore>>,
    { playlist: string; data: BodyType<PlaylistCollaboratorsStoreBody> }
  > = (props) => {
    const { playlist, data } = props ?? {};

    return playlistCollaboratorsStore(playlist, data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type PlaylistCollaboratorsStoreMutationResult = NonNullable<
  Awaited<ReturnType<typeof playlistCollaboratorsStore>>
>;
export type PlaylistCollaboratorsStoreMutationBody =
  BodyType<PlaylistCollaboratorsStoreBody>;
export type PlaylistCollaboratorsStoreMutationError = ErrorType<
  | AuthenticationExceptionResponse
  | AuthorizationExceptionResponse
  | ModelNotFoundExceptionResponse
  | ValidationExceptionResponse
>;

/**
 * @summary Add collaborator
 */
export const usePlaylistCollaboratorsStore = <
  TError = ErrorType<
    | AuthenticationExceptionResponse
    | AuthorizationExceptionResponse
    | ModelNotFoundExceptionResponse
    | ValidationExceptionResponse
  >,
  TContext = unknown
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof playlistCollaboratorsStore>>,
      TError,
      { playlist: string; data: BodyType<PlaylistCollaboratorsStoreBody> },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof playlistCollaboratorsStore>>,
  TError,
  { playlist: string; data: BodyType<PlaylistCollaboratorsStoreBody> },
  TContext
> => {
  const mutationOptions = getPlaylistCollaboratorsStoreMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
/**
 * @summary Remove collaborator
 */
export const playlistCollaboratorsDestroy = (
  playlist: string,
  user: number,
  options?: SecondParameter<typeof customInstance>
) => {
  return customInstance<PlaylistCollaboratorsDestroy200>(
    {
      url: `/api/playlists/${playlist}/collaborators/${user}`,
      method: "DELETE",
    },
    options
  );
};

export const getPlaylistCollaboratorsDestroyMutationOptions = <
  TError = ErrorType<
    | AuthenticationExceptionResponse
    | AuthorizationExceptionResponse
    | ModelNotFoundExceptionResponse
  >,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof playlistCollaboratorsDestroy>>,
    TError,
    { playlist: string; user: number },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof playlistCollaboratorsDestroy>>,
  TError,
  { playlist: string; user: number },
  TContext
> => {
  const mutationKey = ["playlistCollaboratorsDestroy"];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof playlistCollaboratorsDestroy>>,
    { playlist: string; user: number }
  > = (props) => {
    const { playlist, user } = props ?? {};

    return playlistCollaboratorsDestroy(playlist, user, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type PlaylistCollaboratorsDestroyMutationResult = NonNullable<
  Awaited<ReturnType<typeof playlistCollaboratorsDestroy>>
>;

export type PlaylistCollaboratorsDestroyMutationError = ErrorType<
  | AuthenticationExceptionResponse
  | AuthorizationExceptionResponse
  | ModelNotFoundExceptionResponse
>;

/**
 * @summary Remove collaborator
 */
export const usePlaylistCollaboratorsDestroy = <
  TError = ErrorType<
    | AuthenticationExceptionResponse
    | AuthorizationExceptionResponse
    | ModelNotFoundExceptionResponse
  >,
  TContext = unknown
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof playlistCollaboratorsDestroy>>,
      TError,
      { playlist: string; user: number },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof playlistCollaboratorsDestroy>>,
  TError,
  { playlist: string; user: number },
  TContext
> => {
  const mutationOptions =
    getPlaylistCollaboratorsDestroyMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
/**
 * @summary Clone playlist
 */
export const playlistClone = (
  playlist: string,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal
) => {
  return customInstance<PlaylistResource>(
    { url: `/api/playlists/${playlist}/clone`, method: "POST", signal },
    options
  );
};

export const getPlaylistCloneMutationOptions = <
  TError = ErrorType<
    | AuthenticationExceptionResponse
    | AuthorizationExceptionResponse
    | ModelNotFoundExceptionResponse
  >,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof playlistClone>>,
    TError,
    { playlist: string },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof playlistClone>>,
  TError,
  { playlist: string },
  TContext
> => {
  const mutationKey = ["playlistClone"];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof playlistClone>>,
    { playlist: string }
  > = (props) => {
    const { playlist } = props ?? {};

    return playlistClone(playlist, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type PlaylistCloneMutationResult = NonNullable<
  Awaited<ReturnType<typeof playlistClone>>
>;

export type PlaylistCloneMutationError = ErrorType<
  | AuthenticationExceptionResponse
  | AuthorizationExceptionResponse
  | ModelNotFoundExceptionResponse
>;

/**
 * @summary Clone playlist
 */
export const usePlaylistClone = <
  TError = ErrorType<
    | AuthenticationExceptionResponse
    | AuthorizationExceptionResponse
    | ModelNotFoundExceptionResponse
  >,
  TContext = unknown
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof playlistClone>>,
      TError,
      { playlist: string },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof playlistClone>>,
  TError,
  { playlist: string },
  TContext
> => {
  const mutationOptions = getPlaylistCloneMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
/**
 * @summary Get statistics
 */
export const playlistStatistics = (
  playlist: string,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal
) => {
  return customInstance<PlaylistStatistic>(
    { url: `/api/playlists/${playlist}/statistics`, method: "GET", signal },
    options
  );
};

export const getPlaylistStatisticsQueryKey = (playlist?: string) => {
  return [`/api/playlists/${playlist}/statistics`] as const;
};

export const getPlaylistStatisticsInfiniteQueryOptions = <
  TData = InfiniteData<Awaited<ReturnType<typeof playlistStatistics>>>,
  TError = ErrorType<
    | AuthenticationExceptionResponse
    | AuthorizationExceptionResponse
    | ModelNotFoundExceptionResponse
  >
>(
  playlist: string,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof playlistStatistics>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getPlaylistStatisticsQueryKey(playlist);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof playlistStatistics>>
  > = ({ signal }) => playlistStatistics(playlist, requestOptions, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!playlist,
    ...queryOptions,
  } as UseInfiniteQueryOptions<
    Awaited<ReturnType<typeof playlistStatistics>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type PlaylistStatisticsInfiniteQueryResult = NonNullable<
  Awaited<ReturnType<typeof playlistStatistics>>
>;
export type PlaylistStatisticsInfiniteQueryError = ErrorType<
  | AuthenticationExceptionResponse
  | AuthorizationExceptionResponse
  | ModelNotFoundExceptionResponse
>;

export function usePlaylistStatisticsInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof playlistStatistics>>>,
  TError = ErrorType<
    | AuthenticationExceptionResponse
    | AuthorizationExceptionResponse
    | ModelNotFoundExceptionResponse
  >
>(
  playlist: string,
  options: {
    query: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof playlistStatistics>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof playlistStatistics>>,
          TError,
          Awaited<ReturnType<typeof playlistStatistics>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): DefinedUseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function usePlaylistStatisticsInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof playlistStatistics>>>,
  TError = ErrorType<
    | AuthenticationExceptionResponse
    | AuthorizationExceptionResponse
    | ModelNotFoundExceptionResponse
  >
>(
  playlist: string,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof playlistStatistics>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof playlistStatistics>>,
          TError,
          Awaited<ReturnType<typeof playlistStatistics>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function usePlaylistStatisticsInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof playlistStatistics>>>,
  TError = ErrorType<
    | AuthenticationExceptionResponse
    | AuthorizationExceptionResponse
    | ModelNotFoundExceptionResponse
  >
>(
  playlist: string,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof playlistStatistics>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get statistics
 */

export function usePlaylistStatisticsInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof playlistStatistics>>>,
  TError = ErrorType<
    | AuthenticationExceptionResponse
    | AuthorizationExceptionResponse
    | ModelNotFoundExceptionResponse
  >
>(
  playlist: string,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof playlistStatistics>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getPlaylistStatisticsInfiniteQueryOptions(
    playlist,
    options
  );

  const query = useInfiniteQuery(
    queryOptions,
    queryClient
  ) as UseInfiniteQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getPlaylistStatisticsQueryOptions = <
  TData = Awaited<ReturnType<typeof playlistStatistics>>,
  TError = ErrorType<
    | AuthenticationExceptionResponse
    | AuthorizationExceptionResponse
    | ModelNotFoundExceptionResponse
  >
>(
  playlist: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof playlistStatistics>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getPlaylistStatisticsQueryKey(playlist);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof playlistStatistics>>
  > = ({ signal }) => playlistStatistics(playlist, requestOptions, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!playlist,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof playlistStatistics>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type PlaylistStatisticsQueryResult = NonNullable<
  Awaited<ReturnType<typeof playlistStatistics>>
>;
export type PlaylistStatisticsQueryError = ErrorType<
  | AuthenticationExceptionResponse
  | AuthorizationExceptionResponse
  | ModelNotFoundExceptionResponse
>;

export function usePlaylistStatistics<
  TData = Awaited<ReturnType<typeof playlistStatistics>>,
  TError = ErrorType<
    | AuthenticationExceptionResponse
    | AuthorizationExceptionResponse
    | ModelNotFoundExceptionResponse
  >
>(
  playlist: string,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof playlistStatistics>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof playlistStatistics>>,
          TError,
          Awaited<ReturnType<typeof playlistStatistics>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function usePlaylistStatistics<
  TData = Awaited<ReturnType<typeof playlistStatistics>>,
  TError = ErrorType<
    | AuthenticationExceptionResponse
    | AuthorizationExceptionResponse
    | ModelNotFoundExceptionResponse
  >
>(
  playlist: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof playlistStatistics>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof playlistStatistics>>,
          TError,
          Awaited<ReturnType<typeof playlistStatistics>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function usePlaylistStatistics<
  TData = Awaited<ReturnType<typeof playlistStatistics>>,
  TError = ErrorType<
    | AuthenticationExceptionResponse
    | AuthorizationExceptionResponse
    | ModelNotFoundExceptionResponse
  >
>(
  playlist: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof playlistStatistics>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get statistics
 */

export function usePlaylistStatistics<
  TData = Awaited<ReturnType<typeof playlistStatistics>>,
  TError = ErrorType<
    | AuthenticationExceptionResponse
    | AuthorizationExceptionResponse
    | ModelNotFoundExceptionResponse
  >
>(
  playlist: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof playlistStatistics>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getPlaylistStatisticsQueryOptions(playlist, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getPlaylistStatisticsSuspenseQueryOptions = <
  TData = Awaited<ReturnType<typeof playlistStatistics>>,
  TError = ErrorType<
    | AuthenticationExceptionResponse
    | AuthorizationExceptionResponse
    | ModelNotFoundExceptionResponse
  >
>(
  playlist: string,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof playlistStatistics>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getPlaylistStatisticsQueryKey(playlist);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof playlistStatistics>>
  > = ({ signal }) => playlistStatistics(playlist, requestOptions, signal);

  return { queryKey, queryFn, ...queryOptions } as UseSuspenseQueryOptions<
    Awaited<ReturnType<typeof playlistStatistics>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type PlaylistStatisticsSuspenseQueryResult = NonNullable<
  Awaited<ReturnType<typeof playlistStatistics>>
>;
export type PlaylistStatisticsSuspenseQueryError = ErrorType<
  | AuthenticationExceptionResponse
  | AuthorizationExceptionResponse
  | ModelNotFoundExceptionResponse
>;

export function usePlaylistStatisticsSuspense<
  TData = Awaited<ReturnType<typeof playlistStatistics>>,
  TError = ErrorType<
    | AuthenticationExceptionResponse
    | AuthorizationExceptionResponse
    | ModelNotFoundExceptionResponse
  >
>(
  playlist: string,
  options: {
    query: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof playlistStatistics>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function usePlaylistStatisticsSuspense<
  TData = Awaited<ReturnType<typeof playlistStatistics>>,
  TError = ErrorType<
    | AuthenticationExceptionResponse
    | AuthorizationExceptionResponse
    | ModelNotFoundExceptionResponse
  >
>(
  playlist: string,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof playlistStatistics>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function usePlaylistStatisticsSuspense<
  TData = Awaited<ReturnType<typeof playlistStatistics>>,
  TError = ErrorType<
    | AuthenticationExceptionResponse
    | AuthorizationExceptionResponse
    | ModelNotFoundExceptionResponse
  >
>(
  playlist: string,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof playlistStatistics>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get statistics
 */

export function usePlaylistStatisticsSuspense<
  TData = Awaited<ReturnType<typeof playlistStatistics>>,
  TError = ErrorType<
    | AuthenticationExceptionResponse
    | AuthorizationExceptionResponse
    | ModelNotFoundExceptionResponse
  >
>(
  playlist: string,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof playlistStatistics>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getPlaylistStatisticsSuspenseQueryOptions(
    playlist,
    options
  );

  const query = useSuspenseQuery(
    queryOptions,
    queryClient
  ) as UseSuspenseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getPlaylistStatisticsSuspenseInfiniteQueryOptions = <
  TData = InfiniteData<Awaited<ReturnType<typeof playlistStatistics>>>,
  TError = ErrorType<
    | AuthenticationExceptionResponse
    | AuthorizationExceptionResponse
    | ModelNotFoundExceptionResponse
  >
>(
  playlist: string,
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof playlistStatistics>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getPlaylistStatisticsQueryKey(playlist);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof playlistStatistics>>
  > = ({ signal }) => playlistStatistics(playlist, requestOptions, signal);

  return {
    queryKey,
    queryFn,
    ...queryOptions,
  } as UseSuspenseInfiniteQueryOptions<
    Awaited<ReturnType<typeof playlistStatistics>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type PlaylistStatisticsSuspenseInfiniteQueryResult = NonNullable<
  Awaited<ReturnType<typeof playlistStatistics>>
>;
export type PlaylistStatisticsSuspenseInfiniteQueryError = ErrorType<
  | AuthenticationExceptionResponse
  | AuthorizationExceptionResponse
  | ModelNotFoundExceptionResponse
>;

export function usePlaylistStatisticsSuspenseInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof playlistStatistics>>>,
  TError = ErrorType<
    | AuthenticationExceptionResponse
    | AuthorizationExceptionResponse
    | ModelNotFoundExceptionResponse
  >
>(
  playlist: string,
  options: {
    query: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof playlistStatistics>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function usePlaylistStatisticsSuspenseInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof playlistStatistics>>>,
  TError = ErrorType<
    | AuthenticationExceptionResponse
    | AuthorizationExceptionResponse
    | ModelNotFoundExceptionResponse
  >
>(
  playlist: string,
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof playlistStatistics>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function usePlaylistStatisticsSuspenseInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof playlistStatistics>>>,
  TError = ErrorType<
    | AuthenticationExceptionResponse
    | AuthorizationExceptionResponse
    | ModelNotFoundExceptionResponse
  >
>(
  playlist: string,
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof playlistStatistics>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get statistics
 */

export function usePlaylistStatisticsSuspenseInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof playlistStatistics>>>,
  TError = ErrorType<
    | AuthenticationExceptionResponse
    | AuthorizationExceptionResponse
    | ModelNotFoundExceptionResponse
  >
>(
  playlist: string,
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof playlistStatistics>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getPlaylistStatisticsSuspenseInfiniteQueryOptions(
    playlist,
    options
  );

  const query = useSuspenseInfiniteQuery(
    queryOptions,
    queryClient
  ) as UseSuspenseInfiniteQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Statistics - Record view
 */
export const playlistStatisticsRecordView = (
  playlist: string,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal
) => {
  return customInstance<PlaylistStatisticsRecordView200>(
    {
      url: `/api/playlists/${playlist}/statistics/record/view`,
      method: "POST",
      signal,
    },
    options
  );
};

export const getPlaylistStatisticsRecordViewMutationOptions = <
  TError = ErrorType<
    | AuthenticationExceptionResponse
    | AuthorizationExceptionResponse
    | ModelNotFoundExceptionResponse
  >,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof playlistStatisticsRecordView>>,
    TError,
    { playlist: string },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof playlistStatisticsRecordView>>,
  TError,
  { playlist: string },
  TContext
> => {
  const mutationKey = ["playlistStatisticsRecordView"];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof playlistStatisticsRecordView>>,
    { playlist: string }
  > = (props) => {
    const { playlist } = props ?? {};

    return playlistStatisticsRecordView(playlist, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type PlaylistStatisticsRecordViewMutationResult = NonNullable<
  Awaited<ReturnType<typeof playlistStatisticsRecordView>>
>;

export type PlaylistStatisticsRecordViewMutationError = ErrorType<
  | AuthenticationExceptionResponse
  | AuthorizationExceptionResponse
  | ModelNotFoundExceptionResponse
>;

/**
 * @summary Statistics - Record view
 */
export const usePlaylistStatisticsRecordView = <
  TError = ErrorType<
    | AuthenticationExceptionResponse
    | AuthorizationExceptionResponse
    | ModelNotFoundExceptionResponse
  >,
  TContext = unknown
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof playlistStatisticsRecordView>>,
      TError,
      { playlist: string },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof playlistStatisticsRecordView>>,
  TError,
  { playlist: string },
  TContext
> => {
  const mutationOptions =
    getPlaylistStatisticsRecordViewMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
/**
 * @summary Statistics - Record play
 */
export const playlistStatisticsRecordPlay = (
  playlist: string,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal
) => {
  return customInstance<PlaylistStatisticsRecordPlay200>(
    {
      url: `/api/playlists/${playlist}/statistics/record/play`,
      method: "POST",
      signal,
    },
    options
  );
};

export const getPlaylistStatisticsRecordPlayMutationOptions = <
  TError = ErrorType<
    | AuthenticationExceptionResponse
    | AuthorizationExceptionResponse
    | ModelNotFoundExceptionResponse
  >,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof playlistStatisticsRecordPlay>>,
    TError,
    { playlist: string },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof playlistStatisticsRecordPlay>>,
  TError,
  { playlist: string },
  TContext
> => {
  const mutationKey = ["playlistStatisticsRecordPlay"];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof playlistStatisticsRecordPlay>>,
    { playlist: string }
  > = (props) => {
    const { playlist } = props ?? {};

    return playlistStatisticsRecordPlay(playlist, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type PlaylistStatisticsRecordPlayMutationResult = NonNullable<
  Awaited<ReturnType<typeof playlistStatisticsRecordPlay>>
>;

export type PlaylistStatisticsRecordPlayMutationError = ErrorType<
  | AuthenticationExceptionResponse
  | AuthorizationExceptionResponse
  | ModelNotFoundExceptionResponse
>;

/**
 * @summary Statistics - Record play
 */
export const usePlaylistStatisticsRecordPlay = <
  TError = ErrorType<
    | AuthenticationExceptionResponse
    | AuthorizationExceptionResponse
    | ModelNotFoundExceptionResponse
  >,
  TContext = unknown
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof playlistStatisticsRecordPlay>>,
      TError,
      { playlist: string },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof playlistStatisticsRecordPlay>>,
  TError,
  { playlist: string },
  TContext
> => {
  const mutationOptions =
    getPlaylistStatisticsRecordPlayMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
/**
 * @summary Share
 */
export const playlistStatisticsRecordShare = (
  playlist: string,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal
) => {
  return customInstance<PlaylistStatisticsRecordShare200>(
    {
      url: `/api/playlists/${playlist}/statistics/record/share`,
      method: "POST",
      signal,
    },
    options
  );
};

export const getPlaylistStatisticsRecordShareMutationOptions = <
  TError = ErrorType<
    | AuthenticationExceptionResponse
    | AuthorizationExceptionResponse
    | ModelNotFoundExceptionResponse
  >,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof playlistStatisticsRecordShare>>,
    TError,
    { playlist: string },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof playlistStatisticsRecordShare>>,
  TError,
  { playlist: string },
  TContext
> => {
  const mutationKey = ["playlistStatisticsRecordShare"];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof playlistStatisticsRecordShare>>,
    { playlist: string }
  > = (props) => {
    const { playlist } = props ?? {};

    return playlistStatisticsRecordShare(playlist, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type PlaylistStatisticsRecordShareMutationResult = NonNullable<
  Awaited<ReturnType<typeof playlistStatisticsRecordShare>>
>;

export type PlaylistStatisticsRecordShareMutationError = ErrorType<
  | AuthenticationExceptionResponse
  | AuthorizationExceptionResponse
  | ModelNotFoundExceptionResponse
>;

/**
 * @summary Share
 */
export const usePlaylistStatisticsRecordShare = <
  TError = ErrorType<
    | AuthenticationExceptionResponse
    | AuthorizationExceptionResponse
    | ModelNotFoundExceptionResponse
  >,
  TContext = unknown
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof playlistStatisticsRecordShare>>,
      TError,
      { playlist: string },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof playlistStatisticsRecordShare>>,
  TError,
  { playlist: string },
  TContext
> => {
  const mutationOptions =
    getPlaylistStatisticsRecordShareMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
/**
 * @summary Favorite
 */
export const playlistStatisticsRecordFavorite = (
  playlist: string,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal
) => {
  return customInstance<PlaylistStatisticsRecordFavorite200>(
    {
      url: `/api/playlists/${playlist}/statistics/record/favorite`,
      method: "POST",
      signal,
    },
    options
  );
};

export const getPlaylistStatisticsRecordFavoriteMutationOptions = <
  TError = ErrorType<
    | AuthenticationExceptionResponse
    | AuthorizationExceptionResponse
    | ModelNotFoundExceptionResponse
  >,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof playlistStatisticsRecordFavorite>>,
    TError,
    { playlist: string },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof playlistStatisticsRecordFavorite>>,
  TError,
  { playlist: string },
  TContext
> => {
  const mutationKey = ["playlistStatisticsRecordFavorite"];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof playlistStatisticsRecordFavorite>>,
    { playlist: string }
  > = (props) => {
    const { playlist } = props ?? {};

    return playlistStatisticsRecordFavorite(playlist, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type PlaylistStatisticsRecordFavoriteMutationResult = NonNullable<
  Awaited<ReturnType<typeof playlistStatisticsRecordFavorite>>
>;

export type PlaylistStatisticsRecordFavoriteMutationError = ErrorType<
  | AuthenticationExceptionResponse
  | AuthorizationExceptionResponse
  | ModelNotFoundExceptionResponse
>;

/**
 * @summary Favorite
 */
export const usePlaylistStatisticsRecordFavorite = <
  TError = ErrorType<
    | AuthenticationExceptionResponse
    | AuthorizationExceptionResponse
    | ModelNotFoundExceptionResponse
  >,
  TContext = unknown
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof playlistStatisticsRecordFavorite>>,
      TError,
      { playlist: string },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof playlistStatisticsRecordFavorite>>,
  TError,
  { playlist: string },
  TContext
> => {
  const mutationOptions =
    getPlaylistStatisticsRecordFavoriteMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
/**
 * @summary Smart playlist - Create
 */
export const playlistSmartCreate = (
  createSmartPlaylistRequest: BodyType<CreateSmartPlaylistRequest>,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal
) => {
  return customInstance<PlaylistResource>(
    {
      url: `/api/playlists/smart`,
      method: "POST",
      headers: { "Content-Type": "application/json" },
      data: createSmartPlaylistRequest,
      signal,
    },
    options
  );
};

export const getPlaylistSmartCreateMutationOptions = <
  TError = ErrorType<
    AuthenticationExceptionResponse | ValidationExceptionResponse
  >,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof playlistSmartCreate>>,
    TError,
    { data: BodyType<CreateSmartPlaylistRequest> },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof playlistSmartCreate>>,
  TError,
  { data: BodyType<CreateSmartPlaylistRequest> },
  TContext
> => {
  const mutationKey = ["playlistSmartCreate"];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof playlistSmartCreate>>,
    { data: BodyType<CreateSmartPlaylistRequest> }
  > = (props) => {
    const { data } = props ?? {};

    return playlistSmartCreate(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type PlaylistSmartCreateMutationResult = NonNullable<
  Awaited<ReturnType<typeof playlistSmartCreate>>
>;
export type PlaylistSmartCreateMutationBody =
  BodyType<CreateSmartPlaylistRequest>;
export type PlaylistSmartCreateMutationError = ErrorType<
  AuthenticationExceptionResponse | ValidationExceptionResponse
>;

/**
 * @summary Smart playlist - Create
 */
export const usePlaylistSmartCreate = <
  TError = ErrorType<
    AuthenticationExceptionResponse | ValidationExceptionResponse
  >,
  TContext = unknown
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof playlistSmartCreate>>,
      TError,
      { data: BodyType<CreateSmartPlaylistRequest> },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof playlistSmartCreate>>,
  TError,
  { data: BodyType<CreateSmartPlaylistRequest> },
  TContext
> => {
  const mutationOptions = getPlaylistSmartCreateMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
/**
 * @summary Smart playlist - Update rules
 */
export const playlistSmartUpdate = (
  playlist: string,
  updateSmartPlaylistRulesRequest: BodyType<UpdateSmartPlaylistRulesRequest>,
  options?: SecondParameter<typeof customInstance>
) => {
  return customInstance<PlaylistResource>(
    {
      url: `/api/playlists/${playlist}/smart`,
      method: "PUT",
      headers: { "Content-Type": "application/json" },
      data: updateSmartPlaylistRulesRequest,
    },
    options
  );
};

export const getPlaylistSmartUpdateMutationOptions = <
  TError = ErrorType<
    | PlaylistSmartUpdate400
    | AuthenticationExceptionResponse
    | AuthorizationExceptionResponse
    | ModelNotFoundExceptionResponse
    | ValidationExceptionResponse
  >,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof playlistSmartUpdate>>,
    TError,
    { playlist: string; data: BodyType<UpdateSmartPlaylistRulesRequest> },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof playlistSmartUpdate>>,
  TError,
  { playlist: string; data: BodyType<UpdateSmartPlaylistRulesRequest> },
  TContext
> => {
  const mutationKey = ["playlistSmartUpdate"];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof playlistSmartUpdate>>,
    { playlist: string; data: BodyType<UpdateSmartPlaylistRulesRequest> }
  > = (props) => {
    const { playlist, data } = props ?? {};

    return playlistSmartUpdate(playlist, data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type PlaylistSmartUpdateMutationResult = NonNullable<
  Awaited<ReturnType<typeof playlistSmartUpdate>>
>;
export type PlaylistSmartUpdateMutationBody =
  BodyType<UpdateSmartPlaylistRulesRequest>;
export type PlaylistSmartUpdateMutationError = ErrorType<
  | PlaylistSmartUpdate400
  | AuthenticationExceptionResponse
  | AuthorizationExceptionResponse
  | ModelNotFoundExceptionResponse
  | ValidationExceptionResponse
>;

/**
 * @summary Smart playlist - Update rules
 */
export const usePlaylistSmartUpdate = <
  TError = ErrorType<
    | PlaylistSmartUpdate400
    | AuthenticationExceptionResponse
    | AuthorizationExceptionResponse
    | ModelNotFoundExceptionResponse
    | ValidationExceptionResponse
  >,
  TContext = unknown
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof playlistSmartUpdate>>,
      TError,
      { playlist: string; data: BodyType<UpdateSmartPlaylistRulesRequest> },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof playlistSmartUpdate>>,
  TError,
  { playlist: string; data: BodyType<UpdateSmartPlaylistRulesRequest> },
  TContext
> => {
  const mutationOptions = getPlaylistSmartUpdateMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
/**
 * @summary Smart playlist - Sync
 */
export const playlistSmartSync = (
  playlist: string,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal
) => {
  return customInstance<PlaylistSmartSync200>(
    { url: `/api/playlists/${playlist}/smart/sync`, method: "POST", signal },
    options
  );
};

export const getPlaylistSmartSyncMutationOptions = <
  TError = ErrorType<
    | PlaylistSmartSync400
    | AuthenticationExceptionResponse
    | AuthorizationExceptionResponse
    | ModelNotFoundExceptionResponse
  >,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof playlistSmartSync>>,
    TError,
    { playlist: string },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof playlistSmartSync>>,
  TError,
  { playlist: string },
  TContext
> => {
  const mutationKey = ["playlistSmartSync"];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof playlistSmartSync>>,
    { playlist: string }
  > = (props) => {
    const { playlist } = props ?? {};

    return playlistSmartSync(playlist, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type PlaylistSmartSyncMutationResult = NonNullable<
  Awaited<ReturnType<typeof playlistSmartSync>>
>;

export type PlaylistSmartSyncMutationError = ErrorType<
  | PlaylistSmartSync400
  | AuthenticationExceptionResponse
  | AuthorizationExceptionResponse
  | ModelNotFoundExceptionResponse
>;

/**
 * @summary Smart playlist - Sync
 */
export const usePlaylistSmartSync = <
  TError = ErrorType<
    | PlaylistSmartSync400
    | AuthenticationExceptionResponse
    | AuthorizationExceptionResponse
    | ModelNotFoundExceptionResponse
  >,
  TContext = unknown
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof playlistSmartSync>>,
      TError,
      { playlist: string },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof playlistSmartSync>>,
  TError,
  { playlist: string },
  TContext
> => {
  const mutationOptions = getPlaylistSmartSyncMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
