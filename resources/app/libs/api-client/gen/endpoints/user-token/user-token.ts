/**
 * Generated by orval v7.11.2 üç∫
 * Do not edit manually.
 * B√•nder api docs
 * B√•nder.App is a sophisticated media server developed with the primary goal to deliver high performance and seamless experience for users.
Being built on top of Laravel framework and PostgreSQL for database, it leverages the power of robust backend technologies, providing high security, reliability, and scalability.

The main focus of B√•nder.App is efficient media management and delivery.
This application is designed to handle large amounts of media files while ensuring quick and efficient access.
Implemented queuing functionality through Redis offers efficient job management and load handling.
The media information is organized and easily searchable, ensuring users can always find what they are looking for quickly and easily.
 * OpenAPI spec version: 0.0.1
 */
import {
  useInfiniteQuery,
  useMutation,
  useQuery,
  useSuspenseInfiniteQuery,
  useSuspenseQuery,
} from "@tanstack/react-query";
import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseInfiniteQueryResult,
  DefinedUseQueryResult,
  InfiniteData,
  MutationFunction,
  QueryClient,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseInfiniteQueryOptions,
  UseInfiniteQueryResult,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult,
  UseSuspenseInfiniteQueryOptions,
  UseSuspenseInfiniteQueryResult,
  UseSuspenseQueryOptions,
  UseSuspenseQueryResult,
} from "@tanstack/react-query";

import type {
  AuthenticationExceptionResponse,
  AuthorizationExceptionResponse,
  ModelNotFoundExceptionResponse,
  PersonalAccessTokenViewResource,
  UserTokensIndexParams,
  ValidationExceptionResponse,
} from "../../models";

import { customInstance } from "../../../axios-instance";
import type { ErrorType } from "../../../axios-instance";

type SecondParameter<T extends (...args: never) => unknown> = Parameters<T>[1];

/**
 * Returns all active tokens for the authenticated user including detailed
security information such as device details, IP history, location data,
and usage statistics for session management.
 * @summary Get a paginated collection of user's personal access tokens
 */
export const userTokensIndex = (
  user: string,
  params?: UserTokensIndexParams,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal
) => {
  return customInstance<PersonalAccessTokenViewResource[]>(
    { url: `/api/users/tokens/${user}`, method: "GET", params, signal },
    options
  );
};

export const getUserTokensIndexQueryKey = (
  user?: string,
  params?: UserTokensIndexParams
) => {
  return [`/api/users/tokens/${user}`, ...(params ? [params] : [])] as const;
};

export const getUserTokensIndexInfiniteQueryOptions = <
  TData = InfiniteData<
    Awaited<ReturnType<typeof userTokensIndex>>,
    UserTokensIndexParams["page"]
  >,
  TError = ErrorType<
    AuthenticationExceptionResponse | ValidationExceptionResponse
  >
>(
  user: string,
  params?: UserTokensIndexParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof userTokensIndex>>,
        TError,
        TData,
        QueryKey,
        UserTokensIndexParams["page"]
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getUserTokensIndexQueryKey(user, params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof userTokensIndex>>,
    QueryKey,
    UserTokensIndexParams["page"]
  > = ({ signal, pageParam }) =>
    userTokensIndex(
      user,
      { ...params, page: pageParam || params?.["page"] },
      requestOptions,
      signal
    );

  return {
    queryKey,
    queryFn,
    enabled: !!user,
    ...queryOptions,
  } as UseInfiniteQueryOptions<
    Awaited<ReturnType<typeof userTokensIndex>>,
    TError,
    TData,
    QueryKey,
    UserTokensIndexParams["page"]
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type UserTokensIndexInfiniteQueryResult = NonNullable<
  Awaited<ReturnType<typeof userTokensIndex>>
>;
export type UserTokensIndexInfiniteQueryError = ErrorType<
  AuthenticationExceptionResponse | ValidationExceptionResponse
>;

export function useUserTokensIndexInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof userTokensIndex>>,
    UserTokensIndexParams["page"]
  >,
  TError = ErrorType<
    AuthenticationExceptionResponse | ValidationExceptionResponse
  >
>(
  user: string,
  params: undefined | UserTokensIndexParams,
  options: {
    query: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof userTokensIndex>>,
        TError,
        TData,
        QueryKey,
        UserTokensIndexParams["page"]
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof userTokensIndex>>,
          TError,
          Awaited<ReturnType<typeof userTokensIndex>>,
          QueryKey
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): DefinedUseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useUserTokensIndexInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof userTokensIndex>>,
    UserTokensIndexParams["page"]
  >,
  TError = ErrorType<
    AuthenticationExceptionResponse | ValidationExceptionResponse
  >
>(
  user: string,
  params?: UserTokensIndexParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof userTokensIndex>>,
        TError,
        TData,
        QueryKey,
        UserTokensIndexParams["page"]
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof userTokensIndex>>,
          TError,
          Awaited<ReturnType<typeof userTokensIndex>>,
          QueryKey
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useUserTokensIndexInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof userTokensIndex>>,
    UserTokensIndexParams["page"]
  >,
  TError = ErrorType<
    AuthenticationExceptionResponse | ValidationExceptionResponse
  >
>(
  user: string,
  params?: UserTokensIndexParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof userTokensIndex>>,
        TError,
        TData,
        QueryKey,
        UserTokensIndexParams["page"]
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get a paginated collection of user's personal access tokens
 */

export function useUserTokensIndexInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof userTokensIndex>>,
    UserTokensIndexParams["page"]
  >,
  TError = ErrorType<
    AuthenticationExceptionResponse | ValidationExceptionResponse
  >
>(
  user: string,
  params?: UserTokensIndexParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof userTokensIndex>>,
        TError,
        TData,
        QueryKey,
        UserTokensIndexParams["page"]
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getUserTokensIndexInfiniteQueryOptions(
    user,
    params,
    options
  );

  const query = useInfiniteQuery(
    queryOptions,
    queryClient
  ) as UseInfiniteQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getUserTokensIndexQueryOptions = <
  TData = Awaited<ReturnType<typeof userTokensIndex>>,
  TError = ErrorType<
    AuthenticationExceptionResponse | ValidationExceptionResponse
  >
>(
  user: string,
  params?: UserTokensIndexParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof userTokensIndex>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getUserTokensIndexQueryKey(user, params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof userTokensIndex>>> = ({
    signal,
  }) => userTokensIndex(user, params, requestOptions, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!user,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof userTokensIndex>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type UserTokensIndexQueryResult = NonNullable<
  Awaited<ReturnType<typeof userTokensIndex>>
>;
export type UserTokensIndexQueryError = ErrorType<
  AuthenticationExceptionResponse | ValidationExceptionResponse
>;

export function useUserTokensIndex<
  TData = Awaited<ReturnType<typeof userTokensIndex>>,
  TError = ErrorType<
    AuthenticationExceptionResponse | ValidationExceptionResponse
  >
>(
  user: string,
  params: undefined | UserTokensIndexParams,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof userTokensIndex>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof userTokensIndex>>,
          TError,
          Awaited<ReturnType<typeof userTokensIndex>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useUserTokensIndex<
  TData = Awaited<ReturnType<typeof userTokensIndex>>,
  TError = ErrorType<
    AuthenticationExceptionResponse | ValidationExceptionResponse
  >
>(
  user: string,
  params?: UserTokensIndexParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof userTokensIndex>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof userTokensIndex>>,
          TError,
          Awaited<ReturnType<typeof userTokensIndex>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useUserTokensIndex<
  TData = Awaited<ReturnType<typeof userTokensIndex>>,
  TError = ErrorType<
    AuthenticationExceptionResponse | ValidationExceptionResponse
  >
>(
  user: string,
  params?: UserTokensIndexParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof userTokensIndex>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get a paginated collection of user's personal access tokens
 */

export function useUserTokensIndex<
  TData = Awaited<ReturnType<typeof userTokensIndex>>,
  TError = ErrorType<
    AuthenticationExceptionResponse | ValidationExceptionResponse
  >
>(
  user: string,
  params?: UserTokensIndexParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof userTokensIndex>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getUserTokensIndexQueryOptions(user, params, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getUserTokensIndexSuspenseQueryOptions = <
  TData = Awaited<ReturnType<typeof userTokensIndex>>,
  TError = ErrorType<
    AuthenticationExceptionResponse | ValidationExceptionResponse
  >
>(
  user: string,
  params?: UserTokensIndexParams,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof userTokensIndex>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getUserTokensIndexQueryKey(user, params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof userTokensIndex>>> = ({
    signal,
  }) => userTokensIndex(user, params, requestOptions, signal);

  return { queryKey, queryFn, ...queryOptions } as UseSuspenseQueryOptions<
    Awaited<ReturnType<typeof userTokensIndex>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type UserTokensIndexSuspenseQueryResult = NonNullable<
  Awaited<ReturnType<typeof userTokensIndex>>
>;
export type UserTokensIndexSuspenseQueryError = ErrorType<
  AuthenticationExceptionResponse | ValidationExceptionResponse
>;

export function useUserTokensIndexSuspense<
  TData = Awaited<ReturnType<typeof userTokensIndex>>,
  TError = ErrorType<
    AuthenticationExceptionResponse | ValidationExceptionResponse
  >
>(
  user: string,
  params: undefined | UserTokensIndexParams,
  options: {
    query: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof userTokensIndex>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useUserTokensIndexSuspense<
  TData = Awaited<ReturnType<typeof userTokensIndex>>,
  TError = ErrorType<
    AuthenticationExceptionResponse | ValidationExceptionResponse
  >
>(
  user: string,
  params?: UserTokensIndexParams,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof userTokensIndex>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useUserTokensIndexSuspense<
  TData = Awaited<ReturnType<typeof userTokensIndex>>,
  TError = ErrorType<
    AuthenticationExceptionResponse | ValidationExceptionResponse
  >
>(
  user: string,
  params?: UserTokensIndexParams,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof userTokensIndex>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get a paginated collection of user's personal access tokens
 */

export function useUserTokensIndexSuspense<
  TData = Awaited<ReturnType<typeof userTokensIndex>>,
  TError = ErrorType<
    AuthenticationExceptionResponse | ValidationExceptionResponse
  >
>(
  user: string,
  params?: UserTokensIndexParams,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof userTokensIndex>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getUserTokensIndexSuspenseQueryOptions(
    user,
    params,
    options
  );

  const query = useSuspenseQuery(
    queryOptions,
    queryClient
  ) as UseSuspenseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getUserTokensIndexSuspenseInfiniteQueryOptions = <
  TData = InfiniteData<
    Awaited<ReturnType<typeof userTokensIndex>>,
    UserTokensIndexParams["page"]
  >,
  TError = ErrorType<
    AuthenticationExceptionResponse | ValidationExceptionResponse
  >
>(
  user: string,
  params?: UserTokensIndexParams,
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof userTokensIndex>>,
        TError,
        TData,
        QueryKey,
        UserTokensIndexParams["page"]
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getUserTokensIndexQueryKey(user, params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof userTokensIndex>>,
    QueryKey,
    UserTokensIndexParams["page"]
  > = ({ signal, pageParam }) =>
    userTokensIndex(
      user,
      { ...params, page: pageParam || params?.["page"] },
      requestOptions,
      signal
    );

  return {
    queryKey,
    queryFn,
    ...queryOptions,
  } as UseSuspenseInfiniteQueryOptions<
    Awaited<ReturnType<typeof userTokensIndex>>,
    TError,
    TData,
    QueryKey,
    UserTokensIndexParams["page"]
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type UserTokensIndexSuspenseInfiniteQueryResult = NonNullable<
  Awaited<ReturnType<typeof userTokensIndex>>
>;
export type UserTokensIndexSuspenseInfiniteQueryError = ErrorType<
  AuthenticationExceptionResponse | ValidationExceptionResponse
>;

export function useUserTokensIndexSuspenseInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof userTokensIndex>>,
    UserTokensIndexParams["page"]
  >,
  TError = ErrorType<
    AuthenticationExceptionResponse | ValidationExceptionResponse
  >
>(
  user: string,
  params: undefined | UserTokensIndexParams,
  options: {
    query: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof userTokensIndex>>,
        TError,
        TData,
        QueryKey,
        UserTokensIndexParams["page"]
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useUserTokensIndexSuspenseInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof userTokensIndex>>,
    UserTokensIndexParams["page"]
  >,
  TError = ErrorType<
    AuthenticationExceptionResponse | ValidationExceptionResponse
  >
>(
  user: string,
  params?: UserTokensIndexParams,
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof userTokensIndex>>,
        TError,
        TData,
        QueryKey,
        UserTokensIndexParams["page"]
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useUserTokensIndexSuspenseInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof userTokensIndex>>,
    UserTokensIndexParams["page"]
  >,
  TError = ErrorType<
    AuthenticationExceptionResponse | ValidationExceptionResponse
  >
>(
  user: string,
  params?: UserTokensIndexParams,
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof userTokensIndex>>,
        TError,
        TData,
        QueryKey,
        UserTokensIndexParams["page"]
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get a paginated collection of user's personal access tokens
 */

export function useUserTokensIndexSuspenseInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof userTokensIndex>>,
    UserTokensIndexParams["page"]
  >,
  TError = ErrorType<
    AuthenticationExceptionResponse | ValidationExceptionResponse
  >
>(
  user: string,
  params?: UserTokensIndexParams,
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof userTokensIndex>>,
        TError,
        TData,
        QueryKey,
        UserTokensIndexParams["page"]
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getUserTokensIndexSuspenseInfiniteQueryOptions(
    user,
    params,
    options
  );

  const query = useSuspenseInfiniteQuery(
    queryOptions,
    queryClient
  ) as UseSuspenseInfiniteQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Permanently revokes a personal access token, ending the associated session.
Users can only revoke their own tokens. Includes security validation to
prevent unauthorized token revocation.
 * @summary Revoke a specific personal access token
 */
export const userTokensRevoke = (
  token: number,
  options?: SecondParameter<typeof customInstance>
) => {
  return customInstance<null>(
    { url: `/api/users/tokens/${token}`, method: "DELETE" },
    options
  );
};

export const getUserTokensRevokeMutationOptions = <
  TError = ErrorType<
    | AuthenticationExceptionResponse
    | AuthorizationExceptionResponse
    | ModelNotFoundExceptionResponse
  >,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof userTokensRevoke>>,
    TError,
    { token: number },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof userTokensRevoke>>,
  TError,
  { token: number },
  TContext
> => {
  const mutationKey = ["userTokensRevoke"];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof userTokensRevoke>>,
    { token: number }
  > = (props) => {
    const { token } = props ?? {};

    return userTokensRevoke(token, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type UserTokensRevokeMutationResult = NonNullable<
  Awaited<ReturnType<typeof userTokensRevoke>>
>;

export type UserTokensRevokeMutationError = ErrorType<
  | AuthenticationExceptionResponse
  | AuthorizationExceptionResponse
  | ModelNotFoundExceptionResponse
>;

/**
 * @summary Revoke a specific personal access token
 */
export const useUserTokensRevoke = <
  TError = ErrorType<
    | AuthenticationExceptionResponse
    | AuthorizationExceptionResponse
    | ModelNotFoundExceptionResponse
  >,
  TContext = unknown
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof userTokensRevoke>>,
      TError,
      { token: number },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof userTokensRevoke>>,
  TError,
  { token: number },
  TContext
> => {
  const mutationOptions = getUserTokensRevokeMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
