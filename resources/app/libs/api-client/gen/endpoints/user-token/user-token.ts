/**
 * Generated by orval v7.11.2 üç∫
 * Do not edit manually.
 * B√•nder api docs
 * B√•nder.App is a sophisticated media server developed with the primary goal to deliver high performance and seamless experience for users.
Being built on top of Laravel framework and PostgreSQL for database, it leverages the power of robust backend technologies, providing high security, reliability, and scalability.

The main focus of B√•nder.App is efficient media management and delivery.
This application is designed to handle large amounts of media files while ensuring quick and efficient access.
Implemented queuing functionality through Redis offers efficient job management and load handling.
The media information is organized and easily searchable, ensuring users can always find what they are looking for quickly and easily.
 * OpenAPI spec version: 0.0.1
 */
import {
  useInfiniteQuery,
  useMutation,
  useQuery,
  useSuspenseInfiniteQuery,
  useSuspenseQuery,
} from "@tanstack/react-query";
import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseInfiniteQueryResult,
  DefinedUseQueryResult,
  InfiniteData,
  MutationFunction,
  QueryClient,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseInfiniteQueryOptions,
  UseInfiniteQueryResult,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult,
  UseSuspenseInfiniteQueryOptions,
  UseSuspenseInfiniteQueryResult,
  UseSuspenseQueryOptions,
  UseSuspenseQueryResult,
} from "@tanstack/react-query";

import type {
  AuthenticationExceptionResponse,
  ModelNotFoundExceptionResponse,
  UserTokenGetUserTokens200,
  UserTokenGetUserTokensParams,
  ValidationExceptionResponse,
} from "../../models";

import { customInstance } from "../../../axios-instance";
import type { ErrorType } from "../../../axios-instance";

type SecondParameter<T extends (...args: never) => unknown> = Parameters<T>[1];

/**
 * @summary Get a collection of tokens
 */
export const userTokenGetUserTokens = (
  user: string,
  params?: UserTokenGetUserTokensParams,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal
) => {
  return customInstance<UserTokenGetUserTokens200>(
    { url: `/api/users/tokens/${user}`, method: "GET", params, signal },
    options
  );
};

export const getUserTokenGetUserTokensQueryKey = (
  user?: string,
  params?: UserTokenGetUserTokensParams
) => {
  return [`/api/users/tokens/${user}`, ...(params ? [params] : [])] as const;
};

export const getUserTokenGetUserTokensInfiniteQueryOptions = <
  TData = InfiniteData<
    Awaited<ReturnType<typeof userTokenGetUserTokens>>,
    UserTokenGetUserTokensParams["page"]
  >,
  TError = ErrorType<
    AuthenticationExceptionResponse | ValidationExceptionResponse
  >
>(
  user: string,
  params?: UserTokenGetUserTokensParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof userTokenGetUserTokens>>,
        TError,
        TData,
        QueryKey,
        UserTokenGetUserTokensParams["page"]
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getUserTokenGetUserTokensQueryKey(user, params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof userTokenGetUserTokens>>,
    QueryKey,
    UserTokenGetUserTokensParams["page"]
  > = ({ signal, pageParam }) =>
    userTokenGetUserTokens(
      user,
      { ...params, page: pageParam || params?.["page"] },
      requestOptions,
      signal
    );

  return {
    queryKey,
    queryFn,
    enabled: !!user,
    ...queryOptions,
  } as UseInfiniteQueryOptions<
    Awaited<ReturnType<typeof userTokenGetUserTokens>>,
    TError,
    TData,
    QueryKey,
    UserTokenGetUserTokensParams["page"]
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type UserTokenGetUserTokensInfiniteQueryResult = NonNullable<
  Awaited<ReturnType<typeof userTokenGetUserTokens>>
>;
export type UserTokenGetUserTokensInfiniteQueryError = ErrorType<
  AuthenticationExceptionResponse | ValidationExceptionResponse
>;

export function useUserTokenGetUserTokensInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof userTokenGetUserTokens>>,
    UserTokenGetUserTokensParams["page"]
  >,
  TError = ErrorType<
    AuthenticationExceptionResponse | ValidationExceptionResponse
  >
>(
  user: string,
  params: undefined | UserTokenGetUserTokensParams,
  options: {
    query: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof userTokenGetUserTokens>>,
        TError,
        TData,
        QueryKey,
        UserTokenGetUserTokensParams["page"]
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof userTokenGetUserTokens>>,
          TError,
          Awaited<ReturnType<typeof userTokenGetUserTokens>>,
          QueryKey
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): DefinedUseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useUserTokenGetUserTokensInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof userTokenGetUserTokens>>,
    UserTokenGetUserTokensParams["page"]
  >,
  TError = ErrorType<
    AuthenticationExceptionResponse | ValidationExceptionResponse
  >
>(
  user: string,
  params?: UserTokenGetUserTokensParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof userTokenGetUserTokens>>,
        TError,
        TData,
        QueryKey,
        UserTokenGetUserTokensParams["page"]
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof userTokenGetUserTokens>>,
          TError,
          Awaited<ReturnType<typeof userTokenGetUserTokens>>,
          QueryKey
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useUserTokenGetUserTokensInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof userTokenGetUserTokens>>,
    UserTokenGetUserTokensParams["page"]
  >,
  TError = ErrorType<
    AuthenticationExceptionResponse | ValidationExceptionResponse
  >
>(
  user: string,
  params?: UserTokenGetUserTokensParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof userTokenGetUserTokens>>,
        TError,
        TData,
        QueryKey,
        UserTokenGetUserTokensParams["page"]
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get a collection of tokens
 */

export function useUserTokenGetUserTokensInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof userTokenGetUserTokens>>,
    UserTokenGetUserTokensParams["page"]
  >,
  TError = ErrorType<
    AuthenticationExceptionResponse | ValidationExceptionResponse
  >
>(
  user: string,
  params?: UserTokenGetUserTokensParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof userTokenGetUserTokens>>,
        TError,
        TData,
        QueryKey,
        UserTokenGetUserTokensParams["page"]
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getUserTokenGetUserTokensInfiniteQueryOptions(
    user,
    params,
    options
  );

  const query = useInfiniteQuery(
    queryOptions,
    queryClient
  ) as UseInfiniteQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getUserTokenGetUserTokensQueryOptions = <
  TData = Awaited<ReturnType<typeof userTokenGetUserTokens>>,
  TError = ErrorType<
    AuthenticationExceptionResponse | ValidationExceptionResponse
  >
>(
  user: string,
  params?: UserTokenGetUserTokensParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof userTokenGetUserTokens>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getUserTokenGetUserTokensQueryKey(user, params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof userTokenGetUserTokens>>
  > = ({ signal }) =>
    userTokenGetUserTokens(user, params, requestOptions, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!user,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof userTokenGetUserTokens>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type UserTokenGetUserTokensQueryResult = NonNullable<
  Awaited<ReturnType<typeof userTokenGetUserTokens>>
>;
export type UserTokenGetUserTokensQueryError = ErrorType<
  AuthenticationExceptionResponse | ValidationExceptionResponse
>;

export function useUserTokenGetUserTokens<
  TData = Awaited<ReturnType<typeof userTokenGetUserTokens>>,
  TError = ErrorType<
    AuthenticationExceptionResponse | ValidationExceptionResponse
  >
>(
  user: string,
  params: undefined | UserTokenGetUserTokensParams,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof userTokenGetUserTokens>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof userTokenGetUserTokens>>,
          TError,
          Awaited<ReturnType<typeof userTokenGetUserTokens>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useUserTokenGetUserTokens<
  TData = Awaited<ReturnType<typeof userTokenGetUserTokens>>,
  TError = ErrorType<
    AuthenticationExceptionResponse | ValidationExceptionResponse
  >
>(
  user: string,
  params?: UserTokenGetUserTokensParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof userTokenGetUserTokens>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof userTokenGetUserTokens>>,
          TError,
          Awaited<ReturnType<typeof userTokenGetUserTokens>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useUserTokenGetUserTokens<
  TData = Awaited<ReturnType<typeof userTokenGetUserTokens>>,
  TError = ErrorType<
    AuthenticationExceptionResponse | ValidationExceptionResponse
  >
>(
  user: string,
  params?: UserTokenGetUserTokensParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof userTokenGetUserTokens>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get a collection of tokens
 */

export function useUserTokenGetUserTokens<
  TData = Awaited<ReturnType<typeof userTokenGetUserTokens>>,
  TError = ErrorType<
    AuthenticationExceptionResponse | ValidationExceptionResponse
  >
>(
  user: string,
  params?: UserTokenGetUserTokensParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof userTokenGetUserTokens>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getUserTokenGetUserTokensQueryOptions(
    user,
    params,
    options
  );

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getUserTokenGetUserTokensSuspenseQueryOptions = <
  TData = Awaited<ReturnType<typeof userTokenGetUserTokens>>,
  TError = ErrorType<
    AuthenticationExceptionResponse | ValidationExceptionResponse
  >
>(
  user: string,
  params?: UserTokenGetUserTokensParams,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof userTokenGetUserTokens>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getUserTokenGetUserTokensQueryKey(user, params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof userTokenGetUserTokens>>
  > = ({ signal }) =>
    userTokenGetUserTokens(user, params, requestOptions, signal);

  return { queryKey, queryFn, ...queryOptions } as UseSuspenseQueryOptions<
    Awaited<ReturnType<typeof userTokenGetUserTokens>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type UserTokenGetUserTokensSuspenseQueryResult = NonNullable<
  Awaited<ReturnType<typeof userTokenGetUserTokens>>
>;
export type UserTokenGetUserTokensSuspenseQueryError = ErrorType<
  AuthenticationExceptionResponse | ValidationExceptionResponse
>;

export function useUserTokenGetUserTokensSuspense<
  TData = Awaited<ReturnType<typeof userTokenGetUserTokens>>,
  TError = ErrorType<
    AuthenticationExceptionResponse | ValidationExceptionResponse
  >
>(
  user: string,
  params: undefined | UserTokenGetUserTokensParams,
  options: {
    query: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof userTokenGetUserTokens>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useUserTokenGetUserTokensSuspense<
  TData = Awaited<ReturnType<typeof userTokenGetUserTokens>>,
  TError = ErrorType<
    AuthenticationExceptionResponse | ValidationExceptionResponse
  >
>(
  user: string,
  params?: UserTokenGetUserTokensParams,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof userTokenGetUserTokens>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useUserTokenGetUserTokensSuspense<
  TData = Awaited<ReturnType<typeof userTokenGetUserTokens>>,
  TError = ErrorType<
    AuthenticationExceptionResponse | ValidationExceptionResponse
  >
>(
  user: string,
  params?: UserTokenGetUserTokensParams,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof userTokenGetUserTokens>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get a collection of tokens
 */

export function useUserTokenGetUserTokensSuspense<
  TData = Awaited<ReturnType<typeof userTokenGetUserTokens>>,
  TError = ErrorType<
    AuthenticationExceptionResponse | ValidationExceptionResponse
  >
>(
  user: string,
  params?: UserTokenGetUserTokensParams,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof userTokenGetUserTokens>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getUserTokenGetUserTokensSuspenseQueryOptions(
    user,
    params,
    options
  );

  const query = useSuspenseQuery(
    queryOptions,
    queryClient
  ) as UseSuspenseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getUserTokenGetUserTokensSuspenseInfiniteQueryOptions = <
  TData = InfiniteData<
    Awaited<ReturnType<typeof userTokenGetUserTokens>>,
    UserTokenGetUserTokensParams["page"]
  >,
  TError = ErrorType<
    AuthenticationExceptionResponse | ValidationExceptionResponse
  >
>(
  user: string,
  params?: UserTokenGetUserTokensParams,
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof userTokenGetUserTokens>>,
        TError,
        TData,
        QueryKey,
        UserTokenGetUserTokensParams["page"]
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getUserTokenGetUserTokensQueryKey(user, params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof userTokenGetUserTokens>>,
    QueryKey,
    UserTokenGetUserTokensParams["page"]
  > = ({ signal, pageParam }) =>
    userTokenGetUserTokens(
      user,
      { ...params, page: pageParam || params?.["page"] },
      requestOptions,
      signal
    );

  return {
    queryKey,
    queryFn,
    ...queryOptions,
  } as UseSuspenseInfiniteQueryOptions<
    Awaited<ReturnType<typeof userTokenGetUserTokens>>,
    TError,
    TData,
    QueryKey,
    UserTokenGetUserTokensParams["page"]
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type UserTokenGetUserTokensSuspenseInfiniteQueryResult = NonNullable<
  Awaited<ReturnType<typeof userTokenGetUserTokens>>
>;
export type UserTokenGetUserTokensSuspenseInfiniteQueryError = ErrorType<
  AuthenticationExceptionResponse | ValidationExceptionResponse
>;

export function useUserTokenGetUserTokensSuspenseInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof userTokenGetUserTokens>>,
    UserTokenGetUserTokensParams["page"]
  >,
  TError = ErrorType<
    AuthenticationExceptionResponse | ValidationExceptionResponse
  >
>(
  user: string,
  params: undefined | UserTokenGetUserTokensParams,
  options: {
    query: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof userTokenGetUserTokens>>,
        TError,
        TData,
        QueryKey,
        UserTokenGetUserTokensParams["page"]
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useUserTokenGetUserTokensSuspenseInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof userTokenGetUserTokens>>,
    UserTokenGetUserTokensParams["page"]
  >,
  TError = ErrorType<
    AuthenticationExceptionResponse | ValidationExceptionResponse
  >
>(
  user: string,
  params?: UserTokenGetUserTokensParams,
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof userTokenGetUserTokens>>,
        TError,
        TData,
        QueryKey,
        UserTokenGetUserTokensParams["page"]
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useUserTokenGetUserTokensSuspenseInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof userTokenGetUserTokens>>,
    UserTokenGetUserTokensParams["page"]
  >,
  TError = ErrorType<
    AuthenticationExceptionResponse | ValidationExceptionResponse
  >
>(
  user: string,
  params?: UserTokenGetUserTokensParams,
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof userTokenGetUserTokens>>,
        TError,
        TData,
        QueryKey,
        UserTokenGetUserTokensParams["page"]
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get a collection of tokens
 */

export function useUserTokenGetUserTokensSuspenseInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof userTokenGetUserTokens>>,
    UserTokenGetUserTokensParams["page"]
  >,
  TError = ErrorType<
    AuthenticationExceptionResponse | ValidationExceptionResponse
  >
>(
  user: string,
  params?: UserTokenGetUserTokensParams,
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof userTokenGetUserTokens>>,
        TError,
        TData,
        QueryKey,
        UserTokenGetUserTokensParams["page"]
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getUserTokenGetUserTokensSuspenseInfiniteQueryOptions(
    user,
    params,
    options
  );

  const query = useSuspenseInfiniteQuery(
    queryOptions,
    queryClient
  ) as UseSuspenseInfiniteQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Revoke a given token
 */
export const userTokenRevokeToken = (
  token: number,
  options?: SecondParameter<typeof customInstance>
) => {
  return customInstance<null>(
    { url: `/api/users/tokens/${token}`, method: "DELETE" },
    options
  );
};

export const getUserTokenRevokeTokenMutationOptions = <
  TError = ErrorType<
    AuthenticationExceptionResponse | ModelNotFoundExceptionResponse
  >,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof userTokenRevokeToken>>,
    TError,
    { token: number },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof userTokenRevokeToken>>,
  TError,
  { token: number },
  TContext
> => {
  const mutationKey = ["userTokenRevokeToken"];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof userTokenRevokeToken>>,
    { token: number }
  > = (props) => {
    const { token } = props ?? {};

    return userTokenRevokeToken(token, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type UserTokenRevokeTokenMutationResult = NonNullable<
  Awaited<ReturnType<typeof userTokenRevokeToken>>
>;

export type UserTokenRevokeTokenMutationError = ErrorType<
  AuthenticationExceptionResponse | ModelNotFoundExceptionResponse
>;

/**
 * @summary Revoke a given token
 */
export const useUserTokenRevokeToken = <
  TError = ErrorType<
    AuthenticationExceptionResponse | ModelNotFoundExceptionResponse
  >,
  TContext = unknown
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof userTokenRevokeToken>>,
      TError,
      { token: number },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof userTokenRevokeToken>>,
  TError,
  { token: number },
  TContext
> => {
  const mutationOptions = getUserTokenRevokeTokenMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
