/**
 * Generated by orval v7.11.2 üç∫
 * Do not edit manually.
 * B√•nder api docs
 * B√•nder.App is a sophisticated media server developed with the primary goal to deliver high performance and seamless experience for users.
Being built on top of Laravel framework and PostgreSQL for database, it leverages the power of robust backend technologies, providing high security, reliability, and scalability.

The main focus of B√•nder.App is efficient media management and delivery.
This application is designed to handle large amounts of media files while ensuring quick and efficient access.
Implemented queuing functionality through Redis offers efficient job management and load handling.
The media information is organized and easily searchable, ensuring users can always find what they are looking for quickly and easily.
 * OpenAPI spec version: 0.0.1
 */
import {
  useInfiniteQuery,
  useMutation,
  useQuery,
  useSuspenseInfiniteQuery,
  useSuspenseQuery,
} from "@tanstack/react-query";
import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseInfiniteQueryResult,
  DefinedUseQueryResult,
  InfiniteData,
  MutationFunction,
  QueryClient,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseInfiniteQueryOptions,
  UseInfiniteQueryResult,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult,
  UseSuspenseInfiniteQueryOptions,
  UseSuspenseInfiniteQueryResult,
  UseSuspenseQueryOptions,
  UseSuspenseQueryResult,
} from "@tanstack/react-query";

import type {
  AuthenticationExceptionResponse,
  AuthorizationExceptionResponse,
  ModelNotFoundExceptionResponse,
  QueueMetricsMetrics200Item,
  QueueMetricsMetricsParams,
  QueueMetricsQueues200Item,
  QueueMetricsRetryJob200,
  QueueMetricsRetryJob400,
  QueueMetricsShowParams,
  QueueMonitorResource,
  RetryJobRequest,
  ValidationExceptionResponse,
} from "../../models";

import { customInstance } from "../../../axios-instance";
import type { ErrorType, BodyType } from "../../../axios-instance";

type SecondParameter<T extends (...args: never) => unknown> = Parameters<T>[1];

/**
 * Returns filtered and paginated queue job monitoring data with support for
filtering by status, queue name, job name, and custom ordering options.
Provides comprehensive job execution tracking and debugging information.
 * @summary Get paginated collection of queue monitor entries
 */
export const queueMetricsShow = (
  params?: QueueMetricsShowParams,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal
) => {
  return customInstance<QueueMonitorResource[]>(
    { url: `/api/queue-metrics`, method: "GET", params, signal },
    options
  );
};

export const getQueueMetricsShowQueryKey = (
  params?: QueueMetricsShowParams
) => {
  return [`/api/queue-metrics`, ...(params ? [params] : [])] as const;
};

export const getQueueMetricsShowInfiniteQueryOptions = <
  TData = InfiniteData<
    Awaited<ReturnType<typeof queueMetricsShow>>,
    QueueMetricsShowParams["page"]
  >,
  TError = ErrorType<
    | AuthenticationExceptionResponse
    | AuthorizationExceptionResponse
    | ValidationExceptionResponse
  >
>(
  params?: QueueMetricsShowParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof queueMetricsShow>>,
        TError,
        TData,
        QueryKey,
        QueueMetricsShowParams["page"]
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getQueueMetricsShowQueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof queueMetricsShow>>,
    QueryKey,
    QueueMetricsShowParams["page"]
  > = ({ signal, pageParam }) =>
    queueMetricsShow(
      { ...params, page: pageParam || params?.["page"] },
      requestOptions,
      signal
    );

  return { queryKey, queryFn, ...queryOptions } as UseInfiniteQueryOptions<
    Awaited<ReturnType<typeof queueMetricsShow>>,
    TError,
    TData,
    QueryKey,
    QueueMetricsShowParams["page"]
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type QueueMetricsShowInfiniteQueryResult = NonNullable<
  Awaited<ReturnType<typeof queueMetricsShow>>
>;
export type QueueMetricsShowInfiniteQueryError = ErrorType<
  | AuthenticationExceptionResponse
  | AuthorizationExceptionResponse
  | ValidationExceptionResponse
>;

export function useQueueMetricsShowInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof queueMetricsShow>>,
    QueueMetricsShowParams["page"]
  >,
  TError = ErrorType<
    | AuthenticationExceptionResponse
    | AuthorizationExceptionResponse
    | ValidationExceptionResponse
  >
>(
  params: undefined | QueueMetricsShowParams,
  options: {
    query: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof queueMetricsShow>>,
        TError,
        TData,
        QueryKey,
        QueueMetricsShowParams["page"]
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof queueMetricsShow>>,
          TError,
          Awaited<ReturnType<typeof queueMetricsShow>>,
          QueryKey
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): DefinedUseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useQueueMetricsShowInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof queueMetricsShow>>,
    QueueMetricsShowParams["page"]
  >,
  TError = ErrorType<
    | AuthenticationExceptionResponse
    | AuthorizationExceptionResponse
    | ValidationExceptionResponse
  >
>(
  params?: QueueMetricsShowParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof queueMetricsShow>>,
        TError,
        TData,
        QueryKey,
        QueueMetricsShowParams["page"]
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof queueMetricsShow>>,
          TError,
          Awaited<ReturnType<typeof queueMetricsShow>>,
          QueryKey
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useQueueMetricsShowInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof queueMetricsShow>>,
    QueueMetricsShowParams["page"]
  >,
  TError = ErrorType<
    | AuthenticationExceptionResponse
    | AuthorizationExceptionResponse
    | ValidationExceptionResponse
  >
>(
  params?: QueueMetricsShowParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof queueMetricsShow>>,
        TError,
        TData,
        QueryKey,
        QueueMetricsShowParams["page"]
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get paginated collection of queue monitor entries
 */

export function useQueueMetricsShowInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof queueMetricsShow>>,
    QueueMetricsShowParams["page"]
  >,
  TError = ErrorType<
    | AuthenticationExceptionResponse
    | AuthorizationExceptionResponse
    | ValidationExceptionResponse
  >
>(
  params?: QueueMetricsShowParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof queueMetricsShow>>,
        TError,
        TData,
        QueryKey,
        QueueMetricsShowParams["page"]
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getQueueMetricsShowInfiniteQueryOptions(params, options);

  const query = useInfiniteQuery(
    queryOptions,
    queryClient
  ) as UseInfiniteQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getQueueMetricsShowQueryOptions = <
  TData = Awaited<ReturnType<typeof queueMetricsShow>>,
  TError = ErrorType<
    | AuthenticationExceptionResponse
    | AuthorizationExceptionResponse
    | ValidationExceptionResponse
  >
>(
  params?: QueueMetricsShowParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof queueMetricsShow>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getQueueMetricsShowQueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof queueMetricsShow>>
  > = ({ signal }) => queueMetricsShow(params, requestOptions, signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof queueMetricsShow>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type QueueMetricsShowQueryResult = NonNullable<
  Awaited<ReturnType<typeof queueMetricsShow>>
>;
export type QueueMetricsShowQueryError = ErrorType<
  | AuthenticationExceptionResponse
  | AuthorizationExceptionResponse
  | ValidationExceptionResponse
>;

export function useQueueMetricsShow<
  TData = Awaited<ReturnType<typeof queueMetricsShow>>,
  TError = ErrorType<
    | AuthenticationExceptionResponse
    | AuthorizationExceptionResponse
    | ValidationExceptionResponse
  >
>(
  params: undefined | QueueMetricsShowParams,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof queueMetricsShow>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof queueMetricsShow>>,
          TError,
          Awaited<ReturnType<typeof queueMetricsShow>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useQueueMetricsShow<
  TData = Awaited<ReturnType<typeof queueMetricsShow>>,
  TError = ErrorType<
    | AuthenticationExceptionResponse
    | AuthorizationExceptionResponse
    | ValidationExceptionResponse
  >
>(
  params?: QueueMetricsShowParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof queueMetricsShow>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof queueMetricsShow>>,
          TError,
          Awaited<ReturnType<typeof queueMetricsShow>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useQueueMetricsShow<
  TData = Awaited<ReturnType<typeof queueMetricsShow>>,
  TError = ErrorType<
    | AuthenticationExceptionResponse
    | AuthorizationExceptionResponse
    | ValidationExceptionResponse
  >
>(
  params?: QueueMetricsShowParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof queueMetricsShow>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get paginated collection of queue monitor entries
 */

export function useQueueMetricsShow<
  TData = Awaited<ReturnType<typeof queueMetricsShow>>,
  TError = ErrorType<
    | AuthenticationExceptionResponse
    | AuthorizationExceptionResponse
    | ValidationExceptionResponse
  >
>(
  params?: QueueMetricsShowParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof queueMetricsShow>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getQueueMetricsShowQueryOptions(params, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getQueueMetricsShowSuspenseQueryOptions = <
  TData = Awaited<ReturnType<typeof queueMetricsShow>>,
  TError = ErrorType<
    | AuthenticationExceptionResponse
    | AuthorizationExceptionResponse
    | ValidationExceptionResponse
  >
>(
  params?: QueueMetricsShowParams,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof queueMetricsShow>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getQueueMetricsShowQueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof queueMetricsShow>>
  > = ({ signal }) => queueMetricsShow(params, requestOptions, signal);

  return { queryKey, queryFn, ...queryOptions } as UseSuspenseQueryOptions<
    Awaited<ReturnType<typeof queueMetricsShow>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type QueueMetricsShowSuspenseQueryResult = NonNullable<
  Awaited<ReturnType<typeof queueMetricsShow>>
>;
export type QueueMetricsShowSuspenseQueryError = ErrorType<
  | AuthenticationExceptionResponse
  | AuthorizationExceptionResponse
  | ValidationExceptionResponse
>;

export function useQueueMetricsShowSuspense<
  TData = Awaited<ReturnType<typeof queueMetricsShow>>,
  TError = ErrorType<
    | AuthenticationExceptionResponse
    | AuthorizationExceptionResponse
    | ValidationExceptionResponse
  >
>(
  params: undefined | QueueMetricsShowParams,
  options: {
    query: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof queueMetricsShow>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useQueueMetricsShowSuspense<
  TData = Awaited<ReturnType<typeof queueMetricsShow>>,
  TError = ErrorType<
    | AuthenticationExceptionResponse
    | AuthorizationExceptionResponse
    | ValidationExceptionResponse
  >
>(
  params?: QueueMetricsShowParams,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof queueMetricsShow>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useQueueMetricsShowSuspense<
  TData = Awaited<ReturnType<typeof queueMetricsShow>>,
  TError = ErrorType<
    | AuthenticationExceptionResponse
    | AuthorizationExceptionResponse
    | ValidationExceptionResponse
  >
>(
  params?: QueueMetricsShowParams,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof queueMetricsShow>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get paginated collection of queue monitor entries
 */

export function useQueueMetricsShowSuspense<
  TData = Awaited<ReturnType<typeof queueMetricsShow>>,
  TError = ErrorType<
    | AuthenticationExceptionResponse
    | AuthorizationExceptionResponse
    | ValidationExceptionResponse
  >
>(
  params?: QueueMetricsShowParams,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof queueMetricsShow>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getQueueMetricsShowSuspenseQueryOptions(params, options);

  const query = useSuspenseQuery(
    queryOptions,
    queryClient
  ) as UseSuspenseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getQueueMetricsShowSuspenseInfiniteQueryOptions = <
  TData = InfiniteData<
    Awaited<ReturnType<typeof queueMetricsShow>>,
    QueueMetricsShowParams["page"]
  >,
  TError = ErrorType<
    | AuthenticationExceptionResponse
    | AuthorizationExceptionResponse
    | ValidationExceptionResponse
  >
>(
  params?: QueueMetricsShowParams,
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof queueMetricsShow>>,
        TError,
        TData,
        QueryKey,
        QueueMetricsShowParams["page"]
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getQueueMetricsShowQueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof queueMetricsShow>>,
    QueryKey,
    QueueMetricsShowParams["page"]
  > = ({ signal, pageParam }) =>
    queueMetricsShow(
      { ...params, page: pageParam || params?.["page"] },
      requestOptions,
      signal
    );

  return {
    queryKey,
    queryFn,
    ...queryOptions,
  } as UseSuspenseInfiniteQueryOptions<
    Awaited<ReturnType<typeof queueMetricsShow>>,
    TError,
    TData,
    QueryKey,
    QueueMetricsShowParams["page"]
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type QueueMetricsShowSuspenseInfiniteQueryResult = NonNullable<
  Awaited<ReturnType<typeof queueMetricsShow>>
>;
export type QueueMetricsShowSuspenseInfiniteQueryError = ErrorType<
  | AuthenticationExceptionResponse
  | AuthorizationExceptionResponse
  | ValidationExceptionResponse
>;

export function useQueueMetricsShowSuspenseInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof queueMetricsShow>>,
    QueueMetricsShowParams["page"]
  >,
  TError = ErrorType<
    | AuthenticationExceptionResponse
    | AuthorizationExceptionResponse
    | ValidationExceptionResponse
  >
>(
  params: undefined | QueueMetricsShowParams,
  options: {
    query: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof queueMetricsShow>>,
        TError,
        TData,
        QueryKey,
        QueueMetricsShowParams["page"]
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useQueueMetricsShowSuspenseInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof queueMetricsShow>>,
    QueueMetricsShowParams["page"]
  >,
  TError = ErrorType<
    | AuthenticationExceptionResponse
    | AuthorizationExceptionResponse
    | ValidationExceptionResponse
  >
>(
  params?: QueueMetricsShowParams,
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof queueMetricsShow>>,
        TError,
        TData,
        QueryKey,
        QueueMetricsShowParams["page"]
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useQueueMetricsShowSuspenseInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof queueMetricsShow>>,
    QueueMetricsShowParams["page"]
  >,
  TError = ErrorType<
    | AuthenticationExceptionResponse
    | AuthorizationExceptionResponse
    | ValidationExceptionResponse
  >
>(
  params?: QueueMetricsShowParams,
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof queueMetricsShow>>,
        TError,
        TData,
        QueryKey,
        QueueMetricsShowParams["page"]
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get paginated collection of queue monitor entries
 */

export function useQueueMetricsShowSuspenseInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof queueMetricsShow>>,
    QueueMetricsShowParams["page"]
  >,
  TError = ErrorType<
    | AuthenticationExceptionResponse
    | AuthorizationExceptionResponse
    | ValidationExceptionResponse
  >
>(
  params?: QueueMetricsShowParams,
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof queueMetricsShow>>,
        TError,
        TData,
        QueryKey,
        QueueMetricsShowParams["page"]
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getQueueMetricsShowSuspenseInfiniteQueryOptions(
    params,
    options
  );

  const query = useSuspenseInfiniteQuery(
    queryOptions,
    queryClient
  ) as UseSuspenseInfiniteQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Returns a distinct list of all queue names currently in the monitoring system.
Useful for populating filter dropdowns and understanding queue structure.
 * @summary Get list of all available queue names
 */
export const queueMetricsQueues = (
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal
) => {
  return customInstance<QueueMetricsQueues200Item[]>(
    { url: `/api/queue-metrics/queues`, method: "GET", signal },
    options
  );
};

export const getQueueMetricsQueuesQueryKey = () => {
  return [`/api/queue-metrics/queues`] as const;
};

export const getQueueMetricsQueuesInfiniteQueryOptions = <
  TData = InfiniteData<Awaited<ReturnType<typeof queueMetricsQueues>>>,
  TError = ErrorType<
    AuthenticationExceptionResponse | AuthorizationExceptionResponse
  >
>(options?: {
  query?: Partial<
    UseInfiniteQueryOptions<
      Awaited<ReturnType<typeof queueMetricsQueues>>,
      TError,
      TData
    >
  >;
  request?: SecondParameter<typeof customInstance>;
}) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getQueueMetricsQueuesQueryKey();

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof queueMetricsQueues>>
  > = ({ signal }) => queueMetricsQueues(requestOptions, signal);

  return { queryKey, queryFn, ...queryOptions } as UseInfiniteQueryOptions<
    Awaited<ReturnType<typeof queueMetricsQueues>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type QueueMetricsQueuesInfiniteQueryResult = NonNullable<
  Awaited<ReturnType<typeof queueMetricsQueues>>
>;
export type QueueMetricsQueuesInfiniteQueryError = ErrorType<
  AuthenticationExceptionResponse | AuthorizationExceptionResponse
>;

export function useQueueMetricsQueuesInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof queueMetricsQueues>>>,
  TError = ErrorType<
    AuthenticationExceptionResponse | AuthorizationExceptionResponse
  >
>(
  options: {
    query: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof queueMetricsQueues>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof queueMetricsQueues>>,
          TError,
          Awaited<ReturnType<typeof queueMetricsQueues>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): DefinedUseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useQueueMetricsQueuesInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof queueMetricsQueues>>>,
  TError = ErrorType<
    AuthenticationExceptionResponse | AuthorizationExceptionResponse
  >
>(
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof queueMetricsQueues>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof queueMetricsQueues>>,
          TError,
          Awaited<ReturnType<typeof queueMetricsQueues>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useQueueMetricsQueuesInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof queueMetricsQueues>>>,
  TError = ErrorType<
    AuthenticationExceptionResponse | AuthorizationExceptionResponse
  >
>(
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof queueMetricsQueues>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get list of all available queue names
 */

export function useQueueMetricsQueuesInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof queueMetricsQueues>>>,
  TError = ErrorType<
    AuthenticationExceptionResponse | AuthorizationExceptionResponse
  >
>(
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof queueMetricsQueues>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getQueueMetricsQueuesInfiniteQueryOptions(options);

  const query = useInfiniteQuery(
    queryOptions,
    queryClient
  ) as UseInfiniteQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getQueueMetricsQueuesQueryOptions = <
  TData = Awaited<ReturnType<typeof queueMetricsQueues>>,
  TError = ErrorType<
    AuthenticationExceptionResponse | AuthorizationExceptionResponse
  >
>(options?: {
  query?: Partial<
    UseQueryOptions<
      Awaited<ReturnType<typeof queueMetricsQueues>>,
      TError,
      TData
    >
  >;
  request?: SecondParameter<typeof customInstance>;
}) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getQueueMetricsQueuesQueryKey();

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof queueMetricsQueues>>
  > = ({ signal }) => queueMetricsQueues(requestOptions, signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof queueMetricsQueues>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type QueueMetricsQueuesQueryResult = NonNullable<
  Awaited<ReturnType<typeof queueMetricsQueues>>
>;
export type QueueMetricsQueuesQueryError = ErrorType<
  AuthenticationExceptionResponse | AuthorizationExceptionResponse
>;

export function useQueueMetricsQueues<
  TData = Awaited<ReturnType<typeof queueMetricsQueues>>,
  TError = ErrorType<
    AuthenticationExceptionResponse | AuthorizationExceptionResponse
  >
>(
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof queueMetricsQueues>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof queueMetricsQueues>>,
          TError,
          Awaited<ReturnType<typeof queueMetricsQueues>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useQueueMetricsQueues<
  TData = Awaited<ReturnType<typeof queueMetricsQueues>>,
  TError = ErrorType<
    AuthenticationExceptionResponse | AuthorizationExceptionResponse
  >
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof queueMetricsQueues>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof queueMetricsQueues>>,
          TError,
          Awaited<ReturnType<typeof queueMetricsQueues>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useQueueMetricsQueues<
  TData = Awaited<ReturnType<typeof queueMetricsQueues>>,
  TError = ErrorType<
    AuthenticationExceptionResponse | AuthorizationExceptionResponse
  >
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof queueMetricsQueues>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get list of all available queue names
 */

export function useQueueMetricsQueues<
  TData = Awaited<ReturnType<typeof queueMetricsQueues>>,
  TError = ErrorType<
    AuthenticationExceptionResponse | AuthorizationExceptionResponse
  >
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof queueMetricsQueues>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getQueueMetricsQueuesQueryOptions(options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getQueueMetricsQueuesSuspenseQueryOptions = <
  TData = Awaited<ReturnType<typeof queueMetricsQueues>>,
  TError = ErrorType<
    AuthenticationExceptionResponse | AuthorizationExceptionResponse
  >
>(options?: {
  query?: Partial<
    UseSuspenseQueryOptions<
      Awaited<ReturnType<typeof queueMetricsQueues>>,
      TError,
      TData
    >
  >;
  request?: SecondParameter<typeof customInstance>;
}) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getQueueMetricsQueuesQueryKey();

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof queueMetricsQueues>>
  > = ({ signal }) => queueMetricsQueues(requestOptions, signal);

  return { queryKey, queryFn, ...queryOptions } as UseSuspenseQueryOptions<
    Awaited<ReturnType<typeof queueMetricsQueues>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type QueueMetricsQueuesSuspenseQueryResult = NonNullable<
  Awaited<ReturnType<typeof queueMetricsQueues>>
>;
export type QueueMetricsQueuesSuspenseQueryError = ErrorType<
  AuthenticationExceptionResponse | AuthorizationExceptionResponse
>;

export function useQueueMetricsQueuesSuspense<
  TData = Awaited<ReturnType<typeof queueMetricsQueues>>,
  TError = ErrorType<
    AuthenticationExceptionResponse | AuthorizationExceptionResponse
  >
>(
  options: {
    query: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof queueMetricsQueues>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useQueueMetricsQueuesSuspense<
  TData = Awaited<ReturnType<typeof queueMetricsQueues>>,
  TError = ErrorType<
    AuthenticationExceptionResponse | AuthorizationExceptionResponse
  >
>(
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof queueMetricsQueues>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useQueueMetricsQueuesSuspense<
  TData = Awaited<ReturnType<typeof queueMetricsQueues>>,
  TError = ErrorType<
    AuthenticationExceptionResponse | AuthorizationExceptionResponse
  >
>(
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof queueMetricsQueues>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get list of all available queue names
 */

export function useQueueMetricsQueuesSuspense<
  TData = Awaited<ReturnType<typeof queueMetricsQueues>>,
  TError = ErrorType<
    AuthenticationExceptionResponse | AuthorizationExceptionResponse
  >
>(
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof queueMetricsQueues>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getQueueMetricsQueuesSuspenseQueryOptions(options);

  const query = useSuspenseQuery(
    queryOptions,
    queryClient
  ) as UseSuspenseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getQueueMetricsQueuesSuspenseInfiniteQueryOptions = <
  TData = InfiniteData<Awaited<ReturnType<typeof queueMetricsQueues>>>,
  TError = ErrorType<
    AuthenticationExceptionResponse | AuthorizationExceptionResponse
  >
>(options?: {
  query?: Partial<
    UseSuspenseInfiniteQueryOptions<
      Awaited<ReturnType<typeof queueMetricsQueues>>,
      TError,
      TData
    >
  >;
  request?: SecondParameter<typeof customInstance>;
}) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getQueueMetricsQueuesQueryKey();

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof queueMetricsQueues>>
  > = ({ signal }) => queueMetricsQueues(requestOptions, signal);

  return {
    queryKey,
    queryFn,
    ...queryOptions,
  } as UseSuspenseInfiniteQueryOptions<
    Awaited<ReturnType<typeof queueMetricsQueues>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type QueueMetricsQueuesSuspenseInfiniteQueryResult = NonNullable<
  Awaited<ReturnType<typeof queueMetricsQueues>>
>;
export type QueueMetricsQueuesSuspenseInfiniteQueryError = ErrorType<
  AuthenticationExceptionResponse | AuthorizationExceptionResponse
>;

export function useQueueMetricsQueuesSuspenseInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof queueMetricsQueues>>>,
  TError = ErrorType<
    AuthenticationExceptionResponse | AuthorizationExceptionResponse
  >
>(
  options: {
    query: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof queueMetricsQueues>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useQueueMetricsQueuesSuspenseInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof queueMetricsQueues>>>,
  TError = ErrorType<
    AuthenticationExceptionResponse | AuthorizationExceptionResponse
  >
>(
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof queueMetricsQueues>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useQueueMetricsQueuesSuspenseInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof queueMetricsQueues>>>,
  TError = ErrorType<
    AuthenticationExceptionResponse | AuthorizationExceptionResponse
  >
>(
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof queueMetricsQueues>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get list of all available queue names
 */

export function useQueueMetricsQueuesSuspenseInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof queueMetricsQueues>>>,
  TError = ErrorType<
    AuthenticationExceptionResponse | AuthorizationExceptionResponse
  >
>(
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof queueMetricsQueues>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions =
    getQueueMetricsQueuesSuspenseInfiniteQueryOptions(options);

  const query = useSuspenseInfiniteQuery(
    queryOptions,
    queryClient
  ) as UseSuspenseInfiniteQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Returns detailed metrics about queue performance including job counts,
execution times, failure rates, and trend analysis over the specified
time period for system monitoring and optimization.
 * @summary Get comprehensive queue metrics and statistics
 */
export const queueMetricsMetrics = (
  params?: QueueMetricsMetricsParams,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal
) => {
  return customInstance<QueueMetricsMetrics200Item[]>(
    { url: `/api/queue-metrics/metrics`, method: "GET", params, signal },
    options
  );
};

export const getQueueMetricsMetricsQueryKey = (
  params?: QueueMetricsMetricsParams
) => {
  return [`/api/queue-metrics/metrics`, ...(params ? [params] : [])] as const;
};

export const getQueueMetricsMetricsInfiniteQueryOptions = <
  TData = InfiniteData<
    Awaited<ReturnType<typeof queueMetricsMetrics>>,
    QueueMetricsMetricsParams["page"]
  >,
  TError = ErrorType<
    | AuthenticationExceptionResponse
    | AuthorizationExceptionResponse
    | ValidationExceptionResponse
  >
>(
  params?: QueueMetricsMetricsParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof queueMetricsMetrics>>,
        TError,
        TData,
        QueryKey,
        QueueMetricsMetricsParams["page"]
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getQueueMetricsMetricsQueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof queueMetricsMetrics>>,
    QueryKey,
    QueueMetricsMetricsParams["page"]
  > = ({ signal, pageParam }) =>
    queueMetricsMetrics(
      { ...params, page: pageParam || params?.["page"] },
      requestOptions,
      signal
    );

  return { queryKey, queryFn, ...queryOptions } as UseInfiniteQueryOptions<
    Awaited<ReturnType<typeof queueMetricsMetrics>>,
    TError,
    TData,
    QueryKey,
    QueueMetricsMetricsParams["page"]
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type QueueMetricsMetricsInfiniteQueryResult = NonNullable<
  Awaited<ReturnType<typeof queueMetricsMetrics>>
>;
export type QueueMetricsMetricsInfiniteQueryError = ErrorType<
  | AuthenticationExceptionResponse
  | AuthorizationExceptionResponse
  | ValidationExceptionResponse
>;

export function useQueueMetricsMetricsInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof queueMetricsMetrics>>,
    QueueMetricsMetricsParams["page"]
  >,
  TError = ErrorType<
    | AuthenticationExceptionResponse
    | AuthorizationExceptionResponse
    | ValidationExceptionResponse
  >
>(
  params: undefined | QueueMetricsMetricsParams,
  options: {
    query: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof queueMetricsMetrics>>,
        TError,
        TData,
        QueryKey,
        QueueMetricsMetricsParams["page"]
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof queueMetricsMetrics>>,
          TError,
          Awaited<ReturnType<typeof queueMetricsMetrics>>,
          QueryKey
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): DefinedUseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useQueueMetricsMetricsInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof queueMetricsMetrics>>,
    QueueMetricsMetricsParams["page"]
  >,
  TError = ErrorType<
    | AuthenticationExceptionResponse
    | AuthorizationExceptionResponse
    | ValidationExceptionResponse
  >
>(
  params?: QueueMetricsMetricsParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof queueMetricsMetrics>>,
        TError,
        TData,
        QueryKey,
        QueueMetricsMetricsParams["page"]
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof queueMetricsMetrics>>,
          TError,
          Awaited<ReturnType<typeof queueMetricsMetrics>>,
          QueryKey
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useQueueMetricsMetricsInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof queueMetricsMetrics>>,
    QueueMetricsMetricsParams["page"]
  >,
  TError = ErrorType<
    | AuthenticationExceptionResponse
    | AuthorizationExceptionResponse
    | ValidationExceptionResponse
  >
>(
  params?: QueueMetricsMetricsParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof queueMetricsMetrics>>,
        TError,
        TData,
        QueryKey,
        QueueMetricsMetricsParams["page"]
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get comprehensive queue metrics and statistics
 */

export function useQueueMetricsMetricsInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof queueMetricsMetrics>>,
    QueueMetricsMetricsParams["page"]
  >,
  TError = ErrorType<
    | AuthenticationExceptionResponse
    | AuthorizationExceptionResponse
    | ValidationExceptionResponse
  >
>(
  params?: QueueMetricsMetricsParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof queueMetricsMetrics>>,
        TError,
        TData,
        QueryKey,
        QueueMetricsMetricsParams["page"]
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getQueueMetricsMetricsInfiniteQueryOptions(
    params,
    options
  );

  const query = useInfiniteQuery(
    queryOptions,
    queryClient
  ) as UseInfiniteQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getQueueMetricsMetricsQueryOptions = <
  TData = Awaited<ReturnType<typeof queueMetricsMetrics>>,
  TError = ErrorType<
    | AuthenticationExceptionResponse
    | AuthorizationExceptionResponse
    | ValidationExceptionResponse
  >
>(
  params?: QueueMetricsMetricsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof queueMetricsMetrics>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getQueueMetricsMetricsQueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof queueMetricsMetrics>>
  > = ({ signal }) => queueMetricsMetrics(params, requestOptions, signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof queueMetricsMetrics>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type QueueMetricsMetricsQueryResult = NonNullable<
  Awaited<ReturnType<typeof queueMetricsMetrics>>
>;
export type QueueMetricsMetricsQueryError = ErrorType<
  | AuthenticationExceptionResponse
  | AuthorizationExceptionResponse
  | ValidationExceptionResponse
>;

export function useQueueMetricsMetrics<
  TData = Awaited<ReturnType<typeof queueMetricsMetrics>>,
  TError = ErrorType<
    | AuthenticationExceptionResponse
    | AuthorizationExceptionResponse
    | ValidationExceptionResponse
  >
>(
  params: undefined | QueueMetricsMetricsParams,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof queueMetricsMetrics>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof queueMetricsMetrics>>,
          TError,
          Awaited<ReturnType<typeof queueMetricsMetrics>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useQueueMetricsMetrics<
  TData = Awaited<ReturnType<typeof queueMetricsMetrics>>,
  TError = ErrorType<
    | AuthenticationExceptionResponse
    | AuthorizationExceptionResponse
    | ValidationExceptionResponse
  >
>(
  params?: QueueMetricsMetricsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof queueMetricsMetrics>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof queueMetricsMetrics>>,
          TError,
          Awaited<ReturnType<typeof queueMetricsMetrics>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useQueueMetricsMetrics<
  TData = Awaited<ReturnType<typeof queueMetricsMetrics>>,
  TError = ErrorType<
    | AuthenticationExceptionResponse
    | AuthorizationExceptionResponse
    | ValidationExceptionResponse
  >
>(
  params?: QueueMetricsMetricsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof queueMetricsMetrics>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get comprehensive queue metrics and statistics
 */

export function useQueueMetricsMetrics<
  TData = Awaited<ReturnType<typeof queueMetricsMetrics>>,
  TError = ErrorType<
    | AuthenticationExceptionResponse
    | AuthorizationExceptionResponse
    | ValidationExceptionResponse
  >
>(
  params?: QueueMetricsMetricsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof queueMetricsMetrics>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getQueueMetricsMetricsQueryOptions(params, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getQueueMetricsMetricsSuspenseQueryOptions = <
  TData = Awaited<ReturnType<typeof queueMetricsMetrics>>,
  TError = ErrorType<
    | AuthenticationExceptionResponse
    | AuthorizationExceptionResponse
    | ValidationExceptionResponse
  >
>(
  params?: QueueMetricsMetricsParams,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof queueMetricsMetrics>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getQueueMetricsMetricsQueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof queueMetricsMetrics>>
  > = ({ signal }) => queueMetricsMetrics(params, requestOptions, signal);

  return { queryKey, queryFn, ...queryOptions } as UseSuspenseQueryOptions<
    Awaited<ReturnType<typeof queueMetricsMetrics>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type QueueMetricsMetricsSuspenseQueryResult = NonNullable<
  Awaited<ReturnType<typeof queueMetricsMetrics>>
>;
export type QueueMetricsMetricsSuspenseQueryError = ErrorType<
  | AuthenticationExceptionResponse
  | AuthorizationExceptionResponse
  | ValidationExceptionResponse
>;

export function useQueueMetricsMetricsSuspense<
  TData = Awaited<ReturnType<typeof queueMetricsMetrics>>,
  TError = ErrorType<
    | AuthenticationExceptionResponse
    | AuthorizationExceptionResponse
    | ValidationExceptionResponse
  >
>(
  params: undefined | QueueMetricsMetricsParams,
  options: {
    query: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof queueMetricsMetrics>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useQueueMetricsMetricsSuspense<
  TData = Awaited<ReturnType<typeof queueMetricsMetrics>>,
  TError = ErrorType<
    | AuthenticationExceptionResponse
    | AuthorizationExceptionResponse
    | ValidationExceptionResponse
  >
>(
  params?: QueueMetricsMetricsParams,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof queueMetricsMetrics>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useQueueMetricsMetricsSuspense<
  TData = Awaited<ReturnType<typeof queueMetricsMetrics>>,
  TError = ErrorType<
    | AuthenticationExceptionResponse
    | AuthorizationExceptionResponse
    | ValidationExceptionResponse
  >
>(
  params?: QueueMetricsMetricsParams,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof queueMetricsMetrics>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get comprehensive queue metrics and statistics
 */

export function useQueueMetricsMetricsSuspense<
  TData = Awaited<ReturnType<typeof queueMetricsMetrics>>,
  TError = ErrorType<
    | AuthenticationExceptionResponse
    | AuthorizationExceptionResponse
    | ValidationExceptionResponse
  >
>(
  params?: QueueMetricsMetricsParams,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof queueMetricsMetrics>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getQueueMetricsMetricsSuspenseQueryOptions(
    params,
    options
  );

  const query = useSuspenseQuery(
    queryOptions,
    queryClient
  ) as UseSuspenseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getQueueMetricsMetricsSuspenseInfiniteQueryOptions = <
  TData = InfiniteData<
    Awaited<ReturnType<typeof queueMetricsMetrics>>,
    QueueMetricsMetricsParams["page"]
  >,
  TError = ErrorType<
    | AuthenticationExceptionResponse
    | AuthorizationExceptionResponse
    | ValidationExceptionResponse
  >
>(
  params?: QueueMetricsMetricsParams,
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof queueMetricsMetrics>>,
        TError,
        TData,
        QueryKey,
        QueueMetricsMetricsParams["page"]
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getQueueMetricsMetricsQueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof queueMetricsMetrics>>,
    QueryKey,
    QueueMetricsMetricsParams["page"]
  > = ({ signal, pageParam }) =>
    queueMetricsMetrics(
      { ...params, page: pageParam || params?.["page"] },
      requestOptions,
      signal
    );

  return {
    queryKey,
    queryFn,
    ...queryOptions,
  } as UseSuspenseInfiniteQueryOptions<
    Awaited<ReturnType<typeof queueMetricsMetrics>>,
    TError,
    TData,
    QueryKey,
    QueueMetricsMetricsParams["page"]
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type QueueMetricsMetricsSuspenseInfiniteQueryResult = NonNullable<
  Awaited<ReturnType<typeof queueMetricsMetrics>>
>;
export type QueueMetricsMetricsSuspenseInfiniteQueryError = ErrorType<
  | AuthenticationExceptionResponse
  | AuthorizationExceptionResponse
  | ValidationExceptionResponse
>;

export function useQueueMetricsMetricsSuspenseInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof queueMetricsMetrics>>,
    QueueMetricsMetricsParams["page"]
  >,
  TError = ErrorType<
    | AuthenticationExceptionResponse
    | AuthorizationExceptionResponse
    | ValidationExceptionResponse
  >
>(
  params: undefined | QueueMetricsMetricsParams,
  options: {
    query: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof queueMetricsMetrics>>,
        TError,
        TData,
        QueryKey,
        QueueMetricsMetricsParams["page"]
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useQueueMetricsMetricsSuspenseInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof queueMetricsMetrics>>,
    QueueMetricsMetricsParams["page"]
  >,
  TError = ErrorType<
    | AuthenticationExceptionResponse
    | AuthorizationExceptionResponse
    | ValidationExceptionResponse
  >
>(
  params?: QueueMetricsMetricsParams,
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof queueMetricsMetrics>>,
        TError,
        TData,
        QueryKey,
        QueueMetricsMetricsParams["page"]
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useQueueMetricsMetricsSuspenseInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof queueMetricsMetrics>>,
    QueueMetricsMetricsParams["page"]
  >,
  TError = ErrorType<
    | AuthenticationExceptionResponse
    | AuthorizationExceptionResponse
    | ValidationExceptionResponse
  >
>(
  params?: QueueMetricsMetricsParams,
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof queueMetricsMetrics>>,
        TError,
        TData,
        QueryKey,
        QueueMetricsMetricsParams["page"]
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get comprehensive queue metrics and statistics
 */

export function useQueueMetricsMetricsSuspenseInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof queueMetricsMetrics>>,
    QueueMetricsMetricsParams["page"]
  >,
  TError = ErrorType<
    | AuthenticationExceptionResponse
    | AuthorizationExceptionResponse
    | ValidationExceptionResponse
  >
>(
  params?: QueueMetricsMetricsParams,
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof queueMetricsMetrics>>,
        TError,
        TData,
        QueryKey,
        QueueMetricsMetricsParams["page"]
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getQueueMetricsMetricsSuspenseInfiniteQueryOptions(
    params,
    options
  );

  const query = useSuspenseInfiniteQuery(
    queryOptions,
    queryClient
  ) as UseSuspenseInfiniteQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Attempts to retry a previously failed job by re-dispatching it to the queue.
Only failed jobs that haven't been retried and have valid job UUIDs can be retried.
Includes safety checks and error handling.
 * @summary Retry a failed queue job
 */
export const queueMetricsRetryJob = (
  id: string,
  retryJobRequest: BodyType<RetryJobRequest>,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal
) => {
  return customInstance<QueueMetricsRetryJob200>(
    {
      url: `/api/queue-metrics/retry/${id}`,
      method: "POST",
      headers: { "Content-Type": "application/json" },
      data: retryJobRequest,
      signal,
    },
    options
  );
};

export const getQueueMetricsRetryJobMutationOptions = <
  TError = ErrorType<
    | QueueMetricsRetryJob400
    | AuthenticationExceptionResponse
    | AuthorizationExceptionResponse
    | ModelNotFoundExceptionResponse
    | ValidationExceptionResponse
  >,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof queueMetricsRetryJob>>,
    TError,
    { id: string; data: BodyType<RetryJobRequest> },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof queueMetricsRetryJob>>,
  TError,
  { id: string; data: BodyType<RetryJobRequest> },
  TContext
> => {
  const mutationKey = ["queueMetricsRetryJob"];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof queueMetricsRetryJob>>,
    { id: string; data: BodyType<RetryJobRequest> }
  > = (props) => {
    const { id, data } = props ?? {};

    return queueMetricsRetryJob(id, data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type QueueMetricsRetryJobMutationResult = NonNullable<
  Awaited<ReturnType<typeof queueMetricsRetryJob>>
>;
export type QueueMetricsRetryJobMutationBody = BodyType<RetryJobRequest>;
export type QueueMetricsRetryJobMutationError = ErrorType<
  | QueueMetricsRetryJob400
  | AuthenticationExceptionResponse
  | AuthorizationExceptionResponse
  | ModelNotFoundExceptionResponse
  | ValidationExceptionResponse
>;

/**
 * @summary Retry a failed queue job
 */
export const useQueueMetricsRetryJob = <
  TError = ErrorType<
    | QueueMetricsRetryJob400
    | AuthenticationExceptionResponse
    | AuthorizationExceptionResponse
    | ModelNotFoundExceptionResponse
    | ValidationExceptionResponse
  >,
  TContext = unknown
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof queueMetricsRetryJob>>,
      TError,
      { id: string; data: BodyType<RetryJobRequest> },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof queueMetricsRetryJob>>,
  TError,
  { id: string; data: BodyType<RetryJobRequest> },
  TContext
> => {
  const mutationOptions = getQueueMetricsRetryJobMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
/**
 * Permanently removes a queue monitor record from the system.
This only affects monitoring data and does not impact actual queue jobs.
Used for cleaning up monitoring history.
 * @summary Delete a specific queue monitor entry
 */
export const queueMetricsDelete = (
  id: string,
  options?: SecondParameter<typeof customInstance>
) => {
  return customInstance<string>(
    { url: `/api/queue-metrics/${id}`, method: "DELETE" },
    options
  );
};

export const getQueueMetricsDeleteMutationOptions = <
  TError = ErrorType<
    | AuthenticationExceptionResponse
    | AuthorizationExceptionResponse
    | ModelNotFoundExceptionResponse
  >,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof queueMetricsDelete>>,
    TError,
    { id: string },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof queueMetricsDelete>>,
  TError,
  { id: string },
  TContext
> => {
  const mutationKey = ["queueMetricsDelete"];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof queueMetricsDelete>>,
    { id: string }
  > = (props) => {
    const { id } = props ?? {};

    return queueMetricsDelete(id, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type QueueMetricsDeleteMutationResult = NonNullable<
  Awaited<ReturnType<typeof queueMetricsDelete>>
>;

export type QueueMetricsDeleteMutationError = ErrorType<
  | AuthenticationExceptionResponse
  | AuthorizationExceptionResponse
  | ModelNotFoundExceptionResponse
>;

/**
 * @summary Delete a specific queue monitor entry
 */
export const useQueueMetricsDelete = <
  TError = ErrorType<
    | AuthenticationExceptionResponse
    | AuthorizationExceptionResponse
    | ModelNotFoundExceptionResponse
  >,
  TContext = unknown
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof queueMetricsDelete>>,
      TError,
      { id: string },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof queueMetricsDelete>>,
  TError,
  { id: string },
  TContext
> => {
  const mutationOptions = getQueueMetricsDeleteMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
/**
 * Completely clears all queue monitoring data from the system.
This is a destructive operation that removes all historical job tracking
information. Use with extreme caution in production environments.
 * @summary Purge all queue monitor records
 */
export const queueMetricsPurge = (
  options?: SecondParameter<typeof customInstance>
) => {
  return customInstance<null>(
    { url: `/api/queue-metrics/purge`, method: "DELETE" },
    options
  );
};

export const getQueueMetricsPurgeMutationOptions = <
  TError = ErrorType<
    AuthenticationExceptionResponse | AuthorizationExceptionResponse
  >,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof queueMetricsPurge>>,
    TError,
    void,
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof queueMetricsPurge>>,
  TError,
  void,
  TContext
> => {
  const mutationKey = ["queueMetricsPurge"];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof queueMetricsPurge>>,
    void
  > = () => {
    return queueMetricsPurge(requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type QueueMetricsPurgeMutationResult = NonNullable<
  Awaited<ReturnType<typeof queueMetricsPurge>>
>;

export type QueueMetricsPurgeMutationError = ErrorType<
  AuthenticationExceptionResponse | AuthorizationExceptionResponse
>;

/**
 * @summary Purge all queue monitor records
 */
export const useQueueMetricsPurge = <
  TError = ErrorType<
    AuthenticationExceptionResponse | AuthorizationExceptionResponse
  >,
  TContext = unknown
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof queueMetricsPurge>>,
      TError,
      void,
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof queueMetricsPurge>>,
  TError,
  void,
  TContext
> => {
  const mutationOptions = getQueueMetricsPurgeMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
