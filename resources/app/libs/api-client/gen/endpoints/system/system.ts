/**
 * Generated by orval v7.17.2 üç∫
 * Do not edit manually.
 * B√•nder api docs
 * B√•nder.App is a sophisticated media server developed with the primary goal to deliver high performance and seamless experience for users.
Being built on top of Laravel framework and PostgreSQL for database, it leverages the power of robust backend technologies, providing high security, reliability, and scalability.

The main focus of B√•nder.App is efficient media management and delivery.
This application is designed to handle large amounts of media files while ensuring quick and efficient access.
Implemented queuing functionality through Redis offers efficient job management and load handling.
The media information is organized and easily searchable, ensuring users can always find what they are looking for quickly and easily.
 * OpenAPI spec version: 0.0.1
 */
import {
  useInfiniteQuery,
  useMutation,
  useQuery,
  useSuspenseInfiniteQuery,
  useSuspenseQuery,
} from "@tanstack/react-query";
import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseInfiniteQueryResult,
  DefinedUseQueryResult,
  InfiniteData,
  MutationFunction,
  QueryClient,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseInfiniteQueryOptions,
  UseInfiniteQueryResult,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult,
  UseSuspenseInfiniteQueryOptions,
  UseSuspenseInfiniteQueryResult,
  UseSuspenseQueryOptions,
  UseSuspenseQueryResult,
} from "@tanstack/react-query";

import type {
  AuthenticationExceptionResponse,
  AuthorizationExceptionResponse,
  JobCleanup200,
  JobCleanupBody,
  JobFailedCleanup200,
  JobFailedCleanupBody,
  JobLibraryScan200,
  JobLock200,
  JobLockDelete200,
  JobLocks200Item,
  LogFile,
  LogsContent200,
  LogsContentParams,
  LogsDownload200,
  LogsHead200,
  LogsHeadParams,
  LogsLines200,
  LogsSearch200,
  LogsSearchAll200,
  LogsSearchAllParams,
  LogsSearchParams,
  LogsShow200,
  LogsStats200,
  LogsTail200,
  LogsTailParams,
  ModelNotFoundExceptionResponse,
  OpCacheGetStatus200,
  OpcacheClear200,
  OpcacheCompile200,
  OpcacheCompileParams,
  OpcacheGetConfig200,
  QueueMetricsMetrics200Item,
  QueueMetricsMetricsParams,
  QueueMetricsQueues200Item,
  QueueMetricsRetryJob200,
  QueueMetricsRetryJob400,
  QueueMetricsShow200,
  QueueMetricsShowParams,
  RetryJobRequest,
  SystemInfoPhp200Item,
  SystemInfoSys200,
  ValidationExceptionResponse,
} from "../../models";

import { customInstance } from "../../../axios-instance";
import type { ErrorType, BodyType } from "../../../axios-instance";

type SecondParameter<T extends (...args: never) => unknown> = Parameters<T>[1];

/**
 * Returns information about active job locks including TTL, age, and status.
Used for monitoring job execution and identifying stuck or long-running jobs.
 * @summary Get all job locks for a specific job type
 */
export const jobLocks = (
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal
) => {
  return customInstance<JobLocks200Item[]>(
    { url: `/api/jobs/locks`, method: "GET", signal },
    options
  );
};

export const getJobLocksInfiniteQueryKey = () => {
  return ["infinite", `/api/jobs/locks`] as const;
};

export const getJobLocksQueryKey = () => {
  return [`/api/jobs/locks`] as const;
};

export const getJobLocksInfiniteQueryOptions = <
  TData = InfiniteData<JobLock200>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(options?: {
  query?: Partial<
    UseInfiniteQueryOptions<JobLock200, TError, TData>
  >;
  request?: SecondParameter<typeof customInstance>;
}) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getJobLocksInfiniteQueryKey();

  const queryFn: QueryFunction<JobLock200> = ({
    signal,
  }) => jobLocks(requestOptions, signal);

  return { queryKey, queryFn, ...queryOptions } as UseInfiniteQueryOptions<
    JobLock200,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type JobLocksInfiniteQueryResult = NonNullable<
  JobLock200
>;
export type JobLocksInfiniteQueryError =
  ErrorType<AuthenticationExceptionResponse>;

export function useJobLocksInfinite<
  TData = InfiniteData<JobLock200>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(
  options: {
    query: Partial<
      UseInfiniteQueryOptions<
        JobLock200,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          JobLock200,
          TError,
          JobLock200
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): DefinedUseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useJobLocksInfinite<
  TData = InfiniteData<JobLock200>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        JobLock200,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          JobLock200,
          TError,
          JobLock200
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useJobLocksInfinite<
  TData = InfiniteData<JobLock200>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        JobLock200,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get all job locks for a specific job type
 */

export function useJobLocksInfinite<
  TData = InfiniteData<JobLock200>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        JobLock200,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getJobLocksInfiniteQueryOptions(options);

  const query = useInfiniteQuery(
    queryOptions,
    queryClient
  ) as UseInfiniteQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getJobLocksQueryOptions = <
  TData = JobLock200,
  TError = ErrorType<AuthenticationExceptionResponse>
>(options?: {
  query?: Partial<
    UseQueryOptions<JobLock200, TError, TData>
  >;
  request?: SecondParameter<typeof customInstance>;
}) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getJobLocksQueryKey();

  const queryFn: QueryFunction<JobLock200> = ({
    signal,
  }) => jobLocks(requestOptions, signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    JobLock200,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type JobLocksQueryResult = NonNullable<
  JobLock200
>;
export type JobLocksQueryError = ErrorType<AuthenticationExceptionResponse>;

export function useJobLocks<
  TData = JobLock200,
  TError = ErrorType<AuthenticationExceptionResponse>
>(
  options: {
    query: Partial<
      UseQueryOptions<JobLock200, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          JobLock200,
          TError,
          JobLock200
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useJobLocks<
  TData = JobLock200,
  TError = ErrorType<AuthenticationExceptionResponse>
>(
  options?: {
    query?: Partial<
      UseQueryOptions<JobLock200, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          JobLock200,
          TError,
          JobLock200
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useJobLocks<
  TData = JobLock200,
  TError = ErrorType<AuthenticationExceptionResponse>
>(
  options?: {
    query?: Partial<
      UseQueryOptions<JobLock200, TError, TData>
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get all job locks for a specific job type
 */

export function useJobLocks<
  TData = JobLock200,
  TError = ErrorType<AuthenticationExceptionResponse>
>(
  options?: {
    query?: Partial<
      UseQueryOptions<JobLock200, TError, TData>
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getJobLocksQueryOptions(options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getJobLocksSuspenseQueryOptions = <
  TData = JobLock200,
  TError = ErrorType<AuthenticationExceptionResponse>
>(options?: {
  query?: Partial<
    UseSuspenseQueryOptions<JobLock200, TError, TData>
  >;
  request?: SecondParameter<typeof customInstance>;
}) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getJobLocksQueryKey();

  const queryFn: QueryFunction<JobLock200> = ({
    signal,
  }) => jobLocks(requestOptions, signal);

  return { queryKey, queryFn, ...queryOptions } as UseSuspenseQueryOptions<
    JobLock200,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type JobLocksSuspenseQueryResult = NonNullable<
  JobLock200
>;
export type JobLocksSuspenseQueryError =
  ErrorType<AuthenticationExceptionResponse>;

export function useJobLocksSuspense<
  TData = JobLock200,
  TError = ErrorType<AuthenticationExceptionResponse>
>(
  options: {
    query: Partial<
      UseSuspenseQueryOptions<
        JobLock200,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useJobLocksSuspense<
  TData = JobLock200,
  TError = ErrorType<AuthenticationExceptionResponse>
>(
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        JobLock200,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useJobLocksSuspense<
  TData = JobLock200,
  TError = ErrorType<AuthenticationExceptionResponse>
>(
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        JobLock200,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get all job locks for a specific job type
 */

export function useJobLocksSuspense<
  TData = JobLock200,
  TError = ErrorType<AuthenticationExceptionResponse>
>(
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        JobLock200,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getJobLocksSuspenseQueryOptions(options);

  const query = useSuspenseQuery(
    queryOptions,
    queryClient
  ) as UseSuspenseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getJobLocksSuspenseInfiniteQueryOptions = <
  TData = InfiniteData<JobLock200>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(options?: {
  query?: Partial<
    UseSuspenseInfiniteQueryOptions<
      JobLock200,
      TError,
      TData
    >
  >;
  request?: SecondParameter<typeof customInstance>;
}) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getJobLocksInfiniteQueryKey();

  const queryFn: QueryFunction<JobLock200> = ({
    signal,
  }) => jobLocks(requestOptions, signal);

  return {
    queryKey,
    queryFn,
    ...queryOptions,
  } as UseSuspenseInfiniteQueryOptions<
    JobLock200,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type JobLocksSuspenseInfiniteQueryResult = NonNullable<
  JobLock200
>;
export type JobLocksSuspenseInfiniteQueryError =
  ErrorType<AuthenticationExceptionResponse>;

export function useJobLocksSuspenseInfinite<
  TData = InfiniteData<JobLock200>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(
  options: {
    query: Partial<
      UseSuspenseInfiniteQueryOptions<
        JobLock200,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useJobLocksSuspenseInfinite<
  TData = InfiniteData<JobLock200>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        JobLock200,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useJobLocksSuspenseInfinite<
  TData = InfiniteData<JobLock200>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        JobLock200,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get all job locks for a specific job type
 */

export function useJobLocksSuspenseInfinite<
  TData = InfiniteData<JobLock200>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        JobLock200,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getJobLocksSuspenseInfiniteQueryOptions(options);

  const query = useSuspenseInfiniteQuery(
    queryOptions,
    queryClient
  ) as UseSuspenseInfiniteQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Retrieves detailed information about a specific job lock including
its current state, time-to-live, and age for debugging purposes.
 * @summary Get specific job lock information
 */
export const jobLock = (
  jobClass: string,
  jobId: string,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal
) => {
  return customInstance<JobLock200>(
    { url: `/api/jobs/locks/${jobClass}/lock/${jobId}`, method: "GET", signal },
    options
  );
};

export const getJobLockInfiniteQueryKey = (
  jobClass?: string,
  jobId?: string
) => {
  return ["infinite", `/api/jobs/locks/${jobClass}/lock/${jobId}`] as const;
};

export const getJobLockQueryKey = (jobClass?: string, jobId?: string) => {
  return [`/api/jobs/locks/${jobClass}/lock/${jobId}`] as const;
};

export const getJobLockInfiniteQueryOptions = <
  TData = InfiniteData<Awaited<ReturnType<typeof jobLock>>>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(
  jobClass: string,
  jobId: string,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof jobLock>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getJobLockInfiniteQueryKey(jobClass, jobId);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof jobLock>>> = ({
    signal,
  }) => jobLock(jobClass, jobId, requestOptions, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!(jobClass && jobId),
    ...queryOptions,
  } as UseInfiniteQueryOptions<
    Awaited<ReturnType<typeof jobLock>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type JobLockInfiniteQueryResult = NonNullable<
  Awaited<ReturnType<typeof jobLock>>
>;
export type JobLockInfiniteQueryError =
  ErrorType<AuthenticationExceptionResponse>;

export function useJobLockInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof jobLock>>>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(
  jobClass: string,
  jobId: string,
  options: {
    query: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof jobLock>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof jobLock>>,
          TError,
          Awaited<ReturnType<typeof jobLock>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): DefinedUseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useJobLockInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof jobLock>>>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(
  jobClass: string,
  jobId: string,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof jobLock>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof jobLock>>,
          TError,
          Awaited<ReturnType<typeof jobLock>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useJobLockInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof jobLock>>>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(
  jobClass: string,
  jobId: string,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof jobLock>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get specific job lock information
 */

export function useJobLockInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof jobLock>>>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(
  jobClass: string,
  jobId: string,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof jobLock>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getJobLockInfiniteQueryOptions(jobClass, jobId, options);

  const query = useInfiniteQuery(
    queryOptions,
    queryClient
  ) as UseInfiniteQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getJobLockQueryOptions = <
  TData = Awaited<ReturnType<typeof jobLock>>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(
  jobClass: string,
  jobId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof jobLock>>, TError, TData>
    >;
    request?: SecondParameter<typeof customInstance>;
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getJobLockQueryKey(jobClass, jobId);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof jobLock>>> = ({
    signal,
  }) => jobLock(jobClass, jobId, requestOptions, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!(jobClass && jobId),
    ...queryOptions,
  } as UseQueryOptions<Awaited<ReturnType<typeof jobLock>>, TError, TData> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };
};

export type JobLockQueryResult = NonNullable<
  Awaited<ReturnType<typeof jobLock>>
>;
export type JobLockQueryError = ErrorType<AuthenticationExceptionResponse>;

export function useJobLock<
  TData = Awaited<ReturnType<typeof jobLock>>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(
  jobClass: string,
  jobId: string,
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof jobLock>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof jobLock>>,
          TError,
          Awaited<ReturnType<typeof jobLock>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useJobLock<
  TData = Awaited<ReturnType<typeof jobLock>>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(
  jobClass: string,
  jobId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof jobLock>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof jobLock>>,
          TError,
          Awaited<ReturnType<typeof jobLock>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useJobLock<
  TData = Awaited<ReturnType<typeof jobLock>>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(
  jobClass: string,
  jobId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof jobLock>>, TError, TData>
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get specific job lock information
 */

export function useJobLock<
  TData = Awaited<ReturnType<typeof jobLock>>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(
  jobClass: string,
  jobId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof jobLock>>, TError, TData>
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getJobLockQueryOptions(jobClass, jobId, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getJobLockSuspenseQueryOptions = <
  TData = Awaited<ReturnType<typeof jobLock>>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(
  jobClass: string,
  jobId: string,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof jobLock>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getJobLockQueryKey(jobClass, jobId);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof jobLock>>> = ({
    signal,
  }) => jobLock(jobClass, jobId, requestOptions, signal);

  return { queryKey, queryFn, ...queryOptions } as UseSuspenseQueryOptions<
    Awaited<ReturnType<typeof jobLock>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type JobLockSuspenseQueryResult = NonNullable<
  Awaited<ReturnType<typeof jobLock>>
>;
export type JobLockSuspenseQueryError =
  ErrorType<AuthenticationExceptionResponse>;

export function useJobLockSuspense<
  TData = Awaited<ReturnType<typeof jobLock>>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(
  jobClass: string,
  jobId: string,
  options: {
    query: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof jobLock>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useJobLockSuspense<
  TData = Awaited<ReturnType<typeof jobLock>>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(
  jobClass: string,
  jobId: string,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof jobLock>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useJobLockSuspense<
  TData = Awaited<ReturnType<typeof jobLock>>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(
  jobClass: string,
  jobId: string,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof jobLock>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get specific job lock information
 */

export function useJobLockSuspense<
  TData = Awaited<ReturnType<typeof jobLock>>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(
  jobClass: string,
  jobId: string,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof jobLock>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getJobLockSuspenseQueryOptions(jobClass, jobId, options);

  const query = useSuspenseQuery(
    queryOptions,
    queryClient
  ) as UseSuspenseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getJobLockSuspenseInfiniteQueryOptions = <
  TData = InfiniteData<Awaited<ReturnType<typeof jobLock>>>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(
  jobClass: string,
  jobId: string,
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof jobLock>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getJobLockInfiniteQueryKey(jobClass, jobId);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof jobLock>>> = ({
    signal,
  }) => jobLock(jobClass, jobId, requestOptions, signal);

  return {
    queryKey,
    queryFn,
    ...queryOptions,
  } as UseSuspenseInfiniteQueryOptions<
    Awaited<ReturnType<typeof jobLock>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type JobLockSuspenseInfiniteQueryResult = NonNullable<
  Awaited<ReturnType<typeof jobLock>>
>;
export type JobLockSuspenseInfiniteQueryError =
  ErrorType<AuthenticationExceptionResponse>;

export function useJobLockSuspenseInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof jobLock>>>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(
  jobClass: string,
  jobId: string,
  options: {
    query: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof jobLock>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useJobLockSuspenseInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof jobLock>>>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(
  jobClass: string,
  jobId: string,
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof jobLock>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useJobLockSuspenseInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof jobLock>>>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(
  jobClass: string,
  jobId: string,
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof jobLock>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get specific job lock information
 */

export function useJobLockSuspenseInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof jobLock>>>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(
  jobClass: string,
  jobId: string,
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof jobLock>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getJobLockSuspenseInfiniteQueryOptions(
    jobClass,
    jobId,
    options
  );

  const query = useSuspenseInfiniteQuery(
    queryOptions,
    queryClient
  ) as UseSuspenseInfiniteQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Manually removes a job lock, typically used to clear stuck jobs that
are preventing new instances from running. Use with caution as this
can interfere with actively running jobs.
 * @summary Force remove a specific job lock
 */
export const jobLockDelete = (
  jobClass: string,
  jobId: string,
  options?: SecondParameter<typeof customInstance>
) => {
  return customInstance<JobLockDelete200>(
    { url: `/api/jobs/locks/${jobClass}/lock/${jobId}`, method: "DELETE" },
    options
  );
};

export const getJobLockDeleteMutationOptions = <
  TError = ErrorType<AuthenticationExceptionResponse>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof jobLockDelete>>,
    TError,
    { jobClass: string; jobId: string },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof jobLockDelete>>,
  TError,
  { jobClass: string; jobId: string },
  TContext
> => {
  const mutationKey = ["jobLockDelete"];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof jobLockDelete>>,
    { jobClass: string; jobId: string }
  > = (props) => {
    const { jobClass, jobId } = props ?? {};

    return jobLockDelete(jobClass, jobId, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type JobLockDeleteMutationResult = NonNullable<
  Awaited<ReturnType<typeof jobLockDelete>>
>;

export type JobLockDeleteMutationError =
  ErrorType<AuthenticationExceptionResponse>;

/**
 * @summary Force remove a specific job lock
 */
export const useJobLockDelete = <
  TError = ErrorType<AuthenticationExceptionResponse>,
  TContext = unknown
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof jobLockDelete>>,
      TError,
      { jobClass: string; jobId: string },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof jobLockDelete>>,
  TError,
  { jobClass: string; jobId: string },
  TContext
> => {
  const mutationOptions = getJobLockDeleteMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
/**
 * Analyzes the job system for stuck locks and failed jobs, providing a summary
of issues found. Can perform actual cleanup when dry_run is set to false.
 * @summary Get job cleanup summary and optionally perform cleanup
 */
export const jobCleanup = (
  jobCleanupBody: BodyType<JobCleanupBody>,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal
) => {
  return customInstance<JobCleanup200>(
    {
      url: `/api/jobs/cleanup`,
      method: "POST",
      headers: { "Content-Type": "application/json" },
      data: jobCleanupBody,
      signal,
    },
    options
  );
};

export const getJobCleanupMutationOptions = <
  TError = ErrorType<AuthenticationExceptionResponse>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof jobCleanup>>,
    TError,
    { data: BodyType<JobCleanupBody> },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof jobCleanup>>,
  TError,
  { data: BodyType<JobCleanupBody> },
  TContext
> => {
  const mutationKey = ["jobCleanup"];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof jobCleanup>>,
    { data: BodyType<JobCleanupBody> }
  > = (props) => {
    const { data } = props ?? {};

    return jobCleanup(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type JobCleanupMutationResult = NonNullable<
  Awaited<ReturnType<typeof jobCleanup>>
>;
export type JobCleanupMutationBody = BodyType<JobCleanupBody>;
export type JobCleanupMutationError =
  ErrorType<AuthenticationExceptionResponse>;

/**
 * @summary Get job cleanup summary and optionally perform cleanup
 */
export const useJobCleanup = <
  TError = ErrorType<AuthenticationExceptionResponse>,
  TContext = unknown
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof jobCleanup>>,
      TError,
      { data: BodyType<JobCleanupBody> },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof jobCleanup>>,
  TError,
  { data: BodyType<JobCleanupBody> },
  TContext
> => {
  const mutationOptions = getJobCleanupMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
/**
 * Removes failed jobs older than the specified time threshold from the
failed jobs table. Helps maintain system performance and storage efficiency.
 * @summary Clear failed jobs from the queue
 */
export const jobFailedCleanup = (
  jobFailedCleanupBody: BodyType<JobFailedCleanupBody>,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal
) => {
  return customInstance<JobFailedCleanup200>(
    {
      url: `/api/jobs/failed`,
      method: "POST",
      headers: { "Content-Type": "application/json" },
      data: jobFailedCleanupBody,
      signal,
    },
    options
  );
};

export const getJobFailedCleanupMutationOptions = <
  TError = ErrorType<AuthenticationExceptionResponse>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof jobFailedCleanup>>,
    TError,
    { data: BodyType<JobFailedCleanupBody> },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof jobFailedCleanup>>,
  TError,
  { data: BodyType<JobFailedCleanupBody> },
  TContext
> => {
  const mutationKey = ["jobFailedCleanup"];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof jobFailedCleanup>>,
    { data: BodyType<JobFailedCleanupBody> }
  > = (props) => {
    const { data } = props ?? {};

    return jobFailedCleanup(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type JobFailedCleanupMutationResult = NonNullable<
  Awaited<ReturnType<typeof jobFailedCleanup>>
>;
export type JobFailedCleanupMutationBody = BodyType<JobFailedCleanupBody>;
export type JobFailedCleanupMutationError =
  ErrorType<AuthenticationExceptionResponse>;

/**
 * @summary Clear failed jobs from the queue
 */
export const useJobFailedCleanup = <
  TError = ErrorType<AuthenticationExceptionResponse>,
  TContext = unknown
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof jobFailedCleanup>>,
      TError,
      { data: BodyType<JobFailedCleanupBody> },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof jobFailedCleanup>>,
  TError,
  { data: BodyType<JobFailedCleanupBody> },
  TContext
> => {
  const mutationOptions = getJobFailedCleanupMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
/**
 * Dispatches a background job to scan a library for new media content.
The job type (music or movie) is automatically determined by the library type.
 * @summary Start a library scanning job
 */
export const jobLibraryScan = (
  slug: string,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal
) => {
  return customInstance<JobLibraryScan200>(
    { url: `/api/jobs/scanLibrary/${slug}`, method: "POST", signal },
    options
  );
};

export const getJobLibraryScanMutationOptions = <
  TError = ErrorType<
    AuthenticationExceptionResponse | AuthorizationExceptionResponse
  >,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof jobLibraryScan>>,
    TError,
    { slug: string },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof jobLibraryScan>>,
  TError,
  { slug: string },
  TContext
> => {
  const mutationKey = ["jobLibraryScan"];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof jobLibraryScan>>,
    { slug: string }
  > = (props) => {
    const { slug } = props ?? {};

    return jobLibraryScan(slug, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type JobLibraryScanMutationResult = NonNullable<
  Awaited<ReturnType<typeof jobLibraryScan>>
>;

export type JobLibraryScanMutationError = ErrorType<
  AuthenticationExceptionResponse | AuthorizationExceptionResponse
>;

/**
 * @summary Start a library scanning job
 */
export const useJobLibraryScan = <
  TError = ErrorType<
    AuthenticationExceptionResponse | AuthorizationExceptionResponse
  >,
  TContext = unknown
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof jobLibraryScan>>,
      TError,
      { slug: string },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof jobLibraryScan>>,
  TError,
  { slug: string },
  TContext
> => {
  const mutationOptions = getJobLibraryScanMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
/**
 * Returns a sorted list of all available log files in the system
with metadata including file sizes, modification dates, and identifiers.
 * @summary Get a collection of available log files
 */
export const logsIndex = (
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal
) => {
  return customInstance<LogFile[]>(
    { url: `/api/logs`, method: "GET", signal },
    options
  );
};

export const getLogsIndexInfiniteQueryKey = () => {
  return ["infinite", `/api/logs`] as const;
};

export const getLogsIndexQueryKey = () => {
  return [`/api/logs`] as const;
};

export const getLogsIndexInfiniteQueryOptions = <
  TData = InfiniteData<Awaited<ReturnType<typeof logsIndex>>>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(options?: {
  query?: Partial<
    UseInfiniteQueryOptions<
      Awaited<ReturnType<typeof logsIndex>>,
      TError,
      TData
    >
  >;
  request?: SecondParameter<typeof customInstance>;
}) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getLogsIndexInfiniteQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof logsIndex>>> = ({
    signal,
  }) => logsIndex(requestOptions, signal);

  return { queryKey, queryFn, ...queryOptions } as UseInfiniteQueryOptions<
    Awaited<ReturnType<typeof logsIndex>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type LogsIndexInfiniteQueryResult = NonNullable<
  Awaited<ReturnType<typeof logsIndex>>
>;
export type LogsIndexInfiniteQueryError =
  ErrorType<AuthenticationExceptionResponse>;

export function useLogsIndexInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof logsIndex>>>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(
  options: {
    query: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof logsIndex>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof logsIndex>>,
          TError,
          Awaited<ReturnType<typeof logsIndex>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): DefinedUseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useLogsIndexInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof logsIndex>>>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof logsIndex>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof logsIndex>>,
          TError,
          Awaited<ReturnType<typeof logsIndex>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useLogsIndexInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof logsIndex>>>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof logsIndex>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get a collection of available log files
 */

export function useLogsIndexInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof logsIndex>>>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof logsIndex>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getLogsIndexInfiniteQueryOptions(options);

  const query = useInfiniteQuery(
    queryOptions,
    queryClient
  ) as UseInfiniteQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getLogsIndexQueryOptions = <
  TData = Awaited<ReturnType<typeof logsIndex>>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof logsIndex>>, TError, TData>
  >;
  request?: SecondParameter<typeof customInstance>;
}) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getLogsIndexQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof logsIndex>>> = ({
    signal,
  }) => logsIndex(requestOptions, signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof logsIndex>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type LogsIndexQueryResult = NonNullable<
  Awaited<ReturnType<typeof logsIndex>>
>;
export type LogsIndexQueryError = ErrorType<AuthenticationExceptionResponse>;

export function useLogsIndex<
  TData = Awaited<ReturnType<typeof logsIndex>>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof logsIndex>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof logsIndex>>,
          TError,
          Awaited<ReturnType<typeof logsIndex>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useLogsIndex<
  TData = Awaited<ReturnType<typeof logsIndex>>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof logsIndex>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof logsIndex>>,
          TError,
          Awaited<ReturnType<typeof logsIndex>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useLogsIndex<
  TData = Awaited<ReturnType<typeof logsIndex>>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof logsIndex>>, TError, TData>
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get a collection of available log files
 */

export function useLogsIndex<
  TData = Awaited<ReturnType<typeof logsIndex>>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof logsIndex>>, TError, TData>
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getLogsIndexQueryOptions(options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getLogsIndexSuspenseQueryOptions = <
  TData = Awaited<ReturnType<typeof logsIndex>>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(options?: {
  query?: Partial<
    UseSuspenseQueryOptions<
      Awaited<ReturnType<typeof logsIndex>>,
      TError,
      TData
    >
  >;
  request?: SecondParameter<typeof customInstance>;
}) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getLogsIndexQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof logsIndex>>> = ({
    signal,
  }) => logsIndex(requestOptions, signal);

  return { queryKey, queryFn, ...queryOptions } as UseSuspenseQueryOptions<
    Awaited<ReturnType<typeof logsIndex>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type LogsIndexSuspenseQueryResult = NonNullable<
  Awaited<ReturnType<typeof logsIndex>>
>;
export type LogsIndexSuspenseQueryError =
  ErrorType<AuthenticationExceptionResponse>;

export function useLogsIndexSuspense<
  TData = Awaited<ReturnType<typeof logsIndex>>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(
  options: {
    query: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof logsIndex>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useLogsIndexSuspense<
  TData = Awaited<ReturnType<typeof logsIndex>>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof logsIndex>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useLogsIndexSuspense<
  TData = Awaited<ReturnType<typeof logsIndex>>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof logsIndex>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get a collection of available log files
 */

export function useLogsIndexSuspense<
  TData = Awaited<ReturnType<typeof logsIndex>>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof logsIndex>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getLogsIndexSuspenseQueryOptions(options);

  const query = useSuspenseQuery(
    queryOptions,
    queryClient
  ) as UseSuspenseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getLogsIndexSuspenseInfiniteQueryOptions = <
  TData = InfiniteData<Awaited<ReturnType<typeof logsIndex>>>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(options?: {
  query?: Partial<
    UseSuspenseInfiniteQueryOptions<
      Awaited<ReturnType<typeof logsIndex>>,
      TError,
      TData
    >
  >;
  request?: SecondParameter<typeof customInstance>;
}) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getLogsIndexInfiniteQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof logsIndex>>> = ({
    signal,
  }) => logsIndex(requestOptions, signal);

  return {
    queryKey,
    queryFn,
    ...queryOptions,
  } as UseSuspenseInfiniteQueryOptions<
    Awaited<ReturnType<typeof logsIndex>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type LogsIndexSuspenseInfiniteQueryResult = NonNullable<
  Awaited<ReturnType<typeof logsIndex>>
>;
export type LogsIndexSuspenseInfiniteQueryError =
  ErrorType<AuthenticationExceptionResponse>;

export function useLogsIndexSuspenseInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof logsIndex>>>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(
  options: {
    query: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof logsIndex>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useLogsIndexSuspenseInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof logsIndex>>>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof logsIndex>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useLogsIndexSuspenseInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof logsIndex>>>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof logsIndex>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get a collection of available log files
 */

export function useLogsIndexSuspenseInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof logsIndex>>>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof logsIndex>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getLogsIndexSuspenseInfiniteQueryOptions(options);

  const query = useSuspenseInfiniteQuery(
    queryOptions,
    queryClient
  ) as UseSuspenseInfiniteQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Returns comprehensive metadata about a log file including file statistics,
line counts, size information, and performance characteristics.
 * @summary Get detailed information about a specific log file
 */
export const logsShow = (
  logFile: string,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal
) => {
  return customInstance<LogsShow200>(
    { url: `/api/logs/${logFile}`, method: "GET", signal },
    options
  );
};

export const getLogsShowInfiniteQueryKey = (logFile?: string) => {
  return ["infinite", `/api/logs/${logFile}`] as const;
};

export const getLogsShowQueryKey = (logFile?: string) => {
  return [`/api/logs/${logFile}`] as const;
};

export const getLogsShowInfiniteQueryOptions = <
  TData = InfiniteData<Awaited<ReturnType<typeof logsShow>>>,
  TError = ErrorType<
    AuthenticationExceptionResponse | ModelNotFoundExceptionResponse
  >
>(
  logFile: string,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof logsShow>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getLogsShowInfiniteQueryKey(logFile);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof logsShow>>> = ({
    signal,
  }) => logsShow(logFile, requestOptions, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!logFile,
    ...queryOptions,
  } as UseInfiniteQueryOptions<
    Awaited<ReturnType<typeof logsShow>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type LogsShowInfiniteQueryResult = NonNullable<
  Awaited<ReturnType<typeof logsShow>>
>;
export type LogsShowInfiniteQueryError = ErrorType<
  AuthenticationExceptionResponse | ModelNotFoundExceptionResponse
>;

export function useLogsShowInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof logsShow>>>,
  TError = ErrorType<
    AuthenticationExceptionResponse | ModelNotFoundExceptionResponse
  >
>(
  logFile: string,
  options: {
    query: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof logsShow>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof logsShow>>,
          TError,
          Awaited<ReturnType<typeof logsShow>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): DefinedUseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useLogsShowInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof logsShow>>>,
  TError = ErrorType<
    AuthenticationExceptionResponse | ModelNotFoundExceptionResponse
  >
>(
  logFile: string,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof logsShow>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof logsShow>>,
          TError,
          Awaited<ReturnType<typeof logsShow>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useLogsShowInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof logsShow>>>,
  TError = ErrorType<
    AuthenticationExceptionResponse | ModelNotFoundExceptionResponse
  >
>(
  logFile: string,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof logsShow>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get detailed information about a specific log file
 */

export function useLogsShowInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof logsShow>>>,
  TError = ErrorType<
    AuthenticationExceptionResponse | ModelNotFoundExceptionResponse
  >
>(
  logFile: string,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof logsShow>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getLogsShowInfiniteQueryOptions(logFile, options);

  const query = useInfiniteQuery(
    queryOptions,
    queryClient
  ) as UseInfiniteQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getLogsShowQueryOptions = <
  TData = Awaited<ReturnType<typeof logsShow>>,
  TError = ErrorType<
    AuthenticationExceptionResponse | ModelNotFoundExceptionResponse
  >
>(
  logFile: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof logsShow>>, TError, TData>
    >;
    request?: SecondParameter<typeof customInstance>;
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getLogsShowQueryKey(logFile);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof logsShow>>> = ({
    signal,
  }) => logsShow(logFile, requestOptions, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!logFile,
    ...queryOptions,
  } as UseQueryOptions<Awaited<ReturnType<typeof logsShow>>, TError, TData> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };
};

export type LogsShowQueryResult = NonNullable<
  Awaited<ReturnType<typeof logsShow>>
>;
export type LogsShowQueryError = ErrorType<
  AuthenticationExceptionResponse | ModelNotFoundExceptionResponse
>;

export function useLogsShow<
  TData = Awaited<ReturnType<typeof logsShow>>,
  TError = ErrorType<
    AuthenticationExceptionResponse | ModelNotFoundExceptionResponse
  >
>(
  logFile: string,
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof logsShow>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof logsShow>>,
          TError,
          Awaited<ReturnType<typeof logsShow>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useLogsShow<
  TData = Awaited<ReturnType<typeof logsShow>>,
  TError = ErrorType<
    AuthenticationExceptionResponse | ModelNotFoundExceptionResponse
  >
>(
  logFile: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof logsShow>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof logsShow>>,
          TError,
          Awaited<ReturnType<typeof logsShow>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useLogsShow<
  TData = Awaited<ReturnType<typeof logsShow>>,
  TError = ErrorType<
    AuthenticationExceptionResponse | ModelNotFoundExceptionResponse
  >
>(
  logFile: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof logsShow>>, TError, TData>
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get detailed information about a specific log file
 */

export function useLogsShow<
  TData = Awaited<ReturnType<typeof logsShow>>,
  TError = ErrorType<
    AuthenticationExceptionResponse | ModelNotFoundExceptionResponse
  >
>(
  logFile: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof logsShow>>, TError, TData>
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getLogsShowQueryOptions(logFile, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getLogsShowSuspenseQueryOptions = <
  TData = Awaited<ReturnType<typeof logsShow>>,
  TError = ErrorType<
    AuthenticationExceptionResponse | ModelNotFoundExceptionResponse
  >
>(
  logFile: string,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof logsShow>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getLogsShowQueryKey(logFile);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof logsShow>>> = ({
    signal,
  }) => logsShow(logFile, requestOptions, signal);

  return { queryKey, queryFn, ...queryOptions } as UseSuspenseQueryOptions<
    Awaited<ReturnType<typeof logsShow>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type LogsShowSuspenseQueryResult = NonNullable<
  Awaited<ReturnType<typeof logsShow>>
>;
export type LogsShowSuspenseQueryError = ErrorType<
  AuthenticationExceptionResponse | ModelNotFoundExceptionResponse
>;

export function useLogsShowSuspense<
  TData = Awaited<ReturnType<typeof logsShow>>,
  TError = ErrorType<
    AuthenticationExceptionResponse | ModelNotFoundExceptionResponse
  >
>(
  logFile: string,
  options: {
    query: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof logsShow>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useLogsShowSuspense<
  TData = Awaited<ReturnType<typeof logsShow>>,
  TError = ErrorType<
    AuthenticationExceptionResponse | ModelNotFoundExceptionResponse
  >
>(
  logFile: string,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof logsShow>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useLogsShowSuspense<
  TData = Awaited<ReturnType<typeof logsShow>>,
  TError = ErrorType<
    AuthenticationExceptionResponse | ModelNotFoundExceptionResponse
  >
>(
  logFile: string,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof logsShow>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get detailed information about a specific log file
 */

export function useLogsShowSuspense<
  TData = Awaited<ReturnType<typeof logsShow>>,
  TError = ErrorType<
    AuthenticationExceptionResponse | ModelNotFoundExceptionResponse
  >
>(
  logFile: string,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof logsShow>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getLogsShowSuspenseQueryOptions(logFile, options);

  const query = useSuspenseQuery(
    queryOptions,
    queryClient
  ) as UseSuspenseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getLogsShowSuspenseInfiniteQueryOptions = <
  TData = InfiniteData<Awaited<ReturnType<typeof logsShow>>>,
  TError = ErrorType<
    AuthenticationExceptionResponse | ModelNotFoundExceptionResponse
  >
>(
  logFile: string,
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof logsShow>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getLogsShowInfiniteQueryKey(logFile);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof logsShow>>> = ({
    signal,
  }) => logsShow(logFile, requestOptions, signal);

  return {
    queryKey,
    queryFn,
    ...queryOptions,
  } as UseSuspenseInfiniteQueryOptions<
    Awaited<ReturnType<typeof logsShow>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type LogsShowSuspenseInfiniteQueryResult = NonNullable<
  Awaited<ReturnType<typeof logsShow>>
>;
export type LogsShowSuspenseInfiniteQueryError = ErrorType<
  AuthenticationExceptionResponse | ModelNotFoundExceptionResponse
>;

export function useLogsShowSuspenseInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof logsShow>>>,
  TError = ErrorType<
    AuthenticationExceptionResponse | ModelNotFoundExceptionResponse
  >
>(
  logFile: string,
  options: {
    query: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof logsShow>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useLogsShowSuspenseInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof logsShow>>>,
  TError = ErrorType<
    AuthenticationExceptionResponse | ModelNotFoundExceptionResponse
  >
>(
  logFile: string,
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof logsShow>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useLogsShowSuspenseInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof logsShow>>>,
  TError = ErrorType<
    AuthenticationExceptionResponse | ModelNotFoundExceptionResponse
  >
>(
  logFile: string,
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof logsShow>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get detailed information about a specific log file
 */

export function useLogsShowSuspenseInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof logsShow>>>,
  TError = ErrorType<
    AuthenticationExceptionResponse | ModelNotFoundExceptionResponse
  >
>(
  logFile: string,
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof logsShow>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getLogsShowSuspenseInfiniteQueryOptions(
    logFile,
    options
  );

  const query = useSuspenseInfiniteQuery(
    queryOptions,
    queryClient
  ) as UseSuspenseInfiniteQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Retrieves log file content starting from a specific line number
with configurable line limits for efficient pagination through large files.
 * @summary Get paginated content from a log file
 */
export const logsContent = (
  logFile: string,
  params?: LogsContentParams,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal
) => {
  return customInstance<LogsContent200>(
    { url: `/api/logs/${logFile}/content`, method: "GET", params, signal },
    options
  );
};

export const getLogsContentInfiniteQueryKey = (
  logFile?: string,
  params?: LogsContentParams
) => {
  return [
    "infinite",
    `/api/logs/${logFile}/content`,
    ...(params ? [params] : []),
  ] as const;
};

export const getLogsContentQueryKey = (
  logFile?: string,
  params?: LogsContentParams
) => {
  return [`/api/logs/${logFile}/content`, ...(params ? [params] : [])] as const;
};

export const getLogsContentInfiniteQueryOptions = <
  TData = InfiniteData<
    Awaited<ReturnType<typeof logsContent>>,
    LogsContentParams["page"]
  >,
  TError = ErrorType<
    AuthenticationExceptionResponse | ValidationExceptionResponse
  >
>(
  logFile: string,
  params?: LogsContentParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof logsContent>>,
        TError,
        TData,
        QueryKey,
        LogsContentParams["page"]
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getLogsContentInfiniteQueryKey(logFile, params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof logsContent>>,
    QueryKey,
    LogsContentParams["page"]
  > = ({ signal, pageParam }) =>
    logsContent(
      logFile,
      { ...params, page: pageParam || params?.["page"] },
      requestOptions,
      signal
    );

  return {
    queryKey,
    queryFn,
    enabled: !!logFile,
    ...queryOptions,
  } as UseInfiniteQueryOptions<
    Awaited<ReturnType<typeof logsContent>>,
    TError,
    TData,
    QueryKey,
    LogsContentParams["page"]
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type LogsContentInfiniteQueryResult = NonNullable<
  Awaited<ReturnType<typeof logsContent>>
>;
export type LogsContentInfiniteQueryError = ErrorType<
  AuthenticationExceptionResponse | ValidationExceptionResponse
>;

export function useLogsContentInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof logsContent>>,
    LogsContentParams["page"]
  >,
  TError = ErrorType<
    AuthenticationExceptionResponse | ValidationExceptionResponse
  >
>(
  logFile: string,
  params: undefined | LogsContentParams,
  options: {
    query: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof logsContent>>,
        TError,
        TData,
        QueryKey,
        LogsContentParams["page"]
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof logsContent>>,
          TError,
          Awaited<ReturnType<typeof logsContent>>,
          QueryKey
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): DefinedUseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useLogsContentInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof logsContent>>,
    LogsContentParams["page"]
  >,
  TError = ErrorType<
    AuthenticationExceptionResponse | ValidationExceptionResponse
  >
>(
  logFile: string,
  params?: LogsContentParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof logsContent>>,
        TError,
        TData,
        QueryKey,
        LogsContentParams["page"]
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof logsContent>>,
          TError,
          Awaited<ReturnType<typeof logsContent>>,
          QueryKey
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useLogsContentInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof logsContent>>,
    LogsContentParams["page"]
  >,
  TError = ErrorType<
    AuthenticationExceptionResponse | ValidationExceptionResponse
  >
>(
  logFile: string,
  params?: LogsContentParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof logsContent>>,
        TError,
        TData,
        QueryKey,
        LogsContentParams["page"]
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get paginated content from a log file
 */

export function useLogsContentInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof logsContent>>,
    LogsContentParams["page"]
  >,
  TError = ErrorType<
    AuthenticationExceptionResponse | ValidationExceptionResponse
  >
>(
  logFile: string,
  params?: LogsContentParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof logsContent>>,
        TError,
        TData,
        QueryKey,
        LogsContentParams["page"]
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getLogsContentInfiniteQueryOptions(
    logFile,
    params,
    options
  );

  const query = useInfiniteQuery(
    queryOptions,
    queryClient
  ) as UseInfiniteQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getLogsContentQueryOptions = <
  TData = Awaited<ReturnType<typeof logsContent>>,
  TError = ErrorType<
    AuthenticationExceptionResponse | ValidationExceptionResponse
  >
>(
  logFile: string,
  params?: LogsContentParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof logsContent>>, TError, TData>
    >;
    request?: SecondParameter<typeof customInstance>;
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getLogsContentQueryKey(logFile, params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof logsContent>>> = ({
    signal,
  }) => logsContent(logFile, params, requestOptions, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!logFile,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof logsContent>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type LogsContentQueryResult = NonNullable<
  Awaited<ReturnType<typeof logsContent>>
>;
export type LogsContentQueryError = ErrorType<
  AuthenticationExceptionResponse | ValidationExceptionResponse
>;

export function useLogsContent<
  TData = Awaited<ReturnType<typeof logsContent>>,
  TError = ErrorType<
    AuthenticationExceptionResponse | ValidationExceptionResponse
  >
>(
  logFile: string,
  params: undefined | LogsContentParams,
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof logsContent>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof logsContent>>,
          TError,
          Awaited<ReturnType<typeof logsContent>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useLogsContent<
  TData = Awaited<ReturnType<typeof logsContent>>,
  TError = ErrorType<
    AuthenticationExceptionResponse | ValidationExceptionResponse
  >
>(
  logFile: string,
  params?: LogsContentParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof logsContent>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof logsContent>>,
          TError,
          Awaited<ReturnType<typeof logsContent>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useLogsContent<
  TData = Awaited<ReturnType<typeof logsContent>>,
  TError = ErrorType<
    AuthenticationExceptionResponse | ValidationExceptionResponse
  >
>(
  logFile: string,
  params?: LogsContentParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof logsContent>>, TError, TData>
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get paginated content from a log file
 */

export function useLogsContent<
  TData = Awaited<ReturnType<typeof logsContent>>,
  TError = ErrorType<
    AuthenticationExceptionResponse | ValidationExceptionResponse
  >
>(
  logFile: string,
  params?: LogsContentParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof logsContent>>, TError, TData>
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getLogsContentQueryOptions(logFile, params, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getLogsContentSuspenseQueryOptions = <
  TData = Awaited<ReturnType<typeof logsContent>>,
  TError = ErrorType<
    AuthenticationExceptionResponse | ValidationExceptionResponse
  >
>(
  logFile: string,
  params?: LogsContentParams,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof logsContent>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getLogsContentQueryKey(logFile, params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof logsContent>>> = ({
    signal,
  }) => logsContent(logFile, params, requestOptions, signal);

  return { queryKey, queryFn, ...queryOptions } as UseSuspenseQueryOptions<
    Awaited<ReturnType<typeof logsContent>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type LogsContentSuspenseQueryResult = NonNullable<
  Awaited<ReturnType<typeof logsContent>>
>;
export type LogsContentSuspenseQueryError = ErrorType<
  AuthenticationExceptionResponse | ValidationExceptionResponse
>;

export function useLogsContentSuspense<
  TData = Awaited<ReturnType<typeof logsContent>>,
  TError = ErrorType<
    AuthenticationExceptionResponse | ValidationExceptionResponse
  >
>(
  logFile: string,
  params: undefined | LogsContentParams,
  options: {
    query: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof logsContent>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useLogsContentSuspense<
  TData = Awaited<ReturnType<typeof logsContent>>,
  TError = ErrorType<
    AuthenticationExceptionResponse | ValidationExceptionResponse
  >
>(
  logFile: string,
  params?: LogsContentParams,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof logsContent>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useLogsContentSuspense<
  TData = Awaited<ReturnType<typeof logsContent>>,
  TError = ErrorType<
    AuthenticationExceptionResponse | ValidationExceptionResponse
  >
>(
  logFile: string,
  params?: LogsContentParams,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof logsContent>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get paginated content from a log file
 */

export function useLogsContentSuspense<
  TData = Awaited<ReturnType<typeof logsContent>>,
  TError = ErrorType<
    AuthenticationExceptionResponse | ValidationExceptionResponse
  >
>(
  logFile: string,
  params?: LogsContentParams,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof logsContent>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getLogsContentSuspenseQueryOptions(
    logFile,
    params,
    options
  );

  const query = useSuspenseQuery(
    queryOptions,
    queryClient
  ) as UseSuspenseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getLogsContentSuspenseInfiniteQueryOptions = <
  TData = InfiniteData<
    Awaited<ReturnType<typeof logsContent>>,
    LogsContentParams["page"]
  >,
  TError = ErrorType<
    AuthenticationExceptionResponse | ValidationExceptionResponse
  >
>(
  logFile: string,
  params?: LogsContentParams,
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof logsContent>>,
        TError,
        TData,
        QueryKey,
        LogsContentParams["page"]
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getLogsContentInfiniteQueryKey(logFile, params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof logsContent>>,
    QueryKey,
    LogsContentParams["page"]
  > = ({ signal, pageParam }) =>
    logsContent(
      logFile,
      { ...params, page: pageParam || params?.["page"] },
      requestOptions,
      signal
    );

  return {
    queryKey,
    queryFn,
    ...queryOptions,
  } as UseSuspenseInfiniteQueryOptions<
    Awaited<ReturnType<typeof logsContent>>,
    TError,
    TData,
    QueryKey,
    LogsContentParams["page"]
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type LogsContentSuspenseInfiniteQueryResult = NonNullable<
  Awaited<ReturnType<typeof logsContent>>
>;
export type LogsContentSuspenseInfiniteQueryError = ErrorType<
  AuthenticationExceptionResponse | ValidationExceptionResponse
>;

export function useLogsContentSuspenseInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof logsContent>>,
    LogsContentParams["page"]
  >,
  TError = ErrorType<
    AuthenticationExceptionResponse | ValidationExceptionResponse
  >
>(
  logFile: string,
  params: undefined | LogsContentParams,
  options: {
    query: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof logsContent>>,
        TError,
        TData,
        QueryKey,
        LogsContentParams["page"]
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useLogsContentSuspenseInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof logsContent>>,
    LogsContentParams["page"]
  >,
  TError = ErrorType<
    AuthenticationExceptionResponse | ValidationExceptionResponse
  >
>(
  logFile: string,
  params?: LogsContentParams,
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof logsContent>>,
        TError,
        TData,
        QueryKey,
        LogsContentParams["page"]
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useLogsContentSuspenseInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof logsContent>>,
    LogsContentParams["page"]
  >,
  TError = ErrorType<
    AuthenticationExceptionResponse | ValidationExceptionResponse
  >
>(
  logFile: string,
  params?: LogsContentParams,
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof logsContent>>,
        TError,
        TData,
        QueryKey,
        LogsContentParams["page"]
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get paginated content from a log file
 */

export function useLogsContentSuspenseInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof logsContent>>,
    LogsContentParams["page"]
  >,
  TError = ErrorType<
    AuthenticationExceptionResponse | ValidationExceptionResponse
  >
>(
  logFile: string,
  params?: LogsContentParams,
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof logsContent>>,
        TError,
        TData,
        QueryKey,
        LogsContentParams["page"]
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getLogsContentSuspenseInfiniteQueryOptions(
    logFile,
    params,
    options
  );

  const query = useSuspenseInfiniteQuery(
    queryOptions,
    queryClient
  ) as UseSuspenseInfiniteQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Returns the total line count for a log file using optimized counting
algorithms that can handle very large files efficiently.
 * @summary Count total lines in a log file
 */
export const logsLines = (
  logFile: string,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal
) => {
  return customInstance<LogsLines200>(
    { url: `/api/logs/${logFile}/lines`, method: "GET", signal },
    options
  );
};

export const getLogsLinesInfiniteQueryKey = (logFile?: string) => {
  return ["infinite", `/api/logs/${logFile}/lines`] as const;
};

export const getLogsLinesQueryKey = (logFile?: string) => {
  return [`/api/logs/${logFile}/lines`] as const;
};

export const getLogsLinesInfiniteQueryOptions = <
  TData = InfiniteData<Awaited<ReturnType<typeof logsLines>>>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(
  logFile: string,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof logsLines>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getLogsLinesInfiniteQueryKey(logFile);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof logsLines>>> = ({
    signal,
  }) => logsLines(logFile, requestOptions, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!logFile,
    ...queryOptions,
  } as UseInfiniteQueryOptions<
    Awaited<ReturnType<typeof logsLines>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type LogsLinesInfiniteQueryResult = NonNullable<
  Awaited<ReturnType<typeof logsLines>>
>;
export type LogsLinesInfiniteQueryError =
  ErrorType<AuthenticationExceptionResponse>;

export function useLogsLinesInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof logsLines>>>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(
  logFile: string,
  options: {
    query: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof logsLines>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof logsLines>>,
          TError,
          Awaited<ReturnType<typeof logsLines>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): DefinedUseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useLogsLinesInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof logsLines>>>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(
  logFile: string,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof logsLines>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof logsLines>>,
          TError,
          Awaited<ReturnType<typeof logsLines>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useLogsLinesInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof logsLines>>>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(
  logFile: string,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof logsLines>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Count total lines in a log file
 */

export function useLogsLinesInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof logsLines>>>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(
  logFile: string,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof logsLines>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getLogsLinesInfiniteQueryOptions(logFile, options);

  const query = useInfiniteQuery(
    queryOptions,
    queryClient
  ) as UseInfiniteQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getLogsLinesQueryOptions = <
  TData = Awaited<ReturnType<typeof logsLines>>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(
  logFile: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof logsLines>>, TError, TData>
    >;
    request?: SecondParameter<typeof customInstance>;
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getLogsLinesQueryKey(logFile);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof logsLines>>> = ({
    signal,
  }) => logsLines(logFile, requestOptions, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!logFile,
    ...queryOptions,
  } as UseQueryOptions<Awaited<ReturnType<typeof logsLines>>, TError, TData> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };
};

export type LogsLinesQueryResult = NonNullable<
  Awaited<ReturnType<typeof logsLines>>
>;
export type LogsLinesQueryError = ErrorType<AuthenticationExceptionResponse>;

export function useLogsLines<
  TData = Awaited<ReturnType<typeof logsLines>>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(
  logFile: string,
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof logsLines>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof logsLines>>,
          TError,
          Awaited<ReturnType<typeof logsLines>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useLogsLines<
  TData = Awaited<ReturnType<typeof logsLines>>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(
  logFile: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof logsLines>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof logsLines>>,
          TError,
          Awaited<ReturnType<typeof logsLines>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useLogsLines<
  TData = Awaited<ReturnType<typeof logsLines>>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(
  logFile: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof logsLines>>, TError, TData>
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Count total lines in a log file
 */

export function useLogsLines<
  TData = Awaited<ReturnType<typeof logsLines>>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(
  logFile: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof logsLines>>, TError, TData>
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getLogsLinesQueryOptions(logFile, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getLogsLinesSuspenseQueryOptions = <
  TData = Awaited<ReturnType<typeof logsLines>>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(
  logFile: string,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof logsLines>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getLogsLinesQueryKey(logFile);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof logsLines>>> = ({
    signal,
  }) => logsLines(logFile, requestOptions, signal);

  return { queryKey, queryFn, ...queryOptions } as UseSuspenseQueryOptions<
    Awaited<ReturnType<typeof logsLines>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type LogsLinesSuspenseQueryResult = NonNullable<
  Awaited<ReturnType<typeof logsLines>>
>;
export type LogsLinesSuspenseQueryError =
  ErrorType<AuthenticationExceptionResponse>;

export function useLogsLinesSuspense<
  TData = Awaited<ReturnType<typeof logsLines>>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(
  logFile: string,
  options: {
    query: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof logsLines>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useLogsLinesSuspense<
  TData = Awaited<ReturnType<typeof logsLines>>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(
  logFile: string,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof logsLines>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useLogsLinesSuspense<
  TData = Awaited<ReturnType<typeof logsLines>>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(
  logFile: string,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof logsLines>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Count total lines in a log file
 */

export function useLogsLinesSuspense<
  TData = Awaited<ReturnType<typeof logsLines>>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(
  logFile: string,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof logsLines>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getLogsLinesSuspenseQueryOptions(logFile, options);

  const query = useSuspenseQuery(
    queryOptions,
    queryClient
  ) as UseSuspenseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getLogsLinesSuspenseInfiniteQueryOptions = <
  TData = InfiniteData<Awaited<ReturnType<typeof logsLines>>>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(
  logFile: string,
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof logsLines>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getLogsLinesInfiniteQueryKey(logFile);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof logsLines>>> = ({
    signal,
  }) => logsLines(logFile, requestOptions, signal);

  return {
    queryKey,
    queryFn,
    ...queryOptions,
  } as UseSuspenseInfiniteQueryOptions<
    Awaited<ReturnType<typeof logsLines>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type LogsLinesSuspenseInfiniteQueryResult = NonNullable<
  Awaited<ReturnType<typeof logsLines>>
>;
export type LogsLinesSuspenseInfiniteQueryError =
  ErrorType<AuthenticationExceptionResponse>;

export function useLogsLinesSuspenseInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof logsLines>>>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(
  logFile: string,
  options: {
    query: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof logsLines>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useLogsLinesSuspenseInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof logsLines>>>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(
  logFile: string,
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof logsLines>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useLogsLinesSuspenseInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof logsLines>>>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(
  logFile: string,
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof logsLines>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Count total lines in a log file
 */

export function useLogsLinesSuspenseInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof logsLines>>>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(
  logFile: string,
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof logsLines>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getLogsLinesSuspenseInfiniteQueryOptions(
    logFile,
    options
  );

  const query = useSuspenseInfiniteQuery(
    queryOptions,
    queryClient
  ) as UseSuspenseInfiniteQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Returns the most recent lines from a log file, similar to the Unix tail command.
Useful for monitoring recent activity and debugging current issues.
 * @summary Get the last N lines from a log file (tail functionality)
 */
export const logsTail = (
  logFile: string,
  params?: LogsTailParams,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal
) => {
  return customInstance<LogsTail200>(
    { url: `/api/logs/${logFile}/tail`, method: "GET", params, signal },
    options
  );
};

export const getLogsTailInfiniteQueryKey = (
  logFile?: string,
  params?: LogsTailParams
) => {
  return [
    "infinite",
    `/api/logs/${logFile}/tail`,
    ...(params ? [params] : []),
  ] as const;
};

export const getLogsTailQueryKey = (
  logFile?: string,
  params?: LogsTailParams
) => {
  return [`/api/logs/${logFile}/tail`, ...(params ? [params] : [])] as const;
};

export const getLogsTailInfiniteQueryOptions = <
  TData = InfiniteData<
    Awaited<ReturnType<typeof logsTail>>,
    LogsTailParams["page"]
  >,
  TError = ErrorType<
    AuthenticationExceptionResponse | ValidationExceptionResponse
  >
>(
  logFile: string,
  params?: LogsTailParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof logsTail>>,
        TError,
        TData,
        QueryKey,
        LogsTailParams["page"]
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getLogsTailInfiniteQueryKey(logFile, params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof logsTail>>,
    QueryKey,
    LogsTailParams["page"]
  > = ({ signal, pageParam }) =>
    logsTail(
      logFile,
      { ...params, page: pageParam || params?.["page"] },
      requestOptions,
      signal
    );

  return {
    queryKey,
    queryFn,
    enabled: !!logFile,
    ...queryOptions,
  } as UseInfiniteQueryOptions<
    Awaited<ReturnType<typeof logsTail>>,
    TError,
    TData,
    QueryKey,
    LogsTailParams["page"]
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type LogsTailInfiniteQueryResult = NonNullable<
  Awaited<ReturnType<typeof logsTail>>
>;
export type LogsTailInfiniteQueryError = ErrorType<
  AuthenticationExceptionResponse | ValidationExceptionResponse
>;

export function useLogsTailInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof logsTail>>,
    LogsTailParams["page"]
  >,
  TError = ErrorType<
    AuthenticationExceptionResponse | ValidationExceptionResponse
  >
>(
  logFile: string,
  params: undefined | LogsTailParams,
  options: {
    query: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof logsTail>>,
        TError,
        TData,
        QueryKey,
        LogsTailParams["page"]
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof logsTail>>,
          TError,
          Awaited<ReturnType<typeof logsTail>>,
          QueryKey
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): DefinedUseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useLogsTailInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof logsTail>>,
    LogsTailParams["page"]
  >,
  TError = ErrorType<
    AuthenticationExceptionResponse | ValidationExceptionResponse
  >
>(
  logFile: string,
  params?: LogsTailParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof logsTail>>,
        TError,
        TData,
        QueryKey,
        LogsTailParams["page"]
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof logsTail>>,
          TError,
          Awaited<ReturnType<typeof logsTail>>,
          QueryKey
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useLogsTailInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof logsTail>>,
    LogsTailParams["page"]
  >,
  TError = ErrorType<
    AuthenticationExceptionResponse | ValidationExceptionResponse
  >
>(
  logFile: string,
  params?: LogsTailParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof logsTail>>,
        TError,
        TData,
        QueryKey,
        LogsTailParams["page"]
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get the last N lines from a log file (tail functionality)
 */

export function useLogsTailInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof logsTail>>,
    LogsTailParams["page"]
  >,
  TError = ErrorType<
    AuthenticationExceptionResponse | ValidationExceptionResponse
  >
>(
  logFile: string,
  params?: LogsTailParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof logsTail>>,
        TError,
        TData,
        QueryKey,
        LogsTailParams["page"]
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getLogsTailInfiniteQueryOptions(
    logFile,
    params,
    options
  );

  const query = useInfiniteQuery(
    queryOptions,
    queryClient
  ) as UseInfiniteQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getLogsTailQueryOptions = <
  TData = Awaited<ReturnType<typeof logsTail>>,
  TError = ErrorType<
    AuthenticationExceptionResponse | ValidationExceptionResponse
  >
>(
  logFile: string,
  params?: LogsTailParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof logsTail>>, TError, TData>
    >;
    request?: SecondParameter<typeof customInstance>;
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getLogsTailQueryKey(logFile, params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof logsTail>>> = ({
    signal,
  }) => logsTail(logFile, params, requestOptions, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!logFile,
    ...queryOptions,
  } as UseQueryOptions<Awaited<ReturnType<typeof logsTail>>, TError, TData> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };
};

export type LogsTailQueryResult = NonNullable<
  Awaited<ReturnType<typeof logsTail>>
>;
export type LogsTailQueryError = ErrorType<
  AuthenticationExceptionResponse | ValidationExceptionResponse
>;

export function useLogsTail<
  TData = Awaited<ReturnType<typeof logsTail>>,
  TError = ErrorType<
    AuthenticationExceptionResponse | ValidationExceptionResponse
  >
>(
  logFile: string,
  params: undefined | LogsTailParams,
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof logsTail>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof logsTail>>,
          TError,
          Awaited<ReturnType<typeof logsTail>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useLogsTail<
  TData = Awaited<ReturnType<typeof logsTail>>,
  TError = ErrorType<
    AuthenticationExceptionResponse | ValidationExceptionResponse
  >
>(
  logFile: string,
  params?: LogsTailParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof logsTail>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof logsTail>>,
          TError,
          Awaited<ReturnType<typeof logsTail>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useLogsTail<
  TData = Awaited<ReturnType<typeof logsTail>>,
  TError = ErrorType<
    AuthenticationExceptionResponse | ValidationExceptionResponse
  >
>(
  logFile: string,
  params?: LogsTailParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof logsTail>>, TError, TData>
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get the last N lines from a log file (tail functionality)
 */

export function useLogsTail<
  TData = Awaited<ReturnType<typeof logsTail>>,
  TError = ErrorType<
    AuthenticationExceptionResponse | ValidationExceptionResponse
  >
>(
  logFile: string,
  params?: LogsTailParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof logsTail>>, TError, TData>
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getLogsTailQueryOptions(logFile, params, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getLogsTailSuspenseQueryOptions = <
  TData = Awaited<ReturnType<typeof logsTail>>,
  TError = ErrorType<
    AuthenticationExceptionResponse | ValidationExceptionResponse
  >
>(
  logFile: string,
  params?: LogsTailParams,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof logsTail>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getLogsTailQueryKey(logFile, params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof logsTail>>> = ({
    signal,
  }) => logsTail(logFile, params, requestOptions, signal);

  return { queryKey, queryFn, ...queryOptions } as UseSuspenseQueryOptions<
    Awaited<ReturnType<typeof logsTail>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type LogsTailSuspenseQueryResult = NonNullable<
  Awaited<ReturnType<typeof logsTail>>
>;
export type LogsTailSuspenseQueryError = ErrorType<
  AuthenticationExceptionResponse | ValidationExceptionResponse
>;

export function useLogsTailSuspense<
  TData = Awaited<ReturnType<typeof logsTail>>,
  TError = ErrorType<
    AuthenticationExceptionResponse | ValidationExceptionResponse
  >
>(
  logFile: string,
  params: undefined | LogsTailParams,
  options: {
    query: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof logsTail>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useLogsTailSuspense<
  TData = Awaited<ReturnType<typeof logsTail>>,
  TError = ErrorType<
    AuthenticationExceptionResponse | ValidationExceptionResponse
  >
>(
  logFile: string,
  params?: LogsTailParams,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof logsTail>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useLogsTailSuspense<
  TData = Awaited<ReturnType<typeof logsTail>>,
  TError = ErrorType<
    AuthenticationExceptionResponse | ValidationExceptionResponse
  >
>(
  logFile: string,
  params?: LogsTailParams,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof logsTail>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get the last N lines from a log file (tail functionality)
 */

export function useLogsTailSuspense<
  TData = Awaited<ReturnType<typeof logsTail>>,
  TError = ErrorType<
    AuthenticationExceptionResponse | ValidationExceptionResponse
  >
>(
  logFile: string,
  params?: LogsTailParams,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof logsTail>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getLogsTailSuspenseQueryOptions(
    logFile,
    params,
    options
  );

  const query = useSuspenseQuery(
    queryOptions,
    queryClient
  ) as UseSuspenseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getLogsTailSuspenseInfiniteQueryOptions = <
  TData = InfiniteData<
    Awaited<ReturnType<typeof logsTail>>,
    LogsTailParams["page"]
  >,
  TError = ErrorType<
    AuthenticationExceptionResponse | ValidationExceptionResponse
  >
>(
  logFile: string,
  params?: LogsTailParams,
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof logsTail>>,
        TError,
        TData,
        QueryKey,
        LogsTailParams["page"]
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getLogsTailInfiniteQueryKey(logFile, params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof logsTail>>,
    QueryKey,
    LogsTailParams["page"]
  > = ({ signal, pageParam }) =>
    logsTail(
      logFile,
      { ...params, page: pageParam || params?.["page"] },
      requestOptions,
      signal
    );

  return {
    queryKey,
    queryFn,
    ...queryOptions,
  } as UseSuspenseInfiniteQueryOptions<
    Awaited<ReturnType<typeof logsTail>>,
    TError,
    TData,
    QueryKey,
    LogsTailParams["page"]
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type LogsTailSuspenseInfiniteQueryResult = NonNullable<
  Awaited<ReturnType<typeof logsTail>>
>;
export type LogsTailSuspenseInfiniteQueryError = ErrorType<
  AuthenticationExceptionResponse | ValidationExceptionResponse
>;

export function useLogsTailSuspenseInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof logsTail>>,
    LogsTailParams["page"]
  >,
  TError = ErrorType<
    AuthenticationExceptionResponse | ValidationExceptionResponse
  >
>(
  logFile: string,
  params: undefined | LogsTailParams,
  options: {
    query: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof logsTail>>,
        TError,
        TData,
        QueryKey,
        LogsTailParams["page"]
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useLogsTailSuspenseInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof logsTail>>,
    LogsTailParams["page"]
  >,
  TError = ErrorType<
    AuthenticationExceptionResponse | ValidationExceptionResponse
  >
>(
  logFile: string,
  params?: LogsTailParams,
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof logsTail>>,
        TError,
        TData,
        QueryKey,
        LogsTailParams["page"]
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useLogsTailSuspenseInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof logsTail>>,
    LogsTailParams["page"]
  >,
  TError = ErrorType<
    AuthenticationExceptionResponse | ValidationExceptionResponse
  >
>(
  logFile: string,
  params?: LogsTailParams,
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof logsTail>>,
        TError,
        TData,
        QueryKey,
        LogsTailParams["page"]
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get the last N lines from a log file (tail functionality)
 */

export function useLogsTailSuspenseInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof logsTail>>,
    LogsTailParams["page"]
  >,
  TError = ErrorType<
    AuthenticationExceptionResponse | ValidationExceptionResponse
  >
>(
  logFile: string,
  params?: LogsTailParams,
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof logsTail>>,
        TError,
        TData,
        QueryKey,
        LogsTailParams["page"]
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getLogsTailSuspenseInfiniteQueryOptions(
    logFile,
    params,
    options
  );

  const query = useSuspenseInfiniteQuery(
    queryOptions,
    queryClient
  ) as UseSuspenseInfiniteQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Returns the first lines from a log file, similar to the Unix head command.
Useful for examining log file structure and initial entries.
 * @summary Get the first N lines from a log file (head functionality)
 */
export const logsHead = (
  logFile: string,
  params?: LogsHeadParams,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal
) => {
  return customInstance<LogsHead200>(
    { url: `/api/logs/${logFile}/head`, method: "GET", params, signal },
    options
  );
};

export const getLogsHeadInfiniteQueryKey = (
  logFile?: string,
  params?: LogsHeadParams
) => {
  return [
    "infinite",
    `/api/logs/${logFile}/head`,
    ...(params ? [params] : []),
  ] as const;
};

export const getLogsHeadQueryKey = (
  logFile?: string,
  params?: LogsHeadParams
) => {
  return [`/api/logs/${logFile}/head`, ...(params ? [params] : [])] as const;
};

export const getLogsHeadInfiniteQueryOptions = <
  TData = InfiniteData<
    Awaited<ReturnType<typeof logsHead>>,
    LogsHeadParams["page"]
  >,
  TError = ErrorType<
    AuthenticationExceptionResponse | ValidationExceptionResponse
  >
>(
  logFile: string,
  params?: LogsHeadParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof logsHead>>,
        TError,
        TData,
        QueryKey,
        LogsHeadParams["page"]
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getLogsHeadInfiniteQueryKey(logFile, params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof logsHead>>,
    QueryKey,
    LogsHeadParams["page"]
  > = ({ signal, pageParam }) =>
    logsHead(
      logFile,
      { ...params, page: pageParam || params?.["page"] },
      requestOptions,
      signal
    );

  return {
    queryKey,
    queryFn,
    enabled: !!logFile,
    ...queryOptions,
  } as UseInfiniteQueryOptions<
    Awaited<ReturnType<typeof logsHead>>,
    TError,
    TData,
    QueryKey,
    LogsHeadParams["page"]
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type LogsHeadInfiniteQueryResult = NonNullable<
  Awaited<ReturnType<typeof logsHead>>
>;
export type LogsHeadInfiniteQueryError = ErrorType<
  AuthenticationExceptionResponse | ValidationExceptionResponse
>;

export function useLogsHeadInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof logsHead>>,
    LogsHeadParams["page"]
  >,
  TError = ErrorType<
    AuthenticationExceptionResponse | ValidationExceptionResponse
  >
>(
  logFile: string,
  params: undefined | LogsHeadParams,
  options: {
    query: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof logsHead>>,
        TError,
        TData,
        QueryKey,
        LogsHeadParams["page"]
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof logsHead>>,
          TError,
          Awaited<ReturnType<typeof logsHead>>,
          QueryKey
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): DefinedUseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useLogsHeadInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof logsHead>>,
    LogsHeadParams["page"]
  >,
  TError = ErrorType<
    AuthenticationExceptionResponse | ValidationExceptionResponse
  >
>(
  logFile: string,
  params?: LogsHeadParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof logsHead>>,
        TError,
        TData,
        QueryKey,
        LogsHeadParams["page"]
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof logsHead>>,
          TError,
          Awaited<ReturnType<typeof logsHead>>,
          QueryKey
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useLogsHeadInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof logsHead>>,
    LogsHeadParams["page"]
  >,
  TError = ErrorType<
    AuthenticationExceptionResponse | ValidationExceptionResponse
  >
>(
  logFile: string,
  params?: LogsHeadParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof logsHead>>,
        TError,
        TData,
        QueryKey,
        LogsHeadParams["page"]
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get the first N lines from a log file (head functionality)
 */

export function useLogsHeadInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof logsHead>>,
    LogsHeadParams["page"]
  >,
  TError = ErrorType<
    AuthenticationExceptionResponse | ValidationExceptionResponse
  >
>(
  logFile: string,
  params?: LogsHeadParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof logsHead>>,
        TError,
        TData,
        QueryKey,
        LogsHeadParams["page"]
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getLogsHeadInfiniteQueryOptions(
    logFile,
    params,
    options
  );

  const query = useInfiniteQuery(
    queryOptions,
    queryClient
  ) as UseInfiniteQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getLogsHeadQueryOptions = <
  TData = Awaited<ReturnType<typeof logsHead>>,
  TError = ErrorType<
    AuthenticationExceptionResponse | ValidationExceptionResponse
  >
>(
  logFile: string,
  params?: LogsHeadParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof logsHead>>, TError, TData>
    >;
    request?: SecondParameter<typeof customInstance>;
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getLogsHeadQueryKey(logFile, params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof logsHead>>> = ({
    signal,
  }) => logsHead(logFile, params, requestOptions, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!logFile,
    ...queryOptions,
  } as UseQueryOptions<Awaited<ReturnType<typeof logsHead>>, TError, TData> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };
};

export type LogsHeadQueryResult = NonNullable<
  Awaited<ReturnType<typeof logsHead>>
>;
export type LogsHeadQueryError = ErrorType<
  AuthenticationExceptionResponse | ValidationExceptionResponse
>;

export function useLogsHead<
  TData = Awaited<ReturnType<typeof logsHead>>,
  TError = ErrorType<
    AuthenticationExceptionResponse | ValidationExceptionResponse
  >
>(
  logFile: string,
  params: undefined | LogsHeadParams,
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof logsHead>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof logsHead>>,
          TError,
          Awaited<ReturnType<typeof logsHead>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useLogsHead<
  TData = Awaited<ReturnType<typeof logsHead>>,
  TError = ErrorType<
    AuthenticationExceptionResponse | ValidationExceptionResponse
  >
>(
  logFile: string,
  params?: LogsHeadParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof logsHead>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof logsHead>>,
          TError,
          Awaited<ReturnType<typeof logsHead>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useLogsHead<
  TData = Awaited<ReturnType<typeof logsHead>>,
  TError = ErrorType<
    AuthenticationExceptionResponse | ValidationExceptionResponse
  >
>(
  logFile: string,
  params?: LogsHeadParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof logsHead>>, TError, TData>
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get the first N lines from a log file (head functionality)
 */

export function useLogsHead<
  TData = Awaited<ReturnType<typeof logsHead>>,
  TError = ErrorType<
    AuthenticationExceptionResponse | ValidationExceptionResponse
  >
>(
  logFile: string,
  params?: LogsHeadParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof logsHead>>, TError, TData>
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getLogsHeadQueryOptions(logFile, params, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getLogsHeadSuspenseQueryOptions = <
  TData = Awaited<ReturnType<typeof logsHead>>,
  TError = ErrorType<
    AuthenticationExceptionResponse | ValidationExceptionResponse
  >
>(
  logFile: string,
  params?: LogsHeadParams,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof logsHead>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getLogsHeadQueryKey(logFile, params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof logsHead>>> = ({
    signal,
  }) => logsHead(logFile, params, requestOptions, signal);

  return { queryKey, queryFn, ...queryOptions } as UseSuspenseQueryOptions<
    Awaited<ReturnType<typeof logsHead>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type LogsHeadSuspenseQueryResult = NonNullable<
  Awaited<ReturnType<typeof logsHead>>
>;
export type LogsHeadSuspenseQueryError = ErrorType<
  AuthenticationExceptionResponse | ValidationExceptionResponse
>;

export function useLogsHeadSuspense<
  TData = Awaited<ReturnType<typeof logsHead>>,
  TError = ErrorType<
    AuthenticationExceptionResponse | ValidationExceptionResponse
  >
>(
  logFile: string,
  params: undefined | LogsHeadParams,
  options: {
    query: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof logsHead>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useLogsHeadSuspense<
  TData = Awaited<ReturnType<typeof logsHead>>,
  TError = ErrorType<
    AuthenticationExceptionResponse | ValidationExceptionResponse
  >
>(
  logFile: string,
  params?: LogsHeadParams,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof logsHead>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useLogsHeadSuspense<
  TData = Awaited<ReturnType<typeof logsHead>>,
  TError = ErrorType<
    AuthenticationExceptionResponse | ValidationExceptionResponse
  >
>(
  logFile: string,
  params?: LogsHeadParams,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof logsHead>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get the first N lines from a log file (head functionality)
 */

export function useLogsHeadSuspense<
  TData = Awaited<ReturnType<typeof logsHead>>,
  TError = ErrorType<
    AuthenticationExceptionResponse | ValidationExceptionResponse
  >
>(
  logFile: string,
  params?: LogsHeadParams,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof logsHead>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getLogsHeadSuspenseQueryOptions(
    logFile,
    params,
    options
  );

  const query = useSuspenseQuery(
    queryOptions,
    queryClient
  ) as UseSuspenseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getLogsHeadSuspenseInfiniteQueryOptions = <
  TData = InfiniteData<
    Awaited<ReturnType<typeof logsHead>>,
    LogsHeadParams["page"]
  >,
  TError = ErrorType<
    AuthenticationExceptionResponse | ValidationExceptionResponse
  >
>(
  logFile: string,
  params?: LogsHeadParams,
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof logsHead>>,
        TError,
        TData,
        QueryKey,
        LogsHeadParams["page"]
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getLogsHeadInfiniteQueryKey(logFile, params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof logsHead>>,
    QueryKey,
    LogsHeadParams["page"]
  > = ({ signal, pageParam }) =>
    logsHead(
      logFile,
      { ...params, page: pageParam || params?.["page"] },
      requestOptions,
      signal
    );

  return {
    queryKey,
    queryFn,
    ...queryOptions,
  } as UseSuspenseInfiniteQueryOptions<
    Awaited<ReturnType<typeof logsHead>>,
    TError,
    TData,
    QueryKey,
    LogsHeadParams["page"]
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type LogsHeadSuspenseInfiniteQueryResult = NonNullable<
  Awaited<ReturnType<typeof logsHead>>
>;
export type LogsHeadSuspenseInfiniteQueryError = ErrorType<
  AuthenticationExceptionResponse | ValidationExceptionResponse
>;

export function useLogsHeadSuspenseInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof logsHead>>,
    LogsHeadParams["page"]
  >,
  TError = ErrorType<
    AuthenticationExceptionResponse | ValidationExceptionResponse
  >
>(
  logFile: string,
  params: undefined | LogsHeadParams,
  options: {
    query: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof logsHead>>,
        TError,
        TData,
        QueryKey,
        LogsHeadParams["page"]
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useLogsHeadSuspenseInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof logsHead>>,
    LogsHeadParams["page"]
  >,
  TError = ErrorType<
    AuthenticationExceptionResponse | ValidationExceptionResponse
  >
>(
  logFile: string,
  params?: LogsHeadParams,
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof logsHead>>,
        TError,
        TData,
        QueryKey,
        LogsHeadParams["page"]
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useLogsHeadSuspenseInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof logsHead>>,
    LogsHeadParams["page"]
  >,
  TError = ErrorType<
    AuthenticationExceptionResponse | ValidationExceptionResponse
  >
>(
  logFile: string,
  params?: LogsHeadParams,
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof logsHead>>,
        TError,
        TData,
        QueryKey,
        LogsHeadParams["page"]
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get the first N lines from a log file (head functionality)
 */

export function useLogsHeadSuspenseInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof logsHead>>,
    LogsHeadParams["page"]
  >,
  TError = ErrorType<
    AuthenticationExceptionResponse | ValidationExceptionResponse
  >
>(
  logFile: string,
  params?: LogsHeadParams,
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof logsHead>>,
        TError,
        TData,
        QueryKey,
        LogsHeadParams["page"]
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getLogsHeadSuspenseInfiniteQueryOptions(
    logFile,
    params,
    options
  );

  const query = useSuspenseInfiniteQuery(
    queryOptions,
    queryClient
  ) as UseSuspenseInfiniteQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Analyzes log file content to provide detailed statistics including
log level counts, performance metrics, and optimization recommendations.
 * @summary Get comprehensive statistics for a log file
 */
export const logsStats = (
  logFile: string,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal
) => {
  return customInstance<LogsStats200>(
    { url: `/api/logs/${logFile}/stats`, method: "GET", signal },
    options
  );
};

export const getLogsStatsInfiniteQueryKey = (logFile?: string) => {
  return ["infinite", `/api/logs/${logFile}/stats`] as const;
};

export const getLogsStatsQueryKey = (logFile?: string) => {
  return [`/api/logs/${logFile}/stats`] as const;
};

export const getLogsStatsInfiniteQueryOptions = <
  TData = InfiniteData<Awaited<ReturnType<typeof logsStats>>>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(
  logFile: string,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof logsStats>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getLogsStatsInfiniteQueryKey(logFile);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof logsStats>>> = ({
    signal,
  }) => logsStats(logFile, requestOptions, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!logFile,
    ...queryOptions,
  } as UseInfiniteQueryOptions<
    Awaited<ReturnType<typeof logsStats>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type LogsStatsInfiniteQueryResult = NonNullable<
  Awaited<ReturnType<typeof logsStats>>
>;
export type LogsStatsInfiniteQueryError =
  ErrorType<AuthenticationExceptionResponse>;

export function useLogsStatsInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof logsStats>>>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(
  logFile: string,
  options: {
    query: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof logsStats>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof logsStats>>,
          TError,
          Awaited<ReturnType<typeof logsStats>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): DefinedUseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useLogsStatsInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof logsStats>>>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(
  logFile: string,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof logsStats>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof logsStats>>,
          TError,
          Awaited<ReturnType<typeof logsStats>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useLogsStatsInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof logsStats>>>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(
  logFile: string,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof logsStats>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get comprehensive statistics for a log file
 */

export function useLogsStatsInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof logsStats>>>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(
  logFile: string,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof logsStats>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getLogsStatsInfiniteQueryOptions(logFile, options);

  const query = useInfiniteQuery(
    queryOptions,
    queryClient
  ) as UseInfiniteQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getLogsStatsQueryOptions = <
  TData = Awaited<ReturnType<typeof logsStats>>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(
  logFile: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof logsStats>>, TError, TData>
    >;
    request?: SecondParameter<typeof customInstance>;
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getLogsStatsQueryKey(logFile);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof logsStats>>> = ({
    signal,
  }) => logsStats(logFile, requestOptions, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!logFile,
    ...queryOptions,
  } as UseQueryOptions<Awaited<ReturnType<typeof logsStats>>, TError, TData> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };
};

export type LogsStatsQueryResult = NonNullable<
  Awaited<ReturnType<typeof logsStats>>
>;
export type LogsStatsQueryError = ErrorType<AuthenticationExceptionResponse>;

export function useLogsStats<
  TData = Awaited<ReturnType<typeof logsStats>>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(
  logFile: string,
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof logsStats>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof logsStats>>,
          TError,
          Awaited<ReturnType<typeof logsStats>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useLogsStats<
  TData = Awaited<ReturnType<typeof logsStats>>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(
  logFile: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof logsStats>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof logsStats>>,
          TError,
          Awaited<ReturnType<typeof logsStats>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useLogsStats<
  TData = Awaited<ReturnType<typeof logsStats>>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(
  logFile: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof logsStats>>, TError, TData>
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get comprehensive statistics for a log file
 */

export function useLogsStats<
  TData = Awaited<ReturnType<typeof logsStats>>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(
  logFile: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof logsStats>>, TError, TData>
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getLogsStatsQueryOptions(logFile, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getLogsStatsSuspenseQueryOptions = <
  TData = Awaited<ReturnType<typeof logsStats>>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(
  logFile: string,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof logsStats>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getLogsStatsQueryKey(logFile);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof logsStats>>> = ({
    signal,
  }) => logsStats(logFile, requestOptions, signal);

  return { queryKey, queryFn, ...queryOptions } as UseSuspenseQueryOptions<
    Awaited<ReturnType<typeof logsStats>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type LogsStatsSuspenseQueryResult = NonNullable<
  Awaited<ReturnType<typeof logsStats>>
>;
export type LogsStatsSuspenseQueryError =
  ErrorType<AuthenticationExceptionResponse>;

export function useLogsStatsSuspense<
  TData = Awaited<ReturnType<typeof logsStats>>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(
  logFile: string,
  options: {
    query: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof logsStats>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useLogsStatsSuspense<
  TData = Awaited<ReturnType<typeof logsStats>>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(
  logFile: string,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof logsStats>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useLogsStatsSuspense<
  TData = Awaited<ReturnType<typeof logsStats>>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(
  logFile: string,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof logsStats>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get comprehensive statistics for a log file
 */

export function useLogsStatsSuspense<
  TData = Awaited<ReturnType<typeof logsStats>>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(
  logFile: string,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof logsStats>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getLogsStatsSuspenseQueryOptions(logFile, options);

  const query = useSuspenseQuery(
    queryOptions,
    queryClient
  ) as UseSuspenseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getLogsStatsSuspenseInfiniteQueryOptions = <
  TData = InfiniteData<Awaited<ReturnType<typeof logsStats>>>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(
  logFile: string,
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof logsStats>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getLogsStatsInfiniteQueryKey(logFile);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof logsStats>>> = ({
    signal,
  }) => logsStats(logFile, requestOptions, signal);

  return {
    queryKey,
    queryFn,
    ...queryOptions,
  } as UseSuspenseInfiniteQueryOptions<
    Awaited<ReturnType<typeof logsStats>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type LogsStatsSuspenseInfiniteQueryResult = NonNullable<
  Awaited<ReturnType<typeof logsStats>>
>;
export type LogsStatsSuspenseInfiniteQueryError =
  ErrorType<AuthenticationExceptionResponse>;

export function useLogsStatsSuspenseInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof logsStats>>>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(
  logFile: string,
  options: {
    query: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof logsStats>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useLogsStatsSuspenseInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof logsStats>>>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(
  logFile: string,
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof logsStats>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useLogsStatsSuspenseInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof logsStats>>>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(
  logFile: string,
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof logsStats>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get comprehensive statistics for a log file
 */

export function useLogsStatsSuspenseInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof logsStats>>>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(
  logFile: string,
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof logsStats>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getLogsStatsSuspenseInfiniteQueryOptions(
    logFile,
    options
  );

  const query = useSuspenseInfiniteQuery(
    queryOptions,
    queryClient
  ) as UseSuspenseInfiniteQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Performs high-performance pattern matching within log files with support
for case-sensitive/insensitive searches and configurable result limits.
 * @summary Search for patterns within a log file
 */
export const logsSearch = (
  logFile: string,
  params: LogsSearchParams,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal
) => {
  return customInstance<LogsSearch200>(
    { url: `/api/logs/${logFile}/search`, method: "GET", params, signal },
    options
  );
};

export const getLogsSearchInfiniteQueryKey = (
  logFile?: string,
  params?: LogsSearchParams
) => {
  return [
    "infinite",
    `/api/logs/${logFile}/search`,
    ...(params ? [params] : []),
  ] as const;
};

export const getLogsSearchQueryKey = (
  logFile?: string,
  params?: LogsSearchParams
) => {
  return [`/api/logs/${logFile}/search`, ...(params ? [params] : [])] as const;
};

export const getLogsSearchInfiniteQueryOptions = <
  TData = InfiniteData<
    Awaited<ReturnType<typeof logsSearch>>,
    LogsSearchParams["page"]
  >,
  TError = ErrorType<
    AuthenticationExceptionResponse | ValidationExceptionResponse
  >
>(
  logFile: string,
  params: LogsSearchParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof logsSearch>>,
        TError,
        TData,
        QueryKey,
        LogsSearchParams["page"]
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getLogsSearchInfiniteQueryKey(logFile, params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof logsSearch>>,
    QueryKey,
    LogsSearchParams["page"]
  > = ({ signal, pageParam }) =>
    logsSearch(
      logFile,
      { ...params, page: pageParam || params?.["page"] },
      requestOptions,
      signal
    );

  return {
    queryKey,
    queryFn,
    enabled: !!logFile,
    ...queryOptions,
  } as UseInfiniteQueryOptions<
    Awaited<ReturnType<typeof logsSearch>>,
    TError,
    TData,
    QueryKey,
    LogsSearchParams["page"]
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type LogsSearchInfiniteQueryResult = NonNullable<
  Awaited<ReturnType<typeof logsSearch>>
>;
export type LogsSearchInfiniteQueryError = ErrorType<
  AuthenticationExceptionResponse | ValidationExceptionResponse
>;

export function useLogsSearchInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof logsSearch>>,
    LogsSearchParams["page"]
  >,
  TError = ErrorType<
    AuthenticationExceptionResponse | ValidationExceptionResponse
  >
>(
  logFile: string,
  params: LogsSearchParams,
  options: {
    query: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof logsSearch>>,
        TError,
        TData,
        QueryKey,
        LogsSearchParams["page"]
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof logsSearch>>,
          TError,
          Awaited<ReturnType<typeof logsSearch>>,
          QueryKey
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): DefinedUseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useLogsSearchInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof logsSearch>>,
    LogsSearchParams["page"]
  >,
  TError = ErrorType<
    AuthenticationExceptionResponse | ValidationExceptionResponse
  >
>(
  logFile: string,
  params: LogsSearchParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof logsSearch>>,
        TError,
        TData,
        QueryKey,
        LogsSearchParams["page"]
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof logsSearch>>,
          TError,
          Awaited<ReturnType<typeof logsSearch>>,
          QueryKey
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useLogsSearchInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof logsSearch>>,
    LogsSearchParams["page"]
  >,
  TError = ErrorType<
    AuthenticationExceptionResponse | ValidationExceptionResponse
  >
>(
  logFile: string,
  params: LogsSearchParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof logsSearch>>,
        TError,
        TData,
        QueryKey,
        LogsSearchParams["page"]
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Search for patterns within a log file
 */

export function useLogsSearchInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof logsSearch>>,
    LogsSearchParams["page"]
  >,
  TError = ErrorType<
    AuthenticationExceptionResponse | ValidationExceptionResponse
  >
>(
  logFile: string,
  params: LogsSearchParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof logsSearch>>,
        TError,
        TData,
        QueryKey,
        LogsSearchParams["page"]
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getLogsSearchInfiniteQueryOptions(
    logFile,
    params,
    options
  );

  const query = useInfiniteQuery(
    queryOptions,
    queryClient
  ) as UseInfiniteQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getLogsSearchQueryOptions = <
  TData = Awaited<ReturnType<typeof logsSearch>>,
  TError = ErrorType<
    AuthenticationExceptionResponse | ValidationExceptionResponse
  >
>(
  logFile: string,
  params: LogsSearchParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof logsSearch>>, TError, TData>
    >;
    request?: SecondParameter<typeof customInstance>;
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getLogsSearchQueryKey(logFile, params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof logsSearch>>> = ({
    signal,
  }) => logsSearch(logFile, params, requestOptions, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!logFile,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof logsSearch>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type LogsSearchQueryResult = NonNullable<
  Awaited<ReturnType<typeof logsSearch>>
>;
export type LogsSearchQueryError = ErrorType<
  AuthenticationExceptionResponse | ValidationExceptionResponse
>;

export function useLogsSearch<
  TData = Awaited<ReturnType<typeof logsSearch>>,
  TError = ErrorType<
    AuthenticationExceptionResponse | ValidationExceptionResponse
  >
>(
  logFile: string,
  params: LogsSearchParams,
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof logsSearch>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof logsSearch>>,
          TError,
          Awaited<ReturnType<typeof logsSearch>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useLogsSearch<
  TData = Awaited<ReturnType<typeof logsSearch>>,
  TError = ErrorType<
    AuthenticationExceptionResponse | ValidationExceptionResponse
  >
>(
  logFile: string,
  params: LogsSearchParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof logsSearch>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof logsSearch>>,
          TError,
          Awaited<ReturnType<typeof logsSearch>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useLogsSearch<
  TData = Awaited<ReturnType<typeof logsSearch>>,
  TError = ErrorType<
    AuthenticationExceptionResponse | ValidationExceptionResponse
  >
>(
  logFile: string,
  params: LogsSearchParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof logsSearch>>, TError, TData>
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Search for patterns within a log file
 */

export function useLogsSearch<
  TData = Awaited<ReturnType<typeof logsSearch>>,
  TError = ErrorType<
    AuthenticationExceptionResponse | ValidationExceptionResponse
  >
>(
  logFile: string,
  params: LogsSearchParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof logsSearch>>, TError, TData>
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getLogsSearchQueryOptions(logFile, params, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getLogsSearchSuspenseQueryOptions = <
  TData = Awaited<ReturnType<typeof logsSearch>>,
  TError = ErrorType<
    AuthenticationExceptionResponse | ValidationExceptionResponse
  >
>(
  logFile: string,
  params: LogsSearchParams,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof logsSearch>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getLogsSearchQueryKey(logFile, params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof logsSearch>>> = ({
    signal,
  }) => logsSearch(logFile, params, requestOptions, signal);

  return { queryKey, queryFn, ...queryOptions } as UseSuspenseQueryOptions<
    Awaited<ReturnType<typeof logsSearch>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type LogsSearchSuspenseQueryResult = NonNullable<
  Awaited<ReturnType<typeof logsSearch>>
>;
export type LogsSearchSuspenseQueryError = ErrorType<
  AuthenticationExceptionResponse | ValidationExceptionResponse
>;

export function useLogsSearchSuspense<
  TData = Awaited<ReturnType<typeof logsSearch>>,
  TError = ErrorType<
    AuthenticationExceptionResponse | ValidationExceptionResponse
  >
>(
  logFile: string,
  params: LogsSearchParams,
  options: {
    query: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof logsSearch>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useLogsSearchSuspense<
  TData = Awaited<ReturnType<typeof logsSearch>>,
  TError = ErrorType<
    AuthenticationExceptionResponse | ValidationExceptionResponse
  >
>(
  logFile: string,
  params: LogsSearchParams,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof logsSearch>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useLogsSearchSuspense<
  TData = Awaited<ReturnType<typeof logsSearch>>,
  TError = ErrorType<
    AuthenticationExceptionResponse | ValidationExceptionResponse
  >
>(
  logFile: string,
  params: LogsSearchParams,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof logsSearch>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Search for patterns within a log file
 */

export function useLogsSearchSuspense<
  TData = Awaited<ReturnType<typeof logsSearch>>,
  TError = ErrorType<
    AuthenticationExceptionResponse | ValidationExceptionResponse
  >
>(
  logFile: string,
  params: LogsSearchParams,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof logsSearch>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getLogsSearchSuspenseQueryOptions(
    logFile,
    params,
    options
  );

  const query = useSuspenseQuery(
    queryOptions,
    queryClient
  ) as UseSuspenseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getLogsSearchSuspenseInfiniteQueryOptions = <
  TData = InfiniteData<
    Awaited<ReturnType<typeof logsSearch>>,
    LogsSearchParams["page"]
  >,
  TError = ErrorType<
    AuthenticationExceptionResponse | ValidationExceptionResponse
  >
>(
  logFile: string,
  params: LogsSearchParams,
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof logsSearch>>,
        TError,
        TData,
        QueryKey,
        LogsSearchParams["page"]
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getLogsSearchInfiniteQueryKey(logFile, params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof logsSearch>>,
    QueryKey,
    LogsSearchParams["page"]
  > = ({ signal, pageParam }) =>
    logsSearch(
      logFile,
      { ...params, page: pageParam || params?.["page"] },
      requestOptions,
      signal
    );

  return {
    queryKey,
    queryFn,
    ...queryOptions,
  } as UseSuspenseInfiniteQueryOptions<
    Awaited<ReturnType<typeof logsSearch>>,
    TError,
    TData,
    QueryKey,
    LogsSearchParams["page"]
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type LogsSearchSuspenseInfiniteQueryResult = NonNullable<
  Awaited<ReturnType<typeof logsSearch>>
>;
export type LogsSearchSuspenseInfiniteQueryError = ErrorType<
  AuthenticationExceptionResponse | ValidationExceptionResponse
>;

export function useLogsSearchSuspenseInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof logsSearch>>,
    LogsSearchParams["page"]
  >,
  TError = ErrorType<
    AuthenticationExceptionResponse | ValidationExceptionResponse
  >
>(
  logFile: string,
  params: LogsSearchParams,
  options: {
    query: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof logsSearch>>,
        TError,
        TData,
        QueryKey,
        LogsSearchParams["page"]
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useLogsSearchSuspenseInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof logsSearch>>,
    LogsSearchParams["page"]
  >,
  TError = ErrorType<
    AuthenticationExceptionResponse | ValidationExceptionResponse
  >
>(
  logFile: string,
  params: LogsSearchParams,
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof logsSearch>>,
        TError,
        TData,
        QueryKey,
        LogsSearchParams["page"]
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useLogsSearchSuspenseInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof logsSearch>>,
    LogsSearchParams["page"]
  >,
  TError = ErrorType<
    AuthenticationExceptionResponse | ValidationExceptionResponse
  >
>(
  logFile: string,
  params: LogsSearchParams,
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof logsSearch>>,
        TError,
        TData,
        QueryKey,
        LogsSearchParams["page"]
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Search for patterns within a log file
 */

export function useLogsSearchSuspenseInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof logsSearch>>,
    LogsSearchParams["page"]
  >,
  TError = ErrorType<
    AuthenticationExceptionResponse | ValidationExceptionResponse
  >
>(
  logFile: string,
  params: LogsSearchParams,
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof logsSearch>>,
        TError,
        TData,
        QueryKey,
        LogsSearchParams["page"]
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getLogsSearchSuspenseInfiniteQueryOptions(
    logFile,
    params,
    options
  );

  const query = useSuspenseInfiniteQuery(
    queryOptions,
    queryClient
  ) as UseSuspenseInfiniteQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Provides direct download access to log files for offline analysis
or archival purposes. Returns the file as a plain text download.
 * @summary Download a log file
 */
export const logsDownload = (
  logFile: string,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal
) => {
  return customInstance<LogsDownload200>(
    { url: `/api/logs/${logFile}/download`, method: "GET", signal },
    options
  );
};

export const getLogsDownloadInfiniteQueryKey = (logFile?: string) => {
  return ["infinite", `/api/logs/${logFile}/download`] as const;
};

export const getLogsDownloadQueryKey = (logFile?: string) => {
  return [`/api/logs/${logFile}/download`] as const;
};

export const getLogsDownloadInfiniteQueryOptions = <
  TData = InfiniteData<Awaited<ReturnType<typeof logsDownload>>>,
  TError = ErrorType<
    AuthenticationExceptionResponse | ModelNotFoundExceptionResponse
  >
>(
  logFile: string,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof logsDownload>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getLogsDownloadInfiniteQueryKey(logFile);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof logsDownload>>> = ({
    signal,
  }) => logsDownload(logFile, requestOptions, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!logFile,
    ...queryOptions,
  } as UseInfiniteQueryOptions<
    Awaited<ReturnType<typeof logsDownload>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type LogsDownloadInfiniteQueryResult = NonNullable<
  Awaited<ReturnType<typeof logsDownload>>
>;
export type LogsDownloadInfiniteQueryError = ErrorType<
  AuthenticationExceptionResponse | ModelNotFoundExceptionResponse
>;

export function useLogsDownloadInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof logsDownload>>>,
  TError = ErrorType<
    AuthenticationExceptionResponse | ModelNotFoundExceptionResponse
  >
>(
  logFile: string,
  options: {
    query: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof logsDownload>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof logsDownload>>,
          TError,
          Awaited<ReturnType<typeof logsDownload>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): DefinedUseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useLogsDownloadInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof logsDownload>>>,
  TError = ErrorType<
    AuthenticationExceptionResponse | ModelNotFoundExceptionResponse
  >
>(
  logFile: string,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof logsDownload>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof logsDownload>>,
          TError,
          Awaited<ReturnType<typeof logsDownload>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useLogsDownloadInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof logsDownload>>>,
  TError = ErrorType<
    AuthenticationExceptionResponse | ModelNotFoundExceptionResponse
  >
>(
  logFile: string,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof logsDownload>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Download a log file
 */

export function useLogsDownloadInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof logsDownload>>>,
  TError = ErrorType<
    AuthenticationExceptionResponse | ModelNotFoundExceptionResponse
  >
>(
  logFile: string,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof logsDownload>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getLogsDownloadInfiniteQueryOptions(logFile, options);

  const query = useInfiniteQuery(
    queryOptions,
    queryClient
  ) as UseInfiniteQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getLogsDownloadQueryOptions = <
  TData = Awaited<ReturnType<typeof logsDownload>>,
  TError = ErrorType<
    AuthenticationExceptionResponse | ModelNotFoundExceptionResponse
  >
>(
  logFile: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof logsDownload>>, TError, TData>
    >;
    request?: SecondParameter<typeof customInstance>;
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getLogsDownloadQueryKey(logFile);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof logsDownload>>> = ({
    signal,
  }) => logsDownload(logFile, requestOptions, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!logFile,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof logsDownload>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type LogsDownloadQueryResult = NonNullable<
  Awaited<ReturnType<typeof logsDownload>>
>;
export type LogsDownloadQueryError = ErrorType<
  AuthenticationExceptionResponse | ModelNotFoundExceptionResponse
>;

export function useLogsDownload<
  TData = Awaited<ReturnType<typeof logsDownload>>,
  TError = ErrorType<
    AuthenticationExceptionResponse | ModelNotFoundExceptionResponse
  >
>(
  logFile: string,
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof logsDownload>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof logsDownload>>,
          TError,
          Awaited<ReturnType<typeof logsDownload>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useLogsDownload<
  TData = Awaited<ReturnType<typeof logsDownload>>,
  TError = ErrorType<
    AuthenticationExceptionResponse | ModelNotFoundExceptionResponse
  >
>(
  logFile: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof logsDownload>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof logsDownload>>,
          TError,
          Awaited<ReturnType<typeof logsDownload>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useLogsDownload<
  TData = Awaited<ReturnType<typeof logsDownload>>,
  TError = ErrorType<
    AuthenticationExceptionResponse | ModelNotFoundExceptionResponse
  >
>(
  logFile: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof logsDownload>>, TError, TData>
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Download a log file
 */

export function useLogsDownload<
  TData = Awaited<ReturnType<typeof logsDownload>>,
  TError = ErrorType<
    AuthenticationExceptionResponse | ModelNotFoundExceptionResponse
  >
>(
  logFile: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof logsDownload>>, TError, TData>
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getLogsDownloadQueryOptions(logFile, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getLogsDownloadSuspenseQueryOptions = <
  TData = Awaited<ReturnType<typeof logsDownload>>,
  TError = ErrorType<
    AuthenticationExceptionResponse | ModelNotFoundExceptionResponse
  >
>(
  logFile: string,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof logsDownload>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getLogsDownloadQueryKey(logFile);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof logsDownload>>> = ({
    signal,
  }) => logsDownload(logFile, requestOptions, signal);

  return { queryKey, queryFn, ...queryOptions } as UseSuspenseQueryOptions<
    Awaited<ReturnType<typeof logsDownload>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type LogsDownloadSuspenseQueryResult = NonNullable<
  Awaited<ReturnType<typeof logsDownload>>
>;
export type LogsDownloadSuspenseQueryError = ErrorType<
  AuthenticationExceptionResponse | ModelNotFoundExceptionResponse
>;

export function useLogsDownloadSuspense<
  TData = Awaited<ReturnType<typeof logsDownload>>,
  TError = ErrorType<
    AuthenticationExceptionResponse | ModelNotFoundExceptionResponse
  >
>(
  logFile: string,
  options: {
    query: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof logsDownload>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useLogsDownloadSuspense<
  TData = Awaited<ReturnType<typeof logsDownload>>,
  TError = ErrorType<
    AuthenticationExceptionResponse | ModelNotFoundExceptionResponse
  >
>(
  logFile: string,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof logsDownload>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useLogsDownloadSuspense<
  TData = Awaited<ReturnType<typeof logsDownload>>,
  TError = ErrorType<
    AuthenticationExceptionResponse | ModelNotFoundExceptionResponse
  >
>(
  logFile: string,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof logsDownload>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Download a log file
 */

export function useLogsDownloadSuspense<
  TData = Awaited<ReturnType<typeof logsDownload>>,
  TError = ErrorType<
    AuthenticationExceptionResponse | ModelNotFoundExceptionResponse
  >
>(
  logFile: string,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof logsDownload>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getLogsDownloadSuspenseQueryOptions(logFile, options);

  const query = useSuspenseQuery(
    queryOptions,
    queryClient
  ) as UseSuspenseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getLogsDownloadSuspenseInfiniteQueryOptions = <
  TData = InfiniteData<Awaited<ReturnType<typeof logsDownload>>>,
  TError = ErrorType<
    AuthenticationExceptionResponse | ModelNotFoundExceptionResponse
  >
>(
  logFile: string,
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof logsDownload>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getLogsDownloadInfiniteQueryKey(logFile);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof logsDownload>>> = ({
    signal,
  }) => logsDownload(logFile, requestOptions, signal);

  return {
    queryKey,
    queryFn,
    ...queryOptions,
  } as UseSuspenseInfiniteQueryOptions<
    Awaited<ReturnType<typeof logsDownload>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type LogsDownloadSuspenseInfiniteQueryResult = NonNullable<
  Awaited<ReturnType<typeof logsDownload>>
>;
export type LogsDownloadSuspenseInfiniteQueryError = ErrorType<
  AuthenticationExceptionResponse | ModelNotFoundExceptionResponse
>;

export function useLogsDownloadSuspenseInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof logsDownload>>>,
  TError = ErrorType<
    AuthenticationExceptionResponse | ModelNotFoundExceptionResponse
  >
>(
  logFile: string,
  options: {
    query: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof logsDownload>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useLogsDownloadSuspenseInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof logsDownload>>>,
  TError = ErrorType<
    AuthenticationExceptionResponse | ModelNotFoundExceptionResponse
  >
>(
  logFile: string,
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof logsDownload>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useLogsDownloadSuspenseInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof logsDownload>>>,
  TError = ErrorType<
    AuthenticationExceptionResponse | ModelNotFoundExceptionResponse
  >
>(
  logFile: string,
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof logsDownload>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Download a log file
 */

export function useLogsDownloadSuspenseInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof logsDownload>>>,
  TError = ErrorType<
    AuthenticationExceptionResponse | ModelNotFoundExceptionResponse
  >
>(
  logFile: string,
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof logsDownload>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getLogsDownloadSuspenseInfiniteQueryOptions(
    logFile,
    options
  );

  const query = useSuspenseInfiniteQuery(
    queryOptions,
    queryClient
  ) as UseSuspenseInfiniteQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Performs pattern matching across multiple log files in parallel,
providing consolidated search results with performance metrics
and per-file result breakdowns.
 * @summary Search across multiple log files simultaneously
 */
export const logsSearchAll = (
  params: LogsSearchAllParams,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal
) => {
  return customInstance<LogsSearchAll200>(
    { url: `/api/logs/search/all`, method: "GET", params, signal },
    options
  );
};

export const getLogsSearchAllInfiniteQueryKey = (
  params?: LogsSearchAllParams
) => {
  return [
    "infinite",
    `/api/logs/search/all`,
    ...(params ? [params] : []),
  ] as const;
};

export const getLogsSearchAllQueryKey = (params?: LogsSearchAllParams) => {
  return [`/api/logs/search/all`, ...(params ? [params] : [])] as const;
};

export const getLogsSearchAllInfiniteQueryOptions = <
  TData = InfiniteData<
    Awaited<ReturnType<typeof logsSearchAll>>,
    LogsSearchAllParams["page"]
  >,
  TError = ErrorType<
    AuthenticationExceptionResponse | ValidationExceptionResponse
  >
>(
  params: LogsSearchAllParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof logsSearchAll>>,
        TError,
        TData,
        QueryKey,
        LogsSearchAllParams["page"]
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getLogsSearchAllInfiniteQueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof logsSearchAll>>,
    QueryKey,
    LogsSearchAllParams["page"]
  > = ({ signal, pageParam }) =>
    logsSearchAll(
      { ...params, page: pageParam || params?.["page"] },
      requestOptions,
      signal
    );

  return { queryKey, queryFn, ...queryOptions } as UseInfiniteQueryOptions<
    Awaited<ReturnType<typeof logsSearchAll>>,
    TError,
    TData,
    QueryKey,
    LogsSearchAllParams["page"]
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type LogsSearchAllInfiniteQueryResult = NonNullable<
  Awaited<ReturnType<typeof logsSearchAll>>
>;
export type LogsSearchAllInfiniteQueryError = ErrorType<
  AuthenticationExceptionResponse | ValidationExceptionResponse
>;

export function useLogsSearchAllInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof logsSearchAll>>,
    LogsSearchAllParams["page"]
  >,
  TError = ErrorType<
    AuthenticationExceptionResponse | ValidationExceptionResponse
  >
>(
  params: LogsSearchAllParams,
  options: {
    query: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof logsSearchAll>>,
        TError,
        TData,
        QueryKey,
        LogsSearchAllParams["page"]
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof logsSearchAll>>,
          TError,
          Awaited<ReturnType<typeof logsSearchAll>>,
          QueryKey
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): DefinedUseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useLogsSearchAllInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof logsSearchAll>>,
    LogsSearchAllParams["page"]
  >,
  TError = ErrorType<
    AuthenticationExceptionResponse | ValidationExceptionResponse
  >
>(
  params: LogsSearchAllParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof logsSearchAll>>,
        TError,
        TData,
        QueryKey,
        LogsSearchAllParams["page"]
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof logsSearchAll>>,
          TError,
          Awaited<ReturnType<typeof logsSearchAll>>,
          QueryKey
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useLogsSearchAllInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof logsSearchAll>>,
    LogsSearchAllParams["page"]
  >,
  TError = ErrorType<
    AuthenticationExceptionResponse | ValidationExceptionResponse
  >
>(
  params: LogsSearchAllParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof logsSearchAll>>,
        TError,
        TData,
        QueryKey,
        LogsSearchAllParams["page"]
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Search across multiple log files simultaneously
 */

export function useLogsSearchAllInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof logsSearchAll>>,
    LogsSearchAllParams["page"]
  >,
  TError = ErrorType<
    AuthenticationExceptionResponse | ValidationExceptionResponse
  >
>(
  params: LogsSearchAllParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof logsSearchAll>>,
        TError,
        TData,
        QueryKey,
        LogsSearchAllParams["page"]
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getLogsSearchAllInfiniteQueryOptions(params, options);

  const query = useInfiniteQuery(
    queryOptions,
    queryClient
  ) as UseInfiniteQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getLogsSearchAllQueryOptions = <
  TData = Awaited<ReturnType<typeof logsSearchAll>>,
  TError = ErrorType<
    AuthenticationExceptionResponse | ValidationExceptionResponse
  >
>(
  params: LogsSearchAllParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof logsSearchAll>>, TError, TData>
    >;
    request?: SecondParameter<typeof customInstance>;
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getLogsSearchAllQueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof logsSearchAll>>> = ({
    signal,
  }) => logsSearchAll(params, requestOptions, signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof logsSearchAll>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type LogsSearchAllQueryResult = NonNullable<
  Awaited<ReturnType<typeof logsSearchAll>>
>;
export type LogsSearchAllQueryError = ErrorType<
  AuthenticationExceptionResponse | ValidationExceptionResponse
>;

export function useLogsSearchAll<
  TData = Awaited<ReturnType<typeof logsSearchAll>>,
  TError = ErrorType<
    AuthenticationExceptionResponse | ValidationExceptionResponse
  >
>(
  params: LogsSearchAllParams,
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof logsSearchAll>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof logsSearchAll>>,
          TError,
          Awaited<ReturnType<typeof logsSearchAll>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useLogsSearchAll<
  TData = Awaited<ReturnType<typeof logsSearchAll>>,
  TError = ErrorType<
    AuthenticationExceptionResponse | ValidationExceptionResponse
  >
>(
  params: LogsSearchAllParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof logsSearchAll>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof logsSearchAll>>,
          TError,
          Awaited<ReturnType<typeof logsSearchAll>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useLogsSearchAll<
  TData = Awaited<ReturnType<typeof logsSearchAll>>,
  TError = ErrorType<
    AuthenticationExceptionResponse | ValidationExceptionResponse
  >
>(
  params: LogsSearchAllParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof logsSearchAll>>, TError, TData>
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Search across multiple log files simultaneously
 */

export function useLogsSearchAll<
  TData = Awaited<ReturnType<typeof logsSearchAll>>,
  TError = ErrorType<
    AuthenticationExceptionResponse | ValidationExceptionResponse
  >
>(
  params: LogsSearchAllParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof logsSearchAll>>, TError, TData>
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getLogsSearchAllQueryOptions(params, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getLogsSearchAllSuspenseQueryOptions = <
  TData = Awaited<ReturnType<typeof logsSearchAll>>,
  TError = ErrorType<
    AuthenticationExceptionResponse | ValidationExceptionResponse
  >
>(
  params: LogsSearchAllParams,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof logsSearchAll>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getLogsSearchAllQueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof logsSearchAll>>> = ({
    signal,
  }) => logsSearchAll(params, requestOptions, signal);

  return { queryKey, queryFn, ...queryOptions } as UseSuspenseQueryOptions<
    Awaited<ReturnType<typeof logsSearchAll>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type LogsSearchAllSuspenseQueryResult = NonNullable<
  Awaited<ReturnType<typeof logsSearchAll>>
>;
export type LogsSearchAllSuspenseQueryError = ErrorType<
  AuthenticationExceptionResponse | ValidationExceptionResponse
>;

export function useLogsSearchAllSuspense<
  TData = Awaited<ReturnType<typeof logsSearchAll>>,
  TError = ErrorType<
    AuthenticationExceptionResponse | ValidationExceptionResponse
  >
>(
  params: LogsSearchAllParams,
  options: {
    query: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof logsSearchAll>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useLogsSearchAllSuspense<
  TData = Awaited<ReturnType<typeof logsSearchAll>>,
  TError = ErrorType<
    AuthenticationExceptionResponse | ValidationExceptionResponse
  >
>(
  params: LogsSearchAllParams,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof logsSearchAll>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useLogsSearchAllSuspense<
  TData = Awaited<ReturnType<typeof logsSearchAll>>,
  TError = ErrorType<
    AuthenticationExceptionResponse | ValidationExceptionResponse
  >
>(
  params: LogsSearchAllParams,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof logsSearchAll>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Search across multiple log files simultaneously
 */

export function useLogsSearchAllSuspense<
  TData = Awaited<ReturnType<typeof logsSearchAll>>,
  TError = ErrorType<
    AuthenticationExceptionResponse | ValidationExceptionResponse
  >
>(
  params: LogsSearchAllParams,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof logsSearchAll>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getLogsSearchAllSuspenseQueryOptions(params, options);

  const query = useSuspenseQuery(
    queryOptions,
    queryClient
  ) as UseSuspenseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getLogsSearchAllSuspenseInfiniteQueryOptions = <
  TData = InfiniteData<
    Awaited<ReturnType<typeof logsSearchAll>>,
    LogsSearchAllParams["page"]
  >,
  TError = ErrorType<
    AuthenticationExceptionResponse | ValidationExceptionResponse
  >
>(
  params: LogsSearchAllParams,
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof logsSearchAll>>,
        TError,
        TData,
        QueryKey,
        LogsSearchAllParams["page"]
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getLogsSearchAllInfiniteQueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof logsSearchAll>>,
    QueryKey,
    LogsSearchAllParams["page"]
  > = ({ signal, pageParam }) =>
    logsSearchAll(
      { ...params, page: pageParam || params?.["page"] },
      requestOptions,
      signal
    );

  return {
    queryKey,
    queryFn,
    ...queryOptions,
  } as UseSuspenseInfiniteQueryOptions<
    Awaited<ReturnType<typeof logsSearchAll>>,
    TError,
    TData,
    QueryKey,
    LogsSearchAllParams["page"]
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type LogsSearchAllSuspenseInfiniteQueryResult = NonNullable<
  Awaited<ReturnType<typeof logsSearchAll>>
>;
export type LogsSearchAllSuspenseInfiniteQueryError = ErrorType<
  AuthenticationExceptionResponse | ValidationExceptionResponse
>;

export function useLogsSearchAllSuspenseInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof logsSearchAll>>,
    LogsSearchAllParams["page"]
  >,
  TError = ErrorType<
    AuthenticationExceptionResponse | ValidationExceptionResponse
  >
>(
  params: LogsSearchAllParams,
  options: {
    query: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof logsSearchAll>>,
        TError,
        TData,
        QueryKey,
        LogsSearchAllParams["page"]
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useLogsSearchAllSuspenseInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof logsSearchAll>>,
    LogsSearchAllParams["page"]
  >,
  TError = ErrorType<
    AuthenticationExceptionResponse | ValidationExceptionResponse
  >
>(
  params: LogsSearchAllParams,
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof logsSearchAll>>,
        TError,
        TData,
        QueryKey,
        LogsSearchAllParams["page"]
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useLogsSearchAllSuspenseInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof logsSearchAll>>,
    LogsSearchAllParams["page"]
  >,
  TError = ErrorType<
    AuthenticationExceptionResponse | ValidationExceptionResponse
  >
>(
  params: LogsSearchAllParams,
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof logsSearchAll>>,
        TError,
        TData,
        QueryKey,
        LogsSearchAllParams["page"]
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Search across multiple log files simultaneously
 */

export function useLogsSearchAllSuspenseInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof logsSearchAll>>,
    LogsSearchAllParams["page"]
  >,
  TError = ErrorType<
    AuthenticationExceptionResponse | ValidationExceptionResponse
  >
>(
  params: LogsSearchAllParams,
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof logsSearchAll>>,
        TError,
        TData,
        QueryKey,
        LogsSearchAllParams["page"]
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getLogsSearchAllSuspenseInfiniteQueryOptions(
    params,
    options
  );

  const query = useSuspenseInfiniteQuery(
    queryOptions,
    queryClient
  ) as UseSuspenseInfiniteQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Get status
 */
export const opCacheGetStatus = (
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal
) => {
  return customInstance<OpCacheGetStatus200>(
    { url: `/api/opcache/status`, method: "GET", signal },
    options
  );
};

export const getOpCacheGetStatusInfiniteQueryKey = () => {
  return ["infinite", `/api/opcache/status`] as const;
};

export const getOpCacheGetStatusQueryKey = () => {
  return [`/api/opcache/status`] as const;
};

export const getOpCacheGetStatusInfiniteQueryOptions = <
  TData = InfiniteData<Awaited<ReturnType<typeof opCacheGetStatus>>>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(options?: {
  query?: Partial<
    UseInfiniteQueryOptions<
      Awaited<ReturnType<typeof opCacheGetStatus>>,
      TError,
      TData
    >
  >;
  request?: SecondParameter<typeof customInstance>;
}) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getOpCacheGetStatusInfiniteQueryKey();

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof opCacheGetStatus>>
  > = ({ signal }) => opCacheGetStatus(requestOptions, signal);

  return { queryKey, queryFn, ...queryOptions } as UseInfiniteQueryOptions<
    Awaited<ReturnType<typeof opCacheGetStatus>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type OpCacheGetStatusInfiniteQueryResult = NonNullable<
  Awaited<ReturnType<typeof opCacheGetStatus>>
>;
export type OpCacheGetStatusInfiniteQueryError =
  ErrorType<AuthenticationExceptionResponse>;

export function useOpCacheGetStatusInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof opCacheGetStatus>>>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(
  options: {
    query: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof opCacheGetStatus>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof opCacheGetStatus>>,
          TError,
          Awaited<ReturnType<typeof opCacheGetStatus>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): DefinedUseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useOpCacheGetStatusInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof opCacheGetStatus>>>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof opCacheGetStatus>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof opCacheGetStatus>>,
          TError,
          Awaited<ReturnType<typeof opCacheGetStatus>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useOpCacheGetStatusInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof opCacheGetStatus>>>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof opCacheGetStatus>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get status
 */

export function useOpCacheGetStatusInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof opCacheGetStatus>>>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof opCacheGetStatus>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getOpCacheGetStatusInfiniteQueryOptions(options);

  const query = useInfiniteQuery(
    queryOptions,
    queryClient
  ) as UseInfiniteQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getOpCacheGetStatusQueryOptions = <
  TData = Awaited<ReturnType<typeof opCacheGetStatus>>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof opCacheGetStatus>>, TError, TData>
  >;
  request?: SecondParameter<typeof customInstance>;
}) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getOpCacheGetStatusQueryKey();

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof opCacheGetStatus>>
  > = ({ signal }) => opCacheGetStatus(requestOptions, signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof opCacheGetStatus>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type OpCacheGetStatusQueryResult = NonNullable<
  Awaited<ReturnType<typeof opCacheGetStatus>>
>;
export type OpCacheGetStatusQueryError =
  ErrorType<AuthenticationExceptionResponse>;

export function useOpCacheGetStatus<
  TData = Awaited<ReturnType<typeof opCacheGetStatus>>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof opCacheGetStatus>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof opCacheGetStatus>>,
          TError,
          Awaited<ReturnType<typeof opCacheGetStatus>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useOpCacheGetStatus<
  TData = Awaited<ReturnType<typeof opCacheGetStatus>>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof opCacheGetStatus>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof opCacheGetStatus>>,
          TError,
          Awaited<ReturnType<typeof opCacheGetStatus>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useOpCacheGetStatus<
  TData = Awaited<ReturnType<typeof opCacheGetStatus>>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof opCacheGetStatus>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get status
 */

export function useOpCacheGetStatus<
  TData = Awaited<ReturnType<typeof opCacheGetStatus>>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof opCacheGetStatus>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getOpCacheGetStatusQueryOptions(options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getOpCacheGetStatusSuspenseQueryOptions = <
  TData = Awaited<ReturnType<typeof opCacheGetStatus>>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(options?: {
  query?: Partial<
    UseSuspenseQueryOptions<
      Awaited<ReturnType<typeof opCacheGetStatus>>,
      TError,
      TData
    >
  >;
  request?: SecondParameter<typeof customInstance>;
}) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getOpCacheGetStatusQueryKey();

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof opCacheGetStatus>>
  > = ({ signal }) => opCacheGetStatus(requestOptions, signal);

  return { queryKey, queryFn, ...queryOptions } as UseSuspenseQueryOptions<
    Awaited<ReturnType<typeof opCacheGetStatus>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type OpCacheGetStatusSuspenseQueryResult = NonNullable<
  Awaited<ReturnType<typeof opCacheGetStatus>>
>;
export type OpCacheGetStatusSuspenseQueryError =
  ErrorType<AuthenticationExceptionResponse>;

export function useOpCacheGetStatusSuspense<
  TData = Awaited<ReturnType<typeof opCacheGetStatus>>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(
  options: {
    query: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof opCacheGetStatus>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useOpCacheGetStatusSuspense<
  TData = Awaited<ReturnType<typeof opCacheGetStatus>>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof opCacheGetStatus>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useOpCacheGetStatusSuspense<
  TData = Awaited<ReturnType<typeof opCacheGetStatus>>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof opCacheGetStatus>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get status
 */

export function useOpCacheGetStatusSuspense<
  TData = Awaited<ReturnType<typeof opCacheGetStatus>>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof opCacheGetStatus>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getOpCacheGetStatusSuspenseQueryOptions(options);

  const query = useSuspenseQuery(
    queryOptions,
    queryClient
  ) as UseSuspenseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getOpCacheGetStatusSuspenseInfiniteQueryOptions = <
  TData = InfiniteData<Awaited<ReturnType<typeof opCacheGetStatus>>>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(options?: {
  query?: Partial<
    UseSuspenseInfiniteQueryOptions<
      Awaited<ReturnType<typeof opCacheGetStatus>>,
      TError,
      TData
    >
  >;
  request?: SecondParameter<typeof customInstance>;
}) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getOpCacheGetStatusInfiniteQueryKey();

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof opCacheGetStatus>>
  > = ({ signal }) => opCacheGetStatus(requestOptions, signal);

  return {
    queryKey,
    queryFn,
    ...queryOptions,
  } as UseSuspenseInfiniteQueryOptions<
    Awaited<ReturnType<typeof opCacheGetStatus>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type OpCacheGetStatusSuspenseInfiniteQueryResult = NonNullable<
  Awaited<ReturnType<typeof opCacheGetStatus>>
>;
export type OpCacheGetStatusSuspenseInfiniteQueryError =
  ErrorType<AuthenticationExceptionResponse>;

export function useOpCacheGetStatusSuspenseInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof opCacheGetStatus>>>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(
  options: {
    query: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof opCacheGetStatus>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useOpCacheGetStatusSuspenseInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof opCacheGetStatus>>>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof opCacheGetStatus>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useOpCacheGetStatusSuspenseInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof opCacheGetStatus>>>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof opCacheGetStatus>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get status
 */

export function useOpCacheGetStatusSuspenseInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof opCacheGetStatus>>>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof opCacheGetStatus>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getOpCacheGetStatusSuspenseInfiniteQueryOptions(options);

  const query = useSuspenseInfiniteQuery(
    queryOptions,
    queryClient
  ) as UseSuspenseInfiniteQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Get config
 */
export const opcacheGetConfig = (
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal
) => {
  return customInstance<OpcacheGetConfig200>(
    { url: `/api/opcache/config`, method: "GET", signal },
    options
  );
};

export const getOpcacheGetConfigInfiniteQueryKey = () => {
  return ["infinite", `/api/opcache/config`] as const;
};

export const getOpcacheGetConfigQueryKey = () => {
  return [`/api/opcache/config`] as const;
};

export const getOpcacheGetConfigInfiniteQueryOptions = <
  TData = InfiniteData<Awaited<ReturnType<typeof opcacheGetConfig>>>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(options?: {
  query?: Partial<
    UseInfiniteQueryOptions<
      Awaited<ReturnType<typeof opcacheGetConfig>>,
      TError,
      TData
    >
  >;
  request?: SecondParameter<typeof customInstance>;
}) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getOpcacheGetConfigInfiniteQueryKey();

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof opcacheGetConfig>>
  > = ({ signal }) => opcacheGetConfig(requestOptions, signal);

  return { queryKey, queryFn, ...queryOptions } as UseInfiniteQueryOptions<
    Awaited<ReturnType<typeof opcacheGetConfig>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type OpcacheGetConfigInfiniteQueryResult = NonNullable<
  Awaited<ReturnType<typeof opcacheGetConfig>>
>;
export type OpcacheGetConfigInfiniteQueryError =
  ErrorType<AuthenticationExceptionResponse>;

export function useOpcacheGetConfigInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof opcacheGetConfig>>>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(
  options: {
    query: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof opcacheGetConfig>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof opcacheGetConfig>>,
          TError,
          Awaited<ReturnType<typeof opcacheGetConfig>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): DefinedUseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useOpcacheGetConfigInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof opcacheGetConfig>>>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof opcacheGetConfig>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof opcacheGetConfig>>,
          TError,
          Awaited<ReturnType<typeof opcacheGetConfig>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useOpcacheGetConfigInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof opcacheGetConfig>>>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof opcacheGetConfig>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get config
 */

export function useOpcacheGetConfigInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof opcacheGetConfig>>>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof opcacheGetConfig>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getOpcacheGetConfigInfiniteQueryOptions(options);

  const query = useInfiniteQuery(
    queryOptions,
    queryClient
  ) as UseInfiniteQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getOpcacheGetConfigQueryOptions = <
  TData = Awaited<ReturnType<typeof opcacheGetConfig>>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof opcacheGetConfig>>, TError, TData>
  >;
  request?: SecondParameter<typeof customInstance>;
}) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getOpcacheGetConfigQueryKey();

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof opcacheGetConfig>>
  > = ({ signal }) => opcacheGetConfig(requestOptions, signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof opcacheGetConfig>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type OpcacheGetConfigQueryResult = NonNullable<
  Awaited<ReturnType<typeof opcacheGetConfig>>
>;
export type OpcacheGetConfigQueryError =
  ErrorType<AuthenticationExceptionResponse>;

export function useOpcacheGetConfig<
  TData = Awaited<ReturnType<typeof opcacheGetConfig>>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof opcacheGetConfig>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof opcacheGetConfig>>,
          TError,
          Awaited<ReturnType<typeof opcacheGetConfig>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useOpcacheGetConfig<
  TData = Awaited<ReturnType<typeof opcacheGetConfig>>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof opcacheGetConfig>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof opcacheGetConfig>>,
          TError,
          Awaited<ReturnType<typeof opcacheGetConfig>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useOpcacheGetConfig<
  TData = Awaited<ReturnType<typeof opcacheGetConfig>>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof opcacheGetConfig>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get config
 */

export function useOpcacheGetConfig<
  TData = Awaited<ReturnType<typeof opcacheGetConfig>>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof opcacheGetConfig>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getOpcacheGetConfigQueryOptions(options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getOpcacheGetConfigSuspenseQueryOptions = <
  TData = Awaited<ReturnType<typeof opcacheGetConfig>>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(options?: {
  query?: Partial<
    UseSuspenseQueryOptions<
      Awaited<ReturnType<typeof opcacheGetConfig>>,
      TError,
      TData
    >
  >;
  request?: SecondParameter<typeof customInstance>;
}) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getOpcacheGetConfigQueryKey();

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof opcacheGetConfig>>
  > = ({ signal }) => opcacheGetConfig(requestOptions, signal);

  return { queryKey, queryFn, ...queryOptions } as UseSuspenseQueryOptions<
    Awaited<ReturnType<typeof opcacheGetConfig>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type OpcacheGetConfigSuspenseQueryResult = NonNullable<
  Awaited<ReturnType<typeof opcacheGetConfig>>
>;
export type OpcacheGetConfigSuspenseQueryError =
  ErrorType<AuthenticationExceptionResponse>;

export function useOpcacheGetConfigSuspense<
  TData = Awaited<ReturnType<typeof opcacheGetConfig>>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(
  options: {
    query: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof opcacheGetConfig>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useOpcacheGetConfigSuspense<
  TData = Awaited<ReturnType<typeof opcacheGetConfig>>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof opcacheGetConfig>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useOpcacheGetConfigSuspense<
  TData = Awaited<ReturnType<typeof opcacheGetConfig>>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof opcacheGetConfig>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get config
 */

export function useOpcacheGetConfigSuspense<
  TData = Awaited<ReturnType<typeof opcacheGetConfig>>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof opcacheGetConfig>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getOpcacheGetConfigSuspenseQueryOptions(options);

  const query = useSuspenseQuery(
    queryOptions,
    queryClient
  ) as UseSuspenseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getOpcacheGetConfigSuspenseInfiniteQueryOptions = <
  TData = InfiniteData<Awaited<ReturnType<typeof opcacheGetConfig>>>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(options?: {
  query?: Partial<
    UseSuspenseInfiniteQueryOptions<
      Awaited<ReturnType<typeof opcacheGetConfig>>,
      TError,
      TData
    >
  >;
  request?: SecondParameter<typeof customInstance>;
}) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getOpcacheGetConfigInfiniteQueryKey();

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof opcacheGetConfig>>
  > = ({ signal }) => opcacheGetConfig(requestOptions, signal);

  return {
    queryKey,
    queryFn,
    ...queryOptions,
  } as UseSuspenseInfiniteQueryOptions<
    Awaited<ReturnType<typeof opcacheGetConfig>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type OpcacheGetConfigSuspenseInfiniteQueryResult = NonNullable<
  Awaited<ReturnType<typeof opcacheGetConfig>>
>;
export type OpcacheGetConfigSuspenseInfiniteQueryError =
  ErrorType<AuthenticationExceptionResponse>;

export function useOpcacheGetConfigSuspenseInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof opcacheGetConfig>>>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(
  options: {
    query: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof opcacheGetConfig>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useOpcacheGetConfigSuspenseInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof opcacheGetConfig>>>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof opcacheGetConfig>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useOpcacheGetConfigSuspenseInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof opcacheGetConfig>>>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof opcacheGetConfig>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get config
 */

export function useOpcacheGetConfigSuspenseInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof opcacheGetConfig>>>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof opcacheGetConfig>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getOpcacheGetConfigSuspenseInfiniteQueryOptions(options);

  const query = useSuspenseInfiniteQuery(
    queryOptions,
    queryClient
  ) as UseSuspenseInfiniteQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Clear
 */
export const opcacheClear = (
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal
) => {
  return customInstance<OpcacheClear200>(
    { url: `/api/opcache/clear`, method: "POST", signal },
    options
  );
};

export const getOpcacheClearMutationOptions = <
  TError = ErrorType<AuthenticationExceptionResponse>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof opcacheClear>>,
    TError,
    void,
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof opcacheClear>>,
  TError,
  void,
  TContext
> => {
  const mutationKey = ["opcacheClear"];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof opcacheClear>>,
    void
  > = () => {
    return opcacheClear(requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type OpcacheClearMutationResult = NonNullable<
  Awaited<ReturnType<typeof opcacheClear>>
>;

export type OpcacheClearMutationError =
  ErrorType<AuthenticationExceptionResponse>;

/**
 * @summary Clear
 */
export const useOpcacheClear = <
  TError = ErrorType<AuthenticationExceptionResponse>,
  TContext = unknown
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof opcacheClear>>,
      TError,
      void,
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof opcacheClear>>,
  TError,
  void,
  TContext
> => {
  const mutationOptions = getOpcacheClearMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
/**
 * @summary Compile cache
 */
export const opcacheCompile = (
  params?: OpcacheCompileParams,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal
) => {
  return customInstance<OpcacheCompile200>(
    { url: `/api/opcache/compile`, method: "POST", params, signal },
    options
  );
};

export const getOpcacheCompileMutationOptions = <
  TError = ErrorType<AuthenticationExceptionResponse>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof opcacheCompile>>,
    TError,
    { params?: OpcacheCompileParams },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof opcacheCompile>>,
  TError,
  { params?: OpcacheCompileParams },
  TContext
> => {
  const mutationKey = ["opcacheCompile"];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof opcacheCompile>>,
    { params?: OpcacheCompileParams }
  > = (props) => {
    const { params } = props ?? {};

    return opcacheCompile(params, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type OpcacheCompileMutationResult = NonNullable<
  Awaited<ReturnType<typeof opcacheCompile>>
>;

export type OpcacheCompileMutationError =
  ErrorType<AuthenticationExceptionResponse>;

/**
 * @summary Compile cache
 */
export const useOpcacheCompile = <
  TError = ErrorType<AuthenticationExceptionResponse>,
  TContext = unknown
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof opcacheCompile>>,
      TError,
      { params?: OpcacheCompileParams },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof opcacheCompile>>,
  TError,
  { params?: OpcacheCompileParams },
  TContext
> => {
  const mutationOptions = getOpcacheCompileMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
/**
 * Returns filtered and paginated queue job monitoring data with support for
filtering by status, queue name, job name, and custom ordering options.
Provides comprehensive job execution tracking and debugging information.
 * @summary Get paginated collection of queue monitor entries
 */
export const queueMetricsShow = (
  params?: QueueMetricsShowParams,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal
) => {
  return customInstance<QueueMetricsShow200>(
    { url: `/api/queue-metrics`, method: "GET", params, signal },
    options
  );
};

export const getQueueMetricsShowInfiniteQueryKey = (
  params?: QueueMetricsShowParams
) => {
  return [
    "infinite",
    `/api/queue-metrics`,
    ...(params ? [params] : []),
  ] as const;
};

export const getQueueMetricsShowQueryKey = (
  params?: QueueMetricsShowParams
) => {
  return [`/api/queue-metrics`, ...(params ? [params] : [])] as const;
};

export const getQueueMetricsShowInfiniteQueryOptions = <
  TData = InfiniteData<
    Awaited<ReturnType<typeof queueMetricsShow>>,
    QueueMetricsShowParams["page"]
  >,
  TError = ErrorType<
    | AuthenticationExceptionResponse
    | AuthorizationExceptionResponse
    | ValidationExceptionResponse
  >
>(
  params?: QueueMetricsShowParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof queueMetricsShow>>,
        TError,
        TData,
        QueryKey,
        QueueMetricsShowParams["page"]
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getQueueMetricsShowInfiniteQueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof queueMetricsShow>>,
    QueryKey,
    QueueMetricsShowParams["page"]
  > = ({ signal, pageParam }) =>
    queueMetricsShow(
      { ...params, page: pageParam || params?.["page"] },
      requestOptions,
      signal
    );

  return { queryKey, queryFn, ...queryOptions } as UseInfiniteQueryOptions<
    Awaited<ReturnType<typeof queueMetricsShow>>,
    TError,
    TData,
    QueryKey,
    QueueMetricsShowParams["page"]
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type QueueMetricsShowInfiniteQueryResult = NonNullable<
  Awaited<ReturnType<typeof queueMetricsShow>>
>;
export type QueueMetricsShowInfiniteQueryError = ErrorType<
  | AuthenticationExceptionResponse
  | AuthorizationExceptionResponse
  | ValidationExceptionResponse
>;

export function useQueueMetricsShowInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof queueMetricsShow>>,
    QueueMetricsShowParams["page"]
  >,
  TError = ErrorType<
    | AuthenticationExceptionResponse
    | AuthorizationExceptionResponse
    | ValidationExceptionResponse
  >
>(
  params: undefined | QueueMetricsShowParams,
  options: {
    query: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof queueMetricsShow>>,
        TError,
        TData,
        QueryKey,
        QueueMetricsShowParams["page"]
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof queueMetricsShow>>,
          TError,
          Awaited<ReturnType<typeof queueMetricsShow>>,
          QueryKey
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): DefinedUseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useQueueMetricsShowInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof queueMetricsShow>>,
    QueueMetricsShowParams["page"]
  >,
  TError = ErrorType<
    | AuthenticationExceptionResponse
    | AuthorizationExceptionResponse
    | ValidationExceptionResponse
  >
>(
  params?: QueueMetricsShowParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof queueMetricsShow>>,
        TError,
        TData,
        QueryKey,
        QueueMetricsShowParams["page"]
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof queueMetricsShow>>,
          TError,
          Awaited<ReturnType<typeof queueMetricsShow>>,
          QueryKey
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useQueueMetricsShowInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof queueMetricsShow>>,
    QueueMetricsShowParams["page"]
  >,
  TError = ErrorType<
    | AuthenticationExceptionResponse
    | AuthorizationExceptionResponse
    | ValidationExceptionResponse
  >
>(
  params?: QueueMetricsShowParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof queueMetricsShow>>,
        TError,
        TData,
        QueryKey,
        QueueMetricsShowParams["page"]
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get paginated collection of queue monitor entries
 */

export function useQueueMetricsShowInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof queueMetricsShow>>,
    QueueMetricsShowParams["page"]
  >,
  TError = ErrorType<
    | AuthenticationExceptionResponse
    | AuthorizationExceptionResponse
    | ValidationExceptionResponse
  >
>(
  params?: QueueMetricsShowParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof queueMetricsShow>>,
        TError,
        TData,
        QueryKey,
        QueueMetricsShowParams["page"]
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getQueueMetricsShowInfiniteQueryOptions(params, options);

  const query = useInfiniteQuery(
    queryOptions,
    queryClient
  ) as UseInfiniteQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getQueueMetricsShowQueryOptions = <
  TData = Awaited<ReturnType<typeof queueMetricsShow>>,
  TError = ErrorType<
    | AuthenticationExceptionResponse
    | AuthorizationExceptionResponse
    | ValidationExceptionResponse
  >
>(
  params?: QueueMetricsShowParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof queueMetricsShow>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getQueueMetricsShowQueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof queueMetricsShow>>
  > = ({ signal }) => queueMetricsShow(params, requestOptions, signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof queueMetricsShow>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type QueueMetricsShowQueryResult = NonNullable<
  Awaited<ReturnType<typeof queueMetricsShow>>
>;
export type QueueMetricsShowQueryError = ErrorType<
  | AuthenticationExceptionResponse
  | AuthorizationExceptionResponse
  | ValidationExceptionResponse
>;

export function useQueueMetricsShow<
  TData = Awaited<ReturnType<typeof queueMetricsShow>>,
  TError = ErrorType<
    | AuthenticationExceptionResponse
    | AuthorizationExceptionResponse
    | ValidationExceptionResponse
  >
>(
  params: undefined | QueueMetricsShowParams,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof queueMetricsShow>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof queueMetricsShow>>,
          TError,
          Awaited<ReturnType<typeof queueMetricsShow>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useQueueMetricsShow<
  TData = Awaited<ReturnType<typeof queueMetricsShow>>,
  TError = ErrorType<
    | AuthenticationExceptionResponse
    | AuthorizationExceptionResponse
    | ValidationExceptionResponse
  >
>(
  params?: QueueMetricsShowParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof queueMetricsShow>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof queueMetricsShow>>,
          TError,
          Awaited<ReturnType<typeof queueMetricsShow>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useQueueMetricsShow<
  TData = Awaited<ReturnType<typeof queueMetricsShow>>,
  TError = ErrorType<
    | AuthenticationExceptionResponse
    | AuthorizationExceptionResponse
    | ValidationExceptionResponse
  >
>(
  params?: QueueMetricsShowParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof queueMetricsShow>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get paginated collection of queue monitor entries
 */

export function useQueueMetricsShow<
  TData = Awaited<ReturnType<typeof queueMetricsShow>>,
  TError = ErrorType<
    | AuthenticationExceptionResponse
    | AuthorizationExceptionResponse
    | ValidationExceptionResponse
  >
>(
  params?: QueueMetricsShowParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof queueMetricsShow>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getQueueMetricsShowQueryOptions(params, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getQueueMetricsShowSuspenseQueryOptions = <
  TData = Awaited<ReturnType<typeof queueMetricsShow>>,
  TError = ErrorType<
    | AuthenticationExceptionResponse
    | AuthorizationExceptionResponse
    | ValidationExceptionResponse
  >
>(
  params?: QueueMetricsShowParams,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof queueMetricsShow>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getQueueMetricsShowQueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof queueMetricsShow>>
  > = ({ signal }) => queueMetricsShow(params, requestOptions, signal);

  return { queryKey, queryFn, ...queryOptions } as UseSuspenseQueryOptions<
    Awaited<ReturnType<typeof queueMetricsShow>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type QueueMetricsShowSuspenseQueryResult = NonNullable<
  Awaited<ReturnType<typeof queueMetricsShow>>
>;
export type QueueMetricsShowSuspenseQueryError = ErrorType<
  | AuthenticationExceptionResponse
  | AuthorizationExceptionResponse
  | ValidationExceptionResponse
>;

export function useQueueMetricsShowSuspense<
  TData = Awaited<ReturnType<typeof queueMetricsShow>>,
  TError = ErrorType<
    | AuthenticationExceptionResponse
    | AuthorizationExceptionResponse
    | ValidationExceptionResponse
  >
>(
  params: undefined | QueueMetricsShowParams,
  options: {
    query: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof queueMetricsShow>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useQueueMetricsShowSuspense<
  TData = Awaited<ReturnType<typeof queueMetricsShow>>,
  TError = ErrorType<
    | AuthenticationExceptionResponse
    | AuthorizationExceptionResponse
    | ValidationExceptionResponse
  >
>(
  params?: QueueMetricsShowParams,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof queueMetricsShow>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useQueueMetricsShowSuspense<
  TData = Awaited<ReturnType<typeof queueMetricsShow>>,
  TError = ErrorType<
    | AuthenticationExceptionResponse
    | AuthorizationExceptionResponse
    | ValidationExceptionResponse
  >
>(
  params?: QueueMetricsShowParams,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof queueMetricsShow>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get paginated collection of queue monitor entries
 */

export function useQueueMetricsShowSuspense<
  TData = Awaited<ReturnType<typeof queueMetricsShow>>,
  TError = ErrorType<
    | AuthenticationExceptionResponse
    | AuthorizationExceptionResponse
    | ValidationExceptionResponse
  >
>(
  params?: QueueMetricsShowParams,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof queueMetricsShow>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getQueueMetricsShowSuspenseQueryOptions(params, options);

  const query = useSuspenseQuery(
    queryOptions,
    queryClient
  ) as UseSuspenseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getQueueMetricsShowSuspenseInfiniteQueryOptions = <
  TData = InfiniteData<
    Awaited<ReturnType<typeof queueMetricsShow>>,
    QueueMetricsShowParams["page"]
  >,
  TError = ErrorType<
    | AuthenticationExceptionResponse
    | AuthorizationExceptionResponse
    | ValidationExceptionResponse
  >
>(
  params?: QueueMetricsShowParams,
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof queueMetricsShow>>,
        TError,
        TData,
        QueryKey,
        QueueMetricsShowParams["page"]
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getQueueMetricsShowInfiniteQueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof queueMetricsShow>>,
    QueryKey,
    QueueMetricsShowParams["page"]
  > = ({ signal, pageParam }) =>
    queueMetricsShow(
      { ...params, page: pageParam || params?.["page"] },
      requestOptions,
      signal
    );

  return {
    queryKey,
    queryFn,
    ...queryOptions,
  } as UseSuspenseInfiniteQueryOptions<
    Awaited<ReturnType<typeof queueMetricsShow>>,
    TError,
    TData,
    QueryKey,
    QueueMetricsShowParams["page"]
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type QueueMetricsShowSuspenseInfiniteQueryResult = NonNullable<
  Awaited<ReturnType<typeof queueMetricsShow>>
>;
export type QueueMetricsShowSuspenseInfiniteQueryError = ErrorType<
  | AuthenticationExceptionResponse
  | AuthorizationExceptionResponse
  | ValidationExceptionResponse
>;

export function useQueueMetricsShowSuspenseInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof queueMetricsShow>>,
    QueueMetricsShowParams["page"]
  >,
  TError = ErrorType<
    | AuthenticationExceptionResponse
    | AuthorizationExceptionResponse
    | ValidationExceptionResponse
  >
>(
  params: undefined | QueueMetricsShowParams,
  options: {
    query: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof queueMetricsShow>>,
        TError,
        TData,
        QueryKey,
        QueueMetricsShowParams["page"]
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useQueueMetricsShowSuspenseInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof queueMetricsShow>>,
    QueueMetricsShowParams["page"]
  >,
  TError = ErrorType<
    | AuthenticationExceptionResponse
    | AuthorizationExceptionResponse
    | ValidationExceptionResponse
  >
>(
  params?: QueueMetricsShowParams,
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof queueMetricsShow>>,
        TError,
        TData,
        QueryKey,
        QueueMetricsShowParams["page"]
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useQueueMetricsShowSuspenseInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof queueMetricsShow>>,
    QueueMetricsShowParams["page"]
  >,
  TError = ErrorType<
    | AuthenticationExceptionResponse
    | AuthorizationExceptionResponse
    | ValidationExceptionResponse
  >
>(
  params?: QueueMetricsShowParams,
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof queueMetricsShow>>,
        TError,
        TData,
        QueryKey,
        QueueMetricsShowParams["page"]
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get paginated collection of queue monitor entries
 */

export function useQueueMetricsShowSuspenseInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof queueMetricsShow>>,
    QueueMetricsShowParams["page"]
  >,
  TError = ErrorType<
    | AuthenticationExceptionResponse
    | AuthorizationExceptionResponse
    | ValidationExceptionResponse
  >
>(
  params?: QueueMetricsShowParams,
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof queueMetricsShow>>,
        TError,
        TData,
        QueryKey,
        QueueMetricsShowParams["page"]
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getQueueMetricsShowSuspenseInfiniteQueryOptions(
    params,
    options
  );

  const query = useSuspenseInfiniteQuery(
    queryOptions,
    queryClient
  ) as UseSuspenseInfiniteQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Returns a distinct list of all queue names currently in the monitoring system.
Useful for populating filter dropdowns and understanding queue structure.
 * @summary Get list of all available queue names
 */
export const queueMetricsQueues = (
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal
) => {
  return customInstance<QueueMetricsQueues200Item[]>(
    { url: `/api/queue-metrics/queues`, method: "GET", signal },
    options
  );
};

export const getQueueMetricsQueuesInfiniteQueryKey = () => {
  return ["infinite", `/api/queue-metrics/queues`] as const;
};

export const getQueueMetricsQueuesQueryKey = () => {
  return [`/api/queue-metrics/queues`] as const;
};

export const getQueueMetricsQueuesInfiniteQueryOptions = <
  TData = InfiniteData<Awaited<ReturnType<typeof queueMetricsQueues>>>,
  TError = ErrorType<
    AuthenticationExceptionResponse | AuthorizationExceptionResponse
  >
>(options?: {
  query?: Partial<
    UseInfiniteQueryOptions<
      Awaited<ReturnType<typeof queueMetricsQueues>>,
      TError,
      TData
    >
  >;
  request?: SecondParameter<typeof customInstance>;
}) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getQueueMetricsQueuesInfiniteQueryKey();

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof queueMetricsQueues>>
  > = ({ signal }) => queueMetricsQueues(requestOptions, signal);

  return { queryKey, queryFn, ...queryOptions } as UseInfiniteQueryOptions<
    Awaited<ReturnType<typeof queueMetricsQueues>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type QueueMetricsQueuesInfiniteQueryResult = NonNullable<
  Awaited<ReturnType<typeof queueMetricsQueues>>
>;
export type QueueMetricsQueuesInfiniteQueryError = ErrorType<
  AuthenticationExceptionResponse | AuthorizationExceptionResponse
>;

export function useQueueMetricsQueuesInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof queueMetricsQueues>>>,
  TError = ErrorType<
    AuthenticationExceptionResponse | AuthorizationExceptionResponse
  >
>(
  options: {
    query: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof queueMetricsQueues>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof queueMetricsQueues>>,
          TError,
          Awaited<ReturnType<typeof queueMetricsQueues>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): DefinedUseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useQueueMetricsQueuesInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof queueMetricsQueues>>>,
  TError = ErrorType<
    AuthenticationExceptionResponse | AuthorizationExceptionResponse
  >
>(
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof queueMetricsQueues>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof queueMetricsQueues>>,
          TError,
          Awaited<ReturnType<typeof queueMetricsQueues>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useQueueMetricsQueuesInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof queueMetricsQueues>>>,
  TError = ErrorType<
    AuthenticationExceptionResponse | AuthorizationExceptionResponse
  >
>(
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof queueMetricsQueues>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get list of all available queue names
 */

export function useQueueMetricsQueuesInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof queueMetricsQueues>>>,
  TError = ErrorType<
    AuthenticationExceptionResponse | AuthorizationExceptionResponse
  >
>(
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof queueMetricsQueues>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getQueueMetricsQueuesInfiniteQueryOptions(options);

  const query = useInfiniteQuery(
    queryOptions,
    queryClient
  ) as UseInfiniteQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getQueueMetricsQueuesQueryOptions = <
  TData = Awaited<ReturnType<typeof queueMetricsQueues>>,
  TError = ErrorType<
    AuthenticationExceptionResponse | AuthorizationExceptionResponse
  >
>(options?: {
  query?: Partial<
    UseQueryOptions<
      Awaited<ReturnType<typeof queueMetricsQueues>>,
      TError,
      TData
    >
  >;
  request?: SecondParameter<typeof customInstance>;
}) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getQueueMetricsQueuesQueryKey();

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof queueMetricsQueues>>
  > = ({ signal }) => queueMetricsQueues(requestOptions, signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof queueMetricsQueues>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type QueueMetricsQueuesQueryResult = NonNullable<
  Awaited<ReturnType<typeof queueMetricsQueues>>
>;
export type QueueMetricsQueuesQueryError = ErrorType<
  AuthenticationExceptionResponse | AuthorizationExceptionResponse
>;

export function useQueueMetricsQueues<
  TData = Awaited<ReturnType<typeof queueMetricsQueues>>,
  TError = ErrorType<
    AuthenticationExceptionResponse | AuthorizationExceptionResponse
  >
>(
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof queueMetricsQueues>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof queueMetricsQueues>>,
          TError,
          Awaited<ReturnType<typeof queueMetricsQueues>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useQueueMetricsQueues<
  TData = Awaited<ReturnType<typeof queueMetricsQueues>>,
  TError = ErrorType<
    AuthenticationExceptionResponse | AuthorizationExceptionResponse
  >
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof queueMetricsQueues>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof queueMetricsQueues>>,
          TError,
          Awaited<ReturnType<typeof queueMetricsQueues>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useQueueMetricsQueues<
  TData = Awaited<ReturnType<typeof queueMetricsQueues>>,
  TError = ErrorType<
    AuthenticationExceptionResponse | AuthorizationExceptionResponse
  >
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof queueMetricsQueues>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get list of all available queue names
 */

export function useQueueMetricsQueues<
  TData = Awaited<ReturnType<typeof queueMetricsQueues>>,
  TError = ErrorType<
    AuthenticationExceptionResponse | AuthorizationExceptionResponse
  >
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof queueMetricsQueues>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getQueueMetricsQueuesQueryOptions(options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getQueueMetricsQueuesSuspenseQueryOptions = <
  TData = Awaited<ReturnType<typeof queueMetricsQueues>>,
  TError = ErrorType<
    AuthenticationExceptionResponse | AuthorizationExceptionResponse
  >
>(options?: {
  query?: Partial<
    UseSuspenseQueryOptions<
      Awaited<ReturnType<typeof queueMetricsQueues>>,
      TError,
      TData
    >
  >;
  request?: SecondParameter<typeof customInstance>;
}) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getQueueMetricsQueuesQueryKey();

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof queueMetricsQueues>>
  > = ({ signal }) => queueMetricsQueues(requestOptions, signal);

  return { queryKey, queryFn, ...queryOptions } as UseSuspenseQueryOptions<
    Awaited<ReturnType<typeof queueMetricsQueues>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type QueueMetricsQueuesSuspenseQueryResult = NonNullable<
  Awaited<ReturnType<typeof queueMetricsQueues>>
>;
export type QueueMetricsQueuesSuspenseQueryError = ErrorType<
  AuthenticationExceptionResponse | AuthorizationExceptionResponse
>;

export function useQueueMetricsQueuesSuspense<
  TData = Awaited<ReturnType<typeof queueMetricsQueues>>,
  TError = ErrorType<
    AuthenticationExceptionResponse | AuthorizationExceptionResponse
  >
>(
  options: {
    query: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof queueMetricsQueues>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useQueueMetricsQueuesSuspense<
  TData = Awaited<ReturnType<typeof queueMetricsQueues>>,
  TError = ErrorType<
    AuthenticationExceptionResponse | AuthorizationExceptionResponse
  >
>(
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof queueMetricsQueues>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useQueueMetricsQueuesSuspense<
  TData = Awaited<ReturnType<typeof queueMetricsQueues>>,
  TError = ErrorType<
    AuthenticationExceptionResponse | AuthorizationExceptionResponse
  >
>(
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof queueMetricsQueues>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get list of all available queue names
 */

export function useQueueMetricsQueuesSuspense<
  TData = Awaited<ReturnType<typeof queueMetricsQueues>>,
  TError = ErrorType<
    AuthenticationExceptionResponse | AuthorizationExceptionResponse
  >
>(
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof queueMetricsQueues>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getQueueMetricsQueuesSuspenseQueryOptions(options);

  const query = useSuspenseQuery(
    queryOptions,
    queryClient
  ) as UseSuspenseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getQueueMetricsQueuesSuspenseInfiniteQueryOptions = <
  TData = InfiniteData<Awaited<ReturnType<typeof queueMetricsQueues>>>,
  TError = ErrorType<
    AuthenticationExceptionResponse | AuthorizationExceptionResponse
  >
>(options?: {
  query?: Partial<
    UseSuspenseInfiniteQueryOptions<
      Awaited<ReturnType<typeof queueMetricsQueues>>,
      TError,
      TData
    >
  >;
  request?: SecondParameter<typeof customInstance>;
}) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getQueueMetricsQueuesInfiniteQueryKey();

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof queueMetricsQueues>>
  > = ({ signal }) => queueMetricsQueues(requestOptions, signal);

  return {
    queryKey,
    queryFn,
    ...queryOptions,
  } as UseSuspenseInfiniteQueryOptions<
    Awaited<ReturnType<typeof queueMetricsQueues>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type QueueMetricsQueuesSuspenseInfiniteQueryResult = NonNullable<
  Awaited<ReturnType<typeof queueMetricsQueues>>
>;
export type QueueMetricsQueuesSuspenseInfiniteQueryError = ErrorType<
  AuthenticationExceptionResponse | AuthorizationExceptionResponse
>;

export function useQueueMetricsQueuesSuspenseInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof queueMetricsQueues>>>,
  TError = ErrorType<
    AuthenticationExceptionResponse | AuthorizationExceptionResponse
  >
>(
  options: {
    query: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof queueMetricsQueues>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useQueueMetricsQueuesSuspenseInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof queueMetricsQueues>>>,
  TError = ErrorType<
    AuthenticationExceptionResponse | AuthorizationExceptionResponse
  >
>(
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof queueMetricsQueues>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useQueueMetricsQueuesSuspenseInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof queueMetricsQueues>>>,
  TError = ErrorType<
    AuthenticationExceptionResponse | AuthorizationExceptionResponse
  >
>(
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof queueMetricsQueues>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get list of all available queue names
 */

export function useQueueMetricsQueuesSuspenseInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof queueMetricsQueues>>>,
  TError = ErrorType<
    AuthenticationExceptionResponse | AuthorizationExceptionResponse
  >
>(
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof queueMetricsQueues>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions =
    getQueueMetricsQueuesSuspenseInfiniteQueryOptions(options);

  const query = useSuspenseInfiniteQuery(
    queryOptions,
    queryClient
  ) as UseSuspenseInfiniteQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Returns detailed metrics about queue performance including job counts,
execution times, failure rates, and trend analysis over the specified
time period for system monitoring and optimization.
 * @summary Get comprehensive queue metrics and statistics
 */
export const queueMetricsMetrics = (
  params?: QueueMetricsMetricsParams,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal
) => {
  return customInstance<QueueMetricsMetrics200Item[]>(
    { url: `/api/queue-metrics/metrics`, method: "GET", params, signal },
    options
  );
};

export const getQueueMetricsMetricsInfiniteQueryKey = (
  params?: QueueMetricsMetricsParams
) => {
  return [
    "infinite",
    `/api/queue-metrics/metrics`,
    ...(params ? [params] : []),
  ] as const;
};

export const getQueueMetricsMetricsQueryKey = (
  params?: QueueMetricsMetricsParams
) => {
  return [`/api/queue-metrics/metrics`, ...(params ? [params] : [])] as const;
};

export const getQueueMetricsMetricsInfiniteQueryOptions = <
  TData = InfiniteData<
    Awaited<ReturnType<typeof queueMetricsMetrics>>,
    QueueMetricsMetricsParams["page"]
  >,
  TError = ErrorType<
    | AuthenticationExceptionResponse
    | AuthorizationExceptionResponse
    | ValidationExceptionResponse
  >
>(
  params?: QueueMetricsMetricsParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof queueMetricsMetrics>>,
        TError,
        TData,
        QueryKey,
        QueueMetricsMetricsParams["page"]
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getQueueMetricsMetricsInfiniteQueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof queueMetricsMetrics>>,
    QueryKey,
    QueueMetricsMetricsParams["page"]
  > = ({ signal, pageParam }) =>
    queueMetricsMetrics(
      { ...params, page: pageParam || params?.["page"] },
      requestOptions,
      signal
    );

  return { queryKey, queryFn, ...queryOptions } as UseInfiniteQueryOptions<
    Awaited<ReturnType<typeof queueMetricsMetrics>>,
    TError,
    TData,
    QueryKey,
    QueueMetricsMetricsParams["page"]
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type QueueMetricsMetricsInfiniteQueryResult = NonNullable<
  Awaited<ReturnType<typeof queueMetricsMetrics>>
>;
export type QueueMetricsMetricsInfiniteQueryError = ErrorType<
  | AuthenticationExceptionResponse
  | AuthorizationExceptionResponse
  | ValidationExceptionResponse
>;

export function useQueueMetricsMetricsInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof queueMetricsMetrics>>,
    QueueMetricsMetricsParams["page"]
  >,
  TError = ErrorType<
    | AuthenticationExceptionResponse
    | AuthorizationExceptionResponse
    | ValidationExceptionResponse
  >
>(
  params: undefined | QueueMetricsMetricsParams,
  options: {
    query: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof queueMetricsMetrics>>,
        TError,
        TData,
        QueryKey,
        QueueMetricsMetricsParams["page"]
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof queueMetricsMetrics>>,
          TError,
          Awaited<ReturnType<typeof queueMetricsMetrics>>,
          QueryKey
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): DefinedUseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useQueueMetricsMetricsInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof queueMetricsMetrics>>,
    QueueMetricsMetricsParams["page"]
  >,
  TError = ErrorType<
    | AuthenticationExceptionResponse
    | AuthorizationExceptionResponse
    | ValidationExceptionResponse
  >
>(
  params?: QueueMetricsMetricsParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof queueMetricsMetrics>>,
        TError,
        TData,
        QueryKey,
        QueueMetricsMetricsParams["page"]
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof queueMetricsMetrics>>,
          TError,
          Awaited<ReturnType<typeof queueMetricsMetrics>>,
          QueryKey
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useQueueMetricsMetricsInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof queueMetricsMetrics>>,
    QueueMetricsMetricsParams["page"]
  >,
  TError = ErrorType<
    | AuthenticationExceptionResponse
    | AuthorizationExceptionResponse
    | ValidationExceptionResponse
  >
>(
  params?: QueueMetricsMetricsParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof queueMetricsMetrics>>,
        TError,
        TData,
        QueryKey,
        QueueMetricsMetricsParams["page"]
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get comprehensive queue metrics and statistics
 */

export function useQueueMetricsMetricsInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof queueMetricsMetrics>>,
    QueueMetricsMetricsParams["page"]
  >,
  TError = ErrorType<
    | AuthenticationExceptionResponse
    | AuthorizationExceptionResponse
    | ValidationExceptionResponse
  >
>(
  params?: QueueMetricsMetricsParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof queueMetricsMetrics>>,
        TError,
        TData,
        QueryKey,
        QueueMetricsMetricsParams["page"]
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getQueueMetricsMetricsInfiniteQueryOptions(
    params,
    options
  );

  const query = useInfiniteQuery(
    queryOptions,
    queryClient
  ) as UseInfiniteQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getQueueMetricsMetricsQueryOptions = <
  TData = Awaited<ReturnType<typeof queueMetricsMetrics>>,
  TError = ErrorType<
    | AuthenticationExceptionResponse
    | AuthorizationExceptionResponse
    | ValidationExceptionResponse
  >
>(
  params?: QueueMetricsMetricsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof queueMetricsMetrics>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getQueueMetricsMetricsQueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof queueMetricsMetrics>>
  > = ({ signal }) => queueMetricsMetrics(params, requestOptions, signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof queueMetricsMetrics>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type QueueMetricsMetricsQueryResult = NonNullable<
  Awaited<ReturnType<typeof queueMetricsMetrics>>
>;
export type QueueMetricsMetricsQueryError = ErrorType<
  | AuthenticationExceptionResponse
  | AuthorizationExceptionResponse
  | ValidationExceptionResponse
>;

export function useQueueMetricsMetrics<
  TData = Awaited<ReturnType<typeof queueMetricsMetrics>>,
  TError = ErrorType<
    | AuthenticationExceptionResponse
    | AuthorizationExceptionResponse
    | ValidationExceptionResponse
  >
>(
  params: undefined | QueueMetricsMetricsParams,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof queueMetricsMetrics>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof queueMetricsMetrics>>,
          TError,
          Awaited<ReturnType<typeof queueMetricsMetrics>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useQueueMetricsMetrics<
  TData = Awaited<ReturnType<typeof queueMetricsMetrics>>,
  TError = ErrorType<
    | AuthenticationExceptionResponse
    | AuthorizationExceptionResponse
    | ValidationExceptionResponse
  >
>(
  params?: QueueMetricsMetricsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof queueMetricsMetrics>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof queueMetricsMetrics>>,
          TError,
          Awaited<ReturnType<typeof queueMetricsMetrics>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useQueueMetricsMetrics<
  TData = Awaited<ReturnType<typeof queueMetricsMetrics>>,
  TError = ErrorType<
    | AuthenticationExceptionResponse
    | AuthorizationExceptionResponse
    | ValidationExceptionResponse
  >
>(
  params?: QueueMetricsMetricsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof queueMetricsMetrics>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get comprehensive queue metrics and statistics
 */

export function useQueueMetricsMetrics<
  TData = Awaited<ReturnType<typeof queueMetricsMetrics>>,
  TError = ErrorType<
    | AuthenticationExceptionResponse
    | AuthorizationExceptionResponse
    | ValidationExceptionResponse
  >
>(
  params?: QueueMetricsMetricsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof queueMetricsMetrics>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getQueueMetricsMetricsQueryOptions(params, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getQueueMetricsMetricsSuspenseQueryOptions = <
  TData = Awaited<ReturnType<typeof queueMetricsMetrics>>,
  TError = ErrorType<
    | AuthenticationExceptionResponse
    | AuthorizationExceptionResponse
    | ValidationExceptionResponse
  >
>(
  params?: QueueMetricsMetricsParams,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof queueMetricsMetrics>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getQueueMetricsMetricsQueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof queueMetricsMetrics>>
  > = ({ signal }) => queueMetricsMetrics(params, requestOptions, signal);

  return { queryKey, queryFn, ...queryOptions } as UseSuspenseQueryOptions<
    Awaited<ReturnType<typeof queueMetricsMetrics>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type QueueMetricsMetricsSuspenseQueryResult = NonNullable<
  Awaited<ReturnType<typeof queueMetricsMetrics>>
>;
export type QueueMetricsMetricsSuspenseQueryError = ErrorType<
  | AuthenticationExceptionResponse
  | AuthorizationExceptionResponse
  | ValidationExceptionResponse
>;

export function useQueueMetricsMetricsSuspense<
  TData = Awaited<ReturnType<typeof queueMetricsMetrics>>,
  TError = ErrorType<
    | AuthenticationExceptionResponse
    | AuthorizationExceptionResponse
    | ValidationExceptionResponse
  >
>(
  params: undefined | QueueMetricsMetricsParams,
  options: {
    query: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof queueMetricsMetrics>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useQueueMetricsMetricsSuspense<
  TData = Awaited<ReturnType<typeof queueMetricsMetrics>>,
  TError = ErrorType<
    | AuthenticationExceptionResponse
    | AuthorizationExceptionResponse
    | ValidationExceptionResponse
  >
>(
  params?: QueueMetricsMetricsParams,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof queueMetricsMetrics>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useQueueMetricsMetricsSuspense<
  TData = Awaited<ReturnType<typeof queueMetricsMetrics>>,
  TError = ErrorType<
    | AuthenticationExceptionResponse
    | AuthorizationExceptionResponse
    | ValidationExceptionResponse
  >
>(
  params?: QueueMetricsMetricsParams,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof queueMetricsMetrics>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get comprehensive queue metrics and statistics
 */

export function useQueueMetricsMetricsSuspense<
  TData = Awaited<ReturnType<typeof queueMetricsMetrics>>,
  TError = ErrorType<
    | AuthenticationExceptionResponse
    | AuthorizationExceptionResponse
    | ValidationExceptionResponse
  >
>(
  params?: QueueMetricsMetricsParams,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof queueMetricsMetrics>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getQueueMetricsMetricsSuspenseQueryOptions(
    params,
    options
  );

  const query = useSuspenseQuery(
    queryOptions,
    queryClient
  ) as UseSuspenseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getQueueMetricsMetricsSuspenseInfiniteQueryOptions = <
  TData = InfiniteData<
    Awaited<ReturnType<typeof queueMetricsMetrics>>,
    QueueMetricsMetricsParams["page"]
  >,
  TError = ErrorType<
    | AuthenticationExceptionResponse
    | AuthorizationExceptionResponse
    | ValidationExceptionResponse
  >
>(
  params?: QueueMetricsMetricsParams,
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof queueMetricsMetrics>>,
        TError,
        TData,
        QueryKey,
        QueueMetricsMetricsParams["page"]
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getQueueMetricsMetricsInfiniteQueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof queueMetricsMetrics>>,
    QueryKey,
    QueueMetricsMetricsParams["page"]
  > = ({ signal, pageParam }) =>
    queueMetricsMetrics(
      { ...params, page: pageParam || params?.["page"] },
      requestOptions,
      signal
    );

  return {
    queryKey,
    queryFn,
    ...queryOptions,
  } as UseSuspenseInfiniteQueryOptions<
    Awaited<ReturnType<typeof queueMetricsMetrics>>,
    TError,
    TData,
    QueryKey,
    QueueMetricsMetricsParams["page"]
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type QueueMetricsMetricsSuspenseInfiniteQueryResult = NonNullable<
  Awaited<ReturnType<typeof queueMetricsMetrics>>
>;
export type QueueMetricsMetricsSuspenseInfiniteQueryError = ErrorType<
  | AuthenticationExceptionResponse
  | AuthorizationExceptionResponse
  | ValidationExceptionResponse
>;

export function useQueueMetricsMetricsSuspenseInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof queueMetricsMetrics>>,
    QueueMetricsMetricsParams["page"]
  >,
  TError = ErrorType<
    | AuthenticationExceptionResponse
    | AuthorizationExceptionResponse
    | ValidationExceptionResponse
  >
>(
  params: undefined | QueueMetricsMetricsParams,
  options: {
    query: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof queueMetricsMetrics>>,
        TError,
        TData,
        QueryKey,
        QueueMetricsMetricsParams["page"]
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useQueueMetricsMetricsSuspenseInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof queueMetricsMetrics>>,
    QueueMetricsMetricsParams["page"]
  >,
  TError = ErrorType<
    | AuthenticationExceptionResponse
    | AuthorizationExceptionResponse
    | ValidationExceptionResponse
  >
>(
  params?: QueueMetricsMetricsParams,
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof queueMetricsMetrics>>,
        TError,
        TData,
        QueryKey,
        QueueMetricsMetricsParams["page"]
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useQueueMetricsMetricsSuspenseInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof queueMetricsMetrics>>,
    QueueMetricsMetricsParams["page"]
  >,
  TError = ErrorType<
    | AuthenticationExceptionResponse
    | AuthorizationExceptionResponse
    | ValidationExceptionResponse
  >
>(
  params?: QueueMetricsMetricsParams,
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof queueMetricsMetrics>>,
        TError,
        TData,
        QueryKey,
        QueueMetricsMetricsParams["page"]
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get comprehensive queue metrics and statistics
 */

export function useQueueMetricsMetricsSuspenseInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof queueMetricsMetrics>>,
    QueueMetricsMetricsParams["page"]
  >,
  TError = ErrorType<
    | AuthenticationExceptionResponse
    | AuthorizationExceptionResponse
    | ValidationExceptionResponse
  >
>(
  params?: QueueMetricsMetricsParams,
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof queueMetricsMetrics>>,
        TError,
        TData,
        QueryKey,
        QueueMetricsMetricsParams["page"]
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getQueueMetricsMetricsSuspenseInfiniteQueryOptions(
    params,
    options
  );

  const query = useSuspenseInfiniteQuery(
    queryOptions,
    queryClient
  ) as UseSuspenseInfiniteQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Attempts to retry a previously failed job by re-dispatching it to the queue.
Only failed jobs that haven't been retried and have valid job UUIDs can be retried.
Includes safety checks and error handling.
 * @summary Retry a failed queue job
 */
export const queueMetricsRetryJob = (
  id: string,
  retryJobRequest: BodyType<RetryJobRequest>,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal
) => {
  return customInstance<QueueMetricsRetryJob200>(
    {
      url: `/api/queue-metrics/retry/${id}`,
      method: "POST",
      headers: { "Content-Type": "application/json" },
      data: retryJobRequest,
      signal,
    },
    options
  );
};

export const getQueueMetricsRetryJobMutationOptions = <
  TError = ErrorType<
    | QueueMetricsRetryJob400
    | AuthenticationExceptionResponse
    | AuthorizationExceptionResponse
    | ModelNotFoundExceptionResponse
    | ValidationExceptionResponse
  >,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof queueMetricsRetryJob>>,
    TError,
    { id: string; data: BodyType<RetryJobRequest> },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof queueMetricsRetryJob>>,
  TError,
  { id: string; data: BodyType<RetryJobRequest> },
  TContext
> => {
  const mutationKey = ["queueMetricsRetryJob"];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof queueMetricsRetryJob>>,
    { id: string; data: BodyType<RetryJobRequest> }
  > = (props) => {
    const { id, data } = props ?? {};

    return queueMetricsRetryJob(id, data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type QueueMetricsRetryJobMutationResult = NonNullable<
  Awaited<ReturnType<typeof queueMetricsRetryJob>>
>;
export type QueueMetricsRetryJobMutationBody = BodyType<RetryJobRequest>;
export type QueueMetricsRetryJobMutationError = ErrorType<
  | QueueMetricsRetryJob400
  | AuthenticationExceptionResponse
  | AuthorizationExceptionResponse
  | ModelNotFoundExceptionResponse
  | ValidationExceptionResponse
>;

/**
 * @summary Retry a failed queue job
 */
export const useQueueMetricsRetryJob = <
  TError = ErrorType<
    | QueueMetricsRetryJob400
    | AuthenticationExceptionResponse
    | AuthorizationExceptionResponse
    | ModelNotFoundExceptionResponse
    | ValidationExceptionResponse
  >,
  TContext = unknown
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof queueMetricsRetryJob>>,
      TError,
      { id: string; data: BodyType<RetryJobRequest> },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof queueMetricsRetryJob>>,
  TError,
  { id: string; data: BodyType<RetryJobRequest> },
  TContext
> => {
  const mutationOptions = getQueueMetricsRetryJobMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
/**
 * Permanently removes a queue monitor record from the system.
This only affects monitoring data and does not impact actual queue jobs.
Used for cleaning up monitoring history.
 * @summary Delete a specific queue monitor entry
 */
export const queueMetricsDelete = (
  id: string,
  options?: SecondParameter<typeof customInstance>
) => {
  return customInstance<string>(
    { url: `/api/queue-metrics/${id}`, method: "DELETE" },
    options
  );
};

export const getQueueMetricsDeleteMutationOptions = <
  TError = ErrorType<
    | AuthenticationExceptionResponse
    | AuthorizationExceptionResponse
    | ModelNotFoundExceptionResponse
  >,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof queueMetricsDelete>>,
    TError,
    { id: string },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof queueMetricsDelete>>,
  TError,
  { id: string },
  TContext
> => {
  const mutationKey = ["queueMetricsDelete"];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof queueMetricsDelete>>,
    { id: string }
  > = (props) => {
    const { id } = props ?? {};

    return queueMetricsDelete(id, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type QueueMetricsDeleteMutationResult = NonNullable<
  Awaited<ReturnType<typeof queueMetricsDelete>>
>;

export type QueueMetricsDeleteMutationError = ErrorType<
  | AuthenticationExceptionResponse
  | AuthorizationExceptionResponse
  | ModelNotFoundExceptionResponse
>;

/**
 * @summary Delete a specific queue monitor entry
 */
export const useQueueMetricsDelete = <
  TError = ErrorType<
    | AuthenticationExceptionResponse
    | AuthorizationExceptionResponse
    | ModelNotFoundExceptionResponse
  >,
  TContext = unknown
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof queueMetricsDelete>>,
      TError,
      { id: string },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof queueMetricsDelete>>,
  TError,
  { id: string },
  TContext
> => {
  const mutationOptions = getQueueMetricsDeleteMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
/**
 * Completely clears all queue monitoring data from the system.
This is a destructive operation that removes all historical job tracking
information. Use with extreme caution in production environments.
 * @summary Purge all queue monitor records
 */
export const queueMetricsPurge = (
  options?: SecondParameter<typeof customInstance>
) => {
  return customInstance<void>(
    { url: `/api/queue-metrics/purge`, method: "DELETE" },
    options
  );
};

export const getQueueMetricsPurgeMutationOptions = <
  TError = ErrorType<
    AuthenticationExceptionResponse | AuthorizationExceptionResponse
  >,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof queueMetricsPurge>>,
    TError,
    void,
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof queueMetricsPurge>>,
  TError,
  void,
  TContext
> => {
  const mutationKey = ["queueMetricsPurge"];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof queueMetricsPurge>>,
    void
  > = () => {
    return queueMetricsPurge(requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type QueueMetricsPurgeMutationResult = NonNullable<
  Awaited<ReturnType<typeof queueMetricsPurge>>
>;

export type QueueMetricsPurgeMutationError = ErrorType<
  AuthenticationExceptionResponse | AuthorizationExceptionResponse
>;

/**
 * @summary Purge all queue monitor records
 */
export const useQueueMetricsPurge = <
  TError = ErrorType<
    AuthenticationExceptionResponse | AuthorizationExceptionResponse
  >,
  TContext = unknown
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof queueMetricsPurge>>,
      TError,
      void,
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof queueMetricsPurge>>,
  TError,
  void,
  TContext
> => {
  const mutationOptions = getQueueMetricsPurgeMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
/**
 * @summary Get php info
 */
export const systemInfoPhp = (
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal
) => {
  return customInstance<SystemInfoPhp200Item[]>(
    { url: `/api/system-info`, method: "GET", signal },
    options
  );
};

export const getSystemInfoPhpInfiniteQueryKey = () => {
  return ["infinite", `/api/system-info`] as const;
};

export const getSystemInfoPhpQueryKey = () => {
  return [`/api/system-info`] as const;
};

export const getSystemInfoPhpInfiniteQueryOptions = <
  TData = InfiniteData<Awaited<ReturnType<typeof systemInfoPhp>>>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(options?: {
  query?: Partial<
    UseInfiniteQueryOptions<
      Awaited<ReturnType<typeof systemInfoPhp>>,
      TError,
      TData
    >
  >;
  request?: SecondParameter<typeof customInstance>;
}) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getSystemInfoPhpInfiniteQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof systemInfoPhp>>> = ({
    signal,
  }) => systemInfoPhp(requestOptions, signal);

  return { queryKey, queryFn, ...queryOptions } as UseInfiniteQueryOptions<
    Awaited<ReturnType<typeof systemInfoPhp>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type SystemInfoPhpInfiniteQueryResult = NonNullable<
  Awaited<ReturnType<typeof systemInfoPhp>>
>;
export type SystemInfoPhpInfiniteQueryError =
  ErrorType<AuthenticationExceptionResponse>;

export function useSystemInfoPhpInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof systemInfoPhp>>>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(
  options: {
    query: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof systemInfoPhp>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof systemInfoPhp>>,
          TError,
          Awaited<ReturnType<typeof systemInfoPhp>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): DefinedUseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useSystemInfoPhpInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof systemInfoPhp>>>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof systemInfoPhp>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof systemInfoPhp>>,
          TError,
          Awaited<ReturnType<typeof systemInfoPhp>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useSystemInfoPhpInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof systemInfoPhp>>>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof systemInfoPhp>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get php info
 */

export function useSystemInfoPhpInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof systemInfoPhp>>>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof systemInfoPhp>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getSystemInfoPhpInfiniteQueryOptions(options);

  const query = useInfiniteQuery(
    queryOptions,
    queryClient
  ) as UseInfiniteQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getSystemInfoPhpQueryOptions = <
  TData = Awaited<ReturnType<typeof systemInfoPhp>>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof systemInfoPhp>>, TError, TData>
  >;
  request?: SecondParameter<typeof customInstance>;
}) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getSystemInfoPhpQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof systemInfoPhp>>> = ({
    signal,
  }) => systemInfoPhp(requestOptions, signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof systemInfoPhp>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type SystemInfoPhpQueryResult = NonNullable<
  Awaited<ReturnType<typeof systemInfoPhp>>
>;
export type SystemInfoPhpQueryError =
  ErrorType<AuthenticationExceptionResponse>;

export function useSystemInfoPhp<
  TData = Awaited<ReturnType<typeof systemInfoPhp>>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof systemInfoPhp>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof systemInfoPhp>>,
          TError,
          Awaited<ReturnType<typeof systemInfoPhp>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useSystemInfoPhp<
  TData = Awaited<ReturnType<typeof systemInfoPhp>>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof systemInfoPhp>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof systemInfoPhp>>,
          TError,
          Awaited<ReturnType<typeof systemInfoPhp>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useSystemInfoPhp<
  TData = Awaited<ReturnType<typeof systemInfoPhp>>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof systemInfoPhp>>, TError, TData>
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get php info
 */

export function useSystemInfoPhp<
  TData = Awaited<ReturnType<typeof systemInfoPhp>>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof systemInfoPhp>>, TError, TData>
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getSystemInfoPhpQueryOptions(options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getSystemInfoPhpSuspenseQueryOptions = <
  TData = Awaited<ReturnType<typeof systemInfoPhp>>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(options?: {
  query?: Partial<
    UseSuspenseQueryOptions<
      Awaited<ReturnType<typeof systemInfoPhp>>,
      TError,
      TData
    >
  >;
  request?: SecondParameter<typeof customInstance>;
}) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getSystemInfoPhpQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof systemInfoPhp>>> = ({
    signal,
  }) => systemInfoPhp(requestOptions, signal);

  return { queryKey, queryFn, ...queryOptions } as UseSuspenseQueryOptions<
    Awaited<ReturnType<typeof systemInfoPhp>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type SystemInfoPhpSuspenseQueryResult = NonNullable<
  Awaited<ReturnType<typeof systemInfoPhp>>
>;
export type SystemInfoPhpSuspenseQueryError =
  ErrorType<AuthenticationExceptionResponse>;

export function useSystemInfoPhpSuspense<
  TData = Awaited<ReturnType<typeof systemInfoPhp>>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(
  options: {
    query: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof systemInfoPhp>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useSystemInfoPhpSuspense<
  TData = Awaited<ReturnType<typeof systemInfoPhp>>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof systemInfoPhp>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useSystemInfoPhpSuspense<
  TData = Awaited<ReturnType<typeof systemInfoPhp>>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof systemInfoPhp>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get php info
 */

export function useSystemInfoPhpSuspense<
  TData = Awaited<ReturnType<typeof systemInfoPhp>>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof systemInfoPhp>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getSystemInfoPhpSuspenseQueryOptions(options);

  const query = useSuspenseQuery(
    queryOptions,
    queryClient
  ) as UseSuspenseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getSystemInfoPhpSuspenseInfiniteQueryOptions = <
  TData = InfiniteData<Awaited<ReturnType<typeof systemInfoPhp>>>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(options?: {
  query?: Partial<
    UseSuspenseInfiniteQueryOptions<
      Awaited<ReturnType<typeof systemInfoPhp>>,
      TError,
      TData
    >
  >;
  request?: SecondParameter<typeof customInstance>;
}) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getSystemInfoPhpInfiniteQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof systemInfoPhp>>> = ({
    signal,
  }) => systemInfoPhp(requestOptions, signal);

  return {
    queryKey,
    queryFn,
    ...queryOptions,
  } as UseSuspenseInfiniteQueryOptions<
    Awaited<ReturnType<typeof systemInfoPhp>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type SystemInfoPhpSuspenseInfiniteQueryResult = NonNullable<
  Awaited<ReturnType<typeof systemInfoPhp>>
>;
export type SystemInfoPhpSuspenseInfiniteQueryError =
  ErrorType<AuthenticationExceptionResponse>;

export function useSystemInfoPhpSuspenseInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof systemInfoPhp>>>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(
  options: {
    query: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof systemInfoPhp>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useSystemInfoPhpSuspenseInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof systemInfoPhp>>>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof systemInfoPhp>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useSystemInfoPhpSuspenseInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof systemInfoPhp>>>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof systemInfoPhp>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get php info
 */

export function useSystemInfoPhpSuspenseInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof systemInfoPhp>>>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof systemInfoPhp>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getSystemInfoPhpSuspenseInfiniteQueryOptions(options);

  const query = useSuspenseInfiniteQuery(
    queryOptions,
    queryClient
  ) as UseSuspenseInfiniteQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const systemInfoSys = (
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal
) => {
  return customInstance<SystemInfoSys200>(
    { url: `/api/system-info/sys`, method: "GET", signal },
    options
  );
};

export const getSystemInfoSysInfiniteQueryKey = () => {
  return ["infinite", `/api/system-info/sys`] as const;
};

export const getSystemInfoSysQueryKey = () => {
  return [`/api/system-info/sys`] as const;
};

export const getSystemInfoSysInfiniteQueryOptions = <
  TData = InfiniteData<Awaited<ReturnType<typeof systemInfoSys>>>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(options?: {
  query?: Partial<
    UseInfiniteQueryOptions<
      Awaited<ReturnType<typeof systemInfoSys>>,
      TError,
      TData
    >
  >;
  request?: SecondParameter<typeof customInstance>;
}) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getSystemInfoSysInfiniteQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof systemInfoSys>>> = ({
    signal,
  }) => systemInfoSys(requestOptions, signal);

  return { queryKey, queryFn, ...queryOptions } as UseInfiniteQueryOptions<
    Awaited<ReturnType<typeof systemInfoSys>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type SystemInfoSysInfiniteQueryResult = NonNullable<
  Awaited<ReturnType<typeof systemInfoSys>>
>;
export type SystemInfoSysInfiniteQueryError =
  ErrorType<AuthenticationExceptionResponse>;

export function useSystemInfoSysInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof systemInfoSys>>>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(
  options: {
    query: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof systemInfoSys>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof systemInfoSys>>,
          TError,
          Awaited<ReturnType<typeof systemInfoSys>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): DefinedUseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useSystemInfoSysInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof systemInfoSys>>>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof systemInfoSys>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof systemInfoSys>>,
          TError,
          Awaited<ReturnType<typeof systemInfoSys>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useSystemInfoSysInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof systemInfoSys>>>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof systemInfoSys>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};

export function useSystemInfoSysInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof systemInfoSys>>>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof systemInfoSys>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getSystemInfoSysInfiniteQueryOptions(options);

  const query = useInfiniteQuery(
    queryOptions,
    queryClient
  ) as UseInfiniteQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getSystemInfoSysQueryOptions = <
  TData = Awaited<ReturnType<typeof systemInfoSys>>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof systemInfoSys>>, TError, TData>
  >;
  request?: SecondParameter<typeof customInstance>;
}) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getSystemInfoSysQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof systemInfoSys>>> = ({
    signal,
  }) => systemInfoSys(requestOptions, signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof systemInfoSys>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type SystemInfoSysQueryResult = NonNullable<
  Awaited<ReturnType<typeof systemInfoSys>>
>;
export type SystemInfoSysQueryError =
  ErrorType<AuthenticationExceptionResponse>;

export function useSystemInfoSys<
  TData = Awaited<ReturnType<typeof systemInfoSys>>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof systemInfoSys>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof systemInfoSys>>,
          TError,
          Awaited<ReturnType<typeof systemInfoSys>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useSystemInfoSys<
  TData = Awaited<ReturnType<typeof systemInfoSys>>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof systemInfoSys>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof systemInfoSys>>,
          TError,
          Awaited<ReturnType<typeof systemInfoSys>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useSystemInfoSys<
  TData = Awaited<ReturnType<typeof systemInfoSys>>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof systemInfoSys>>, TError, TData>
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};

export function useSystemInfoSys<
  TData = Awaited<ReturnType<typeof systemInfoSys>>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof systemInfoSys>>, TError, TData>
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getSystemInfoSysQueryOptions(options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getSystemInfoSysSuspenseQueryOptions = <
  TData = Awaited<ReturnType<typeof systemInfoSys>>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(options?: {
  query?: Partial<
    UseSuspenseQueryOptions<
      Awaited<ReturnType<typeof systemInfoSys>>,
      TError,
      TData
    >
  >;
  request?: SecondParameter<typeof customInstance>;
}) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getSystemInfoSysQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof systemInfoSys>>> = ({
    signal,
  }) => systemInfoSys(requestOptions, signal);

  return { queryKey, queryFn, ...queryOptions } as UseSuspenseQueryOptions<
    Awaited<ReturnType<typeof systemInfoSys>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type SystemInfoSysSuspenseQueryResult = NonNullable<
  Awaited<ReturnType<typeof systemInfoSys>>
>;
export type SystemInfoSysSuspenseQueryError =
  ErrorType<AuthenticationExceptionResponse>;

export function useSystemInfoSysSuspense<
  TData = Awaited<ReturnType<typeof systemInfoSys>>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(
  options: {
    query: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof systemInfoSys>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useSystemInfoSysSuspense<
  TData = Awaited<ReturnType<typeof systemInfoSys>>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof systemInfoSys>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useSystemInfoSysSuspense<
  TData = Awaited<ReturnType<typeof systemInfoSys>>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof systemInfoSys>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};

export function useSystemInfoSysSuspense<
  TData = Awaited<ReturnType<typeof systemInfoSys>>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof systemInfoSys>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getSystemInfoSysSuspenseQueryOptions(options);

  const query = useSuspenseQuery(
    queryOptions,
    queryClient
  ) as UseSuspenseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getSystemInfoSysSuspenseInfiniteQueryOptions = <
  TData = InfiniteData<Awaited<ReturnType<typeof systemInfoSys>>>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(options?: {
  query?: Partial<
    UseSuspenseInfiniteQueryOptions<
      Awaited<ReturnType<typeof systemInfoSys>>,
      TError,
      TData
    >
  >;
  request?: SecondParameter<typeof customInstance>;
}) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getSystemInfoSysInfiniteQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof systemInfoSys>>> = ({
    signal,
  }) => systemInfoSys(requestOptions, signal);

  return {
    queryKey,
    queryFn,
    ...queryOptions,
  } as UseSuspenseInfiniteQueryOptions<
    Awaited<ReturnType<typeof systemInfoSys>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type SystemInfoSysSuspenseInfiniteQueryResult = NonNullable<
  Awaited<ReturnType<typeof systemInfoSys>>
>;
export type SystemInfoSysSuspenseInfiniteQueryError =
  ErrorType<AuthenticationExceptionResponse>;

export function useSystemInfoSysSuspenseInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof systemInfoSys>>>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(
  options: {
    query: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof systemInfoSys>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useSystemInfoSysSuspenseInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof systemInfoSys>>>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof systemInfoSys>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useSystemInfoSysSuspenseInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof systemInfoSys>>>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof systemInfoSys>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};

export function useSystemInfoSysSuspenseInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof systemInfoSys>>>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof systemInfoSys>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getSystemInfoSysSuspenseInfiniteQueryOptions(options);

  const query = useSuspenseInfiniteQuery(
    queryOptions,
    queryClient
  ) as UseSuspenseInfiniteQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}
