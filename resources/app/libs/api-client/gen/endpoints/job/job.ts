/**
 * Generated by orval v7.11.2 üç∫
 * Do not edit manually.
 * B√•nder api docs
 * B√•nder.App is a sophisticated media server developed with the primary goal to deliver high performance and seamless experience for users.
Being built on top of Laravel framework and PostgreSQL for database, it leverages the power of robust backend technologies, providing high security, reliability, and scalability.

The main focus of B√•nder.App is efficient media management and delivery.
This application is designed to handle large amounts of media files while ensuring quick and efficient access.
Implemented queuing functionality through Redis offers efficient job management and load handling.
The media information is organized and easily searchable, ensuring users can always find what they are looking for quickly and easily.
 * OpenAPI spec version: 0.0.1
 */
import {
  useInfiniteQuery,
  useMutation,
  useQuery,
  useSuspenseInfiniteQuery,
  useSuspenseQuery,
} from "@tanstack/react-query";
import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseInfiniteQueryResult,
  DefinedUseQueryResult,
  InfiniteData,
  MutationFunction,
  QueryClient,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseInfiniteQueryOptions,
  UseInfiniteQueryResult,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult,
  UseSuspenseInfiniteQueryOptions,
  UseSuspenseInfiniteQueryResult,
  UseSuspenseQueryOptions,
  UseSuspenseQueryResult,
} from "@tanstack/react-query";

import type {
  AuthenticationExceptionResponse,
  JobCleanup200,
  JobCleanupBody,
  JobFailedCleanup200,
  JobFailedCleanupBody,
  JobLibraryScan200,
  JobLock200,
  JobLockDelete200,
  JobLocks200Item,
} from "../../models";

import { customInstance } from "../../../axios-instance";
import type { ErrorType, BodyType } from "../../../axios-instance";

type SecondParameter<T extends (...args: never) => unknown> = Parameters<T>[1];

/**
 * @summary Get job locks
 */
export const jobLocks = (
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal
) => {
  return customInstance<JobLocks200Item[]>(
    { url: `/api/jobs/locks`, method: "GET", signal },
    options
  );
};

export const getJobLocksQueryKey = () => {
  return [`/api/jobs/locks`] as const;
};

export const getJobLocksInfiniteQueryOptions = <
  TData = InfiniteData<Awaited<ReturnType<typeof jobLocks>>>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(options?: {
  query?: Partial<
    UseInfiniteQueryOptions<Awaited<ReturnType<typeof jobLocks>>, TError, TData>
  >;
  request?: SecondParameter<typeof customInstance>;
}) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getJobLocksQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof jobLocks>>> = ({
    signal,
  }) => jobLocks(requestOptions, signal);

  return { queryKey, queryFn, ...queryOptions } as UseInfiniteQueryOptions<
    Awaited<ReturnType<typeof jobLocks>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type JobLocksInfiniteQueryResult = NonNullable<
  Awaited<ReturnType<typeof jobLocks>>
>;
export type JobLocksInfiniteQueryError =
  ErrorType<AuthenticationExceptionResponse>;

export function useJobLocksInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof jobLocks>>>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(
  options: {
    query: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof jobLocks>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof jobLocks>>,
          TError,
          Awaited<ReturnType<typeof jobLocks>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): DefinedUseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useJobLocksInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof jobLocks>>>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof jobLocks>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof jobLocks>>,
          TError,
          Awaited<ReturnType<typeof jobLocks>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useJobLocksInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof jobLocks>>>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof jobLocks>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get job locks
 */

export function useJobLocksInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof jobLocks>>>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof jobLocks>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getJobLocksInfiniteQueryOptions(options);

  const query = useInfiniteQuery(
    queryOptions,
    queryClient
  ) as UseInfiniteQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getJobLocksQueryOptions = <
  TData = Awaited<ReturnType<typeof jobLocks>>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof jobLocks>>, TError, TData>
  >;
  request?: SecondParameter<typeof customInstance>;
}) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getJobLocksQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof jobLocks>>> = ({
    signal,
  }) => jobLocks(requestOptions, signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof jobLocks>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type JobLocksQueryResult = NonNullable<
  Awaited<ReturnType<typeof jobLocks>>
>;
export type JobLocksQueryError = ErrorType<AuthenticationExceptionResponse>;

export function useJobLocks<
  TData = Awaited<ReturnType<typeof jobLocks>>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof jobLocks>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof jobLocks>>,
          TError,
          Awaited<ReturnType<typeof jobLocks>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useJobLocks<
  TData = Awaited<ReturnType<typeof jobLocks>>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof jobLocks>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof jobLocks>>,
          TError,
          Awaited<ReturnType<typeof jobLocks>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useJobLocks<
  TData = Awaited<ReturnType<typeof jobLocks>>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof jobLocks>>, TError, TData>
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get job locks
 */

export function useJobLocks<
  TData = Awaited<ReturnType<typeof jobLocks>>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof jobLocks>>, TError, TData>
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getJobLocksQueryOptions(options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getJobLocksSuspenseQueryOptions = <
  TData = Awaited<ReturnType<typeof jobLocks>>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(options?: {
  query?: Partial<
    UseSuspenseQueryOptions<Awaited<ReturnType<typeof jobLocks>>, TError, TData>
  >;
  request?: SecondParameter<typeof customInstance>;
}) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getJobLocksQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof jobLocks>>> = ({
    signal,
  }) => jobLocks(requestOptions, signal);

  return { queryKey, queryFn, ...queryOptions } as UseSuspenseQueryOptions<
    Awaited<ReturnType<typeof jobLocks>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type JobLocksSuspenseQueryResult = NonNullable<
  Awaited<ReturnType<typeof jobLocks>>
>;
export type JobLocksSuspenseQueryError =
  ErrorType<AuthenticationExceptionResponse>;

export function useJobLocksSuspense<
  TData = Awaited<ReturnType<typeof jobLocks>>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(
  options: {
    query: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof jobLocks>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useJobLocksSuspense<
  TData = Awaited<ReturnType<typeof jobLocks>>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof jobLocks>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useJobLocksSuspense<
  TData = Awaited<ReturnType<typeof jobLocks>>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof jobLocks>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get job locks
 */

export function useJobLocksSuspense<
  TData = Awaited<ReturnType<typeof jobLocks>>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof jobLocks>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getJobLocksSuspenseQueryOptions(options);

  const query = useSuspenseQuery(
    queryOptions,
    queryClient
  ) as UseSuspenseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getJobLocksSuspenseInfiniteQueryOptions = <
  TData = InfiniteData<Awaited<ReturnType<typeof jobLocks>>>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(options?: {
  query?: Partial<
    UseSuspenseInfiniteQueryOptions<
      Awaited<ReturnType<typeof jobLocks>>,
      TError,
      TData
    >
  >;
  request?: SecondParameter<typeof customInstance>;
}) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getJobLocksQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof jobLocks>>> = ({
    signal,
  }) => jobLocks(requestOptions, signal);

  return {
    queryKey,
    queryFn,
    ...queryOptions,
  } as UseSuspenseInfiniteQueryOptions<
    Awaited<ReturnType<typeof jobLocks>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type JobLocksSuspenseInfiniteQueryResult = NonNullable<
  Awaited<ReturnType<typeof jobLocks>>
>;
export type JobLocksSuspenseInfiniteQueryError =
  ErrorType<AuthenticationExceptionResponse>;

export function useJobLocksSuspenseInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof jobLocks>>>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(
  options: {
    query: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof jobLocks>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useJobLocksSuspenseInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof jobLocks>>>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof jobLocks>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useJobLocksSuspenseInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof jobLocks>>>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof jobLocks>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get job locks
 */

export function useJobLocksSuspenseInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof jobLocks>>>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof jobLocks>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getJobLocksSuspenseInfiniteQueryOptions(options);

  const query = useSuspenseInfiniteQuery(
    queryOptions,
    queryClient
  ) as UseSuspenseInfiniteQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Get job lock
 */
export const jobLock = (
  jobClass: string,
  jobId: string,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal
) => {
  return customInstance<JobLock200>(
    { url: `/api/jobs/locks/${jobClass}/lock/${jobId}`, method: "GET", signal },
    options
  );
};

export const getJobLockQueryKey = (jobClass?: string, jobId?: string) => {
  return [`/api/jobs/locks/${jobClass}/lock/${jobId}`] as const;
};

export const getJobLockInfiniteQueryOptions = <
  TData = InfiniteData<Awaited<ReturnType<typeof jobLock>>>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(
  jobClass: string,
  jobId: string,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof jobLock>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getJobLockQueryKey(jobClass, jobId);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof jobLock>>> = ({
    signal,
  }) => jobLock(jobClass, jobId, requestOptions, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!(jobClass && jobId),
    ...queryOptions,
  } as UseInfiniteQueryOptions<
    Awaited<ReturnType<typeof jobLock>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type JobLockInfiniteQueryResult = NonNullable<
  Awaited<ReturnType<typeof jobLock>>
>;
export type JobLockInfiniteQueryError =
  ErrorType<AuthenticationExceptionResponse>;

export function useJobLockInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof jobLock>>>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(
  jobClass: string,
  jobId: string,
  options: {
    query: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof jobLock>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof jobLock>>,
          TError,
          Awaited<ReturnType<typeof jobLock>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): DefinedUseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useJobLockInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof jobLock>>>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(
  jobClass: string,
  jobId: string,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof jobLock>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof jobLock>>,
          TError,
          Awaited<ReturnType<typeof jobLock>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useJobLockInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof jobLock>>>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(
  jobClass: string,
  jobId: string,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof jobLock>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get job lock
 */

export function useJobLockInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof jobLock>>>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(
  jobClass: string,
  jobId: string,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof jobLock>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getJobLockInfiniteQueryOptions(jobClass, jobId, options);

  const query = useInfiniteQuery(
    queryOptions,
    queryClient
  ) as UseInfiniteQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getJobLockQueryOptions = <
  TData = Awaited<ReturnType<typeof jobLock>>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(
  jobClass: string,
  jobId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof jobLock>>, TError, TData>
    >;
    request?: SecondParameter<typeof customInstance>;
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getJobLockQueryKey(jobClass, jobId);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof jobLock>>> = ({
    signal,
  }) => jobLock(jobClass, jobId, requestOptions, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!(jobClass && jobId),
    ...queryOptions,
  } as UseQueryOptions<Awaited<ReturnType<typeof jobLock>>, TError, TData> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };
};

export type JobLockQueryResult = NonNullable<
  Awaited<ReturnType<typeof jobLock>>
>;
export type JobLockQueryError = ErrorType<AuthenticationExceptionResponse>;

export function useJobLock<
  TData = Awaited<ReturnType<typeof jobLock>>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(
  jobClass: string,
  jobId: string,
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof jobLock>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof jobLock>>,
          TError,
          Awaited<ReturnType<typeof jobLock>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useJobLock<
  TData = Awaited<ReturnType<typeof jobLock>>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(
  jobClass: string,
  jobId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof jobLock>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof jobLock>>,
          TError,
          Awaited<ReturnType<typeof jobLock>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useJobLock<
  TData = Awaited<ReturnType<typeof jobLock>>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(
  jobClass: string,
  jobId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof jobLock>>, TError, TData>
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get job lock
 */

export function useJobLock<
  TData = Awaited<ReturnType<typeof jobLock>>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(
  jobClass: string,
  jobId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof jobLock>>, TError, TData>
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getJobLockQueryOptions(jobClass, jobId, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getJobLockSuspenseQueryOptions = <
  TData = Awaited<ReturnType<typeof jobLock>>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(
  jobClass: string,
  jobId: string,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof jobLock>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getJobLockQueryKey(jobClass, jobId);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof jobLock>>> = ({
    signal,
  }) => jobLock(jobClass, jobId, requestOptions, signal);

  return { queryKey, queryFn, ...queryOptions } as UseSuspenseQueryOptions<
    Awaited<ReturnType<typeof jobLock>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type JobLockSuspenseQueryResult = NonNullable<
  Awaited<ReturnType<typeof jobLock>>
>;
export type JobLockSuspenseQueryError =
  ErrorType<AuthenticationExceptionResponse>;

export function useJobLockSuspense<
  TData = Awaited<ReturnType<typeof jobLock>>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(
  jobClass: string,
  jobId: string,
  options: {
    query: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof jobLock>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useJobLockSuspense<
  TData = Awaited<ReturnType<typeof jobLock>>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(
  jobClass: string,
  jobId: string,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof jobLock>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useJobLockSuspense<
  TData = Awaited<ReturnType<typeof jobLock>>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(
  jobClass: string,
  jobId: string,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof jobLock>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get job lock
 */

export function useJobLockSuspense<
  TData = Awaited<ReturnType<typeof jobLock>>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(
  jobClass: string,
  jobId: string,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof jobLock>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getJobLockSuspenseQueryOptions(jobClass, jobId, options);

  const query = useSuspenseQuery(
    queryOptions,
    queryClient
  ) as UseSuspenseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getJobLockSuspenseInfiniteQueryOptions = <
  TData = InfiniteData<Awaited<ReturnType<typeof jobLock>>>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(
  jobClass: string,
  jobId: string,
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof jobLock>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getJobLockQueryKey(jobClass, jobId);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof jobLock>>> = ({
    signal,
  }) => jobLock(jobClass, jobId, requestOptions, signal);

  return {
    queryKey,
    queryFn,
    ...queryOptions,
  } as UseSuspenseInfiniteQueryOptions<
    Awaited<ReturnType<typeof jobLock>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type JobLockSuspenseInfiniteQueryResult = NonNullable<
  Awaited<ReturnType<typeof jobLock>>
>;
export type JobLockSuspenseInfiniteQueryError =
  ErrorType<AuthenticationExceptionResponse>;

export function useJobLockSuspenseInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof jobLock>>>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(
  jobClass: string,
  jobId: string,
  options: {
    query: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof jobLock>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useJobLockSuspenseInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof jobLock>>>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(
  jobClass: string,
  jobId: string,
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof jobLock>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useJobLockSuspenseInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof jobLock>>>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(
  jobClass: string,
  jobId: string,
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof jobLock>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get job lock
 */

export function useJobLockSuspenseInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof jobLock>>>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(
  jobClass: string,
  jobId: string,
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof jobLock>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getJobLockSuspenseInfiniteQueryOptions(
    jobClass,
    jobId,
    options
  );

  const query = useSuspenseInfiniteQuery(
    queryOptions,
    queryClient
  ) as UseSuspenseInfiniteQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Destroy job lock
 */
export const jobLockDelete = (
  jobClass: string,
  jobId: string,
  options?: SecondParameter<typeof customInstance>
) => {
  return customInstance<JobLockDelete200>(
    { url: `/api/jobs/locks/${jobClass}/lock/${jobId}`, method: "DELETE" },
    options
  );
};

export const getJobLockDeleteMutationOptions = <
  TError = ErrorType<AuthenticationExceptionResponse>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof jobLockDelete>>,
    TError,
    { jobClass: string; jobId: string },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof jobLockDelete>>,
  TError,
  { jobClass: string; jobId: string },
  TContext
> => {
  const mutationKey = ["jobLockDelete"];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof jobLockDelete>>,
    { jobClass: string; jobId: string }
  > = (props) => {
    const { jobClass, jobId } = props ?? {};

    return jobLockDelete(jobClass, jobId, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type JobLockDeleteMutationResult = NonNullable<
  Awaited<ReturnType<typeof jobLockDelete>>
>;

export type JobLockDeleteMutationError =
  ErrorType<AuthenticationExceptionResponse>;

/**
 * @summary Destroy job lock
 */
export const useJobLockDelete = <
  TError = ErrorType<AuthenticationExceptionResponse>,
  TContext = unknown
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof jobLockDelete>>,
      TError,
      { jobClass: string; jobId: string },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof jobLockDelete>>,
  TError,
  { jobClass: string; jobId: string },
  TContext
> => {
  const mutationOptions = getJobLockDeleteMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
/**
 * @summary Cleanup jobs
 */
export const jobCleanup = (
  jobCleanupBody: BodyType<JobCleanupBody>,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal
) => {
  return customInstance<JobCleanup200>(
    {
      url: `/api/jobs/cleanup`,
      method: "POST",
      headers: { "Content-Type": "application/json" },
      data: jobCleanupBody,
      signal,
    },
    options
  );
};

export const getJobCleanupMutationOptions = <
  TError = ErrorType<AuthenticationExceptionResponse>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof jobCleanup>>,
    TError,
    { data: BodyType<JobCleanupBody> },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof jobCleanup>>,
  TError,
  { data: BodyType<JobCleanupBody> },
  TContext
> => {
  const mutationKey = ["jobCleanup"];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof jobCleanup>>,
    { data: BodyType<JobCleanupBody> }
  > = (props) => {
    const { data } = props ?? {};

    return jobCleanup(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type JobCleanupMutationResult = NonNullable<
  Awaited<ReturnType<typeof jobCleanup>>
>;
export type JobCleanupMutationBody = BodyType<JobCleanupBody>;
export type JobCleanupMutationError =
  ErrorType<AuthenticationExceptionResponse>;

/**
 * @summary Cleanup jobs
 */
export const useJobCleanup = <
  TError = ErrorType<AuthenticationExceptionResponse>,
  TContext = unknown
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof jobCleanup>>,
      TError,
      { data: BodyType<JobCleanupBody> },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof jobCleanup>>,
  TError,
  { data: BodyType<JobCleanupBody> },
  TContext
> => {
  const mutationOptions = getJobCleanupMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
/**
 * @summary Clear failed jobs
 */
export const jobFailedCleanup = (
  jobFailedCleanupBody: BodyType<JobFailedCleanupBody>,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal
) => {
  return customInstance<JobFailedCleanup200>(
    {
      url: `/api/jobs/failed`,
      method: "POST",
      headers: { "Content-Type": "application/json" },
      data: jobFailedCleanupBody,
      signal,
    },
    options
  );
};

export const getJobFailedCleanupMutationOptions = <
  TError = ErrorType<AuthenticationExceptionResponse>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof jobFailedCleanup>>,
    TError,
    { data: BodyType<JobFailedCleanupBody> },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof jobFailedCleanup>>,
  TError,
  { data: BodyType<JobFailedCleanupBody> },
  TContext
> => {
  const mutationKey = ["jobFailedCleanup"];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof jobFailedCleanup>>,
    { data: BodyType<JobFailedCleanupBody> }
  > = (props) => {
    const { data } = props ?? {};

    return jobFailedCleanup(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type JobFailedCleanupMutationResult = NonNullable<
  Awaited<ReturnType<typeof jobFailedCleanup>>
>;
export type JobFailedCleanupMutationBody = BodyType<JobFailedCleanupBody>;
export type JobFailedCleanupMutationError =
  ErrorType<AuthenticationExceptionResponse>;

/**
 * @summary Clear failed jobs
 */
export const useJobFailedCleanup = <
  TError = ErrorType<AuthenticationExceptionResponse>,
  TContext = unknown
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof jobFailedCleanup>>,
      TError,
      { data: BodyType<JobFailedCleanupBody> },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof jobFailedCleanup>>,
  TError,
  { data: BodyType<JobFailedCleanupBody> },
  TContext
> => {
  const mutationOptions = getJobFailedCleanupMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
/**
 * @summary Scan a library
 */
export const jobLibraryScan = (
  slug: string,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal
) => {
  return customInstance<JobLibraryScan200>(
    { url: `/api/jobs/scanLibrary/${slug}`, method: "POST", signal },
    options
  );
};

export const getJobLibraryScanMutationOptions = <
  TError = ErrorType<AuthenticationExceptionResponse>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof jobLibraryScan>>,
    TError,
    { slug: string },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof jobLibraryScan>>,
  TError,
  { slug: string },
  TContext
> => {
  const mutationKey = ["jobLibraryScan"];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof jobLibraryScan>>,
    { slug: string }
  > = (props) => {
    const { slug } = props ?? {};

    return jobLibraryScan(slug, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type JobLibraryScanMutationResult = NonNullable<
  Awaited<ReturnType<typeof jobLibraryScan>>
>;

export type JobLibraryScanMutationError =
  ErrorType<AuthenticationExceptionResponse>;

/**
 * @summary Scan a library
 */
export const useJobLibraryScan = <
  TError = ErrorType<AuthenticationExceptionResponse>,
  TContext = unknown
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof jobLibraryScan>>,
      TError,
      { slug: string },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof jobLibraryScan>>,
  TError,
  { slug: string },
  TContext
> => {
  const mutationOptions = getJobLibraryScanMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
