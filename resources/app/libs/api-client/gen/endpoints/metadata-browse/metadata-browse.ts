/**
 * Generated by orval v7.17.2 üç∫
 * Do not edit manually.
 * B√•nder api docs
 * B√•nder.App is a sophisticated media server developed with the primary goal to deliver high performance and seamless experience for users.
Being built on top of Laravel framework and PostgreSQL for database, it leverages the power of robust backend technologies, providing high security, reliability, and scalability.

The main focus of B√•nder.App is efficient media management and delivery.
This application is designed to handle large amounts of media files while ensuring quick and efficient access.
Implemented queuing functionality through Redis offers efficient job management and load handling.
The media information is organized and easily searchable, ensuring users can always find what they are looking for quickly and easily.
 * OpenAPI spec version: 0.0.1
 */
import {
  useInfiniteQuery,
  useMutation,
  useQuery,
  useSuspenseInfiniteQuery,
  useSuspenseQuery,
} from "@tanstack/react-query";
import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseInfiniteQueryResult,
  DefinedUseQueryResult,
  InfiniteData,
  MutationFunction,
  QueryClient,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseInfiniteQueryOptions,
  UseInfiniteQueryResult,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult,
  UseSuspenseInfiniteQueryOptions,
  UseSuspenseInfiniteQueryResult,
  UseSuspenseQueryOptions,
  UseSuspenseQueryResult,
} from "@tanstack/react-query";

import type {
  ApplyMetadataRequest,
  AuthenticationExceptionResponse,
  MetadataBrowseAlbums200,
  MetadataBrowseAlbumsParams,
  MetadataBrowseApply200,
  MetadataBrowseArtists200,
  MetadataBrowseArtistsParams,
  MetadataBrowseLookup200,
  MetadataBrowseSongs200,
  MetadataBrowseSongsParams,
  ValidationExceptionResponse,
} from "../../models";

import { customInstance } from "../../../axios-instance";
import type { ErrorType, BodyType } from "../../../axios-instance";

type SecondParameter<T extends (...args: never) => unknown> = Parameters<T>[1];

/**
 * @summary Search albums by query
 */
export const metadataBrowseAlbums = (
  params: MetadataBrowseAlbumsParams,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal
) => {
  return customInstance<MetadataBrowseAlbums200>(
    { url: `/api/metadata/browse/albums`, method: "GET", params, signal },
    options
  );
};

export const getMetadataBrowseAlbumsInfiniteQueryKey = (
  params?: MetadataBrowseAlbumsParams
) => {
  return [
    "infinite",
    `/api/metadata/browse/albums`,
    ...(params ? [params] : []),
  ] as const;
};

export const getMetadataBrowseAlbumsQueryKey = (
  params?: MetadataBrowseAlbumsParams
) => {
  return [`/api/metadata/browse/albums`, ...(params ? [params] : [])] as const;
};

export const getMetadataBrowseAlbumsInfiniteQueryOptions = <
  TData = InfiniteData<
    MetadataBrowseAlbums200,
    MetadataBrowseAlbumsParams["page"]
  >,
  TError = ErrorType<
    AuthenticationExceptionResponse | ValidationExceptionResponse
  >
>(
  params: MetadataBrowseAlbumsParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        MetadataBrowseAlbums200,
        TError,
        TData,
        QueryKey,
        MetadataBrowseAlbumsParams["page"]
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getMetadataBrowseAlbumsInfiniteQueryKey(params);

  const queryFn: QueryFunction<
    MetadataBrowseAlbums200,
    QueryKey,
    MetadataBrowseAlbumsParams["page"]
  > = ({ signal, pageParam }) =>
    metadataBrowseAlbums(
      { ...params, page: pageParam || params?.["page"] },
      requestOptions,
      signal
    );

  return { queryKey, queryFn, ...queryOptions } as UseInfiniteQueryOptions<
    MetadataBrowseAlbums200,
    TError,
    TData,
    QueryKey,
    MetadataBrowseAlbumsParams["page"]
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type MetadataBrowseAlbumsInfiniteQueryResult = NonNullable<
  MetadataBrowseAlbums200
>;
export type MetadataBrowseAlbumsInfiniteQueryError = ErrorType<
  AuthenticationExceptionResponse | ValidationExceptionResponse
>;

export function useMetadataBrowseAlbumsInfinite<
  TData = InfiniteData<
    MetadataBrowseAlbums200,
    MetadataBrowseAlbumsParams["page"]
  >,
  TError = ErrorType<
    AuthenticationExceptionResponse | ValidationExceptionResponse
  >
>(
  params: MetadataBrowseAlbumsParams,
  options: {
    query: Partial<
      UseInfiniteQueryOptions<
        MetadataBrowseAlbums200,
        TError,
        TData,
        QueryKey,
        MetadataBrowseAlbumsParams["page"]
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          MetadataBrowseAlbums200,
          TError,
          MetadataBrowseAlbums200,
          QueryKey
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): DefinedUseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useMetadataBrowseAlbumsInfinite<
  TData = InfiniteData<
    MetadataBrowseAlbums200,
    MetadataBrowseAlbumsParams["page"]
  >,
  TError = ErrorType<
    AuthenticationExceptionResponse | ValidationExceptionResponse
  >
>(
  params: MetadataBrowseAlbumsParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        MetadataBrowseAlbums200,
        TError,
        TData,
        QueryKey,
        MetadataBrowseAlbumsParams["page"]
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          MetadataBrowseAlbums200,
          TError,
          MetadataBrowseAlbums200,
          QueryKey
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useMetadataBrowseAlbumsInfinite<
  TData = InfiniteData<
    MetadataBrowseAlbums200,
    MetadataBrowseAlbumsParams["page"]
  >,
  TError = ErrorType<
    AuthenticationExceptionResponse | ValidationExceptionResponse
  >
>(
  params: MetadataBrowseAlbumsParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        MetadataBrowseAlbums200,
        TError,
        TData,
        QueryKey,
        MetadataBrowseAlbumsParams["page"]
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Search albums by query
 */

export function useMetadataBrowseAlbumsInfinite<
  TData = InfiniteData<
    MetadataBrowseAlbums200,
    MetadataBrowseAlbumsParams["page"]
  >,
  TError = ErrorType<
    AuthenticationExceptionResponse | ValidationExceptionResponse
  >
>(
  params: MetadataBrowseAlbumsParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        MetadataBrowseAlbums200,
        TError,
        TData,
        QueryKey,
        MetadataBrowseAlbumsParams["page"]
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getMetadataBrowseAlbumsInfiniteQueryOptions(
    params,
    options
  );

  const query = useInfiniteQuery(
    queryOptions,
    queryClient
  ) as UseInfiniteQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getMetadataBrowseAlbumsQueryOptions = <
  TData = MetadataBrowseAlbums200,
  TError = ErrorType<
    AuthenticationExceptionResponse | ValidationExceptionResponse
  >
>(
  params: MetadataBrowseAlbumsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        MetadataBrowseAlbums200,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getMetadataBrowseAlbumsQueryKey(params);

  const queryFn: QueryFunction<
    MetadataBrowseAlbums200
  > = ({ signal }) => metadataBrowseAlbums(params, requestOptions, signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    MetadataBrowseAlbums200,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type MetadataBrowseAlbumsQueryResult = NonNullable<
  MetadataBrowseAlbums200
>;
export type MetadataBrowseAlbumsQueryError = ErrorType<
  AuthenticationExceptionResponse | ValidationExceptionResponse
>;

export function useMetadataBrowseAlbums<
  TData = MetadataBrowseAlbums200,
  TError = ErrorType<
    AuthenticationExceptionResponse | ValidationExceptionResponse
  >
>(
  params: MetadataBrowseAlbumsParams,
  options: {
    query: Partial<
      UseQueryOptions<
        MetadataBrowseAlbums200,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          MetadataBrowseAlbums200,
          TError,
          MetadataBrowseAlbums200
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useMetadataBrowseAlbums<
  TData = MetadataBrowseAlbums200,
  TError = ErrorType<
    AuthenticationExceptionResponse | ValidationExceptionResponse
  >
>(
  params: MetadataBrowseAlbumsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        MetadataBrowseAlbums200,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          MetadataBrowseAlbums200,
          TError,
          MetadataBrowseAlbums200
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useMetadataBrowseAlbums<
  TData = MetadataBrowseAlbums200,
  TError = ErrorType<
    AuthenticationExceptionResponse | ValidationExceptionResponse
  >
>(
  params: MetadataBrowseAlbumsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        MetadataBrowseAlbums200,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Search albums by query
 */

export function useMetadataBrowseAlbums<
  TData = MetadataBrowseAlbums200,
  TError = ErrorType<
    AuthenticationExceptionResponse | ValidationExceptionResponse
  >
>(
  params: MetadataBrowseAlbumsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        MetadataBrowseAlbums200,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getMetadataBrowseAlbumsQueryOptions(params, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getMetadataBrowseAlbumsSuspenseQueryOptions = <
  TData = MetadataBrowseAlbums200,
  TError = ErrorType<
    AuthenticationExceptionResponse | ValidationExceptionResponse
  >
>(
  params: MetadataBrowseAlbumsParams,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        MetadataBrowseAlbums200,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getMetadataBrowseAlbumsQueryKey(params);

  const queryFn: QueryFunction<
    MetadataBrowseAlbums200
  > = ({ signal }) => metadataBrowseAlbums(params, requestOptions, signal);

  return { queryKey, queryFn, ...queryOptions } as UseSuspenseQueryOptions<
    MetadataBrowseAlbums200,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type MetadataBrowseAlbumsSuspenseQueryResult = NonNullable<
  MetadataBrowseAlbums200
>;
export type MetadataBrowseAlbumsSuspenseQueryError = ErrorType<
  AuthenticationExceptionResponse | ValidationExceptionResponse
>;

export function useMetadataBrowseAlbumsSuspense<
  TData = MetadataBrowseAlbums200,
  TError = ErrorType<
    AuthenticationExceptionResponse | ValidationExceptionResponse
  >
>(
  params: MetadataBrowseAlbumsParams,
  options: {
    query: Partial<
      UseSuspenseQueryOptions<
        MetadataBrowseAlbums200,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useMetadataBrowseAlbumsSuspense<
  TData = MetadataBrowseAlbums200,
  TError = ErrorType<
    AuthenticationExceptionResponse | ValidationExceptionResponse
  >
>(
  params: MetadataBrowseAlbumsParams,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        MetadataBrowseAlbums200,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useMetadataBrowseAlbumsSuspense<
  TData = MetadataBrowseAlbums200,
  TError = ErrorType<
    AuthenticationExceptionResponse | ValidationExceptionResponse
  >
>(
  params: MetadataBrowseAlbumsParams,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        MetadataBrowseAlbums200,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Search albums by query
 */

export function useMetadataBrowseAlbumsSuspense<
  TData = MetadataBrowseAlbums200,
  TError = ErrorType<
    AuthenticationExceptionResponse | ValidationExceptionResponse
  >
>(
  params: MetadataBrowseAlbumsParams,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        MetadataBrowseAlbums200,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getMetadataBrowseAlbumsSuspenseQueryOptions(
    params,
    options
  );

  const query = useSuspenseQuery(
    queryOptions,
    queryClient
  ) as UseSuspenseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getMetadataBrowseAlbumsSuspenseInfiniteQueryOptions = <
  TData = InfiniteData<
    MetadataBrowseAlbums200,
    MetadataBrowseAlbumsParams["page"]
  >,
  TError = ErrorType<
    AuthenticationExceptionResponse | ValidationExceptionResponse
  >
>(
  params: MetadataBrowseAlbumsParams,
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        MetadataBrowseAlbums200,
        TError,
        TData,
        QueryKey,
        MetadataBrowseAlbumsParams["page"]
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getMetadataBrowseAlbumsInfiniteQueryKey(params);

  const queryFn: QueryFunction<
    MetadataBrowseAlbums200,
    QueryKey,
    MetadataBrowseAlbumsParams["page"]
  > = ({ signal, pageParam }) =>
    metadataBrowseAlbums(
      { ...params, page: pageParam || params?.["page"] },
      requestOptions,
      signal
    );

  return {
    queryKey,
    queryFn,
    ...queryOptions,
  } as UseSuspenseInfiniteQueryOptions<
    MetadataBrowseAlbums200,
    TError,
    TData,
    QueryKey,
    MetadataBrowseAlbumsParams["page"]
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type MetadataBrowseAlbumsSuspenseInfiniteQueryResult = NonNullable<
  MetadataBrowseAlbums200
>;
export type MetadataBrowseAlbumsSuspenseInfiniteQueryError = ErrorType<
  AuthenticationExceptionResponse | ValidationExceptionResponse
>;

export function useMetadataBrowseAlbumsSuspenseInfinite<
  TData = InfiniteData<
    MetadataBrowseAlbums200,
    MetadataBrowseAlbumsParams["page"]
  >,
  TError = ErrorType<
    AuthenticationExceptionResponse | ValidationExceptionResponse
  >
>(
  params: MetadataBrowseAlbumsParams,
  options: {
    query: Partial<
      UseSuspenseInfiniteQueryOptions<
        MetadataBrowseAlbums200,
        TError,
        TData,
        QueryKey,
        MetadataBrowseAlbumsParams["page"]
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useMetadataBrowseAlbumsSuspenseInfinite<
  TData = InfiniteData<
    MetadataBrowseAlbums200,
    MetadataBrowseAlbumsParams["page"]
  >,
  TError = ErrorType<
    AuthenticationExceptionResponse | ValidationExceptionResponse
  >
>(
  params: MetadataBrowseAlbumsParams,
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        MetadataBrowseAlbums200,
        TError,
        TData,
        QueryKey,
        MetadataBrowseAlbumsParams["page"]
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useMetadataBrowseAlbumsSuspenseInfinite<
  TData = InfiniteData<
    MetadataBrowseAlbums200,
    MetadataBrowseAlbumsParams["page"]
  >,
  TError = ErrorType<
    AuthenticationExceptionResponse | ValidationExceptionResponse
  >
>(
  params: MetadataBrowseAlbumsParams,
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        MetadataBrowseAlbums200,
        TError,
        TData,
        QueryKey,
        MetadataBrowseAlbumsParams["page"]
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Search albums by query
 */

export function useMetadataBrowseAlbumsSuspenseInfinite<
  TData = InfiniteData<
    MetadataBrowseAlbums200,
    MetadataBrowseAlbumsParams["page"]
  >,
  TError = ErrorType<
    AuthenticationExceptionResponse | ValidationExceptionResponse
  >
>(
  params: MetadataBrowseAlbumsParams,
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        MetadataBrowseAlbums200,
        TError,
        TData,
        QueryKey,
        MetadataBrowseAlbumsParams["page"]
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getMetadataBrowseAlbumsSuspenseInfiniteQueryOptions(
    params,
    options
  );

  const query = useSuspenseInfiniteQuery(
    queryOptions,
    queryClient
  ) as UseSuspenseInfiniteQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Search artists by query
 */
export const metadataBrowseArtists = (
  params: MetadataBrowseArtistsParams,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal
) => {
  return customInstance<MetadataBrowseArtists200>(
    { url: `/api/metadata/browse/artists`, method: "GET", params, signal },
    options
  );
};

export const getMetadataBrowseArtistsInfiniteQueryKey = (
  params?: MetadataBrowseArtistsParams
) => {
  return [
    "infinite",
    `/api/metadata/browse/artists`,
    ...(params ? [params] : []),
  ] as const;
};

export const getMetadataBrowseArtistsQueryKey = (
  params?: MetadataBrowseArtistsParams
) => {
  return [`/api/metadata/browse/artists`, ...(params ? [params] : [])] as const;
};

export const getMetadataBrowseArtistsInfiniteQueryOptions = <
  TData = InfiniteData<
    Awaited<ReturnType<typeof metadataBrowseArtists>>,
    MetadataBrowseArtistsParams["page"]
  >,
  TError = ErrorType<
    AuthenticationExceptionResponse | ValidationExceptionResponse
  >
>(
  params: MetadataBrowseArtistsParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof metadataBrowseArtists>>,
        TError,
        TData,
        QueryKey,
        MetadataBrowseArtistsParams["page"]
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getMetadataBrowseArtistsInfiniteQueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof metadataBrowseArtists>>,
    QueryKey,
    MetadataBrowseArtistsParams["page"]
  > = ({ signal, pageParam }) =>
    metadataBrowseArtists(
      { ...params, page: pageParam || params?.["page"] },
      requestOptions,
      signal
    );

  return { queryKey, queryFn, ...queryOptions } as UseInfiniteQueryOptions<
    Awaited<ReturnType<typeof metadataBrowseArtists>>,
    TError,
    TData,
    QueryKey,
    MetadataBrowseArtistsParams["page"]
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type MetadataBrowseArtistsInfiniteQueryResult = NonNullable<
  Awaited<ReturnType<typeof metadataBrowseArtists>>
>;
export type MetadataBrowseArtistsInfiniteQueryError = ErrorType<
  AuthenticationExceptionResponse | ValidationExceptionResponse
>;

export function useMetadataBrowseArtistsInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof metadataBrowseArtists>>,
    MetadataBrowseArtistsParams["page"]
  >,
  TError = ErrorType<
    AuthenticationExceptionResponse | ValidationExceptionResponse
  >
>(
  params: MetadataBrowseArtistsParams,
  options: {
    query: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof metadataBrowseArtists>>,
        TError,
        TData,
        QueryKey,
        MetadataBrowseArtistsParams["page"]
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof metadataBrowseArtists>>,
          TError,
          Awaited<ReturnType<typeof metadataBrowseArtists>>,
          QueryKey
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): DefinedUseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useMetadataBrowseArtistsInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof metadataBrowseArtists>>,
    MetadataBrowseArtistsParams["page"]
  >,
  TError = ErrorType<
    AuthenticationExceptionResponse | ValidationExceptionResponse
  >
>(
  params: MetadataBrowseArtistsParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof metadataBrowseArtists>>,
        TError,
        TData,
        QueryKey,
        MetadataBrowseArtistsParams["page"]
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof metadataBrowseArtists>>,
          TError,
          Awaited<ReturnType<typeof metadataBrowseArtists>>,
          QueryKey
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useMetadataBrowseArtistsInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof metadataBrowseArtists>>,
    MetadataBrowseArtistsParams["page"]
  >,
  TError = ErrorType<
    AuthenticationExceptionResponse | ValidationExceptionResponse
  >
>(
  params: MetadataBrowseArtistsParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof metadataBrowseArtists>>,
        TError,
        TData,
        QueryKey,
        MetadataBrowseArtistsParams["page"]
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Search artists by query
 */

export function useMetadataBrowseArtistsInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof metadataBrowseArtists>>,
    MetadataBrowseArtistsParams["page"]
  >,
  TError = ErrorType<
    AuthenticationExceptionResponse | ValidationExceptionResponse
  >
>(
  params: MetadataBrowseArtistsParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof metadataBrowseArtists>>,
        TError,
        TData,
        QueryKey,
        MetadataBrowseArtistsParams["page"]
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getMetadataBrowseArtistsInfiniteQueryOptions(
    params,
    options
  );

  const query = useInfiniteQuery(
    queryOptions,
    queryClient
  ) as UseInfiniteQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getMetadataBrowseArtistsQueryOptions = <
  TData = Awaited<ReturnType<typeof metadataBrowseArtists>>,
  TError = ErrorType<
    AuthenticationExceptionResponse | ValidationExceptionResponse
  >
>(
  params: MetadataBrowseArtistsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof metadataBrowseArtists>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getMetadataBrowseArtistsQueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof metadataBrowseArtists>>
  > = ({ signal }) => metadataBrowseArtists(params, requestOptions, signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof metadataBrowseArtists>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type MetadataBrowseArtistsQueryResult = NonNullable<
  Awaited<ReturnType<typeof metadataBrowseArtists>>
>;
export type MetadataBrowseArtistsQueryError = ErrorType<
  AuthenticationExceptionResponse | ValidationExceptionResponse
>;

export function useMetadataBrowseArtists<
  TData = Awaited<ReturnType<typeof metadataBrowseArtists>>,
  TError = ErrorType<
    AuthenticationExceptionResponse | ValidationExceptionResponse
  >
>(
  params: MetadataBrowseArtistsParams,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof metadataBrowseArtists>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof metadataBrowseArtists>>,
          TError,
          Awaited<ReturnType<typeof metadataBrowseArtists>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useMetadataBrowseArtists<
  TData = Awaited<ReturnType<typeof metadataBrowseArtists>>,
  TError = ErrorType<
    AuthenticationExceptionResponse | ValidationExceptionResponse
  >
>(
  params: MetadataBrowseArtistsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof metadataBrowseArtists>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof metadataBrowseArtists>>,
          TError,
          Awaited<ReturnType<typeof metadataBrowseArtists>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useMetadataBrowseArtists<
  TData = Awaited<ReturnType<typeof metadataBrowseArtists>>,
  TError = ErrorType<
    AuthenticationExceptionResponse | ValidationExceptionResponse
  >
>(
  params: MetadataBrowseArtistsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof metadataBrowseArtists>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Search artists by query
 */

export function useMetadataBrowseArtists<
  TData = Awaited<ReturnType<typeof metadataBrowseArtists>>,
  TError = ErrorType<
    AuthenticationExceptionResponse | ValidationExceptionResponse
  >
>(
  params: MetadataBrowseArtistsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof metadataBrowseArtists>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getMetadataBrowseArtistsQueryOptions(params, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getMetadataBrowseArtistsSuspenseQueryOptions = <
  TData = Awaited<ReturnType<typeof metadataBrowseArtists>>,
  TError = ErrorType<
    AuthenticationExceptionResponse | ValidationExceptionResponse
  >
>(
  params: MetadataBrowseArtistsParams,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof metadataBrowseArtists>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getMetadataBrowseArtistsQueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof metadataBrowseArtists>>
  > = ({ signal }) => metadataBrowseArtists(params, requestOptions, signal);

  return { queryKey, queryFn, ...queryOptions } as UseSuspenseQueryOptions<
    Awaited<ReturnType<typeof metadataBrowseArtists>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type MetadataBrowseArtistsSuspenseQueryResult = NonNullable<
  Awaited<ReturnType<typeof metadataBrowseArtists>>
>;
export type MetadataBrowseArtistsSuspenseQueryError = ErrorType<
  AuthenticationExceptionResponse | ValidationExceptionResponse
>;

export function useMetadataBrowseArtistsSuspense<
  TData = Awaited<ReturnType<typeof metadataBrowseArtists>>,
  TError = ErrorType<
    AuthenticationExceptionResponse | ValidationExceptionResponse
  >
>(
  params: MetadataBrowseArtistsParams,
  options: {
    query: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof metadataBrowseArtists>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useMetadataBrowseArtistsSuspense<
  TData = Awaited<ReturnType<typeof metadataBrowseArtists>>,
  TError = ErrorType<
    AuthenticationExceptionResponse | ValidationExceptionResponse
  >
>(
  params: MetadataBrowseArtistsParams,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof metadataBrowseArtists>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useMetadataBrowseArtistsSuspense<
  TData = Awaited<ReturnType<typeof metadataBrowseArtists>>,
  TError = ErrorType<
    AuthenticationExceptionResponse | ValidationExceptionResponse
  >
>(
  params: MetadataBrowseArtistsParams,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof metadataBrowseArtists>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Search artists by query
 */

export function useMetadataBrowseArtistsSuspense<
  TData = Awaited<ReturnType<typeof metadataBrowseArtists>>,
  TError = ErrorType<
    AuthenticationExceptionResponse | ValidationExceptionResponse
  >
>(
  params: MetadataBrowseArtistsParams,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof metadataBrowseArtists>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getMetadataBrowseArtistsSuspenseQueryOptions(
    params,
    options
  );

  const query = useSuspenseQuery(
    queryOptions,
    queryClient
  ) as UseSuspenseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getMetadataBrowseArtistsSuspenseInfiniteQueryOptions = <
  TData = InfiniteData<
    Awaited<ReturnType<typeof metadataBrowseArtists>>,
    MetadataBrowseArtistsParams["page"]
  >,
  TError = ErrorType<
    AuthenticationExceptionResponse | ValidationExceptionResponse
  >
>(
  params: MetadataBrowseArtistsParams,
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof metadataBrowseArtists>>,
        TError,
        TData,
        QueryKey,
        MetadataBrowseArtistsParams["page"]
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getMetadataBrowseArtistsInfiniteQueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof metadataBrowseArtists>>,
    QueryKey,
    MetadataBrowseArtistsParams["page"]
  > = ({ signal, pageParam }) =>
    metadataBrowseArtists(
      { ...params, page: pageParam || params?.["page"] },
      requestOptions,
      signal
    );

  return {
    queryKey,
    queryFn,
    ...queryOptions,
  } as UseSuspenseInfiniteQueryOptions<
    Awaited<ReturnType<typeof metadataBrowseArtists>>,
    TError,
    TData,
    QueryKey,
    MetadataBrowseArtistsParams["page"]
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type MetadataBrowseArtistsSuspenseInfiniteQueryResult = NonNullable<
  Awaited<ReturnType<typeof metadataBrowseArtists>>
>;
export type MetadataBrowseArtistsSuspenseInfiniteQueryError = ErrorType<
  AuthenticationExceptionResponse | ValidationExceptionResponse
>;

export function useMetadataBrowseArtistsSuspenseInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof metadataBrowseArtists>>,
    MetadataBrowseArtistsParams["page"]
  >,
  TError = ErrorType<
    AuthenticationExceptionResponse | ValidationExceptionResponse
  >
>(
  params: MetadataBrowseArtistsParams,
  options: {
    query: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof metadataBrowseArtists>>,
        TError,
        TData,
        QueryKey,
        MetadataBrowseArtistsParams["page"]
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useMetadataBrowseArtistsSuspenseInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof metadataBrowseArtists>>,
    MetadataBrowseArtistsParams["page"]
  >,
  TError = ErrorType<
    AuthenticationExceptionResponse | ValidationExceptionResponse
  >
>(
  params: MetadataBrowseArtistsParams,
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof metadataBrowseArtists>>,
        TError,
        TData,
        QueryKey,
        MetadataBrowseArtistsParams["page"]
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useMetadataBrowseArtistsSuspenseInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof metadataBrowseArtists>>,
    MetadataBrowseArtistsParams["page"]
  >,
  TError = ErrorType<
    AuthenticationExceptionResponse | ValidationExceptionResponse
  >
>(
  params: MetadataBrowseArtistsParams,
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof metadataBrowseArtists>>,
        TError,
        TData,
        QueryKey,
        MetadataBrowseArtistsParams["page"]
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Search artists by query
 */

export function useMetadataBrowseArtistsSuspenseInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof metadataBrowseArtists>>,
    MetadataBrowseArtistsParams["page"]
  >,
  TError = ErrorType<
    AuthenticationExceptionResponse | ValidationExceptionResponse
  >
>(
  params: MetadataBrowseArtistsParams,
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof metadataBrowseArtists>>,
        TError,
        TData,
        QueryKey,
        MetadataBrowseArtistsParams["page"]
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getMetadataBrowseArtistsSuspenseInfiniteQueryOptions(
    params,
    options
  );

  const query = useSuspenseInfiniteQuery(
    queryOptions,
    queryClient
  ) as UseSuspenseInfiniteQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Search songs by query
 */
export const metadataBrowseSongs = (
  params: MetadataBrowseSongsParams,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal
) => {
  return customInstance<MetadataBrowseSongs200>(
    { url: `/api/metadata/browse/songs`, method: "GET", params, signal },
    options
  );
};

export const getMetadataBrowseSongsInfiniteQueryKey = (
  params?: MetadataBrowseSongsParams
) => {
  return [
    "infinite",
    `/api/metadata/browse/songs`,
    ...(params ? [params] : []),
  ] as const;
};

export const getMetadataBrowseSongsQueryKey = (
  params?: MetadataBrowseSongsParams
) => {
  return [`/api/metadata/browse/songs`, ...(params ? [params] : [])] as const;
};

export const getMetadataBrowseSongsInfiniteQueryOptions = <
  TData = InfiniteData<
    Awaited<ReturnType<typeof metadataBrowseSongs>>,
    MetadataBrowseSongsParams["page"]
  >,
  TError = ErrorType<
    AuthenticationExceptionResponse | ValidationExceptionResponse
  >
>(
  params: MetadataBrowseSongsParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof metadataBrowseSongs>>,
        TError,
        TData,
        QueryKey,
        MetadataBrowseSongsParams["page"]
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getMetadataBrowseSongsInfiniteQueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof metadataBrowseSongs>>,
    QueryKey,
    MetadataBrowseSongsParams["page"]
  > = ({ signal, pageParam }) =>
    metadataBrowseSongs(
      { ...params, page: pageParam || params?.["page"] },
      requestOptions,
      signal
    );

  return { queryKey, queryFn, ...queryOptions } as UseInfiniteQueryOptions<
    Awaited<ReturnType<typeof metadataBrowseSongs>>,
    TError,
    TData,
    QueryKey,
    MetadataBrowseSongsParams["page"]
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type MetadataBrowseSongsInfiniteQueryResult = NonNullable<
  Awaited<ReturnType<typeof metadataBrowseSongs>>
>;
export type MetadataBrowseSongsInfiniteQueryError = ErrorType<
  AuthenticationExceptionResponse | ValidationExceptionResponse
>;

export function useMetadataBrowseSongsInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof metadataBrowseSongs>>,
    MetadataBrowseSongsParams["page"]
  >,
  TError = ErrorType<
    AuthenticationExceptionResponse | ValidationExceptionResponse
  >
>(
  params: MetadataBrowseSongsParams,
  options: {
    query: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof metadataBrowseSongs>>,
        TError,
        TData,
        QueryKey,
        MetadataBrowseSongsParams["page"]
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof metadataBrowseSongs>>,
          TError,
          Awaited<ReturnType<typeof metadataBrowseSongs>>,
          QueryKey
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): DefinedUseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useMetadataBrowseSongsInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof metadataBrowseSongs>>,
    MetadataBrowseSongsParams["page"]
  >,
  TError = ErrorType<
    AuthenticationExceptionResponse | ValidationExceptionResponse
  >
>(
  params: MetadataBrowseSongsParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof metadataBrowseSongs>>,
        TError,
        TData,
        QueryKey,
        MetadataBrowseSongsParams["page"]
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof metadataBrowseSongs>>,
          TError,
          Awaited<ReturnType<typeof metadataBrowseSongs>>,
          QueryKey
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useMetadataBrowseSongsInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof metadataBrowseSongs>>,
    MetadataBrowseSongsParams["page"]
  >,
  TError = ErrorType<
    AuthenticationExceptionResponse | ValidationExceptionResponse
  >
>(
  params: MetadataBrowseSongsParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof metadataBrowseSongs>>,
        TError,
        TData,
        QueryKey,
        MetadataBrowseSongsParams["page"]
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Search songs by query
 */

export function useMetadataBrowseSongsInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof metadataBrowseSongs>>,
    MetadataBrowseSongsParams["page"]
  >,
  TError = ErrorType<
    AuthenticationExceptionResponse | ValidationExceptionResponse
  >
>(
  params: MetadataBrowseSongsParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof metadataBrowseSongs>>,
        TError,
        TData,
        QueryKey,
        MetadataBrowseSongsParams["page"]
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getMetadataBrowseSongsInfiniteQueryOptions(
    params,
    options
  );

  const query = useInfiniteQuery(
    queryOptions,
    queryClient
  ) as UseInfiniteQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getMetadataBrowseSongsQueryOptions = <
  TData = Awaited<ReturnType<typeof metadataBrowseSongs>>,
  TError = ErrorType<
    AuthenticationExceptionResponse | ValidationExceptionResponse
  >
>(
  params: MetadataBrowseSongsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof metadataBrowseSongs>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getMetadataBrowseSongsQueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof metadataBrowseSongs>>
  > = ({ signal }) => metadataBrowseSongs(params, requestOptions, signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof metadataBrowseSongs>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type MetadataBrowseSongsQueryResult = NonNullable<
  Awaited<ReturnType<typeof metadataBrowseSongs>>
>;
export type MetadataBrowseSongsQueryError = ErrorType<
  AuthenticationExceptionResponse | ValidationExceptionResponse
>;

export function useMetadataBrowseSongs<
  TData = Awaited<ReturnType<typeof metadataBrowseSongs>>,
  TError = ErrorType<
    AuthenticationExceptionResponse | ValidationExceptionResponse
  >
>(
  params: MetadataBrowseSongsParams,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof metadataBrowseSongs>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof metadataBrowseSongs>>,
          TError,
          Awaited<ReturnType<typeof metadataBrowseSongs>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useMetadataBrowseSongs<
  TData = Awaited<ReturnType<typeof metadataBrowseSongs>>,
  TError = ErrorType<
    AuthenticationExceptionResponse | ValidationExceptionResponse
  >
>(
  params: MetadataBrowseSongsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof metadataBrowseSongs>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof metadataBrowseSongs>>,
          TError,
          Awaited<ReturnType<typeof metadataBrowseSongs>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useMetadataBrowseSongs<
  TData = Awaited<ReturnType<typeof metadataBrowseSongs>>,
  TError = ErrorType<
    AuthenticationExceptionResponse | ValidationExceptionResponse
  >
>(
  params: MetadataBrowseSongsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof metadataBrowseSongs>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Search songs by query
 */

export function useMetadataBrowseSongs<
  TData = Awaited<ReturnType<typeof metadataBrowseSongs>>,
  TError = ErrorType<
    AuthenticationExceptionResponse | ValidationExceptionResponse
  >
>(
  params: MetadataBrowseSongsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof metadataBrowseSongs>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getMetadataBrowseSongsQueryOptions(params, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getMetadataBrowseSongsSuspenseQueryOptions = <
  TData = Awaited<ReturnType<typeof metadataBrowseSongs>>,
  TError = ErrorType<
    AuthenticationExceptionResponse | ValidationExceptionResponse
  >
>(
  params: MetadataBrowseSongsParams,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof metadataBrowseSongs>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getMetadataBrowseSongsQueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof metadataBrowseSongs>>
  > = ({ signal }) => metadataBrowseSongs(params, requestOptions, signal);

  return { queryKey, queryFn, ...queryOptions } as UseSuspenseQueryOptions<
    Awaited<ReturnType<typeof metadataBrowseSongs>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type MetadataBrowseSongsSuspenseQueryResult = NonNullable<
  Awaited<ReturnType<typeof metadataBrowseSongs>>
>;
export type MetadataBrowseSongsSuspenseQueryError = ErrorType<
  AuthenticationExceptionResponse | ValidationExceptionResponse
>;

export function useMetadataBrowseSongsSuspense<
  TData = Awaited<ReturnType<typeof metadataBrowseSongs>>,
  TError = ErrorType<
    AuthenticationExceptionResponse | ValidationExceptionResponse
  >
>(
  params: MetadataBrowseSongsParams,
  options: {
    query: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof metadataBrowseSongs>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useMetadataBrowseSongsSuspense<
  TData = Awaited<ReturnType<typeof metadataBrowseSongs>>,
  TError = ErrorType<
    AuthenticationExceptionResponse | ValidationExceptionResponse
  >
>(
  params: MetadataBrowseSongsParams,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof metadataBrowseSongs>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useMetadataBrowseSongsSuspense<
  TData = Awaited<ReturnType<typeof metadataBrowseSongs>>,
  TError = ErrorType<
    AuthenticationExceptionResponse | ValidationExceptionResponse
  >
>(
  params: MetadataBrowseSongsParams,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof metadataBrowseSongs>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Search songs by query
 */

export function useMetadataBrowseSongsSuspense<
  TData = Awaited<ReturnType<typeof metadataBrowseSongs>>,
  TError = ErrorType<
    AuthenticationExceptionResponse | ValidationExceptionResponse
  >
>(
  params: MetadataBrowseSongsParams,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof metadataBrowseSongs>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getMetadataBrowseSongsSuspenseQueryOptions(
    params,
    options
  );

  const query = useSuspenseQuery(
    queryOptions,
    queryClient
  ) as UseSuspenseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getMetadataBrowseSongsSuspenseInfiniteQueryOptions = <
  TData = InfiniteData<
    Awaited<ReturnType<typeof metadataBrowseSongs>>,
    MetadataBrowseSongsParams["page"]
  >,
  TError = ErrorType<
    AuthenticationExceptionResponse | ValidationExceptionResponse
  >
>(
  params: MetadataBrowseSongsParams,
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof metadataBrowseSongs>>,
        TError,
        TData,
        QueryKey,
        MetadataBrowseSongsParams["page"]
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getMetadataBrowseSongsInfiniteQueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof metadataBrowseSongs>>,
    QueryKey,
    MetadataBrowseSongsParams["page"]
  > = ({ signal, pageParam }) =>
    metadataBrowseSongs(
      { ...params, page: pageParam || params?.["page"] },
      requestOptions,
      signal
    );

  return {
    queryKey,
    queryFn,
    ...queryOptions,
  } as UseSuspenseInfiniteQueryOptions<
    Awaited<ReturnType<typeof metadataBrowseSongs>>,
    TError,
    TData,
    QueryKey,
    MetadataBrowseSongsParams["page"]
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type MetadataBrowseSongsSuspenseInfiniteQueryResult = NonNullable<
  Awaited<ReturnType<typeof metadataBrowseSongs>>
>;
export type MetadataBrowseSongsSuspenseInfiniteQueryError = ErrorType<
  AuthenticationExceptionResponse | ValidationExceptionResponse
>;

export function useMetadataBrowseSongsSuspenseInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof metadataBrowseSongs>>,
    MetadataBrowseSongsParams["page"]
  >,
  TError = ErrorType<
    AuthenticationExceptionResponse | ValidationExceptionResponse
  >
>(
  params: MetadataBrowseSongsParams,
  options: {
    query: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof metadataBrowseSongs>>,
        TError,
        TData,
        QueryKey,
        MetadataBrowseSongsParams["page"]
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useMetadataBrowseSongsSuspenseInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof metadataBrowseSongs>>,
    MetadataBrowseSongsParams["page"]
  >,
  TError = ErrorType<
    AuthenticationExceptionResponse | ValidationExceptionResponse
  >
>(
  params: MetadataBrowseSongsParams,
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof metadataBrowseSongs>>,
        TError,
        TData,
        QueryKey,
        MetadataBrowseSongsParams["page"]
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useMetadataBrowseSongsSuspenseInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof metadataBrowseSongs>>,
    MetadataBrowseSongsParams["page"]
  >,
  TError = ErrorType<
    AuthenticationExceptionResponse | ValidationExceptionResponse
  >
>(
  params: MetadataBrowseSongsParams,
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof metadataBrowseSongs>>,
        TError,
        TData,
        QueryKey,
        MetadataBrowseSongsParams["page"]
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Search songs by query
 */

export function useMetadataBrowseSongsSuspenseInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof metadataBrowseSongs>>,
    MetadataBrowseSongsParams["page"]
  >,
  TError = ErrorType<
    AuthenticationExceptionResponse | ValidationExceptionResponse
  >
>(
  params: MetadataBrowseSongsParams,
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof metadataBrowseSongs>>,
        TError,
        TData,
        QueryKey,
        MetadataBrowseSongsParams["page"]
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getMetadataBrowseSongsSuspenseInfiniteQueryOptions(
    params,
    options
  );

  const query = useSuspenseInfiniteQuery(
    queryOptions,
    queryClient
  ) as UseSuspenseInfiniteQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Lookup by provider-specific ID
 */
export const metadataBrowseLookup = (
  source: string,
  id: string,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal
) => {
  return customInstance<MetadataBrowseLookup200>(
    {
      url: `/api/metadata/browse/lookup/${source}/${id}`,
      method: "GET",
      signal,
    },
    options
  );
};

export const getMetadataBrowseLookupInfiniteQueryKey = (
  source?: string,
  id?: string
) => {
  return ["infinite", `/api/metadata/browse/lookup/${source}/${id}`] as const;
};

export const getMetadataBrowseLookupQueryKey = (
  source?: string,
  id?: string
) => {
  return [`/api/metadata/browse/lookup/${source}/${id}`] as const;
};

export const getMetadataBrowseLookupInfiniteQueryOptions = <
  TData = InfiniteData<Awaited<ReturnType<typeof metadataBrowseLookup>>>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(
  source: string,
  id: string,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof metadataBrowseLookup>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getMetadataBrowseLookupInfiniteQueryKey(source, id);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof metadataBrowseLookup>>
  > = ({ signal }) => metadataBrowseLookup(source, id, requestOptions, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!(source && id),
    ...queryOptions,
  } as UseInfiniteQueryOptions<
    Awaited<ReturnType<typeof metadataBrowseLookup>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type MetadataBrowseLookupInfiniteQueryResult = NonNullable<
  Awaited<ReturnType<typeof metadataBrowseLookup>>
>;
export type MetadataBrowseLookupInfiniteQueryError =
  ErrorType<AuthenticationExceptionResponse>;

export function useMetadataBrowseLookupInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof metadataBrowseLookup>>>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(
  source: string,
  id: string,
  options: {
    query: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof metadataBrowseLookup>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof metadataBrowseLookup>>,
          TError,
          Awaited<ReturnType<typeof metadataBrowseLookup>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): DefinedUseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useMetadataBrowseLookupInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof metadataBrowseLookup>>>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(
  source: string,
  id: string,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof metadataBrowseLookup>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof metadataBrowseLookup>>,
          TError,
          Awaited<ReturnType<typeof metadataBrowseLookup>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useMetadataBrowseLookupInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof metadataBrowseLookup>>>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(
  source: string,
  id: string,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof metadataBrowseLookup>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Lookup by provider-specific ID
 */

export function useMetadataBrowseLookupInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof metadataBrowseLookup>>>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(
  source: string,
  id: string,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof metadataBrowseLookup>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getMetadataBrowseLookupInfiniteQueryOptions(
    source,
    id,
    options
  );

  const query = useInfiniteQuery(
    queryOptions,
    queryClient
  ) as UseInfiniteQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getMetadataBrowseLookupQueryOptions = <
  TData = Awaited<ReturnType<typeof metadataBrowseLookup>>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(
  source: string,
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof metadataBrowseLookup>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getMetadataBrowseLookupQueryKey(source, id);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof metadataBrowseLookup>>
  > = ({ signal }) => metadataBrowseLookup(source, id, requestOptions, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!(source && id),
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof metadataBrowseLookup>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type MetadataBrowseLookupQueryResult = NonNullable<
  Awaited<ReturnType<typeof metadataBrowseLookup>>
>;
export type MetadataBrowseLookupQueryError =
  ErrorType<AuthenticationExceptionResponse>;

export function useMetadataBrowseLookup<
  TData = Awaited<ReturnType<typeof metadataBrowseLookup>>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(
  source: string,
  id: string,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof metadataBrowseLookup>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof metadataBrowseLookup>>,
          TError,
          Awaited<ReturnType<typeof metadataBrowseLookup>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useMetadataBrowseLookup<
  TData = Awaited<ReturnType<typeof metadataBrowseLookup>>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(
  source: string,
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof metadataBrowseLookup>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof metadataBrowseLookup>>,
          TError,
          Awaited<ReturnType<typeof metadataBrowseLookup>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useMetadataBrowseLookup<
  TData = Awaited<ReturnType<typeof metadataBrowseLookup>>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(
  source: string,
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof metadataBrowseLookup>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Lookup by provider-specific ID
 */

export function useMetadataBrowseLookup<
  TData = Awaited<ReturnType<typeof metadataBrowseLookup>>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(
  source: string,
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof metadataBrowseLookup>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getMetadataBrowseLookupQueryOptions(source, id, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getMetadataBrowseLookupSuspenseQueryOptions = <
  TData = Awaited<ReturnType<typeof metadataBrowseLookup>>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(
  source: string,
  id: string,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof metadataBrowseLookup>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getMetadataBrowseLookupQueryKey(source, id);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof metadataBrowseLookup>>
  > = ({ signal }) => metadataBrowseLookup(source, id, requestOptions, signal);

  return { queryKey, queryFn, ...queryOptions } as UseSuspenseQueryOptions<
    Awaited<ReturnType<typeof metadataBrowseLookup>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type MetadataBrowseLookupSuspenseQueryResult = NonNullable<
  Awaited<ReturnType<typeof metadataBrowseLookup>>
>;
export type MetadataBrowseLookupSuspenseQueryError =
  ErrorType<AuthenticationExceptionResponse>;

export function useMetadataBrowseLookupSuspense<
  TData = Awaited<ReturnType<typeof metadataBrowseLookup>>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(
  source: string,
  id: string,
  options: {
    query: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof metadataBrowseLookup>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useMetadataBrowseLookupSuspense<
  TData = Awaited<ReturnType<typeof metadataBrowseLookup>>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(
  source: string,
  id: string,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof metadataBrowseLookup>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useMetadataBrowseLookupSuspense<
  TData = Awaited<ReturnType<typeof metadataBrowseLookup>>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(
  source: string,
  id: string,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof metadataBrowseLookup>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Lookup by provider-specific ID
 */

export function useMetadataBrowseLookupSuspense<
  TData = Awaited<ReturnType<typeof metadataBrowseLookup>>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(
  source: string,
  id: string,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof metadataBrowseLookup>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getMetadataBrowseLookupSuspenseQueryOptions(
    source,
    id,
    options
  );

  const query = useSuspenseQuery(
    queryOptions,
    queryClient
  ) as UseSuspenseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getMetadataBrowseLookupSuspenseInfiniteQueryOptions = <
  TData = InfiniteData<Awaited<ReturnType<typeof metadataBrowseLookup>>>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(
  source: string,
  id: string,
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof metadataBrowseLookup>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getMetadataBrowseLookupInfiniteQueryKey(source, id);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof metadataBrowseLookup>>
  > = ({ signal }) => metadataBrowseLookup(source, id, requestOptions, signal);

  return {
    queryKey,
    queryFn,
    ...queryOptions,
  } as UseSuspenseInfiniteQueryOptions<
    Awaited<ReturnType<typeof metadataBrowseLookup>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type MetadataBrowseLookupSuspenseInfiniteQueryResult = NonNullable<
  Awaited<ReturnType<typeof metadataBrowseLookup>>
>;
export type MetadataBrowseLookupSuspenseInfiniteQueryError =
  ErrorType<AuthenticationExceptionResponse>;

export function useMetadataBrowseLookupSuspenseInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof metadataBrowseLookup>>>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(
  source: string,
  id: string,
  options: {
    query: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof metadataBrowseLookup>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useMetadataBrowseLookupSuspenseInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof metadataBrowseLookup>>>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(
  source: string,
  id: string,
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof metadataBrowseLookup>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useMetadataBrowseLookupSuspenseInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof metadataBrowseLookup>>>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(
  source: string,
  id: string,
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof metadataBrowseLookup>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Lookup by provider-specific ID
 */

export function useMetadataBrowseLookupSuspenseInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof metadataBrowseLookup>>>,
  TError = ErrorType<AuthenticationExceptionResponse>
>(
  source: string,
  id: string,
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof metadataBrowseLookup>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getMetadataBrowseLookupSuspenseInfiniteQueryOptions(
    source,
    id,
    options
  );

  const query = useSuspenseInfiniteQuery(
    queryOptions,
    queryClient
  ) as UseSuspenseInfiniteQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Apply selected metadata to local entity
 */
export const metadataBrowseApply = (
  applyMetadataRequest: BodyType<ApplyMetadataRequest>,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal
) => {
  return customInstance<MetadataBrowseApply200>(
    {
      url: `/api/metadata/browse/apply`,
      method: "POST",
      headers: { "Content-Type": "application/json" },
      data: applyMetadataRequest,
      signal,
    },
    options
  );
};

export const getMetadataBrowseApplyMutationOptions = <
  TError = ErrorType<
    AuthenticationExceptionResponse | ValidationExceptionResponse
  >,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof metadataBrowseApply>>,
    TError,
    { data: BodyType<ApplyMetadataRequest> },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof metadataBrowseApply>>,
  TError,
  { data: BodyType<ApplyMetadataRequest> },
  TContext
> => {
  const mutationKey = ["metadataBrowseApply"];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof metadataBrowseApply>>,
    { data: BodyType<ApplyMetadataRequest> }
  > = (props) => {
    const { data } = props ?? {};

    return metadataBrowseApply(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type MetadataBrowseApplyMutationResult = NonNullable<
  Awaited<ReturnType<typeof metadataBrowseApply>>
>;
export type MetadataBrowseApplyMutationBody = BodyType<ApplyMetadataRequest>;
export type MetadataBrowseApplyMutationError = ErrorType<
  AuthenticationExceptionResponse | ValidationExceptionResponse
>;

/**
 * @summary Apply selected metadata to local entity
 */
export const useMetadataBrowseApply = <
  TError = ErrorType<
    AuthenticationExceptionResponse | ValidationExceptionResponse
  >,
  TContext = unknown
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof metadataBrowseApply>>,
      TError,
      { data: BodyType<ApplyMetadataRequest> },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof metadataBrowseApply>>,
  TError,
  { data: BodyType<ApplyMetadataRequest> },
  TContext
> => {
  const mutationOptions = getMetadataBrowseApplyMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
