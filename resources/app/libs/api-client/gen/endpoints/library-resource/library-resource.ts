/**
 * Generated by orval v7.11.2 üç∫
 * Do not edit manually.
 * B√•nder api docs
 * B√•nder.App is a sophisticated media server developed with the primary goal to deliver high performance and seamless experience for users.
Being built on top of Laravel framework and PostgreSQL for database, it leverages the power of robust backend technologies, providing high security, reliability, and scalability.

The main focus of B√•nder.App is efficient media management and delivery.
This application is designed to handle large amounts of media files while ensuring quick and efficient access.
Implemented queuing functionality through Redis offers efficient job management and load handling.
The media information is organized and easily searchable, ensuring users can always find what they are looking for quickly and easily.
 * OpenAPI spec version: 0.0.1
 */
import {
  useInfiniteQuery,
  useQuery,
  useSuspenseInfiniteQuery,
  useSuspenseQuery,
} from "@tanstack/react-query";
import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseInfiniteQueryResult,
  DefinedUseQueryResult,
  InfiniteData,
  QueryClient,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseInfiniteQueryOptions,
  UseInfiniteQueryResult,
  UseQueryOptions,
  UseQueryResult,
  UseSuspenseInfiniteQueryOptions,
  UseSuspenseInfiniteQueryResult,
  UseSuspenseQueryOptions,
  UseSuspenseQueryResult,
} from "@tanstack/react-query";

import type {
  AlbumResource,
  AuthenticationExceptionResponse,
  ModelNotFoundExceptionResponse,
  ShowByPublicIdSongParams,
  SongResource,
  ValidationExceptionResponse,
} from "../../models";

import { customInstance } from "../../../axios-instance";
import type { ErrorType } from "../../../axios-instance";

type SecondParameter<T extends (...args: never) => unknown> = Parameters<T>[1];

/**
 * @summary Get a song by public ID

Retrieves a single song from the specified library using its public ID.
Supports relation inclusion for comprehensive song information including
artists, album data, genres, and audio metadata
 */
export const showByPublicIdSong = (
  publicId: string,
  params?: ShowByPublicIdSongParams,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal
) => {
  return customInstance<SongResource>(
    { url: `/api/show/${publicId}/song`, method: "GET", params, signal },
    options
  );
};

export const getShowByPublicIdSongQueryKey = (
  publicId?: string,
  params?: ShowByPublicIdSongParams
) => {
  return [`/api/show/${publicId}/song`, ...(params ? [params] : [])] as const;
};

export const getShowByPublicIdSongInfiniteQueryOptions = <
  TData = InfiniteData<
    Awaited<ReturnType<typeof showByPublicIdSong>>,
    ShowByPublicIdSongParams["page"]
  >,
  TError = ErrorType<
    | AuthenticationExceptionResponse
    | ModelNotFoundExceptionResponse
    | ValidationExceptionResponse
  >
>(
  publicId: string,
  params?: ShowByPublicIdSongParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof showByPublicIdSong>>,
        TError,
        TData,
        QueryKey,
        ShowByPublicIdSongParams["page"]
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getShowByPublicIdSongQueryKey(publicId, params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof showByPublicIdSong>>,
    QueryKey,
    ShowByPublicIdSongParams["page"]
  > = ({ signal, pageParam }) =>
    showByPublicIdSong(
      publicId,
      { ...params, page: pageParam || params?.["page"] },
      requestOptions,
      signal
    );

  return {
    queryKey,
    queryFn,
    enabled: !!publicId,
    ...queryOptions,
  } as UseInfiniteQueryOptions<
    Awaited<ReturnType<typeof showByPublicIdSong>>,
    TError,
    TData,
    QueryKey,
    ShowByPublicIdSongParams["page"]
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type ShowByPublicIdSongInfiniteQueryResult = NonNullable<
  Awaited<ReturnType<typeof showByPublicIdSong>>
>;
export type ShowByPublicIdSongInfiniteQueryError = ErrorType<
  | AuthenticationExceptionResponse
  | ModelNotFoundExceptionResponse
  | ValidationExceptionResponse
>;

export function useShowByPublicIdSongInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof showByPublicIdSong>>,
    ShowByPublicIdSongParams["page"]
  >,
  TError = ErrorType<
    | AuthenticationExceptionResponse
    | ModelNotFoundExceptionResponse
    | ValidationExceptionResponse
  >
>(
  publicId: string,
  params: undefined | ShowByPublicIdSongParams,
  options: {
    query: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof showByPublicIdSong>>,
        TError,
        TData,
        QueryKey,
        ShowByPublicIdSongParams["page"]
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof showByPublicIdSong>>,
          TError,
          Awaited<ReturnType<typeof showByPublicIdSong>>,
          QueryKey
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): DefinedUseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useShowByPublicIdSongInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof showByPublicIdSong>>,
    ShowByPublicIdSongParams["page"]
  >,
  TError = ErrorType<
    | AuthenticationExceptionResponse
    | ModelNotFoundExceptionResponse
    | ValidationExceptionResponse
  >
>(
  publicId: string,
  params?: ShowByPublicIdSongParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof showByPublicIdSong>>,
        TError,
        TData,
        QueryKey,
        ShowByPublicIdSongParams["page"]
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof showByPublicIdSong>>,
          TError,
          Awaited<ReturnType<typeof showByPublicIdSong>>,
          QueryKey
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useShowByPublicIdSongInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof showByPublicIdSong>>,
    ShowByPublicIdSongParams["page"]
  >,
  TError = ErrorType<
    | AuthenticationExceptionResponse
    | ModelNotFoundExceptionResponse
    | ValidationExceptionResponse
  >
>(
  publicId: string,
  params?: ShowByPublicIdSongParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof showByPublicIdSong>>,
        TError,
        TData,
        QueryKey,
        ShowByPublicIdSongParams["page"]
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get a song by public ID

Retrieves a single song from the specified library using its public ID.
Supports relation inclusion for comprehensive song information including
artists, album data, genres, and audio metadata
 */

export function useShowByPublicIdSongInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof showByPublicIdSong>>,
    ShowByPublicIdSongParams["page"]
  >,
  TError = ErrorType<
    | AuthenticationExceptionResponse
    | ModelNotFoundExceptionResponse
    | ValidationExceptionResponse
  >
>(
  publicId: string,
  params?: ShowByPublicIdSongParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof showByPublicIdSong>>,
        TError,
        TData,
        QueryKey,
        ShowByPublicIdSongParams["page"]
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getShowByPublicIdSongInfiniteQueryOptions(
    publicId,
    params,
    options
  );

  const query = useInfiniteQuery(
    queryOptions,
    queryClient
  ) as UseInfiniteQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getShowByPublicIdSongQueryOptions = <
  TData = Awaited<ReturnType<typeof showByPublicIdSong>>,
  TError = ErrorType<
    | AuthenticationExceptionResponse
    | ModelNotFoundExceptionResponse
    | ValidationExceptionResponse
  >
>(
  publicId: string,
  params?: ShowByPublicIdSongParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof showByPublicIdSong>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getShowByPublicIdSongQueryKey(publicId, params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof showByPublicIdSong>>
  > = ({ signal }) =>
    showByPublicIdSong(publicId, params, requestOptions, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!publicId,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof showByPublicIdSong>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type ShowByPublicIdSongQueryResult = NonNullable<
  Awaited<ReturnType<typeof showByPublicIdSong>>
>;
export type ShowByPublicIdSongQueryError = ErrorType<
  | AuthenticationExceptionResponse
  | ModelNotFoundExceptionResponse
  | ValidationExceptionResponse
>;

export function useShowByPublicIdSong<
  TData = Awaited<ReturnType<typeof showByPublicIdSong>>,
  TError = ErrorType<
    | AuthenticationExceptionResponse
    | ModelNotFoundExceptionResponse
    | ValidationExceptionResponse
  >
>(
  publicId: string,
  params: undefined | ShowByPublicIdSongParams,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof showByPublicIdSong>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof showByPublicIdSong>>,
          TError,
          Awaited<ReturnType<typeof showByPublicIdSong>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useShowByPublicIdSong<
  TData = Awaited<ReturnType<typeof showByPublicIdSong>>,
  TError = ErrorType<
    | AuthenticationExceptionResponse
    | ModelNotFoundExceptionResponse
    | ValidationExceptionResponse
  >
>(
  publicId: string,
  params?: ShowByPublicIdSongParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof showByPublicIdSong>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof showByPublicIdSong>>,
          TError,
          Awaited<ReturnType<typeof showByPublicIdSong>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useShowByPublicIdSong<
  TData = Awaited<ReturnType<typeof showByPublicIdSong>>,
  TError = ErrorType<
    | AuthenticationExceptionResponse
    | ModelNotFoundExceptionResponse
    | ValidationExceptionResponse
  >
>(
  publicId: string,
  params?: ShowByPublicIdSongParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof showByPublicIdSong>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get a song by public ID

Retrieves a single song from the specified library using its public ID.
Supports relation inclusion for comprehensive song information including
artists, album data, genres, and audio metadata
 */

export function useShowByPublicIdSong<
  TData = Awaited<ReturnType<typeof showByPublicIdSong>>,
  TError = ErrorType<
    | AuthenticationExceptionResponse
    | ModelNotFoundExceptionResponse
    | ValidationExceptionResponse
  >
>(
  publicId: string,
  params?: ShowByPublicIdSongParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof showByPublicIdSong>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getShowByPublicIdSongQueryOptions(
    publicId,
    params,
    options
  );

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getShowByPublicIdSongSuspenseQueryOptions = <
  TData = Awaited<ReturnType<typeof showByPublicIdSong>>,
  TError = ErrorType<
    | AuthenticationExceptionResponse
    | ModelNotFoundExceptionResponse
    | ValidationExceptionResponse
  >
>(
  publicId: string,
  params?: ShowByPublicIdSongParams,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof showByPublicIdSong>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getShowByPublicIdSongQueryKey(publicId, params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof showByPublicIdSong>>
  > = ({ signal }) =>
    showByPublicIdSong(publicId, params, requestOptions, signal);

  return { queryKey, queryFn, ...queryOptions } as UseSuspenseQueryOptions<
    Awaited<ReturnType<typeof showByPublicIdSong>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type ShowByPublicIdSongSuspenseQueryResult = NonNullable<
  Awaited<ReturnType<typeof showByPublicIdSong>>
>;
export type ShowByPublicIdSongSuspenseQueryError = ErrorType<
  | AuthenticationExceptionResponse
  | ModelNotFoundExceptionResponse
  | ValidationExceptionResponse
>;

export function useShowByPublicIdSongSuspense<
  TData = Awaited<ReturnType<typeof showByPublicIdSong>>,
  TError = ErrorType<
    | AuthenticationExceptionResponse
    | ModelNotFoundExceptionResponse
    | ValidationExceptionResponse
  >
>(
  publicId: string,
  params: undefined | ShowByPublicIdSongParams,
  options: {
    query: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof showByPublicIdSong>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useShowByPublicIdSongSuspense<
  TData = Awaited<ReturnType<typeof showByPublicIdSong>>,
  TError = ErrorType<
    | AuthenticationExceptionResponse
    | ModelNotFoundExceptionResponse
    | ValidationExceptionResponse
  >
>(
  publicId: string,
  params?: ShowByPublicIdSongParams,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof showByPublicIdSong>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useShowByPublicIdSongSuspense<
  TData = Awaited<ReturnType<typeof showByPublicIdSong>>,
  TError = ErrorType<
    | AuthenticationExceptionResponse
    | ModelNotFoundExceptionResponse
    | ValidationExceptionResponse
  >
>(
  publicId: string,
  params?: ShowByPublicIdSongParams,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof showByPublicIdSong>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get a song by public ID

Retrieves a single song from the specified library using its public ID.
Supports relation inclusion for comprehensive song information including
artists, album data, genres, and audio metadata
 */

export function useShowByPublicIdSongSuspense<
  TData = Awaited<ReturnType<typeof showByPublicIdSong>>,
  TError = ErrorType<
    | AuthenticationExceptionResponse
    | ModelNotFoundExceptionResponse
    | ValidationExceptionResponse
  >
>(
  publicId: string,
  params?: ShowByPublicIdSongParams,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof showByPublicIdSong>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getShowByPublicIdSongSuspenseQueryOptions(
    publicId,
    params,
    options
  );

  const query = useSuspenseQuery(
    queryOptions,
    queryClient
  ) as UseSuspenseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getShowByPublicIdSongSuspenseInfiniteQueryOptions = <
  TData = InfiniteData<
    Awaited<ReturnType<typeof showByPublicIdSong>>,
    ShowByPublicIdSongParams["page"]
  >,
  TError = ErrorType<
    | AuthenticationExceptionResponse
    | ModelNotFoundExceptionResponse
    | ValidationExceptionResponse
  >
>(
  publicId: string,
  params?: ShowByPublicIdSongParams,
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof showByPublicIdSong>>,
        TError,
        TData,
        QueryKey,
        ShowByPublicIdSongParams["page"]
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getShowByPublicIdSongQueryKey(publicId, params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof showByPublicIdSong>>,
    QueryKey,
    ShowByPublicIdSongParams["page"]
  > = ({ signal, pageParam }) =>
    showByPublicIdSong(
      publicId,
      { ...params, page: pageParam || params?.["page"] },
      requestOptions,
      signal
    );

  return {
    queryKey,
    queryFn,
    ...queryOptions,
  } as UseSuspenseInfiniteQueryOptions<
    Awaited<ReturnType<typeof showByPublicIdSong>>,
    TError,
    TData,
    QueryKey,
    ShowByPublicIdSongParams["page"]
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type ShowByPublicIdSongSuspenseInfiniteQueryResult = NonNullable<
  Awaited<ReturnType<typeof showByPublicIdSong>>
>;
export type ShowByPublicIdSongSuspenseInfiniteQueryError = ErrorType<
  | AuthenticationExceptionResponse
  | ModelNotFoundExceptionResponse
  | ValidationExceptionResponse
>;

export function useShowByPublicIdSongSuspenseInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof showByPublicIdSong>>,
    ShowByPublicIdSongParams["page"]
  >,
  TError = ErrorType<
    | AuthenticationExceptionResponse
    | ModelNotFoundExceptionResponse
    | ValidationExceptionResponse
  >
>(
  publicId: string,
  params: undefined | ShowByPublicIdSongParams,
  options: {
    query: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof showByPublicIdSong>>,
        TError,
        TData,
        QueryKey,
        ShowByPublicIdSongParams["page"]
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useShowByPublicIdSongSuspenseInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof showByPublicIdSong>>,
    ShowByPublicIdSongParams["page"]
  >,
  TError = ErrorType<
    | AuthenticationExceptionResponse
    | ModelNotFoundExceptionResponse
    | ValidationExceptionResponse
  >
>(
  publicId: string,
  params?: ShowByPublicIdSongParams,
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof showByPublicIdSong>>,
        TError,
        TData,
        QueryKey,
        ShowByPublicIdSongParams["page"]
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useShowByPublicIdSongSuspenseInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof showByPublicIdSong>>,
    ShowByPublicIdSongParams["page"]
  >,
  TError = ErrorType<
    | AuthenticationExceptionResponse
    | ModelNotFoundExceptionResponse
    | ValidationExceptionResponse
  >
>(
  publicId: string,
  params?: ShowByPublicIdSongParams,
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof showByPublicIdSong>>,
        TError,
        TData,
        QueryKey,
        ShowByPublicIdSongParams["page"]
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get a song by public ID

Retrieves a single song from the specified library using its public ID.
Supports relation inclusion for comprehensive song information including
artists, album data, genres, and audio metadata
 */

export function useShowByPublicIdSongSuspenseInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof showByPublicIdSong>>,
    ShowByPublicIdSongParams["page"]
  >,
  TError = ErrorType<
    | AuthenticationExceptionResponse
    | ModelNotFoundExceptionResponse
    | ValidationExceptionResponse
  >
>(
  publicId: string,
  params?: ShowByPublicIdSongParams,
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof showByPublicIdSong>>,
        TError,
        TData,
        QueryKey,
        ShowByPublicIdSongParams["page"]
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getShowByPublicIdSongSuspenseInfiniteQueryOptions(
    publicId,
    params,
    options
  );

  const query = useSuspenseInfiniteQuery(
    queryOptions,
    queryClient
  ) as UseSuspenseInfiniteQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Get an album by public ID

Retrieves a single album from the specified library with all related data
including artists, cover art, and songs for comprehensive display
 */
export const libraryResourceShow = (
  publicId: string,
  album: string,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal
) => {
  return customInstance<AlbumResource>(
    { url: `/api/show/${publicId}/${album}`, method: "GET", signal },
    options
  );
};

export const getLibraryResourceShowQueryKey = (
  publicId?: string,
  album?: string
) => {
  return [`/api/show/${publicId}/${album}`] as const;
};

export const getLibraryResourceShowInfiniteQueryOptions = <
  TData = InfiniteData<Awaited<ReturnType<typeof libraryResourceShow>>>,
  TError = ErrorType<unknown>
>(
  publicId: string,
  album: string,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof libraryResourceShow>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getLibraryResourceShowQueryKey(publicId, album);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof libraryResourceShow>>
  > = ({ signal }) =>
    libraryResourceShow(publicId, album, requestOptions, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!(publicId && album),
    ...queryOptions,
  } as UseInfiniteQueryOptions<
    Awaited<ReturnType<typeof libraryResourceShow>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type LibraryResourceShowInfiniteQueryResult = NonNullable<
  Awaited<ReturnType<typeof libraryResourceShow>>
>;
export type LibraryResourceShowInfiniteQueryError = ErrorType<unknown>;

export function useLibraryResourceShowInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof libraryResourceShow>>>,
  TError = ErrorType<unknown>
>(
  publicId: string,
  album: string,
  options: {
    query: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof libraryResourceShow>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof libraryResourceShow>>,
          TError,
          Awaited<ReturnType<typeof libraryResourceShow>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): DefinedUseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useLibraryResourceShowInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof libraryResourceShow>>>,
  TError = ErrorType<unknown>
>(
  publicId: string,
  album: string,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof libraryResourceShow>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof libraryResourceShow>>,
          TError,
          Awaited<ReturnType<typeof libraryResourceShow>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useLibraryResourceShowInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof libraryResourceShow>>>,
  TError = ErrorType<unknown>
>(
  publicId: string,
  album: string,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof libraryResourceShow>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get an album by public ID

Retrieves a single album from the specified library with all related data
including artists, cover art, and songs for comprehensive display
 */

export function useLibraryResourceShowInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof libraryResourceShow>>>,
  TError = ErrorType<unknown>
>(
  publicId: string,
  album: string,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof libraryResourceShow>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getLibraryResourceShowInfiniteQueryOptions(
    publicId,
    album,
    options
  );

  const query = useInfiniteQuery(
    queryOptions,
    queryClient
  ) as UseInfiniteQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getLibraryResourceShowQueryOptions = <
  TData = Awaited<ReturnType<typeof libraryResourceShow>>,
  TError = ErrorType<unknown>
>(
  publicId: string,
  album: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof libraryResourceShow>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getLibraryResourceShowQueryKey(publicId, album);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof libraryResourceShow>>
  > = ({ signal }) =>
    libraryResourceShow(publicId, album, requestOptions, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!(publicId && album),
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof libraryResourceShow>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type LibraryResourceShowQueryResult = NonNullable<
  Awaited<ReturnType<typeof libraryResourceShow>>
>;
export type LibraryResourceShowQueryError = ErrorType<unknown>;

export function useLibraryResourceShow<
  TData = Awaited<ReturnType<typeof libraryResourceShow>>,
  TError = ErrorType<unknown>
>(
  publicId: string,
  album: string,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof libraryResourceShow>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof libraryResourceShow>>,
          TError,
          Awaited<ReturnType<typeof libraryResourceShow>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useLibraryResourceShow<
  TData = Awaited<ReturnType<typeof libraryResourceShow>>,
  TError = ErrorType<unknown>
>(
  publicId: string,
  album: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof libraryResourceShow>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof libraryResourceShow>>,
          TError,
          Awaited<ReturnType<typeof libraryResourceShow>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useLibraryResourceShow<
  TData = Awaited<ReturnType<typeof libraryResourceShow>>,
  TError = ErrorType<unknown>
>(
  publicId: string,
  album: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof libraryResourceShow>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get an album by public ID

Retrieves a single album from the specified library with all related data
including artists, cover art, and songs for comprehensive display
 */

export function useLibraryResourceShow<
  TData = Awaited<ReturnType<typeof libraryResourceShow>>,
  TError = ErrorType<unknown>
>(
  publicId: string,
  album: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof libraryResourceShow>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getLibraryResourceShowQueryOptions(
    publicId,
    album,
    options
  );

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getLibraryResourceShowSuspenseQueryOptions = <
  TData = Awaited<ReturnType<typeof libraryResourceShow>>,
  TError = ErrorType<unknown>
>(
  publicId: string,
  album: string,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof libraryResourceShow>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getLibraryResourceShowQueryKey(publicId, album);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof libraryResourceShow>>
  > = ({ signal }) =>
    libraryResourceShow(publicId, album, requestOptions, signal);

  return { queryKey, queryFn, ...queryOptions } as UseSuspenseQueryOptions<
    Awaited<ReturnType<typeof libraryResourceShow>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type LibraryResourceShowSuspenseQueryResult = NonNullable<
  Awaited<ReturnType<typeof libraryResourceShow>>
>;
export type LibraryResourceShowSuspenseQueryError = ErrorType<unknown>;

export function useLibraryResourceShowSuspense<
  TData = Awaited<ReturnType<typeof libraryResourceShow>>,
  TError = ErrorType<unknown>
>(
  publicId: string,
  album: string,
  options: {
    query: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof libraryResourceShow>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useLibraryResourceShowSuspense<
  TData = Awaited<ReturnType<typeof libraryResourceShow>>,
  TError = ErrorType<unknown>
>(
  publicId: string,
  album: string,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof libraryResourceShow>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useLibraryResourceShowSuspense<
  TData = Awaited<ReturnType<typeof libraryResourceShow>>,
  TError = ErrorType<unknown>
>(
  publicId: string,
  album: string,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof libraryResourceShow>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get an album by public ID

Retrieves a single album from the specified library with all related data
including artists, cover art, and songs for comprehensive display
 */

export function useLibraryResourceShowSuspense<
  TData = Awaited<ReturnType<typeof libraryResourceShow>>,
  TError = ErrorType<unknown>
>(
  publicId: string,
  album: string,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof libraryResourceShow>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getLibraryResourceShowSuspenseQueryOptions(
    publicId,
    album,
    options
  );

  const query = useSuspenseQuery(
    queryOptions,
    queryClient
  ) as UseSuspenseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getLibraryResourceShowSuspenseInfiniteQueryOptions = <
  TData = InfiniteData<Awaited<ReturnType<typeof libraryResourceShow>>>,
  TError = ErrorType<unknown>
>(
  publicId: string,
  album: string,
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof libraryResourceShow>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getLibraryResourceShowQueryKey(publicId, album);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof libraryResourceShow>>
  > = ({ signal }) =>
    libraryResourceShow(publicId, album, requestOptions, signal);

  return {
    queryKey,
    queryFn,
    ...queryOptions,
  } as UseSuspenseInfiniteQueryOptions<
    Awaited<ReturnType<typeof libraryResourceShow>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type LibraryResourceShowSuspenseInfiniteQueryResult = NonNullable<
  Awaited<ReturnType<typeof libraryResourceShow>>
>;
export type LibraryResourceShowSuspenseInfiniteQueryError = ErrorType<unknown>;

export function useLibraryResourceShowSuspenseInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof libraryResourceShow>>>,
  TError = ErrorType<unknown>
>(
  publicId: string,
  album: string,
  options: {
    query: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof libraryResourceShow>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useLibraryResourceShowSuspenseInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof libraryResourceShow>>>,
  TError = ErrorType<unknown>
>(
  publicId: string,
  album: string,
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof libraryResourceShow>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useLibraryResourceShowSuspenseInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof libraryResourceShow>>>,
  TError = ErrorType<unknown>
>(
  publicId: string,
  album: string,
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof libraryResourceShow>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get an album by public ID

Retrieves a single album from the specified library with all related data
including artists, cover art, and songs for comprehensive display
 */

export function useLibraryResourceShowSuspenseInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof libraryResourceShow>>>,
  TError = ErrorType<unknown>
>(
  publicId: string,
  album: string,
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof libraryResourceShow>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getLibraryResourceShowSuspenseInfiniteQueryOptions(
    publicId,
    album,
    options
  );

  const query = useSuspenseInfiniteQuery(
    queryOptions,
    queryClient
  ) as UseSuspenseInfiniteQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}
