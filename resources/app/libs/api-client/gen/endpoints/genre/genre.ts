/**
 * Generated by orval v7.11.2 üç∫
 * Do not edit manually.
 * B√•nder api docs
 * B√•nder.App is a sophisticated media server developed with the primary goal to deliver high performance and seamless experience for users.
Being built on top of Laravel framework and PostgreSQL for database, it leverages the power of robust backend technologies, providing high security, reliability, and scalability.

The main focus of B√•nder.App is efficient media management and delivery.
This application is designed to handle large amounts of media files while ensuring quick and efficient access.
Implemented queuing functionality through Redis offers efficient job management and load handling.
The media information is organized and easily searchable, ensuring users can always find what they are looking for quickly and easily.
 * OpenAPI spec version: 0.0.1
 */
import {
  useInfiniteQuery,
  useMutation,
  useQuery,
  useSuspenseInfiniteQuery,
  useSuspenseQuery,
} from "@tanstack/react-query";
import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseInfiniteQueryResult,
  DefinedUseQueryResult,
  InfiniteData,
  MutationFunction,
  QueryClient,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseInfiniteQueryOptions,
  UseInfiniteQueryResult,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult,
  UseSuspenseInfiniteQueryOptions,
  UseSuspenseInfiniteQueryResult,
  UseSuspenseQueryOptions,
  UseSuspenseQueryResult,
} from "@tanstack/react-query";

import type {
  AuthenticationExceptionResponse,
  GenreResource,
  GenresIndex200,
  GenresIndexParams,
  ModelNotFoundExceptionResponse,
  UpdateGenreRequest,
  ValidationExceptionResponse,
} from "../../models";

import { customInstance } from "../../../axios-instance";
import type { ErrorType, BodyType } from "../../../axios-instance";

type SecondParameter<T extends (...args: never) => unknown> = Parameters<T>[1];

/**
 * @summary Get a collection of genres
 */
export const genresIndex = (
  params?: GenresIndexParams,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal
) => {
  return customInstance<GenresIndex200>(
    { url: `/api/genres`, method: "GET", params, signal },
    options
  );
};

export const getGenresIndexQueryKey = (params?: GenresIndexParams) => {
  return [`/api/genres`, ...(params ? [params] : [])] as const;
};

export const getGenresIndexInfiniteQueryOptions = <
  TData = InfiniteData<
    Awaited<ReturnType<typeof genresIndex>>,
    GenresIndexParams["page"]
  >,
  TError = ErrorType<
    AuthenticationExceptionResponse | ValidationExceptionResponse
  >
>(
  params?: GenresIndexParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof genresIndex>>,
        TError,
        TData,
        QueryKey,
        GenresIndexParams["page"]
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGenresIndexQueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof genresIndex>>,
    QueryKey,
    GenresIndexParams["page"]
  > = ({ signal, pageParam }) =>
    genresIndex(
      { ...params, page: pageParam || params?.["page"] },
      requestOptions,
      signal
    );

  return { queryKey, queryFn, ...queryOptions } as UseInfiniteQueryOptions<
    Awaited<ReturnType<typeof genresIndex>>,
    TError,
    TData,
    QueryKey,
    GenresIndexParams["page"]
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GenresIndexInfiniteQueryResult = NonNullable<
  Awaited<ReturnType<typeof genresIndex>>
>;
export type GenresIndexInfiniteQueryError = ErrorType<
  AuthenticationExceptionResponse | ValidationExceptionResponse
>;

export function useGenresIndexInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof genresIndex>>,
    GenresIndexParams["page"]
  >,
  TError = ErrorType<
    AuthenticationExceptionResponse | ValidationExceptionResponse
  >
>(
  params: undefined | GenresIndexParams,
  options: {
    query: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof genresIndex>>,
        TError,
        TData,
        QueryKey,
        GenresIndexParams["page"]
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof genresIndex>>,
          TError,
          Awaited<ReturnType<typeof genresIndex>>,
          QueryKey
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): DefinedUseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGenresIndexInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof genresIndex>>,
    GenresIndexParams["page"]
  >,
  TError = ErrorType<
    AuthenticationExceptionResponse | ValidationExceptionResponse
  >
>(
  params?: GenresIndexParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof genresIndex>>,
        TError,
        TData,
        QueryKey,
        GenresIndexParams["page"]
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof genresIndex>>,
          TError,
          Awaited<ReturnType<typeof genresIndex>>,
          QueryKey
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGenresIndexInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof genresIndex>>,
    GenresIndexParams["page"]
  >,
  TError = ErrorType<
    AuthenticationExceptionResponse | ValidationExceptionResponse
  >
>(
  params?: GenresIndexParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof genresIndex>>,
        TError,
        TData,
        QueryKey,
        GenresIndexParams["page"]
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get a collection of genres
 */

export function useGenresIndexInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof genresIndex>>,
    GenresIndexParams["page"]
  >,
  TError = ErrorType<
    AuthenticationExceptionResponse | ValidationExceptionResponse
  >
>(
  params?: GenresIndexParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof genresIndex>>,
        TError,
        TData,
        QueryKey,
        GenresIndexParams["page"]
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGenresIndexInfiniteQueryOptions(params, options);

  const query = useInfiniteQuery(
    queryOptions,
    queryClient
  ) as UseInfiniteQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getGenresIndexQueryOptions = <
  TData = Awaited<ReturnType<typeof genresIndex>>,
  TError = ErrorType<
    AuthenticationExceptionResponse | ValidationExceptionResponse
  >
>(
  params?: GenresIndexParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof genresIndex>>, TError, TData>
    >;
    request?: SecondParameter<typeof customInstance>;
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGenresIndexQueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof genresIndex>>> = ({
    signal,
  }) => genresIndex(params, requestOptions, signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof genresIndex>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GenresIndexQueryResult = NonNullable<
  Awaited<ReturnType<typeof genresIndex>>
>;
export type GenresIndexQueryError = ErrorType<
  AuthenticationExceptionResponse | ValidationExceptionResponse
>;

export function useGenresIndex<
  TData = Awaited<ReturnType<typeof genresIndex>>,
  TError = ErrorType<
    AuthenticationExceptionResponse | ValidationExceptionResponse
  >
>(
  params: undefined | GenresIndexParams,
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof genresIndex>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof genresIndex>>,
          TError,
          Awaited<ReturnType<typeof genresIndex>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGenresIndex<
  TData = Awaited<ReturnType<typeof genresIndex>>,
  TError = ErrorType<
    AuthenticationExceptionResponse | ValidationExceptionResponse
  >
>(
  params?: GenresIndexParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof genresIndex>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof genresIndex>>,
          TError,
          Awaited<ReturnType<typeof genresIndex>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGenresIndex<
  TData = Awaited<ReturnType<typeof genresIndex>>,
  TError = ErrorType<
    AuthenticationExceptionResponse | ValidationExceptionResponse
  >
>(
  params?: GenresIndexParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof genresIndex>>, TError, TData>
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get a collection of genres
 */

export function useGenresIndex<
  TData = Awaited<ReturnType<typeof genresIndex>>,
  TError = ErrorType<
    AuthenticationExceptionResponse | ValidationExceptionResponse
  >
>(
  params?: GenresIndexParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof genresIndex>>, TError, TData>
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGenresIndexQueryOptions(params, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getGenresIndexSuspenseQueryOptions = <
  TData = Awaited<ReturnType<typeof genresIndex>>,
  TError = ErrorType<
    AuthenticationExceptionResponse | ValidationExceptionResponse
  >
>(
  params?: GenresIndexParams,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof genresIndex>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGenresIndexQueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof genresIndex>>> = ({
    signal,
  }) => genresIndex(params, requestOptions, signal);

  return { queryKey, queryFn, ...queryOptions } as UseSuspenseQueryOptions<
    Awaited<ReturnType<typeof genresIndex>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GenresIndexSuspenseQueryResult = NonNullable<
  Awaited<ReturnType<typeof genresIndex>>
>;
export type GenresIndexSuspenseQueryError = ErrorType<
  AuthenticationExceptionResponse | ValidationExceptionResponse
>;

export function useGenresIndexSuspense<
  TData = Awaited<ReturnType<typeof genresIndex>>,
  TError = ErrorType<
    AuthenticationExceptionResponse | ValidationExceptionResponse
  >
>(
  params: undefined | GenresIndexParams,
  options: {
    query: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof genresIndex>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGenresIndexSuspense<
  TData = Awaited<ReturnType<typeof genresIndex>>,
  TError = ErrorType<
    AuthenticationExceptionResponse | ValidationExceptionResponse
  >
>(
  params?: GenresIndexParams,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof genresIndex>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGenresIndexSuspense<
  TData = Awaited<ReturnType<typeof genresIndex>>,
  TError = ErrorType<
    AuthenticationExceptionResponse | ValidationExceptionResponse
  >
>(
  params?: GenresIndexParams,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof genresIndex>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get a collection of genres
 */

export function useGenresIndexSuspense<
  TData = Awaited<ReturnType<typeof genresIndex>>,
  TError = ErrorType<
    AuthenticationExceptionResponse | ValidationExceptionResponse
  >
>(
  params?: GenresIndexParams,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof genresIndex>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGenresIndexSuspenseQueryOptions(params, options);

  const query = useSuspenseQuery(
    queryOptions,
    queryClient
  ) as UseSuspenseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getGenresIndexSuspenseInfiniteQueryOptions = <
  TData = InfiniteData<
    Awaited<ReturnType<typeof genresIndex>>,
    GenresIndexParams["page"]
  >,
  TError = ErrorType<
    AuthenticationExceptionResponse | ValidationExceptionResponse
  >
>(
  params?: GenresIndexParams,
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof genresIndex>>,
        TError,
        TData,
        QueryKey,
        GenresIndexParams["page"]
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGenresIndexQueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof genresIndex>>,
    QueryKey,
    GenresIndexParams["page"]
  > = ({ signal, pageParam }) =>
    genresIndex(
      { ...params, page: pageParam || params?.["page"] },
      requestOptions,
      signal
    );

  return {
    queryKey,
    queryFn,
    ...queryOptions,
  } as UseSuspenseInfiniteQueryOptions<
    Awaited<ReturnType<typeof genresIndex>>,
    TError,
    TData,
    QueryKey,
    GenresIndexParams["page"]
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GenresIndexSuspenseInfiniteQueryResult = NonNullable<
  Awaited<ReturnType<typeof genresIndex>>
>;
export type GenresIndexSuspenseInfiniteQueryError = ErrorType<
  AuthenticationExceptionResponse | ValidationExceptionResponse
>;

export function useGenresIndexSuspenseInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof genresIndex>>,
    GenresIndexParams["page"]
  >,
  TError = ErrorType<
    AuthenticationExceptionResponse | ValidationExceptionResponse
  >
>(
  params: undefined | GenresIndexParams,
  options: {
    query: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof genresIndex>>,
        TError,
        TData,
        QueryKey,
        GenresIndexParams["page"]
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGenresIndexSuspenseInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof genresIndex>>,
    GenresIndexParams["page"]
  >,
  TError = ErrorType<
    AuthenticationExceptionResponse | ValidationExceptionResponse
  >
>(
  params?: GenresIndexParams,
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof genresIndex>>,
        TError,
        TData,
        QueryKey,
        GenresIndexParams["page"]
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGenresIndexSuspenseInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof genresIndex>>,
    GenresIndexParams["page"]
  >,
  TError = ErrorType<
    AuthenticationExceptionResponse | ValidationExceptionResponse
  >
>(
  params?: GenresIndexParams,
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof genresIndex>>,
        TError,
        TData,
        QueryKey,
        GenresIndexParams["page"]
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get a collection of genres
 */

export function useGenresIndexSuspenseInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof genresIndex>>,
    GenresIndexParams["page"]
  >,
  TError = ErrorType<
    AuthenticationExceptionResponse | ValidationExceptionResponse
  >
>(
  params?: GenresIndexParams,
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof genresIndex>>,
        TError,
        TData,
        QueryKey,
        GenresIndexParams["page"]
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGenresIndexSuspenseInfiniteQueryOptions(
    params,
    options
  );

  const query = useSuspenseInfiniteQuery(
    queryOptions,
    queryClient
  ) as UseSuspenseInfiniteQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Get a genre
 */
export const genresShow = (
  genre: string,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal
) => {
  return customInstance<GenreResource>(
    { url: `/api/genres/${genre}`, method: "GET", signal },
    options
  );
};

export const getGenresShowQueryKey = (genre?: string) => {
  return [`/api/genres/${genre}`] as const;
};

export const getGenresShowInfiniteQueryOptions = <
  TData = InfiniteData<Awaited<ReturnType<typeof genresShow>>>,
  TError = ErrorType<
    AuthenticationExceptionResponse | ModelNotFoundExceptionResponse
  >
>(
  genre: string,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof genresShow>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGenresShowQueryKey(genre);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof genresShow>>> = ({
    signal,
  }) => genresShow(genre, requestOptions, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!genre,
    ...queryOptions,
  } as UseInfiniteQueryOptions<
    Awaited<ReturnType<typeof genresShow>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GenresShowInfiniteQueryResult = NonNullable<
  Awaited<ReturnType<typeof genresShow>>
>;
export type GenresShowInfiniteQueryError = ErrorType<
  AuthenticationExceptionResponse | ModelNotFoundExceptionResponse
>;

export function useGenresShowInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof genresShow>>>,
  TError = ErrorType<
    AuthenticationExceptionResponse | ModelNotFoundExceptionResponse
  >
>(
  genre: string,
  options: {
    query: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof genresShow>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof genresShow>>,
          TError,
          Awaited<ReturnType<typeof genresShow>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): DefinedUseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGenresShowInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof genresShow>>>,
  TError = ErrorType<
    AuthenticationExceptionResponse | ModelNotFoundExceptionResponse
  >
>(
  genre: string,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof genresShow>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof genresShow>>,
          TError,
          Awaited<ReturnType<typeof genresShow>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGenresShowInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof genresShow>>>,
  TError = ErrorType<
    AuthenticationExceptionResponse | ModelNotFoundExceptionResponse
  >
>(
  genre: string,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof genresShow>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get a genre
 */

export function useGenresShowInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof genresShow>>>,
  TError = ErrorType<
    AuthenticationExceptionResponse | ModelNotFoundExceptionResponse
  >
>(
  genre: string,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof genresShow>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGenresShowInfiniteQueryOptions(genre, options);

  const query = useInfiniteQuery(
    queryOptions,
    queryClient
  ) as UseInfiniteQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getGenresShowQueryOptions = <
  TData = Awaited<ReturnType<typeof genresShow>>,
  TError = ErrorType<
    AuthenticationExceptionResponse | ModelNotFoundExceptionResponse
  >
>(
  genre: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof genresShow>>, TError, TData>
    >;
    request?: SecondParameter<typeof customInstance>;
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGenresShowQueryKey(genre);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof genresShow>>> = ({
    signal,
  }) => genresShow(genre, requestOptions, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!genre,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof genresShow>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GenresShowQueryResult = NonNullable<
  Awaited<ReturnType<typeof genresShow>>
>;
export type GenresShowQueryError = ErrorType<
  AuthenticationExceptionResponse | ModelNotFoundExceptionResponse
>;

export function useGenresShow<
  TData = Awaited<ReturnType<typeof genresShow>>,
  TError = ErrorType<
    AuthenticationExceptionResponse | ModelNotFoundExceptionResponse
  >
>(
  genre: string,
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof genresShow>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof genresShow>>,
          TError,
          Awaited<ReturnType<typeof genresShow>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGenresShow<
  TData = Awaited<ReturnType<typeof genresShow>>,
  TError = ErrorType<
    AuthenticationExceptionResponse | ModelNotFoundExceptionResponse
  >
>(
  genre: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof genresShow>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof genresShow>>,
          TError,
          Awaited<ReturnType<typeof genresShow>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGenresShow<
  TData = Awaited<ReturnType<typeof genresShow>>,
  TError = ErrorType<
    AuthenticationExceptionResponse | ModelNotFoundExceptionResponse
  >
>(
  genre: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof genresShow>>, TError, TData>
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get a genre
 */

export function useGenresShow<
  TData = Awaited<ReturnType<typeof genresShow>>,
  TError = ErrorType<
    AuthenticationExceptionResponse | ModelNotFoundExceptionResponse
  >
>(
  genre: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof genresShow>>, TError, TData>
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGenresShowQueryOptions(genre, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getGenresShowSuspenseQueryOptions = <
  TData = Awaited<ReturnType<typeof genresShow>>,
  TError = ErrorType<
    AuthenticationExceptionResponse | ModelNotFoundExceptionResponse
  >
>(
  genre: string,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof genresShow>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGenresShowQueryKey(genre);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof genresShow>>> = ({
    signal,
  }) => genresShow(genre, requestOptions, signal);

  return { queryKey, queryFn, ...queryOptions } as UseSuspenseQueryOptions<
    Awaited<ReturnType<typeof genresShow>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GenresShowSuspenseQueryResult = NonNullable<
  Awaited<ReturnType<typeof genresShow>>
>;
export type GenresShowSuspenseQueryError = ErrorType<
  AuthenticationExceptionResponse | ModelNotFoundExceptionResponse
>;

export function useGenresShowSuspense<
  TData = Awaited<ReturnType<typeof genresShow>>,
  TError = ErrorType<
    AuthenticationExceptionResponse | ModelNotFoundExceptionResponse
  >
>(
  genre: string,
  options: {
    query: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof genresShow>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGenresShowSuspense<
  TData = Awaited<ReturnType<typeof genresShow>>,
  TError = ErrorType<
    AuthenticationExceptionResponse | ModelNotFoundExceptionResponse
  >
>(
  genre: string,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof genresShow>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGenresShowSuspense<
  TData = Awaited<ReturnType<typeof genresShow>>,
  TError = ErrorType<
    AuthenticationExceptionResponse | ModelNotFoundExceptionResponse
  >
>(
  genre: string,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof genresShow>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get a genre
 */

export function useGenresShowSuspense<
  TData = Awaited<ReturnType<typeof genresShow>>,
  TError = ErrorType<
    AuthenticationExceptionResponse | ModelNotFoundExceptionResponse
  >
>(
  genre: string,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof genresShow>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGenresShowSuspenseQueryOptions(genre, options);

  const query = useSuspenseQuery(
    queryOptions,
    queryClient
  ) as UseSuspenseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getGenresShowSuspenseInfiniteQueryOptions = <
  TData = InfiniteData<Awaited<ReturnType<typeof genresShow>>>,
  TError = ErrorType<
    AuthenticationExceptionResponse | ModelNotFoundExceptionResponse
  >
>(
  genre: string,
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof genresShow>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGenresShowQueryKey(genre);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof genresShow>>> = ({
    signal,
  }) => genresShow(genre, requestOptions, signal);

  return {
    queryKey,
    queryFn,
    ...queryOptions,
  } as UseSuspenseInfiniteQueryOptions<
    Awaited<ReturnType<typeof genresShow>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GenresShowSuspenseInfiniteQueryResult = NonNullable<
  Awaited<ReturnType<typeof genresShow>>
>;
export type GenresShowSuspenseInfiniteQueryError = ErrorType<
  AuthenticationExceptionResponse | ModelNotFoundExceptionResponse
>;

export function useGenresShowSuspenseInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof genresShow>>>,
  TError = ErrorType<
    AuthenticationExceptionResponse | ModelNotFoundExceptionResponse
  >
>(
  genre: string,
  options: {
    query: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof genresShow>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGenresShowSuspenseInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof genresShow>>>,
  TError = ErrorType<
    AuthenticationExceptionResponse | ModelNotFoundExceptionResponse
  >
>(
  genre: string,
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof genresShow>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGenresShowSuspenseInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof genresShow>>>,
  TError = ErrorType<
    AuthenticationExceptionResponse | ModelNotFoundExceptionResponse
  >
>(
  genre: string,
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof genresShow>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get a genre
 */

export function useGenresShowSuspenseInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof genresShow>>>,
  TError = ErrorType<
    AuthenticationExceptionResponse | ModelNotFoundExceptionResponse
  >
>(
  genre: string,
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof genresShow>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGenresShowSuspenseInfiniteQueryOptions(
    genre,
    options
  );

  const query = useSuspenseInfiniteQuery(
    queryOptions,
    queryClient
  ) as UseSuspenseInfiniteQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Update a genre
 */
export const genresUpdate = (
  genre: string,
  updateGenreRequest: BodyType<UpdateGenreRequest>,
  options?: SecondParameter<typeof customInstance>
) => {
  return customInstance<GenreResource>(
    {
      url: `/api/genres/${genre}`,
      method: "PATCH",
      headers: { "Content-Type": "application/json" },
      data: updateGenreRequest,
    },
    options
  );
};

export const getGenresUpdateMutationOptions = <
  TError = ErrorType<
    | AuthenticationExceptionResponse
    | ModelNotFoundExceptionResponse
    | ValidationExceptionResponse
  >,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof genresUpdate>>,
    TError,
    { genre: string; data: BodyType<UpdateGenreRequest> },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof genresUpdate>>,
  TError,
  { genre: string; data: BodyType<UpdateGenreRequest> },
  TContext
> => {
  const mutationKey = ["genresUpdate"];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof genresUpdate>>,
    { genre: string; data: BodyType<UpdateGenreRequest> }
  > = (props) => {
    const { genre, data } = props ?? {};

    return genresUpdate(genre, data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type GenresUpdateMutationResult = NonNullable<
  Awaited<ReturnType<typeof genresUpdate>>
>;
export type GenresUpdateMutationBody = BodyType<UpdateGenreRequest>;
export type GenresUpdateMutationError = ErrorType<
  | AuthenticationExceptionResponse
  | ModelNotFoundExceptionResponse
  | ValidationExceptionResponse
>;

/**
 * @summary Update a genre
 */
export const useGenresUpdate = <
  TError = ErrorType<
    | AuthenticationExceptionResponse
    | ModelNotFoundExceptionResponse
    | ValidationExceptionResponse
  >,
  TContext = unknown
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof genresUpdate>>,
      TError,
      { genre: string; data: BodyType<UpdateGenreRequest> },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof genresUpdate>>,
  TError,
  { genre: string; data: BodyType<UpdateGenreRequest> },
  TContext
> => {
  const mutationOptions = getGenresUpdateMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
/**
 * @summary Delete a genre
 */
export const genresDestroy = (
  genre: string,
  options?: SecondParameter<typeof customInstance>
) => {
  return customInstance<null>(
    { url: `/api/genres/${genre}`, method: "DELETE" },
    options
  );
};

export const getGenresDestroyMutationOptions = <
  TError = ErrorType<
    AuthenticationExceptionResponse | ModelNotFoundExceptionResponse
  >,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof genresDestroy>>,
    TError,
    { genre: string },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof genresDestroy>>,
  TError,
  { genre: string },
  TContext
> => {
  const mutationKey = ["genresDestroy"];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof genresDestroy>>,
    { genre: string }
  > = (props) => {
    const { genre } = props ?? {};

    return genresDestroy(genre, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type GenresDestroyMutationResult = NonNullable<
  Awaited<ReturnType<typeof genresDestroy>>
>;

export type GenresDestroyMutationError = ErrorType<
  AuthenticationExceptionResponse | ModelNotFoundExceptionResponse
>;

/**
 * @summary Delete a genre
 */
export const useGenresDestroy = <
  TError = ErrorType<
    AuthenticationExceptionResponse | ModelNotFoundExceptionResponse
  >,
  TContext = unknown
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof genresDestroy>>,
      TError,
      { genre: string },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof genresDestroy>>,
  TError,
  { genre: string },
  TContext
> => {
  const mutationOptions = getGenresDestroyMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
