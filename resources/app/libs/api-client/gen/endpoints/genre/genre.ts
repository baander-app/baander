/**
 * Generated by orval v7.17.2 üç∫
 * Do not edit manually.
 * B√•nder api docs
 * B√•nder.App is a sophisticated media server developed with the primary goal to deliver high performance and seamless experience for users.
Being built on top of Laravel framework and PostgreSQL for database, it leverages the power of robust backend technologies, providing high security, reliability, and scalability.

The main focus of B√•nder.App is efficient media management and delivery.
This application is designed to handle large amounts of media files while ensuring quick and efficient access.
Implemented queuing functionality through Redis offers efficient job management and load handling.
The media information is organized and easily searchable, ensuring users can always find what they are looking for quickly and easily.
 * OpenAPI spec version: 0.0.1
 */
import {
  useInfiniteQuery,
  useMutation,
  useQuery,
  useSuspenseInfiniteQuery,
  useSuspenseQuery,
} from "@tanstack/react-query";
import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseInfiniteQueryResult,
  DefinedUseQueryResult,
  InfiniteData,
  MutationFunction,
  QueryClient,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseInfiniteQueryOptions,
  UseInfiniteQueryResult,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult,
  UseSuspenseInfiniteQueryOptions,
  UseSuspenseInfiniteQueryResult,
  UseSuspenseQueryOptions,
  UseSuspenseQueryResult,
} from "@tanstack/react-query";

import type {
  AuthenticationExceptionResponse,
  GenreResource,
  GenresIndex200,
  GenresIndexParams,
  ModelNotFoundExceptionResponse,
  UpdateGenreRequest,
  ValidationExceptionResponse,
} from "../../models";

import { customInstance } from "../../../axios-instance";
import type { ErrorType, BodyType } from "../../../axios-instance";

type SecondParameter<T extends (...args: never) => unknown> = Parameters<T>[1];

/**
 * Returns a filtered and paginated list of all music genres in the system.
Supports field selection and library filtering for optimized queries.
 * @summary Get a paginated collection of music genres
 */
export const genresIndex = (
  params?: GenresIndexParams,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal
) => {
  return customInstance<GenresIndex200>(
    { url: `/api/genres`, method: "GET", params, signal },
    options
  );
};

export const getGenresIndexInfiniteQueryKey = (params?: GenresIndexParams) => {
  return ["infinite", `/api/genres`, ...(params ? [params] : [])] as const;
};

export const getGenresIndexQueryKey = (params?: GenresIndexParams) => {
  return [`/api/genres`, ...(params ? [params] : [])] as const;
};

export const getGenresIndexInfiniteQueryOptions = <
  TData = InfiniteData<
    GenresIndex200,
    GenresIndexParams["page"]
  >,
  TError = ErrorType<
    AuthenticationExceptionResponse | ValidationExceptionResponse
  >
>(
  params?: GenresIndexParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        GenresIndex200,
        TError,
        TData,
        QueryKey,
        GenresIndexParams["page"]
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGenresIndexInfiniteQueryKey(params);

  const queryFn: QueryFunction<
    GenresIndex200,
    QueryKey,
    GenresIndexParams["page"]
  > = ({ signal, pageParam }) =>
    genresIndex(
      { ...params, page: pageParam || params?.["page"] },
      requestOptions,
      signal
    );

  return { queryKey, queryFn, ...queryOptions } as UseInfiniteQueryOptions<
    GenresIndex200,
    TError,
    TData,
    QueryKey,
    GenresIndexParams["page"]
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GenresIndexInfiniteQueryResult = NonNullable<
  GenresIndex200
>;
export type GenresIndexInfiniteQueryError = ErrorType<
  AuthenticationExceptionResponse | ValidationExceptionResponse
>;

export function useGenresIndexInfinite<
  TData = InfiniteData<
    GenresIndex200,
    GenresIndexParams["page"]
  >,
  TError = ErrorType<
    AuthenticationExceptionResponse | ValidationExceptionResponse
  >
>(
  params: undefined | GenresIndexParams,
  options: {
    query: Partial<
      UseInfiniteQueryOptions<
        GenresIndex200,
        TError,
        TData,
        QueryKey,
        GenresIndexParams["page"]
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          GenresIndex200,
          TError,
          GenresIndex200,
          QueryKey
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): DefinedUseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGenresIndexInfinite<
  TData = InfiniteData<
    GenresIndex200,
    GenresIndexParams["page"]
  >,
  TError = ErrorType<
    AuthenticationExceptionResponse | ValidationExceptionResponse
  >
>(
  params?: GenresIndexParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        GenresIndex200,
        TError,
        TData,
        QueryKey,
        GenresIndexParams["page"]
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          GenresIndex200,
          TError,
          GenresIndex200,
          QueryKey
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGenresIndexInfinite<
  TData = InfiniteData<
    GenresIndex200,
    GenresIndexParams["page"]
  >,
  TError = ErrorType<
    AuthenticationExceptionResponse | ValidationExceptionResponse
  >
>(
  params?: GenresIndexParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        GenresIndex200,
        TError,
        TData,
        QueryKey,
        GenresIndexParams["page"]
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get a paginated collection of music genres
 */

export function useGenresIndexInfinite<
  TData = InfiniteData<
    GenresIndex200,
    GenresIndexParams["page"]
  >,
  TError = ErrorType<
    AuthenticationExceptionResponse | ValidationExceptionResponse
  >
>(
  params?: GenresIndexParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        GenresIndex200,
        TError,
        TData,
        QueryKey,
        GenresIndexParams["page"]
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGenresIndexInfiniteQueryOptions(params, options);

  const query = useInfiniteQuery(
    queryOptions,
    queryClient
  ) as UseInfiniteQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getGenresIndexQueryOptions = <
  TData = GenresIndex200,
  TError = ErrorType<
    AuthenticationExceptionResponse | ValidationExceptionResponse
  >
>(
  params?: GenresIndexParams,
  options?: {
    query?: Partial<
      UseQueryOptions<GenresIndex200, TError, TData>
    >;
    request?: SecondParameter<typeof customInstance>;
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGenresIndexQueryKey(params);

  const queryFn: QueryFunction<GenresIndex200> = ({
    signal,
  }) => genresIndex(params, requestOptions, signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    GenresIndex200,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GenresIndexQueryResult = NonNullable<
  GenresIndex200
>;
export type GenresIndexQueryError = ErrorType<
  AuthenticationExceptionResponse | ValidationExceptionResponse
>;

export function useGenresIndex<
  TData = GenresIndex200,
  TError = ErrorType<
    AuthenticationExceptionResponse | ValidationExceptionResponse
  >
>(
  params: undefined | GenresIndexParams,
  options: {
    query: Partial<
      UseQueryOptions<GenresIndex200, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          GenresIndex200,
          TError,
          GenresIndex200
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGenresIndex<
  TData = GenresIndex200,
  TError = ErrorType<
    AuthenticationExceptionResponse | ValidationExceptionResponse
  >
>(
  params?: GenresIndexParams,
  options?: {
    query?: Partial<
      UseQueryOptions<GenresIndex200, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          GenresIndex200,
          TError,
          GenresIndex200
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGenresIndex<
  TData = GenresIndex200,
  TError = ErrorType<
    AuthenticationExceptionResponse | ValidationExceptionResponse
  >
>(
  params?: GenresIndexParams,
  options?: {
    query?: Partial<
      UseQueryOptions<GenresIndex200, TError, TData>
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get a paginated collection of music genres
 */

export function useGenresIndex<
  TData = GenresIndex200,
  TError = ErrorType<
    AuthenticationExceptionResponse | ValidationExceptionResponse
  >
>(
  params?: GenresIndexParams,
  options?: {
    query?: Partial<
      UseQueryOptions<GenresIndex200, TError, TData>
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGenresIndexQueryOptions(params, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getGenresIndexSuspenseQueryOptions = <
  TData = GenresIndex200,
  TError = ErrorType<
    AuthenticationExceptionResponse | ValidationExceptionResponse
  >
>(
  params?: GenresIndexParams,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        GenresIndex200,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGenresIndexQueryKey(params);

  const queryFn: QueryFunction<GenresIndex200> = ({
    signal,
  }) => genresIndex(params, requestOptions, signal);

  return { queryKey, queryFn, ...queryOptions } as UseSuspenseQueryOptions<
    GenresIndex200,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GenresIndexSuspenseQueryResult = NonNullable<
  GenresIndex200
>;
export type GenresIndexSuspenseQueryError = ErrorType<
  AuthenticationExceptionResponse | ValidationExceptionResponse
>;

export function useGenresIndexSuspense<
  TData = GenresIndex200,
  TError = ErrorType<
    AuthenticationExceptionResponse | ValidationExceptionResponse
  >
>(
  params: undefined | GenresIndexParams,
  options: {
    query: Partial<
      UseSuspenseQueryOptions<
        GenresIndex200,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGenresIndexSuspense<
  TData = GenresIndex200,
  TError = ErrorType<
    AuthenticationExceptionResponse | ValidationExceptionResponse
  >
>(
  params?: GenresIndexParams,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        GenresIndex200,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGenresIndexSuspense<
  TData = GenresIndex200,
  TError = ErrorType<
    AuthenticationExceptionResponse | ValidationExceptionResponse
  >
>(
  params?: GenresIndexParams,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        GenresIndex200,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get a paginated collection of music genres
 */

export function useGenresIndexSuspense<
  TData = GenresIndex200,
  TError = ErrorType<
    AuthenticationExceptionResponse | ValidationExceptionResponse
  >
>(
  params?: GenresIndexParams,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        GenresIndex200,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGenresIndexSuspenseQueryOptions(params, options);

  const query = useSuspenseQuery(
    queryOptions,
    queryClient
  ) as UseSuspenseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getGenresIndexSuspenseInfiniteQueryOptions = <
  TData = InfiniteData<
    GenresIndex200,
    GenresIndexParams["page"]
  >,
  TError = ErrorType<
    AuthenticationExceptionResponse | ValidationExceptionResponse
  >
>(
  params?: GenresIndexParams,
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        GenresIndex200,
        TError,
        TData,
        QueryKey,
        GenresIndexParams["page"]
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGenresIndexInfiniteQueryKey(params);

  const queryFn: QueryFunction<
    GenresIndex200,
    QueryKey,
    GenresIndexParams["page"]
  > = ({ signal, pageParam }) =>
    genresIndex(
      { ...params, page: pageParam || params?.["page"] },
      requestOptions,
      signal
    );

  return {
    queryKey,
    queryFn,
    ...queryOptions,
  } as UseSuspenseInfiniteQueryOptions<
    GenresIndex200,
    TError,
    TData,
    QueryKey,
    GenresIndexParams["page"]
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GenresIndexSuspenseInfiniteQueryResult = NonNullable<
  GenresIndex200
>;
export type GenresIndexSuspenseInfiniteQueryError = ErrorType<
  AuthenticationExceptionResponse | ValidationExceptionResponse
>;

export function useGenresIndexSuspenseInfinite<
  TData = InfiniteData<
    GenresIndex200,
    GenresIndexParams["page"]
  >,
  TError = ErrorType<
    AuthenticationExceptionResponse | ValidationExceptionResponse
  >
>(
  params: undefined | GenresIndexParams,
  options: {
    query: Partial<
      UseSuspenseInfiniteQueryOptions<
        GenresIndex200,
        TError,
        TData,
        QueryKey,
        GenresIndexParams["page"]
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGenresIndexSuspenseInfinite<
  TData = InfiniteData<
    GenresIndex200,
    GenresIndexParams["page"]
  >,
  TError = ErrorType<
    AuthenticationExceptionResponse | ValidationExceptionResponse
  >
>(
  params?: GenresIndexParams,
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        GenresIndex200,
        TError,
        TData,
        QueryKey,
        GenresIndexParams["page"]
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGenresIndexSuspenseInfinite<
  TData = InfiniteData<
    GenresIndex200,
    GenresIndexParams["page"]
  >,
  TError = ErrorType<
    AuthenticationExceptionResponse | ValidationExceptionResponse
  >
>(
  params?: GenresIndexParams,
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        GenresIndex200,
        TError,
        TData,
        QueryKey,
        GenresIndexParams["page"]
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get a paginated collection of music genres
 */

export function useGenresIndexSuspenseInfinite<
  TData = InfiniteData<
    GenresIndex200,
    GenresIndexParams["page"]
  >,
  TError = ErrorType<
    AuthenticationExceptionResponse | ValidationExceptionResponse
  >
>(
  params?: GenresIndexParams,
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        GenresIndex200,
        TError,
        TData,
        QueryKey,
        GenresIndexParams["page"]
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGenresIndexSuspenseInfiniteQueryOptions(
    params,
    options
  );

  const query = useSuspenseInfiniteQuery(
    queryOptions,
    queryClient
  ) as UseSuspenseInfiniteQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Retrieves a single genre with comprehensive information including
associated artists, albums, and usage statistics.
 * @summary Get a specific genre with detailed information
 */
export const genresShow = (
  genre: string,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal
) => {
  return customInstance<GenreResource>(
    { url: `/api/genres/${genre}`, method: "GET", signal },
    options
  );
};

export const getGenresShowInfiniteQueryKey = (genre?: string) => {
  return ["infinite", `/api/genres/${genre}`] as const;
};

export const getGenresShowQueryKey = (genre?: string) => {
  return [`/api/genres/${genre}`] as const;
};

export const getGenresShowInfiniteQueryOptions = <
  TData = InfiniteData<Awaited<ReturnType<typeof genresShow>>>,
  TError = ErrorType<
    AuthenticationExceptionResponse | ModelNotFoundExceptionResponse
  >
>(
  genre: string,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof genresShow>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGenresShowInfiniteQueryKey(genre);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof genresShow>>> = ({
    signal,
  }) => genresShow(genre, requestOptions, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!genre,
    ...queryOptions,
  } as UseInfiniteQueryOptions<
    Awaited<ReturnType<typeof genresShow>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GenresShowInfiniteQueryResult = NonNullable<
  Awaited<ReturnType<typeof genresShow>>
>;
export type GenresShowInfiniteQueryError = ErrorType<
  AuthenticationExceptionResponse | ModelNotFoundExceptionResponse
>;

export function useGenresShowInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof genresShow>>>,
  TError = ErrorType<
    AuthenticationExceptionResponse | ModelNotFoundExceptionResponse
  >
>(
  genre: string,
  options: {
    query: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof genresShow>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof genresShow>>,
          TError,
          Awaited<ReturnType<typeof genresShow>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): DefinedUseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGenresShowInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof genresShow>>>,
  TError = ErrorType<
    AuthenticationExceptionResponse | ModelNotFoundExceptionResponse
  >
>(
  genre: string,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof genresShow>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof genresShow>>,
          TError,
          Awaited<ReturnType<typeof genresShow>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGenresShowInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof genresShow>>>,
  TError = ErrorType<
    AuthenticationExceptionResponse | ModelNotFoundExceptionResponse
  >
>(
  genre: string,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof genresShow>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get a specific genre with detailed information
 */

export function useGenresShowInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof genresShow>>>,
  TError = ErrorType<
    AuthenticationExceptionResponse | ModelNotFoundExceptionResponse
  >
>(
  genre: string,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof genresShow>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGenresShowInfiniteQueryOptions(genre, options);

  const query = useInfiniteQuery(
    queryOptions,
    queryClient
  ) as UseInfiniteQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getGenresShowQueryOptions = <
  TData = Awaited<ReturnType<typeof genresShow>>,
  TError = ErrorType<
    AuthenticationExceptionResponse | ModelNotFoundExceptionResponse
  >
>(
  genre: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof genresShow>>, TError, TData>
    >;
    request?: SecondParameter<typeof customInstance>;
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGenresShowQueryKey(genre);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof genresShow>>> = ({
    signal,
  }) => genresShow(genre, requestOptions, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!genre,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof genresShow>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GenresShowQueryResult = NonNullable<
  Awaited<ReturnType<typeof genresShow>>
>;
export type GenresShowQueryError = ErrorType<
  AuthenticationExceptionResponse | ModelNotFoundExceptionResponse
>;

export function useGenresShow<
  TData = Awaited<ReturnType<typeof genresShow>>,
  TError = ErrorType<
    AuthenticationExceptionResponse | ModelNotFoundExceptionResponse
  >
>(
  genre: string,
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof genresShow>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof genresShow>>,
          TError,
          Awaited<ReturnType<typeof genresShow>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGenresShow<
  TData = Awaited<ReturnType<typeof genresShow>>,
  TError = ErrorType<
    AuthenticationExceptionResponse | ModelNotFoundExceptionResponse
  >
>(
  genre: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof genresShow>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof genresShow>>,
          TError,
          Awaited<ReturnType<typeof genresShow>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGenresShow<
  TData = Awaited<ReturnType<typeof genresShow>>,
  TError = ErrorType<
    AuthenticationExceptionResponse | ModelNotFoundExceptionResponse
  >
>(
  genre: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof genresShow>>, TError, TData>
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get a specific genre with detailed information
 */

export function useGenresShow<
  TData = Awaited<ReturnType<typeof genresShow>>,
  TError = ErrorType<
    AuthenticationExceptionResponse | ModelNotFoundExceptionResponse
  >
>(
  genre: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof genresShow>>, TError, TData>
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGenresShowQueryOptions(genre, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getGenresShowSuspenseQueryOptions = <
  TData = Awaited<ReturnType<typeof genresShow>>,
  TError = ErrorType<
    AuthenticationExceptionResponse | ModelNotFoundExceptionResponse
  >
>(
  genre: string,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof genresShow>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGenresShowQueryKey(genre);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof genresShow>>> = ({
    signal,
  }) => genresShow(genre, requestOptions, signal);

  return { queryKey, queryFn, ...queryOptions } as UseSuspenseQueryOptions<
    Awaited<ReturnType<typeof genresShow>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GenresShowSuspenseQueryResult = NonNullable<
  Awaited<ReturnType<typeof genresShow>>
>;
export type GenresShowSuspenseQueryError = ErrorType<
  AuthenticationExceptionResponse | ModelNotFoundExceptionResponse
>;

export function useGenresShowSuspense<
  TData = Awaited<ReturnType<typeof genresShow>>,
  TError = ErrorType<
    AuthenticationExceptionResponse | ModelNotFoundExceptionResponse
  >
>(
  genre: string,
  options: {
    query: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof genresShow>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGenresShowSuspense<
  TData = Awaited<ReturnType<typeof genresShow>>,
  TError = ErrorType<
    AuthenticationExceptionResponse | ModelNotFoundExceptionResponse
  >
>(
  genre: string,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof genresShow>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGenresShowSuspense<
  TData = Awaited<ReturnType<typeof genresShow>>,
  TError = ErrorType<
    AuthenticationExceptionResponse | ModelNotFoundExceptionResponse
  >
>(
  genre: string,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof genresShow>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get a specific genre with detailed information
 */

export function useGenresShowSuspense<
  TData = Awaited<ReturnType<typeof genresShow>>,
  TError = ErrorType<
    AuthenticationExceptionResponse | ModelNotFoundExceptionResponse
  >
>(
  genre: string,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof genresShow>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGenresShowSuspenseQueryOptions(genre, options);

  const query = useSuspenseQuery(
    queryOptions,
    queryClient
  ) as UseSuspenseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getGenresShowSuspenseInfiniteQueryOptions = <
  TData = InfiniteData<Awaited<ReturnType<typeof genresShow>>>,
  TError = ErrorType<
    AuthenticationExceptionResponse | ModelNotFoundExceptionResponse
  >
>(
  genre: string,
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof genresShow>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGenresShowInfiniteQueryKey(genre);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof genresShow>>> = ({
    signal,
  }) => genresShow(genre, requestOptions, signal);

  return {
    queryKey,
    queryFn,
    ...queryOptions,
  } as UseSuspenseInfiniteQueryOptions<
    Awaited<ReturnType<typeof genresShow>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GenresShowSuspenseInfiniteQueryResult = NonNullable<
  Awaited<ReturnType<typeof genresShow>>
>;
export type GenresShowSuspenseInfiniteQueryError = ErrorType<
  AuthenticationExceptionResponse | ModelNotFoundExceptionResponse
>;

export function useGenresShowSuspenseInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof genresShow>>>,
  TError = ErrorType<
    AuthenticationExceptionResponse | ModelNotFoundExceptionResponse
  >
>(
  genre: string,
  options: {
    query: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof genresShow>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGenresShowSuspenseInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof genresShow>>>,
  TError = ErrorType<
    AuthenticationExceptionResponse | ModelNotFoundExceptionResponse
  >
>(
  genre: string,
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof genresShow>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGenresShowSuspenseInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof genresShow>>>,
  TError = ErrorType<
    AuthenticationExceptionResponse | ModelNotFoundExceptionResponse
  >
>(
  genre: string,
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof genresShow>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get a specific genre with detailed information
 */

export function useGenresShowSuspenseInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof genresShow>>>,
  TError = ErrorType<
    AuthenticationExceptionResponse | ModelNotFoundExceptionResponse
  >
>(
  genre: string,
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof genresShow>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGenresShowSuspenseInfiniteQueryOptions(
    genre,
    options
  );

  const query = useSuspenseInfiniteQuery(
    queryOptions,
    queryClient
  ) as UseSuspenseInfiniteQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Updates genre information including name, description, and metadata.
Only the fields included in the request will be modified.
 * @summary Update an existing genre
 */
export const genresUpdate = (
  genre: string,
  updateGenreRequest: BodyType<UpdateGenreRequest>,
  options?: SecondParameter<typeof customInstance>
) => {
  return customInstance<GenreResource>(
    {
      url: `/api/genres/${genre}`,
      method: "PATCH",
      headers: { "Content-Type": "application/json" },
      data: updateGenreRequest,
    },
    options
  );
};

export const getGenresUpdateMutationOptions = <
  TError = ErrorType<
    | AuthenticationExceptionResponse
    | ModelNotFoundExceptionResponse
    | ValidationExceptionResponse
  >,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof genresUpdate>>,
    TError,
    { genre: string; data: BodyType<UpdateGenreRequest> },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof genresUpdate>>,
  TError,
  { genre: string; data: BodyType<UpdateGenreRequest> },
  TContext
> => {
  const mutationKey = ["genresUpdate"];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof genresUpdate>>,
    { genre: string; data: BodyType<UpdateGenreRequest> }
  > = (props) => {
    const { genre, data } = props ?? {};

    return genresUpdate(genre, data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type GenresUpdateMutationResult = NonNullable<
  Awaited<ReturnType<typeof genresUpdate>>
>;
export type GenresUpdateMutationBody = BodyType<UpdateGenreRequest>;
export type GenresUpdateMutationError = ErrorType<
  | AuthenticationExceptionResponse
  | ModelNotFoundExceptionResponse
  | ValidationExceptionResponse
>;

/**
 * @summary Update an existing genre
 */
export const useGenresUpdate = <
  TError = ErrorType<
    | AuthenticationExceptionResponse
    | ModelNotFoundExceptionResponse
    | ValidationExceptionResponse
  >,
  TContext = unknown
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof genresUpdate>>,
      TError,
      { genre: string; data: BodyType<UpdateGenreRequest> },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof genresUpdate>>,
  TError,
  { genre: string; data: BodyType<UpdateGenreRequest> },
  TContext
> => {
  const mutationOptions = getGenresUpdateMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
/**
 * Permanently removes a genre from the system. This action will also
remove the genre association from all related albums and songs.
 * @summary Delete a genre
 */
export const genresDestroy = (
  genre: string,
  options?: SecondParameter<typeof customInstance>
) => {
  return customInstance<void>(
    { url: `/api/genres/${genre}`, method: "DELETE" },
    options
  );
};

export const getGenresDestroyMutationOptions = <
  TError = ErrorType<
    AuthenticationExceptionResponse | ModelNotFoundExceptionResponse
  >,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof genresDestroy>>,
    TError,
    { genre: string },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof genresDestroy>>,
  TError,
  { genre: string },
  TContext
> => {
  const mutationKey = ["genresDestroy"];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof genresDestroy>>,
    { genre: string }
  > = (props) => {
    const { genre } = props ?? {};

    return genresDestroy(genre, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type GenresDestroyMutationResult = NonNullable<
  Awaited<ReturnType<typeof genresDestroy>>
>;

export type GenresDestroyMutationError = ErrorType<
  AuthenticationExceptionResponse | ModelNotFoundExceptionResponse
>;

/**
 * @summary Delete a genre
 */
export const useGenresDestroy = <
  TError = ErrorType<
    AuthenticationExceptionResponse | ModelNotFoundExceptionResponse
  >,
  TContext = unknown
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof genresDestroy>>,
      TError,
      { genre: string },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof genresDestroy>>,
  TError,
  { genre: string },
  TContext
> => {
  const mutationOptions = getGenresDestroyMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
