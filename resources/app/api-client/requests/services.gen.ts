// This file is auto-generated by @hey-api/openapi-ts

import type { CancelablePromise } from './core/CancelablePromise';
import { OpenAPI } from './core/OpenAPI';
import { request as __request } from './core/request';
import type { AlbumsIndexData, AlbumsIndexResponse, AlbumsShowData, AlbumsShowResponse, ArtistsIndexData, ArtistsIndexResponse, ArtistsShowData, ArtistsShowResponse, AuthLoginData, AuthLoginResponse, AuthRefreshTokenData, AuthRefreshTokenResponse, AuthStreamTokenData, AuthStreamTokenResponse, AuthRegisterData, AuthRegisterResponse, AuthForgotPasswordData, AuthForgotPasswordResponse, AuthResetPasswordData, AuthResetPasswordResponse, AuthVerifyData, AuthVerifyResponse, GenresIndexData, GenresIndexResponse, GenresShowData, GenresShowResponse, GenresUpdateData, GenresUpdateResponse, GenresDestroyData, GenresDestroyResponse, ImageServeData, ImageServeResponse, JobLibraryScanData, JobLibraryScanResponse, LibrariesIndexData, LibrariesIndexResponse, LibraryCreateData, LibraryCreateResponse, LibraryUpdateData, LibraryUpdateResponse, LibraryDeleteResponse, SchemasModelResponse, OpCacheGetStatusResponse, OpcacheGetConfigResponse, OpcacheClearData, OpcacheClearResponse, OpcacheCompileData, OpcacheCompileResponse, SongsIndexData, SongsIndexResponse, SongsShowData, SongsShowResponse, SongsStreamData, SongsStreamResponse, UsersIndexResponse, UsersStoreData, UsersStoreResponse, UsersUpdateData, UsersUpdateResponse, UsersShowData, UsersShowResponse, UsersDestroyData, UsersDestroyResponse, UsersMeResponse, UserTokenGetUserTokensData, UserTokenGetUserTokensResponse, UserTokenRevokeTokenData, UserTokenRevokeTokenResponse, WidgetsGetWidgetData, WidgetsGetWidgetResponse, WidgetSchemaGetWidgetsResponse, WidgetSchemaGetWidgetData, WidgetSchemaGetWidgetResponse } from './types.gen';

export class AlbumService {
    /**
     * Get a collection of albums
     * @param data The data for the request.
     * @param data.library The library slug
     * @param data.fields Comma seperated string of fields you want to select. If nothing is defined `select *` is default.
     * - title
     * - slug
     * - year
     * - directory
     * @param data.relations Comma seperated string of relations
     * - albumArist
     * - cover
     * - library
     * - songs
     * @param data.page Current page
     * @param data.limit Items per page
     * @param data.genres _Extension_ Comma seperated list of genres
     * @returns unknown Json paginated set of `AlbumResourceResource`
     * @throws ApiError
     */
    public static albumsIndex(data: AlbumsIndexData): CancelablePromise<AlbumsIndexResponse> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/libraries/{library}/albums',
            path: {
                library: data.library
            },
            query: {
                fields: data.fields,
                relations: data.relations,
                page: data.page,
                limit: data.limit,
                genres: data.genres
            },
            errors: {
                401: 'Unauthenticated',
                403: 'Authorization error',
                404: 'Not found',
                422: 'Validation error'
            }
        });
    }
    
    /**
     * Get an album
     * @param data The data for the request.
     * @param data.library The library slug
     * @param data.album The album slug
     * @returns AlbumResourceResource `AlbumResourceResource`
     * @throws ApiError
     */
    public static albumsShow(data: AlbumsShowData): CancelablePromise<AlbumsShowResponse> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/libraries/{library}/albums/{album}',
            path: {
                library: data.library,
                album: data.album
            },
            errors: {
                401: 'Unauthenticated',
                404: 'Not found'
            }
        });
    }
    
}

export class ArtistService {
    /**
     * Get a collection of artists
     * @param data The data for the request.
     * @param data.library
     * @param data.fields Comma seperated string of fields you want to select. If nothing is defined `select *` is default.
     * - title
     * - slug
     * @param data.relations Comma seperated string of relations
     * - portrait
     * - songs
     * @param data.page Current page
     * @param data.limit Items per page
     * @param data.genres _Extension_ Comma seperated list of genres
     * @returns unknown Json paginated set of `ArtistResource`
     * @throws ApiError
     */
    public static artistsIndex(data: ArtistsIndexData): CancelablePromise<ArtistsIndexResponse> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/libraries/{library}/artists',
            path: {
                library: data.library
            },
            query: {
                fields: data.fields,
                relations: data.relations,
                page: data.page,
                limit: data.limit,
                genres: data.genres
            },
            errors: {
                401: 'Unauthenticated',
                403: 'Authorization error',
                422: 'Validation error'
            }
        });
    }
    
    /**
     * Get an artist
     * @param data The data for the request.
     * @param data.library
     * @param data.artist The artist slug
     * @returns ArtistResource `ArtistResource`
     * @throws ApiError
     */
    public static artistsShow(data: ArtistsShowData): CancelablePromise<ArtistsShowResponse> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/libraries/{library}/artists/{artist}',
            path: {
                library: data.library,
                artist: data.artist
            },
            errors: {
                401: 'Unauthenticated',
                404: 'Not found'
            }
        });
    }
    
}

export class AuthService {
    /**
     * Login
     * @param data The data for the request.
     * @param data.requestBody
     * @returns unknown
     * @throws ApiError
     */
    public static authLogin(data: AuthLoginData = {}): CancelablePromise<AuthLoginResponse> {
        return __request(OpenAPI, {
            method: 'POST',
            url: '/auth/login',
            body: data.requestBody,
            mediaType: 'application/json',
            errors: {
                401: 'An error',
                403: 'Authorization error',
                422: 'Validation error'
            }
        });
    }
    
    /**
     * Refresh token
     * Needs refresh token with ability "issue-access-token"
     * @param data The data for the request.
     * @param data.requestBody
     * @returns unknown
     * @throws ApiError
     */
    public static authRefreshToken(data: AuthRefreshTokenData = {}): CancelablePromise<AuthRefreshTokenResponse> {
        return __request(OpenAPI, {
            method: 'POST',
            url: '/auth/refreshToken',
            body: data.requestBody,
            mediaType: 'application/json',
            errors: {
                401: 'Unauthenticated'
            }
        });
    }
    
    /**
     * Get a stream token
     * Needs refresh token with ability "issue-access-token"
     * @param data The data for the request.
     * @param data.requestBody
     * @returns unknown
     * @throws ApiError
     */
    public static authStreamToken(data: AuthStreamTokenData = {}): CancelablePromise<AuthStreamTokenResponse> {
        return __request(OpenAPI, {
            method: 'POST',
            url: '/auth/streamToken',
            body: data.requestBody,
            mediaType: 'application/json',
            errors: {
                401: 'Unauthenticated'
            }
        });
    }
    
    /**
     * Register
     * @param data The data for the request.
     * @param data.requestBody
     * @returns unknown
     * @throws ApiError
     */
    public static authRegister(data: AuthRegisterData = {}): CancelablePromise<AuthRegisterResponse> {
        return __request(OpenAPI, {
            method: 'POST',
            url: '/auth/register',
            body: data.requestBody,
            mediaType: 'application/json',
            errors: {
                403: 'Authorization error',
                422: 'Validation error'
            }
        });
    }
    
    /**
     * Request reset password link
     * @param data The data for the request.
     * @param data.requestBody
     * @returns unknown
     * @throws ApiError
     */
    public static authForgotPassword(data: AuthForgotPasswordData = {}): CancelablePromise<AuthForgotPasswordResponse> {
        return __request(OpenAPI, {
            method: 'POST',
            url: '/auth/forgotPassword',
            body: data.requestBody,
            mediaType: 'application/json',
            errors: {
                403: 'Authorization error',
                422: 'Validation error'
            }
        });
    }
    
    /**
     * Reset password
     * @param data The data for the request.
     * @param data.requestBody
     * @returns unknown
     * @throws ApiError
     */
    public static authResetPassword(data: AuthResetPasswordData = {}): CancelablePromise<AuthResetPasswordResponse> {
        return __request(OpenAPI, {
            method: 'POST',
            url: '/auth/resetPassword',
            body: data.requestBody,
            mediaType: 'application/json',
            errors: {
                400: 'An error',
                403: 'Authorization error',
                422: 'Validation error'
            }
        });
    }
    
    /**
     * Verify email
     * @param data The data for the request.
     * @param data.requestBody
     * @returns UserResource `UserResource`
     * @throws ApiError
     */
    public static authVerify(data: AuthVerifyData = {}): CancelablePromise<AuthVerifyResponse> {
        return __request(OpenAPI, {
            method: 'POST',
            url: '/auth/verify/:id/:hash',
            body: data.requestBody,
            mediaType: 'application/json',
            errors: {
                403: 'Authorization error'
            }
        });
    }
    
}

export class GenreService {
    /**
     * Get a collection of genres
     * @param data The data for the request.
     * @param data.fields Comma seperated string of fields you want to select. If nothing is defined `select *` is default.
     * - name
     * - slug
     * @param data.relations Comma seperated string of relations
     * - songs
     * @param data.librarySlug Constrain the query to only fetch genres that are contained within the given library
     * @param data.page Current page
     * @param data.limit Items per page
     * @returns unknown Json paginated set of `GenreResource`
     * @throws ApiError
     */
    public static genresIndex(data: GenresIndexData = {}): CancelablePromise<GenresIndexResponse> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/genres',
            query: {
                fields: data.fields,
                relations: data.relations,
                librarySlug: data.librarySlug,
                page: data.page,
                limit: data.limit
            },
            errors: {
                401: 'Unauthenticated',
                403: 'Authorization error',
                422: 'Validation error'
            }
        });
    }
    
    /**
     * Get a genre
     * @param data The data for the request.
     * @param data.genre The genre slug
     * @returns GenreResource `GenreResource`
     * @throws ApiError
     */
    public static genresShow(data: GenresShowData): CancelablePromise<GenresShowResponse> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/genres/{genre}',
            path: {
                genre: data.genre
            },
            errors: {
                401: 'Unauthenticated',
                404: 'Not found'
            }
        });
    }
    
    /**
     * Update a genre
     * @param data The data for the request.
     * @param data.genre The genre slug
     * @param data.requestBody
     * @returns GenreResource `GenreResource`
     * @throws ApiError
     */
    public static genresUpdate(data: GenresUpdateData): CancelablePromise<GenresUpdateResponse> {
        return __request(OpenAPI, {
            method: 'PATCH',
            url: '/genres/{genre}',
            path: {
                genre: data.genre
            },
            body: data.requestBody,
            mediaType: 'application/json',
            errors: {
                401: 'Unauthenticated',
                403: 'Authorization error',
                404: 'Not found',
                422: 'Validation error'
            }
        });
    }
    
    /**
     * Delete a genre
     * @param data The data for the request.
     * @param data.genre The genre slug
     * @returns null No content
     * @throws ApiError
     */
    public static genresDestroy(data: GenresDestroyData): CancelablePromise<GenresDestroyResponse> {
        return __request(OpenAPI, {
            method: 'DELETE',
            url: '/genres/{genre}',
            path: {
                genre: data.genre
            },
            errors: {
                401: 'Unauthenticated',
                404: 'Not found'
            }
        });
    }
    
}

export class ImageService {
    /**
     * Get an image asset
     * @param data The data for the request.
     * @param data.image The image public id
     * @returns string
     * @throws ApiError
     */
    public static imageServe(data: ImageServeData): CancelablePromise<ImageServeResponse> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/images/{image}',
            path: {
                image: data.image
            },
            errors: {
                404: 'Not found'
            }
        });
    }
    
}

export class JobService {
    /**
     * Scan a library
     * @param data The data for the request.
     * @param data.slug
     * @param data.requestBody
     * @returns unknown
     * @throws ApiError
     */
    public static jobLibraryScan(data: JobLibraryScanData): CancelablePromise<JobLibraryScanResponse> {
        return __request(OpenAPI, {
            method: 'POST',
            url: '/jobs/scanLibrary/{slug}',
            path: {
                slug: data.slug
            },
            body: data.requestBody,
            mediaType: 'application/json',
            errors: {
                401: 'Unauthenticated'
            }
        });
    }
    
}

export class LibraryService {
    /**
     * Get a collection of media libraries
     * @param data The data for the request.
     * @param data.page Current page
     * @param data.limit Items per page
     * @returns unknown Json paginated set of `LibraryResource`
     * @throws ApiError
     */
    public static librariesIndex(data: LibrariesIndexData = {}): CancelablePromise<LibrariesIndexResponse> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/libraries',
            query: {
                page: data.page,
                limit: data.limit
            },
            errors: {
                401: 'Unauthenticated',
                403: 'Authorization error',
                422: 'Validation error'
            }
        });
    }
    
    /**
     * Create a library
     * @param data The data for the request.
     * @param data.requestBody
     * @returns LibraryResource `LibraryResource`
     * @throws ApiError
     */
    public static libraryCreate(data: LibraryCreateData = {}): CancelablePromise<LibraryCreateResponse> {
        return __request(OpenAPI, {
            method: 'POST',
            url: '/libraries',
            body: data.requestBody,
            mediaType: 'application/json',
            errors: {
                401: 'Unauthenticated',
                403: 'Authorization error',
                422: 'Validation error'
            }
        });
    }
    
    /**
     * Update a library specified by the provided slug
     * @param data The data for the request.
     * @param data.requestBody
     * @returns LibraryResource `LibraryResource`
     * @throws ApiError
     */
    public static libraryUpdate(data: LibraryUpdateData = {}): CancelablePromise<LibraryUpdateResponse> {
        return __request(OpenAPI, {
            method: 'PATCH',
            url: '/libraries/:slug',
            body: data.requestBody,
            mediaType: 'application/json',
            errors: {
                401: 'Unauthenticated',
                403: 'Authorization error',
                422: 'Validation error'
            }
        });
    }
    
    /**
     * Delete a library
     * @returns null No content
     * @throws ApiError
     */
    public static libraryDelete(): CancelablePromise<LibraryDeleteResponse> {
        return __request(OpenAPI, {
            method: 'DELETE',
            url: '/libraries/:slug',
            errors: {
                401: 'Unauthenticated'
            }
        });
    }
    
}

export class ModelSchemaService {
    /**
     * @returns string
     * @throws ApiError
     */
    public static schemasModel(): CancelablePromise<SchemasModelResponse> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/schemas/models',
            errors: {
                401: 'Unauthenticated'
            }
        });
    }
    
}

export class OpCacheService {
    /**
     * Get status
     * @returns unknown
     * @throws ApiError
     */
    public static opCacheGetStatus(): CancelablePromise<OpCacheGetStatusResponse> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/opcache/status',
            errors: {
                401: 'Unauthenticated'
            }
        });
    }
    
    /**
     * Get config
     * @returns unknown
     * @throws ApiError
     */
    public static opcacheGetConfig(): CancelablePromise<OpcacheGetConfigResponse> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/opcache/config',
            errors: {
                401: 'Unauthenticated'
            }
        });
    }
    
    /**
     * Clear
     * @param data The data for the request.
     * @param data.requestBody
     * @returns unknown
     * @throws ApiError
     */
    public static opcacheClear(data: OpcacheClearData = {}): CancelablePromise<OpcacheClearResponse> {
        return __request(OpenAPI, {
            method: 'POST',
            url: '/opcache/clear',
            body: data.requestBody,
            mediaType: 'application/json',
            errors: {
                401: 'Unauthenticated'
            }
        });
    }
    
    /**
     * Compile cache
     * @param data The data for the request.
     * @param data.force
     * @param data.requestBody
     * @returns unknown
     * @throws ApiError
     */
    public static opcacheCompile(data: OpcacheCompileData = {}): CancelablePromise<OpcacheCompileResponse> {
        return __request(OpenAPI, {
            method: 'POST',
            url: '/opcache/compile',
            query: {
                force: data.force
            },
            body: data.requestBody,
            mediaType: 'application/json',
            errors: {
                401: 'Unauthenticated'
            }
        });
    }
    
}

export class SongService {
    /**
     * Get a collection of songs
     * @param data The data for the request.
     * @param data.library The library slug
     * @param data.page Current page
     * @param data.limit Items per page
     * @param data.genreNames Comma seperated list of genre names You can only search for names or slugs. Not both.
     * @param data.genreSlugs Comma seperated list of genre slugs
     * @param data.relations Comma seperated string of relations
     * - album
     * - artists
     * - albumArtist
     * - genres
     * @returns unknown Json paginated set of `SongResource`
     * @throws ApiError
     */
    public static songsIndex(data: SongsIndexData): CancelablePromise<SongsIndexResponse> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/libraries/{library}/songs',
            path: {
                library: data.library
            },
            query: {
                page: data.page,
                limit: data.limit,
                genreNames: data.genreNames,
                genreSlugs: data.genreSlugs,
                relations: data.relations
            },
            errors: {
                400: 'An error',
                401: 'Unauthenticated',
                403: 'Authorization error',
                404: 'Not found',
                422: 'Validation error'
            }
        });
    }
    
    /**
     * Get a song
     * @param data The data for the request.
     * @param data.library The library slug
     * @param data.song The song public id
     * @returns SongResource `SongResource`
     * @throws ApiError
     */
    public static songsShow(data: SongsShowData): CancelablePromise<SongsShowResponse> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/libraries/{library}/songs/{song}',
            path: {
                library: data.library,
                song: data.song
            },
            errors: {
                401: 'Unauthenticated',
                404: 'Not found'
            }
        });
    }
    
    /**
     * Direct stream the song
     * Requires token with "access-stream"
     * @param data The data for the request.
     * @param data.library The library slug
     * @param data.song The song public id
     * @returns unknown
     * @throws ApiError
     */
    public static songsStream(data: SongsStreamData): CancelablePromise<SongsStreamResponse> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/libraries/{library}/songs/stream/song/{song}/direct',
            path: {
                library: data.library,
                song: data.song
            },
            errors: {
                401: 'Unauthenticated',
                404: 'Not found'
            }
        });
    }
    
}

export class UserService {
    /**
     * Get a collection of users
     * @returns unknown Json paginated set of `UserResource`
     * @throws ApiError
     */
    public static usersIndex(): CancelablePromise<UsersIndexResponse> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/users',
            errors: {
                401: 'Unauthenticated'
            }
        });
    }
    
    /**
     * Create user
     * This is endpoint allows administrators to create users
     * @param data The data for the request.
     * @param data.requestBody
     * @returns UserResource `UserResource`
     * @throws ApiError
     */
    public static usersStore(data: UsersStoreData = {}): CancelablePromise<UsersStoreResponse> {
        return __request(OpenAPI, {
            method: 'POST',
            url: '/users',
            body: data.requestBody,
            mediaType: 'application/json',
            errors: {
                401: 'Unauthenticated',
                403: 'Authorization error',
                422: 'Validation error'
            }
        });
    }
    
    /**
     * Update a user
     * @param data The data for the request.
     * @param data.user The user ID
     * @param data.requestBody
     * @returns UserResource `UserResource`
     * @throws ApiError
     */
    public static usersUpdate(data: UsersUpdateData): CancelablePromise<UsersUpdateResponse> {
        return __request(OpenAPI, {
            method: 'PATCH',
            url: '/users/{user}',
            path: {
                user: data.user
            },
            body: data.requestBody,
            mediaType: 'application/json',
            errors: {
                401: 'Unauthenticated',
                403: 'Authorization error',
                404: 'Not found',
                422: 'Validation error'
            }
        });
    }
    
    /**
     * Get small user detail info
     * @param data The data for the request.
     * @param data.user The user ID
     * @returns UserResource `UserResource`
     * @throws ApiError
     */
    public static usersShow(data: UsersShowData): CancelablePromise<UsersShowResponse> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/users/{user}',
            path: {
                user: data.user
            },
            errors: {
                401: 'Unauthenticated',
                404: 'Not found'
            }
        });
    }
    
    /**
     * Delete a user
     * @param data The data for the request.
     * @param data.user
     * @returns null No content
     * @throws ApiError
     */
    public static usersDestroy(data: UsersDestroyData): CancelablePromise<UsersDestroyResponse> {
        return __request(OpenAPI, {
            method: 'DELETE',
            url: '/users/{user}',
            path: {
                user: data.user
            },
            errors: {
                401: 'Unauthenticated'
            }
        });
    }
    
    /**
     * Get the authenticated user
     * @returns UserResource `UserResource`
     * @throws ApiError
     */
    public static usersMe(): CancelablePromise<UsersMeResponse> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/users/me',
            errors: {
                401: 'Unauthenticated'
            }
        });
    }
    
}

export class UserTokenService {
    /**
     * Get a collection of tokens
     * @param data The data for the request.
     * @param data.user
     * @param data.page
     * @param data.perPage
     * @returns unknown Json paginated set of `PersonalAccessTokenViewResource`
     * @throws ApiError
     */
    public static userTokenGetUserTokens(data: UserTokenGetUserTokensData): CancelablePromise<UserTokenGetUserTokensResponse> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/users/tokens/{user}',
            path: {
                user: data.user
            },
            query: {
                page: data.page,
                perPage: data.perPage
            },
            errors: {
                401: 'Unauthenticated',
                403: 'Authorization error',
                422: 'Validation error'
            }
        });
    }
    
    /**
     * Revoke a given token
     * @param data The data for the request.
     * @param data.token The token ID
     * @returns null No content
     * @throws ApiError
     */
    public static userTokenRevokeToken(data: UserTokenRevokeTokenData): CancelablePromise<UserTokenRevokeTokenResponse> {
        return __request(OpenAPI, {
            method: 'DELETE',
            url: '/users/tokens/{token}',
            path: {
                token: data.token
            },
            errors: {
                401: 'Unauthenticated',
                404: 'Not found'
            }
        });
    }
    
}

export class WidgetService {
    /**
     * Get a widget for the user
     * @param data The data for the request.
     * @param data.name
     * @returns null
     * @throws ApiError
     */
    public static widgetsGetWidget(data: WidgetsGetWidgetData): CancelablePromise<WidgetsGetWidgetResponse> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/widgets/{name}',
            path: {
                name: data.name
            },
            errors: {
                401: 'Unauthenticated'
            }
        });
    }
    
}

export class WidgetSchemaService {
    /**
     * Get a list of widgets
     * @returns WidgetListItemResource Array of `WidgetListItemResource`
     * @throws ApiError
     */
    public static widgetSchemaGetWidgets(): CancelablePromise<WidgetSchemaGetWidgetsResponse> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/schemas/widgets',
            errors: {
                401: 'Unauthenticated'
            }
        });
    }
    
    /**
     * Get widget schema
     * @param data The data for the request.
     * @param data.name Name of the schema
     * @param data.id
     * @returns string
     * @throws ApiError
     */
    public static widgetSchemaGetWidget(data: WidgetSchemaGetWidgetData): CancelablePromise<WidgetSchemaGetWidgetResponse> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/schemas/widgets/{name}',
            path: {
                name: data.name
            },
            query: {
                id: data.id
            },
            errors: {
                401: 'Unauthenticated',
                403: 'Authorization error',
                422: 'Validation error'
            }
        });
    }
    
}