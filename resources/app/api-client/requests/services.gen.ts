// This file is auto-generated by @hey-api/openapi-ts

import type { CancelablePromise } from './core/CancelablePromise';
import { OpenAPI } from './core/OpenAPI';
import { request as __request } from './core/request';
import type { AlbumsIndexData, AlbumsIndexResponse, AlbumsShowData, AlbumsShowResponse, ArtistsIndexData, ArtistsIndexResponse, ArtistsShowData, ArtistsShowResponse, AuthLoginData, AuthLoginResponse, AuthRefreshTokenResponse, AuthStreamTokenResponse, AuthRegisterData, AuthRegisterResponse, AuthForgotPasswordData, AuthForgotPasswordResponse, AuthResetPasswordData, AuthResetPasswordResponse, AuthVerifyResponse, GenresIndexData, GenresIndexResponse, GenresShowData, GenresShowResponse, GenresUpdateData, GenresUpdateResponse, GenresDestroyData, GenresDestroyResponse, ImageServeData, ImageServeResponse, JobLibraryScanData, JobLibraryScanResponse, LibrariesIndexData, LibrariesIndexResponse, LibraryCreateData, LibraryCreateResponse, LibraryUpdateData, LibraryUpdateResponse, LibraryDeleteResponse, OpCacheGetStatusResponse, OpcacheGetConfigResponse, OpcacheClearResponse, OpcacheCompileData, OpcacheCompileResponse, QueueMetricsShowData, QueueMetricsShowResponse, QueueMetricsQueuesResponse, QueueMetricsMetricsData, QueueMetricsMetricsResponse, QueueMetricsRetryJobData, QueueMetricsRetryJobResponse, QueueMetricsDeleteData, QueueMetricsDeleteResponse, QueueMetricsPurgeResponse, SongsIndexData, SongsIndexResponse, SongsShowData, SongsShowResponse, SongsStreamData, SongsStreamResponse, SystemInfoPhpResponse, SystemInfoSysResponse, UsersIndexData, UsersIndexResponse, UsersStoreData, UsersStoreResponse, UsersUpdateData, UsersUpdateResponse, UsersShowData, UsersShowResponse, UsersDestroyData, UsersDestroyResponse, UsersMeResponse, UserTokenGetUserTokensData, UserTokenGetUserTokensResponse, UserTokenRevokeTokenData, UserTokenRevokeTokenResponse } from './types.gen';

export class AlbumService {
    /**
     * Get a collection of albums
     * @param data The data for the request.
     * @param data.library The library slug
     * @param data.fields Comma seperated string of fields you want to select. If nothing is defined `select *` is default.
     * - title
     * - slug
     * - year
     * - directory
     * @param data.relations Comma seperated string of relations
     * - albumArist
     * - cover
     * - library
     * - songs
     * @param data.page Current page
     * @param data.limit Items per page
     * @param data.genres _Extension_ Comma seperated list of genres
     * @returns unknown Json paginated set of `AlbumResource`
     * @throws ApiError
     */
    public static albumsIndex(data: AlbumsIndexData): CancelablePromise<AlbumsIndexResponse> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/libraries/{library}/albums',
            path: {
                library: data.library
            },
            query: {
                fields: data.fields,
                relations: data.relations,
                page: data.page,
                limit: data.limit,
                genres: data.genres
            },
            errors: {
                401: 'Unauthenticated',
                403: 'Authorization error',
                404: 'Not found',
                422: 'Validation error'
            }
        });
    }
    
    /**
     * Get an album
     * @param data The data for the request.
     * @param data.library The library slug
     * @param data.album The album slug
     * @returns AlbumResource `AlbumResource`
     * @throws ApiError
     */
    public static albumsShow(data: AlbumsShowData): CancelablePromise<AlbumsShowResponse> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/libraries/{library}/albums/{album}',
            path: {
                library: data.library,
                album: data.album
            },
            errors: {
                401: 'Unauthenticated',
                404: 'Not found'
            }
        });
    }
    
}

export class ArtistService {
    /**
     * Get a collection of artists
     * @param data The data for the request.
     * @param data.library
     * @param data.fields Comma seperated string of fields you want to select. If nothing is defined `select *` is default.
     * - title
     * - slug
     * @param data.relations Comma seperated string of relations
     * - portrait
     * - songs
     * @param data.page Current page
     * @param data.limit Items per page
     * @param data.genres _Extension_ Comma seperated list of genres
     * @returns unknown Json paginated set of `ArtistResource`
     * @throws ApiError
     */
    public static artistsIndex(data: ArtistsIndexData): CancelablePromise<ArtistsIndexResponse> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/libraries/{library}/artists',
            path: {
                library: data.library
            },
            query: {
                fields: data.fields,
                relations: data.relations,
                page: data.page,
                limit: data.limit,
                genres: data.genres
            },
            errors: {
                401: 'Unauthenticated',
                403: 'Authorization error',
                422: 'Validation error'
            }
        });
    }
    
    /**
     * Get an artist
     * @param data The data for the request.
     * @param data.library
     * @param data.artist The artist slug
     * @returns ArtistResource `ArtistResource`
     * @throws ApiError
     */
    public static artistsShow(data: ArtistsShowData): CancelablePromise<ArtistsShowResponse> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/libraries/{library}/artists/{artist}',
            path: {
                library: data.library,
                artist: data.artist
            },
            errors: {
                401: 'Unauthenticated',
                404: 'Not found'
            }
        });
    }
    
}

export class AuthService {
    /**
     * Login
     * @param data The data for the request.
     * @param data.requestBody
     * @returns unknown
     * @throws ApiError
     */
    public static authLogin(data: AuthLoginData = {}): CancelablePromise<AuthLoginResponse> {
        return __request(OpenAPI, {
            method: 'POST',
            url: '/auth/login',
            body: data.requestBody,
            mediaType: 'application/json',
            errors: {
                401: 'An error',
                403: 'Authorization error',
                422: 'Validation error'
            }
        });
    }
    
    /**
     * Refresh token
     * Needs refresh token with ability "issue-access-token"
     * @returns unknown
     * @throws ApiError
     */
    public static authRefreshToken(): CancelablePromise<AuthRefreshTokenResponse> {
        return __request(OpenAPI, {
            method: 'POST',
            url: '/auth/refreshToken',
            errors: {
                401: 'Unauthenticated'
            }
        });
    }
    
    /**
     * Get a stream token
     * Needs refresh token with ability "issue-access-token"
     * @returns unknown
     * @throws ApiError
     */
    public static authStreamToken(): CancelablePromise<AuthStreamTokenResponse> {
        return __request(OpenAPI, {
            method: 'POST',
            url: '/auth/streamToken',
            errors: {
                401: 'Unauthenticated'
            }
        });
    }
    
    /**
     * Register
     * @param data The data for the request.
     * @param data.requestBody
     * @returns unknown
     * @throws ApiError
     */
    public static authRegister(data: AuthRegisterData = {}): CancelablePromise<AuthRegisterResponse> {
        return __request(OpenAPI, {
            method: 'POST',
            url: '/auth/register',
            body: data.requestBody,
            mediaType: 'application/json',
            errors: {
                403: 'Authorization error',
                422: 'Validation error'
            }
        });
    }
    
    /**
     * Request reset password link
     * @param data The data for the request.
     * @param data.requestBody
     * @returns unknown
     * @throws ApiError
     */
    public static authForgotPassword(data: AuthForgotPasswordData = {}): CancelablePromise<AuthForgotPasswordResponse> {
        return __request(OpenAPI, {
            method: 'POST',
            url: '/auth/forgotPassword',
            body: data.requestBody,
            mediaType: 'application/json',
            errors: {
                403: 'Authorization error',
                422: 'Validation error'
            }
        });
    }
    
    /**
     * Reset password
     * @param data The data for the request.
     * @param data.requestBody
     * @returns unknown
     * @throws ApiError
     */
    public static authResetPassword(data: AuthResetPasswordData = {}): CancelablePromise<AuthResetPasswordResponse> {
        return __request(OpenAPI, {
            method: 'POST',
            url: '/auth/resetPassword',
            body: data.requestBody,
            mediaType: 'application/json',
            errors: {
                400: 'An error',
                403: 'Authorization error',
                422: 'Validation error'
            }
        });
    }
    
    /**
     * Verify email
     * @returns UserResource `UserResource`
     * @throws ApiError
     */
    public static authVerify(): CancelablePromise<AuthVerifyResponse> {
        return __request(OpenAPI, {
            method: 'POST',
            url: '/auth/verify/:id/:hash',
            errors: {
                403: 'Authorization error'
            }
        });
    }
    
}

export class GenreService {
    /**
     * Get a collection of genres
     * @param data The data for the request.
     * @param data.fields Comma seperated string of fields you want to select. If nothing is defined `select *` is default.
     * - name
     * - slug
     * @param data.relations Comma seperated string of relations
     * - songs
     * @param data.librarySlug Constrain the query to only fetch genres that are contained within the given library
     * @param data.page Current page
     * @param data.limit Items per page
     * @returns unknown Json paginated set of `GenreResource`
     * @throws ApiError
     */
    public static genresIndex(data: GenresIndexData = {}): CancelablePromise<GenresIndexResponse> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/genres',
            query: {
                fields: data.fields,
                relations: data.relations,
                librarySlug: data.librarySlug,
                page: data.page,
                limit: data.limit
            },
            errors: {
                401: 'Unauthenticated',
                403: 'Authorization error',
                422: 'Validation error'
            }
        });
    }
    
    /**
     * Get a genre
     * @param data The data for the request.
     * @param data.genre The genre slug
     * @returns GenreResource `GenreResource`
     * @throws ApiError
     */
    public static genresShow(data: GenresShowData): CancelablePromise<GenresShowResponse> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/genres/{genre}',
            path: {
                genre: data.genre
            },
            errors: {
                401: 'Unauthenticated',
                404: 'Not found'
            }
        });
    }
    
    /**
     * Update a genre
     * @param data The data for the request.
     * @param data.genre The genre slug
     * @param data.requestBody
     * @returns GenreResource `GenreResource`
     * @throws ApiError
     */
    public static genresUpdate(data: GenresUpdateData): CancelablePromise<GenresUpdateResponse> {
        return __request(OpenAPI, {
            method: 'PATCH',
            url: '/genres/{genre}',
            path: {
                genre: data.genre
            },
            body: data.requestBody,
            mediaType: 'application/json',
            errors: {
                401: 'Unauthenticated',
                403: 'Authorization error',
                404: 'Not found',
                422: 'Validation error'
            }
        });
    }
    
    /**
     * Delete a genre
     * @param data The data for the request.
     * @param data.genre The genre slug
     * @returns null No content
     * @throws ApiError
     */
    public static genresDestroy(data: GenresDestroyData): CancelablePromise<GenresDestroyResponse> {
        return __request(OpenAPI, {
            method: 'DELETE',
            url: '/genres/{genre}',
            path: {
                genre: data.genre
            },
            errors: {
                401: 'Unauthenticated',
                404: 'Not found'
            }
        });
    }
    
}

export class ImageService {
    /**
     * Get an image asset
     * @param data The data for the request.
     * @param data.image The image public id
     * @returns string
     * @throws ApiError
     */
    public static imageServe(data: ImageServeData): CancelablePromise<ImageServeResponse> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/images/{image}',
            path: {
                image: data.image
            },
            errors: {
                404: 'Not found'
            }
        });
    }
    
}

export class JobService {
    /**
     * Scan a library
     * @param data The data for the request.
     * @param data.slug
     * @returns unknown
     * @throws ApiError
     */
    public static jobLibraryScan(data: JobLibraryScanData): CancelablePromise<JobLibraryScanResponse> {
        return __request(OpenAPI, {
            method: 'POST',
            url: '/jobs/scanLibrary/{slug}',
            path: {
                slug: data.slug
            },
            errors: {
                401: 'Unauthenticated'
            }
        });
    }
    
}

export class LibraryService {
    /**
     * Get a collection of media libraries
     * @param data The data for the request.
     * @param data.page Current page
     * @param data.limit Items per page
     * @returns unknown Json paginated set of `LibraryResource`
     * @throws ApiError
     */
    public static librariesIndex(data: LibrariesIndexData = {}): CancelablePromise<LibrariesIndexResponse> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/libraries',
            query: {
                page: data.page,
                limit: data.limit
            },
            errors: {
                401: 'Unauthenticated',
                403: 'Authorization error',
                422: 'Validation error'
            }
        });
    }
    
    /**
     * Create a library
     * @param data The data for the request.
     * @param data.requestBody
     * @returns LibraryResource `LibraryResource`
     * @throws ApiError
     */
    public static libraryCreate(data: LibraryCreateData = {}): CancelablePromise<LibraryCreateResponse> {
        return __request(OpenAPI, {
            method: 'POST',
            url: '/libraries',
            body: data.requestBody,
            mediaType: 'application/json',
            errors: {
                401: 'Unauthenticated',
                403: 'Authorization error',
                422: 'Validation error'
            }
        });
    }
    
    /**
     * Update a library specified by the provided slug
     * @param data The data for the request.
     * @param data.requestBody
     * @returns LibraryResource `LibraryResource`
     * @throws ApiError
     */
    public static libraryUpdate(data: LibraryUpdateData = {}): CancelablePromise<LibraryUpdateResponse> {
        return __request(OpenAPI, {
            method: 'PATCH',
            url: '/libraries/:slug',
            body: data.requestBody,
            mediaType: 'application/json',
            errors: {
                401: 'Unauthenticated',
                403: 'Authorization error',
                422: 'Validation error'
            }
        });
    }
    
    /**
     * Delete a library
     * @returns null No content
     * @throws ApiError
     */
    public static libraryDelete(): CancelablePromise<LibraryDeleteResponse> {
        return __request(OpenAPI, {
            method: 'DELETE',
            url: '/libraries/:slug',
            errors: {
                401: 'Unauthenticated'
            }
        });
    }
    
}

export class OpCacheService {
    /**
     * Get status
     * @returns unknown
     * @throws ApiError
     */
    public static opCacheGetStatus(): CancelablePromise<OpCacheGetStatusResponse> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/opcache/status',
            errors: {
                401: 'Unauthenticated'
            }
        });
    }
    
    /**
     * Get config
     * @returns unknown
     * @throws ApiError
     */
    public static opcacheGetConfig(): CancelablePromise<OpcacheGetConfigResponse> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/opcache/config',
            errors: {
                401: 'Unauthenticated'
            }
        });
    }
    
    /**
     * Clear
     * @returns unknown
     * @throws ApiError
     */
    public static opcacheClear(): CancelablePromise<OpcacheClearResponse> {
        return __request(OpenAPI, {
            method: 'POST',
            url: '/opcache/clear',
            errors: {
                401: 'Unauthenticated'
            }
        });
    }
    
    /**
     * Compile cache
     * @param data The data for the request.
     * @param data.force
     * @param data.requestBody
     * @returns unknown
     * @throws ApiError
     */
    public static opcacheCompile(data: OpcacheCompileData = {}): CancelablePromise<OpcacheCompileResponse> {
        return __request(OpenAPI, {
            method: 'POST',
            url: '/opcache/compile',
            query: {
                force: data.force
            },
            body: data.requestBody,
            mediaType: 'application/json',
            errors: {
                401: 'Unauthenticated'
            }
        });
    }
    
}

export class QueueService {
    /**
     * Get a collection of monitor entries
     * @param data The data for the request.
     * @param data.page Current page
     * @param data.limit Items per page
     * @param data.status MonitorStatus
     * - 0=RUNNING
     * - 1=SUCCEEDED
     * - 2=FAILED
     * - 3=STALE
     * - 4=QUEUED
     * @param data.queue Name of the queue
     * @param data.name Name of the job
     * @param data.queuedFirst Order queued jobs first
     * @returns unknown Json paginated set of `QueueMonitorResource`
     * @throws ApiError
     */
    public static queueMetricsShow(data: QueueMetricsShowData = {}): CancelablePromise<QueueMetricsShowResponse> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/queue-metrics',
            query: {
                page: data.page,
                limit: data.limit,
                status: data.status,
                queue: data.queue,
                name: data.name,
                queuedFirst: data.queuedFirst
            },
            errors: {
                401: 'Unauthenticated',
                403: 'Authorization error',
                422: 'Validation error'
            }
        });
    }
    
    /**
     * Get a list of queue names
     * @returns unknown
     * @throws ApiError
     */
    public static queueMetricsQueues(): CancelablePromise<QueueMetricsQueuesResponse> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/queue-metrics/queues',
            errors: {
                401: 'Unauthenticated'
            }
        });
    }
    
    /**
     * Get a metrics collection
     * @param data The data for the request.
     * @param data.aggregateDays Days to aggregate
     * @returns unknown
     * @throws ApiError
     */
    public static queueMetricsMetrics(data: QueueMetricsMetricsData = {}): CancelablePromise<QueueMetricsMetricsResponse> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/queue-metrics/metrics',
            query: {
                aggregateDays: data.aggregateDays
            },
            errors: {
                401: 'Unauthenticated',
                403: 'Authorization error',
                422: 'Validation error'
            }
        });
    }
    
    /**
     * Retry a job
     * @param data The data for the request.
     * @param data.id
     * @param data.requestBody
     * @returns unknown
     * @throws ApiError
     */
    public static queueMetricsRetryJob(data: QueueMetricsRetryJobData): CancelablePromise<QueueMetricsRetryJobResponse> {
        return __request(OpenAPI, {
            method: 'POST',
            url: '/queue-metrics/retry/{id}',
            path: {
                id: data.id
            },
            body: data.requestBody,
            mediaType: 'application/json',
            errors: {
                400: 'An error',
                401: 'Unauthenticated',
                403: 'Authorization error',
                422: 'Validation error'
            }
        });
    }
    
    /**
     * Delete by id
     * @param data The data for the request.
     * @param data.id
     * @returns null No content
     * @throws ApiError
     */
    public static queueMetricsDelete(data: QueueMetricsDeleteData): CancelablePromise<QueueMetricsDeleteResponse> {
        return __request(OpenAPI, {
            method: 'DELETE',
            url: '/queue-metrics/{id}',
            path: {
                id: data.id
            },
            errors: {
                401: 'Unauthenticated'
            }
        });
    }
    
    /**
     * Purge all records
     * @returns null No content
     * @throws ApiError
     */
    public static queueMetricsPurge(): CancelablePromise<QueueMetricsPurgeResponse> {
        return __request(OpenAPI, {
            method: 'DELETE',
            url: '/queue-metrics/purge',
            errors: {
                401: 'Unauthenticated'
            }
        });
    }
    
}

export class SongService {
    /**
     * Get a collection of songs
     * @param data The data for the request.
     * @param data.library The library slug
     * @param data.page Current page
     * @param data.limit Items per page
     * @param data.genreNames Comma seperated list of genre names You can only search for names or slugs. Not both.
     * @param data.genreSlugs Comma seperated list of genre slugs
     * @param data.relations Comma seperated string of relations
     * - album
     * - artists
     * - album.albumArtist
     * - genres
     * @returns unknown Json paginated set of `SongResource`
     * @throws ApiError
     */
    public static songsIndex(data: SongsIndexData): CancelablePromise<SongsIndexResponse> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/libraries/{library}/songs',
            path: {
                library: data.library
            },
            query: {
                page: data.page,
                limit: data.limit,
                genreNames: data.genreNames,
                genreSlugs: data.genreSlugs,
                relations: data.relations
            },
            errors: {
                400: 'An error',
                401: 'Unauthenticated',
                403: 'Authorization error',
                404: 'Not found',
                422: 'Validation error'
            }
        });
    }
    
    /**
     * Get a song by public id
     * @param data The data for the request.
     * @param data.library The library slug
     * @param data.publicId
     * @param data.relations Comma seperated string of relations
     * - album
     * - artists
     * - albumArtist
     * - genres
     * @returns SongResource `SongResource`
     * @throws ApiError
     */
    public static songsShow(data: SongsShowData): CancelablePromise<SongsShowResponse> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/libraries/{library}/songs/{publicId}',
            path: {
                library: data.library,
                publicId: data.publicId
            },
            query: {
                relations: data.relations
            },
            errors: {
                401: 'Unauthenticated',
                403: 'Authorization error',
                404: 'Not found',
                422: 'Validation error'
            }
        });
    }
    
    /**
     * Direct stream the song
     * Requires token with "access-stream"
     * @param data The data for the request.
     * @param data.library The library slug
     * @param data.song The song public id
     * @returns unknown
     * @throws ApiError
     */
    public static songsStream(data: SongsStreamData): CancelablePromise<SongsStreamResponse> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/libraries/{library}/songs/stream/song/{song}/direct',
            path: {
                library: data.library,
                song: data.song
            },
            errors: {
                401: 'Unauthenticated',
                404: 'Not found'
            }
        });
    }
    
}

export class SystemInfoService {
    /**
     * Get php info
     * @returns unknown
     * @throws ApiError
     */
    public static systemInfoPhp(): CancelablePromise<SystemInfoPhpResponse> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/system-info',
            errors: {
                401: 'Unauthenticated'
            }
        });
    }
    
    /**
     * @returns unknown
     * @throws ApiError
     */
    public static systemInfoSys(): CancelablePromise<SystemInfoSysResponse> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/system-info/sys',
            errors: {
                401: 'Unauthenticated'
            }
        });
    }
    
}

export class UserService {
    /**
     * Get a collection of users
     * @param data The data for the request.
     * @param data.page Current page
     * @param data.limit Items per page
     * @param data.globalFilter
     * @param data.filters JSON object
     * @param data.filterModes JSON object
     * @param data.sorting JSON object
     * @returns unknown Json paginated set of `UserResource`
     * @throws ApiError
     */
    public static usersIndex(data: UsersIndexData = {}): CancelablePromise<UsersIndexResponse> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/users',
            query: {
                page: data.page,
                limit: data.limit,
                globalFilter: data.globalFilter,
                filters: data.filters,
                filterModes: data.filterModes,
                sorting: data.sorting
            },
            errors: {
                401: 'Unauthenticated',
                403: 'Authorization error',
                422: 'Validation error'
            }
        });
    }
    
    /**
     * Create user
     * This is endpoint allows administrators to create users
     * @param data The data for the request.
     * @param data.requestBody
     * @returns UserResource `UserResource`
     * @throws ApiError
     */
    public static usersStore(data: UsersStoreData = {}): CancelablePromise<UsersStoreResponse> {
        return __request(OpenAPI, {
            method: 'POST',
            url: '/users',
            body: data.requestBody,
            mediaType: 'application/json',
            errors: {
                401: 'Unauthenticated',
                403: 'Authorization error',
                422: 'Validation error'
            }
        });
    }
    
    /**
     * Update a user
     * @param data The data for the request.
     * @param data.user The user ID
     * @param data.requestBody
     * @returns UserResource `UserResource`
     * @throws ApiError
     */
    public static usersUpdate(data: UsersUpdateData): CancelablePromise<UsersUpdateResponse> {
        return __request(OpenAPI, {
            method: 'PATCH',
            url: '/users/{user}',
            path: {
                user: data.user
            },
            body: data.requestBody,
            mediaType: 'application/json',
            errors: {
                401: 'Unauthenticated',
                403: 'Authorization error',
                404: 'Not found',
                422: 'Validation error'
            }
        });
    }
    
    /**
     * Get small user detail info
     * @param data The data for the request.
     * @param data.user The user ID
     * @returns UserResource `UserResource`
     * @throws ApiError
     */
    public static usersShow(data: UsersShowData): CancelablePromise<UsersShowResponse> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/users/{user}',
            path: {
                user: data.user
            },
            errors: {
                401: 'Unauthenticated',
                404: 'Not found'
            }
        });
    }
    
    /**
     * Delete a user
     * @param data The data for the request.
     * @param data.user
     * @returns null No content
     * @throws ApiError
     */
    public static usersDestroy(data: UsersDestroyData): CancelablePromise<UsersDestroyResponse> {
        return __request(OpenAPI, {
            method: 'DELETE',
            url: '/users/{user}',
            path: {
                user: data.user
            },
            errors: {
                401: 'Unauthenticated'
            }
        });
    }
    
    /**
     * Get the authenticated user
     * @returns UserResource `UserResource`
     * @throws ApiError
     */
    public static usersMe(): CancelablePromise<UsersMeResponse> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/users/me',
            errors: {
                401: 'Unauthenticated'
            }
        });
    }
    
}

export class UserTokenService {
    /**
     * Get a collection of tokens
     * @param data The data for the request.
     * @param data.user
     * @param data.page
     * @param data.perPage
     * @returns unknown Json paginated set of `PersonalAccessTokenViewResource`
     * @throws ApiError
     */
    public static userTokenGetUserTokens(data: UserTokenGetUserTokensData): CancelablePromise<UserTokenGetUserTokensResponse> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/users/tokens/{user}',
            path: {
                user: data.user
            },
            query: {
                page: data.page,
                perPage: data.perPage
            },
            errors: {
                401: 'Unauthenticated',
                403: 'Authorization error',
                422: 'Validation error'
            }
        });
    }
    
    /**
     * Revoke a given token
     * @param data The data for the request.
     * @param data.token The token ID
     * @returns null No content
     * @throws ApiError
     */
    public static userTokenRevokeToken(data: UserTokenRevokeTokenData): CancelablePromise<UserTokenRevokeTokenResponse> {
        return __request(OpenAPI, {
            method: 'DELETE',
            url: '/users/tokens/{token}',
            path: {
                token: data.token
            },
            errors: {
                401: 'Unauthenticated',
                404: 'Not found'
            }
        });
    }
    
}