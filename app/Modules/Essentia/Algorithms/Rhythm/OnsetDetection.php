<?php

declare(strict_types=1);

namespace App\Modules\Essentia\Algorithms\Rhythm;

use App\Modules\Essentia\Algorithms\BaseAlgorithm;
use App\Modules\Essentia\Exceptions\AlgorithmException;
use App\Modules\Essentia\Types\AudioVector;

/**
 * OnsetDetection


Inputs:

  [vector_real] spectrum - the input spectrum
  [vector_real] phase - the phase vector corresponding to this spectrum (used only by the "complex" method)


Outputs:

  [real] onsetDetection - the value of the detection function in the current frame


Parameters:

  method:
    string ∈ {hfc,complex,complex_phase,flux,melflux,rms} (default = "hfc")
    the method used for onset detection

  sampleRate:
    real ∈ (0,inf) (default = 44100)
    the sampling rate of the audio signal [Hz]


Description:

  This algorithm computes various onset detection functions. The output of this
  algorithm should be post-processed in order to determine whether the frame
  contains an onset or not. Namely, it could be fed to the Onsets algorithm. It
  is recommended that the input "spectrum" is generated by the Spectrum
  algorithm.
  Four methods are available:
    - 'HFC', the High Frequency Content detection function which accurately
  detects percussive events (see HFC algorithm for details).
    - 'complex', the Complex-Domain spectral difference function [1] taking
  into account changes in magnitude and phase. It emphasizes note onsets either
  as a result of significant change in energy in the magnitude spectrum, and/or
  a deviation from the expected phase values in the phase spectrum, caused by a
  change in pitch.
    - 'complex_phase', the simplified Complex-Domain spectral difference
  function [2] taking into account phase changes, weighted by magnitude.
  TODO:It reacts better on tonal sounds such as bowed string, but tends to
  over-detect percussive events.
    - 'flux', the Spectral Flux detection function which characterizes changes
  in magnitude spectrum. See Flux algorithm for details.
    - 'melflux', the spectral difference function, similar to spectral flux,
  but using half-rectified energy changes in Mel-frequency bands of the
  spectrum [3].
    - 'rms', the difference function, measuring the half-rectified change of
  the RMS of the magnitude spectrum (i.e., measuring overall energy flux) [4].
  
  If using the 'HFC' detection function, make sure to adhere to HFC's input
  requirements when providing an input spectrum. Input vectors of different
  size or empty input spectra will raise exceptions.
  If using the 'complex' detection function, suggested parameters for
  computation of "spectrum" and "phase" are 44100Hz sample rate, frame size of
  1024 and hopSize of 512 samples, which results in a resolution of 11.6ms, and
  a Hann window.
  
  References:
    [1] Bello, Juan P., Chris Duxbury, Mike Davies, and Mark Sandler, On the
    use of phase and energy for musical onset detection in the complex domain,
    Signal Processing Letters, IEEE 11, no. 6 (2004): 553-556.
  
    [2] P. Brossier, J. P. Bello, and M. D. Plumbley, "Fast labelling of notes
    in music signals," in International Symposium on Music Information
    Retrieval (ISMIR’04), 2004, pp. 331–336.
  
    [3] D. P. W. Ellis, "Beat Tracking by Dynamic Programming," Journal of
    New Music Research, vol. 36, no. 1, pp. 51–60, 2007.
  
    [4] J. Laroche, "Efficient Tempo and Beat Tracking in Audio Recordings,"
    JAES, vol. 51, no. 4, pp. 226–233, 2003.
 * 
 * Category: Rhythm
 * Mode: standard
 */
class OnsetDetection extends BaseAlgorithm
{
    protected string $algorithmName = 'OnsetDetection';
    protected string $mode = 'standard';
    protected string $category = 'Rhythm';

    public function compute($input): array
    {
        try {
            // Input validation based on algorithm type
            $this->validateAlgorithmInput($input);
            
            // Convert input to appropriate format
            $processedInput = $this->prepareInput($input);
            
            // Execute the algorithm
            $result = $this->executeAlgorithm($processedInput);
            
            return $this->processOutput($result);
            
        } catch (\Exception $e) {
            throw new AlgorithmException(
                "Failed to compute OnsetDetection: " . $e->getMessage(),
                0,
                $e
            );
        }
    }

    private function validateAlgorithmInput($input): void
    {
        // Category-specific input validation
        switch ($this->category) {
            case 'Spectral':
            case 'Temporal':
                $this->validateInput($input, 'array');
                break;
            case 'Io':
                if (!is_string($input) && !($input instanceof AudioVector)) {
                    throw new AlgorithmException('IO algorithms expect string path or AudioVector');
                }
                break;
            default:
                // Generic validation
                if (!is_array($input) && !($input instanceof AudioVector) && !is_numeric($input)) {
                    throw new AlgorithmException('Unsupported input type for algorithm');
                }
        }
    }

    private function prepareInput($input)
    {
        if ($input instanceof AudioVector) {
            return $input->toCArray($this->essentia->getFFI());
        }
        
        return $input;
    }

    private function executeAlgorithm($input)
    {
        // This would contain the actual FFI calls to Essentia
        // Implementation depends on the specific algorithm
        
        // Placeholder for algorithm execution
        return [];
    }

    private function processOutput($result): array
    {
        // Process and format the output from Essentia
        return is_array($result) ? $result : [$result];
    }
}