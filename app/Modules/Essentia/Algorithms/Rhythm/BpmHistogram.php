<?php

declare(strict_types=1);

namespace App\Modules\Essentia\Algorithms\Rhythm;

use App\Modules\Essentia\Algorithms\BaseAlgorithm;
use App\Modules\Essentia\Exceptions\{AlgorithmException, ConfigurationException};
use App\Modules\Essentia\Types\AudioVector;
use FFI;

/**
 * BpmHistogram


Inputs:

  [vector_real] novelty - the novelty curve


Outputs:

         [real] bpm - mean BPM of the most salient tempo
  [vector_real] bpmCandidates - list of the most salient BPM values
  [vector_real] bpmMagnitudes - magnitudes of the most salient BPM values
  [matrix_real] tempogram - spectrogram-like representation of tempo over time (frames of BPM magnitudes)
  [vector_real] frameBpms - BPM values at each frame
  [vector_real] ticks - time positions of ticks [s]
  [vector_real] ticksMagnitude - ticks' strength (magnitude)
  [vector_real] sinusoid - sinusoid whose peaks indicate tick positions


Parameters:

  bpm:
    real ∈ [0,inf) (default = 0)
    bpm to induce a certain tempo tracking. Zero if unknown

  constantTempo:
    bool ∈ {true,false} (default = false)
    whether to consider constant tempo. Set to true when inducina specific
    tempo

  frameRate:
    real ∈ [1,inf) (default = 86.1328125)
    the sampling rate of the novelty curve [frame/s]

  frameSize:
    real ∈ [1,inf) (default = 4)
    the minimum length to compute the FFT [s]

  maxBpm:
    real ∈ (0,inf) (default = 560)
    the maximum bpm to consider

  maxPeaks:
    integer ∈ (0,inf] (default = 50)
    the number of peaks to be considered at each spectrum

  minBpm:
    real ∈ [0,inf) (default = 30)
    the minimum bpm to consider

  overlap:
    integer ∈ (0,inf) (default = 16)
    the overlap factor

  tempoChange:
    real ∈ [0,inf) (default = 5)
    the minimum length to consider a change in tempo as stable [s]

  weightByMagnitude:
    bool ∈ {true,false} (default = true)
    whether to consider peaks' magnitude when building the histogram

  windowType:
    string (default = "hann")
    the window type to be used when computing the FFT

  zeroPadding:
    integer ∈ [0,inf) (default = 0)
    zero padding factor to compute the FFT [s]


Description:

  This algorithm analyzes predominant periodicities in a signal given its
  novelty curve [1] (see NoveltyCurve algorithm) or another onset detection
  function (see OnsetDetection and OnsetDetectionGlobal). It estimates pulse
  BPM values and time positions together with a half-wave rectified sinusoid
  whose peaks represent the pulses present in the audio signal and their
  magnitudes. The analysis is based on the FFT of the input novelty curve from
  which salient periodicities are detected by thresholding. Temporal evolution
  of these periodicities is output in the "tempogram". Candidate BPMs are then
  detected based on a histogram of the observed periodicities weighted by their
  energy in the tempogram. The sinusoidal model is constructed based on the
  observed periodicities and their magnitudes with the estimated overall BPM as
  a reference.
  
  The algorithm outputs: 
   - bpm: the mean of the most salient BPM values representing periodicities in
  the signal (the mean BPM).
   - bpmCandidates and bpmMagnitudes: list of the most salient BPM values and
  their magnitudes (intensity). These two outputs can be helpful for taking an
  alternative decision on estimation of the overall BPM.
   - tempogram: spectrogram-like representation of the estimated salient
  periodicities and their intensities over time (per-frame BPM magnitudes). It
  is useful for detecting tempo variations and visualization of tempo
  evolution.
   - frameBpms: list of candidate BPM values at each frame. The candidate
  values are similar to the mean BPM. If no candidates are found to be similar,
  the mean value itself is used unless "tempoChange" seconds have triggered a
  variation in tempo.
   - ticks: time positions of ticks in seconds.
   - ticksMagnitude: magnitude of each tick. Higher values correspond to higher
  probability of correctly identified ticks.
   - sinusoid: a sinusoidal model of the ticks' positions. The previous outputs
  are based on detecting peaks of this half-wave rectified sinusoid. This model
  can be used to obtain ticks using alternative peak detection algorithms if
  necessary. Beware that the last few ticks may exceed the length of the audio
  signal due to overlap factors. Therefore, this output should be always
  checked against the length of audio signal.
  
  Note:
   - This algorithm is outdated. For beat tracking it is recommended to use
  RhythmExtractor2013 algorithm found to perform better than NoveltyCurve with
  BpmHistogram in evaluations.
   - The "frameRate" parameter refers to the frame rate at which the novelty
  curve has been computed. It is equal to the audio sampling rate divided by
  the hop size at which the signal was processed.
   - Although the algorithm tries to find beats that fit the mean BPM the best,
  the tempo is not assumed to be constant unless specified in the corresponding
  parameter. For this reason and if tempo differs too much from frame to frame,
  there may be phase discontinuities when constructing the sinusoid which can
  yield to too many ticks. One can recursively run this algorithm on the
  sinusoid output until the ticks stabilize. At this point it may be useful to
  infer a specific BPM and set the constant tempo parameter to true.
   - Another useful trick is to run the algorithm one time to get an estimation
  of the mean BPM and re-run it again with a "frameSize" parameter set to a
  multiple of the mean BPM.
  
  Quality: outdated (use RhythmExtractor2013 instead, still this algorithm
  might be useful when working with other onset detection functions apart from
  NoveltyCurve)
  
  References:
    [1] P. Grosche and M. Müller, "A mid-level representation for capturing
    dominant tempo and pulse information in music recordings," in
    International Society for Music Information Retrieval Conference
    (ISMIR’09), 2009, pp. 189–194.
 * 
 * Category: Rhythm
 * Mode: standard
 */
class BpmHistogram extends BaseAlgorithm
{
    protected string $algorithmName = 'BpmHistogram';
    protected string $mode = 'standard';
    protected string $category = 'Rhythm';
    
    private ?\FFI\CData $algorithmHandle = null;
    private bool $configured = false;

    public function __destruct()
    {
        if ($this->algorithmHandle) {
            $this->cleanupAlgorithm();
        }
    }

    public function compute($input): array
    {
        try {
            // Lazy initialization of the algorithm
            if (!$this->algorithmHandle) {
                $this->initializeAlgorithm();
            }
            
            // Input validation based on algorithm type
            $this->validateAlgorithmInput($input);
            
            // Convert input to appropriate format
            $processedInput = $this->prepareInput($input);
            
            // Execute the algorithm
            $result = $this->executeAlgorithm($processedInput);
            
            return $this->processOutput($result);
            
        } catch (\Exception $e) {
            throw new AlgorithmException(
                "Failed to compute BpmHistogram: " . $e->getMessage(),
                0,
                $e
            );
        }
    }

    private function initializeAlgorithm(): void
    {
        $ffi = $this->essentia->getFFI();
        
        try {
            // Create algorithm instance
            $this->algorithmHandle = $ffi->{$this->getAlgorithmCreateFunction()}();
            
            if (!$this->algorithmHandle) {
                throw new AlgorithmException("Failed to create BpmHistogram algorithm instance");
            }
            
            // Configure algorithm parameters
            $this->configureAlgorithmParameters();
            $this->configured = true;
            
        } catch (\FFI\Exception $e) {
            throw new AlgorithmException("FFI error initializing BpmHistogram: " . $e->getMessage(), 0, $e);
        }
    }

    private function getAlgorithmCreateFunction(): string
    {
        // Convert algorithm name to C function name
        $functionName = 'essentia_create_' . strtolower($this->algorithmName);
        return $functionName;
    }

    private function configureAlgorithmParameters(): void
    {
        if (empty($this->parameters)) {
            return;
        }
        
        $ffi = $this->essentia->getFFI();
        
        foreach ($this->parameters as $key => $value) {
            try {
                $this->setAlgorithmParameter($ffi, $key, $value);
            } catch (\Exception $e) {
                throw new ConfigurationException("Failed to set parameter '$key': " . $e->getMessage(), 0, $e);
            }
        }
    }

    private function setAlgorithmParameter(FFI $ffi, string $key, $value): void
    {
        // Parameter setting logic based on value type
        switch (gettype($value)) {
            case 'integer':
                $ffi->essentia_algorithm_set_int_parameter($this->algorithmHandle, $key, $value);
                break;
            case 'double':
                $ffi->essentia_algorithm_set_real_parameter($this->algorithmHandle, $key, (float) $value);
                break;
            case 'string':
                $ffi->essentia_algorithm_set_string_parameter($this->algorithmHandle, $key, $value);
                break;
            case 'boolean':
                $ffi->essentia_algorithm_set_bool_parameter($this->algorithmHandle, $key, $value);
                break;
            case 'array':
                $this->setArrayParameter($ffi, $key, $value);
                break;
            default:
                throw new ConfigurationException("Unsupported parameter type for '$key': " . gettype($value));
        }
    }

    private function setArrayParameter(FFI $ffi, string $key, array $value): void
    {
        if (empty($value)) {
            return;
        }
        
        $firstElement = reset($value);
        
        if (is_numeric($firstElement)) {
            // Numeric array
            $size = count($value);
            $cArray = $ffi->new("float[$size]");
            
            for ($i = 0; $i < $size; $i++) {
                $cArray[$i] = (float) $value[$i];
            }
            
            $ffi->essentia_algorithm_set_real_vector_parameter($this->algorithmHandle, $key, $cArray, $size);
        } else {
            // String array
            $size = count($value);
            $cArray = $ffi->new("char*[$size]");
            
            for ($i = 0; $i < $size; $i++) {
                $cArray[$i] = $ffi->new("char[" . (strlen($value[$i]) + 1) . "]");
                FFI::memcpy($cArray[$i], $value[$i], strlen($value[$i]));
            }
            
            $ffi->essentia_algorithm_set_string_vector_parameter($this->algorithmHandle, $key, $cArray, $size);
        }
    }

    private function validateAlgorithmInput($input): void
    {
        // Category-specific input validation
        switch ($this->category) {
            case 'Spectral':
            case 'Temporal':
            case 'Tonal':
                if (!is_array($input) && !($input instanceof AudioVector)) {
                    throw new AlgorithmException('Rhythm algorithms expect array or AudioVector input');
                }
                break;
                
            case 'Io':
                if (in_array($this->algorithmName, ['AudioLoader', 'MonoLoader', 'EasyLoader'])) {
                    if (!is_string($input)) {
                        throw new AlgorithmException('Loader algorithms expect string file path');
                    }
                    if (!file_exists($input)) {
                        throw new AlgorithmException("Audio file not found: $input");
                    }
                } elseif (in_array($this->algorithmName, ['AudioWriter', 'MonoWriter'])) {
                    if (!($input instanceof AudioVector) && !is_array($input)) {
                        throw new AlgorithmException('Writer algorithms expect AudioVector or array input');
                    }
                }
                break;
                
            case 'Rhythm':
                $this->validateInput($input, 'array');
                break;
                
            case 'Filters':
                $this->validateInput($input, 'array');
                break;
                
            case 'MachineLearning':
                // ML algorithms may have different input requirements
                if (!is_array($input) && !($input instanceof AudioVector)) {
                    throw new AlgorithmException('ML algorithms expect array or AudioVector input');
                }
                break;
                
            case 'Standard':
                // Most flexible category
                if (!is_array($input) && !($input instanceof AudioVector) && !is_numeric($input) && !is_string($input)) {
                    throw new AlgorithmException('Unsupported input type');
                }
                break;
                
            default:
                // Generic validation
                if (!is_array($input) && !($input instanceof AudioVector) && !is_numeric($input)) {
                    throw new AlgorithmException('Unsupported input type for algorithm');
                }
        }
    }

    private function prepareInput($input)
    {
        if ($input instanceof AudioVector) {
            return $input->toCArray($this->essentia->getFFI());
        }
        
        if (is_array($input)) {
            $ffi = $this->essentia->getFFI();
            $size = count($input);
            $cArray = $ffi->new("float[$size]");
            
            for ($i = 0; $i < $size; $i++) {
                $cArray[$i] = (float) $input[$i];
            }
            
            return $cArray;
        }
        
        return $input;
    }

    private function executeAlgorithm($input): array
    {
        $ffi = $this->essentia->getFFI();
        
        try {
            // Algorithm-specific execution logic
            return $this->executeSpecificAlgorithm($ffi, $input);
            
        } catch (\FFI\Exception $e) {
            throw new AlgorithmException("FFI execution error: " . $e->getMessage(), 0, $e);
        }
    }

    private function executeSpecificAlgorithm(FFI $ffi, $input): array
    {
        // This method contains algorithm-specific execution logic
        $outputs = [];
        
        switch ($this->algorithmName) {

            
            default:
                // Generic execution for unknown algorithms
                $outputs = $this->executeGenericAlgorithm($ffi, $input);
        }
        
        return $outputs;
    }

    private function executeGenericAlgorithm(FFI $ffi, $input): array
    {
        // Generic algorithm execution - assumes single input/output
        try {
            // Prepare output buffers
            $outputSize = $this->estimateOutputSize($input);
            $output = $ffi->new("float[$outputSize]");
            $actualSize = $ffi->new("int");
            
            // Execute algorithm
            $result = $ffi->essentia_algorithm_compute($this->algorithmHandle, $input, $output, $actualSize);
            
            if ($result != 0) {
                throw new AlgorithmException("Algorithm execution failed with code: $result");
            }
            
            // Convert output to PHP array
            $phpOutput = [];
            for ($i = 0; $i < $actualSize->cdata; $i++) {
                $phpOutput[] = $output[$i];
            }
            
            return $phpOutput;
            
        } catch (\Exception $e) {
            throw new AlgorithmException("Generic execution failed: " . $e->getMessage(), 0, $e);
        }
    }

    private function estimateOutputSize($input): int
    {
        // Estimate output size based on algorithm category and input
        switch ($this->category) {
            case 'Spectral':
                // Spectral algorithms often output half the input size (FFT)
                return is_array($input) ? count($input) / 2 : 1024;
                
            case 'Temporal':
            case 'Tonal':
                // Temporal/tonal algorithms often output similar or smaller size
                return is_array($input) ? count($input) : 1024;
                
            case 'Stats':
                // Statistical algorithms often output small fixed sizes
                return 16;
                
            case 'Rhythm':
                // Rhythm algorithms vary widely
                return 256;
                
            default:
                // Conservative default
                return is_array($input) ? count($input) : 1024;
        }
    }

    private function processOutput(array $result): array
    {
        // Post-process the output based on algorithm characteristics
        switch ($this->category) {
            case 'Spectral':
                return $this->processSpectralOutput($result);
                
            case 'Temporal':
                return $this->processTemporalOutput($result);
                
            case 'Tonal':
                return $this->processTonalOutput($result);
                
            case 'Rhythm':
                return $this->processRhythmOutput($result);
                
            case 'Stats':
                return $this->processStatsOutput($result);
                
            default:
                // Return as-is for unknown categories
                return $result;
        }
    }

    private function processSpectralOutput(array $result): array
    {
        // Process spectral algorithm outputs
        switch ($this->algorithmName) {
            case 'SpectralCentroid':
            case 'SpectralRolloff':
                return ['value' => $result[0] ?? 0.0];
                
            case 'MFCC':
                return ['coefficients' => $result];
                
            case 'MelBands':
            case 'BarkBands':
                return ['bands' => $result];
                
            case 'SpectralPeaks':
                // Usually returns frequencies and magnitudes
                $half = count($result) / 2;
                return [
                    'frequencies' => array_slice($result, 0, $half),
                    'magnitudes' => array_slice($result, $half)
                ];
                
            default:
                return ['spectrum' => $result];
        }
    }

    private function processTemporalOutput(array $result): array
    {
        switch ($this->algorithmName) {
            case 'Energy':
            case 'RMS':
            case 'ZeroCrossingRate':
                return ['value' => $result[0] ?? 0.0];
                
            case 'Envelope':
                return ['envelope' => $result];
                
            default:
                return ['values' => $result];
        }
    }

    private function processTonalOutput(array $result): array
    {
        switch ($this->algorithmName) {
            case 'PitchYin':
            case 'PitchYinFFT':
                return [
                    'pitch' => $result[0] ?? 0.0,
                    'confidence' => $result[1] ?? 0.0
                ];
                
            case 'Key':
                return [
                    'key' => $result[0] ?? 'C',
                    'scale' => $result[1] ?? 'major',
                    'strength' => $result[2] ?? 0.0
                ];
                
            case 'HPCP':
            case 'Chromagram':
                return ['chroma' => $result];
                
            default:
                return ['tonal_features' => $result];
        }
    }

    private function processRhythmOutput(array $result): array
    {
        switch ($this->algorithmName) {
            case 'RhythmExtractor':
                return [
                    'bpm' => $result[0] ?? 0.0,
                    'beats' => array_slice($result, 1) ?? []
                ];
                
            case 'OnsetDetection':
                return ['onsets' => $result];
                
            case 'TempoTap':
                return ['tempo' => $result[0] ?? 0.0];
                
            default:
                return ['rhythm_features' => $result];
        }
    }

    private function processStatsOutput(array $result): array
    {
        switch ($this->algorithmName) {
            case 'Mean':
            case 'Variance':
            case 'Centroid':
                return ['value' => $result[0] ?? 0.0];
                
            case 'DistributionShape':
                return [
                    'spread' => $result[0] ?? 0.0,
                    'skewness' => $result[1] ?? 0.0,
                    'kurtosis' => $result[2] ?? 0.0
                ];
                
            default:
                return ['statistics' => $result];
        }
    }

    private function cleanupAlgorithm(): void
    {
        if ($this->algorithmHandle) {
            try {
                $ffi = $this->essentia->getFFI();
                $ffi->essentia_delete_algorithm($this->algorithmHandle);
            } catch (\Exception $e) {
                // Ignore cleanup errors
            }
            $this->algorithmHandle = null;
        }
    }

    protected function isValidParameter(string $parameter): bool
    {
        // Algorithm-specific parameter validation
        $validParams = $this->getValidParameters();
        return empty($validParams) || in_array($parameter, $validParams);
    }

    private function getValidParameters(): array
    {
        // Return algorithm-specific valid parameters
        return [];
    }
}